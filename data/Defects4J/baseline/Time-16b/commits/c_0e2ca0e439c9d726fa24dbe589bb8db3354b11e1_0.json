{"sha": "0e2ca0e439c9d726fa24dbe589bb8db3354b11e1", "log": "Change TimePeriod to Period   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.format.ISOTimePeriodFormat;\n+import org.joda.time.format.ISOPeriodFormat;\n \n /**\n  * AbstractDuration provides the common behaviour for duration classes.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a TimePeriod instance using the All type.\n+     * Converts this duration to a Period instance using the All type.\n      * <p>\n      * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * For more control over the conversion process, you should convert the duration\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n-     * @return a TimePeriod created using the millisecond duration from this instance\n-     */\n-    public final TimePeriod toTimePeriod() {\n-        return new TimePeriod(this, PeriodType.getAllType());\n-    }\n-\n-    /**\n-     * Converts this duration to a TimePeriod instance specifying a period type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public final Period toPeriod() {\n+        return new Period(this, PeriodType.getAllType());\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance specifying a period type\n      * to control how the duration is split into fields.\n      * <p>\n      * The exact impact of this method is determined by the period type.\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param type  the period type determining how to split the duration into fields\n-     * @return a TimePeriod created using the millisecond duration from this instance\n-     */\n-    public final TimePeriod toTimePeriod(PeriodType type) {\n-        return new TimePeriod(this, type);\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public final Period toPeriod(PeriodType type) {\n+        return new Period(this, type);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the value as an ISO8601 string\n      */\n     public String toString() {\n-        return ISOTimePeriodFormat.getInstance().standard().print(toTimePeriod());\n+        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n      */\n     public AbstractInterval(Object interval) {\n         super();\n-        TimePeriod duration;\n+        Period duration;\n         if (interval instanceof AbstractInterval) {\n             AbstractInterval ri = (AbstractInterval) interval;\n             iStartMillis = ri.iStartMillis;\n      * @param period  the period of this interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    public AbstractInterval(ReadableInstant start, ReadableTimePeriod period) {\n+    public AbstractInterval(ReadableInstant start, ReadablePeriod period) {\n         super();\n         Chronology chrono = null;\n         if (start == null) {\n      * @param end  end of this interval, null means now\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    public AbstractInterval(ReadableTimePeriod period, ReadableInstant end) {\n+    public AbstractInterval(ReadablePeriod period, ReadableInstant end) {\n         super();\n         Chronology chrono = null;\n         if (end == null) {\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public final TimePeriod toTimePeriod() {\n-        return new TimePeriod(getStartMillis(), getEndMillis());\n+    public final Period toPeriod() {\n+        return new Period(getStartMillis(), getEndMillis());\n     }\n \n     /**\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public final TimePeriod toTimePeriod(PeriodType type) {\n-        return new TimePeriod(getStartMillis(), getEndMillis(), type);\n+    public final Period toPeriod(PeriodType type) {\n+        return new Period(getStartMillis(), getEndMillis(), type);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    protected void setTimePeriodAfterStart(ReadableTimePeriod period) {\n+    protected void setPeriodAfterStart(ReadablePeriod period) {\n         if (period == null) {\n             setEndMillis(getStartMillis());\n         } else {\n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    protected void setTimePeriodBeforeEnd(ReadableTimePeriod period) {\n+    protected void setPeriodBeforeEnd(ReadablePeriod period) {\n         if (period == null) {\n             setStartMillis(getEndMillis());\n         } else {\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractPeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PeriodConverter;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+    /** Millis cache is currently unknown */\n+    private static final int STATE_UNKNOWN = 0;\n+    /** Millis cache is not calculable */\n+    private static final int STATE_NOT_CALCULABLE = 1;\n+    /** Millis cache has been calculated and is valid */\n+    private static final int STATE_CALCULATED = 2;\n+\n+    /** The period type that allocates the duration to fields */\n+    private final PeriodType iType;\n+    /** The object state */\n+    private int iState;\n+    /** The duration, if known */\n+    private long iDuration;\n+    /** Value for years */\n+    private int iYears;\n+    /** Value for months */\n+    private int iMonths;\n+    /** Value for weeks */\n+    private int iWeeks;\n+    /** Value for days */\n+    private int iDays;\n+    /** Value for hours */\n+    private int iHours;\n+    /** Value for minutes */\n+    private int iMinutes;\n+    /** Value for seconds */\n+    private int iSeconds;\n+    /** Value for millis */\n+    private int iMillis;\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the period type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    public AbstractPeriod(long duration, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, duration);\n+    }\n+\n+    /**\n+     * Creates a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractPeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    public AbstractPeriod(long startInstant, long endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    public AbstractPeriod(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n+            // Only call a private method\n+            setPeriod(type, start, end);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new period based on another using the {@link ConverterManager}.\n+     *\n+     * @param period  the period to convert\n+     * @param type  which set of fields this period supports, null means use type from object\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractPeriod(Object period, PeriodType type) {\n+        super();\n+        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n+        type = (type == null ? converter.getPeriodType(period, false) : type);\n+        type = checkPeriodType(type);\n+        iType = type;\n+        if (this instanceof ReadWritablePeriod) {\n+            converter.setInto((ReadWritablePeriod) this, period);\n+        } else {\n+            // Only call a private method\n+            setPeriod(type, new MutablePeriod(period, type));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is invalid\n+     */\n+    protected abstract PeriodType checkPeriodType(PeriodType type);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the object which defines which fields this period supports.\n+     */\n+    public final PeriodType getPeriodType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A typical precise period could include millis, seconds, minutes or hours,\n+     * but days, weeks, months and years usually vary in length, resulting in\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the period is precise\n+     */\n+    public final boolean isPrecise() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        return (state == STATE_CALCULATED);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this period to the given instant using the chronology of the period\n+     * which typically ignores time zones.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar) {\n+        return addTo(instant, scalar, null);\n+    }\n+\n+    /**\n+     * Adds this period to the given instant using a specific chronology.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @param chrono  override the period's chronology, unless null is passed in\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar, Chronology chrono) {\n+        if (isPrecise()) {\n+            return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n+        }\n+        \n+        PeriodType type = iType;\n+        if (chrono != null) {\n+            type = type.withChronology(chrono);\n+        }\n+        \n+        long value; // used to lock fields against threading issues\n+        value = scaleValue(iYears, scalar);\n+        if (value != 0) {\n+            instant = type.years().add(instant, value);\n+        }\n+        value = scaleValue(iMonths, scalar);\n+        if (value != 0) {\n+            instant = type.months().add(instant, value);\n+        }\n+        value = scaleValue(iWeeks, scalar);\n+        if (value != 0) {\n+            instant = type.weeks().add(instant, value);\n+        }\n+        value = scaleValue(iDays, scalar);\n+        if (value != 0) {\n+            instant = type.days().add(instant, value);\n+        }\n+        value = scaleValue(iHours, scalar);\n+        if (value != 0) {\n+            instant = type.hours().add(instant, value);\n+        }\n+        value = scaleValue(iMinutes, scalar);\n+        if (value != 0) {\n+            instant = type.minutes().add(instant, value);\n+        }\n+        value = scaleValue(iSeconds, scalar);\n+        if (value != 0) {\n+            instant = type.seconds().add(instant, value);\n+        }\n+        value = scaleValue(iMillis, scalar);\n+        if (value != 0) {\n+            instant = type.millis().add(instant, value);\n+        }\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * Convert the scalar to a multiple efficiently.\n+     * \n+     * @param value  the value\n+     * @param scalar  the scalar\n+     * @return the converted value\n+     */\n+    private static long scaleValue(int value, int scalar) {\n+        long val = value;  // use long to avoid truncation\n+        switch (scalar) {\n+        case -1:\n+            return -val;\n+        case 0:\n+            return 0;\n+        case 1:\n+            return val;\n+        default:\n+            return val * scalar;\n+        }\n+    }\n+\n+    /**\n+     * Adds this period to the given instant using the chronology of the specified\n+     * instant (if present), returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the period to, null means now\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return instant with the original value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final Instant addTo(ReadableInstant instant, int scalar) {\n+        if (instant == null) {\n+            return new Instant(addTo(DateTimeUtils.currentTimeMillis(), scalar));\n+        }\n+        return new Instant(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+    }\n+\n+    /**\n+     * Adds this period into the given mutable instant using the chronology of\n+     * the specified mutable instant (if present).\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added period, must not be null\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final void addInto(ReadWritableInstant instant, int scalar) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        instant.setMillis(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public final int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public final int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public final int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public final int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public final int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public final int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public final int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public final int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an immutable Period. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    public final Period toPeriod() {\n+        if (this instanceof Period) {\n+            return (Period) this;\n+        }\n+        return new Period(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutablePeriod.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    public final MutablePeriod toMutablePeriod() {\n+        return new MutablePeriod(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final long toDurationMillis() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != STATE_CALCULATED) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iDuration;\n+    }\n+\n+    /**\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final Duration toDuration() {\n+        return new Duration(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadablePeriod instances are accepted.\n+     * <p>\n+     * To compare two periods for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     *\n+     * @param readablePeriod  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public final boolean equals(Object readablePeriod) {\n+        if (this == readablePeriod) {\n+            return true;\n+        }\n+        if (readablePeriod instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) readablePeriod;\n+        PeriodType type = getPeriodType();\n+        if (type.equals(other.getPeriodType()) == false) {\n+            return false;\n+        }\n+        return getYears() == other.getYears()\n+            && getMonths() == other.getMonths()\n+            && getWeeks() == other.getWeeks()\n+            && getDays() == other.getDays()\n+            && getHours() == other.getHours()\n+            && getMinutes() == other.getMinutes()\n+            && getSeconds() == other.getSeconds()\n+            && getMillis() == other.getMillis();\n+    }\n+\n+    /**\n+     * Gets a hash code for the period that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public final int hashCode() {\n+        int hash = getPeriodType().hashCode();\n+        hash = 53 * hash + getYears();\n+        hash = 53 * hash + getMonths();\n+        hash = 53 * hash + getWeeks();\n+        hash = 53 * hash + getDays();\n+        hash = 53 * hash + getHours();\n+        hash = 53 * hash + getMinutes();\n+        hash = 53 * hash + getSeconds();\n+        hash = 53 * hash + getMillis();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return ISOPeriodFormat.getInstance().standard().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkSupport(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(ReadablePeriod period) {\n+        if (period == null) {\n+            setPeriod(iType, 0L);\n+        } else {\n+            setPeriod(iType, period);\n+        }\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type, ReadablePeriod period) {\n+        setPeriod(type,\n+            period.getYears(), period.getMonths(),\n+            period.getWeeks(), period.getDays(),\n+            period.getHours(), period.getMinutes(),\n+            period.getSeconds(), period.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(int years, int months, int weeks, int days,\n+                               int hours, int minutes, int seconds, int millis) {\n+        setPeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type,\n+                             int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+        if (years != 0) {\n+            checkArgument(type.years());\n+        }\n+        if (months != 0) {\n+            checkArgument(type.months());\n+        }\n+        if (weeks != 0) {\n+            checkArgument(type.weeks());\n+        }\n+        if (days != 0) {\n+            checkArgument(type.days());\n+        }\n+        if (hours != 0) {\n+            checkArgument(type.hours());\n+        }\n+        if (minutes != 0) {\n+            checkArgument(type.minutes());\n+        }\n+        if (seconds != 0) {\n+            checkArgument(type.seconds());\n+        }\n+        if (millis != 0) {\n+            checkArgument(type.millis());\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    protected void setPeriod(long startInstant, long endInstant) {\n+        setPeriod(iType, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long startInstant, long endInstant) {\n+        long baseTotalMillis = (endInstant - startInstant);\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        field = type.years();\n+        if (field.isSupported()) {\n+            years = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported()) {\n+            months = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported()) {\n+            weeks = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported()) {\n+            days = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported()) {\n+            hours = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported()) {\n+            minutes = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported()) {\n+            seconds = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported()) {\n+            millis = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    protected void setPeriod(long duration) {\n+        setPeriod(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long duration) {\n+        if (duration == 0) {\n+            iDuration = duration;\n+            iYears = 0;\n+            iMonths = 0;\n+            iWeeks = 0;\n+            iDays = 0;\n+            iHours = 0;\n+            iMinutes = 0;\n+            iSeconds = 0;\n+            iMillis = 0;\n+            iState = STATE_CALCULATED;\n+            return;\n+        }\n+        \n+        type = type.withChronology(type.getChronology().withUTC());\n+        long startInstant = 0;\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        \n+        field = type.years();\n+        if (field.isSupported() && field.isPrecise()) {\n+            years = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported() && field.isPrecise()) {\n+            months = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported() && field.isPrecise()) {\n+            weeks = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported() && field.isPrecise()) {\n+            days = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported() && field.isPrecise()) {\n+            hours = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported() && field.isPrecise()) {\n+            minutes = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported() && field.isPrecise()) {\n+            seconds = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported() && field.isPrecise()) {\n+            millis = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    protected void setPeriod(ReadableInterval interval) {\n+        if (interval != null) {\n+            setPeriod(interval.getStartMillis(), interval.getEndMillis());\n+        } else {\n+            setPeriod(0L);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    protected void setPeriod(ReadableDuration duration) {\n+        if (duration != null) {\n+            setPeriod(duration.getMillis());\n+        } else {\n+            setPeriod(0L);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this period is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the period\n+     */\n+    private int updateTotalMillis() {\n+        final PeriodType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n+        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n+        if (years != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            }\n+        }\n+        if (months != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            }\n+        }\n+        if (weeks != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n+            }\n+        }\n+        if (days != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n+            }\n+        }\n+        if (hours != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n+            }\n+        }\n+        if (minutes != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n+            }\n+        }\n+        if (seconds != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n+            }\n+        }\n+        if (millis != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n+            }\n+        }\n+        \n+        iDuration = totalMillis;\n+        if (isPrecise) {\n+            return iState = STATE_CALCULATED;\n+        } else {\n+            return iState = STATE_NOT_CALCULABLE;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadablePeriod period) {\n+        if (period != null) {\n+            setPeriod(\n+                FieldUtils.safeAdd(getYears(), period.getYears()),\n+                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n+                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n+                FieldUtils.safeAdd(getDays(), period.getDays()),\n+                FieldUtils.safeAdd(getHours(), period.getHours()),\n+                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n+                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n+                FieldUtils.safeAdd(getMillis(), period.getMillis())\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis) {\n+        setPeriod(\n+            FieldUtils.safeAdd(getYears(), years),\n+            FieldUtils.safeAdd(getMonths(), months),\n+            FieldUtils.safeAdd(getWeeks(), weeks),\n+            FieldUtils.safeAdd(getDays(), days),\n+            FieldUtils.safeAdd(getHours(), hours),\n+            FieldUtils.safeAdd(getMinutes(), minutes),\n+            FieldUtils.safeAdd(getSeconds(), seconds),\n+            FieldUtils.safeAdd(getMillis(), millis)\n+        );\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableInterval interval) {\n+        if (interval != null) {\n+            add(interval.toPeriod(getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableDuration duration) {\n+        if (duration != null) {\n+            add(new Period(duration.getMillis(), getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(long duration) {\n+        add(new Period(duration, getPeriodType()));\n+    }\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    protected void normalize() {\n+        setPeriod(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setYears(int years) {\n+        if (years != iYears) {\n+            if (years != 0) {\n+                checkSupport(iType.years());\n+            }\n+            iYears = years;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addYears(int years) {\n+        if (years != 0) {\n+            setYears(FieldUtils.safeAdd(getYears(), years));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMonths(int months) {\n+        if (months != iMonths) {\n+            if (months != 0) {\n+                checkSupport(iType.months());\n+            }\n+            iMonths = months;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMonths(int months) {\n+        if (months != 0) {\n+            setMonths(FieldUtils.safeAdd(getMonths(), months));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setWeeks(int weeks) {\n+        if (weeks != iWeeks) {\n+            if (weeks != 0) {\n+                checkSupport(iType.weeks());\n+            }\n+            iWeeks = weeks;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addWeeks(int weeks) {\n+        if (weeks != 0) {\n+            setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setDays(int days) {\n+        if (days != iDays) {\n+            if (days != 0) {\n+                checkSupport(iType.days());\n+            }\n+            iDays = days;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addDays(int days) {\n+        if (days != 0) {\n+            setDays(FieldUtils.safeAdd(getDays(), days));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setHours(int hours) {\n+        if (hours != iHours) {\n+            if (hours != 0) {\n+                checkSupport(iType.hours());\n+            }\n+            iHours = hours;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addHours(int hours) {\n+        if (hours != 0) {\n+            setHours(FieldUtils.safeAdd(getHours(), hours));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMinutes(int minutes) {\n+        if (minutes != iMinutes) {\n+            if (minutes != 0) {\n+                checkSupport(iType.minutes());\n+            }\n+            iMinutes = minutes;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMinutes(int minutes) {\n+        if (minutes != 0) {\n+            setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setSeconds(int seconds) {\n+        if (seconds != iSeconds) {\n+            if (seconds != 0) {\n+                checkSupport(iType.seconds());\n+            }\n+            iSeconds = seconds;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addSeconds(int seconds) {\n+        if (seconds != 0) {\n+            setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMillis(int millis) {\n+        if (millis != iMillis) {\n+            if (millis != 0) {\n+                checkSupport(iType.millis());\n+            }\n+            iMillis = millis;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMillis(int millis) {\n+        if (millis != 0) {\n+            setMillis(FieldUtils.safeAdd(getMillis(), millis));\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n  * <p>\n  * A duration is defined by a fixed number of milliseconds.\n  * There is no concept of fields, such as days or seconds, as these fields can vary in length.\n- * A duration may be converted to a {@link TimePeriod} to obtain field values.\n+ * A duration may be converted to a {@link Period} to obtain field values.\n  * This conversion will typically cause a loss of precision however.\n  * <p>\n  * Duration is thread-safe and immutable.\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n      * @param period  the period of this interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    public Interval(ReadableInstant start, ReadableTimePeriod period) {\n+    public Interval(ReadableInstant start, ReadablePeriod period) {\n         super(start, period);\n     }\n \n      * @param end  end of this interval, null means now\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    public Interval(ReadableTimePeriod period, ReadableInstant end) {\n+    public Interval(ReadablePeriod period, ReadableInstant end) {\n         super(period, end);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/JodaTimePermission.java\n+++ b/JodaTime/src/java/org/joda/time/JodaTimePermission.java\n  * ConverterManager\n  *   .alterInstantConverters     Allows an instant converter to be added or removed\n  *   .alterDurationConverters    Allows a duration converter to be added or removed\n- *   .alterTimePeriodConverters  Allows a time period converter to be added or removed\n+ *   .alterPeriodConverters      Allows a period converter to be added or removed\n  *   .alterIntervalConverters    Allows an interval converter to be added or removed\n  *\n  * CurrentTime.setProvider       Allows the current time provider to be set\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n         if (duration instanceof ReadableDuration) {\n             ReadableDuration d = (ReadableDuration) duration;\n             add(FieldUtils.safeMultiply(d.getMillis(), scalar));\n-        } else if (duration instanceof ReadableTimePeriod) {\n-            ReadableTimePeriod d = (ReadableTimePeriod) duration;\n+        } else if (duration instanceof ReadablePeriod) {\n+            ReadablePeriod d = (ReadablePeriod) duration;\n             d.addInto(this, scalar);\n         } else {\n             DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n      * @param period  the period of this interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    public MutableInterval(ReadableInstant start, ReadableTimePeriod period) {\n+    public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n         super(start, period);\n     }\n \n      * @param end  end of this interval, null means now\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    public MutableInterval(ReadableTimePeriod period, ReadableInstant end) {\n+    public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n         super(period, end);\n     }\n \n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    public void setTimePeriodAfterStart(ReadableTimePeriod period) {\n-        super.setTimePeriodAfterStart(period);\n+    public void setPeriodAfterStart(ReadablePeriod period) {\n+        super.setPeriodAfterStart(period);\n     }\n \n     /**\n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    public void setTimePeriodBeforeEnd(ReadableTimePeriod period) {\n-        super.setTimePeriodBeforeEnd(period);\n+    public void setPeriodBeforeEnd(ReadablePeriod period) {\n+        super.setPeriodBeforeEnd(period);\n     }\n \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Standard mutable time period implementation.\n+ * <p>\n+ * MutablePeriod is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see Period\n+ */\n+public class MutablePeriod\n+        extends AbstractPeriod\n+        implements ReadWritablePeriod, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3436451121567212165L;\n+\n+    /**\n+     * Creates a zero-length period using AllType.\n+     */\n+    public MutablePeriod() {\n+        super(0L, null);\n+    }\n+\n+    /**\n+     * Creates a zero-length period using the specified period type.\n+     *\n+     * @param type  which set of fields this period supports\n+     */\n+    public MutablePeriod(PeriodType type) {\n+        super(0L, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using AllType.\n+     * <p>\n+     * The exact impact of this constructor is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MutablePeriod(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The exact impact of this constructor is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     */\n+    public MutablePeriod(long duration, PeriodType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutablePeriod(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutablePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public MutablePeriod(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period) {\n+        super(period, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, PeriodType type) {\n+        super(period, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is not precise\n+     */\n+    protected PeriodType checkPeriodType(PeriodType type) {\n+        if (type == null) {\n+            return PeriodType.getAllType();\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setPeriod(ReadablePeriod period) {\n+        super.setPeriod(period);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setPeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis) {\n+        super.setPeriod(years, months, weeks, days,\n+                          hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    public void setPeriod(ReadableInterval interval) {\n+        super.setPeriod(interval);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public void setPeriod(long startInstant, long endInstant) {\n+        super.setPeriod(startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    public void setPeriod(ReadableDuration duration) {\n+        super.setPeriod(duration);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    public void setPeriod(long duration) {\n+        super.setPeriod(duration);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadablePeriod period) {\n+        super.add(period);\n+    }\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super.add(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Adds an interval to this one by converting it to a period using the same\n+     * period type and then adding each field in turn.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableInterval interval) {\n+        super.add(interval);\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableDuration duration) {\n+        super.add(duration);\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to add\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(long duration) {\n+        super.add(duration);\n+    }\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    public void normalize() {\n+        super.normalize();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setYears(int years) {\n+        super.setYears(years);\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addYears(int years) {\n+        super.addYears(years);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMonths(int months) {\n+        super.setMonths(months);\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMonths(int months) {\n+        super.addMonths(months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setWeeks(int weeks) {\n+        super.setWeeks(weeks);\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addWeeks(int weeks) {\n+        super.addWeeks(weeks);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setDays(int days) {\n+        super.setDays(days);\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addDays(int days) {\n+        super.addDays(days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setHours(int hours) {\n+        super.setHours(hours);\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addHours(int hours) {\n+        super.addHours(hours);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMinutes(int minutes) {\n+        super.setMinutes(minutes);\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMinutes(int minutes) {\n+        super.addMinutes(minutes);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setSeconds(int seconds) {\n+        super.setSeconds(seconds);\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addSeconds(int seconds) {\n+        super.addSeconds(seconds);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    public void setMillis(int millis) {\n+        super.setMillis(millis);\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMillis(int millis) {\n+        super.addMillis(millis);\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutablePeriod copy() {\n+        return (MutablePeriod)clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An immutable time period specifying a set of duration field values.\n+ * <p>\n+ * A time period is divided into a number of fields, such as hours and seconds.\n+ * The way in which that divide occurs is controlled by the PeriodType class.\n+ * <p>\n+ * <code>Period</code> can use any period type to split the milliseconds into fields.\n+ * The {@link PeriodType#getAllType() All} type is used by default.\n+ * <code>All</code> uses the ISO chronology and divides a duration into years, months,\n+ * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n+ * <p>\n+ * This class performs calculations using the individual fields.\n+ * It <i>may</i> be possible to convert a <code>Period</code> to a <code>Duration</code>.\n+ * The conversion will succeed if the time period is precise.\n+ * A time period is precise if all of the populated fields have a fixed known duration.\n+ * <p>\n+ * When this time period is added to an instant, the effect is of adding each field in turn.\n+ * As a result, this takes into account daylight savings time.\n+ * Adding a time period of 1 day to the day before daylight savings starts will only add\n+ * 23 hours rather than 24 to ensure that the time remains the same.\n+ * If this is not the behaviour you want, then see {@link Duration}.\n+ * <p>\n+ * Period is thread-safe and immutable, provided that the PeriodType is as well.\n+ * All standard PeriodType classes supplied are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see MutablePeriod\n+ */\n+public class Period\n+        extends AbstractPeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 741052353876488155L;\n+\n+    /**\n+     * Creates a period from the given millisecond duration using AllType.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the period type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the period type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public Period(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the period type. This ensures that there are no odd effects caused by\n+     * time zones. The add methods will still use the time zone specific version\n+     * of the period type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports\n+     */\n+    public Period(long duration, PeriodType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public Period(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using AllType.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public Period(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public Period(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public Period(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public Period(long startInstant, long endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using AllType.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * This constructor creates a precise period.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period) {\n+        super(period, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, PeriodType type) {\n+        super(period, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is not precise\n+     */\n+    protected final PeriodType checkPeriodType(PeriodType type) {\n+        if (type == null) {\n+            return PeriodType.getAllType();\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Period instance with the same field values but\n+     * different PeriodType.\n+     * \n+     * @param type  the period type to use, null means AllType\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n+     */\n+    public final Period withPeriodType(PeriodType type) {\n+        if (type == null) {\n+            type = PeriodType.getAllType();\n+        }\n+        if (type.equals(getPeriodType())) {\n+            return this;\n+        }\n+        return new Period(getYears(), getMonths(), getWeeks(), getDays(),\n+                    getHours(), getMinutes(), getSeconds(), getMillis(), type);\n+    }\n+\n+    /**\n+     * Creates a new Period instance with the same millisecond duration but\n+     * different PeriodType.\n+     * \n+     * @param type  the period type to use, null means AllType\n+     * @return the new period instance\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    public final Period withPeriodTypeRetainDuration(PeriodType type) {\n+        if (type == null) {\n+            type = PeriodType.getAllType();\n+        }\n+        if (type.equals(getPeriodType())) {\n+            return this;\n+        }\n+        return new Period(toDurationMillis(), type);\n+    }\n+\n+    /**\n+     * Creates a new Period instance with the same millisecond duration but\n+     * all the fields normalized to be within their standard ranges.\n+     * \n+     * @return the new period instance\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    public final Period withFieldsNormalized() {\n+        return new Period(toDurationMillis(), getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setPeriod(ReadablePeriod period) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setPeriod(int years, int months, int weeks, int days,\n+                                       int hours, int minutes, int seconds, int millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setPeriod(long startInstant, long endInstant) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setPeriod(long duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setYears(int years) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMonths(int months) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setWeeks(int weeks) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setDays(int days) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setHours(int hours) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMinutes(int minutes) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setSeconds(int seconds) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMillis(int millis) {\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    void setTimePeriodAfterStart(ReadableTimePeriod period);\n+    void setPeriodAfterStart(ReadablePeriod period);\n \n     /**\n      * Sets the period of this time interval, preserving the end instant.\n      * @param period  new period for interval, null means zero length\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    void setTimePeriodBeforeEnd(ReadableTimePeriod period);\n+    void setPeriodBeforeEnd(ReadablePeriod period);\n \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a duration of time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritablePeriod extends ReadablePeriod {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setPeriod(ReadablePeriod period);\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setPeriod(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    void setPeriod(ReadableInterval interval);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    void setPeriod(long startInstant, long endInstant);\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    void setPeriod(ReadableDuration duration);\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     */\n+    void setPeriod(long duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadablePeriod period);\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableInterval interval);\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableDuration duration);\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and then adding each field in turn.\n+     * <p>\n+     * The exact impact of this method is determined by the period type.\n+     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly. The situation is more complex\n+     * for larger durations.\n+     * <p>\n+     * If this period uses the PreciseAll period type then all fields can be set.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 1 year, 2 months and 5 days using the PreciseAll type.\n+     * <p>\n+     * If the period uses the All period type then the years and months fields\n+     * will remain as zero, with the duration allocated to the weeks field.\n+     * Normally, the weeks and days fields are imprecise, but this method\n+     * calculates using the UTC time zone making weeks and days precise.\n+     * The effect is that a large duration of several years or months will be converted\n+     * to a period including a large number of weeks and zero years and months.\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * 61 weeks and 3 days.\n+     * <p>\n+     * For more control over the conversion process, you should convert the duration\n+     * to an interval by referencing a fixed instant and then obtain the period.\n+     * \n+     * @param duration  the duration to add\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(long duration);\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    void normalize();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setYears(int years);\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMonths(int months);\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setWeeks(int weeks);\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setDays(int days);\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setHours(int hours);\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addHours(int hours);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMinutes(int minutes);\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setSeconds(int seconds);\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    void setMillis(int millis);\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMillis(int millis);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n  * interface only gives access to retrieve data, never to change it.\n  *\n  * @see ReadableInterval\n- * @see ReadableTimePeriod\n+ * @see ReadablePeriod\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n  * @since 1.0\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a TimePeriod instance using the All type.\n+     * Converts this duration to a Period instance using the All type.\n      * <p>\n      * Only precise fields in the period type will be used and the calculation will use UTC.\n      * <p>\n      * For more control over the conversion process, you should convert the duration\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n-     * @return a TimePeriod created using the millisecond duration from this instance\n-     */\n-    TimePeriod toTimePeriod();\n-\n-    /**\n-     * Converts this duration to a TimePeriod instance specifying a period type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    Period toPeriod();\n+\n+    /**\n+     * Converts this duration to a Period instance specifying a period type\n      * to control how the duration is split into fields.\n      * <p>\n      * The exact impact of this method is determined by the period type.\n      * to an interval by referencing a fixed instant and then obtain the period.\n      * \n      * @param type  the period type determining how to split the duration into fields\n-     * @return a TimePeriod created using the millisecond duration from this instance\n-     */\n-    TimePeriod toTimePeriod(PeriodType type);\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    Period toPeriod(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    TimePeriod toTimePeriod();\n+    Period toPeriod();\n \n     /**\n      * Converts the duration of the interval to a time period using the\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    TimePeriod toTimePeriod(PeriodType type);\n+    Period toPeriod(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n  */\n package org.joda.time;\n \n-\n /**\n  * Defines an partial time that does not support every datetime field.\n  * <p>\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadablePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a time period specified in terms of individual duration fields\n+ * such as years and days.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable. This\n+ * interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Periods are split up into multiple fields, for example days and seconds.\n+ * Implementations are not required to evenly distribute the values across the fields.\n+ * The value for each field may be positive or negative.\n+ * The {@link PeriodType} defines the rules for dividing the fields and which fields\n+ * are supported. Unsupported fields always have a value of zero.\n+ * <p>\n+ * When a time period is added to an instant, the effect is to add each field in turn.\n+ * For example, a time period could be defined as 3 months, 2 days and -1 hours.\n+ * In most circumstances this would be the same as 3 months, 1 day, and 23 hours.\n+ * However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long.\n+ * Thus, the time period is always added field by field to the datetime.\n+ *\n+ * @see ReadableDuration\n+ * @see ReadableInterval\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadablePeriod {\n+\n+    /**\n+     * Returns the period type which defines which fields this period supports.\n+     * \n+     * @return the period type\n+     */\n+    PeriodType getPeriodType();\n+\n+    /**\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A precise period could include millis, seconds, minutes or hours.\n+     * However, days, weeks, months and years can vary in length, resulting in\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the period is precise\n+     */\n+    boolean isPrecise();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this period to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses the chronology of the PeriodType.\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar);\n+\n+    /**\n+     * Adds this period to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses the chronology specified.\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @param chrono  override the chronology of the period type, unless null is passed in\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    long addTo(long instant, int scalar, Chronology chrono);\n+\n+    /**\n+     * Adds this period to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return instant with the original value plus this period times scalar\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    Instant addTo(ReadableInstant instant, int scalar);\n+\n+    /**\n+     * Adds this period into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added period\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    void addInto(ReadWritableInstant instant, int scalar);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    int getYears();\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    int getMonths();\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    int getWeeks();\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    int getDays();\n+\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    int getHours();\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    int getMinutes();\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    int getSeconds();\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    int getMillis();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this object as an immutable Period. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    Period toPeriod();\n+\n+    /**\n+     * Get this object as a MutablePeriod.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    MutablePeriod toMutablePeriod();\n+\n+    /**\n+     * Gets the total length of this time period in milliseconds, \n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the time period in milliseconds.\n+     * @throws IllegalStateException if this time period is imprecise\n+     */\n+    long toDurationMillis();\n+\n+    /**\n+     * Gets the total length of this time period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the time period in milliseconds.\n+     * @throws IllegalStateException if this time period is imprecise\n+     */\n+    Duration toDuration();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadablePeriod instances are accepted.\n+     * <p>\n+     * To compare two periods for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     *\n+     * @param readablePeriod  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    boolean equals(Object readablePeriod);\n+\n+    /**\n+     * Gets a hash code for the period that is compatable with the \n+     * equals method. The hashcode must be calculated as follows:\n+     * <pre>\n+     *   int hash = getPeriodType().hashCode();\n+     *   hash = 53 * hash + getYears();\n+     *   hash = 53 * hash + getMonths();\n+     *   hash = 53 * hash + getWeeks();\n+     *   hash = 53 * hash + getDays();\n+     *   hash = 53 * hash + getHours();\n+     *   hash = 53 * hash + getMinutes();\n+     *   hash = 53 * hash + getSeconds();\n+     *   hash = 53 * hash + getMillis();\n+     *   return hash;\n+     * </pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  *\n  * The default time period converters are:\n  * <ul>\n- * <li>ReadableTimePeriod\n+ * <li>ReadablePeriod\n  * <li>ReadableInterval\n  * <li>String\n  * <li>null (zero)\n     \n     private ConverterSet iInstantConverters;\n     private ConverterSet iDurationConverters;\n-    private ConverterSet iTimePeriodConverters;\n+    private ConverterSet iPeriodConverters;\n     private ConverterSet iIntervalConverters;\n     \n     /**\n \n         iDurationConverters = new ConverterSet(new Converter[] {\n             ReadableDurationConverter.INSTANCE,\n-            ReadableTimePeriodConverter.INSTANCE,\n+            ReadablePeriodConverter.INSTANCE,\n             ReadableIntervalConverter.INSTANCE,\n             StringConverter.INSTANCE,\n             LongConverter.INSTANCE,\n             NullConverter.INSTANCE,\n         });\n \n-        iTimePeriodConverters = new ConverterSet(new Converter[] {\n+        iPeriodConverters = new ConverterSet(new Converter[] {\n             ReadableDurationConverter.INSTANCE,\n-            ReadableTimePeriodConverter.INSTANCE,\n+            ReadablePeriodConverter.INSTANCE,\n             ReadableIntervalConverter.INSTANCE,\n             StringConverter.INSTANCE,\n             NullConverter.INSTANCE,\n      * @throws IllegalStateException if multiple converters match the type\n      * equally well\n      */\n-    public TimePeriodConverter getTimePeriodConverter(Object object) {\n-        TimePeriodConverter converter =\n-            (TimePeriodConverter)iTimePeriodConverters.select(object == null ? null : object.getClass());\n+    public PeriodConverter getPeriodConverter(Object object) {\n+        PeriodConverter converter =\n+            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n         if (converter != null) {\n             return converter;\n         }\n      * \n      * @return the converters, a copy of the real data, never null\n      */\n-    public TimePeriodConverter[] getTimePeriodConverters() {\n-        ConverterSet set = iTimePeriodConverters;\n-        TimePeriodConverter[] converters = new TimePeriodConverter[set.size()];\n+    public PeriodConverter[] getPeriodConverters() {\n+        ConverterSet set = iPeriodConverters;\n+        PeriodConverter[] converters = new PeriodConverter[set.size()];\n         set.copyInto(converters);\n         return converters;\n     }\n      * @param converter  the converter to add, null ignored\n      * @return replaced converter, or null\n      */\n-    public TimePeriodConverter addTimePeriodConverter(TimePeriodConverter converter)\n-            throws SecurityException {\n-        \n-        checkAlterTimePeriodConverters();\n-        if (converter == null) {\n-            return null;\n-        }\n-        TimePeriodConverter[] removed = new TimePeriodConverter[1];\n-        iTimePeriodConverters = iTimePeriodConverters.add(converter, removed);\n+    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PeriodConverter[] removed = new PeriodConverter[1];\n+        iPeriodConverters = iPeriodConverters.add(converter, removed);\n         return removed[0];\n     }\n     \n      * @param converter  the converter to remove, null ignored\n      * @return replaced converter, or null\n      */\n-    public TimePeriodConverter removeTimePeriodConverter(TimePeriodConverter converter)\n-            throws SecurityException {\n-        \n-        checkAlterTimePeriodConverters();\n-        if (converter == null) {\n-            return null;\n-        }\n-        TimePeriodConverter[] removed = new TimePeriodConverter[1];\n-        iTimePeriodConverters = iTimePeriodConverters.remove(converter, removed);\n+    public PeriodConverter removePeriodConverter(PeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PeriodConverter[] removed = new PeriodConverter[1];\n+        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n         return removed[0];\n     }\n     \n      * \n      * @throws SecurityException if the user does not have the permission\n      */\n-    private void checkAlterTimePeriodConverters() throws SecurityException {\n+    private void checkAlterPeriodConverters() throws SecurityException {\n         SecurityManager sm = System.getSecurityManager();\n         if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterTimePeriodConverters\"));\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n         }\n     }\n \n         return \"ConverterManager[\" +\n             iInstantConverters.size() + \" instant,\" +\n             iDurationConverters.size() + \" duration,\" +\n-            iTimePeriodConverters.size() + \" period,\" +\n+            iPeriodConverters.size() + \" period,\" +\n             iIntervalConverters.size() + \" interval]\";\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n \n /**\n  * LongConverter converts a Long to milliseconds in the ISOChronology.\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritableTimePeriod duration, Object object) {\n-        duration.setTimePeriod(((Long) object).longValue());\n+    public void setInto(ReadWritablePeriod duration, Object object) {\n+        duration.setPeriod(((Long) object).longValue());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.DateTimeUtils;\n-import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n \n /**\n  * NullConverter converts null to milliseconds (now) in the ISOChronology.\n  * @since 1.0\n  */\n class NullConverter extends AbstractConverter\n-        implements InstantConverter, DurationConverter, TimePeriodConverter {\n+        implements InstantConverter, DurationConverter, PeriodConverter {\n     \n     /**\n      * Singleton instance.\n      * @param object  the object to convert\n      * @throws NullPointerException if the duration is null\n      */\n-    public void setInto(ReadWritableTimePeriod duration, Object object) {\n-        duration.setTimePeriod(0L);\n+    public void setInto(ReadWritablePeriod duration, Object object) {\n+        duration.setPeriod(0L);\n     }\n \n     //-----------------------------------------------------------------------\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/PeriodConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+\n+/**\n+ * PeriodConverter defines how an object is converted to a time period.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface PeriodConverter extends Converter {\n+\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param period  the period to modify\n+     * @param object  the object to convert, must not be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    void setInto(ReadWritablePeriod period, Object object);\n+\n+    /**\n+     * Selects a suitable period type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @param precise  true if the period type must be precise\n+     * @return the period type, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    PeriodType getPeriodType(Object object, boolean precise);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.PeriodType;\n-import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadableDuration;\n \n /**\n  * @since 1.0\n  */\n class ReadableDurationConverter extends AbstractConverter\n-        implements DurationConverter, TimePeriodConverter {\n+        implements DurationConverter, PeriodConverter {\n \n     /**\n      * Singleton instance.\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritableTimePeriod duration, Object object) {\n-        duration.setTimePeriod((ReadableDuration) object);\n+    public void setInto(ReadWritablePeriod duration, Object object) {\n+        duration.setPeriod((ReadableDuration) object);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableInterval;\n \n  * @since 1.0\n  */\n class ReadableIntervalConverter extends AbstractConverter\n-        implements IntervalConverter, DurationConverter, TimePeriodConverter {\n+        implements IntervalConverter, DurationConverter, PeriodConverter {\n \n     /**\n      * Singleton instance.\n      * @param writablePeriod  the period to modify\n      * @param object  the interval to set from\n      */\n-    public void setInto(ReadWritableTimePeriod writablePeriod, Object object) {\n+    public void setInto(ReadWritablePeriod writablePeriod, Object object) {\n         ReadableInterval interval = (ReadableInterval) object;\n-        writablePeriod.setTimePeriod(interval.getStartMillis(), interval.getEndMillis());\n+        writablePeriod.setPeriod(interval.getStartMillis(), interval.getEndMillis());\n     }\n \n     //-----------------------------------------------------------------------\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * ReadablePeriodConverter extracts milliseconds and chronology from a ReadablePeriod.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ReadablePeriodConverter extends AbstractConverter\n+        implements PeriodConverter, DurationConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadablePeriodConverter INSTANCE = new ReadablePeriodConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadablePeriodConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public long getDurationMillis(Object object) {\n+        return ((ReadablePeriod) object).toDurationMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritablePeriod.\n+     *\n+     * @param duration duration to get modified\n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond duration\n+     * @throws NullPointerException if the duration or object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setInto(ReadWritablePeriod duration, Object object) {\n+        duration.setPeriod((ReadablePeriod) object);\n+    }\n+\n+    /**\n+     * Selects a suitable period type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @param precise  true if a precise type is required\n+     * @return the period type from the readable duration\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public PeriodType getPeriodType(Object object, boolean precise) {\n+        ReadablePeriod period = (ReadablePeriod) object;\n+        if (precise) {\n+            if (period.getPeriodType().isPrecise()) {\n+                return period.getPeriodType();\n+            } else {\n+                return PeriodType.getPreciseAllType();\n+            }\n+        }\n+        return period.getPeriodType();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadablePeriod class.\n+     * \n+     * @return ReadablePeriod.class\n+     */\n+    public Class getSupportedType() {\n+        return ReadablePeriod.class;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.ReadWritableInterval;\n-import org.joda.time.ReadWritableTimePeriod;\n-import org.joda.time.TimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.Period;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.format.ISOTimePeriodFormat;\n-import org.joda.time.format.TimePeriodFormatter;\n-import org.joda.time.format.TimePeriodParser;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.format.PeriodParser;\n \n /**\n  * StringConverter converts a String to milliseconds in the ISOChronology.\n  * @since 1.0\n  */\n class StringConverter extends AbstractConverter\n-        implements InstantConverter, DurationConverter, TimePeriodConverter, IntervalConverter {\n+        implements InstantConverter, DurationConverter, PeriodConverter, IntervalConverter {\n \n     /**\n      * Singleton instance.\n      */\n     public long getDurationMillis(Object object) {\n         String str = (String) object;\n-        MutableTimePeriod period = new MutableTimePeriod(PeriodType.getPreciseAllType());\n-        TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n+        MutablePeriod period = new MutablePeriod(PeriodType.getPreciseAllType());\n+        PeriodParser parser = ISOPeriodFormat.getInstance().standard();\n         int pos = parser.parseInto(period, str, 0);\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableTimePeriod(period.getPeriodType(), str);\n+                parser.parseMutablePeriod(period.getPeriodType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n      * @return the millisecond duration\n      * @throws ClassCastException if the object is invalid\n      */\n-    public void setInto(ReadWritableTimePeriod period, Object object) {\n-        String str = (String) object;\n-        TimePeriodParser parser = ISOTimePeriodFormat.getInstance().standard();\n+    public void setInto(ReadWritablePeriod period, Object object) {\n+        String str = (String) object;\n+        PeriodParser parser = ISOPeriodFormat.getInstance().standard();\n         int pos = parser.parseInto(period, str, 0);\n         if (pos < str.length()) {\n             if (pos < 0) {\n                 // Parse again to get a better exception thrown.\n-                parser.parseMutableTimePeriod(period.getPeriodType(), str);\n+                parser.parseMutablePeriod(period.getPeriodType(), str);\n             }\n             throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n         }\n         }\n \n         DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n-        TimePeriodFormatter durationParser = ISOTimePeriodFormat.getInstance().standard();\n+        PeriodFormatter durationParser = ISOPeriodFormat.getInstance().standard();\n         long startInstant;\n-        TimePeriod period;\n+        Period period;\n \n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n             startInstant = 0;\n-            period = durationParser.parseTimePeriod(getPeriodType(leftStr, false), leftStr);\n+            period = durationParser.parsePeriod(getPeriodType(leftStr, false), leftStr);\n         } else {\n             startInstant = dateTimeParser.parseMillis(leftStr);\n             period = null;\n             if (period != null) {\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n-            period = durationParser.parseTimePeriod(getPeriodType(rightStr, false), rightStr);\n+            period = durationParser.parsePeriod(getPeriodType(rightStr, false), rightStr);\n             writableInterval.setStartMillis(startInstant);\n-            writableInterval.setTimePeriodAfterStart(period);\n+            writableInterval.setPeriodAfterStart(period);\n         } else {\n             long endInstant = dateTimeParser.parseMillis(rightStr);\n             writableInterval.setEndMillis(endInstant);\n             if (period == null) {\n                 writableInterval.setStartMillis(startInstant);\n             } else {\n-                writableInterval.setTimePeriodBeforeEnd(period);\n+                writableInterval.setPeriodBeforeEnd(period);\n             }\n         }\n     }\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n  */\n public abstract class AbstractDateTimeFormatter {\n \n-    // Accessed also by AbstractTimePeriodFormatter.\n+    // Accessed also by AbstractPeriodFormatter.\n     static String createErrorMessage(final String text, final int errorPos) {\n         int sampleLen = errorPos + 20;\n         String sampleText;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractPeriodFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.PeriodType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.Period;\n+\n+/**\n+ * Abstract base class for implementing {@link PeriodPrinter}s,\n+ * {@link PeriodParser}s, and {@link PeriodFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented PeriodPrinter or\n+ * PeriodFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * PeriodParser or PeriodFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractPeriodFormatter {\n+    \n+    public int countFieldsToPrint(ReadablePeriod period) {\n+        return ((PeriodPrinter) this).countFieldsToPrint(period, Integer.MAX_VALUE);\n+    }\n+\n+    public String print(ReadablePeriod period) {\n+        PeriodPrinter p = (PeriodPrinter) this;\n+        StringBuffer buf = new StringBuffer(p.calculatePrintedLength(period));\n+        p.printTo(buf, period);\n+        return buf.toString();\n+    }\n+\n+    public Period parsePeriod(PeriodType type, String text) {\n+        return parseMutablePeriod(type, text).toPeriod();\n+    }\n+\n+    public MutablePeriod parseMutablePeriod(PeriodType type, String text) {\n+        PeriodParser p = (PeriodParser) this;\n+        MutablePeriod period = new MutablePeriod(0, type);\n+\n+        int newPos = p.parseInto(period, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return period;\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(\n+            AbstractDateTimeFormatter.createErrorMessage(text, newPos));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/ISOPeriodFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * ISOPeriodFormat provides factory methods for the ISO8601 standard.\n+ * <p>\n+ * ISOPeriodFormat is thread-safe and immutable, and the formatters it\n+ * returns are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PeriodFormat\n+ * @see PeriodFormatterBuilder\n+ */\n+public class ISOPeriodFormat {\n+    private static final ISOPeriodFormat INSTANCE = new ISOPeriodFormat();\n+\n+    /**\n+     * Returns a singleton instance of ISOPeriodFormat.\n+     */\n+    public static ISOPeriodFormat getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private transient PeriodFormatter\n+        iStandard,\n+        iAlternate,\n+        iAlternateExtended,\n+        iAlternateWithWeeks,\n+        iAlternateExtendedWihWeeks;\n+\n+    private ISOPeriodFormat() {\n+    }\n+\n+    /**\n+     * The standard ISO format - PyYmMwWdDThHmMsS.\n+     * Milliseconds are not output.\n+     */\n+    public PeriodFormatter standard() {\n+        if (iStandard == null) {\n+            iStandard = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroRarely()\n+                .appendYears()\n+                .appendSuffix(\"Y\")\n+                .appendMonths()\n+                .appendSuffix(\"M\")\n+                .appendWeeks()\n+                .appendSuffix(\"W\")\n+                .appendDays()\n+                .appendSuffix(\"D\")\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSuffix(\"H\")\n+                .appendMinutes()\n+                .appendSuffix(\"M\")\n+                .appendSeconds()\n+                .appendSuffix(\"S\")\n+                .toFormatter();\n+        }\n+        return iStandard;\n+    }\n+\n+    /**\n+     * PyyyymmddThhmmss\n+     */\n+    public PeriodFormatter alternate() {\n+        if (iAlternate == null) {\n+            iAlternate = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternate;\n+    }\n+\n+    /**\n+     * Pyyyy-mm-ddThh:mm:ss\n+     */\n+    public PeriodFormatter alternateExtended() {\n+        if (iAlternateExtended == null) {\n+            iAlternateExtended = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateExtended;\n+    }\n+\n+    /**\n+     * PyyyyWwwddThhmmss\n+     */\n+    public PeriodFormatter alternateWithWeeks() {\n+        if (iAlternateWithWeeks == null) {\n+            iAlternateWithWeeks = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateWithWeeks;\n+    }\n+\n+    /**\n+     * Pyyyy-Www-ddThh:mm:ss\n+     */\n+    public PeriodFormatter alternateExtendedWithWeeks() {\n+        if (iAlternateExtendedWihWeeks == null) {\n+            iAlternateExtendedWihWeeks = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparator(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSeconds()\n+                .toFormatter();\n+        }\n+        return iAlternateExtendedWihWeeks;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Locale;\n+\n+/**\n+ * PeriodFormat provides basic printing and parsing capabilities for\n+ * durations. Eventually, this class will also support localization.\n+ * <p>\n+ * PeriodFormat is thread-safe and immutable, and the formatters it returns\n+ * are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see ISOPeriodFormat\n+ * @see PeriodFormatterBuilder\n+ */\n+public class PeriodFormat {\n+\n+    private static final PeriodFormat INSTANCE = new PeriodFormat();\n+\n+    /**\n+     * Gets a formatter provider that works using the default locale.\n+     * \n+     * @return a format provider\n+     */\n+    public static PeriodFormat getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a formatter provider that works using the given locale.\n+     * \n+     * @param locale  the Locale to use, null for default locale\n+     * @return a format provider\n+     */\n+    public static PeriodFormat getInstance(Locale locale) {\n+        return INSTANCE;\n+    }\n+\n+    private final PeriodFormatter iDefault;\n+\n+    private PeriodFormat() {\n+        iDefault = new PeriodFormatterBuilder()\n+            .appendYears()\n+            .appendSuffix(\" year\", \" years\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMonths()\n+            .appendSuffix(\" month\", \" months\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendWeeks()\n+            .appendSuffix(\" week\", \" weeks\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendDays()\n+            .appendSuffix(\" day\", \" days\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendHours()\n+            .appendSuffix(\" hour\", \" hours\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMinutes()\n+            .appendSuffix(\" minute\", \" minutes\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendSeconds()\n+            .appendSuffix(\" second\", \" seconds\")\n+            .appendSeparator(\", \", \" and \")\n+            .appendMillis()\n+            .appendSuffix(\" millisecond\", \" milliseconds\")\n+            .toFormatter();\n+    }\n+\n+    /**\n+     * Returns the default PeriodFormatter.\n+     */\n+    public PeriodFormatter getDefault() {\n+        return iDefault;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Combined interface for printing and parsing.\n+ * <p>\n+ * See each extended interface for details of the methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface PeriodFormatter extends PeriodPrinter, PeriodParser {\n+\n+    // Methods inherited\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * PeriodFormatterBuilder is used for constructing {@link PeriodFormatter}s.\n+ * PeriodFormatters are built by appending specific fields and separators.\n+ *\n+ * <p>\n+ * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n+ * can be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n+ *     .printZeroAlways()\n+ *     .appendYears()\n+ *     .appendSuffix(\" year\", \" years\")\n+ *     .appendSeparator(\" and \")\n+ *     .printZeroRarely()\n+ *     .appendMonths()\n+ *     .appendSuffix(\" month\", \" months\")\n+ *     .toFormatter();\n+ * </pre>\n+ * <p>\n+ * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n+ *\n+ * @see PeriodFormat\n+ * @author Brian S O'Neill\n+ */\n+public class PeriodFormatterBuilder {\n+    private static final int PRINT_ZERO_RARELY = 1;\n+    private static final int PRINT_ZERO_IF_SUPPORTED = 2;\n+    private static final int PRINT_ZERO_ALWAYS = 3;\n+\n+    private boolean iFavorFirstFieldForZero;\n+\n+    private int iMinPrintedDigits;\n+    private int iPrintZeroSetting;\n+    private int iMaxParsedDigits;\n+    private boolean iRejectSignedValues;\n+\n+    private DurationFieldAffix iPrefix;\n+\n+    // List of PeriodFormatters used to build a final formatter.\n+    private List iFormatters;\n+\n+    // List of PeriodFormatters used to build an alternate formatter. The\n+    // alternate is chosen if no other fields are printed.\n+    private List iAlternateFormatters;\n+\n+    public PeriodFormatterBuilder() {\n+        clear();\n+    }\n+\n+    /**\n+     * Converts to a PeriodPrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     */\n+    public PeriodPrinter toPrinter() {\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a PeriodParser that parses using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * parser.\n+     */\n+    public PeriodParser toParser() {\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a PeriodFormatter that formats using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * formatter.\n+     */\n+    public PeriodFormatter toFormatter() {\n+        PeriodFormatter formatter = toFormatter(iFormatters);\n+        List altFormatters = iAlternateFormatters;\n+        if (altFormatters.size() > 0) {\n+            // Alternate is needed only if field formatters were\n+            // appended. Literals may have been appended as well.\n+            for (int i=altFormatters.size(); --i>=0; ) {\n+                if (altFormatters.get(i) instanceof FieldFormatter) {\n+                    formatter = new AlternateSelector\n+                        (formatter, altFormatters, iFavorFirstFieldForZero);\n+                    break;\n+                }\n+            }\n+        }\n+        return formatter;\n+    }\n+\n+    private static PeriodFormatter toFormatter(List formatters) {\n+        int size = formatters.size();\n+        if (size >= 2 && formatters.get(1) instanceof Separator) {\n+            PeriodFormatter before = (PeriodFormatter) formatters.get(0);\n+            if (size == 2) {\n+                // Separator at the end would never format anything.\n+                return before;\n+            }\n+            return ((Separator) formatters.get(1)).finish\n+                (before, toFormatter(formatters.subList(2, size)));\n+        }\n+        return createComposite(formatters);\n+    }\n+\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be\n+     * reused.\n+     */\n+    public void clear() {\n+        iFavorFirstFieldForZero = false;\n+        iMinPrintedDigits = 1;\n+        iPrintZeroSetting = PRINT_ZERO_RARELY;\n+        iMaxParsedDigits = 10;\n+        iRejectSignedValues = false;\n+        iPrefix = null;\n+        if (iFormatters == null) {\n+            iFormatters = new ArrayList();\n+        } else {\n+            iFormatters.clear();\n+        }\n+        if (iAlternateFormatters == null) {\n+            iAlternateFormatters = new ArrayList();\n+        } else {\n+            iAlternateFormatters.clear();\n+        }\n+    }\n+\n+    /**\n+     * Appends another formatter.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder append(PeriodFormatter formatter)\n+        throws IllegalArgumentException\n+    {\n+        if (formatter == null) {\n+            throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        clearPrefix();\n+        iFormatters.add(formatter);\n+        return this;\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect\n+     * it. The parser is case-insensitive.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public PeriodFormatterBuilder appendLiteral(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n+        clearPrefix();\n+        Literal literal = new Literal(text);\n+        iFormatters.add(literal);\n+        iAlternateFormatters.add(literal);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the minimum digits printed for the next and following appended\n+     * fields. By default, the minimum digits printed is one. If the field value\n+     * is zero, it is not printed unless a printZero rule is applied.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n+        iMinPrintedDigits = minDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the maximum digits parsed for the next and following appended\n+     * fields. By default, the maximum digits parsed is ten.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n+        iMaxParsedDigits = maxDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Reject signed values when parsing the next and following appended fields.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n+        iRejectSignedValues = v;\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields,\n+     * unless no fields would be printed. If no fields are printed, the printer\n+     * forces at most one \"printZeroRarely\" field to print a zero.\n+     * <p>\n+     * This field setting is the default.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     * @see #favorLastFieldForZero()\n+     * @see #favorFirstFieldForZero()\n+     */\n+    public PeriodFormatterBuilder printZeroRarely() {\n+        iPrintZeroSetting = PRINT_ZERO_RARELY;\n+        return this;\n+    }\n+\n+    /**\n+     * Print zero values for the next and following appened fields only if the\n+     * duration supports it.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroIfSupported() {\n+        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n+        return this;\n+    }\n+\n+    /**\n+     * Always print zero values for the next and following appended fields,\n+     * even if the duration doesn't support it. The parser requires values for\n+     * fields that always print zero.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroAlways() {\n+        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param text text to print before field only if field is printed\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public PeriodFormatterBuilder appendPrefix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether\n+     * or not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public PeriodFormatterBuilder appendPrefix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param prefix custom prefix\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    private PeriodFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n+        if (prefix == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (iPrefix != null) {\n+            prefix = new CompositeAffix(iPrefix, prefix);\n+        }\n+        iPrefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer years field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendYears() {\n+        appendField(1);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer years field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMonths() {\n+        appendField(2);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer weeks field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendWeeks() {\n+        appendField(3);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer days field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendDays() {\n+        appendField(4);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer hours field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendHours() {\n+        appendField(5);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer minutes field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMinutes() {\n+        appendField(6);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer seconds field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSeconds() {\n+        appendField(7);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMillis() {\n+        appendField(8);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMillis3Digit() {\n+        appendField(8, 3);\n+        return this;\n+    }\n+\n+    private void appendField(int type) {\n+        appendField(type, iMinPrintedDigits);\n+    }\n+\n+    private void appendField(int type, int minPrinted) {\n+        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n+            iMaxParsedDigits, iRejectSignedValues, type, iPrefix, null);\n+        iFormatters.add(field);\n+        if (iPrintZeroSetting == PRINT_ZERO_RARELY) {\n+            iAlternateFormatters.add(field);\n+        }\n+        iPrefix = null;\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param text text to print after field only if field is printed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public PeriodFormatterBuilder appendSuffix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new SingularAffix(text));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether or\n+     * not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public PeriodFormatterBuilder appendSuffix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param suffix custom suffix\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    private PeriodFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n+        final Object originalField;\n+        if (iFormatters.size() > 0) {\n+            originalField = iFormatters.get(iFormatters.size() - 1);\n+        } else {\n+            originalField = null;\n+        }\n+\n+        if (originalField == null || !(originalField instanceof FieldFormatter)) {\n+            throw new IllegalStateException(\"No field to apply suffix to\");\n+        }\n+\n+        clearPrefix();\n+        Object newField = new FieldFormatter((FieldFormatter) originalField, suffix);\n+        iFormatters.set(iFormatters.size() - 1, newField);\n+\n+        int index = iAlternateFormatters.lastIndexOf(originalField);\n+        if (index >= 0) {\n+            iAlternateFormatters.set(index, newField);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text) {\n+        return appendSeparator(text, text);\n+    }\n+\n+    /**\n+     * During printing, separators are only printed if fields are printed\n+     * following the latest one.\n+     * <p>\n+     * During parsing, either text parameter is accepted, and is\n+     * case-insensitive.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param finalText alternate used if this is the final separator\n+     * printed\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text,\n+                                                    String finalText) {\n+        if (text == null || finalText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        clearPrefix();\n+\n+        List formatters = iFormatters;\n+\n+        if (formatters.size() == 0) {\n+            // Separator at the beginning would never print anything.\n+            return this;\n+        }\n+\n+        // Create a composite over all the fields between separators.\n+        int i;\n+        Separator lastSeparator = null;\n+        for (i=formatters.size(); --i>=0; ) {\n+            if (formatters.get(i) instanceof Separator) {\n+                lastSeparator = (Separator) formatters.get(i);\n+                formatters = formatters.subList(i + 1, formatters.size());\n+                break;\n+            }\n+        }\n+\n+        if (lastSeparator != null && formatters.size() == 0) {\n+            // Merge two adjacent separators together.\n+            iFormatters.set(i, lastSeparator.merge(text, finalText));\n+        } else {\n+            PeriodFormatter composite = createComposite(formatters);\n+            formatters.clear();\n+            formatters.add(composite);\n+            \n+            // The separator will be finished later.\n+            formatters.add(new Separator(text, finalText));\n+        }\n+            \n+        return this;\n+    }\n+\n+    /**\n+     * If the printer doesn't print any field values, it forces a\n+     * \"printZeroRarely\" field to print. This setting controls which field is\n+     * selected.\n+     * <p>\n+     * It starts from the last appended field, and moves towards the first,\n+     * stopping until it finds a field that is supported by the duration being\n+     * printed. If no supported fields are found, then no fields are printed.\n+     * <p>\n+     * This setting is the default.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     * @see #printZeroRarely()\n+     */\n+    public PeriodFormatterBuilder favorLastFieldForZero() {\n+        iFavorFirstFieldForZero = false;\n+        return this;\n+    }\n+\n+    /**\n+     * If the printer doesn't print any field values, it forces a\n+     * \"printZeroRarely\" field to print. This setting controls which field is\n+     * selected.\n+     * <p>\n+     * It starts from the first appended field, and moves towards the last,\n+     * stopping until it finds a field that is supported by the duration being\n+     * printed. If no supported fields are found, then no fields are printed.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     * @see #printZeroRarely()\n+     */\n+    public PeriodFormatterBuilder favorFirstFieldForZero() {\n+        iFavorFirstFieldForZero = true;\n+        return this;\n+    }\n+\n+    private void clearPrefix() throws IllegalStateException {\n+        if (iPrefix != null) {\n+            throw new IllegalStateException(\"Prefix not followed by field\");\n+        }\n+        iPrefix = null;\n+    }\n+\n+    private static PeriodFormatter createComposite(List formatters) {\n+        if (formatters.size() == 1) {\n+            return (PeriodFormatter)formatters.get(0);\n+        } else {\n+            return new Composite(formatters);\n+        }\n+    }\n+\n+    /**\n+     * Defines a formatted field's prefix or suffix text.\n+     */\n+    private static interface DurationFieldAffix {\n+        int calculatePrintedLength(int value);\n+        \n+        void printTo(StringBuffer buf, int value);\n+        \n+        void printTo(Writer out, int value) throws IOException;\n+        \n+        /**\n+         * @return new position after parsing affix, or ~position of failure\n+         */\n+        int parse(String durationStr, int position);\n+\n+        /**\n+         * @return position where affix starts, or original ~position if not found\n+         */\n+        int scan(String durationStr, int position);\n+    }\n+\n+    private static final class SingularAffix implements DurationFieldAffix {\n+        private final String iText;\n+\n+        SingularAffix(String text) {\n+            iText = text;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            if (durationStr.regionMatches(true, position, text, 0, textLength)) {\n+                return position + textLength;\n+            }\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text, 0, textLength)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class PluralAffix implements DurationFieldAffix {\n+        private final String iSingularText;\n+        private final String iPluralText;\n+\n+        PluralAffix(String singularText, String pluralText) {\n+            iSingularText = singularText;\n+            iPluralText = pluralText;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return (value == 1 ? iSingularText : iPluralText).length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            if (durationStr.regionMatches\n+                (true, position, text1, 0, text1.length())) {\n+                return position + text1.length();\n+            }\n+            if (durationStr.regionMatches\n+                (true, position, text2, 0, text2.length())) {\n+                return position + text2.length();\n+            }\n+\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            int textLength1 = text1.length();\n+            int textLength2 = text2.length();\n+\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text1, 0, textLength1)) {\n+                    return pos;\n+                }\n+                if (durationStr.regionMatches(true, pos, text2, 0, textLength2)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class CompositeAffix implements DurationFieldAffix {\n+        private final DurationFieldAffix iLeft;\n+        private final DurationFieldAffix iRight;\n+\n+        CompositeAffix(DurationFieldAffix left, DurationFieldAffix right) {\n+            iLeft = left;\n+            iRight = right;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iLeft.calculatePrintedLength(value)\n+                + iRight.calculatePrintedLength(value);\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            iLeft.printTo(buf, value);\n+            iRight.printTo(buf, value);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            iLeft.printTo(out, value);\n+            iRight.printTo(out, value);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            position = iLeft.parse(durationStr, position);\n+            if (position >= 0) {\n+                position = iRight.parse(durationStr, position);\n+            }\n+            return position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            int pos = iLeft.scan(durationStr, position);\n+            if (pos >= 0) {\n+                return iRight.scan(durationStr, pos);\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class FieldFormatter extends AbstractPeriodFormatter\n+        implements PeriodFormatter\n+    {\n+        private final int iMinPrintedDigits;\n+        private final int iPrintZeroSetting;\n+        private final int iMaxParsedDigits;\n+        private final boolean iRejectSignedValues;\n+\n+        private final int iFieldType;\n+\n+        private final DurationFieldAffix iPrefix;\n+        private final DurationFieldAffix iSuffix;\n+\n+        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n+                       int maxParsedDigits, boolean rejectSignedValues,\n+                       int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = minPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iRejectSignedValues = rejectSignedValues;\n+            iFieldType = fieldType;\n+            iPrefix = prefix;\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = field.iPrintZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n+            iFieldType = field.iFieldType;\n+            iPrefix = field.iPrefix;\n+            if (field.iSuffix != null) {\n+                suffix = new CompositeAffix(field.iSuffix, suffix);\n+            }\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, int printZeroSetting) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n+            iFieldType = field.iFieldType;\n+            iPrefix = field.iPrefix;\n+            iSuffix = field.iSuffix;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period) {\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) >= 0) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+            return stopAt <= 0 ? 0 : countFieldsToPrint(period);\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return 0;\n+            }\n+\n+            int value = (int)valueLong;\n+\n+            int sum = Math.max\n+                (FormatUtils.calculateDigitCount(value), iMinPrintedDigits);\n+            if (value < 0) {\n+                // Account for sign character\n+                sum++;\n+            }\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                sum += affix.calculatePrintedLength(value);\n+            }\n+\n+            return sum;\n+        }\n+        \n+        public void printTo(StringBuffer buf, ReadablePeriod period) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.appendUnpaddedInteger(buf, value);\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(buf, value);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong < 0) {\n+                return;\n+            }\n+            int value = (int)valueLong;\n+\n+            DurationFieldAffix affix;\n+            if ((affix = iPrefix) != null) {\n+                affix.printTo(out, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.writeUnpaddedInteger(out, value);\n+            } else {\n+                FormatUtils.writePaddedInteger(out, value, minDigits);\n+            }\n+            if ((affix = iSuffix) != null) {\n+                affix.printTo(out, value);\n+            }\n+        }\n+\n+        public int parseInto(ReadWritablePeriod period,\n+                             String text, int position) {\n+\n+            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n+\n+            // Shortcut test.\n+            if (position >= text.length()) {\n+                return mustParse ? ~position : position;\n+            }\n+\n+            if (iPrefix != null) {\n+                position = iPrefix.parse(text, position);\n+                if (position >= 0) {\n+                    // If prefix is found, then the parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Prefix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~position;\n+                    }\n+                    return position;\n+                }\n+            }\n+\n+            int suffixPos = -1;\n+            if (iSuffix != null && !mustParse) {\n+                // Pre-scan the suffix, to help determine if this field must be\n+                // parsed.\n+                suffixPos = iSuffix.scan(text, position);\n+                if (suffixPos >= 0) {\n+                    // If suffix is found, then parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Suffix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~suffixPos;\n+                    }\n+                    return suffixPos;\n+                }\n+            }\n+\n+            if (!mustParse && !isSupported(period.getPeriodType())) {\n+                // If parsing is not required and the field is not supported,\n+                // exit gracefully so that another parser can continue on.\n+                return position;\n+            }\n+\n+            int limit;\n+            if (suffixPos > 0) {\n+                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n+            } else {\n+                limit = Math.min(iMaxParsedDigits, text.length() - position);\n+            }\n+\n+            boolean negative = false;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n+                    negative = c == '-';\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            int value;\n+            if (length >= 9) {\n+                // Since value may exceed max, use stock parser which checks\n+                // for this.\n+                value = Integer.parseInt\n+                    (text.substring(position, position += length));\n+            } else {\n+                int i = position;\n+                if (negative) {\n+                    i++;\n+                }\n+                value = text.charAt(i++) - '0';\n+                position += length;\n+                while (i < position) {\n+                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n+                }\n+                if (negative) {\n+                    value = -value;\n+                }\n+            }\n+            \n+            setFieldValue(period, value);\n+                \n+            if (position >= 0 && iSuffix != null) {\n+                position = iSuffix.parse(text, position);\n+            }\n+                \n+            return position;\n+        }\n+\n+        /**\n+         * @return negative value if nothing to print, otherwise lower 32 bits\n+         * is signed int value.\n+         */\n+        long getFieldValue(ReadablePeriod period) {\n+            PeriodType type;\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n+                type = null; // Don't need to check if supported.\n+            } else {\n+                type = period.getPeriodType();\n+            }\n+\n+            int value;\n+\n+            switch (iFieldType) {\n+            default:\n+                return -1;\n+            case 1:\n+                if (type != null && type.years().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getYears();\n+                break;\n+            case 2:\n+                if (type != null && type.months().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMonths();\n+                break;\n+            case 3:\n+                if (type != null && type.weeks().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getWeeks();\n+                break;\n+            case 4:\n+                if (type != null && type.days().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getDays();\n+                break;\n+            case 5:\n+                if (type != null && type.hours().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getHours();\n+                break;\n+            case 6:\n+                if (type != null && type.minutes().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMinutes();\n+                break;\n+            case 7:\n+                if (type != null && type.seconds().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getSeconds();\n+                break;\n+            case 8:\n+                if (type != null && type.millis().isSupported() == false) {\n+                    return -1;\n+                }\n+                value = period.getMillis();\n+                break;\n+            }\n+\n+            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {\n+                return -1;\n+            }\n+\n+            return value & 0xffffffffL;\n+        }\n+\n+        boolean isSupported(PeriodType type) {\n+            switch (iFieldType) {\n+            default:\n+                return false;\n+            case 1:\n+                return type.years().isSupported();\n+            case 2:\n+                return type.months().isSupported();\n+            case 3:\n+                return type.weeks().isSupported();\n+            case 4:\n+                return type.days().isSupported();\n+            case 5:\n+                return type.hours().isSupported();\n+            case 6:\n+                return type.minutes().isSupported();\n+            case 7:\n+                return type.seconds().isSupported();\n+            case 8:\n+                return type.millis().isSupported();\n+            }\n+        }\n+\n+        void setFieldValue(ReadWritablePeriod period, int value) {\n+            switch (iFieldType) {\n+            default:\n+                break;\n+            case 1:\n+                period.setYears(value);\n+                break;\n+            case 2:\n+                period.setMonths(value);\n+                break;\n+            case 3:\n+                period.setWeeks(value);\n+                break;\n+            case 4:\n+                period.setDays(value);\n+                break;\n+            case 5:\n+                period.setHours(value);\n+                break;\n+            case 6:\n+                period.setMinutes(value);\n+                break;\n+            case 7:\n+                period.setSeconds(value);\n+                break;\n+            case 8:\n+                period.setMillis(value);\n+                break;\n+            }\n+        }\n+\n+        int getPrintZeroSetting() {\n+            return iPrintZeroSetting;\n+        }\n+    }\n+\n+    private static final class Literal extends AbstractPeriodFormatter\n+        implements PeriodFormatter\n+    {\n+        private final String iText;\n+\n+        Literal(String text) {\n+            iText = text;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+            return 0;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parseInto(ReadWritablePeriod period,\n+                             String periodStr, int position) {\n+            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                return position + iText.length();\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private static final class Separator extends AbstractPeriodFormatter\n+        implements PeriodFormatter\n+    {\n+        private final String iText;\n+        private final String iFinalText;\n+\n+        private final PeriodFormatter iBefore;\n+        private final PeriodFormatter iAfter;\n+\n+        Separator(String text, String finalText) {\n+            this(text, finalText, null, null);\n+        }\n+\n+        Separator(String text, String finalText,\n+                  PeriodFormatter before, PeriodFormatter after) {\n+            iText = text;\n+            iFinalText = finalText;\n+            iBefore = before;\n+            iAfter = after;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+            int sum = iBefore.countFieldsToPrint(period, stopAt);\n+            if (sum < stopAt) {\n+                sum += iAfter.countFieldsToPrint(period, stopAt);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period) {\n+            int sum = iBefore.calculatePrintedLength(period)\n+                + iAfter.calculatePrintedLength(period);\n+\n+            if (iBefore.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = iAfter.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    sum += (afterCount > 1 ? iText : iFinalText).length();\n+                }\n+            }\n+\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period) {\n+            PeriodPrinter before = iBefore;\n+            PeriodPrinter after = iAfter;\n+\n+            before.printTo(buf, period);\n+\n+            if (before.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    buf.append(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(buf, period);\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+            PeriodPrinter before = iBefore;\n+            PeriodPrinter after = iAfter;\n+\n+            before.printTo(out, period);\n+\n+            if (before.countFieldsToPrint(period, 1) > 0) {\n+                int afterCount = after.countFieldsToPrint(period, 2);\n+                if (afterCount > 0) {\n+                    out.write(afterCount > 1 ? iText : iFinalText);\n+                }\n+            }\n+\n+            after.printTo(out, period);\n+        }\n+\n+        public int parseInto(ReadWritablePeriod period,\n+                             String periodStr, int position) {\n+            final int oldPos = position;\n+\n+            position = iBefore.parseInto(period, periodStr, position);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            if (position > oldPos) {\n+                // Since position advanced, this separator is\n+                // allowed. Optionally parse it.\n+                if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                    position += iText.length();\n+                } else if (iText != iFinalText && periodStr.regionMatches\n+                           (true, position, iFinalText, 0, iFinalText.length())) {\n+                    position += iFinalText.length();\n+                }\n+            }\n+\n+            return iAfter.parseInto(period, periodStr, position);\n+        }\n+\n+        Separator merge(String text, String finalText) {\n+            return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);\n+        }\n+\n+        Separator finish(PeriodFormatter before, PeriodFormatter after) {\n+            return new Separator(iText, iFinalText, before, after);\n+        }\n+    }\n+\n+    private static final class Composite extends AbstractPeriodFormatter\n+        implements PeriodFormatter\n+    {\n+        private final PeriodFormatter[] iFormatters;\n+\n+        Composite(List formatters) {\n+            iFormatters = (PeriodFormatter[])formatters.toArray\n+                (new PeriodFormatter[formatters.size()]);\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+            int sum = 0;\n+            PeriodPrinter[] printers = iFormatters;\n+            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n+                sum += printers[i].countFieldsToPrint(period);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period) {\n+            int sum = 0;\n+            PeriodPrinter[] printers = iFormatters;\n+            for (int i=printers.length; --i>=0; ) {\n+                sum += printers[i].calculatePrintedLength(period);\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period) {\n+            PeriodPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(buf, period);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+            PeriodPrinter[] printers = iFormatters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(out, period);\n+            }\n+        }\n+\n+        public int parseInto(ReadWritablePeriod period,\n+                             String periodStr, int position) {\n+            PeriodParser[] parsers = iFormatters;\n+\n+            if (parsers == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = parsers.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = parsers[i].parseInto(period, periodStr, position);\n+            }\n+            return position;\n+        }\n+    }\n+\n+    private static final class AlternateSelector extends AbstractPeriodFormatter\n+        implements PeriodFormatter\n+    {\n+        private final PeriodFormatter iPrimaryFormatter;\n+        private final PeriodPrinter[] iAlternatePrinters;\n+        private final boolean iFavorFirstFieldForZero;\n+\n+        AlternateSelector(PeriodFormatter primaryFormatter,\n+                          List alternatePrinters,\n+                          boolean favorFirstFieldForZero) {\n+            iPrimaryFormatter = primaryFormatter;\n+            iAlternatePrinters = (PeriodPrinter[])alternatePrinters.toArray\n+                (new PeriodPrinter[alternatePrinters.size()]);\n+            iFavorFirstFieldForZero = favorFirstFieldForZero;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+            int count = iPrimaryFormatter.countFieldsToPrint(period, stopAt);\n+            if (count < 1 && stopAt >= 1) {\n+                if (chooseFieldToPrint(period) != null) {\n+                    return 1;\n+                }\n+            }\n+            return count;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period) {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                return iPrimaryFormatter.calculatePrintedLength(period);\n+            }\n+\n+            Object chosenOne = chooseFieldToPrint(period);\n+\n+            int sum = 0;\n+            PeriodPrinter[] printers = iAlternatePrinters;\n+            for (int i=printers.length; --i>=0; ) {\n+                PeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    sum += dp.calculatePrintedLength(period);\n+                }\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period) {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                iPrimaryFormatter.printTo(buf, period);\n+                return;\n+            }\n+\n+            Object chosenOne = chooseFieldToPrint(period);\n+            \n+            PeriodPrinter[] printers = iAlternatePrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                PeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    dp.printTo(buf, period);\n+                }\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+            if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {\n+                iPrimaryFormatter.printTo(out, period);\n+                return;\n+            }\n+            \n+            Object chosenOne = chooseFieldToPrint(period);\n+\n+            PeriodPrinter[] printers = iAlternatePrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                PeriodPrinter dp = printers[i];\n+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {\n+                    dp.printTo(out, period);\n+                }\n+            }\n+        }\n+\n+        public int parseInto(ReadWritablePeriod period,\n+                             String periodStr, int position) {\n+            return iPrimaryFormatter.parseInto(period, periodStr, position);\n+        }\n+\n+        private FieldFormatter chooseFieldToPrint(ReadablePeriod period) {\n+            PeriodType type = period.getPeriodType();\n+            PeriodPrinter[] printers = iAlternatePrinters;\n+            if (iFavorFirstFieldForZero) {\n+                int len = printers.length;\n+                for (int i=0; i<len; i++) {\n+                    PeriodPrinter dp = printers[i];\n+                    if (dp instanceof FieldFormatter) {\n+                        FieldFormatter ff = (FieldFormatter) dp;\n+                        if (ff.isSupported(type)) {\n+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {\n+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);\n+                                printers[i] = ff;\n+                            }\n+                            return ff;\n+                        }\n+                    }\n+                }\n+            } else {\n+                for (int i=printers.length; --i>=0; ) {\n+                    PeriodPrinter dp = printers[i];\n+                    if (dp instanceof FieldFormatter) {\n+                        FieldFormatter ff = (FieldFormatter) dp;\n+                        if (ff.isSupported(type)) {\n+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {\n+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);\n+                                printers[i] = ff;\n+                            }\n+                            return ff;\n+                        }\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodParser.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.ReadWritablePeriod;\n+\n+/**\n+ * Defines an interface for parsing textual representations of time periods.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PeriodFormatter\n+ * @see PeriodFormatterBuilder\n+ * @see PeriodFormat\n+ * @since 1.0\n+ */\n+public interface PeriodParser {\n+\n+    /**\n+     * Parses a period from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableDuration. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the period may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param period  a period that will be modified\n+     * @param periodStr  text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritablePeriod period, String periodStr, int position);\n+\n+    /**\n+     * Parses a period from the given text, returning a new Period.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param periodStr  text to parse\n+     * @return parsed value in a Duration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    Period parsePeriod(PeriodType type, String periodStr);\n+\n+    /**\n+     * Parses a period from the given text, returning a new MutablePeriod.\n+     *\n+     * @param type  defines which fields may be parsed\n+     * @param periodStr  text to parse\n+     * @return parsed value in a MutableDuration object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    MutablePeriod parseMutablePeriod(PeriodType type, String periodStr);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodPrinter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * Defines an interface for creating textual representations of time periods.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PeriodFormatter\n+ * @see PeriodFormatterBuilder\n+ * @see PeriodFormat\n+ * @since 1.0\n+ */\n+public interface PeriodPrinter {\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadablePeriod period);\n+\n+    /**\n+     * Returns the amount of fields from the given duration that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @param stopAt stop counting at this value\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadablePeriod period, int stopAt);\n+\n+    /**\n+     * Returns the exact number of characters produced for the given duration.\n+     * \n+     * @param period  the period to use\n+     * @return the estimated length\n+     */\n+    int calculatePrintedLength(ReadablePeriod period);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePeriod to a StringBuffer.\n+     *\n+     * @param buf  the formatted period is appended to this buffer\n+     * @param period  the period to format\n+     */\n+    void printTo(StringBuffer buf, ReadablePeriod period);\n+\n+    /**\n+     * Prints a ReadablePeriod to a Writer.\n+     *\n+     * @param out  the formatted period is written out\n+     * @param period  the period to format\n+     */\n+    void printTo(Writer out, ReadablePeriod period) throws IOException;\n+\n+    /**\n+     * Prints a ReadablePeriod to a new String.\n+     *\n+     * @param period  the period to format\n+     * @return the printed result\n+     */\n+    String print(ReadablePeriod period);\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n         assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n     }\n     \n-    class MockDuration extends AbstractTimePeriod {\n+    class MockDuration extends AbstractPeriod {\n         public MockDuration(long value) {\n             super(value, null);\n         }\n \n     public void testToMutableTimePeriod() {\n         TimePeriod test = new TimePeriod(123L);\n-        MutableTimePeriod result = test.toMutableTimePeriod();\n+        MutablePeriod result = test.toMutableTimePeriod();\n         assertEquals(test, result);\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n     //-----------------------------------------------------------------------\n     public void testConstructor_RI_RP1() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n-        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n+        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstance().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstance().hourOfDay().add(result, 1);\n \n     public void testConstructor_RI_RP2() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n+        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);\n \n     public void testConstructor_RI_RP3() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n-        TimePeriod dur = new TimePeriod(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);\n+        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstance().hourOfDay().add(result, 1);\n         result = ISOChronology.getInstance().millisOfSecond().add(result, 23);\n     }\n \n     public void testConstructor_RI_RP6() throws Throwable {\n-        TimePeriod dur = new TimePeriod(0, 6, 0, 0, 1, 0, 0, 0);\n+        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);\n         result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n     }\n \n     public void testAdd_Object3() {\n-        TimePeriod d = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1);\n+        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d);\n     }\n \n     public void testAdd_Object_int3() {\n-        TimePeriod d = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1);\n+        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d, -2);\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType() {\n-        MutableTimePeriod test = new MutableTimePeriod();\n+        MutablePeriod test = new MutablePeriod();\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n     }\n \n     public void testGetIsPrecise() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutablePeriod test = new MutablePeriod(123L);\n         assertEquals(true, test.isPrecise());\n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isPrecise());\n     }\n \n     public void testGetMethods() {\n-        MutableTimePeriod test = new MutableTimePeriod();\n+        MutablePeriod test = new MutablePeriod();\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getDays());\n     }\n \n     public void testEqualsHashCode() {\n-        MutableTimePeriod test1 = new MutableTimePeriod(123L);\n-        MutableTimePeriod test2 = new MutableTimePeriod(123L);\n+        MutablePeriod test1 = new MutablePeriod(123L);\n+        MutablePeriod test2 = new MutablePeriod(123L);\n         assertEquals(true, test1.equals(test2));\n         assertEquals(true, test2.equals(test1));\n         assertEquals(true, test1.equals(test1));\n         assertEquals(true, test1.hashCode() == test1.hashCode());\n         assertEquals(true, test2.hashCode() == test2.hashCode());\n         \n-        MutableTimePeriod test3 = new MutableTimePeriod(321L);\n+        MutablePeriod test3 = new MutablePeriod(321L);\n         assertEquals(false, test1.equals(test3));\n         assertEquals(false, test2.equals(test3));\n         assertEquals(false, test3.equals(test1));\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockMutablePeriod(123L)));\n-        assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n-    }\n-    \n-    class MockMutablePeriod extends AbstractTimePeriod {\n+        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n+    }\n+    \n+    class MockMutablePeriod extends AbstractPeriod {\n         public MockMutablePeriod(long value) {\n             super(value, null);\n         }\n \n     //-----------------------------------------------------------------------\n     public void testSerialization() throws Exception {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutablePeriod test = new MutablePeriod(123L);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        MutableTimePeriod result = (MutableTimePeriod) ois.readObject();\n+        MutablePeriod result = (MutablePeriod) ois.readObject();\n         ois.close();\n         \n         assertEquals(test, result);\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo4() {\n         long expected = TEST_TIME_NOW;\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 0);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo5() {\n         long expected = TEST_TIME_NOW + 100L;\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        MutablePeriod test = new MutablePeriod(100L);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         Instant added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, 1);\n         assertEquals(expected, mdt.getMillis());\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n     \n     public void testAddIntoRWI3() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.addInto(null, 1);\n             fail();\n     \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n         \n-        test = new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n+        test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n         assertEquals(\"PT0S\", test.toString());\n         \n-        test = new MutableTimePeriod(12345L);\n+        test = new MutablePeriod(12345L);\n         assertEquals(\"PT12.345S\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToTimePeriod() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n-        TimePeriod result = test.toTimePeriod();\n+    public void testToPeriod() {\n+        MutablePeriod test = new MutablePeriod(123L);\n+        Period result = test.toPeriod();\n         assertEquals(test, result);\n     }\n \n-    public void testToMutableTimePeriod() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n-        MutableTimePeriod result = test.toMutableTimePeriod();\n+    public void testToMutablePeriod() {\n+        MutablePeriod test = new MutablePeriod(123L);\n+        MutablePeriod result = test.toMutablePeriod();\n         assertEquals(test, result);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testToDurationMillis() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutablePeriod test = new MutablePeriod(123L);\n         assertEquals(123L, test.toDurationMillis());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.toDurationMillis();\n             fail();\n     }\n \n     public void testToDuration() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n+        MutablePeriod test = new MutablePeriod(123L);\n         assertEquals(new Duration(123L), test.toDuration());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.toDuration();\n             fail();\n \n     //-----------------------------------------------------------------------\n     public void testCopy() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n-        MutableTimePeriod copy = test.copy();\n+        MutablePeriod test = new MutablePeriod(123L);\n+        MutablePeriod copy = test.copy();\n         assertEquals(test.getPeriodType(), copy.getPeriodType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n \n     //-----------------------------------------------------------------------\n     public void testClone() {\n-        MutableTimePeriod test = new MutableTimePeriod(123L);\n-        MutableTimePeriod copy = (MutableTimePeriod) test.clone();\n+        MutablePeriod test = new MutablePeriod(123L);\n+        MutablePeriod copy = (MutablePeriod) test.clone();\n         assertEquals(test.getPeriodType(), copy.getPeriodType());\n         assertEquals(test.isPrecise(), copy.isPrecise());\n         assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n      * Test constructor ()\n      */\n     public void testConstructor1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod();\n+        MutablePeriod test = new MutablePeriod();\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (PeriodType)\n      */\n     public void testConstructor_PeriodType1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_PeriodType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod((PeriodType) null);\n+        MutablePeriod test = new MutablePeriod((PeriodType) null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length);\n+        MutablePeriod test = new MutablePeriod(length);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length);\n+        MutablePeriod test = new MutablePeriod(length);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, null);\n+        MutablePeriod test = new MutablePeriod(length, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getMillisType());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.getMillisType());\n         assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getAllType());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableTimePeriod test = new MutableTimePeriod(length, PeriodType.getAllType().withMillisRemoved());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (4ints)\n      */\n     public void testConstructor_4int1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(5, 6, 7, 8);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int__PeriodType1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_8int__PeriodType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n+        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     public void testConstructor_8int__PeriodType3() throws Throwable {\n         try {\n-            new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n+            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n     public void testConstructor_long_long1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n     public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, null);\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getDayHourType());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutableTimePeriod test = new MutableTimePeriod(dt1, dt2, PeriodType.getAllType());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\");\n+        MutablePeriod test = new MutablePeriod(\"P1Y2M3D\");\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod((Object) null);\n+        MutablePeriod test = new MutablePeriod((Object) null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n-        MutableTimePeriod test = new MutableTimePeriod(base);\n+        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n+        MutablePeriod test = new MutablePeriod(base);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n      * Test constructor (Object,PeriodType)\n      */\n     public void testConstructor_Object_PeriodType1() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType2() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod((Object) null, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType3() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType4() throws Throwable {\n-        MutableTimePeriod test = new MutableTimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n \n     //-----------------------------------------------------------------------\n     public void testAddYears() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(10);\n         assertEquals(11, test.getYears());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(-10);\n         assertEquals(-9, test.getYears());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addYears(0);\n         assertEquals(1, test.getYears());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMonths() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(10);\n         assertEquals(12, test.getMonths());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(-10);\n         assertEquals(-8, test.getMonths());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMonths(0);\n         assertEquals(2, test.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddWeeks() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(10);\n         assertEquals(13, test.getWeeks());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(-10);\n         assertEquals(-7, test.getWeeks());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addWeeks(0);\n         assertEquals(3, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddDays() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(10);\n         assertEquals(14, test.getDays());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(-10);\n         assertEquals(-6, test.getDays());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addDays(0);\n         assertEquals(4, test.getDays());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddHours() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(10);\n         assertEquals(15, test.getHours());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(-10);\n         assertEquals(-5, test.getHours());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addHours(0);\n         assertEquals(5, test.getHours());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMinutes() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(10);\n         assertEquals(16, test.getMinutes());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(-10);\n         assertEquals(-4, test.getMinutes());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMinutes(0);\n         assertEquals(6, test.getMinutes());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddSeconds() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(10);\n         assertEquals(17, test.getSeconds());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(-10);\n         assertEquals(-3, test.getSeconds());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addSeconds(0);\n         assertEquals(7, test.getSeconds());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddMillis() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(10);\n         assertEquals(18, test.getMillis());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(-10);\n         assertEquals(-2, test.getMillis());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.addMillis(0);\n         assertEquals(8, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetYears() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(10);\n         assertEquals(10, test.getYears());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(-10);\n         assertEquals(-10, test.getYears());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setYears(0);\n         assertEquals(0, test.getYears());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMonths() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(10);\n         assertEquals(10, test.getMonths());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(-10);\n         assertEquals(-10, test.getMonths());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMonths(0);\n         assertEquals(0, test.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetWeeks() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(10);\n         assertEquals(10, test.getWeeks());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(-10);\n         assertEquals(-10, test.getWeeks());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setWeeks(0);\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetDays() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(10);\n         assertEquals(10, test.getDays());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(-10);\n         assertEquals(-10, test.getDays());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setDays(0);\n         assertEquals(0, test.getDays());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetHours() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(10);\n         assertEquals(10, test.getHours());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(-10);\n         assertEquals(-10, test.getHours());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setHours(0);\n         assertEquals(0, test.getHours());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMinutes() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(10);\n         assertEquals(10, test.getMinutes());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(-10);\n         assertEquals(-10, test.getMinutes());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMinutes(0);\n         assertEquals(0, test.getMinutes());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetSeconds() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(10);\n         assertEquals(10, test.getSeconds());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(-10);\n         assertEquals(-10, test.getSeconds());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setSeconds(0);\n         assertEquals(0, test.getSeconds());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testSetMillis() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(10);\n         assertEquals(10, test.getMillis());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(-10);\n         assertEquals(-10, test.getMillis());\n         \n-        test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.setMillis(0);\n         assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetTimePeriod_8ints1() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.setTimePeriod(11, 12, 13, 14, 15, 16, 17, 18);\n+    public void testSetPeriod_8ints1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(13, test.getWeeks());\n         assertEquals(18, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_8ints2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n+    public void testSetPeriod_8ints2() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n         try {\n-            test.setTimePeriod(11, 12, 13, 14, 15, 16, 17, 18);\n+            test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         assertEquals(0, test.getYears());\n         assertEquals(100, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_8ints3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n-        test.setTimePeriod(0, 0, 0, 0, 0, 0, 0, 18);\n+    public void testSetPeriod_8ints3() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(18, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_8ints4() {\n-        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n+    public void testSetPeriod_8ints4() {\n+        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n         assertEquals(true, test.isPrecise());\n-        test.setTimePeriod(11, 12, 13, 14, 15, 16, 17, 18);\n+        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n         assertEquals(false, test.isPrecise());\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetTimePeriod_RP1() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.setTimePeriod(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n+    public void testSetPeriod_RP1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(13, test.getWeeks());\n         assertEquals(18, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_RP2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n+    public void testSetPeriod_RP2() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n         try {\n-            test.setTimePeriod(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n+            test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         assertEquals(0, test.getYears());\n         assertEquals(100, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_RP3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getMillisType());\n-        test.setTimePeriod(new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 18));\n+    public void testSetPeriod_RP3() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(18, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_RP4() {\n-        MutableTimePeriod test = new MutableTimePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n+    public void testSetPeriod_RP4() {\n+        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n         assertEquals(true, test.isPrecise());\n-        test.setTimePeriod(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n+        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n         assertEquals(false, test.isPrecise());\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(18, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_RP5() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.setTimePeriod((ReadableTimePeriod) null);\n+    public void testSetPeriod_RP5() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.setPeriod((ReadablePeriod) null);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetTimePeriod_long_long1() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+    public void testSetPeriod_long_long1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long2() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+    public void testSetPeriod_long_long2() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt2.getMillis(), dt1.getMillis());\n+        test.setPeriod(dt2.getMillis(), dt1.getMillis());\n         assertEquals(-1, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         assertEquals(-1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long3() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+    public void testSetPeriod_long_long3() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n-        test.setTimePeriod(dt1.getMillis(), dt1.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt1.getMillis());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoYears() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withYearsRemoved());\n+    public void testSetPeriod_long_long_NoYears() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withYearsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(0, test.getYears());\n         assertEquals(13, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoMonths() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMonthsRemoved());\n+    public void testSetPeriod_long_long_NoMonths() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMonthsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(5, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoWeeks() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withWeeksRemoved());\n+    public void testSetPeriod_long_long_NoWeeks() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withWeeksRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoDays() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withDaysRemoved());\n+    public void testSetPeriod_long_long_NoDays() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withDaysRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoHours() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withHoursRemoved());\n+    public void testSetPeriod_long_long_NoHours() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withHoursRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoMinutes() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMinutesRemoved());\n+    public void testSetPeriod_long_long_NoMinutes() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMinutesRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoSeconds() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withSecondsRemoved());\n+    public void testSetPeriod_long_long_NoSeconds() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withSecondsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1001, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_long_NoMillis() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getAllType().withMillisRemoved());\n+    public void testSetPeriod_long_long_NoMillis() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMillisRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n-        test.setTimePeriod(dt1.getMillis(), dt2.getMillis());\n+        test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetTimePeriod_long1() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.setTimePeriod(100L);\n+    public void testSetPeriod_long1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.setPeriod(100L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(100, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long2() {\n-        MutableTimePeriod test = new MutableTimePeriod();\n-        test.setTimePeriod(\n+    public void testSetPeriod_long2() {\n+        MutablePeriod test = new MutablePeriod();\n+        test.setPeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n         assertEquals(8, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long3() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType());\n-        test.setTimePeriod(\n+    public void testSetPeriod_long3() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());\n+        test.setPeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n         assertEquals(8, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long4() {\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearWeekType());\n-        test.setTimePeriod(\n+    public void testSetPeriod_long4() {\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());\n+        test.setPeriod(\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n         assertEquals(8, test.getMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoYears() {\n+    public void testSetPeriod_long_NoYears() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());\n+        test.setPeriod(ms);\n         assertEquals(0, test.getYears());\n         assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoMonths() {\n+    public void testSetPeriod_long_NoMonths() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoWeeks() {\n+    public void testSetPeriod_long_NoWeeks() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoDays() {\n+    public void testSetPeriod_long_NoDays() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoHours() {\n+    public void testSetPeriod_long_NoHours() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoMinutes() {\n+    public void testSetPeriod_long_NoMinutes() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoSeconds() {\n+    public void testSetPeriod_long_NoSeconds() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(ms, test.toDurationMillis());\n     }\n \n-    public void testSetTimePeriod_long_NoMillis() {\n+    public void testSetPeriod_long_NoMillis() {\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutableTimePeriod test = new MutableTimePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());\n-        test.setTimePeriod(ms);\n+        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());\n+        test.setPeriod(ms);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n \n     //-----------------------------------------------------------------------\n     public void testAdd_8ints1() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        MutablePeriod test = new MutablePeriod(100L);\n         test.add(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testAdd_8ints2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());\n         try {\n             test.add(1, 2, 3, 4, 5, 6, 7, 8);\n             fail();\n \n     //-----------------------------------------------------------------------\n     public void testAdd_long1() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        MutablePeriod test = new MutablePeriod(100L);\n         test.add(100L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testAdd_long2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testAdd_long3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(ms);\n         assertEquals(0, test.getYears());\n     }\n \n     public void testAdd_long4() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add(2100L);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testAdd_RD1() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        MutablePeriod test = new MutablePeriod(100L);\n         test.add(new Duration(100L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testAdd_RD2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n     }\n \n     public void testAdd_RD3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(new Duration(ms));\n         assertEquals(0, test.getYears());\n     }\n \n     public void testAdd_RD4() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add(new Duration(2100L));\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testAdd_RD5() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add((ReadableDuration) null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testAdd_RP1() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n-        test.add(new TimePeriod(100L));\n+        MutablePeriod test = new MutablePeriod(100L);\n+        test.add(new Period(100L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testAdd_RP2() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n-        test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getPreciseAllType()));\n+        MutablePeriod test = new MutablePeriod(100L);  // All type\n+        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getPreciseAllType()));\n         assertEquals(1, test.getYears());  // add field value, ignore different types\n         assertEquals(2, test.getMonths());  // add field value, ignore different types\n         assertEquals(3, test.getWeeks());  // add field value, ignore different types\n     }\n \n     public void testAdd_RP3() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n-        test.add(new TimePeriod(0L));\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        test.add(new Period(0L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testAdd_RP4() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getYearMonthType());\n         try {\n-            test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n+            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         assertEquals(1, test.getYears());\n     }\n \n     public void testAdd_RP5() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.add((ReadableTimePeriod) null);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add((ReadablePeriod) null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n \n     //-----------------------------------------------------------------------\n     public void testAdd_RInterval1() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L);\n+        MutablePeriod test = new MutablePeriod(100L);\n         test.add(new Interval(100L, 200L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testAdd_RInterval2() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8);\n-        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n+        MutablePeriod test = new MutablePeriod(100L);  // All type\n         test.add(new Interval(dt1, dt2));\n         assertEquals(1, test.getYears());  // add field value from interval\n         assertEquals(6, test.getMonths());  // add field value from interval\n     public void testAdd_RInterval3() {\n         DateTime dt1 = new DateTime(2005, 12, 18, 0, 0, 0, 8);\n         DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        MutableTimePeriod test = new MutableTimePeriod(100L);  // All type\n+        MutablePeriod test = new MutablePeriod(100L);  // All type\n         test.add(new Interval(dt1, dt2));\n         assertEquals(-1, test.getYears());  // add field value from interval\n         assertEquals(-6, test.getMonths());  // add field value from interval\n     }\n \n     public void testAdd_RInterval4() {\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         test.add(new Interval(0L, 0L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testAdd_RInterval5() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);\n-        MutableTimePeriod test = new MutableTimePeriod(100L, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());\n         test.add(new Interval(dt1, dt2));\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     }\n \n     public void testAdd_RInterval6() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add((ReadableInterval) null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testNormalize1() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.normalize();\n             fail();\n     }\n \n     public void testNormalize2() {\n-        MutableTimePeriod test = new MutableTimePeriod(1, 14, 0, 36, 29, 66, 67, 1008, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(1, 14, 0, 36, 29, 66, 67, 1008, PeriodType.getPreciseYearMonthType());\n         //   365 + 14*30 + 6 days\n         // extra year created from 12 months of 30 days plus 5 extra days\n         // 2*365 +  2*30 + 1 day\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestPeriodType.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Modifier;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a JUnit test for PeriodType.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestPeriodType extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestPeriodType.class);\n+    }\n+\n+    public TestPeriodType(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertEqualsAfterSerialization(PeriodType type) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(type);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        PeriodType result = (PeriodType) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(type, result);\n+    }\n+\n+    private void assertSameAfterSerialization(PeriodType type) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(type);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        PeriodType result = (PeriodType) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(type, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMillisType() throws Exception {\n+        PeriodType type = PeriodType.getMillisType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getMillisType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"MillisType\", type.getName());\n+        assertEquals(\"PeriodType[MillisType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDayHourType() throws Exception {\n+        PeriodType type = PeriodType.getDayHourType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstance(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getDayHourType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"DayHourType\", type.getName());\n+        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDayHourType_Chronology() throws Exception {\n+        PeriodType type = PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(null));\n+        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getDayHourType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"DayHourType\", type.getName());\n+        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getDayHourType(), type.withChronology(null));\n+        assertSame(PeriodType.getDayHourType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearWeekType() throws Exception {\n+        PeriodType type = PeriodType.getYearWeekType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstance(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getYearWeekType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"YearWeekType\", type.getName());\n+        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearWeekType_Chronology() throws Exception {\n+        PeriodType type = PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(null));\n+        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getYearWeekType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"YearWeekType\", type.getName());\n+        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));\n+        assertSame(PeriodType.getYearWeekType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearMonthType() throws Exception {\n+        PeriodType type = PeriodType.getYearMonthType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstance(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getYearMonthType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"YearMonthType\", type.getName());\n+        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearMonthType_Chronology() throws Exception {\n+        PeriodType type = PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(null));\n+        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getYearMonthType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"YearMonthType\", type.getName());\n+        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));\n+        assertSame(PeriodType.getYearMonthType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAllType() throws Exception {\n+        PeriodType type = PeriodType.getAllType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstance(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getAllType());\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"AllType\", type.getName());\n+        assertEquals(\"PeriodType[AllType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAllType_Chronology() throws Exception {\n+        PeriodType type = PeriodType.getAllType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(null));\n+        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(ISOChronology.getInstance()));\n+        assertEquals(true, type.equals(PeriodType.getAllType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"AllType\", type.getName());\n+        assertEquals(\"PeriodType[AllType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(PeriodType.getAllType(), type.withChronology(null));\n+        assertSame(PeriodType.getAllType(), type.withChronology(ISOChronology.getInstance()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseDayHourType() throws Exception {\n+        PeriodType type = PeriodType.getPreciseDayHourType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseDayHourType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"PreciseDayHourType\", type.getName());\n+        assertEquals(\"PeriodType[PreciseDayHourType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearDayType() throws Exception {\n+        PeriodType type = PeriodType.getPreciseYearDayType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseYearDayType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearDayType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearDayType\", type.getName());\n+        assertEquals(\"PeriodType[PreciseYearDayType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearWeekType() throws Exception {\n+        PeriodType type = PeriodType.getPreciseYearWeekType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseYearWeekType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearWeekType\", type.getName());\n+        assertEquals(\"PeriodType[PreciseYearWeekType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearMonthType() throws Exception {\n+        PeriodType type = PeriodType.getPreciseYearMonthType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseYearMonthType());\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearMonthType\", type.getName());\n+        assertEquals(\"PeriodType[PreciseYearMonthType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseAllType() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.getPreciseAllType());\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"PreciseAllType\", type.getName());\n+        assertEquals(\"PeriodType[PreciseAllType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskYears() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withYearsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withYearsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedYears[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedYears[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMonths() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withMonthsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMonthsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMonthsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMonths[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedMonths[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskWeeks() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withWeeksRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withWeeksRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withWeeksRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedWeeks[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedWeeks[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskDays() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withDaysRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withDaysRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withDaysRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedDays[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedDays[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskHours() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedHours[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedHours[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMinutes() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withMinutesRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMinutesRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMinutesRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMinutes[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedMinutes[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskSeconds() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withSecondsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedSeconds[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedSeconds[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMillis() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withMillisRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(false, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMillisRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMillisRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMillis[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedMillis[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskHoursMinutesSeconds() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n+        assertEquals(\"MaskedHoursMinutesSeconds[PreciseAllType]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedHoursMinutesSeconds[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskWithChronology() throws Exception {\n+        PeriodType type = PeriodType.getAllType().withYearsRemoved();\n+        assertEquals(type, type.withChronology(null));\n+        assertEquals(type, type.withChronology(ISOChronology.getInstance()));\n+        \n+        PeriodType type2 = type.withChronology(CopticChronology.getInstanceUTC());\n+        assertEquals(CopticChronology.getInstanceUTC(), type2.getChronology());\n+        assertEquals(false, type2.years().isSupported());\n+        assertEquals(true, type2.months().isSupported());\n+        assertEquals(true, type2.weeks().isSupported());\n+        assertEquals(true, type2.days().isSupported());\n+        assertEquals(true, type2.hours().isSupported());\n+        assertEquals(true, type2.minutes().isSupported());\n+        assertEquals(true, type2.seconds().isSupported());\n+        assertEquals(true, type2.millis().isSupported());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskTwice1() throws Exception {\n+        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n+        PeriodType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withMonthsRemoved();\n+        type2 = type.withMonthsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withWeeksRemoved();\n+        type2 = type.withWeeksRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withDaysRemoved();\n+        type2 = type.withDaysRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withHoursRemoved();\n+        type2 = type.withHoursRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withMinutesRemoved();\n+        type2 = type.withMinutesRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withSecondsRemoved();\n+        type2 = type.withSecondsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getPreciseAllType().withMillisRemoved();\n+        type2 = type.withMillisRemoved();\n+        assertEquals(true, type == type2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskTwice2() throws Exception {\n+        PeriodType type = PeriodType.getDayHourType();\n+        PeriodType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getDayHourType();\n+        type2 = type.withMonthsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getDayHourType();\n+        type2 = type.withWeeksRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getMillisType();\n+        type2 = type.withDaysRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getMillisType();\n+        type2 = type.withHoursRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getMillisType();\n+        type2 = type.withMinutesRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = PeriodType.getMillisType();\n+        type2 = type.withSecondsRemoved();\n+        assertEquals(true, type == type2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskNullName() throws Exception {\n+        PeriodType type = new MockPeriodTypeWithFields().withYearsRemoved();\n+        assertEquals(\"MaskedYears[]\", type.getName());\n+        assertEquals(\"PeriodType[MaskedYears[]]\", type.toString());\n+    }        \n+\n+    //-----------------------------------------------------------------------\n+    public void testAbstract() throws Exception {\n+        assertEquals(true, Modifier.isPublic(PeriodType.class.getModifiers()));\n+        assertEquals(true, Modifier.isAbstract(PeriodType.class.getModifiers()));\n+        \n+        PeriodType type = new MockPeriodType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(false, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(null, type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(new MockPeriodType()));\n+        assertEquals(false, type.equals(PeriodType.getAllType()));\n+        assertEquals(false, type.equals(null));\n+        assertEquals(false, type.equals(\"six\"));\n+        assertEquals(null, type.getName());\n+        assertEquals(\"PeriodType[]\", type.toString());\n+    }\n+\n+    static class MockPeriodType extends PeriodType {\n+        public String getName() {\n+            return null;\n+        }\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+        public PeriodType withChronology(Chronology chrono) {\n+            return null;\n+        }\n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    }\n+\n+    static class MockPeriodTypeWithFields extends PeriodType {\n+        public String getName() {\n+            return null;\n+        }\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+        public DurationField years() {\n+            return ISOChronology.getInstanceUTC().years();\n+        }\n+        public DurationField months() {\n+            return ISOChronology.getInstanceUTC().months();\n+        }\n+        public PeriodType withChronology(Chronology chrono) {\n+            return null;\n+        }\n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType() {\n-        TimePeriod test = new TimePeriod(0L);\n+        Period test = new Period(0L);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n     }\n \n     public void testGetIsPrecise() {\n-        TimePeriod test = new TimePeriod(123L);\n+        Period test = new Period(123L);\n         assertEquals(true, test.isPrecise());\n-        test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(false, test.isPrecise());\n     }\n \n     public void testGetMethods() {\n-        TimePeriod test = new TimePeriod(0L);\n+        Period test = new Period(0L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     public void testEqualsHashCode() {\n-        TimePeriod test1 = new TimePeriod(123L);\n-        TimePeriod test2 = new TimePeriod(123L);\n+        Period test1 = new Period(123L);\n+        Period test2 = new Period(123L);\n         assertEquals(true, test1.equals(test2));\n         assertEquals(true, test2.equals(test1));\n         assertEquals(true, test1.equals(test1));\n         assertEquals(true, test1.hashCode() == test1.hashCode());\n         assertEquals(true, test2.hashCode() == test2.hashCode());\n         \n-        TimePeriod test3 = new TimePeriod(321L);\n+        Period test3 = new Period(321L);\n         assertEquals(false, test1.equals(test3));\n         assertEquals(false, test2.equals(test3));\n         assertEquals(false, test3.equals(test1));\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockPeriod(123L)));\n-        assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));\n-    }\n-    \n-    class MockPeriod extends AbstractTimePeriod {\n+        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n+    }\n+    \n+    class MockPeriod extends AbstractPeriod {\n         public MockPeriod(long value) {\n             super(value, null);\n         }\n \n     //-----------------------------------------------------------------------\n     public void testSerialization() throws Exception {\n-        TimePeriod test = new TimePeriod(123L);\n+        Period test = new Period(123L);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         ObjectOutputStream oos = new ObjectOutputStream(baos);\n         \n         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ObjectInputStream ois = new ObjectInputStream(bais);\n-        TimePeriod result = (TimePeriod) ois.readObject();\n+        Period result = (Period) ois.readObject();\n         ois.close();\n         \n         assertEquals(test, result);\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo4() {\n         long expected = TEST_TIME_NOW;\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 0);\n         assertEquals(expected, added);\n     }\n     \n     public void testAddTo5() {\n         long expected = TEST_TIME_NOW + 100L;\n-        TimePeriod test = new TimePeriod(100L);\n+        Period test = new Period(100L);\n         long added = test.addTo(TEST_TIME_NOW, 1);\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n         assertEquals(expected, added);\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         Instant added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n         assertEquals(expected, added.getMillis());\n     }\n         expected = ISOChronology.getInstance().seconds().add(expected, 7);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, 1);\n         assertEquals(expected, mdt.getMillis());\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n     \n     public void testAddIntoRWI3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.addInto(null, 1);\n             fail();\n     \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n         \n-        test = new TimePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n+        test = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n         assertEquals(\"PT0S\", test.toString());\n         \n-        test = new TimePeriod(12345L);\n+        test = new Period(12345L);\n         assertEquals(\"PT12.345S\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToTimePeriod() {\n-        TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.toTimePeriod();\n+    public void testToPeriod() {\n+        Period test = new Period(123L);\n+        Period result = test.toPeriod();\n         assertSame(test, result);\n     }\n \n-    public void testToMutableTimePeriod() {\n-        TimePeriod test = new TimePeriod(123L);\n-        MutableTimePeriod result = test.toMutableTimePeriod();\n+    public void testToMutablePeriod() {\n+        Period test = new Period(123L);\n+        MutablePeriod result = test.toMutablePeriod();\n         assertEquals(test, result);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testToDurationMillis() {\n-        TimePeriod test = new TimePeriod(123L);\n+        Period test = new Period(123L);\n         assertEquals(123L, test.toDurationMillis());\n         \n-        test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.toDurationMillis();\n             fail();\n     }\n \n     public void testToDuration() {\n-        TimePeriod test = new TimePeriod(123L);\n+        Period test = new Period(123L);\n         assertEquals(new Duration(123L), test.toDuration());\n         \n-        test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         try {\n             test.toDuration();\n             fail();\n \n     //-----------------------------------------------------------------------\n     public void testWithPeriodTypeRetainDuration1() {\n-        TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withPeriodTypeRetainDuration(PeriodType.getAllType());\n+        Period test = new Period(123L);\n+        Period result = test.withPeriodTypeRetainDuration(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n     public void testWithPeriodTypeRetainDuration2() {\n-        TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n+        Period test = new Period(3123L);\n+        Period result = test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n     }\n \n     public void testWithPeriodTypeRetainDuration3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n             test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n             fail();\n     }\n \n     public void testWithPeriodTypeRetainDuration4() {\n-        TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withPeriodTypeRetainDuration(null);\n+        Period test = new Period(3123L);\n+        Period result = test.withPeriodTypeRetainDuration(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n \n     //-----------------------------------------------------------------------\n     public void testWithPeriodType1() {\n-        TimePeriod test = new TimePeriod(123L);\n-        TimePeriod result = test.withPeriodType(PeriodType.getAllType());\n+        Period test = new Period(123L);\n+        Period result = test.withPeriodType(PeriodType.getAllType());\n         assertSame(test, result);\n     }\n \n     public void testWithPeriodType2() {\n-        TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withPeriodType(PeriodType.getDayHourType());\n+        Period test = new Period(3123L);\n+        Period result = test.withPeriodType(PeriodType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n     }\n \n     public void testWithPeriodType3() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n         try {\n             test.withPeriodType(PeriodType.getDayHourType());\n             fail();\n     }\n \n     public void testWithPeriodType4() {\n-        TimePeriod test = new TimePeriod(3123L);\n-        TimePeriod result = test.withPeriodType(null);\n+        Period test = new Period(3123L);\n+        Period result = test.withPeriodType(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.toDurationMillis());\n     }\n \n     public void testWithPeriodType5() {\n-        TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());\n-        TimePeriod result = test.withPeriodType(PeriodType.getYearMonthType());\n+        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        Period result = test.withPeriodType(PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n \n     //-----------------------------------------------------------------------\n     public void testWithFieldsNormalized1() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());\n-        TimePeriod result = test.withFieldsNormalized();\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());\n+        Period result = test.withFieldsNormalized();\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(3, result.getWeeks());\n     }\n \n     public void testWithFieldsNormalized2() {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());\n         try {\n             test.withFieldsNormalized();\n             fail();\n         assertEquals(111L, test.toDurationMillis());\n     }\n     \n-    static class MockChangeDuration extends TimePeriod {\n+    static class MockChangeDuration extends Period {\n         MockChangeDuration(long duration) {\n             super(duration);\n         }\n         public void testSetDuration_RD() {\n-            setTimePeriod((ReadableDuration) null);\n+            setPeriod((ReadableDuration) null);\n         }\n         public void testSetDuration_ints() {\n-            setTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+            setPeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         }\n         public void testSetTotalMillis_1() {\n-            setTimePeriod(123L);\n+            setPeriod(123L);\n         }\n         public void testSetTotalMillis_2() {\n-            setTimePeriod(123L, 321L);\n+            setPeriod(123L, 321L);\n         }\n         public void testSetYears() {\n             setYears(1);\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length);\n+        Period test = new Period(length);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length);\n+        Period test = new Period(length);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, null);\n+        Period test = new Period(length, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, PeriodType.getMillisType());\n+        Period test = new Period(length, PeriodType.getMillisType());\n         assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, PeriodType.getDayHourType());\n+        Period test = new Period(length, PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        TimePeriod test = new TimePeriod(length, PeriodType.getAllType().withMillisRemoved());\n+        Period test = new Period(length, PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (4ints)\n      */\n     public void testConstructor_4int1() throws Throwable {\n-        TimePeriod test = new TimePeriod(5, 6, 7, 8);\n+        Period test = new Period(5, 6, 7, 8);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int1() throws Throwable {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n      * Test constructor (8ints)\n      */\n     public void testConstructor_8int__PeriodType1() throws Throwable {\n-        TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_8int__PeriodType2() throws Throwable {\n-        TimePeriod test = new TimePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n+        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n \n     public void testConstructor_8int__PeriodType3() throws Throwable {\n         try {\n-            new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n+            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n     public void testConstructor_long_long1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), null);\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2);\n+        Period test = new Period(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2);\n+        Period test = new Period(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2);\n+        Period test = new Period(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        TimePeriod test = new TimePeriod(dt1, dt2);\n+        Period test = new Period(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n     public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        TimePeriod test = new TimePeriod(dt1, dt2);\n+        Period test = new Period(dt1, dt2);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, null);\n+        Period test = new Period(dt1, dt2, null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getDayHourType());\n+        Period test = new Period(dt1, dt2, PeriodType.getDayHourType());\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n+        Period test = new Period(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n         assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType());\n+        Period test = new Period(dt1, dt2, PeriodType.getAllType());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n     public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        TimePeriod test = new TimePeriod(dt1, dt2, PeriodType.getAllType());\n+        Period test = new Period(dt1, dt2, PeriodType.getAllType());\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object1() throws Throwable {\n-        TimePeriod test = new TimePeriod(\"P1Y2M3D\");\n+        Period test = new Period(\"P1Y2M3D\");\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n-        TimePeriod test = new TimePeriod((Object) null);\n+        Period test = new Period((Object) null);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        TimePeriod base = new TimePeriod(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n-        TimePeriod test = new TimePeriod(base);\n+        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n+        Period test = new Period(base);\n         assertEquals(PeriodType.getAllType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object_PeriodType1() throws Throwable {\n-        TimePeriod test = new TimePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n+        Period test = new Period(\"P1Y2M3D\", PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType2() throws Throwable {\n-        TimePeriod test = new TimePeriod((Object) null, PeriodType.getYearMonthType());\n+        Period test = new Period((Object) null, PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType3() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n         assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testConstructor_Object_PeriodType4() throws Throwable {\n-        TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n         assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.Duration;\n-import org.joda.time.ReadableTimePeriod;\n-import org.joda.time.TimePeriod;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.Period;\n import org.joda.time.PeriodType;\n import org.joda.time.Interval;\n import org.joda.time.JodaTimePermission;\n-import org.joda.time.ReadWritableTimePeriod;\n+import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDateTime;\n import org.joda.time.ReadableDuration;\n         c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getDurationConverter(new TimePeriod(PeriodType.getMillisType()));\n+        c = ConverterManager.getInstance().getDurationConverter(new Period(PeriodType.getMillisType()));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n         c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));\n     //-----------------------------------------------------------------------\n     private static int PERIOD_SIZE = 5;\n     \n-    public void testGetTimePeriodConverter() {\n-        TimePeriodConverter c = ConverterManager.getInstance().getTimePeriodConverter(new TimePeriod(PeriodType.getMillisType()));\n-        assertEquals(ReadableTimePeriod.class, c.getSupportedType());\n-        \n-        c = ConverterManager.getInstance().getTimePeriodConverter(new Duration(123L));\n+    public void testGetPeriodConverter() {\n+        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(PeriodType.getMillisType()));\n+        assertEquals(ReadablePeriod.class, c.getSupportedType());\n+        \n+        c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getTimePeriodConverter(new Interval(0L, 1000L));\n+        c = ConverterManager.getInstance().getPeriodConverter(new Interval(0L, 1000L));\n         assertEquals(ReadableInterval.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getTimePeriodConverter(\"\");\n+        c = ConverterManager.getInstance().getPeriodConverter(\"\");\n         assertEquals(String.class, c.getSupportedType());\n         \n-        c = ConverterManager.getInstance().getTimePeriodConverter(null);\n+        c = ConverterManager.getInstance().getPeriodConverter(null);\n         assertEquals(null, c.getSupportedType());\n         \n         try {\n-            ConverterManager.getInstance().getTimePeriodConverter(Boolean.TRUE);\n+            ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n-    public void testGetTimePeriodConverterRemovedNull() {\n-        try {\n-            ConverterManager.getInstance().removeTimePeriodConverter(NullConverter.INSTANCE);\n+    public void testGetPeriodConverterRemovedNull() {\n+        try {\n+            ConverterManager.getInstance().removePeriodConverter(NullConverter.INSTANCE);\n             try {\n-                ConverterManager.getInstance().getTimePeriodConverter(null);\n+                ConverterManager.getInstance().getPeriodConverter(null);\n                 fail();\n             } catch (IllegalArgumentException ex) {}\n         } finally {\n-            ConverterManager.getInstance().addTimePeriodConverter(NullConverter.INSTANCE);\n-        }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetTimePeriodConverters() {\n-        TimePeriodConverter[] array = ConverterManager.getInstance().getTimePeriodConverters();\n+            ConverterManager.getInstance().addPeriodConverter(NullConverter.INSTANCE);\n+        }\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetPeriodConverters() {\n+        PeriodConverter[] array = ConverterManager.getInstance().getPeriodConverters();\n         assertEquals(PERIOD_SIZE, array.length);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testAddTimePeriodConverter1() {\n-        TimePeriodConverter c = new TimePeriodConverter() {\n-            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n+    public void testAddPeriodConverter1() {\n+        PeriodConverter c = new PeriodConverter() {\n+            public void setInto(ReadWritablePeriod duration, Object object) {}\n             public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         try {\n-            TimePeriodConverter removed = ConverterManager.getInstance().addTimePeriodConverter(c);\n+            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);\n             assertEquals(null, removed);\n-            assertEquals(Boolean.class, ConverterManager.getInstance().getTimePeriodConverter(Boolean.TRUE).getSupportedType());\n-            assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getTimePeriodConverters().length);\n-        } finally {\n-            ConverterManager.getInstance().removeTimePeriodConverter(c);\n-        }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testAddTimePeriodConverter2() {\n-        TimePeriodConverter c = new TimePeriodConverter() {\n-            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n+            assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType());\n+            assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length);\n+        } finally {\n+            ConverterManager.getInstance().removePeriodConverter(c);\n+        }\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testAddPeriodConverter2() {\n+        PeriodConverter c = new PeriodConverter() {\n+            public void setInto(ReadWritablePeriod duration, Object object) {}\n             public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return String.class;}\n         };\n         try {\n-            TimePeriodConverter removed = ConverterManager.getInstance().addTimePeriodConverter(c);\n+            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);\n             assertEquals(StringConverter.INSTANCE, removed);\n-            assertEquals(String.class, ConverterManager.getInstance().getTimePeriodConverter(\"\").getSupportedType());\n-            assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-        } finally {\n-            ConverterManager.getInstance().addTimePeriodConverter(StringConverter.INSTANCE);\n-        }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testAddTimePeriodConverter3() {\n-        TimePeriodConverter removed = ConverterManager.getInstance().addTimePeriodConverter(null);\n-        assertEquals(null, removed);\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testAddTimePeriodConverterSecurity() {\n+            assertEquals(String.class, ConverterManager.getInstance().getPeriodConverter(\"\").getSupportedType());\n+            assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+        } finally {\n+            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);\n+        }\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testAddPeriodConverter3() {\n+        PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(null);\n+        assertEquals(null, removed);\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testAddPeriodConverterSecurity() {\n         try {\n             Policy.setPolicy(RESTRICT);\n             System.setSecurityManager(new SecurityManager());\n-            ConverterManager.getInstance().addTimePeriodConverter(StringConverter.INSTANCE);\n+            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);\n             fail();\n         } catch (SecurityException ex) {\n             // ok\n             System.setSecurityManager(null);\n             Policy.setPolicy(ALLOW);\n         }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testRemoveTimePeriodConverter1() {\n-        try {\n-            TimePeriodConverter removed = ConverterManager.getInstance().removeTimePeriodConverter(StringConverter.INSTANCE);\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testRemovePeriodConverter1() {\n+        try {\n+            PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);\n             assertEquals(StringConverter.INSTANCE, removed);\n-            assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getTimePeriodConverters().length);\n-        } finally {\n-            ConverterManager.getInstance().addTimePeriodConverter(StringConverter.INSTANCE);\n-        }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testRemoveTimePeriodConverter2() {\n-        TimePeriodConverter c = new TimePeriodConverter() {\n-            public void setInto(ReadWritableTimePeriod duration, Object object) {}\n+            assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length);\n+        } finally {\n+            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);\n+        }\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testRemovePeriodConverter2() {\n+        PeriodConverter c = new PeriodConverter() {\n+            public void setInto(ReadWritablePeriod duration, Object object) {}\n             public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n-        TimePeriodConverter removed = ConverterManager.getInstance().removeTimePeriodConverter(c);\n-        assertEquals(null, removed);\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testRemoveTimePeriodConverter3() {\n-        TimePeriodConverter removed = ConverterManager.getInstance().removeTimePeriodConverter(null);\n-        assertEquals(null, removed);\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n-    }\n-\n-    public void testRemoveTimePeriodConverterSecurity() {\n+        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c);\n+        assertEquals(null, removed);\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testRemovePeriodConverter3() {\n+        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(null);\n+        assertEquals(null, removed);\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n+    }\n+\n+    public void testRemovePeriodConverterSecurity() {\n         try {\n             Policy.setPolicy(RESTRICT);\n             System.setSecurityManager(new SecurityManager());\n-            ConverterManager.getInstance().removeTimePeriodConverter(StringConverter.INSTANCE);\n+            ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);\n             fail();\n         } catch (SecurityException ex) {\n             // ok\n             System.setSecurityManager(null);\n             Policy.setPolicy(ALLOW);\n         }\n-        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getTimePeriodConverters().length);\n+        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n         LongConverter.INSTANCE.setInto(m, new Long(123L));\n         assertEquals(123L, m.toDurationMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n         NullConverter.INSTANCE.setInto(m, null);\n         assertEquals(0L, m.toDurationMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.Duration;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.ReadableDuration;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n         ReadableDurationConverter.INSTANCE.setInto(m, new Duration(\n             3L * DateTimeConstants.MILLIS_PER_DAY +\n             4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n import org.joda.time.Interval;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.MutableInterval;\n import org.joda.time.ReadableInterval;\n import org.joda.time.chrono.ISOChronology;\n \n     public void testSetInto_Object() throws Exception {\n         Interval i = new Interval(100L, 223L);\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getMillisType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n         ReadableIntervalConverter.INSTANCE.setInto(m, i);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n-import org.joda.time.ReadableTimePeriod;\n-import org.joda.time.TimePeriod;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.Period;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n /**\n- * This class is a Junit unit test for ReadableTimePeriodConverter.\n+ * This class is a Junit unit test for ReadablePeriodConverter.\n  *\n  * @author Stephen Colebourne\n  */\n \n     //-----------------------------------------------------------------------\n     public void testSingleton() throws Exception {\n-        Class cls = ReadableTimePeriodConverter.class;\n+        Class cls = ReadablePeriodConverter.class;\n         assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n         assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n         assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n \n     //-----------------------------------------------------------------------\n     public void testSupportedType() throws Exception {\n-        assertEquals(ReadableTimePeriod.class, ReadableTimePeriodConverter.INSTANCE.getSupportedType());\n+        assertEquals(ReadablePeriod.class, ReadablePeriodConverter.INSTANCE.getSupportedType());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetTimePeriodMillis_Object() throws Exception {\n-        assertEquals(123L, ReadableTimePeriodConverter.INSTANCE.getDurationMillis(new TimePeriod(123L)));\n+    public void testGetPeriodMillis_Object() throws Exception {\n+        assertEquals(123L, ReadablePeriodConverter.INSTANCE.getDurationMillis(new Period(123L)));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n         assertEquals(PeriodType.getAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L), false));\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), false));\n         assertEquals(PeriodType.getPreciseAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L), true));\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), true));\n         assertEquals(PeriodType.getPreciseAllType(),\n-            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L, PeriodType.getAllType()), true));\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getAllType()), true));\n         assertEquals(PeriodType.getPreciseYearDayType(),\n-            ReadableTimePeriodConverter.INSTANCE.getPeriodType(new TimePeriod(123L, PeriodType.getPreciseYearDayType()), true));\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getPreciseYearDayType()), true));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n-        ReadableTimePeriodConverter.INSTANCE.setInto(m, new TimePeriod(0, 0, 0, 3, 0, 4, 0, 5));\n+        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n+        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5));\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n         assertEquals(0, m.getWeeks());\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        assertEquals(\"Converter[org.joda.time.ReadableTimePeriod]\", ReadableTimePeriodConverter.INSTANCE.toString());\n+        assertEquals(\"Converter[org.joda.time.ReadablePeriod]\", ReadablePeriodConverter.INSTANCE.toString());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutableTimePeriod;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.MutableInterval;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutableTimePeriod m = new MutableTimePeriod(PeriodType.getYearMonthType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y6M9DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(6, m.getMonths());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableTimePeriod(PeriodType.getYearWeekType());\n+        m = new MutablePeriod(PeriodType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3DT12H24M48S\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableTimePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.getYearWeekType());\n+        m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());", "timestamp": 1091831531, "metainfo": ""}