{"sha": "583cfd39b4778a5ea15458d237574cb7472574c0", "log": "Refactor Single Era fields to BasicSingleEraDateTimeField   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.field.BaseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * Provides time calculations for the coptic era component of time.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticEraDateTimeField\n+ */\n+final class BasicSingleEraDateTimeField extends BaseDateTimeField {\n+\n+    /**\n+     * Value of the era, which will be the same as DateTimeConstants.CE.\n+     */\n+    private static final int ERA_VALUE = DateTimeConstants.CE;\n+    /**\n+     * Text value of the era.\n+     */\n+    private final String iEraText;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    BasicSingleEraDateTimeField(String text) {\n+        super(DateTimeFieldType.era());\n+        iEraText = text;\n+    }\n+\n+    /** @inheritDoc */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /** @inheritDoc */\n+    public int get(long instant) {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, ERA_VALUE, ERA_VALUE);\n+        return instant;\n+    }\n+\n+    /** @inheritDoc */\n+    public long set(long instant, String text, Locale locale) {\n+        if (iEraText.equals(text) == false && \"1\".equals(text) == false) {\n+            throw new IllegalFieldValueException(DateTimeFieldType.era(), text);\n+        }\n+        return instant;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundCeiling(long instant) {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfCeiling(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfEven(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n+    }\n+\n+    /** @inheritDoc */\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMinimumValue() {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMaximumValue() {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return iEraText;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMaximumTextLength(Locale locale) {\n+        return iEraText.length();\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n      */\n     public static final int BE = DateTimeConstants.CE;\n \n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"BE\");\n+\n     /** Number of years difference in calendars. */\n     private static final int BUDDHIST_OFFSET = 543;\n \n             fields.weekyearOfCentury = new OffsetDateTimeField(\n                 field, DateTimeFieldType.weekyearOfCentury(), 1);\n             \n-            fields.era = ThaiBuddhistEraDateTimeField.INSTANCE;\n+            fields.era = ERA_FIELD;\n         }\n     }\n    \n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n      */\n     public static final int AM = DateTimeConstants.CE;\n \n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"AM\");\n+\n     private static final long MILLIS_PER_YEAR =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n \n     private static final long MILLIS_PER_MONTH =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n-    // The lowest year that can be fully supported.\n+    /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292269337;\n \n-    // The highest year that can be fully supported. Although\n-    // calculateFirstDayOfYearMillis can go higher without overflowing, the\n-    // getYear method overflows when it adds the approximate millis at the\n-    // epoch.\n+    /**\n+     * The highest year that can be fully supported.\n+     * Although calculateFirstDayOfYearMillis can go higher without\n+     * overflowing, the getYear method overflows when it adds the\n+     * approximate millis at the epoch.\n+     */\n     private static final int MAX_YEAR = 292271022;\n \n+    /** Singleton 30 day month field used to build the monthOfYear field. */\n     private static final DurationField cMonthsField;\n \n     /** Singleton instance of a UTC CopticChronology */\n         if (getBase() == null) {\n             super.assemble(fields);\n \n-            fields.year = new BasicYearDateTimeField(this);\n-            fields.years = fields.year.getDurationField();\n-\n             // Coptic, like Julian, has no year zero.\n             fields.year = new SkipDateTimeField(this, fields.year);\n             fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n             \n-            fields.era = CopticEraDateTimeField.INSTANCE;\n+            fields.era = ERA_FIELD;\n             fields.months = cMonthsField;\n             fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);\n             fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);", "timestamp": 1125786755, "metainfo": ""}