{"sha": "5f9b9b675631bda3568df0d47ca305126d426011", "log": "Create BasePartial   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class TimeOfDay extends AbstractPartial implements ReadablePartial, Serializable {\n+public final class TimeOfDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3633353405803318660L;\n      * @param values  the new set of values\n      */\n     TimeOfDay(TimeOfDay partial, int[] values) {\n-        super();\n-        iChronology = partial.iChronology;\n-        iValues = values;\n+        super(partial, values);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.base.*;\n+import org.joda.time.base.BasePartial;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.AbstractPartialFieldProperty;\n \n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class YearMonthDay extends AbstractPartial implements ReadablePartial, Serializable {\n+public final class YearMonthDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 797544782896179L;\n      * @param values  the new set of values\n      */\n     YearMonthDay(YearMonthDay partial, int[] values) {\n-        super();\n-        iChronology = partial.iChronology;\n-        iValues = values;\n+        super(partial, values);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n  */\n package org.joda.time.base;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.Serializable;\n-import java.util.Arrays;\n-\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n-import org.joda.time.chrono.ISOChronology;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.InstantConverter;\n \n /**\n  * AbstractPartial provides a standard base implementation of most methods\n  * Calculations on are performed using a {@link Chronology}.\n  * This chronology is set to be in the UTC time zone for all calculations.\n  * <p>\n+ * The methods on this class uses {@link ReadablePartial#getFieldSize()},\n+ * {@link ReadablePartial#getField(int)} and {@link ReadablePartial#getValue(int)}\n+ * to calculate their results. Subclasses may have a better implementation.\n+ * <p>\n  * AbstractPartial allows subclasses may be mutable and not thread-safe.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public abstract class AbstractPartial implements ReadablePartial, Serializable {\n-\n-    /** Serialization version */\n-    private static final long serialVersionUID = 2353678632973660L;\n-\n-    /** The chronology in use */\n-    protected Chronology iChronology;\n-    /** The values of each field in this partial */\n-    protected int[] iValues;\n-    /** The values of each field in this partial */\n-    protected transient DateTimeField[] iFields;\n-\n-    // Constructors\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a AbstractPartial with the current time, using ISOChronology in\n-     * the default zone to extract the fields.\n-     * <p>\n-     * The constructor uses the default time zone, resulting in the local time\n-     * being initialised. Once the constructor is complete, all further calculations\n-     * are performed without reference to a timezone (by switching to UTC).\n+public abstract class AbstractPartial implements ReadablePartial {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n      */\n     protected AbstractPartial() {\n-        this(DateTimeUtils.currentTimeMillis(), null);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial with the current time, using the specified chronology\n-     * and zone to extract the fields.\n-     * <p>\n-     * The constructor uses the time zone of the chronology specified.\n-     * Once the constructor is complete, all further calculations are performed\n-     * without reference to a timezone (by switching to UTC).\n-     *\n-     * @param chronology  the chronology, null means ISOChronology in the default zone\n-     */\n-    protected AbstractPartial(Chronology chronology) {\n-        this(DateTimeUtils.currentTimeMillis(), chronology);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial extracting the partial fields from the specified\n-     * milliseconds using the ISOChronology in the default zone.\n-     * <p>\n-     * The constructor uses the default time zone, resulting in the local time\n-     * being initialised. Once the constructor is complete, all further calculations\n-     * are performed without reference to a timezone (by switching to UTC).\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n-     */\n-    protected AbstractPartial(long instant) {\n-        this(instant, null);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial extracting the partial fields from the specified\n-     * milliseconds using the chronology provided.\n-     * <p>\n-     * The constructor uses the time zone of the chronology specified.\n-     * Once the constructor is complete, all further calculations are performed\n-     * without reference to a timezone (by switching to UTC).\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n-     * @param chronology  the chronology, null means ISOChronology in the default zone\n-     */\n-    protected AbstractPartial(long instant, Chronology chronology) {\n         super();\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n-        iValues = initValues(instant, chronology);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial from an Object that represents a time.\n-     * <p>\n-     * The recognised object types are defined in\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n-     *\n-     * @param instant  the datetime object, must not be null\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    protected AbstractPartial(Object instant) {\n-        super();\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        long millis = converter.getInstantMillis(instant);\n-        Chronology chronology = converter.getChronology(instant);\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n-        iValues = initValues(millis, chronology);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial from an Object that represents a time, using the\n-     * specified chronology.\n-     * <p>\n-     * The recognised object types are defined in\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n-     * <p>\n-     * The constructor uses the time zone of the chronology specified.\n-     * Once the constructor is complete, all further calculations are performed\n-     * without reference to a timezone (by switching to UTC).\n-     *\n-     * @param instant  the datetime object, must not be null\n-     * @param chronology  the chronology, null means ISOChronology\n-     * @throws IllegalArgumentException if the date is null\n-     */\n-    protected AbstractPartial(Object instant, Chronology chronology) {\n-        super();\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        long millis = converter.getInstantMillis(instant, chronology);\n-        chronology = converter.getChronology(instant, chronology);\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n-        iValues = initValues(millis, chronology);\n-    }\n-\n-    /**\n-     * Constructs a AbstractPartial with specified time field values and chronology.\n-     * <p>\n-     * The constructor uses the time zone of the chronology specified.\n-     * Once the constructor is complete, all further calculations are performed\n-     * without reference to a timezone (by switching to UTC).\n-     *\n-     * @param values  the new set of values\n-     * @param chronology  the chronology, null means ISOChronology in the default zone\n-     */\n-    protected AbstractPartial(int[] values, Chronology chronology) {\n-        super();\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n-        iValues = values;\n-        chronology.validate(this);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Recreates the state of this object after deserialization.\n-     * \n-     * @param in  the input stream\n-     */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        iFields = initFields(iChronology);\n-    }\n-\n-    /**\n-     * Initialize the array of fields.\n-     * The field and value arrays must match.\n-     * \n-     * @param chrono  the chronology to use\n-     */\n-    protected abstract DateTimeField[] initFields(Chronology chrono);\n-\n-    /**\n-     * Initialize the array of values.\n-     * The field and value arrays must match.\n-     * \n-     * @param instant  the instant to use\n-     * @param chrono  the chronology to use\n-     */\n-    protected abstract int[] initValues(long instant, Chronology chrono);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the number of fields in this partial.\n-     * \n-     * @return the field count\n-     */\n-    public int getFieldSize() {\n-        return iFields.length;\n-    }\n-\n-    /**\n-     * Gets the field at the specifed index.\n-     * \n-     * @param index  the index\n-     * @return the field\n-     * @throws IndexOutOfBoundsException if the index is invalid\n-     */\n-    public DateTimeField getField(int index) {\n-        if (index < 0 || index >= iFields.length) {\n-            throw new IllegalArgumentException(Integer.toString(index));\n-        }\n-        return iFields[index];\n-    }\n-\n-    /**\n-     * Gets the value of the field at the specifed index.\n-     * \n-     * @param index  the index\n-     * @return the value\n-     * @throws IndexOutOfBoundsException if the index is invalid\n-     */\n-    public int getValue(int index) {\n-        if (index < 0 || index >= iValues.length) {\n-            throw new IllegalArgumentException(Integer.toString(index));\n-        }\n-        return iValues[index];\n     }\n \n     //-----------------------------------------------------------------------\n      * <p>\n      * The fields are returned largest to smallest, for example Hour, Minute, Second.\n      *\n-     * @return the fields supported (cloned), largest to smallest\n+     * @return the fields supported in an array that may be altered, largest to smallest\n      */\n     public DateTimeField[] getFields() {\n-        return (DateTimeField[]) iFields.clone();\n+        DateTimeField[] result = new DateTimeField[getFieldSize()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getField(i);\n+        }\n+        return result;\n     }\n \n     /**\n      * The fields are returned largest to smallest, for example Hour, Minute, Second.\n      * Each value corresponds to the same array index as <code>getFields()</code>\n      *\n-     * @return the current values of each field (cloned), largest to smallest\n+     * @return the current values of each field in an array that may be altered, largest to smallest\n      */\n     public int[] getValues() {\n-        return (int[]) iValues.clone();\n-    }\n-\n-    /**\n-     * Gets the chronology of the partial which is never null.\n-     * <p>\n-     * The {@link Chronology} is the calculation engine behind the partial and\n-     * provides conversion and validation of the fields in a particular calendar system.\n-     * \n-     * @return the chronology\n-     */\n-    public Chronology getChronology() {\n-        return iChronology;\n+        int[] result = new int[getFieldSize()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getValue(i);\n+        }\n+        return result;\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n     public int get(DateTimeField field) {\n-        for (int i = 0; i < iFields.length; i++) {\n-            if (iFields[i] == field) {\n-                return iValues[i];\n+        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+            if (getField(i) == field) {\n+                return getValue(i);\n             }\n         }\n         throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n      * @return true if the field is supported\n      */\n     public boolean isSupported(DateTimeField field) {\n-        for (int i = 0; i < iFields.length; i++) {\n-            if (iFields[i] == field) {\n+        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+            if (getField(i) == field) {\n                 return true;\n             }\n         }\n      * @return the combined instant in milliseconds\n      */\n     public long resolve(long baseInstant, DateTimeZone zone) {\n-        Chronology chrono = iChronology.withZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n         return resolve(baseInstant, chrono);\n     }\n \n      * @return the combined datetime\n      */\n     public DateTime resolveDateTime(ReadableInstant baseInstant) {\n-        long resolved;\n-        Chronology chrono;\n-        if (baseInstant == null) {\n-            chrono = ISOChronology.getInstance();\n-            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);\n-        } else {\n-            chrono = baseInstant.getChronology();\n-            resolved = resolve(baseInstant.getMillis(), chrono);\n-        }\n+        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n+        long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n+        long resolved = resolve(instantMillis, chrono);\n         return new DateTime(resolved, chrono);\n     }\n \n      */\n     protected long resolve(long baseInstant, Chronology chrono) {\n         long millis = baseInstant;\n-        for (int i = 0; i < iFields.length; i++) {\n-            millis = iFields[i].set(millis, iValues[i]);\n+        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+            millis = getField(i).set(millis, getValue(i));\n         }\n         return millis;\n     }\n      * @return true if fields and values are equal\n      */\n     public boolean equals(Object partial) {\n-        if (partial instanceof AbstractPartial) {\n-            AbstractPartial other = (AbstractPartial) partial;\n-            return Arrays.equals(iValues, other.iValues) &&\n-                   Arrays.equals(iFields, other.iFields) &&\n-                   iChronology == other.iChronology;\n-        } else if (partial instanceof ReadablePartial) {\n-            ReadablePartial other = (ReadablePartial) partial;\n-            return Arrays.equals(iValues, other.getValues()) &&\n-                   Arrays.equals(iFields, other.getFields()) &&\n-                   iChronology == other.getChronology();\n-        }\n-        return false;\n+        if (partial instanceof ReadablePartial == false) {\n+            return false;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (getFieldSize() != other.getFieldSize()) {\n+            return false;\n+        }\n+        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+            if (getValue(i) != other.getValue(i) || getField(i) != other.getField(i)) {\n+                return false;\n+            }\n+        }\n+        return (getChronology() == other.getChronology());\n     }\n \n     /**\n      */\n     public int hashCode() {\n         int total = 157;\n-        for (int i = 0; i < iFields.length; i++) {\n-            total = 23 * total + iValues[i];\n-            total = 23 * total + iFields[i].hashCode();\n-        }\n-        total += iChronology.hashCode();\n+        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+            total = 23 * total + getValue(i);\n+            total = 23 * total + getField(i).hashCode();\n+        }\n+        total += getChronology().hashCode();\n         return total;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * BasePartial is an abstract implementation of ReadablePartial that stores\n+ * data in array and <code>Chronology</code> fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadablePeriod} interface should be used when different \n+ * kinds of partial objects are to be referenced.\n+ * <p>\n+ * BasePartial subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BasePartial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2353678632973660L;\n+\n+    /** The chronology in use */\n+    private Chronology iChronology;\n+    /** The values of each field in this partial */\n+    private int[] iValues;\n+    /** The values of each field in this partial */\n+    private transient DateTimeField[] iFields;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a AbstractPartial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    protected BasePartial() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected BasePartial(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    protected BasePartial(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected BasePartial(long instant, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    protected BasePartial(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant);\n+        Chronology chronology = converter.getChronology(instant);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    protected BasePartial(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param values  the new set of values\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected BasePartial(int[] values, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        chronology.validate(this, values);\n+        iValues = (int[]) values.clone();\n+    }\n+\n+    /**\n+     * Private constructor to be used by subclasses only which performs no validation.\n+     * <p>\n+     * Data is assigned (not cloned) to the new instance.\n+     * Thus, two BasePartials will share the same field array.\n+     *\n+     * @param other  the other partial to use to extract the fields and chronology\n+     * @param values  the new set of values, not cloned\n+     */\n+    protected BasePartial(BasePartial other, int[] values) {\n+        super();\n+        iFields = other.iFields;\n+        iValues = values;\n+        iChronology = other.iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Recreates the state of this object after deserialization.\n+     * \n+     * @param in  the input stream\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        iFields = initFields(iChronology);\n+    }\n+\n+    /**\n+     * Initialize the array of fields.\n+     * The field and value arrays must match.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract DateTimeField[] initFields(Chronology chrono);\n+\n+    /**\n+     * Initialize the array of values.\n+     * The field and value arrays must match.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract int[] initValues(long instant, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return iFields.length;\n+    }\n+\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        return iFields[index];\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        return (DateTimeField[]) iFields.clone();\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @param value  the value to set\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void setValue(int index, int value) {\n+        DateTimeField field = getField(index);\n+        iValues = field.set(this, index, iValues, value);\n+    }\n+\n+    /**\n+     * Sets the values of all fields.\n+     * \n+     * @param values  the array of values\n+     */\n+    protected void setValues(int[] values) {\n+        getChronology().validate(this, values);\n+        iValues = values;\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/MockPartial.java\n+++ b/JodaTime/src/test/org/joda/time/MockPartial.java\n         return ISOChronology.getInstance();\n     }\n     public int getFieldSize() {\n-        return 0;\n+        return getFields().length;\n     }\n     public DateTimeField getField(int index) {\n-        return null;\n+        return getFields()[index];\n     }\n     public int getValue(int index) {\n-        return 0;\n+        return getValues()[index];\n     }\n     public int get(DateTimeField field) {\n         return 0;\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n         assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));\n         try {\n             test.getField(-1);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n         try {\n             test.getField(5);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n     }\n \n     public void testGetFields() {\n         assertEquals(40, test.getValue(3));\n         try {\n             test.getValue(-1);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n         try {\n             test.getValue(5);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n     }\n \n     public void testGetValues() {\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n         assertSame(ISOChronology.getInstance().dayOfMonth(), test.getField(2));\n         try {\n             test.getField(-1);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n         try {\n             test.getField(3);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n     }\n \n     public void testGetFields() {\n         assertEquals(9, test.getValue(2));\n         try {\n             test.getValue(-1);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n         try {\n             test.getValue(3);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (IndexOutOfBoundsException ex) {}\n     }\n \n     public void testGetValues() {", "timestamp": 1093185844, "metainfo": ""}