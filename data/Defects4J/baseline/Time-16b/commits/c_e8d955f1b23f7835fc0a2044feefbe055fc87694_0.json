{"sha": "e8d955f1b23f7835fc0a2044feefbe055fc87694", "log": "Create BaseInterval   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n \n import java.io.Serializable;\n \n-import org.joda.time.base.*;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.IntervalConverter;\n-import org.joda.time.field.FieldUtils;\n+import org.joda.time.base.BaseInterval;\n \n /**\n  * Interval is the standard implementation of an immutable time interval.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class Interval\n-        extends AbstractInterval\n+public final class Interval\n+        extends BaseInterval\n         implements ReadableInterval, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 4922451897541386752L;\n \n-    /** The start of the period */\n-    private final long iStartMillis;\n-    /** The end of the period */\n-    private final long iEndMillis;\n-\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public Interval(long startInstant, long endInstant) {\n-        super();\n-        checkInterval(startInstant, endInstant);\n-        iStartMillis = startInstant;\n-        iEndMillis = endInstant;\n+        super(startInstant, endInstant);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public Interval(ReadableInstant start, ReadableInstant end) {\n-        super();\n-        if (start == null && end == null) {\n-            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iStartMillis = DateTimeUtils.getInstantMillis(start);\n-            iEndMillis = DateTimeUtils.getInstantMillis(end);\n-            checkInterval(iStartMillis, iEndMillis);\n-        }\n+        super(start, end);\n     }\n \n     /**\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public Interval(ReadableInstant start, ReadableDuration duration) {\n-        super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n-        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(start, duration);\n     }\n \n     /**\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public Interval(ReadableDuration duration, ReadableInstant end) {\n-        super();\n-        iEndMillis = DateTimeUtils.getInstantMillis(end);\n-        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n-        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(duration, end);\n     }\n \n     /**\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public Interval(ReadableInstant start, ReadablePeriod period) {\n-        super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        if (period == null) {\n-            iEndMillis = iStartMillis;\n-        } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(start, null);\n-            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(start, period);\n     }\n \n     /**\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public Interval(ReadablePeriod period, ReadableInstant end) {\n-        super();\n-        iEndMillis = DateTimeUtils.getInstantMillis(end);\n-        if (period == null) {\n-            iStartMillis = iEndMillis;\n-        } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(end, null);\n-            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(period, end);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public Interval(Object interval) {\n-        super();\n-        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n-        long[] millis = converter.getIntervalMillis(interval);\n-        iStartMillis = millis[0];\n-        iEndMillis = millis[1];\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the start of this time interval which is inclusive.\n-     *\n-     * @return the start of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public final long getStartMillis() {\n-        return iStartMillis;\n-    }\n-\n-    /**\n-     * Gets the end of this time interval which is exclusive.\n-     *\n-     * @return the end of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public final long getEndMillis() {\n-        return iEndMillis;\n+        super(interval);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return an interval with the end from this interval and the specified start\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public final Interval withStartMillis(long startInstant) {\n+    public Interval withStartMillis(long startInstant) {\n         if (startInstant == getStartMillis()) {\n             return this;\n         }\n      * @return an interval with the end from this interval and the specified start\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public final Interval withStartInstant(ReadableInstant start) {\n+    public Interval withStartInstant(ReadableInstant start) {\n         long startMillis = DateTimeUtils.getInstantMillis(start);\n         return withStartMillis(startMillis);\n     }\n      * @return an interval with the start from this interval and the specified end\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public final Interval withEndMillis(long endInstant) {\n+    public Interval withEndMillis(long endInstant) {\n         if (endInstant == getEndMillis()) {\n             return this;\n         }\n      * @return an interval with the start from this interval and the specified end\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public final Interval withEndInstant(ReadableInstant end) {\n+    public Interval withEndInstant(ReadableInstant end) {\n         long endMillis = DateTimeUtils.getInstantMillis(end);\n         return withEndMillis(endMillis);\n     }\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n \n import java.io.Serializable;\n \n-import org.joda.time.base.*;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.base.BaseInterval;\n import org.joda.time.field.FieldUtils;\n \n /**\n  * @since 1.0\n  */\n public class MutableInterval\n-        extends AbstractInterval\n+        extends BaseInterval\n         implements ReadWritableInterval, Cloneable, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -5982824024992428470L;\n \n-    /** The start of the period */\n-    private long iStartMillis;\n-    /** The end of the period */\n-    private long iEndMillis;\n-\n     /**\n      * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.\n      */\n     public MutableInterval() {\n-        super();\n+        super(0L, 0L);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public MutableInterval(long startInstant, long endInstant) {\n-        super();\n-        checkInterval(startInstant, endInstant);\n-        iStartMillis = startInstant;\n-        iEndMillis = endInstant;\n+        super(startInstant, endInstant);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public MutableInterval(ReadableInstant start, ReadableInstant end) {\n-        super();\n-        if (start == null && end == null) {\n-            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iStartMillis = DateTimeUtils.getInstantMillis(start);\n-            iEndMillis = DateTimeUtils.getInstantMillis(end);\n-            checkInterval(iStartMillis, iEndMillis);\n-        }\n+        super(start, end);\n     }\n \n     /**\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n-        super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n-        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(start, duration);\n     }\n \n     /**\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n-        super();\n-        iEndMillis = DateTimeUtils.getInstantMillis(end);\n-        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n-        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(duration, end);\n     }\n \n     /**\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n-        super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        if (period == null) {\n-            iEndMillis = iStartMillis;\n-        } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(start, null);\n-            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(start, period);\n     }\n \n     /**\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n-        super();\n-        iEndMillis = DateTimeUtils.getInstantMillis(end);\n-        if (period == null) {\n-            iStartMillis = iEndMillis;\n-        } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(end, null);\n-            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n+        super(period, end);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public MutableInterval(Object interval) {\n-        super();\n-        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n-        converter.setInto(this, interval);\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the start of this time interval which is inclusive.\n-     *\n-     * @return the start of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public long getStartMillis() {\n-        return iStartMillis;\n-    }\n-\n-    /** \n-     * Gets the end of this time interval which is exclusive.\n-     *\n-     * @return the end of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public long getEndMillis() {\n-        return iEndMillis;\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        super(interval);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // NOTE: All updates go via setInterval(long,long), setStartMillis(long)\n+    // or setEndMillis(long) on this class\n+    \n     /**\n      * Sets this interval from two millisecond instants.\n-     * <p>\n-     * All updates ocurr via this method (exclusing the constructors).\n      *\n      * @param startInstant  the start of the time interval\n      * @param endInstant  the start of the time interval\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setInterval(long startInstant, long endInstant) {\n-        if (startInstant != iStartMillis || endInstant != iEndMillis) {\n-            checkInterval(startInstant, endInstant);\n-            iStartMillis = startInstant;\n-            iEndMillis = endInstant;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        super.setInterval(startInstant, endInstant);\n+    }\n+\n     /**\n      * Sets this interval to be the same as another.\n      *\n      */\n     public void setInterval(ReadableInstant start, ReadableInstant end) {\n         if (start == null && end == null) {\n-            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+            long now = DateTimeUtils.currentTimeMillis();\n+            setInterval(now, now);\n         } else {\n             long startMillis = DateTimeUtils.getInstantMillis(start);\n             long endMillis = DateTimeUtils.getInstantMillis(end);\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setStartMillis(long startInstant) {\n-        setInterval(startInstant, iEndMillis);\n+        super.setStartMillis(startInstant);\n     }\n \n     /**\n      */\n     public void setStartInstant(ReadableInstant start) {\n         long startMillis = DateTimeUtils.getInstantMillis(start);\n-        setInterval(startMillis, iEndMillis);\n+        setStartMillis(startMillis);\n     }\n \n     //-----------------------------------------------------------------------\n     /** \n      * Sets the end of this time interval.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is public and final. This also ensures that\n-     * all lower subclasses are also immutable.\n      *\n      * @param endInstant  the end of the time interval,\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setEndMillis(long endInstant) {\n-        setInterval(iStartMillis, endInstant);\n+        super.setEndMillis(endInstant);\n     }\n \n     /** \n      */\n     public void setEndInstant(ReadableInstant end) {\n         long endMillis = DateTimeUtils.getInstantMillis(end);\n-        setInterval(iStartMillis, endMillis);\n+        setEndMillis(endMillis);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n      *\n      * @return the start of the time interval\n      */\n-    public final Instant getStartInstant() {\n+    public Instant getStartInstant() {\n         return new Instant(getStartMillis());\n     }\n \n      *\n      * @return the end of the time interval\n      */\n-    public final Instant getEndInstant() {\n+    public Instant getEndInstant() {\n         return new Instant(getEndMillis());\n     }\n \n      * @return the duration of the time interval in milliseconds\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public final long getDurationMillis() {\n+    public long getDurationMillis() {\n         return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n     }\n \n      * @return the duration of the time interval\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public final Duration getDuration() {\n+    public Duration getDuration() {\n         long durMillis = getDurationMillis();\n         if (durMillis == 0) {\n             return Duration.ZERO;\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval contains the millisecond\n      */\n-    public final boolean contains(long millisInstant) {\n+    public boolean contains(long millisInstant) {\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n         return (millisInstant >= thisStart && millisInstant < thisEnd);\n      * \n      * @return true if this time interval contains the current instant\n      */\n-    public final boolean containsNow() {\n+    public boolean containsNow() {\n         return contains(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n      */\n-    public final boolean contains(ReadableInstant instant) {\n+    public boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n             return contains(DateTimeUtils.currentTimeMillis());\n         }\n      * @return true if this time interval contains the time interval\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public final boolean contains(ReadableInterval interval) {\n+    public boolean contains(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      * @return true if the time intervals overlap\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public final boolean overlaps(ReadableInterval interval) {\n+    public boolean overlaps(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is before the instant\n      */\n-    public final boolean isBefore(long millisInstant) {\n+    public boolean isBefore(long millisInstant) {\n         return (getEndMillis() <= millisInstant);\n     }\n \n      * \n      * @return true if this time interval is before the current instant\n      */\n-    public final boolean isBeforeNow() {\n+    public boolean isBeforeNow() {\n         return isBefore(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is before the instant\n      */\n-    public final boolean isBefore(ReadableInstant instant) {\n+    public boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n             return isBefore(DateTimeUtils.currentTimeMillis());\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is after the instant\n      */\n-    public final boolean isAfter(long millisInstant) {\n+    public boolean isAfter(long millisInstant) {\n         return (getStartMillis() > millisInstant);\n     }\n \n      * \n      * @return true if this time interval is after the current instant\n      */\n-    public final boolean isAfterNow() {\n+    public boolean isAfterNow() {\n         return isAfter(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is after the instant\n      */\n-    public final boolean isAfter(ReadableInstant instant) {\n+    public boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n             return isAfter(DateTimeUtils.currentTimeMillis());\n         }\n      *\n      * @return the interval as an Interval object\n      */\n-    public final Interval toInterval() {\n+    public Interval toInterval() {\n         if (this instanceof Interval) {\n             return (Interval) this;\n         }\n      *\n      * @return the time interval as a MutableInterval object\n      */\n-    public final MutableInterval toMutableInterval() {\n+    public MutableInterval toMutableInterval() {\n         return new MutableInterval(getStartMillis(), getEndMillis());\n     }\n \n      *\n      * @return a time period derived from the interval\n      */\n-    public final Period toPeriod() {\n+    public Period toPeriod() {\n         return new Period(getStartMillis(), getEndMillis());\n     }\n \n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public final Period toPeriod(PeriodType type) {\n+    public Period toPeriod(PeriodType type) {\n         return new Period(getStartMillis(), getEndMillis(), type);\n     }\n \n      * @param readableInterval  a readable interval to check against\n      * @return true if the start and end millis are equal\n      */\n-    public final boolean equals(Object readableInterval) {\n+    public boolean equals(Object readableInterval) {\n         if (this == readableInterval) {\n             return true;\n         }\n      *\n      * @return suitable hashcode\n      */\n-    public final int hashCode() {\n+    public int hashCode() {\n         long start = getStartMillis();\n         long end = getEndMillis();\n         int result = 97;\n      *\n      * @return re-parsable string\n      */\n-    public final String toString() {\n+    public String toString() {\n         DateTimePrinter printer =\n             ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())\n             .dateHourMinuteSecondFraction();\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BaseInterval.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadWritableInterval;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseInterval is an abstract implementation of ReadableInterval that stores\n+ * data in two <code>long</code> millisecond fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableInterval} interface should be used when different \n+ * kinds of interval objects are to be referenced.\n+ * <p>\n+ * BaseInterval subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Sean Geoghegan\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class BaseInterval\n+        extends AbstractInterval\n+        implements ReadableInterval, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 576586928732749278L;\n+\n+    /** The start of the interval */\n+    private long iStartMillis;\n+    /** The end of the interval */\n+    private long iEndMillis;\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public BaseInterval(long startInstant, long endInstant) {\n+        super();\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public BaseInterval(ReadableInstant start, ReadableInstant end) {\n+        super();\n+        if (start == null && end == null) {\n+            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iStartMillis = DateTimeUtils.getInstantMillis(start);\n+            iEndMillis = DateTimeUtils.getInstantMillis(end);\n+            checkInterval(iStartMillis, iEndMillis);\n+        }\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public BaseInterval(ReadableInstant start, ReadableDuration duration) {\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public BaseInterval(ReadableDuration duration, ReadableInstant end) {\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public BaseInterval(ReadableInstant start, ReadablePeriod period) {\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        if (period == null) {\n+            iEndMillis = iStartMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(start, null);\n+            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public BaseInterval(ReadablePeriod period, ReadableInstant end) {\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        if (period == null) {\n+            iStartMillis = iEndMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(end, null);\n+            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null or invalid\n+     */\n+    public BaseInterval(Object interval) {\n+        super();\n+        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n+        if (this instanceof ReadWritableInterval) {\n+            converter.setInto((ReadWritableInterval) this, interval);\n+        } else {\n+            long[] millis = converter.getIntervalMillis(interval);\n+            iStartMillis = millis[0];\n+            iEndMillis = millis[1];\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this time interval which is inclusive.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getStartMillis() {\n+        return iStartMillis;\n+    }\n+\n+    /**\n+     * Gets the end of this time interval which is exclusive.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getEndMillis() {\n+        return iEndMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the start of this time interval which is inclusive.\n+     *\n+     * @param startInstant  the new start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    protected void setStartMillis(long startInstant) {\n+        checkInterval(startInstant, iEndMillis);\n+        iStartMillis = startInstant;\n+    }\n+\n+    /**\n+     * Sets the end of this time interval which is exclusive.\n+     *\n+     * @param endInstant  the new end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    protected void setEndMillis(long endInstant) {\n+        checkInterval(iStartMillis, endInstant);\n+        iEndMillis = endInstant;\n+    }\n+\n+    /**\n+     * Sets this interval from two millisecond instants.\n+     *\n+     * @param startInstant  the start of the time interval\n+     * @param endInstant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected void setInterval(long startInstant, long endInstant) {\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n+    }\n+\n+}", "timestamp": 1093043996, "metainfo": ""}