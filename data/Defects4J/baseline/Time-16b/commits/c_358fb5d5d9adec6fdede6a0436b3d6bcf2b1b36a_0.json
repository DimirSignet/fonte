{"sha": "358fb5d5d9adec6fdede6a0436b3d6bcf2b1b36a", "log": "Intervals are back.   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractInterval provides the common behaviour for time intervals.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInterval} interface should be used when different \n+ * kinds of intervals are to be referenced.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractInterval implements ReadableInterval {\n+    \n+    /** The start of the period */\n+    private long iStartMillis;\n+    /** The end of the period */\n+    private long iEndMillis;\n+\n+    /** Cache the start instant */\n+    private transient Instant iStartInstant;\n+    /** Cache the end instant */\n+    private transient Instant iEndInstant;\n+    /** Cache the duration */\n+    private transient Duration iDuration;\n+    \n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public AbstractInterval(ReadableInterval interval) {\n+        super();\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"The interval must not be null\");\n+        }\n+        iStartMillis = interval.getStartMillis();\n+        iEndMillis = interval.getEndMillis();\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     */\n+    public AbstractInterval(long startInstant, long endInstant) {\n+        super();\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param start  start of this interval\n+     * @param end  end of this interval\n+     * @throws IllegalArgumentException if either instant is null\n+     */\n+    public AbstractInterval(ReadableInstant start, ReadableInstant end) {\n+        super();\n+        if (start == null) {\n+            throw new IllegalArgumentException(\"The start instant must not be null\");\n+        }\n+        if (end == null) {\n+            throw new IllegalArgumentException(\"The end instant must not be null\");\n+        }\n+        iStartMillis = start.getMillis();\n+        if (start instanceof Instant) {\n+            iStartInstant = (Instant) start;\n+        }\n+        iEndMillis = end.getMillis();\n+        if (end instanceof Instant) {\n+            iEndInstant = (Instant) end;\n+        }\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval\n+     * @param duration  duration of this interval\n+     */\n+    public AbstractInterval(ReadableInstant start, ReadableDuration duration) {\n+        super();\n+        if (start == null) {\n+            throw new IllegalArgumentException(\"The start instant must not be null\");\n+        }\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        iStartMillis = start.getMillis();\n+        if (start instanceof Instant) {\n+            iStartInstant = (Instant) start;\n+        }\n+        iEndMillis = duration.addTo((ReadableInstant) start, 1).getMillis();\n+    }\n+    \n+    /**\n+     * Constructs an interval from a duration and an end instant.\n+     * \n+     * @param duration duration of this interval\n+     * @param end end of this interval\n+     */\n+    public AbstractInterval(ReadableDuration duration, ReadableInstant end) {\n+        super();\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        if (end == null) {\n+            throw new IllegalArgumentException(\"The end instant must not be null\");\n+        }\n+        iEndMillis = end.getMillis();\n+        if (end instanceof Instant) {\n+            iEndInstant = (Instant) end;\n+        }\n+        iStartMillis = duration.addTo((ReadableInstant) end, -1).getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this interval as the number of milliseconds elapsed\n+     * since 1970-01-01T00:00:00Z.\n+     *\n+     * @return the start of the interval\n+     */\n+    public long getStartMillis() {\n+        return iStartMillis;\n+    }\n+\n+    /**\n+     * Gets the start of this time interval as an Instant.\n+     *\n+     * @return the start of the time interval\n+     */\n+    public Instant getStartInstant() {\n+        if (iStartInstant == null) {\n+            iStartInstant = new Instant(getStartMillis());\n+        }\n+        return iStartInstant;\n+    }\n+\n+    /**\n+     * Gets the end of this interval as the number of milliseconds elapsed\n+     * since 1970-01-01T00:00:00Z.\n+     *\n+     * @return the start of the interval\n+     */\n+    public long getEndMillis() {\n+        return iEndMillis;\n+    }\n+\n+    /**\n+     * Gets the end of this time interval as an Instant.\n+     *\n+     * @return the end of the time interval\n+     */\n+    public Instant getEndInstant() {\n+        if (iEndInstant == null) {\n+            iEndInstant = new Instant(getEndMillis());\n+        }\n+        return iEndInstant;\n+    }\n+\n+    /**\n+     * Gets the duration of this time interval in milliseconds.\n+     * <p>\n+     * The duration returned will always be precise because it is relative to\n+     * a known date.\n+     *\n+     * @return the duration of the time interval in milliseconds\n+     */\n+    public long getDurationMillis() {\n+        return (getEndMillis() - getStartMillis());\n+    }\n+\n+    /**\n+     * Gets the duration of this time interval.\n+     * <p>\n+     * The duration returned will always be precise because it is relative to\n+     * a known date.\n+     *\n+     * @return the duration of the time interval\n+     */\n+    public Duration getDuration() {\n+        if (iDuration == null) {\n+            iDuration = new Duration(DurationType.getDayHourType(),\n+                                     getEndMillis() - getStartMillis());\n+        }\n+        return iDuration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval contains the millisecond\n+     */\n+    public boolean contains(long millisInstant) {\n+        return (millisInstant >= getStartMillis() && millisInstant <= getEndMillis());\n+    }\n+    \n+    /**\n+     * Does this time interval contain the specified instant.\n+     * \n+     * @param instant  the instant\n+     * @return true if this time interval contains the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean contains(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return contains(instant.getMillis());\n+    }\n+    \n+    /**\n+     * Does this time interval contain the specified time interval completely.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if this interval contains the time interval\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public boolean contains(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"The time interval must not be null\");\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        return \n+            (otherStart >= getStartMillis() && otherStart <= getEndMillis())\n+            && (otherEnd >= getStartMillis() && otherEnd <= getEndMillis());\n+    }\n+    \n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * The intervals overlap if at least some of the time interval is in common.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if the time intervals overlap\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public boolean overlaps(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"The time interval must not be null\");\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        return \n+            (otherStart >= getStartMillis() && otherStart <= getEndMillis())\n+            || (otherEnd >= getStartMillis() && otherEnd <= getEndMillis());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval before the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is before the instant\n+     */\n+    public boolean isBefore(long millisInstant) {\n+        return (getStartMillis() < millisInstant && getEndMillis() < millisInstant);\n+    }\n+    \n+    /**\n+     * Is this time interval before the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return true if this time interval is before the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean isBefore(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return isBefore(instant.getMillis());\n+    }\n+    \n+    /**\n+     * Is this time interval after the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is after the instant\n+     */\n+    public boolean isAfter(long millisInstant) {\n+        return (getStartMillis() > millisInstant && getEndMillis() > millisInstant);\n+    }\n+    \n+    /**\n+     * Is this time interval after the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return true if this time interval is after the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean isAfter(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return isAfter(instant.getMillis());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the object as an Interval.\n+     * \n+     * @return an immutable interval object\n+     */\n+    public Interval toInterval() {\n+        if (this instanceof Interval) {\n+            return (Interval) this;\n+        }\n+        return new Interval(this);\n+    }\n+\n+    /**\n+     * Get the object as a MutableInterval.\n+     * \n+     * @return a mutable interval object\n+     */\n+    public MutableInterval toMutableInterval() {\n+        return new MutableInterval(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on start and end millis. All ReadableInterval instances are accepted.\n+     * <p>\n+     * To compare the duration of two time intervals, use {@link #getDuration()}\n+     * to get the durations and compare those.\n+     *\n+     * @param readableInterval  a readable interval to check against\n+     * @return true if the start and end millis are equal\n+     */\n+    public boolean equals(Object readableInterval) {\n+        if (this == readableInterval) {\n+            return true;\n+        }\n+        if (readableInterval instanceof ReadableInterval == false) {\n+            return false;\n+        }\n+        ReadableInterval other = (ReadableInterval) readableInterval;\n+        return \n+            (getStartMillis() == other.getStartMillis() \n+            && getEndMillis() == other.getEndMillis());\n+    }\n+\n+    /**\n+     * Hashcode compatable with equals method.\n+     *\n+     * @return suitable hashcode\n+     */\n+    public int hashCode() {\n+        int result = 97;\n+        result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));\n+        result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));\n+        return result;\n+    }\n+\n+    /**\n+     * Output a string in ISO8601 interval format.\n+     *\n+     * @return re-parsable string\n+     */\n+    public String toString() {\n+        DateTimePrinter printer =\n+            ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())\n+            .dateHourMinuteSecondFraction();\n+        StringBuffer buf = new StringBuffer(48);\n+        printer.printTo(buf, getStartMillis());\n+        buf.append('/');\n+        printer.printTo(buf, getEndMillis());\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the start of this time interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @param millisInstant  the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    protected void setStartMillis(long millisInstant) {\n+        iStartMillis = millisInstant;\n+        iStartInstant = null;\n+        iDuration = null;\n+    }\n+\n+    /** \n+     * Sets the end of this time interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @param millisInstant  the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    protected void setEndMillis(long millisInstant) {\n+        iEndMillis = millisInstant;\n+        iEndInstant = null;\n+        iDuration = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.text.ParseException;\n+\n+/**\n+ * Interval is the standard implementation of an immutable time interval\n+ * class. The duration of the time interval is always a precise amount of\n+ * milliseconds even if a variable length duration was passed into the\n+ * constructor.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Sean Geoghegan\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class Interval extends AbstractInterval\n+        implements ReadableInterval, Serializable {\n+\n+    static final long serialVersionUID = 4922451897541386752L;\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public Interval(ReadableInterval interval) {\n+        super(interval);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     */\n+    public Interval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param start  start of this interval\n+     * @param end  end of this interval\n+     * @throws IllegalArgumentException if either instant is null\n+     */\n+    public Interval(ReadableInstant start, ReadableInstant end) {\n+        super(start, end);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval\n+     * @param duration  duration of this interval\n+     */\n+    public Interval(ReadableInstant start, ReadableDuration duration) {\n+        super(start, duration);\n+    }\n+\n+    /**\n+     * Constructs an interval from a duration and an end instant.\n+     * \n+     * @param duration duration of this interval\n+     * @param end end of this interval\n+     */\n+    public Interval(ReadableDuration duration, ReadableInstant end) {\n+        super(duration, end);\n+    }\n+\n+    /** \n+     * Creates new TimePeriod.\n+     *\n+     * TimePeriod is created from an ISO formatted\n+     * TimePeriod string. Only accepts strings in the\n+     * ISO_STANDARD_BASIC_FORMAT pattern.\n+     *\n+     * @param period an ISO interval string\n+     */\n+    /* TODO\n+    public Interval(String period) throws ParseException {\n+        Interval temp = (Interval)TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(period);\n+        iStartMillis = temp.iStartMillis;\n+        iEndMillis = temp.iEndMillis;\n+    }\n+    */\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected void setStartMillis(long millisInstant) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected void setEndMillis(long millisInstant) {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.text.ParseException;\n+\n+/**\n+ * MutableInterval is the standard implementation of a mutable time interval.\n+ * <p>\n+ * If performing significant calculations on an interval, it may be faster to\n+ * convert an Interval object to a MutableInterval one.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class MutableInterval extends AbstractInterval\n+        implements ReadWritableInterval, Serializable {\n+\n+    static final long serialVersionUID = -5982824024992428470L;\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public MutableInterval(ReadableInterval interval) {\n+        super(interval);\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from\n+     *  1970-01-01T00:00:00Z.\n+     */\n+    public MutableInterval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param start  start of this interval\n+     * @param end  end of this interval\n+     * @throws IllegalArgumentException if either instant is null\n+     */\n+    public MutableInterval(ReadableInstant start, ReadableInstant end) {\n+        super(start, end);\n+    }\n+    \n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval\n+     * @param duration  duration of this interval\n+     */\n+    public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n+        super(start, duration);\n+    }\n+    \n+    /**\n+     * Constructs an interval from a duration and an end instant.\n+     * \n+     * @param duration duration of this interval\n+     * @param end end of this interval\n+     */\n+    public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n+        super(duration, end);\n+    }\n+    \n+    /**\n+     * Constructors an interval from an ISO format string.\n+     *\n+     * @param intervalStr  an ISO interval string\n+     */\n+    /* TODO\n+    public MutableInterval(String intervalStr) throws ParseException {\n+        Interval interval = (Interval) TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(intervalStr);\n+        iStartMillis = interval.getStartMillis();\n+        iEndMillis = interval.getEndMillis();\n+    }\n+    */\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the start of this time interval.\n+     *\n+     * @param millisInstant  the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public void setStartMillis(long millisInstant) {\n+        super.setStartMillis(millisInstant);\n+    }\n+\n+    /**\n+     * Sets the start of this time interval as an Instant.\n+     *\n+     * @param instant  the start of the time interval\n+     */\n+    public void setStartInstant(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        super.setStartMillis(instant.getMillis());\n+    }\n+\n+    /** \n+     * Sets the end of this time interval.\n+     *\n+     * @param millisInstant  the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public void setEndMillis(long millisInstant) {\n+        super.setEndMillis(millisInstant);\n+    }\n+\n+    /** \n+     * Sets the end of this time interval as an Instant.\n+     *\n+     * @param instant  the end of the time interval\n+     */\n+    public void setEndInstant(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        super.setEndMillis(instant.getMillis());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Writable interface for an interval.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritableInterval extends ReadableInterval {\n+\n+    /**\n+     * Sets the start of this time interval.\n+     *\n+     * @param millisInstant  the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    void setStartMillis(long millisInstant);\n+\n+    /**\n+     * Sets the start of this time interval as an Instant.\n+     *\n+     * @param instant  the start of the time interval\n+     */\n+    void setStartInstant(ReadableInstant instant);\n+\n+    /** \n+     * Sets the end of this time interval.\n+     *\n+     * @param millisInstant  the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    void setEndMillis(long millisInstant);\n+\n+    /** \n+     * Sets the end of this time interval as an Instant.\n+     *\n+     * @param instant  the end of the time interval\n+     */\n+    void setEndInstant(ReadableInstant instant);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+/* \n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/** \n+ * Readable interface for a time interval.\n+ * <p>\n+ * A time interval represents a period of time between two instants.\n+ * This interval has a duration, represented separately by ReadableDuration.\n+ *\n+ * @author Sean Geoghegan\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableInterval {\n+\n+    /**\n+     * Gets the start of this time interval.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    long getStartMillis();\n+\n+    /**\n+     * Gets the start of this time interval as an Instant.\n+     *\n+     * @return the start of the time interval\n+     */\n+    Instant getStartInstant();\n+\n+    /** \n+     * Gets the end of this time interval.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    long getEndMillis();\n+\n+    /** \n+     * Gets the end of this time interval as an Instant.\n+     *\n+     * @return the end of the time interval\n+     */\n+    Instant getEndInstant();\n+\n+    /** \n+     * Gets the duration of this time interval in milliseconds.\n+     * <p>\n+     * The duration returned will always be precise because it is relative to\n+     * a known date.\n+     *\n+     * @return the duration of the time interval in milliseconds\n+     */\n+    long getDurationMillis();\n+\n+    /** \n+     * Gets the duration of this time interval.\n+     * <p>\n+     * The duration returned will always be precise because it is relative to\n+     * a known date.\n+     *\n+     * @return the duration of the time interval\n+     */\n+    Duration getDuration();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval contains the millisecond\n+     */\n+    public boolean contains(long millisInstant);\n+    \n+    /**\n+     * Does this time interval contain the specified instant.\n+     * \n+     * @param instant  the instant\n+     * @return true if this time interval contains the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean contains(ReadableInstant instant);\n+    \n+    /**\n+     * Does this time interval contain the specified time interval completely.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if this time interval contains the time interval\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public boolean contains(ReadableInterval interval);\n+    \n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * The intervals overlap if at least some of the time interval is in common.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if the time intervals overlap\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public boolean overlaps(ReadableInterval interval);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval before the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is before the instant\n+     */\n+    public boolean isBefore(long millisInstant);\n+    \n+    /**\n+     * Is this time interval before the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return true if this time interval is before the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean isBefore(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval after the specified millisecond instant.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is after the instant\n+     */\n+    public boolean isAfter(long millisInstant);\n+    \n+    /**\n+     * Is this time interval after the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return true if this time interval is after the instant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public boolean isAfter(ReadableInstant instant);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a simple immutable object. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     *\n+     * @return the value as an Interval object\n+     */\n+    Interval toInterval();\n+\n+    /**\n+     * Get this time interval as a MutableInterval object.\n+     *\n+     * @return the time interval as a MutableInterval object\n+     */\n+    MutableInterval toMutableInterval();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on start and end millis. All ReadableInterval instances are accepted.\n+     * <p>\n+     * To compare the duration of two time intervals, use {@link #getDuration()}\n+     * to get the durations and compare those.\n+     *\n+     * @param readableInterval  a readable interval to check against\n+     * @return true if the start and end millis are equal\n+     */\n+    boolean equals(Object readableInterval);\n+\n+    /**\n+     * Gets a hash code for the time interval that is compatable with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be as follows:\n+     * <pre>int result = 97;\n+     * result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));\n+     * result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));\n+     * return result;</pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in the ISO8601 interval format.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}", "timestamp": 1071987722, "metainfo": ""}