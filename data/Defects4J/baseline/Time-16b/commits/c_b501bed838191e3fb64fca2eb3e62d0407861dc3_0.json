{"sha": "b501bed838191e3fb64fca2eb3e62d0407861dc3", "log": "Refactor abstract chronology classes to be package scoped and better named   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n import org.joda.time.field.RemainderDateTimeField;\n \n /**\n- * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n+ * Abstract implementation for calendar systems that use a typical\n+ * day/month/year/leapYear model.\n  * Most of the utility methods required by subclasses are package-private,\n  * reflecting the intention that they be defined in the same package.\n  * <p>\n  * @author Guy Allard\n  * @since 1.0\n  */\n-public abstract class BaseGJChronology extends AssembledChronology {\n+abstract class BaseGJChronology extends AssembledChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = 8283225332206808863L;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.PreciseDurationField;\n+\n+/**\n+ * Abstract implementation of a calendar system based around fixed length months.\n+ * <p>\n+ * As the month length is fixed various calculations can be optimised.\n+ * This implementation assumes any additional days after twelve\n+ * months fall into a thirteenth month.\n+ * <p>\n+ * BasicFixedMonthChronology is thread-safe and immutable, and all\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticChronology\n+ */\n+abstract class BasicFixedMonthChronology extends BaseGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 261387371998L;\n+\n+    /** The length of the month. */\n+    static final int MONTH_LENGTH = 30;\n+\n+    /** The typical millis per year. */\n+    static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The length of the month in millis. */\n+    static final long MILLIS_PER_MONTH = ((long) MONTH_LENGTH) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** Singleton fixed length month field used to build the monthOfYear field. */\n+    static final DurationField MONTH_DURATION_FIELD;\n+    static {\n+        // init after other static fields\n+        MONTH_DURATION_FIELD =  new PreciseDurationField\n+            (DurationFieldType.months(), MILLIS_PER_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param base  the base chronology\n+     * @param param  the init parameter\n+     * @param minDaysInFirstWeek  the minimum days in the first week\n+     */\n+    BasicFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to fixed months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to fixed months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 13);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        return (month * MILLIS_PER_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for fixed months\n+        return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 3;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return MONTH_LENGTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return (month != 13 ? MONTH_LENGTH : 6);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH;\n+        return ((int) monthZeroBased) + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicGJChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * BasicGJChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.2, refactored from CommonGJChronology\n+ */\n+abstract class BasicGJChronology extends BaseGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 538276888268L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i=0; i<12; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+        }\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return (value > 28 ? getDaysInMonthMax(instant) : 28);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 12);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+    \n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+    \n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (isLeapYear(subtrahendYear)) {\n+                if (!isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+    \n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeapYear(thisYear)) {\n+                // Current date is Feb 29 or later.\n+                if (!isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Current date is Mar 01 or later.\n+                if (isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class CopticChronology extends CommonFixedMonthChronology {\n+public final class CopticChronology extends BasicFixedMonthChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -5972804258688333942L;\n--- a/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n  * @author Stephen Colebourne\n  * @since 1.2\n  */\n-public final class EthiopicChronology extends CommonFixedMonthChronology {\n+public final class EthiopicChronology extends BasicFixedMonthChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -5972804258688333942L;\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class GregorianChronology extends CommonGJChronology {\n+public final class GregorianChronology extends BasicGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -861407383323710522L;\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class JulianChronology extends CommonGJChronology {\n+public final class JulianChronology extends BasicGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -8731039522547897247L;", "timestamp": 1130968378, "metainfo": ""}