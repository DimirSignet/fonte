{"sha": "a26563f0cd1fbdd5587a0f9d3c0c77864553d737", "log": "Rename getDateTimeZone methods to getZone etc   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/Examples.java\n+++ b/JodaTime/src/example/org/joda/example/time/Examples.java\n         System.out.println(\"Millisecond time:      in.getMillis():           \" + in.getMillis());\n         System.out.println(\"ISO string version:    in.toString():            \" + in.toString());\n         System.out.println(\"No chronology:         in.getChronology():       \" + in.getChronology());\n-        System.out.println(\"No time zone:          in.getDateTimeZone():     \" + in.getDateTimeZone());\n+        System.out.println(\"No time zone:          in.getDateTimeZone():     \" + in.getZone());\n         System.out.println(\"\");\n         System.out.println(\"Convert to DateTime:   in.toDateTime():          \" + in.toDateTime());\n         System.out.println(\"Convert to trusted:    in.toTrustedISODateTime():\" + in.toTrustedISODateTime());\n         System.out.println(\"Compare millisecond:   in.isBefore(in2):         \" + in.isBefore(in2));\n         System.out.println(\"\");\n         System.out.println(\"Change chrono IGNORED: in.withChronology(...):   \" + in.withChronology(null));\n-        System.out.println(\"Change zone IGNORED:   in.withDateTimeZone(...): \" + in.withDateTimeZone(null));\n-        System.out.println(\"Change zone IGNORED:   in.withDateTimeZoneMoved(...):\" + in.withDateTimeZoneMoved(null));\n+        System.out.println(\"Change zone IGNORED:   in.withZone(...):         \" + in.withZone(null));\n+        System.out.println(\"Change zone IGNORED:   in.withZoneRetainFields(...):\" + in.withZoneRetainFields(null));\n         System.out.println(\"Change millis:         in.withMillis(0):         \" + in.withMillis(0L));\n     }\n }\n--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n      * @param zone  the time zone to use, null means default zone\n      * @see #moveDateTimeZone\n      */\n-    protected void setDateTimeZone(DateTimeZone zone) {\n+    protected void setZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (iChronology.getDateTimeZone() != zone) {\n+        if (iChronology.getZone() != zone) {\n             // Don't set iChronology directly, as it may provide a backdoor to\n             // immutable subclasses.\n-            setChronology(iChronology.withDateTimeZone(zone));\n+            setChronology(iChronology.withZone(zone));\n         }\n     }\n \n      * relative to the new time zone.\n      *\n      * @param zone  the time zone to use, null means default zone\n-     * @see #setDateTimeZone\n+     * @see #setZone\n      */\n     protected void moveDateTimeZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        DateTimeZone currentZone = iChronology.getDateTimeZone();\n+        DateTimeZone currentZone = iChronology.getZone();\n         if (currentZone != zone) {\n             long millis = iMillis;\n             millis += currentZone.getOffset(millis);\n             millis -= zone.getOffsetFromLocal(millis);\n             // Don't set iChronology and iMillis directly, as it may provide a\n             // backdoor to immutable subclasses.\n-            setChronology(iChronology.withDateTimeZone(zone));\n+            setChronology(iChronology.withZone(zone));\n             setMillis(millis);\n         }\n     }\n--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n      * \n      * @return the DateTimeZone that the datetime is using\n      */\n-    public final DateTimeZone getDateTimeZone() {\n+    public final DateTimeZone getZone() {\n         Chronology chrono = getChronology();\n-        return (chrono != null ? chrono.getDateTimeZone() : null);\n+        return (chrono != null ? chrono.getZone() : null);\n     }\n \n     // Accessors\n      *\n      * @param newDateTimeZone  the new time zone\n      * @return a copy of this instant with a different time zone\n-     * @see #withDateTimeZoneRetainFields\n-     */\n-    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {\n+     * @see #withZoneRetainFields\n+     */\n+    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {\n         final Chronology originalChrono = getChronology();\n         if (originalChrono == null) {\n             // Without an original chronology, no new time zone can be\n             // should be made or not.\n             return withMillis(getMillis());\n         }\n-        return withChronology(originalChrono.withDateTimeZone(newDateTimeZone));\n+        return withChronology(originalChrono.withZone(newDateTimeZone));\n     }\n \n     /**\n      *\n      * @param newDateTimeZone  the new time zone\n      * @return a copy of this instant with a different time zone\n-     * @see #withDateTimeZone\n-     */\n-    public ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone) {\n+     * @see #withZone\n+     */\n+    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {\n         final long originalMillis = getMillis();\n         final Chronology originalChrono = getChronology();\n         final DateTimeZone originalZone;\n-        if (originalChrono == null || (originalZone = originalChrono.getDateTimeZone()) == null) {\n+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {\n             // Without an original chronology or time zone, no new time zone\n             // can be set. Call withMillis to allow subclass to decide if a\n             // clone should be made or not.\n             return withMillis(originalMillis);\n         }\n \n-        ReadableInstant newInstant = withChronology(originalChrono.withDateTimeZone(newDateTimeZone));\n-        newDateTimeZone = newInstant.getDateTimeZone();\n+        ReadableInstant newInstant = withChronology(originalChrono.withZone(newDateTimeZone));\n+        newDateTimeZone = newInstant.getZone();\n \n         if (newDateTimeZone == null || newDateTimeZone == originalZone) {\n             // New time zone didn't stick or didn't change. Skip millis adjustment.\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (this instanceof DateTime && getDateTimeZone() == zone) {\n+        if (this instanceof DateTime && getZone() == zone) {\n             return (DateTime) this;\n         }\n         return new DateTime(this, zone);\n         if (base == null) {\n             return new DateTime(this);\n         }\n-        DateTimeZone zone = base.getDateTimeZone();\n+        DateTimeZone zone = base.getZone();\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        return new DateTime(getMillis(base), getChronology().withDateTimeZone(zone));\n+        return new DateTime(getMillis(base), getChronology().withZone(zone));\n     }\n \n     /**\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        return new DateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));\n+        return new DateTime(getMillis(base, zone), getChronology().withZone(zone));\n     }\n \n     /**\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        return new DateTime(getMillis(base, chronology.getDateTimeZone()), chronology);\n+        return new DateTime(getMillis(base, chronology.getZone()), chronology);\n     }\n \n     /**\n      * no matching trusted time zone can be found.\n      */\n     public final DateTime toTrustedISODateTime() {\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         if (zone == null) {\n             return new DateTime(this, (Chronology)null);\n         }\n         if (base == null) {\n             return new MutableDateTime(this);\n         }\n-        DateTimeZone zone = base.getDateTimeZone();\n+        DateTimeZone zone = base.getZone();\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        return new MutableDateTime(getMillis(base), getChronology().withDateTimeZone(zone));\n+        return new MutableDateTime(getMillis(base), getChronology().withZone(zone));\n     }\n \n     /**\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        return new MutableDateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));\n+        return new MutableDateTime(getMillis(base, zone), getChronology().withZone(zone));\n     }\n \n     /**\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        return new MutableDateTime(getMillis(base, chronology.getDateTimeZone()), chronology);\n+        return new MutableDateTime(getMillis(base, chronology.getZone()), chronology);\n     }\n \n     /**\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         Calendar cal;\n         if (zone == null) {\n             cal = Calendar.getInstance(locale);\n      * @return a GregorianCalendar initialised with this datetime\n      */\n     public final GregorianCalendar toGregorianCalendar() {\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         GregorianCalendar cal;\n         if (zone == null) {\n             cal = new GregorianCalendar();\n--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java\n      */\n     private static long toLocalTime(long instant, Chronology original, Chronology chronoUTC) {\n         if (original != chronoUTC) {\n-            DateTimeZone zone = original.getDateTimeZone();\n+            DateTimeZone zone = original.getZone();\n             if (zone != null) {\n                 instant += zone.getOffset(instant);\n             }\n             if (utc != null) {\n                 return utc;\n             }\n-            DateTimeZone zone = chronology.getDateTimeZone();\n+            DateTimeZone zone = chronology.getZone();\n             if (zone == null || zone == DateTimeZone.UTC) {\n                 return chronology;\n             }\n         if (base == null || isMatchingType(base)) {\n             return getMillis();\n         }\n-        return getMillis(base, base.getDateTimeZone());\n+        return getMillis(base, base.getZone());\n     }\n \n     /**\n         long millis = getMillis();\n         long baseMillis = base.getMillis();\n \n-        DateTimeZone baseZone = base.getDateTimeZone();\n+        DateTimeZone baseZone = base.getZone();\n         if (baseZone != null) {\n             // Strip zone from base such that sum can be performed.\n             baseMillis += baseZone.getOffset(baseMillis);\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n      *\n      * @return DateTimeZone null if unspecified\n      */\n-    DateTimeZone getDateTimeZone();\n+    DateTimeZone getZone();\n \n     /**\n      * Returns an instance of this Chronology that operates in the UTC time\n      * @param zone to use, or default if null\n      * @see org.joda.time.chrono.ZonedChronology\n      */\n-    Chronology withDateTimeZone(DateTimeZone zone);\n+    Chronology withZone(DateTimeZone zone);\n \n     /**\n      * Returns a date-only millisecond instant, by clearing the time fields\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n         if (id.equals(\"UTC\")) {\n             return DateTimeZone.UTC;\n         }\n-        DateTimeZone zone = cProvider.getDateTimeZone(id);\n+        DateTimeZone zone = cProvider.getZone(id);\n         if (zone != null) {\n             return zone;\n         }\n         DateTimeZone dtz;\n         // Convert from old alias before consulting provider since they may differ.\n         String convId = getConvertedId(id);\n-        if (convId == null || (dtz = cProvider.getDateTimeZone(convId)) == null) {\n-            dtz = cProvider.getDateTimeZone(id);\n+        if (convId == null || (dtz = cProvider.getZone(convId)) == null) {\n+            dtz = cProvider.getZone(id);\n         }\n         if (dtz != null) {\n             return dtz;\n         if (!ids.contains(\"UTC\")) {\n             throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n         }\n-        if (!UTC.equals(provider.getDateTimeZone(\"UTC\"))) {\n+        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n             throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n         }\n         cProvider = provider;\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n      * @param newDateTimeZone  ignored\n      * @return this\n      */\n-    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {\n+    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {\n         return this;\n     }\n \n      * @param newDateTimeZone  ignored\n      * @return this\n      */\n-    public ReadableInstant withDateTimeZoneMoved(DateTimeZone newDateTimeZone) {\n+    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {\n         return this;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java\n      *\n      * @param zone  ignored\n      */\n-    public void setDateTimeZone(DateTimeZone zone) {\n+    public void setZone(DateTimeZone zone) {\n     }\n \n     /**\n      *\n      * @param zone  ignored\n      */\n-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {\n+    public void setZoneRetainFields(DateTimeZone zone) {\n     }\n \n     // Add\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      * If the chronology already has this time zone, no change occurs.\n      *\n      * @param zone  the time zone to use, null means default zone\n-     * @see #setDateTimeZoneRetainFields\n-     */\n-    public void setDateTimeZone(DateTimeZone zone) {\n-        super.setDateTimeZone(zone);\n+     * @see #setZoneRetainFields\n+     */\n+    public void setZone(DateTimeZone zone) {\n+        super.setZone(zone);\n     }\n \n     /**\n      * If the chronology already has this time zone, no change occurs.\n      *\n      * @param zone  the time zone to use, null means default zone\n-     * @see #setDateTimeZone\n-     */\n-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {\n+     * @see #setZone\n+     */\n+    public void setZoneRetainFields(DateTimeZone zone) {\n         super.moveDateTimeZone(zone);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java\n+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java\n      *\n      * @param zone  ignored\n      */\n-    public void setDateTimeZone(DateTimeZone zone) {\n+    public void setZone(DateTimeZone zone) {\n     }\n \n     /**\n      *\n      * @param zone  ignored\n      */\n-    public void setDateTimeZoneRetainFields(DateTimeZone zone) {\n+    public void setZoneRetainFields(DateTimeZone zone) {\n     }\n \n     // Add\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n      * If the chronology already has this time zone, no change occurs.\n      *\n      * @param zone  the time zone to use, null means default zone\n-     * @see #setDateTimeZoneRetainFields\n-     */\n-    void setDateTimeZone(DateTimeZone zone);\n+     * @see #setZoneRetainFields\n+     */\n+    void setZone(DateTimeZone zone);\n \n     /**\n      * Sets the time zone of the datetime, changing the chronology and millisecond.\n      * If the chronology already has this time zone, no change occurs.\n      *\n      * @param zone  the time zone to use, null means default zone\n-     * @see #setDateTimeZone\n-     */\n-    void setDateTimeZoneRetainFields(DateTimeZone zone);\n+     * @see #setZone\n+     */\n+    void setZoneRetainFields(DateTimeZone zone);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n      * \n      * @return the DateTimeZone, null if not applicable\n      */\n-    DateTimeZone getDateTimeZone();\n+    DateTimeZone getZone();\n \n     /**\n      * Get the value of one of the fields of a datetime.\n      *\n      * @param newDateTimeZone  the new time zone\n      * @return a copy of this instant with a different time zone\n-     * @see #withDateTimeZoneRetainFields\n-     */\n-    ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone);\n+     * @see #withZoneRetainFields\n+     */\n+    ReadableInstant withZone(DateTimeZone newDateTimeZone);\n \n     /**\n      * Gets a copy of this instant with a different time zone, preserving the\n      *\n      * @param newDateTimeZone  the new time zone\n      * @return a copy of this instant with a different time zone\n-     * @see #withDateTimeZone\n-     */\n-    ReadableInstant withDateTimeZoneRetainFields(DateTimeZone newDateTimeZone);\n+     * @see #withZone\n+     */\n+    ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n      *\n      * @return DateTimeZone null if unspecified\n      */\n-    public abstract DateTimeZone getDateTimeZone();\n+    public abstract DateTimeZone getZone();\n \n     /**\n      * Returns an instance of this Chronology that operates in the UTC time\n      * @param zone to use, or default if null\n      * @see org.joda.time.chrono.ZonedChronology\n      */\n-    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+    public abstract Chronology withZone(DateTimeZone zone);\n \n     /**\n      * Returns a date-only millisecond instant, by clearing the time fields\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n         iYearInfoCacheMask = cacheSize - 1;\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         Chronology base;\n         if ((base = getBase()) != null) {\n-            return base.getDateTimeZone();\n+            return base.getZone();\n         }\n         return DateTimeZone.UTC;\n     }\n         }\n         sb.append(name);\n         sb.append('[');\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         if (zone != null) {\n             sb.append(zone.getID());\n             sb.append(\", \");\n--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n         setFields();\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         Chronology base;\n         if ((base = iBase) != null) {\n-            return base.getDateTimeZone();\n+            return base.getZone();\n         }\n         return null;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getBase().getDateTimeZone());\n+        return getInstance(getBase().getZone());\n     }\n \n     // Conversion\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone);\n      */\n     public String toString() {\n         String str = \"BuddhistChronology\";\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         if (zone != null) {\n             str = str + '[' + zone.getID() + ']';\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getBase().getDateTimeZone());\n+        return getInstance(getBase().getZone());\n     }\n \n     // Conversion\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone);\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getDateTimeZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n-    }\n-\n-    public DateTimeZone getDateTimeZone() {\n+        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n+    }\n+\n+    public DateTimeZone getZone() {\n         Chronology base;\n         if ((base = getBase()) != null) {\n-            return base.getDateTimeZone();\n+            return base.getZone();\n         }\n         return DateTimeZone.UTC;\n     }\n      * @return the chronology in UTC\n      */\n     public Chronology withUTC() {\n-        return withDateTimeZone(DateTimeZone.UTC);\n+        return withZone(DateTimeZone.UTC);\n     }\n \n     /**\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n         StringBuffer sb = new StringBuffer(60);\n         sb.append(\"GJCutoverChronology\");\n         sb.append('[');\n-        sb.append(getDateTimeZone().getID());\n+        sb.append(getZone().getID());\n         sb.append(\", \");\n \n         sb.append(\"cutover=\");\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getBase().getDateTimeZone());\n+        return getInstance(getBase().getZone());\n     }\n \n     // Conversion\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone);\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n         }\n         int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n         ISOChronology chrono = cFastCache[index];\n-        if (chrono != null && chrono.getDateTimeZone() == zone) {\n+        if (chrono != null && chrono.getZone() == zone) {\n             return chrono;\n         }\n         synchronized (cCache) {\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone);\n      */\n     public String toString() {\n         String str = \"ISOChronology\";\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         if (zone != null) {\n             str = str + '[' + zone.getID() + ']';\n         }\n     }\n \n     protected void assemble(Fields fields) {\n-        if (getBase().getDateTimeZone() == DateTimeZone.UTC) {\n+        if (getBase().getZone() == DateTimeZone.UTC) {\n             // Use zero based century and year of century.\n             fields.centuryOfEra = new DividedDateTimeField\n                 (ISOYearOfEraDateTimeField.INSTANCE, \"centuryOfEra\", \"centuries\", 100);\n      * serialized size, and deserialized instances come from the cache.\n      */\n     private Object writeReplace() {\n-        return new Stub(getDateTimeZone());\n+        return new Stub(getZone());\n     }\n \n     private static final class Stub implements Serializable {\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n      * Serialization singleton\n      */\n     private Object readResolve() {\n-        return getInstance(getBase().getDateTimeZone());\n+        return getInstance(getBase().getZone());\n     }\n \n     // Conversion\n      * @param zone  the zone to get the chronology in, null is default\n      * @return the chronology\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n         return getInstance(zone);\n--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n \n     public Chronology withUTC() {\n         if (iWithUTC == null) {\n-            if (getDateTimeZone() == DateTimeZone.UTC) {\n+            if (getZone() == DateTimeZone.UTC) {\n                 iWithUTC = this;\n             } else {\n                 iWithUTC = LenientChronology.getInstance(getBase().withUTC());\n         return iWithUTC;\n     }\n \n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n         if (zone == DateTimeZone.UTC) {\n             return withUTC();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n-        return LenientChronology.getInstance(getBase().withDateTimeZone(zone));\n+        return LenientChronology.getInstance(getBase().withZone(zone));\n     }\n \n     protected void assemble(Fields fields) {\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n \n     /**\n      * Wraps another chronology, with datetime limits. When withUTC or\n-     * withDateTimeZone is called, the returned LimitChronology instance has\n+     * withZone is called, the returned LimitChronology instance has\n      * the same limits, except they are time zone adjusted.\n      *\n      * @param base  base chronology to wrap\n \n     /**\n      * Wraps another chronology, with datetime limits. When withUTC or\n-     * withDateTimeZone is called, the returned LimitChronology instance has\n+     * withZone is called, the returned LimitChronology instance has\n      * the same limits, except they are time zone adjusted.\n      *\n      * @param lowerLimit  inclusive lower limit, or null if none\n      * adjusted to the new time zone.\n      */\n     public Chronology withUTC() {\n-        return withDateTimeZone(DateTimeZone.UTC);\n+        return withZone(DateTimeZone.UTC);\n     }\n \n     /**\n      * this is returned. Otherwise, a new instance is returned, with the limits\n      * adjusted to the new time zone.\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n \n         DateTime lowerLimit = iLowerLimit;\n         if (lowerLimit != null) {\n             MutableDateTime mdt = lowerLimit.toMutableDateTime();\n-            mdt.setDateTimeZoneRetainFields(zone);\n+            mdt.setZoneRetainFields(zone);\n             lowerLimit = mdt.toDateTime();\n         }\n \n         DateTime upperLimit = iUpperLimit;\n         if (upperLimit != null) {\n             MutableDateTime mdt = upperLimit.toMutableDateTime();\n-            mdt.setDateTimeZoneRetainFields(zone);\n+            mdt.setZoneRetainFields(zone);\n             upperLimit = mdt.toDateTime();\n         }\n         \n         LimitChronology chrono = getInstance\n-            (getBase().withDateTimeZone(zone), lowerLimit, upperLimit);\n+            (getBase().withZone(zone), lowerLimit, upperLimit);\n \n         if (zone == DateTimeZone.UTC) {\n             iWithUTC = chrono;\n--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n \n     public Chronology withUTC() {\n         if (iWithUTC == null) {\n-            if (getDateTimeZone() == DateTimeZone.UTC) {\n+            if (getZone() == DateTimeZone.UTC) {\n                 iWithUTC = this;\n             } else {\n                 iWithUTC = StrictChronology.getInstance(getBase().withUTC());\n         return iWithUTC;\n     }\n \n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n         if (zone == DateTimeZone.UTC) {\n             return withUTC();\n         }\n-        if (zone == getDateTimeZone()) {\n+        if (zone == getZone()) {\n             return this;\n         }\n-        return StrictChronology.getInstance(getBase().withDateTimeZone(zone));\n+        return StrictChronology.getInstance(getBase().withZone(zone));\n     }\n \n     protected void assemble(Fields fields) {\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n         super(base, zone);\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         return (DateTimeZone)getParam();\n     }\n \n         return getBase();\n     }\n \n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n         throws IllegalArgumentException\n     {\n         return localToUTC(getBase().getDateTimeMillis\n-                          (instant + getDateTimeZone().getOffset(instant),\n+                          (instant + getZone().getOffset(instant),\n                            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n     }\n \n      * @param instant instant from 1970-01-01T00:00:00 local time\n      */\n     private long localToUTC(long instant) {\n-        DateTimeZone zone = getDateTimeZone();\n+        DateTimeZone zone = getZone();\n         int offset = zone.getOffsetFromLocal(instant);\n         instant -= offset;\n         if (offset != zone.getOffset(instant)) {\n         if (converted.containsKey(field)) {\n             return (DurationField)converted.get(field);\n         }\n-        ZonedDurationField zonedField = new ZonedDurationField(field, getDateTimeZone());\n+        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n         converted.put(field, zonedField);\n         return zonedField;\n     }\n             return (DateTimeField)converted.get(field);\n         }\n         ZonedDateTimeField zonedField =\n-            new ZonedDateTimeField(field, getDateTimeZone(),\n+            new ZonedDateTimeField(field, getZone(),\n                                    convertField(field.getDurationField(), converted),\n                                    convertField(field.getRangeDurationField(), converted),\n                                    convertField(field.getLeapDurationField(), converted));\n     }\n \n     public String toString() {\n-        return \"ZonedChronology[\" + getBase() + \", \" + getDateTimeZone().getID() + ']';\n+        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n     }\n \n     /*\n--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java\n         if (chrono == null) {\n             zone = DateTimeZone.getDefault();\n         } else {\n-            zone = chrono.getDateTimeZone();\n+            zone = chrono.getZone();\n         }\n         if (zone != null) {\n             millis -= zone.getOffsetFromLocal(millis);\n         if (chrono == null) {\n             return ISOChronology.getInstance();\n         }\n-        return chrono.withDateTimeZone(DateTimeZone.getDefault());\n+        return chrono.withZone(DateTimeZone.getDefault());\n     }\n     \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n         if (chrono == null) {\n             return ISOChronology.getInstance(zone);\n         }\n-        DateTimeZone chronoZone = chrono.getDateTimeZone();\n+        DateTimeZone chronoZone = chrono.getZone();\n         if (chronoZone != zone) {\n-            chrono = chrono.withDateTimeZone(zone);\n+            chrono = chrono.withZone(zone);\n             if (chrono == null) {\n                 return ISOChronology.getInstance(zone);\n             }\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n      * Returns the DateTimeZone from the formatter's Chronology, defaulting to\n      * UTC if the Chronology or its DateTimeZone is null.\n      */\n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         Chronology chrono = getChronology();\n         if (chrono == null) {\n             return DateTimeZone.UTC;\n         }\n-        DateTimeZone zone = chrono.getDateTimeZone();\n+        DateTimeZone zone = chrono.getZone();\n         return zone == null ? DateTimeZone.UTC : zone;\n     }\n \n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n-            printTo(buf, millisUTC, chrono.getDateTimeZone());\n+            printTo(buf, millisUTC, chrono.getZone());\n         } else {\n             ((DateTimePrinter)this).printTo(buf, millisUTC, null);\n         }\n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n-            printTo(out, millisUTC, chrono.getDateTimeZone());\n+            printTo(out, millisUTC, chrono.getZone());\n         } else {\n             ((DateTimePrinter)this).printTo(out, millisUTC, null);\n         }\n \n     public void printTo(final StringBuffer buf, final long instant, DateTimeZone zone) {\n         if (zone == null) {\n-            zone = getDateTimeZone();\n+            zone = getZone();\n         }\n         ((DateTimePrinter) this).printTo\n             (buf, instant, zone, instant + zone.getOffset(instant));\n \n     public void printTo(final Writer out, final long instant, DateTimeZone zone) throws IOException {\n         if (zone == null) {\n-            zone = getDateTimeZone();\n+            zone = getZone();\n         }\n         ((DateTimePrinter) this).printTo\n             (out, instant, zone, instant + zone.getOffset(instant));\n         long millisUTC = instant.getMillis();\n         Chronology chrono;\n         if ((chrono = instant.getChronology()) != null) {\n-            return print(millisUTC, chrono.getDateTimeZone());\n+            return print(millisUTC, chrono.getZone());\n         } else {\n             return print(millisUTC, null);\n         }\n \n     public String print(final long instant, DateTimeZone zone) {\n         if (zone == null) {\n-            zone = getDateTimeZone();\n+            zone = getZone();\n         }\n         return print(instant, zone, instant + zone.getOffset(instant));\n     }\n         long millis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         if (chrono != null) {\n-            DateTimeZone zone = chrono.getDateTimeZone();\n+            DateTimeZone zone = chrono.getZone();\n             if (zone != null) {\n                 // Move millis to local time.\n                 millis += zone.getOffset(millis);\n             instantLocal = 0;\n         } else {\n             instantLocal = instant.getMillis();\n-            DateTimeZone zone = instant.getDateTimeZone();\n+            DateTimeZone zone = instant.getZone();\n             if (zone != null) {\n                 instantLocal += zone.getOffset(instantLocal);\n             }\n         DateTimeParserBucket bucket = new DateTimeParserBucket(millis);\n         Chronology chrono = getChronology();\n         if (chrono != null) {\n-            DateTimeZone zone = chrono.getDateTimeZone();\n+            DateTimeZone zone = chrono.getZone();\n             if (zone != null) {\n-                bucket.setDateTimeZone(zone);\n+                bucket.setZone(zone);\n             }\n         }\n         return bucket;\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n         }\n         iChrono = chrono;\n         iChronoUTC = chrono.withUTC();\n-        DateTimeZone zone = chrono.getDateTimeZone();\n+        DateTimeZone zone = chrono.getZone();\n         iLocale = locale;\n         iElementPairs = new ArrayList();\n     }\n         public void printTo(StringBuffer buf, long instant,\n                             DateTimeZone zone, long instantLocal) {\n             if (zone == null) {\n-                zone = getDateTimeZone();\n+                zone = getZone();\n             }\n             if (iShortFormat) {\n                 buf.append(zone.getShortName(instant, this.iLocale));\n         public void printTo(Writer out, long instant,\n                             DateTimeZone zone, long instantLocal) throws IOException {\n             if (zone == null) {\n-                zone = getDateTimeZone();\n+                zone = getZone();\n             }\n             if (iShortFormat) {\n                 out.write(zone.getShortName(instant, this.iLocale));\n \n         public String print(long instant, DateTimeZone zone, long instantLocal) {\n             if (zone == null) {\n-                zone = getDateTimeZone();\n+                zone = getZone();\n             }\n             if (iShortFormat) {\n                 return zone.getShortName(instant, this.iLocale);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n      * Returns the time zone used by computeMillis, or null if an offset is\n      * used instead.\n      */\n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         return iZone;\n     }\n \n      *\n      * @param zone the date time zone to operate in, or null if UTC\n      */\n-    public void setDateTimeZone(DateTimeZone zone) {\n+    public void setZone(DateTimeZone zone) {\n         iSavedState = null;\n         iZone = zone == DateTimeZone.UTC ? null : zone;\n         iOffset = 0;\n \n     /**\n      * Returns the time zone offset used by computeMillis, unless\n-     * getDateTimeZone doesn't return null.\n+     * getZone doesn't return null.\n      */\n     public int getOffset() {\n         return iOffset;\n--- a/JodaTime/src/java/org/joda/time/tz/Provider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/Provider.java\n      *\n      * @return null if not found\n      */\n-    DateTimeZone getDateTimeZone(String id);\n+    DateTimeZone getZone(String id);\n \n     /**\n      * Returns an unmodifiable set of ids. All providers must at least\n--- a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java\n      * Returns {@link DateTimeZone#UTC UTC} for <code>\"UTC\"</code>, null\n      * otherwise.\n      */\n-    public DateTimeZone getDateTimeZone(String id) {\n+    public DateTimeZone getZone(String id) {\n         if (\"UTC\".equalsIgnoreCase(id)) {\n             return DateTimeZone.UTC;\n         }\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n      * called to log the error and null is returned for this and all future\n      * requests.\n      */\n-    public synchronized DateTimeZone getDateTimeZone(String id) {\n+    public synchronized DateTimeZone getZone(String id) {\n         if (id == null) {\n             return null;\n         }\n         }\n \n         // If this point is reached, mapping must link to another.\n-        return getDateTimeZone((String)obj);\n+        return getZone((String)obj);\n     }\n \n     public synchronized Set getAvailableIDs() {\n     }\n \n     /**\n-     * Called if an exception is thrown from getDateTimeZone while loading zone\n+     * Called if an exception is thrown from getZone while loading zone\n      * data.\n      */\n     protected void uncaughtException(Exception e) {\n--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java\n         DateTimeZone zone = DateTimeZone.getDefault();\n         assertNotNull(BuddhistChronology.getInstance());\n         assertTrue(BuddhistChronology.getInstance() instanceof BuddhistChronology);\n-        assertSame(zone, BuddhistChronology.getInstance().getDateTimeZone());\n+        assertSame(zone, BuddhistChronology.getInstance().getZone());\n     }\n     public void testGetInstanceZone() throws Exception {\n         DateTimeZone zone = DateTimeZone.getInstance(\"+01:00\");\n         assertNotNull(BuddhistChronology.getInstance(zone));\n         assertTrue(BuddhistChronology.getInstance(zone) instanceof BuddhistChronology);\n-        assertSame(zone, BuddhistChronology.getInstance(zone).getDateTimeZone());\n+        assertSame(zone, BuddhistChronology.getInstance(zone).getZone());\n     }\n     public void testGetInstanceZoneUTC() throws Exception {\n         assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(DateTimeZone.UTC));\n--- a/JodaTime/src/test/org/joda/test/time/TestParseISO.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestParseISO.java\n                 str = (zone < 0 ? \"-\" : \"+\") + str;\n                 z = DateTimeZone.getInstance(str);\n             }\n-            assertEquals(msg + \"\\nZone: \", z, dt.getDateTimeZone());\n+            assertEquals(msg + \"\\nZone: \", z, dt.getZone());\n         }\n         protected void parse(DateTimeParser p) {\n             int result = p.parseInto(dt, extended, 0);\n--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n         iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;\n     }\n \n-    public DateTimeZone getDateTimeZone() {\n+    public DateTimeZone getZone() {\n         return null;\n     }\n \n     /**\n      * Unsupported.\n      */\n-    public Chronology withDateTimeZone(DateTimeZone zone) {\n+    public Chronology withZone(DateTimeZone zone) {\n         throw new UnsupportedOperationException();\n     }\n ", "timestamp": 1081986187, "metainfo": ""}