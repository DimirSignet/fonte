{"sha": "028e01cbba9c1c7824f6c5a576a96fcacad81b61", "log": "Initial version of src/main/gwt and src/main/gwt-emul  ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt/org/joda/time/gwt/GwtTimeZone.java\n+package org.joda.time.gwt;\n+\n+import java.util.Date;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.gwt.util.ExceptionUtils;\n+\n+import com.google.gwt.i18n.client.TimeZone;\n+\n+public class GwtTimeZone extends DateTimeZone {\n+\n+    private final TimeZone gwtTimeZone;\n+\n+    public GwtTimeZone(TimeZone gwtTimeZone) {\n+        super(gwtTimeZone.getID());\n+        this.gwtTimeZone = gwtTimeZone;\n+    }\n+    \n+    public TimeZone getGwtTimeZone() {\n+        return gwtTimeZone;\n+    }\n+\n+    public long previousTransition(long instant) {\n+        throw ExceptionUtils.unsupportedInGwt();\n+    }\n+\n+    public long nextTransition(long instant) {\n+        throw ExceptionUtils.unsupportedInGwt();\n+    }\n+\n+    public boolean isFixed() {\n+        throw ExceptionUtils.unsupportedInGwt();\n+    }\n+    \n+    public int getStandardOffset(long instant) {\n+        // TODO looks like in GWT standardOffset does not depend on instant\n+        return -1 * 1000 * DateTimeConstants.SECONDS_PER_MINUTE * gwtTimeZone.getStandardOffset();\n+    }\n+\n+    public int getOffset(long instant) {\n+        return -1 * 1000 * DateTimeConstants.SECONDS_PER_MINUTE * gwtTimeZone.getOffset(new Date(instant));\n+    }\n+\n+    public String getNameKey(long instant) {\n+        return gwtTimeZone.getShortName(new Date(instant));\n+    }\n+\n+    public int hashCode() {\n+        return getID().hashCode();\n+    }\n+\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (object instanceof GwtTimeZone) {\n+            // TODO not sure if this is correct (also for hashCode)...\n+            GwtTimeZone other = (GwtTimeZone) object;\n+            return getID().equals(other.getID());\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt/org/joda/time/gwt/tz/GwtZoneInfoProvider.java\n+package org.joda.time.gwt.tz;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.gwt.GwtTimeZone;\n+import org.joda.time.tz.Provider;\n+\n+import com.google.gwt.core.client.GWT;\n+import com.google.gwt.i18n.client.TimeZone;\n+import com.google.gwt.i18n.client.TimeZoneInfo;\n+import com.google.gwt.i18n.client.constants.TimeZoneConstants;\n+\n+public class GwtZoneInfoProvider implements Provider {\n+\n+    private TimeZoneConstants timeZoneConstants;\n+    private Map map = new HashMap();\n+    private Set set;\n+    private static GwtZoneInfoProvider singleton;\n+\n+    public static GwtZoneInfoProvider singleton() {\n+        if (singleton == null) {\n+            singleton = new GwtZoneInfoProvider();\n+        }\n+        return singleton;\n+    }\n+\n+    public GwtZoneInfoProvider() {\n+        timeZoneConstants = (TimeZoneConstants) GWT.create(TimeZoneConstants.class);\n+\n+        set = new HashSet();\n+        set.add(\"UTC\");\n+\n+        // http://google-web-toolkit.googlecode.com/svn/trunk/user/src/com/google/gwt/i18n/client/constants/TimeZoneConstants.properties\n+        // awk '{print \"add(timeZoneConstants.\"$1\"());\" }' tz_constants.txt\n+        add(timeZoneConstants.atlanticCanary());\n+        add(timeZoneConstants.australiaMelbourne());\n+        add(timeZoneConstants.antarcticaMawson());\n+        add(timeZoneConstants.americaNipigon());\n+        add(timeZoneConstants.americaMiquelon());\n+        add(timeZoneConstants.pacificWallis());\n+        add(timeZoneConstants.europeSkopje());\n+        add(timeZoneConstants.americaCoralHarbour());\n+        add(timeZoneConstants.asiaDhaka());\n+        add(timeZoneConstants.americaStLucia());\n+        add(timeZoneConstants.asiaKashgar());\n+        add(timeZoneConstants.americaPhoenix());\n+        add(timeZoneConstants.asiaKuwait());\n+        add(timeZoneConstants.asiaHongKong());\n+        add(timeZoneConstants.antarcticaRothera());\n+        add(timeZoneConstants.europeStockholm());\n+        add(timeZoneConstants.pacificFiji());\n+        add(timeZoneConstants.pacificApia());\n+        add(timeZoneConstants.pacificPagoPago());\n+        add(timeZoneConstants.asiaRangoon());\n+        add(timeZoneConstants.americaMexicoCity());\n+        add(timeZoneConstants.americaPuertoRico());\n+        add(timeZoneConstants.indianMauritius());\n+        add(timeZoneConstants.europeBerlin());\n+        add(timeZoneConstants.europeZurich());\n+        add(timeZoneConstants.americaBelem());\n+        add(timeZoneConstants.antarcticaDavis());\n+        add(timeZoneConstants.asiaKrasnoyarsk());\n+        add(timeZoneConstants.atlanticBermuda());\n+        add(timeZoneConstants.australiaCurrie());\n+        add(timeZoneConstants.asiaTehran());\n+        add(timeZoneConstants.asiaSaigon());\n+        add(timeZoneConstants.asiaBaku());\n+        add(timeZoneConstants.americaDanmarkshavn());\n+        add(timeZoneConstants.americaScoresbysund());\n+        add(timeZoneConstants.americaEirunepe());\n+        add(timeZoneConstants.americaCaracas());\n+        add(timeZoneConstants.asiaBaghdad());\n+        add(timeZoneConstants.africaMonrovia());\n+        add(timeZoneConstants.americaStVincent());\n+        add(timeZoneConstants.americaVancouver());\n+        add(timeZoneConstants.asiaThimphu());\n+        add(timeZoneConstants.africaAccra());\n+        add(timeZoneConstants.americaBelize());\n+        add(timeZoneConstants.americaEdmonton());\n+        add(timeZoneConstants.asiaTashkent());\n+        add(timeZoneConstants.asiaTokyo());\n+        add(timeZoneConstants.pacificKiritimati());\n+        add(timeZoneConstants.australiaSydney());\n+        add(timeZoneConstants.europeRiga());\n+        add(timeZoneConstants.asiaDili());\n+        add(timeZoneConstants.africaMbabane());\n+        add(timeZoneConstants.asiaOral());\n+        add(timeZoneConstants.asiaAden());\n+        add(timeZoneConstants.europeIstanbul());\n+        add(timeZoneConstants.africaAbidjan());\n+        add(timeZoneConstants.australiaLindeman());\n+        add(timeZoneConstants.pacificGalapagos());\n+        add(timeZoneConstants.americaBogota());\n+        add(timeZoneConstants.americaDawson());\n+        add(timeZoneConstants.americaChicago());\n+        add(timeZoneConstants.pacificKwajalein());\n+        add(timeZoneConstants.australiaBrokenHill());\n+        add(timeZoneConstants.americaCuiaba());\n+        add(timeZoneConstants.indianChristmas());\n+        add(timeZoneConstants.asiaJayapura());\n+        add(timeZoneConstants.europeBrussels());\n+        add(timeZoneConstants.europeLisbon());\n+        add(timeZoneConstants.asiaChongqing());\n+        add(timeZoneConstants.americaNoronha());\n+        add(timeZoneConstants.europeMadrid());\n+        add(timeZoneConstants.africaAlgiers());\n+        add(timeZoneConstants.africaHarare());\n+        add(timeZoneConstants.africaNdjamena());\n+        add(timeZoneConstants.americaCostaRica());\n+        add(timeZoneConstants.europeLjubljana());\n+        add(timeZoneConstants.indianMayotte());\n+        add(timeZoneConstants.asiaPhnomPenh());\n+        add(timeZoneConstants.americaManagua());\n+        add(timeZoneConstants.asiaBrunei());\n+        add(timeZoneConstants.americaTijuana());\n+        add(timeZoneConstants.pacificFakaofo());\n+        add(timeZoneConstants.americaAdak());\n+        add(timeZoneConstants.americaAntigua());\n+        add(timeZoneConstants.americaArgentinaLaRioja());\n+        add(timeZoneConstants.pacificTahiti());\n+        add(timeZoneConstants.americaPangnirtung());\n+        add(timeZoneConstants.europeZagreb());\n+        add(timeZoneConstants.americaAsuncion());\n+        add(timeZoneConstants.europeVienna());\n+        add(timeZoneConstants.australiaHobart());\n+        add(timeZoneConstants.americaJuneau());\n+        add(timeZoneConstants.americaInuvik());\n+        add(timeZoneConstants.americaMontreal());\n+        add(timeZoneConstants.asiaSeoul());\n+        add(timeZoneConstants.indianComoro());\n+        add(timeZoneConstants.europeParis());\n+        add(timeZoneConstants.europeTallinn());\n+        add(timeZoneConstants.indianMahe());\n+        add(timeZoneConstants.asiaCalcutta());\n+        add(timeZoneConstants.americaMartinique());\n+        add(timeZoneConstants.asiaSingapore());\n+        add(timeZoneConstants.africaNairobi());\n+        add(timeZoneConstants.americaMaceio());\n+        add(timeZoneConstants.africaCairo());\n+        add(timeZoneConstants.europeMoscow());\n+        add(timeZoneConstants.antarcticaPalmer());\n+        add(timeZoneConstants.asiaUlaanbaatar());\n+        add(timeZoneConstants.americaRainyRiver());\n+        add(timeZoneConstants.indianMaldives());\n+        add(timeZoneConstants.asiaColombo());\n+        add(timeZoneConstants.australiaAdelaide());\n+        add(timeZoneConstants.americaCambridgeBay());\n+        add(timeZoneConstants.africaLuanda());\n+        add(timeZoneConstants.pacificChatham());\n+        add(timeZoneConstants.americaCordoba());\n+        add(timeZoneConstants.asiaTbilisi());\n+        add(timeZoneConstants.europeGibraltar());\n+        add(timeZoneConstants.asiaKarachi());\n+        add(timeZoneConstants.asiaHarbin());\n+        add(timeZoneConstants.australiaLordHowe());\n+        add(timeZoneConstants.americaBoaVista());\n+        add(timeZoneConstants.africaTripoli());\n+        add(timeZoneConstants.indianReunion());\n+        add(timeZoneConstants.atlanticStanley());\n+        add(timeZoneConstants.americaBlancSablon());\n+        add(timeZoneConstants.americaSantoDomingo());\n+        add(timeZoneConstants.antarcticaSyowa());\n+        add(timeZoneConstants.americaJamaica());\n+        add(timeZoneConstants.europeKiev());\n+        add(timeZoneConstants.europeBudapest());\n+        add(timeZoneConstants.pacificMidway());\n+        add(timeZoneConstants.americaGooseBay());\n+        add(timeZoneConstants.asiaAmman());\n+        add(timeZoneConstants.asiaSakhalin());\n+        add(timeZoneConstants.africaWindhoek());\n+        add(timeZoneConstants.asiaKatmandu());\n+        add(timeZoneConstants.americaGuyana());\n+        add(timeZoneConstants.americaSaoPaulo());\n+        add(timeZoneConstants.australiaPerth());\n+        add(timeZoneConstants.africaDjibouti());\n+        add(timeZoneConstants.asiaJakarta());\n+        add(timeZoneConstants.asiaPyongyang());\n+        add(timeZoneConstants.africaJohannesburg());\n+        add(timeZoneConstants.asiaIrkutsk());\n+        add(timeZoneConstants.africaNiamey());\n+        add(timeZoneConstants.africaCasablanca());\n+        add(timeZoneConstants.asiaBishkek());\n+        add(timeZoneConstants.africaNouakchott());\n+        add(timeZoneConstants.europeVilnius());\n+        add(timeZoneConstants.americaCayenne());\n+        add(timeZoneConstants.africaMogadishu());\n+        add(timeZoneConstants.americaKentuckyMonticello());\n+        add(timeZoneConstants.americaRioBranco());\n+        add(timeZoneConstants.americaCancun());\n+        add(timeZoneConstants.americaHavana());\n+        add(timeZoneConstants.pacificGuam());\n+        add(timeZoneConstants.pacificKosrae());\n+        add(timeZoneConstants.atlanticAzores());\n+        add(timeZoneConstants.australiaEucla());\n+        add(timeZoneConstants.asiaShanghai());\n+        add(timeZoneConstants.americaRankinInlet());\n+        add(timeZoneConstants.americaIqaluit());\n+        add(timeZoneConstants.africaMaputo());\n+        add(timeZoneConstants.asiaBahrain());\n+        add(timeZoneConstants.asiaAshgabat());\n+        add(timeZoneConstants.asiaRiyadh());\n+        add(timeZoneConstants.atlanticFaeroe());\n+        add(timeZoneConstants.europeWarsaw());\n+        add(timeZoneConstants.americaAnguilla());\n+        add(timeZoneConstants.asiaDamascus());\n+        add(timeZoneConstants.americaNorthDakotaCenter());\n+        add(timeZoneConstants.americaIndianaVevay());\n+        add(timeZoneConstants.atlanticStHelena());\n+        add(timeZoneConstants.americaBarbados());\n+        add(timeZoneConstants.americaIndianaVincennes());\n+        add(timeZoneConstants.asiaAlmaty());\n+        add(timeZoneConstants.africaLome());\n+        add(timeZoneConstants.africaBrazzaville());\n+        add(timeZoneConstants.americaNome());\n+        add(timeZoneConstants.asiaTaipei());\n+        add(timeZoneConstants.americaYakutat());\n+        add(timeZoneConstants.americaAraguaina());\n+        add(timeZoneConstants.europeVaduz());\n+        add(timeZoneConstants.africaAsmera());\n+        add(timeZoneConstants.europeMinsk());\n+        add(timeZoneConstants.americaBuenosAires());\n+        add(timeZoneConstants.africaMaseru());\n+        add(timeZoneConstants.americaStJohns());\n+        add(timeZoneConstants.asiaKuching());\n+        add(timeZoneConstants.africaLibreville());\n+        add(timeZoneConstants.africaFreetown());\n+        add(timeZoneConstants.africaBissau());\n+        add(timeZoneConstants.europeSamara());\n+        add(timeZoneConstants.europeAmsterdam());\n+        add(timeZoneConstants.europeTirane());\n+        add(timeZoneConstants.pacificSaipan());\n+        add(timeZoneConstants.asiaMagadan());\n+        add(timeZoneConstants.europeZaporozhye());\n+        add(timeZoneConstants.americaElSalvador());\n+        add(timeZoneConstants.europePodgorica());\n+        add(timeZoneConstants.americaSantiago());\n+        add(timeZoneConstants.americaAruba());\n+        add(timeZoneConstants.americaIndianapolis());\n+        add(timeZoneConstants.americaRegina());\n+        add(timeZoneConstants.pacificTruk());\n+        add(timeZoneConstants.pacificFunafuti());\n+        add(timeZoneConstants.americaMerida());\n+        add(timeZoneConstants.americaGuatemala());\n+        add(timeZoneConstants.africaSaoTome());\n+        add(timeZoneConstants.asiaMakassar());\n+        add(timeZoneConstants.africaBujumbura());\n+        add(timeZoneConstants.europeChisinau());\n+        add(timeZoneConstants.americaMonterrey());\n+        add(timeZoneConstants.asiaYekaterinburg());\n+        add(timeZoneConstants.antarcticaCasey());\n+        add(timeZoneConstants.pacificEnderbury());\n+        add(timeZoneConstants.americaThule());\n+        add(timeZoneConstants.americaLouisville());\n+        add(timeZoneConstants.americaMoncton());\n+        add(timeZoneConstants.europeHelsinki());\n+        add(timeZoneConstants.atlanticCapeVerde());\n+        add(timeZoneConstants.americaTegucigalpa());\n+        add(timeZoneConstants.indianCocos());\n+        add(timeZoneConstants.americaBoise());\n+        add(timeZoneConstants.americaGuadeloupe());\n+        add(timeZoneConstants.americaNassau());\n+        add(timeZoneConstants.europePrague());\n+        add(timeZoneConstants.americaHalifax());\n+        add(timeZoneConstants.asiaHovd());\n+        add(timeZoneConstants.americaManaus());\n+        add(timeZoneConstants.americaGodthab());\n+        add(timeZoneConstants.americaCatamarca());\n+        add(timeZoneConstants.americaChihuahua());\n+        add(timeZoneConstants.asiaBeirut());\n+        add(timeZoneConstants.americaArgentinaRioGallegos());\n+        add(timeZoneConstants.pacificGambier());\n+        add(timeZoneConstants.europeVolgograd());\n+        add(timeZoneConstants.africaBamako());\n+        add(timeZoneConstants.europeUzhgorod());\n+        add(timeZoneConstants.africaBanjul());\n+        add(timeZoneConstants.asiaAqtau());\n+        add(timeZoneConstants.africaMalabo());\n+        add(timeZoneConstants.atlanticMadeira());\n+        add(timeZoneConstants.pacificNoumea());\n+        add(timeZoneConstants.africaKinshasa());\n+        add(timeZoneConstants.europeMalta());\n+        add(timeZoneConstants.americaArgentinaUshuaia());\n+        add(timeZoneConstants.asiaBangkok());\n+        add(timeZoneConstants.pacificNiue());\n+        add(timeZoneConstants.australiaBrisbane());\n+        add(timeZoneConstants.americaRecife());\n+        add(timeZoneConstants.asiaYerevan());\n+        add(timeZoneConstants.americaLaPaz());\n+        add(timeZoneConstants.asiaUrumqi());\n+        add(timeZoneConstants.africaLusaka());\n+        add(timeZoneConstants.pacificGuadalcanal());\n+        add(timeZoneConstants.americaYellowknife());\n+        add(timeZoneConstants.asiaVientiane());\n+        add(timeZoneConstants.europeKaliningrad());\n+        add(timeZoneConstants.africaConakry());\n+        add(timeZoneConstants.americaArgentinaTucuman());\n+        add(timeZoneConstants.europeOslo());\n+        add(timeZoneConstants.americaStKitts());\n+        add(timeZoneConstants.americaPanama());\n+        add(timeZoneConstants.americaHermosillo());\n+        add(timeZoneConstants.pacificPalau());\n+        add(timeZoneConstants.americaGuayaquil());\n+        add(timeZoneConstants.asiaKualaLumpur());\n+        add(timeZoneConstants.europeLondon());\n+        add(timeZoneConstants.americaMenominee());\n+        add(timeZoneConstants.asiaKamchatka());\n+        add(timeZoneConstants.asiaVladivostok());\n+        add(timeZoneConstants.asiaQatar());\n+        add(timeZoneConstants.asiaDubai());\n+        add(timeZoneConstants.asiaYakutsk());\n+        add(timeZoneConstants.asiaOmsk());\n+        add(timeZoneConstants.africaBangui());\n+        add(timeZoneConstants.americaParamaribo());\n+        add(timeZoneConstants.africaLubumbashi());\n+        add(timeZoneConstants.pacificMarquesas());\n+        add(timeZoneConstants.europeBratislava());\n+        add(timeZoneConstants.asiaAnadyr());\n+        add(timeZoneConstants.americaNewYork());\n+        add(timeZoneConstants.pacificNorfolk());\n+        add(timeZoneConstants.pacificRarotonga());\n+        add(timeZoneConstants.americaDominica());\n+        add(timeZoneConstants.africaPortoNovo());\n+        add(timeZoneConstants.asiaSamarkand());\n+        add(timeZoneConstants.asiaDushanbe());\n+        add(timeZoneConstants.americaToronto());\n+        add(timeZoneConstants.americaBahia());\n+        add(timeZoneConstants.africaKampala());\n+        add(timeZoneConstants.africaOuagadougou());\n+        add(timeZoneConstants.asiaMuscat());\n+        add(timeZoneConstants.americaPortofSpain());\n+        add(timeZoneConstants.pacificWake());\n+        add(timeZoneConstants.australiaDarwin());\n+        add(timeZoneConstants.americaWhitehorse());\n+        add(timeZoneConstants.americaSwiftCurrent());\n+        add(timeZoneConstants.europeCopenhagen());\n+        add(timeZoneConstants.americaMontserrat());\n+        add(timeZoneConstants.americaMendoza());\n+        add(timeZoneConstants.europeSimferopol());\n+        add(timeZoneConstants.africaBlantyre());\n+        add(timeZoneConstants.americaDetroit());\n+        add(timeZoneConstants.americaShiprock());\n+        add(timeZoneConstants.americaGrenada());\n+        add(timeZoneConstants.americaIndianaPetersburg());\n+        add(timeZoneConstants.asiaPontianak());\n+        add(timeZoneConstants.europeAthens());\n+        add(timeZoneConstants.americaPortauPrince());\n+        add(timeZoneConstants.americaCayman());\n+        add(timeZoneConstants.africaDaresSalaam());\n+        add(timeZoneConstants.americaCuracao());\n+        add(timeZoneConstants.indianKerguelen());\n+        add(timeZoneConstants.africaKhartoum());\n+        add(timeZoneConstants.asiaManila());\n+        add(timeZoneConstants.europeSarajevo());\n+        add(timeZoneConstants.americaJujuy());\n+        add(timeZoneConstants.africaDouala());\n+        add(timeZoneConstants.europeRome());\n+        add(timeZoneConstants.americaArgentinaSanJuan());\n+        add(timeZoneConstants.americaNorthDakotaNewSalem());\n+        add(timeZoneConstants.pacificPortMoresby());\n+        add(timeZoneConstants.europeAndorra());\n+        add(timeZoneConstants.europeLuxembourg());\n+        add(timeZoneConstants.pacificHonolulu());\n+        add(timeZoneConstants.americaStThomas());\n+        add(timeZoneConstants.pacificMajuro());\n+        add(timeZoneConstants.americaMazatlan());\n+        add(timeZoneConstants.asiaMacau());\n+        add(timeZoneConstants.europeBelgrade());\n+        add(timeZoneConstants.asiaChoibalsan());\n+        add(timeZoneConstants.antarcticaMcMurdo());\n+        add(timeZoneConstants.americaThunderBay());\n+        add(timeZoneConstants.americaLosAngeles());\n+        add(timeZoneConstants.asiaKabul());\n+        add(timeZoneConstants.indianAntananarivo());\n+        add(timeZoneConstants.atlanticReykjavik());\n+        add(timeZoneConstants.asiaNicosia());\n+        add(timeZoneConstants.pacificPonape());\n+        add(timeZoneConstants.pacificTongatapu());\n+        add(timeZoneConstants.pacificPitcairn());\n+        add(timeZoneConstants.pacificEaster());\n+        add(timeZoneConstants.atlanticSouthGeorgia());\n+        add(timeZoneConstants.africaElAaiun());\n+        add(timeZoneConstants.americaCampoGrande());\n+        add(timeZoneConstants.americaDawsonCreek());\n+        add(timeZoneConstants.antarcticaVostok());\n+        add(timeZoneConstants.europeBucharest());\n+        add(timeZoneConstants.americaPortoVelho());\n+        add(timeZoneConstants.europeMonaco());\n+        add(timeZoneConstants.americaIndianaMarengo());\n+        add(timeZoneConstants.africaCeuta());\n+        add(timeZoneConstants.americaWinnipeg());\n+        add(timeZoneConstants.asiaAqtobe());\n+        add(timeZoneConstants.africaDakar());\n+        add(timeZoneConstants.americaFortaleza());\n+        add(timeZoneConstants.pacificTarawa());\n+        add(timeZoneConstants.africaAddisAbaba());\n+        add(timeZoneConstants.pacificEfate());\n+        add(timeZoneConstants.pacificJohnston());\n+        add(timeZoneConstants.asiaQyzylorda());\n+        add(timeZoneConstants.asiaJerusalem());\n+        add(timeZoneConstants.pacificAuckland());\n+        add(timeZoneConstants.americaTortola());\n+        add(timeZoneConstants.americaDenver());\n+        add(timeZoneConstants.indianChagos());\n+        add(timeZoneConstants.americaGlaceBay());\n+        add(timeZoneConstants.africaGaborone());\n+        add(timeZoneConstants.africaTunis());\n+        add(timeZoneConstants.americaMontevideo());\n+        add(timeZoneConstants.asiaGaza());\n+        add(timeZoneConstants.europeDublin());\n+        add(timeZoneConstants.antarcticaDumontDUrville());\n+        add(timeZoneConstants.americaIndianaKnox());\n+        add(timeZoneConstants.asiaNovosibirsk());\n+        add(timeZoneConstants.africaKigali());\n+        add(timeZoneConstants.americaGrandTurk());\n+        add(timeZoneConstants.africaLagos());\n+        add(timeZoneConstants.europeSofia());\n+        add(timeZoneConstants.americaLima());\n+        add(timeZoneConstants.americaAnchorage());\n+        add(timeZoneConstants.pacificNauru());\n+    }\n+\n+    private void add(String string) {\n+        TimeZone timeZone = TimeZone.createTimeZone(TimeZoneInfo.buildTimeZoneData(string));\n+        map.put(timeZone.getID(), new GwtTimeZone(timeZone));\n+        set.add(timeZone.getID());\n+    }\n+\n+    public Set getAvailableIDs() {\n+        return set;\n+    }\n+\n+    public DateTimeZone getZone(String id) {\n+        if (id.equals(\"UTC\")) {\n+            return DateTimeZone.UTC;\n+        }\n+        return (DateTimeZone) map.get(id);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt/org/joda/time/gwt/util/Arrays.java\n+package org.joda.time.gwt.util;\n+\n+\n+\n+public class Arrays {\n+    private Arrays() {\n+    }\n+\n+    public static int[] copyOf(int[] original, int newLength) {\n+        int[] copy = new int[newLength];\n+        System.arraycopy(original, 0, copy, 0,\n+                         Math.min(original.length, newLength));\n+        return copy;\n+    }\n+\n+    public static void copy(Object[] original, Object[] dest) {\n+        //Cannot use copyOf similar to the one in java.util.Arrays; cannot generically create an array in GWT\n+        //Also use Object[] iso T[] because joda supports 1.3\n+        System.arraycopy(original, 0, dest, 0,\n+                         Math.min(original.length, dest.length));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt/org/joda/time/gwt/util/ExceptionUtils.java\n+package org.joda.time.gwt.util;\n+\n+public class ExceptionUtils {\n+    \n+    private ExceptionUtils() {}\n+\n+    public static UnsupportedOperationException unsupportedInGwt() {\n+        return new UnsupportedOperationException(\"Code is not ported to GWT\");\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/java/io/DataInput.java\n+package java.io;\n+\n+public class DataInput {\n+\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/java/io/DataOutput.java\n+package java.io;\n+\n+public class DataOutput {\n+\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/java/io/ObjectStreamException.java\n+package java.io;\n+\n+public class ObjectStreamException extends IOException {\n+\n+}\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/DateTimeUtils.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/DateTimeUtils.java\n      * @throws SecurityException if the provider may not be changed\n      */\n     private static void checkPermission() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/DateTimeZone.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/DateTimeZone.java\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n+//import java.lang.ref.Reference;\n+//import java.lang.ref.SoftReference;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n import org.joda.time.tz.NameProvider;\n import org.joda.time.tz.Provider;\n import org.joda.time.tz.UTCProvider;\n-import org.joda.time.tz.ZoneInfoProvider;\n+//import org.joda.time.tz.ZoneInfoProvider;\n \n /**\n  * DateTimeZone represents a time zone.\n         setNameProvider0(null);\n \n         try {\n-            try {\n-                cDefault = forID(System.getProperty(\"user.timezone\"));\n-            } catch (RuntimeException ex) {\n-                // ignored\n-            }\n-            if (cDefault == null) {\n-                cDefault = forTimeZone(TimeZone.getDefault());\n-            }\n+//            try {\n+//                cDefault = forID(System.getProperty(\"user.timezone\"));\n+//            } catch (RuntimeException ex) {\n+//                // ignored\n+//            }\n+//            if (cDefault == null) {\n+//                cDefault = forTimeZone(TimeZone.getDefault());\n+//            }\n         } catch (IllegalArgumentException ex) {\n             // ignored\n         }\n      * @throws SecurityException if the application has insufficient security rights\n      */\n     public static void setDefault(DateTimeZone zone) throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n+//        }\n         if (zone == null) {\n             throw new IllegalArgumentException(\"The datetime zone must not be null\");\n         }\n         if (iFixedOffsetCache == null) {\n             iFixedOffsetCache = new HashMap();\n         }\n-        DateTimeZone zone;\n-        Reference ref = (Reference) iFixedOffsetCache.get(id);\n-        if (ref != null) {\n-            zone = (DateTimeZone) ref.get();\n-            if (zone != null) {\n-                return zone;\n-            }\n-        }\n-        zone = new FixedDateTimeZone(id, null, offset, offset);\n-        iFixedOffsetCache.put(id, new SoftReference(zone));\n+//        DateTimeZone zone;\n+//        Reference ref = (Reference) iFixedOffsetCache.get(id);\n+//        if (ref != null) {\n+//            zone = (DateTimeZone) ref.get();\n+//            if (zone != null) {\n+//                return zone;\n+//            }\n+//        }\n+//        zone = new FixedDateTimeZone(id, null, offset, offset);\n+//        iFixedOffsetCache.put(id, new SoftReference(zone));\n+        DateTimeZone zone = (DateTimeZone) iFixedOffsetCache.get(id);\n+        if (zone == null) {\n+            zone = new FixedDateTimeZone(id, null, offset, offset);\n+            iFixedOffsetCache.put(id, zone);\n+        }\n         return zone;\n     }\n \n      * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setProvider(Provider provider) throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n+//        }\n         setProvider0(provider);\n     }\n \n     private static Provider getDefaultProvider() {\n         Provider provider = null;\n \n-        try {\n-            String providerClass =\n-                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n-            if (providerClass != null) {\n-                try {\n-                    provider = (Provider) Class.forName(providerClass).newInstance();\n-                } catch (Exception ex) {\n-                    Thread thread = Thread.currentThread();\n-                    thread.getThreadGroup().uncaughtException(thread, ex);\n-                }\n-            }\n-        } catch (SecurityException ex) {\n-            // ignored\n-        }\n-\n-        if (provider == null) {\n-            try {\n-                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n-            } catch (Exception ex) {\n-                Thread thread = Thread.currentThread();\n-                thread.getThreadGroup().uncaughtException(thread, ex);\n-            }\n-        }\n+//        try {\n+//            String providerClass =\n+//                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+//            if (providerClass != null) {\n+//                try {\n+//                    provider = (Provider) Class.forName(providerClass).newInstance();\n+//                } catch (Exception ex) {\n+//                    Thread thread = Thread.currentThread();\n+//                    thread.getThreadGroup().uncaughtException(thread, ex);\n+//                }\n+//            }\n+//        } catch (SecurityException ex) {\n+//            // ignored\n+//        }\n+//\n+//        if (provider == null) {\n+//            try {\n+//                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+//            } catch (Exception ex) {\n+//                Thread thread = Thread.currentThread();\n+//                thread.getThreadGroup().uncaughtException(thread, ex);\n+//            }\n+//        }\n \n         if (provider == null) {\n             provider = new UTCProvider();\n      * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n+//        }\n         setNameProvider0(nameProvider);\n     }\n \n      */\n     private static NameProvider getDefaultNameProvider() {\n         NameProvider nameProvider = null;\n-        try {\n-            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n-            if (providerClass != null) {\n-                try {\n-                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n-                } catch (Exception ex) {\n-                    Thread thread = Thread.currentThread();\n-                    thread.getThreadGroup().uncaughtException(thread, ex);\n-                }\n-            }\n-        } catch (SecurityException ex) {\n-            // ignore\n-        }\n+//        try {\n+//            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+//            if (providerClass != null) {\n+//                try {\n+//                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n+//                } catch (Exception ex) {\n+//                    Thread thread = Thread.currentThread();\n+//                    thread.getThreadGroup().uncaughtException(thread, ex);\n+//                }\n+//            }\n+//        } catch (SecurityException ex) {\n+//            // ignore\n+//        }\n \n         if (nameProvider == null) {\n             nameProvider = new DefaultNameProvider();\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Days.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Days.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of days.\n     public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380865L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Days parseDays(String periodStr) {\n-        if (periodStr == null) {\n-            return Days.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Days.days(p.getDays());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Days.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Days.days(p.getDays());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Hours.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Hours.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of hours.\n     public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380864L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Hours parseHours(String periodStr) {\n-        if (periodStr == null) {\n-            return Hours.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Hours.hours(p.getHours());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Hours.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Hours.hours(p.getHours());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Minutes.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Minutes.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of minutes.\n     public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380863L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Minutes parseMinutes(String periodStr) {\n-        if (periodStr == null) {\n-            return Minutes.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Minutes.minutes(p.getMinutes());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Minutes.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Minutes.minutes(p.getMinutes());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Months.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Months.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of months.\n     public static final Months MIN_VALUE = new Months(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.months());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.months());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380867L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Months parseMonths(String periodStr) {\n-        if (periodStr == null) {\n-            return Months.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Months.months(p.getMonths());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Months.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Months.months(p.getMonths());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutableDateTime.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutableDateTime.java\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * MutableDateTime is the standard implementation of a modifiable datetime class.\n      * @return a clone of this object.\n      */\n     public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (CloneNotSupportedException ex) {\n-            throw new InternalError(\"Clone error\");\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        try {\n+//            return super.clone();\n+//        } catch (CloneNotSupportedException ex) {\n+//            throw new InternalError(\"Clone error\");\n+//        }\n     }\n \n     /**\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutableInterval.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutableInterval.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * MutableInterval is the standard implementation of a mutable time interval.\n      * @return a clone of this object.\n      */\n     public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (CloneNotSupportedException ex) {\n-            throw new InternalError(\"Clone error\");\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        try {\n+//            return super.clone();\n+//        } catch (CloneNotSupportedException ex) {\n+//            throw new InternalError(\"Clone error\");\n+//        }\n     }\n \n }\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutablePeriod.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/MutablePeriod.java\n import org.joda.time.base.BasePeriod;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * Standard mutable time period implementation.\n      * @return a clone of this object.\n      */\n     public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (CloneNotSupportedException ex) {\n-            throw new InternalError(\"Clone error\");\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        try {\n+//            return super.clone();\n+//        } catch (CloneNotSupportedException ex) {\n+//            throw new InternalError(\"Clone error\");\n+//        }\n     }\n \n }\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Partial.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Partial.java\n             lastUnitField = loopUnitField;\n         }\n         \n-        iTypes = (DateTimeFieldType[]) types.clone();\n+        //iTypes = (DateTimeFieldType[]) types.clone();\n+        iTypes = new DateTimeFieldType[types.length];\n+        org.joda.time.gwt.util.Arrays.copy(types, iTypes);\n         chronology.validate(this, values);\n-        iValues = (int[]) values.clone();\n+        //iValues = (int[]) values.clone();\n+        iValues = org.joda.time.gwt.util.Arrays.copyOf(values, values.length);\n     }\n \n     /**\n      * @return the array of field types (cloned), largest to smallest\n      */\n     public DateTimeFieldType[] getFieldTypes() {\n-        return (DateTimeFieldType[]) iTypes.clone();\n+        //return (DateTimeFieldType[]) iTypes.clone();\n+        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length];\n+        org.joda.time.gwt.util.Arrays.copy(iTypes, newTypes);\n+        return newTypes;\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the current values of each field (cloned), largest to smallest\n      */\n     public int[] getValues() {\n-        return (int[]) iValues.clone();\n+        //return (int[]) iValues.clone();\n+        return org.joda.time.gwt.util.Arrays.copyOf(iValues, iValues.length);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Seconds.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Seconds.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of seconds.\n     public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380862L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Seconds parseSeconds(String periodStr) {\n-        if (periodStr == null) {\n-            return Seconds.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Seconds.seconds(p.getSeconds());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Seconds.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Seconds.seconds(p.getSeconds());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/TimeOfDay.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/TimeOfDay.java\n import org.joda.time.field.AbstractPartialFieldProperty;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.gwt.util.Arrays;\n \n /**\n  * TimeOfDay is an immutable partial supporting the hour, minute, second\n      * @return the array of field types (cloned), largest to smallest\n      */\n     public DateTimeFieldType[] getFieldTypes() {\n-        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+        DateTimeFieldType[] fieldTypes = new DateTimeFieldType[FIELD_TYPES.length];\n+        Arrays.copy(FIELD_TYPES, fieldTypes);\n+        return fieldTypes;\n+        //return (DateTimeFieldType[]) FIELD_TYPES.clone();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Weeks.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Weeks.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of weeks.\n     public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380866L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Weeks parseWeeks(String periodStr) {\n-        if (periodStr == null) {\n-            return Weeks.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Weeks.weeks(p.getWeeks());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Weeks.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Weeks.weeks(p.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/YearMonthDay.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/YearMonthDay.java\n import org.joda.time.field.AbstractPartialFieldProperty;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.gwt.util.Arrays;\n \n /**\n  * YearMonthDay is an immutable partial supporting the year, monthOfYear\n      * @return the array of field types (cloned), largest to smallest\n      */\n     public DateTimeFieldType[] getFieldTypes() {\n-        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+        //return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+        DateTimeFieldType[] fieldTypes = new DateTimeFieldType[FIELD_TYPES.length];\n+        Arrays.copy(FIELD_TYPES, fieldTypes);\n+        return fieldTypes;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Years.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/Years.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n import org.joda.time.format.PeriodFormatter;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * An immutable time period representing a number of years.\n     public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);\n \n     /** The paser to use for this class. */\n-    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());\n+    //private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());\n     /** Serialization version. */\n     private static final long serialVersionUID = 87525275727380868L;\n \n      * @throws IllegalArgumentException if the string format is invalid\n      */\n     public static Years parseYears(String periodStr) {\n-        if (periodStr == null) {\n-            return Years.ZERO;\n-        }\n-        Period p = PARSER.parsePeriod(periodStr);\n-        return Years.years(p.getYears());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (periodStr == null) {\n+//            return Years.ZERO;\n+//        }\n+//        Period p = PARSER.parsePeriod(periodStr);\n+//        return Years.years(p.getYears());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/base/AbstractDateTime.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableDateTime;\n import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * AbstractDateTime provides the common behaviour for datetime classes.\n      * @return a localized Calendar initialised with this datetime\n      */\n     public Calendar toCalendar(Locale locale) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        DateTimeZone zone = getZone();\n-        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n-        cal.setTime(toDate());\n-        return cal;\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (locale == null) {\n+//            locale = Locale.getDefault();\n+//        }\n+//        DateTimeZone zone = getZone();\n+//        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n+//        cal.setTime(toDate());\n+//        return cal;\n     }\n \n     /**\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/base/BasePartial.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/base/BasePartial.java\n import org.joda.time.convert.PartialConverter;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.gwt.util.Arrays;\n \n /**\n  * BasePartial is an abstract implementation of ReadablePartial that stores\n      * @return the current values of each field (cloned), largest to smallest\n      */\n     public int[] getValues() {\n-        return (int[]) iValues.clone();\n+        //return (int[]) iValues.clone();\n+        return Arrays.copyOf(iValues, iValues.length);\n     }\n \n     /**\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/chrono/GJLocaleSymbols.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/chrono/GJLocaleSymbols.java\n  */\n package org.joda.time.chrono;\n \n-import java.lang.ref.WeakReference;\n+//import java.lang.ref.WeakReference;\n import java.text.DateFormatSymbols;\n-import java.util.WeakHashMap;\n+//import java.util.WeakHashMap;\n import java.util.Locale;\n import java.util.TreeMap;\n \n import org.joda.time.DateTimeFieldType;\n import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * Utility class used by a few of the GJDateTimeFields.\n \n     private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];\n \n-    private static WeakHashMap cCache = new WeakHashMap();\n+    //private static WeakHashMap cCache = new WeakHashMap();\n \n     public static GJLocaleSymbols forLocale(Locale locale) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);\n-        GJLocaleSymbols symbols = cFastCache[index];\n-        if (symbols != null && symbols.iLocale.get() == locale) {\n-            return symbols;\n-        }\n-        synchronized (cCache) {\n-            symbols = (GJLocaleSymbols) cCache.get(locale);\n-            if (symbols == null) {\n-                symbols = new GJLocaleSymbols(locale);\n-                cCache.put(locale, symbols);\n-            }\n-        }\n-        cFastCache[index] = symbols;\n-        return symbols;\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (locale == null) {\n+//            locale = Locale.getDefault();\n+//        }\n+//        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);\n+//        GJLocaleSymbols symbols = cFastCache[index];\n+//        if (symbols != null && symbols.iLocale.get() == locale) {\n+//            return symbols;\n+//        }\n+//        synchronized (cCache) {\n+//            symbols = (GJLocaleSymbols) cCache.get(locale);\n+//            if (symbols == null) {\n+//                symbols = new GJLocaleSymbols(locale);\n+//                cCache.put(locale, symbols);\n+//            }\n+//        }\n+//        cFastCache[index] = symbols;\n+//        return symbols;\n     }\n \n     private static String[] realignMonths(String[] months) {\n         return max;\n     }\n \n-    private final WeakReference iLocale;\n+    //private final WeakReference iLocale;\n \n     private final String[] iEras;\n     private final String[] iDaysOfWeek;\n      * @param locale must not be null\n      */\n     private GJLocaleSymbols(Locale locale) {\n-        iLocale = new WeakReference(locale);\n+        //iLocale = new WeakReference(locale);\n \n         DateFormatSymbols dfs = new DateFormatSymbols(locale);\n \n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/convert/ConverterManager.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.JodaTimePermission;\n+//import org.joda.time.JodaTimePermission;\n \n /**\n  * ConverterManager controls the date and time converters.\n      * @throws SecurityException if the user does not have the permission\n      */\n     private void checkAlterInstantConverters() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws SecurityException if the user does not have the permission\n      */\n     private void checkAlterPartialConverters() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws SecurityException if the user does not have the permission\n      */\n     private void checkAlterDurationConverters() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws SecurityException if the user does not have the permission\n      */\n     private void checkAlterPeriodConverters() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws SecurityException if the user does not have the permission\n      */\n     private void checkAlterIntervalConverters() throws SecurityException {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\n-        }\n+//        SecurityManager sm = System.getSecurityManager();\n+//        if (sm != null) {\n+//            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/convert/ConverterSet.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/convert/ConverterSet.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.gwt.util.Arrays;\n+import org.joda.time.gwt.util.ExceptionUtils;\n+\n /**\n  * A set of converters, which allows exact converters to be quickly\n  * selected. This class is threadsafe because it is (essentially) immutable.\n         // Do all updates on a copy: slots in iSelectEntries must not be\n         // updated by multiple threads as this can allow all null slots to be\n         // consumed.\n-        entries = (Entry[])entries.clone();\n+        //entries = (Entry[])entries.clone();\n+        entries = new Entry[entries.length];\n+        Arrays.copy(entries, entries);\n \n         // Add new entry.\n         entries[index] = e;\n                 return converter;\n             }\n \n-            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n-                // Eliminate the impossible.\n-                set = set.remove(i, null);\n-                converters = set.iConverters;\n-                length = converters.length;\n-            }\n+            throw ExceptionUtils.unsupportedInGwt();\n+//            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n+//                // Eliminate the impossible.\n+//                set = set.remove(i, null);\n+//                converters = set.iConverters;\n+//                length = converters.length;\n+//            }\n         }\n \n         // Haven't found exact match, so check what remains in the set.\n             converter = converters[i];\n             Class supportedType = converter.getSupportedType();\n             for (int j=length; --j>=0; ) {\n-                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n-                    // Eliminate supertype.\n-                    set = set.remove(j, null);\n-                    converters = set.iConverters;\n-                    length = converters.length;\n-                    i = length - 1;\n-                }\n+                throw ExceptionUtils.unsupportedInGwt();\n+//                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n+//                    // Eliminate supertype.\n+//                    set = set.remove(j, null);\n+//                    converters = set.iConverters;\n+//                    length = converters.length;\n+//                    i = length - 1;\n+//                }\n             }\n         }        \n         \n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * Factory that creates instances of DateTimeFormatter from patterns and styles.\n         }\n \n         String getPattern(Locale locale) {\n-            DateFormat f = null;\n-            switch (iType) {\n-                case DATE:\n-                    f = DateFormat.getDateInstance(iDateStyle, locale);\n-                    break;\n-                case TIME:\n-                    f = DateFormat.getTimeInstance(iTimeStyle, locale);\n-                    break;\n-                case DATETIME:\n-                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);\n-                    break;\n-            }\n-            if (f instanceof SimpleDateFormat == false) {\n-                throw new IllegalArgumentException(\"No datetime pattern for locale: \" + locale);\n-            }\n-            return ((SimpleDateFormat) f).toPattern();\n+            throw ExceptionUtils.unsupportedInGwt();\n+//            DateFormat f = null;\n+//            switch (iType) {\n+//                case DATE:\n+//                    f = DateFormat.getDateInstance(iDateStyle, locale);\n+//                    break;\n+//                case TIME:\n+//                    f = DateFormat.getTimeInstance(iTimeStyle, locale);\n+//                    break;\n+//                case DATETIME:\n+//                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);\n+//                    break;\n+//            }\n+//            if (f instanceof SimpleDateFormat == false) {\n+//                throw new IllegalArgumentException(\"No datetime pattern for locale: \" + locale);\n+//            }\n+//            return ((SimpleDateFormat) f).toPattern();\n         }\n     }\n \n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeFormatterBuilder.java\n                     for (int i = min; i <= max; i++) {\n                         property.set(i);\n                         validValues.add(property.getAsShortText(locale));\n-                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n-                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n+                        //validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n+                        //validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n+                        validValues.add(property.getAsShortText(locale).toLowerCase());\n+                        validValues.add(property.getAsShortText(locale).toUpperCase());\n                         validValues.add(property.getAsText(locale));\n-                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n-                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n+                        //validValues.add(property.getAsText(locale).toLowerCase(locale));\n+                        //validValues.add(property.getAsText(locale).toUpperCase(locale));\n+                        validValues.add(property.getAsText(locale).toLowerCase());\n+                        validValues.add(property.getAsText(locale).toUpperCase());\n                     }\n                     if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                         // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/DateTimeParserBucket.java\n         SavedField[] savedFields = iSavedFields;\n         int count = iSavedFieldsCount;\n         if (iSavedFieldsShared) {\n-            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+            //iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+            savedFields = new SavedField[iSavedFields.length];\n+            org.joda.time.gwt.util.Arrays.copy(iSavedFields, savedFields);\n+            iSavedFields = savedFields;\n             iSavedFieldsShared = false;\n         }\n         sort(savedFields, count);\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/format/PeriodFormatterBuilder.java\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadablePeriod;\n+import org.joda.time.gwt.util.Arrays;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * Factory that creates complex instances of PeriodFormatter via method calls.\n      */\n     public PeriodFormatter toFormatter() {\n         PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n-        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n+        //iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n+        iFieldFormatters = new FieldFormatter[iFieldFormatters.length];\n+        Arrays.copy(iFieldFormatters, iFieldFormatters);\n         return formatter;\n     }\n \n         for (i=pairs.size(); --i>=0; ) {\n             if (pairs.get(i) instanceof Separator) {\n                 lastSeparator = (Separator) pairs.get(i);\n-                pairs = pairs.subList(i + 1, pairs.size());\n-                break;\n+                throw ExceptionUtils.unsupportedInGwt();\n+                //pairs = pairs.subList(i + 1, pairs.size());\n+                //break;\n             }\n             i--;  // element pairs\n         }\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n-            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n-            sep = sep.finish(f.getPrinter(), f.getParser());\n-            return new PeriodFormatter(sep, sep);\n+            throw ExceptionUtils.unsupportedInGwt();\n+            //PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n+            //sep = sep.finish(f.getPrinter(), f.getParser());\n+            //return new PeriodFormatter(sep, sep);\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/CachedDateTimeZone.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/CachedDateTimeZone.java\n     private static final int cInfoCacheMask;\n \n     static {\n-        Integer i;\n-        try {\n-            i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n-        } catch (SecurityException e) {\n-            i = null;\n-        }\n-\n-        int cacheSize;\n-        if (i == null) {\n-            // With a cache size of 512, dates that lie within any 69.7 year\n-            // period have no cache collisions.\n-            cacheSize = 512; // (1 << 9)\n-        } else {\n-            cacheSize = i.intValue();\n-            // Ensure cache size is even power of 2.\n-            cacheSize--;\n-            int shift = 0;\n-            while (cacheSize > 0) {\n-                shift++;\n-                cacheSize >>= 1;\n-            }\n-            cacheSize = 1 << shift;\n-        }\n-\n+//        Integer i;\n+//        try {\n+//            i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n+//        } catch (SecurityException e) {\n+//            i = null;\n+//        }\n+//\n+//        int cacheSize;\n+//        if (i == null) {\n+//            // With a cache size of 512, dates that lie within any 69.7 year\n+//            // period have no cache collisions.\n+//            cacheSize = 512; // (1 << 9)\n+//        } else {\n+//            cacheSize = i.intValue();\n+//            // Ensure cache size is even power of 2.\n+//            cacheSize--;\n+//            int shift = 0;\n+//            while (cacheSize > 0) {\n+//                shift++;\n+//                cacheSize >>= 1;\n+//            }\n+//            cacheSize = 1 << shift;\n+//        }\n+\n+        int cacheSize = 512;\n         cInfoCacheMask = cacheSize - 1;\n     }\n \n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/DateTimeZoneBuilder.java\n package org.joda.time.tz;\n \n import java.io.DataInput;\n-import java.io.DataInputStream;\n+//import java.io.DataInputStream;\n import java.io.DataOutput;\n-import java.io.DataOutputStream;\n+//import java.io.DataOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.text.DateFormatSymbols;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.HashSet;\n+//import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Locale;\n-import java.util.Set;\n+//import java.util.Set;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.Period;\n import org.joda.time.PeriodType;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since\n      * @param id time zone id to assign\n      */\n     public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n-        if (in instanceof DataInput) {\n-            return readFrom((DataInput)in, id);\n-        } else {\n-            return readFrom((DataInput)new DataInputStream(in), id);\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (in instanceof DataInput) {\n+//            return readFrom((DataInput)in, id);\n+//        } else {\n+//            return readFrom((DataInput)new DataInputStream(in), id);\n+//        }\n     }\n \n     /**\n      * @param id time zone id to assign\n      */\n     public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n-        switch (in.readUnsignedByte()) {\n-        case 'F':\n-            DateTimeZone fixed = new FixedDateTimeZone\n-                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n-            if (fixed.equals(DateTimeZone.UTC)) {\n-                fixed = DateTimeZone.UTC;\n-            }\n-            return fixed;\n-        case 'C':\n-            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n-        case 'P':\n-            return PrecalculatedZone.readFrom(in, id);\n-        default:\n-            throw new IOException(\"Invalid encoding\");\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        switch (in.readUnsignedByte()) {\n+//        case 'F':\n+//            DateTimeZone fixed = new FixedDateTimeZone\n+//                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n+//            if (fixed.equals(DateTimeZone.UTC)) {\n+//                fixed = DateTimeZone.UTC;\n+//            }\n+//            return fixed;\n+//        case 'C':\n+//            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n+//        case 'P':\n+//            return PrecalculatedZone.readFrom(in, id);\n+//        default:\n+//            throw new IOException(\"Invalid encoding\");\n+//        }\n     }\n \n     /**\n      * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.\n      */\n     static void writeMillis(DataOutput out, long millis) throws IOException {\n-        if (millis % (30 * 60000L) == 0) {\n-            // Try to write in 30 minute units.\n-            long units = millis / (30 * 60000L);\n-            if (((units << (64 - 6)) >> (64 - 6)) == units) {\n-                // Form 00 (6 bits effective precision)\n-                out.writeByte((int)(units & 0x3f));\n-                return;\n-            }\n-        }\n-\n-        if (millis % 60000L == 0) {\n-            // Try to write minutes.\n-            long minutes = millis / 60000L;\n-            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n-                // Form 01 (30 bits effective precision)\n-                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));\n-                return;\n-            }\n-        }\n-        \n-        if (millis % 1000L == 0) {\n-            // Try to write seconds.\n-            long seconds = millis / 1000L;\n-            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n-                // Form 10 (38 bits effective precision)\n-                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));\n-                out.writeInt((int)(seconds & 0xffffffff));\n-                return;\n-            }\n-        }\n-\n-        // Write milliseconds either because the additional precision is\n-        // required or the minutes didn't fit in the field.\n-        \n-        // Form 11 (64 bits effective precision, but write as if 70 bits)\n-        out.writeByte(millis < 0 ? 0xff : 0xc0);\n-        out.writeLong(millis);\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (millis % (30 * 60000L) == 0) {\n+//            // Try to write in 30 minute units.\n+//            long units = millis / (30 * 60000L);\n+//            if (((units << (64 - 6)) >> (64 - 6)) == units) {\n+//                // Form 00 (6 bits effective precision)\n+//                out.writeByte((int)(units & 0x3f));\n+//                return;\n+//            }\n+//        }\n+//\n+//        if (millis % 60000L == 0) {\n+//            // Try to write minutes.\n+//            long minutes = millis / 60000L;\n+//            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n+//                // Form 01 (30 bits effective precision)\n+//                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));\n+//                return;\n+//            }\n+//        }\n+//        \n+//        if (millis % 1000L == 0) {\n+//            // Try to write seconds.\n+//            long seconds = millis / 1000L;\n+//            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n+//                // Form 10 (38 bits effective precision)\n+//                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));\n+//                out.writeInt((int)(seconds & 0xffffffff));\n+//                return;\n+//            }\n+//        }\n+//\n+//        // Write milliseconds either because the additional precision is\n+//        // required or the minutes didn't fit in the field.\n+//        \n+//        // Form 11 (64 bits effective precision, but write as if 70 bits)\n+//        out.writeByte(millis < 0 ? 0xff : 0xc0);\n+//        out.writeLong(millis);\n     }\n \n     /**\n      * Reads encoding generated by writeMillis.\n      */\n     static long readMillis(DataInput in) throws IOException {\n-        int v = in.readUnsignedByte();\n-        switch (v >> 6) {\n-        case 0: default:\n-            // Form 00 (6 bits effective precision)\n-            v = (v << (32 - 6)) >> (32 - 6);\n-            return v * (30 * 60000L);\n-\n-        case 1:\n-            // Form 01 (30 bits effective precision)\n-            v = (v << (32 - 6)) >> (32 - 30);\n-            v |= (in.readUnsignedByte()) << 16;\n-            v |= (in.readUnsignedByte()) << 8;\n-            v |= (in.readUnsignedByte());\n-            return v * 60000L;\n-\n-        case 2:\n-            // Form 10 (38 bits effective precision)\n-            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n-            w |= (in.readUnsignedByte()) << 24;\n-            w |= (in.readUnsignedByte()) << 16;\n-            w |= (in.readUnsignedByte()) << 8;\n-            w |= (in.readUnsignedByte());\n-            return w * 1000L;\n-\n-        case 3:\n-            // Form 11 (64 bits effective precision)\n-            return in.readLong();\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        int v = in.readUnsignedByte();\n+//        switch (v >> 6) {\n+//        case 0: default:\n+//            // Form 00 (6 bits effective precision)\n+//            v = (v << (32 - 6)) >> (32 - 6);\n+//            return v * (30 * 60000L);\n+//\n+//        case 1:\n+//            // Form 01 (30 bits effective precision)\n+//            v = (v << (32 - 6)) >> (32 - 30);\n+//            v |= (in.readUnsignedByte()) << 16;\n+//            v |= (in.readUnsignedByte()) << 8;\n+//            v |= (in.readUnsignedByte());\n+//            return v * 60000L;\n+//\n+//        case 2:\n+//            // Form 10 (38 bits effective precision)\n+//            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n+//            w |= (in.readUnsignedByte()) << 24;\n+//            w |= (in.readUnsignedByte()) << 16;\n+//            w |= (in.readUnsignedByte()) << 8;\n+//            w |= (in.readUnsignedByte());\n+//            return w * 1000L;\n+//\n+//        case 3:\n+//            // Form 11 (64 bits effective precision)\n+//            return in.readLong();\n+//        }\n     }\n \n     private static DateTimeZone buildFixedZone(String id, String nameKey,\n      * @since 1.5 (parameter added)\n      */\n     public void writeTo(String zoneID, OutputStream out) throws IOException {\n-        if (out instanceof DataOutput) {\n-            writeTo(zoneID, (DataOutput)out);\n-        } else {\n-            writeTo(zoneID, (DataOutput)new DataOutputStream(out));\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        if (out instanceof DataOutput) {\n+//            writeTo(zoneID, (DataOutput)out);\n+//        } else {\n+//            writeTo(zoneID, (DataOutput)new DataOutputStream(out));\n+//        }\n     }\n \n     /**\n      * @since 1.5 (parameter added)\n      */\n     public void writeTo(String zoneID, DataOutput out) throws IOException {\n-        // pass false so zone id is not written out\n-        DateTimeZone zone = toDateTimeZone(zoneID, false);\n-\n-        if (zone instanceof FixedDateTimeZone) {\n-            out.writeByte('F'); // 'F' for fixed\n-            out.writeUTF(zone.getNameKey(0));\n-            writeMillis(out, zone.getOffset(0));\n-            writeMillis(out, zone.getStandardOffset(0));\n-        } else {\n-            if (zone instanceof CachedDateTimeZone) {\n-                out.writeByte('C'); // 'C' for cached, precalculated\n-                zone = ((CachedDateTimeZone)zone).getUncachedZone();\n-            } else {\n-                out.writeByte('P'); // 'P' for precalculated, uncached\n-            }\n-            ((PrecalculatedZone)zone).writeTo(out);\n-        }\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        // pass false so zone id is not written out\n+//        DateTimeZone zone = toDateTimeZone(zoneID, false);\n+//\n+//        if (zone instanceof FixedDateTimeZone) {\n+//            out.writeByte('F'); // 'F' for fixed\n+//            out.writeUTF(zone.getNameKey(0));\n+//            writeMillis(out, zone.getOffset(0));\n+//            writeMillis(out, zone.getStandardOffset(0));\n+//        } else {\n+//            if (zone instanceof CachedDateTimeZone) {\n+//                out.writeByte('C'); // 'C' for cached, precalculated\n+//                zone = ((CachedDateTimeZone)zone).getUncachedZone();\n+//            } else {\n+//                out.writeByte('P'); // 'P' for precalculated, uncached\n+//            }\n+//            ((PrecalculatedZone)zone).writeTo(out);\n+//        }\n     }\n \n     /**\n      * Supports setting fields of year and moving between transitions.\n      */\n     private static final class OfYear {\n-        static OfYear readFrom(DataInput in) throws IOException {\n-            return new OfYear((char)in.readUnsignedByte(),\n-                              (int)in.readUnsignedByte(),\n-                              (int)in.readByte(),\n-                              (int)in.readUnsignedByte(),\n-                              in.readBoolean(),\n-                              (int)readMillis(in));\n-        }\n+//        static OfYear readFrom(DataInput in) throws IOException {\n+//            return new OfYear((char)in.readUnsignedByte(),\n+//                              (int)in.readUnsignedByte(),\n+//                              (int)in.readByte(),\n+//                              (int)in.readUnsignedByte(),\n+//                              in.readBoolean(),\n+//                              (int)readMillis(in));\n+//        }\n \n         // Is 'u', 'w', or 's'.\n         final char iMode;\n         }\n         */\n \n-        public void writeTo(DataOutput out) throws IOException {\n-            out.writeByte(iMode);\n-            out.writeByte(iMonthOfYear);\n-            out.writeByte(iDayOfMonth);\n-            out.writeByte(iDayOfWeek);\n-            out.writeBoolean(iAdvance);\n-            writeMillis(out, iMillisOfDay);\n-        }\n+//        public void writeTo(DataOutput out) throws IOException {\n+//            out.writeByte(iMode);\n+//            out.writeByte(iMonthOfYear);\n+//            out.writeByte(iDayOfMonth);\n+//            out.writeByte(iDayOfWeek);\n+//            out.writeBoolean(iAdvance);\n+//            writeMillis(out, iMillisOfDay);\n+//        }\n \n         /**\n          * If month-day is 02-29 and year isn't leap, advances to next leap year.\n      * Extends OfYear with a nameKey and savings.\n      */\n     private static final class Recurrence {\n-        static Recurrence readFrom(DataInput in) throws IOException {\n-            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n-        }\n+//        static Recurrence readFrom(DataInput in) throws IOException {\n+//            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n+//        }\n \n         final OfYear iOfYear;\n         final String iNameKey;\n             return false;\n         }\n \n-        public void writeTo(DataOutput out) throws IOException {\n-            iOfYear.writeTo(out);\n-            out.writeUTF(iNameKey);\n-            writeMillis(out, iSaveMillis);\n-        }\n+//        public void writeTo(DataOutput out) throws IOException {\n+//            iOfYear.writeTo(out);\n+//            out.writeUTF(iNameKey);\n+//            writeMillis(out, iSaveMillis);\n+//        }\n \n         Recurrence rename(String nameKey) {\n             return new Recurrence(iOfYear, nameKey, iSaveMillis);\n     private static final class DSTZone extends DateTimeZone {\n         private static final long serialVersionUID = 6941492635554961361L;\n \n-        static DSTZone readFrom(DataInput in, String id) throws IOException {\n-            return new DSTZone(id, (int)readMillis(in), \n-                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n-        }\n+//        static DSTZone readFrom(DataInput in, String id) throws IOException {\n+//            return new DSTZone(id, (int)readMillis(in), \n+//                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n+//        }\n \n         final int iStandardOffset;\n         final Recurrence iStartRecurrence;\n             return false;\n         }\n \n-        public void writeTo(DataOutput out) throws IOException {\n-            writeMillis(out, iStandardOffset);\n-            iStartRecurrence.writeTo(out);\n-            iEndRecurrence.writeTo(out);\n-        }\n+//        public void writeTo(DataOutput out) throws IOException {\n+//            writeMillis(out, iStandardOffset);\n+//            iStartRecurrence.writeTo(out);\n+//            iEndRecurrence.writeTo(out);\n+//        }\n \n         private Recurrence findMatchingRecurrence(long instant) {\n             int standardOffset = iStandardOffset;\n     private static final class PrecalculatedZone extends DateTimeZone {\n         private static final long serialVersionUID = 7811976468055766265L;\n \n-        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n-            // Read string pool.\n-            int poolSize = in.readUnsignedShort();\n-            String[] pool = new String[poolSize];\n-            for (int i=0; i<poolSize; i++) {\n-                pool[i] = in.readUTF();\n-            }\n-\n-            int size = in.readInt();\n-            long[] transitions = new long[size];\n-            int[] wallOffsets = new int[size];\n-            int[] standardOffsets = new int[size];\n-            String[] nameKeys = new String[size];\n-            \n-            for (int i=0; i<size; i++) {\n-                transitions[i] = readMillis(in);\n-                wallOffsets[i] = (int)readMillis(in);\n-                standardOffsets[i] = (int)readMillis(in);\n-                try {\n-                    int index;\n-                    if (poolSize < 256) {\n-                        index = in.readUnsignedByte();\n-                    } else {\n-                        index = in.readUnsignedShort();\n-                    }\n-                    nameKeys[i] = pool[index];\n-                } catch (ArrayIndexOutOfBoundsException e) {\n-                    throw new IOException(\"Invalid encoding\");\n-                }\n-            }\n-\n-            DSTZone tailZone = null;\n-            if (in.readBoolean()) {\n-                tailZone = DSTZone.readFrom(in, id);\n-            }\n-\n-            return new PrecalculatedZone\n-                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n-        }\n+//        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n+//            // Read string pool.\n+//            int poolSize = in.readUnsignedShort();\n+//            String[] pool = new String[poolSize];\n+//            for (int i=0; i<poolSize; i++) {\n+//                pool[i] = in.readUTF();\n+//            }\n+//\n+//            int size = in.readInt();\n+//            long[] transitions = new long[size];\n+//            int[] wallOffsets = new int[size];\n+//            int[] standardOffsets = new int[size];\n+//            String[] nameKeys = new String[size];\n+//            \n+//            for (int i=0; i<size; i++) {\n+//                transitions[i] = readMillis(in);\n+//                wallOffsets[i] = (int)readMillis(in);\n+//                standardOffsets[i] = (int)readMillis(in);\n+//                try {\n+//                    int index;\n+//                    if (poolSize < 256) {\n+//                        index = in.readUnsignedByte();\n+//                    } else {\n+//                        index = in.readUnsignedShort();\n+//                    }\n+//                    nameKeys[i] = pool[index];\n+//                } catch (ArrayIndexOutOfBoundsException e) {\n+//                    throw new IOException(\"Invalid encoding\");\n+//                }\n+//            }\n+//\n+//            DSTZone tailZone = null;\n+//            if (in.readBoolean()) {\n+//                tailZone = DSTZone.readFrom(in, id);\n+//            }\n+//\n+//            return new PrecalculatedZone\n+//                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n+//        }\n \n         /**\n          * Factory to create instance from builder.\n             return false;\n         }\n \n-        public void writeTo(DataOutput out) throws IOException {\n-            int size = iTransitions.length;\n-\n-            // Create unique string pool.\n-            Set poolSet = new HashSet();\n-            for (int i=0; i<size; i++) {\n-                poolSet.add(iNameKeys[i]);\n-            }\n-\n-            int poolSize = poolSet.size();\n-            if (poolSize > 65535) {\n-                throw new UnsupportedOperationException(\"String pool is too large\");\n-            }\n-            String[] pool = new String[poolSize];\n-            Iterator it = poolSet.iterator();\n-            for (int i=0; it.hasNext(); i++) {\n-                pool[i] = (String)it.next();\n-            }\n-\n-            // Write out the pool.\n-            out.writeShort(poolSize);\n-            for (int i=0; i<poolSize; i++) {\n-                out.writeUTF(pool[i]);\n-            }\n-\n-            out.writeInt(size);\n-\n-            for (int i=0; i<size; i++) {\n-                writeMillis(out, iTransitions[i]);\n-                writeMillis(out, iWallOffsets[i]);\n-                writeMillis(out, iStandardOffsets[i]);\n-                \n-                // Find pool index and write it out.\n-                String nameKey = iNameKeys[i];\n-                for (int j=0; j<poolSize; j++) {\n-                    if (pool[j].equals(nameKey)) {\n-                        if (poolSize < 256) {\n-                            out.writeByte(j);\n-                        } else {\n-                            out.writeShort(j);\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            out.writeBoolean(iTailZone != null);\n-            if (iTailZone != null) {\n-                iTailZone.writeTo(out);\n-            }\n-        }\n+//        public void writeTo(DataOutput out) throws IOException {\n+//            int size = iTransitions.length;\n+//\n+//            // Create unique string pool.\n+//            Set poolSet = new HashSet();\n+//            for (int i=0; i<size; i++) {\n+//                poolSet.add(iNameKeys[i]);\n+//            }\n+//\n+//            int poolSize = poolSet.size();\n+//            if (poolSize > 65535) {\n+//                throw new UnsupportedOperationException(\"String pool is too large\");\n+//            }\n+//            String[] pool = new String[poolSize];\n+//            Iterator it = poolSet.iterator();\n+//            for (int i=0; it.hasNext(); i++) {\n+//                pool[i] = (String)it.next();\n+//            }\n+//\n+//            // Write out the pool.\n+//            out.writeShort(poolSize);\n+//            for (int i=0; i<poolSize; i++) {\n+//                out.writeUTF(pool[i]);\n+//            }\n+//\n+//            out.writeInt(size);\n+//\n+//            for (int i=0; i<size; i++) {\n+//                writeMillis(out, iTransitions[i]);\n+//                writeMillis(out, iWallOffsets[i]);\n+//                writeMillis(out, iStandardOffsets[i]);\n+//                \n+//                // Find pool index and write it out.\n+//                String nameKey = iNameKeys[i];\n+//                for (int j=0; j<poolSize; j++) {\n+//                    if (pool[j].equals(nameKey)) {\n+//                        if (poolSize < 256) {\n+//                            out.writeByte(j);\n+//                        } else {\n+//                            out.writeShort(j);\n+//                        }\n+//                        break;\n+//                    }\n+//                }\n+//            }\n+//\n+//            out.writeBoolean(iTailZone != null);\n+//            if (iTailZone != null) {\n+//                iTailZone.writeTo(out);\n+//            }\n+//        }\n \n         public boolean isCachable() {\n             if (iTailZone != null) {\n--- a/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/FixedDateTimeZone.java\n+++ b/JodaTimeContrib/gwt/src/main/gwt-emul/org/joda/time/emul/org/joda/time/tz/FixedDateTimeZone.java\n package org.joda.time.tz;\n \n import org.joda.time.DateTimeZone;\n+import org.joda.time.gwt.util.ExceptionUtils;\n \n /**\n  * Basic DateTimeZone implementation that has a fixed name key and offsets.\n      * @since 1.5\n      */\n     public java.util.TimeZone toTimeZone() {\n-        String id = getID();\n-        if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n-            // standard format offset [+-]hh:mm\n-            // our ID is without any prefix, so we need to add the GMT back\n-            return java.util.TimeZone.getTimeZone(\"GMT\" + getID());\n-        }\n-        // unusual offset, so setup a SimpleTimeZone as best we can\n-        return new java.util.SimpleTimeZone(iWallOffset, getID());\n+        throw ExceptionUtils.unsupportedInGwt();\n+//        String id = getID();\n+//        if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n+//            // standard format offset [+-]hh:mm\n+//            // our ID is without any prefix, so we need to add the GMT back\n+//            return java.util.TimeZone.getTimeZone(\"GMT\" + getID());\n+//        }\n+//        // unusual offset, so setup a SimpleTimeZone as best we can\n+//        return new java.util.SimpleTimeZone(iWallOffset, getID());\n     }\n \n     public boolean equals(Object obj) {", "timestamp": 1257849039, "metainfo": ""}