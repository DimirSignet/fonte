{"sha": "9282fb099a9662b31168d402cfb80084c41fab5c", "log": "Fix whitespace and line endings  ", "commit": "\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/AbstractStringBasedJodaType.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/AbstractStringBasedJodaType.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.UserType;\n-\n-/**\n- * @author gjoseph\n- */\n-public abstract class AbstractStringBasedJodaType implements UserType, Serializable {\n-    private static final int[] SQL_TYPES = new int[]{Types.VARCHAR};\n-\n-    public int[] sqlTypes() {\n-        return SQL_TYPES;\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n-        String s = (String) Hibernate.STRING.nullSafeGet(resultSet, strings[0]);\n-        if (s == null) {\n-            return null;\n-        }\n-\n-        return fromNonNullString(s);\n-    }\n-\n-    protected abstract Object fromNonNullString(String s);\n-\n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n-        if (value == null) {\n-            Hibernate.STRING.nullSafeSet(preparedStatement, null, index);\n-        } else {\n-            Hibernate.STRING.nullSafeSet(preparedStatement, toNonNullString(value), index);\n-        }\n-    }\n-\n-    protected abstract String toNonNullString(Object value);\n-\n-    public boolean equals(Object x, Object y) throws HibernateException {\n-        if (x == y) {\n-            return true;\n-        }\n-        if (x == null || y == null) {\n-            return false;\n-        }\n-        // why do this !? .. TODO : maybe we need to check types ?\n-        // Period px = (Period) x;\n-        // Period py = (Period) y;\n-\n-        return x.equals(y);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException {\n-        return object.hashCode();\n-    }\n-\n-    public Object deepCopy(Object value) throws HibernateException {\n-        return value;\n-    }\n-\n-    public boolean isMutable() {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n-        return original;\n-    }\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.UserType;\n+\n+/**\n+ * @author gjoseph\n+ */\n+public abstract class AbstractStringBasedJodaType implements UserType, Serializable {\n+    private static final int[] SQL_TYPES = new int[]{Types.VARCHAR};\n+\n+    public int[] sqlTypes() {\n+        return SQL_TYPES;\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n+        String s = (String) Hibernate.STRING.nullSafeGet(resultSet, strings[0]);\n+        if (s == null) {\n+            return null;\n+        }\n+\n+        return fromNonNullString(s);\n+    }\n+\n+    protected abstract Object fromNonNullString(String s);\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n+            Hibernate.STRING.nullSafeSet(preparedStatement, null, index);\n+        } else {\n+            Hibernate.STRING.nullSafeSet(preparedStatement, toNonNullString(value), index);\n+        }\n+    }\n+\n+    protected abstract String toNonNullString(Object value);\n+\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n+            return true;\n+        }\n+        if (x == null || y == null) {\n+            return false;\n+        }\n+        // why do this !? .. TODO : maybe we need to check types ?\n+        // Period px = (Period) x;\n+        // Period py = (Period) y;\n+\n+        return x.equals(y);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException {\n+        return object.hashCode();\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException {\n+        return value;\n+    }\n+\n+    public boolean isMutable() {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n+        return original;\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java\n  */\n public class PersistentDateTime implements EnhancedUserType, Serializable\n {\n-\tpublic final static PersistentDateTime INSTANCE = new PersistentDateTime();\n+    public final static PersistentDateTime INSTANCE = new PersistentDateTime();\n \n-\tprivate static final int[] SQL_TYPES = new int[]\n+    private static final int[] SQL_TYPES = new int[]\n     {\n         Types.TIMESTAMP,\n     };\n \n     public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n     {\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n+        return nullSafeGet(resultSet, strings[0]);\n \n-\t}\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n \n-\t\treturn new DateTime(timestamp);\n-\t}\n+        return new DateTime(timestamp);\n+    }\n \n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((DateTime) value).toDate(), index);\n-\t\t}\n-\t}\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((DateTime) value).toDate(), index);\n+        }\n+    }\n \n     public Object deepCopy(Object value) throws HibernateException\n     {\n         return original;\n     }\n \n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n \n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n \n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new DateTime(string);\n-\t}\n+    public Object fromXMLString(String string)\n+    {\n+        return new DateTime(string);\n+    }\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n  */\n public class PersistentDateTimeTZ implements UserType, Serializable\n {\n-\tpublic final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();\n+    public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();\n \n-\tprivate static final int[] SQL_TYPES = new int[]\n+    private static final int[] SQL_TYPES = new int[]\n     {\n         Types.TIMESTAMP,\n         Types.VARCHAR,\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDuration.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDuration.java\n-/*\n- *  Copyright 2001-2008 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import org.joda.time.Duration;\n-\n-/**\n- * Converts a org.joda.time.Duration to and from Sql for Hibernate.\n- * It simply stores the value as a varchar using Duration.toString.\n- *\n- * @author gjoseph\n- */\n-public class PersistentDuration extends AbstractStringBasedJodaType {\n-\n-    public Class returnedClass() {\n-        return Duration.class;\n-    }\n-\n-    protected Object fromNonNullString(String s) {\n-        return new Duration(s);\n-    }\n-\n-    protected String toNonNullString(Object value) {\n-        return value.toString();\n-    }\n-\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.Duration;\n+\n+/**\n+ * Converts a org.joda.time.Duration to and from Sql for Hibernate.\n+ * It simply stores the value as a varchar using Duration.toString.\n+ *\n+ * @author gjoseph\n+ */\n+public class PersistentDuration extends AbstractStringBasedJodaType {\n+\n+    public Class returnedClass() {\n+        return Duration.class;\n+    }\n+\n+    protected Object fromNonNullString(String s) {\n+        return new Duration(s);\n+    }\n+\n+    protected String toNonNullString(Object value) {\n+        return value.toString();\n+    }\n+\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstant.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstant.java\n         return original;\n     }\n \n-\t// __________ EnhancedUserType ____________________\n+    // __________ EnhancedUserType ____________________\n \n     public String objectToSQLString(Object object)\n     {\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstantAsBigInt.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstantAsBigInt.java\n  */\n public class PersistentInstantAsBigInt implements EnhancedUserType, Serializable\n {\n-\tpublic final static PersistentInstantAsBigInt INSTANCE = new PersistentInstantAsBigInt();\n+    public final static PersistentInstantAsBigInt INSTANCE = new PersistentInstantAsBigInt();\n \n-\tprivate static final int[] SQL_TYPES = new int[] {Types.BIGINT};\n+    private static final int[] SQL_TYPES = new int[] {Types.BIGINT};\n \n-\tpublic int[] sqlTypes()\n-\t{\n-\t\treturn SQL_TYPES;\n-\t}\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n \n-\tpublic Class returnedClass()\n-\t{\n-\t\treturn Instant.class;\n-\t}\n+    public Class returnedClass()\n+    {\n+        return Instant.class;\n+    }\n \n-\tpublic boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-\t\tif (x == y)\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n         {\n-\t\t\treturn true;\n+            return true;\n         }\n-\t\tif (x == null || y == null)\n+        if (x == null || y == null)\n         {\n-\t\t\treturn false;\n+            return false;\n         }\n-\t\tInstant ix = (Instant) x;\n-\t\tInstant iy = (Instant) y;\n+        Instant ix = (Instant) x;\n+        Instant iy = (Instant) y;\n \n-\t\treturn ix.equals(iy);\n-\t}\n+        return ix.equals(iy);\n+    }\n \n-\tpublic int hashCode(Object object) throws HibernateException\n-\t{\n-\t\treturn object.hashCode();\n-\t}\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, names[0]);\n-\t}\n+    public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, names[0]);\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String name) throws HibernateException, SQLException\n-\t{\n-\t\tObject value = Hibernate.LONG.nullSafeGet(resultSet, name);\n-\t\tif (value == null)\n+    public Object nullSafeGet(ResultSet resultSet, String name) throws HibernateException, SQLException\n+    {\n+        Object value = Hibernate.LONG.nullSafeGet(resultSet, name);\n+        if (value == null)\n         {\n-\t\t\treturn null;\n+            return null;\n         }\n \n-\t\treturn new Instant(value);\n-\t}\n+        return new Instant(value);\n+    }\n \n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.LONG.nullSafeSet(preparedStatement, null, index);\n-\t    }\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.LONG.nullSafeSet(preparedStatement, new Long(((Instant)value).getMillis()), index);\n-\t\t}\n-\t}\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.LONG.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.LONG.nullSafeSet(preparedStatement, new Long(((Instant)value).getMillis()), index);\n+        }\n+    }\n \n-\tpublic Object deepCopy(Object value) throws HibernateException\n-\t{\n-\t\tif (value == null)\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n         {\n-\t\t\treturn null;\n+            return null;\n         }\n \n-\t\treturn new Instant(value);\n-\t}\n+        return new Instant(value);\n+    }\n \n-\tpublic boolean isMutable()\n-\t{\n-\t\treturn false;\n-\t}\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n \n-\tpublic Serializable disassemble(Object value) throws HibernateException\n-\t{\n-\t\treturn (Serializable)value;\n-\t}\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable)value;\n+    }\n \n-\tpublic Object assemble(Serializable serializable, Object value) throws HibernateException\n-\t{\n-\t\treturn serializable;\n-\t}\n+    public Object assemble(Serializable serializable, Object value) throws HibernateException\n+    {\n+        return serializable;\n+    }\n \n-\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException\n-\t{\n-\t\treturn original;\n-\t}\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n \n-\t// __________ EnhancedUserType ____________________\n+    // __________ EnhancedUserType ____________________\n \n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n \n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n \n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new Instant(string);\n-\t}\n+    public Object fromXMLString(String string)\n+    {\n+        return new Instant(string);\n+    }\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.EnhancedUserType;\n-import org.joda.time.LocalDate;\n-\n-/**\n- * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n- * @author Mario Ivankovits (mario@ops.co.at)\n- */\n-public class PersistentLocalDate implements EnhancedUserType, Serializable\n-{\n-\tpublic final static PersistentLocalDate INSTANCE = new PersistentLocalDate();\n-\n-\tprivate static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.DATE,\n-    };\n-\n-    public int[] sqlTypes()\n-    {\n-        return SQL_TYPES;\n-    }\n-\n-    public Class returnedClass()\n-    {\n-        return LocalDate.class;\n-    }\n-\n-    public boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-        if (x == y)\n-        {\n-            return true;\n-        }\n-        if (x == null || y == null)\n-        {\n-            return false;\n-        }\n-        LocalDate dtx = (LocalDate) x;\n-        LocalDate dty = (LocalDate) y;\n-\n-        return dtx.equals(dty);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException\n-    {\n-        return object.hashCode();\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n-\n-\t}\n-\n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.DATE.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn new LocalDate(timestamp);\n-\t}\n-\n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, ((LocalDate) value).toDateTimeAtStartOfDay().toDate(), index);\n-\t\t}\n-\t}\n-\n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n-            return null;\n-        }\n-\n-        return new LocalDate(value);\n-    }\n-\n-    public boolean isMutable()\n-    {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n-        return original;\n-    }\n-\n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n-\n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n-\n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new LocalDate(string);\n-\t}\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalDate;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalDate implements EnhancedUserType, Serializable\n+{\n+    public final static PersistentLocalDate INSTANCE = new PersistentLocalDate();\n+\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.DATE,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalDate.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalDate dtx = (LocalDate) x;\n+        LocalDate dty = (LocalDate) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n+\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.DATE.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDate(timestamp);\n+    }\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.DATE.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.DATE.nullSafeSet(preparedStatement, ((LocalDate) value).toDateTimeAtStartOfDay().toDate(), index);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDate(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n+\n+    public Object fromXMLString(String string)\n+    {\n+        return new LocalDate(string);\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.EnhancedUserType;\n-import org.joda.time.LocalDateTime;\n-\n-/**\n- * Persist {@link org.joda.time.LocalDateTime} via hibernate.\n- *\n- * @author Mario Ivankovits (mario@ops.co.at)\n- */\n-public class PersistentLocalDateTime implements EnhancedUserType, Serializable\n-{\n-\tpublic final static PersistentLocalDateTime INSTANCE = new PersistentLocalDateTime();\n-\n-\tprivate static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIMESTAMP,\n-    };\n-\n-    public int[] sqlTypes()\n-    {\n-        return SQL_TYPES;\n-    }\n-\n-    public Class returnedClass()\n-    {\n-        return LocalDateTime.class;\n-    }\n-\n-    public boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-        if (x == y)\n-        {\n-            return true;\n-        }\n-        if (x == null || y == null)\n-        {\n-            return false;\n-        }\n-        LocalDateTime dtx = (LocalDateTime) x;\n-        LocalDateTime dty = (LocalDateTime) y;\n-\n-        return dtx.equals(dty);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException\n-    {\n-        return object.hashCode();\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n-\n-\t}\n-\n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn new LocalDateTime(timestamp);\n-\t}\n-\n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((LocalDateTime) value).toDateTime().toDate(), index);\n-\t\t}\n-\t}\n-\n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n-            return null;\n-        }\n-\n-        return new LocalDateTime(value);\n-    }\n-\n-    public boolean isMutable()\n-    {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n-        return original;\n-    }\n-\n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n-\n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n-\n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new LocalDateTime(string);\n-\t}\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalDateTime;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDateTime} via hibernate.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalDateTime implements EnhancedUserType, Serializable\n+{\n+    public final static PersistentLocalDateTime INSTANCE = new PersistentLocalDateTime();\n+\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIMESTAMP,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalDateTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalDateTime dtx = (LocalDateTime) x;\n+        LocalDateTime dty = (LocalDateTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n+\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDateTime(timestamp);\n+    }\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((LocalDateTime) value).toDateTime().toDate(), index);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDateTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n+\n+    public Object fromXMLString(String string)\n+    {\n+        return new LocalDateTime(string);\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.EnhancedUserType;\n-import org.joda.time.LocalTime;\n-\n-/**\n- * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n- * @author Mario Ivankovits (mario@ops.co.at)\n- */\n-public class PersistentLocalTimeAsString implements EnhancedUserType, Serializable\n-{\n-\tpublic final static PersistentLocalTimeAsString INSTANCE = new PersistentLocalTimeAsString();\n-\n-\tprivate static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.VARCHAR,\n-    };\n-\n-    public int[] sqlTypes()\n-    {\n-        return SQL_TYPES;\n-    }\n-\n-    public Class returnedClass()\n-    {\n-        return LocalTime.class;\n-    }\n-\n-    public boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-        if (x == y)\n-        {\n-            return true;\n-        }\n-        if (x == null || y == null)\n-        {\n-            return false;\n-        }\n-        LocalTime dtx = (LocalTime) x;\n-        LocalTime dty = (LocalTime) y;\n-\n-        return dtx.equals(dty);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException\n-    {\n-        return object.hashCode();\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n-\n-\t}\n-\n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.STRING.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn new LocalTime(timestamp.toString());\n-\t}\n-\n-\n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.STRING.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tLocalTime lt = ((LocalTime) value);\n-\n-\t\t\tHibernate.STRING.nullSafeSet(preparedStatement, lt.toString(), index);\n-\t\t}\n-\t}\n-\n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n-            return null;\n-        }\n-\n-        return new LocalTime(value);\n-    }\n-\n-    public boolean isMutable()\n-    {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n-        return original;\n-    }\n-\n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n-\n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n-\n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new LocalTime(string);\n-\t}\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalTime;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeAsString implements EnhancedUserType, Serializable\n+{\n+    public final static PersistentLocalTimeAsString INSTANCE = new PersistentLocalTimeAsString();\n+\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.VARCHAR,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n+\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.STRING.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(timestamp.toString());\n+    }\n+\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.STRING.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            LocalTime lt = ((LocalTime) value);\n+\n+            Hibernate.STRING.nullSafeSet(preparedStatement, lt.toString(), index);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n+\n+    public Object fromXMLString(String string)\n+    {\n+        return new LocalTime(string);\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Time;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.EnhancedUserType;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.LocalTime;\n-\n-/**\n- * Persist {@link org.joda.time.LocalDate} via hibernate.\n- * This uses a simple integer to store the time as milliseconds since 1970-1-1.\n- * The milliseconds will survive.\n- *\n- * @author Mario Ivankovits (mario@ops.co.at)\n- */\n-public class PersistentLocalTimeAsTime implements EnhancedUserType, Serializable\n-{\n-\tpublic final static PersistentLocalTimeAsTime INSTANCE = new PersistentLocalTimeAsTime();\n-\n-\tprivate static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIME,\n-    };\n-\n-    public int[] sqlTypes()\n-    {\n-        return SQL_TYPES;\n-    }\n-\n-    public Class returnedClass()\n-    {\n-        return LocalTime.class;\n-    }\n-\n-    public boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-        if (x == y)\n-        {\n-            return true;\n-        }\n-        if (x == null || y == null)\n-        {\n-            return false;\n-        }\n-        LocalTime dtx = (LocalTime) x;\n-        LocalTime dty = (LocalTime) y;\n-\n-        return dtx.equals(dty);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException\n-    {\n-        return object.hashCode();\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n-\n-\t}\n-\n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.TIME.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn new LocalTime(timestamp, DateTimeZone.UTC);\n-\t}\n-\n-\n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tLocalTime lt = ((LocalTime) value);\n-\t\t\tTime time = new Time(lt.getMillisOfDay());\n-\n-\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, time, index);\n-\t\t}\n-\t}\n-\n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n-            return null;\n-        }\n-\n-        return new LocalTime(value);\n-    }\n-\n-    public boolean isMutable()\n-    {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n-        return original;\n-    }\n-\n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n-\n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n-\n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new LocalTime(string);\n-\t}\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalTime;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate.\n+ * This uses a simple integer to store the time as milliseconds since 1970-1-1.\n+ * The milliseconds will survive.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeAsTime implements EnhancedUserType, Serializable\n+{\n+    public final static PersistentLocalTimeAsTime INSTANCE = new PersistentLocalTimeAsTime();\n+\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIME,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n+\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.TIME.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(timestamp, DateTimeZone.UTC);\n+    }\n+\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIME.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            LocalTime lt = ((LocalTime) value);\n+            Time time = new Time(lt.getMillisOfDay());\n+\n+            Hibernate.TIME.nullSafeSet(preparedStatement, time, index);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n+\n+    public Object fromXMLString(String string)\n+    {\n+        return new LocalTime(string);\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java\n-/*\n- *  Copyright 2001-2009 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import java.io.Serializable;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-\n-import org.hibernate.Hibernate;\n-import org.hibernate.HibernateException;\n-import org.hibernate.usertype.EnhancedUserType;\n-import org.joda.time.LocalTime;\n-\n-/**\n- * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n- * @author Mario Ivankovits (mario@ops.co.at)\n- */\n-public class PersistentLocalTimeExact implements EnhancedUserType, Serializable\n-{\n-\tpublic final static PersistentLocalTimeExact INSTANCE = new PersistentLocalTimeExact();\n-\n-\tprivate static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.INTEGER,\n-    };\n-\n-    public int[] sqlTypes()\n-    {\n-        return SQL_TYPES;\n-    }\n-\n-    public Class returnedClass()\n-    {\n-        return LocalTime.class;\n-    }\n-\n-    public boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-        if (x == y)\n-        {\n-            return true;\n-        }\n-        if (x == null || y == null)\n-        {\n-            return false;\n-        }\n-        LocalTime dtx = (LocalTime) x;\n-        LocalTime dty = (LocalTime) y;\n-\n-        return dtx.equals(dty);\n-    }\n-\n-    public int hashCode(Object object) throws HibernateException\n-    {\n-        return object.hashCode();\n-    }\n-\n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n-\n-\t}\n-\n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject timestamp = Hibernate.INTEGER.nullSafeGet(resultSet, string);\n-\t\tif (timestamp == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn LocalTime.fromMillisOfDay(((Number) timestamp).intValue());\n-\t}\n-\n-\n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.INTEGER.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tLocalTime lt = ((LocalTime) value);\n-\n-\t\t\tHibernate.INTEGER.nullSafeSet(preparedStatement, new Integer(lt.getMillisOfDay()), index);\n-\t\t}\n-\t}\n-\n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n-            return null;\n-        }\n-\n-        return new LocalTime(value);\n-    }\n-\n-    public boolean isMutable()\n-    {\n-        return false;\n-    }\n-\n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable) value;\n-    }\n-\n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n-        return cached;\n-    }\n-\n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n-        return original;\n-    }\n-\n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n-\n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n-\n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new LocalTime(string);\n-\t}\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalTime;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeExact implements EnhancedUserType, Serializable\n+{\n+    public final static PersistentLocalTimeExact INSTANCE = new PersistentLocalTimeExact();\n+\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.INTEGER,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n+\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object timestamp = Hibernate.INTEGER.nullSafeGet(resultSet, string);\n+        if (timestamp == null)\n+        {\n+            return null;\n+        }\n+\n+        return LocalTime.fromMillisOfDay(((Number) timestamp).intValue());\n+    }\n+\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.INTEGER.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            LocalTime lt = ((LocalTime) value);\n+\n+            Hibernate.INTEGER.nullSafeSet(preparedStatement, new Integer(lt.getMillisOfDay()), index);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n+\n+    public Object fromXMLString(String string)\n+    {\n+        return new LocalTime(string);\n+    }\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentPeriod.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentPeriod.java\n-/*\n- *  Copyright 2001-2008 Stephen Colebourne\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.joda.time.contrib.hibernate;\n-\n-import org.joda.time.Period;\n-\n-/**\n- * Converts a org.joda.time.Period to and from Sql for Hibernate.\n- * It simply stores and retrieves the value as a varchar using Period.toString.\n- *\n- * @author gjoseph\n- */\n-public class PersistentPeriod extends AbstractStringBasedJodaType {\n-\n-    public Class returnedClass() {\n-        return Period.class;\n-    }\n-\n-    protected Object fromNonNullString(String s) {\n-        return new Period(s);\n-    }\n-\n-    protected String toNonNullString(Object value) {\n-        return value.toString();\n-    }\n-\n-}\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.Period;\n+\n+/**\n+ * Converts a org.joda.time.Period to and from Sql for Hibernate.\n+ * It simply stores and retrieves the value as a varchar using Period.toString.\n+ *\n+ * @author gjoseph\n+ */\n+public class PersistentPeriod extends AbstractStringBasedJodaType {\n+\n+    public Class returnedClass() {\n+        return Period.class;\n+    }\n+\n+    protected Object fromNonNullString(String s) {\n+        return new Period(s);\n+    }\n+\n+    protected String toNonNullString(Object value) {\n+        return value.toString();\n+    }\n+\n+}\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java\n  */\n public class PersistentTimeOfDay implements EnhancedUserType, Serializable\n {\n-\tprivate final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n-\tpublic final static PersistentTimeOfDay INSTANCE = new PersistentTimeOfDay();\n+    private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+    public final static PersistentTimeOfDay INSTANCE = new PersistentTimeOfDay();\n \n-\tprivate static final int[] SQL_TYPES = new int[]\n-\t{\n-\t\tTypes.TIME,\n-\t};\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIME,\n+    };\n \n-\tpublic int[] sqlTypes()\n-\t{\n-\t\treturn SQL_TYPES;\n-\t}\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n \n-\tpublic Class returnedClass()\n-\t{\n-\t\treturn TimeOfDay.class;\n-\t}\n+    public Class returnedClass()\n+    {\n+        return TimeOfDay.class;\n+    }\n \n-\tpublic boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-\t\tif (x == y)\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (x == null || y == null)\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t\tTimeOfDay dtx = (TimeOfDay) x;\n-\t\tTimeOfDay dty = (TimeOfDay) y;\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        TimeOfDay dtx = (TimeOfDay) x;\n+        TimeOfDay dty = (TimeOfDay) y;\n \n-\t\treturn dtx.equals(dty);\n-\t}\n+        return dtx.equals(dty);\n+    }\n \n-\tpublic int hashCode(Object object) throws HibernateException\n-\t{\n-\t\treturn object.hashCode();\n-\t}\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n \n-\t}\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject date = Hibernate.TIME.nullSafeGet(resultSet, string);\n-\t\tif (date == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object date = Hibernate.TIME.nullSafeGet(resultSet, string);\n+        if (date == null)\n+        {\n+            return null;\n+        }\n \n-\t\treturn new TimeOfDay(date);\n-\t}\n+        return new TimeOfDay(date);\n+    }\n \n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);\n-\t\t}\n-\t}\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIME.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.TIME.nullSafeSet(preparedStatement, new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);\n+        }\n+    }\n \n-\tpublic Object deepCopy(Object value) throws HibernateException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n \n-\t\treturn new TimeOfDay(value);\n-\t}\n+        return new TimeOfDay(value);\n+    }\n \n-\tpublic boolean isMutable()\n-\t{\n-\t\treturn false;\n-\t}\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n \n-\tpublic Serializable disassemble(Object value) throws HibernateException\n-\t{\n-\t\treturn (Serializable) value;\n-\t}\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n \n-\tpublic Object assemble(Serializable cached, Object value) throws HibernateException\n-\t{\n-\t\treturn cached;\n-\t}\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n \n-\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException\n-\t{\n-\t\treturn original;\n-\t}\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n \n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n \n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n \n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new TimeOfDay(string);\n-\t}\n+    public Object fromXMLString(String string)\n+    {\n+        return new TimeOfDay(string);\n+    }\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java\n  */\n public class PersistentTimeOfDayExact implements EnhancedUserType, Serializable\n {\n-\tprivate final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n-\tpublic final static PersistentTimeOfDayExact INSTANCE = new PersistentTimeOfDayExact();\n+    private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+    public final static PersistentTimeOfDayExact INSTANCE = new PersistentTimeOfDayExact();\n \n-\tprivate static final int[] SQL_TYPES = new int[]\n-\t{\n-\t\tTypes.INTEGER,\n-\t};\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.INTEGER,\n+    };\n \n-\tpublic int[] sqlTypes()\n-\t{\n-\t\treturn SQL_TYPES;\n-\t}\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n \n-\tpublic Class returnedClass()\n-\t{\n-\t\treturn TimeOfDay.class;\n-\t}\n+    public Class returnedClass()\n+    {\n+        return TimeOfDay.class;\n+    }\n \n-\tpublic boolean equals(Object x, Object y) throws HibernateException\n-\t{\n-\t\tif (x == y)\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (x == null || y == null)\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t\tTimeOfDay dtx = (TimeOfDay) x;\n-\t\tTimeOfDay dty = (TimeOfDay) y;\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        TimeOfDay dtx = (TimeOfDay) x;\n+        TimeOfDay dty = (TimeOfDay) y;\n \n-\t\treturn dtx.equals(dty);\n-\t}\n+        return dtx.equals(dty);\n+    }\n \n-\tpublic int hashCode(Object object) throws HibernateException\n-\t{\n-\t\treturn object.hashCode();\n-\t}\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-\t{\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        return nullSafeGet(resultSet, strings[0]);\n \n-\t}\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tint value = resultSet.getInt(string);\n-\t\tif (resultSet.wasNull())\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        int value = resultSet.getInt(string);\n+        if (resultSet.wasNull())\n+        {\n+            return null;\n+        }\n \n-\t\treturn new TimeOfDay(value);\n-\t}\n+        return new TimeOfDay(value);\n+    }\n \n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tpreparedStatement.setNull(index, SQL_TYPES[0]);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tpreparedStatement.setInt(index, (int) ((TimeOfDay) value).toDateTime(timeBase).getMillis());\n-\t\t}\n-\t}\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            preparedStatement.setNull(index, SQL_TYPES[0]);\n+        }\n+        else\n+        {\n+            preparedStatement.setInt(index, (int) ((TimeOfDay) value).toDateTime(timeBase).getMillis());\n+        }\n+    }\n \n-\tpublic Object deepCopy(Object value) throws HibernateException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n \n-\t\treturn new TimeOfDay(value);\n-\t}\n+        return new TimeOfDay(value);\n+    }\n \n-\tpublic boolean isMutable()\n-\t{\n-\t\treturn false;\n-\t}\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n \n-\tpublic Serializable disassemble(Object value) throws HibernateException\n-\t{\n-\t\treturn (Serializable) value;\n-\t}\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n \n-\tpublic Object assemble(Serializable cached, Object value) throws HibernateException\n-\t{\n-\t\treturn cached;\n-\t}\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n \n-\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException\n-\t{\n-\t\treturn original;\n-\t}\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n \n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n \n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n \n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new TimeOfDay(string);\n-\t}\n+    public Object fromXMLString(String string)\n+    {\n+        return new TimeOfDay(string);\n+    }\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java\n  */\n public class PersistentYearMonthDay implements EnhancedUserType, Serializable\n {\n-\tpublic final static PersistentYearMonthDay INSTANCE = new PersistentYearMonthDay();\n+    public final static PersistentYearMonthDay INSTANCE = new PersistentYearMonthDay();\n \n-\tprivate static final int[] SQL_TYPES = new int[]\n+    private static final int[] SQL_TYPES = new int[]\n     {\n         Types.DATE,\n     };\n \n     public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n     {\n-\t\treturn nullSafeGet(resultSet, strings[0]);\n+        return nullSafeGet(resultSet, strings[0]);\n \n-\t}\n+    }\n \n-\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-\t{\n-\t\tObject date = Hibernate.DATE.nullSafeGet(resultSet, string);\n-\t\tif (date == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+    {\n+        Object date = Hibernate.DATE.nullSafeGet(resultSet, string);\n+        if (date == null)\n+        {\n+            return null;\n+        }\n \n-\t\treturn new YearMonthDay(date);\n-\t}\n+        return new YearMonthDay(date);\n+    }\n \n-\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-\t{\n-\t\tif (value == null)\n-\t\t{\n-\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, null, index);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, ((YearMonthDay) value).toDateMidnight().toDate(), index);\n-\t\t}\n-\t}\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.DATE.nullSafeSet(preparedStatement, null, index);\n+        }\n+        else\n+        {\n+            Hibernate.DATE.nullSafeSet(preparedStatement, ((YearMonthDay) value).toDateMidnight().toDate(), index);\n+        }\n+    }\n \n     public Object deepCopy(Object value) throws HibernateException\n     {\n         return original;\n     }\n \n-\tpublic String objectToSQLString(Object object)\n-\t{\n-\t\tthrow new UnsupportedOperationException();\n-\t}\n+    public String objectToSQLString(Object object)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n \n-\tpublic String toXMLString(Object object)\n-\t{\n-\t\treturn object.toString();\n-\t}\n+    public String toXMLString(Object object)\n+    {\n+        return object.toString();\n+    }\n \n-\tpublic Object fromXMLString(String string)\n-\t{\n-\t\treturn new YearMonthDay(string);\n-\t}\n+    public Object fromXMLString(String string)\n+    {\n+        return new YearMonthDay(string);\n+    }\n }", "timestamp": 1257633659, "metainfo": ""}