{"sha": "89be5d7dd4355ae9d3e841a2b97b59a001c8e85d", "log": "Add functionality to intervals   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n         extends BaseInterval\n         implements ReadableInterval, Serializable {\n \n+    /** An interval over all time, as represented by milliseconds. */\n+    public static final Interval ALWAYS = new Interval(Long.MIN_VALUE, Long.MAX_VALUE);\n+\n     /** Serialization version */\n     private static final long serialVersionUID = 4922451897541386752L;\n \n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n  * An interval can also be converted to a {@link ReadablePeriod}.\n  * This represents the difference between the start and end points in terms of fields\n  * such as years and days.\n+ * <p>\n+ * Methods that are passed an interval as a parameter will treat <code>null</code>\n+ * as a zero length interval at the current instant in time.\n  *\n  * @author Sean Geoghegan\n  * @author Brian S O'Neill\n      * <p>\n      * Intervals are inclusive of the start instant and exclusive of the end.\n      * \n-     * @param interval  the time interval to compare to\n+     * @param interval  the time interval to compare to, null means now\n      * @return true if this time interval contains the time interval\n-     * @throws IllegalArgumentException if the interval is null\n      */\n     boolean contains(ReadableInterval interval);\n     \n      * The intervals overlap if at least some of the time interval is in common.\n      * Intervals are inclusive of the start instant and exclusive of the end.\n      * \n-     * @param interval  the time interval to compare to\n+     * @param interval  the time interval to compare to, null means now\n      * @return true if the time intervals overlap\n-     * @throws IllegalArgumentException if the interval is null\n      */\n     boolean overlaps(ReadableInterval interval);\n     \n     boolean isAfter(ReadableInstant instant);\n     \n     /**\n+     * Is this time interval entirely after the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is after the interval specified\n+     */\n+    boolean isAfter(ReadableInterval interval);\n+    \n+    /**\n      * Is this time interval before the specified instant.\n      * <p>\n      * Intervals are inclusive of the start instant and exclusive of the end.\n      * @return true if this time interval is before the instant\n      */\n     boolean isBefore(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval entirely before the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is before the interval specified\n+     */\n+    boolean isBefore(ReadableInterval interval);\n     \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n      */\n     public boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n-            return contains(DateTimeUtils.currentTimeMillis());\n+            return containsNow();\n         }\n         return contains(instant.getMillis());\n     }\n      * <p>\n      * Intervals are inclusive of the start instant and exclusive of the end.\n      * \n-     * @param interval  the time interval to compare to\n+     * @param interval  the time interval to compare to, null means now\n      * @return true if this time interval contains the time interval\n-     * @throws IllegalArgumentException if the interval is null\n      */\n     public boolean contains(ReadableInterval interval) {\n         if (interval == null) {\n-            throw new IllegalArgumentException(\"The time interval must not be null\");\n+            return containsNow();\n         }\n         long otherStart = interval.getStartMillis();\n         long otherEnd = interval.getEndMillis();\n      * The intervals overlap if at least some of the time interval is in common.\n      * Intervals are inclusive of the start instant and exclusive of the end.\n      * \n-     * @param interval  the time interval to compare to\n+     * @param interval  the time interval to compare to, null means now\n      * @return true if the time intervals overlap\n-     * @throws IllegalArgumentException if the interval is null\n      */\n     public boolean overlaps(ReadableInterval interval) {\n         if (interval == null) {\n-            throw new IllegalArgumentException(\"The time interval must not be null\");\n+            return containsNow();\n         }\n         long otherStart = interval.getStartMillis();\n         long otherEnd = interval.getEndMillis();\n      */\n     public boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n-            return isBefore(DateTimeUtils.currentTimeMillis());\n+            return isBeforeNow();\n         }\n         return isBefore(instant.getMillis());\n     }\n \n+    /**\n+     * Is this time interval entirely before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is before the interval specified\n+     */\n+    public boolean isBefore(ReadableInterval interval) {\n+        if (interval == null) {\n+            return isBeforeNow();\n+        }\n+        return isBefore(interval.getStartMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Is this time interval after the specified millisecond instant.\n      * <p>\n      */\n     public boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n-            return isAfter(DateTimeUtils.currentTimeMillis());\n+            return isAfterNow();\n         }\n         return isAfter(instant.getMillis());\n+    }\n+\n+    /**\n+     * Is this time interval entirely after the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is after the interval specified\n+     */\n+    public boolean isAfter(ReadableInterval interval) {\n+        if (interval == null) {\n+            return isAfterNow();\n+        }\n+        return isAfter(interval.getEndMillis());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n         assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));\n         assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));\n         \n-        try {\n-            test.contains((ReadableInterval) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+        assertEquals(true, test.contains((ReadableInterval) null));\n     }\n \n     public void testOverlaps_RInterval() {\n         assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));\n         assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));\n         \n-        try {\n-            test.overlaps((ReadableInterval) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+        assertEquals(true, test.overlaps((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));\n         assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));\n         \n-        assertEquals(false, test.isBefore(null));\n+        assertEquals(false, test.isBefore((ReadableInstant) null));\n+    }\n+\n+    public void testIsBefore_RInterval() {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));\n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));\n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));\n+        \n+        assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));\n+        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));\n+        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));\n+        \n+        assertEquals(false, test.isBefore((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));\n         assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));\n         \n-        assertEquals(false, test.isAfter(null));\n+        assertEquals(false, test.isAfter((ReadableInstant) null));\n+    }\n+\n+    public void testIsAfter_RInterval() {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));\n+        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));\n+        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));\n+        \n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));\n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));\n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));\n+        \n+        assertEquals(false, test.isAfter((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testAlways() {\n+        Interval test = Interval.ALWAYS;\n+        assertEquals(Long.MIN_VALUE, test.getStartMillis());\n+        assertEquals(Long.MAX_VALUE, test.getEndMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testWithStartMillis_long1() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         Interval result = test.withStartMillis(TEST_TIME1 - 1);\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n         public boolean overlaps(ReadableInterval interval) {\n             return false;\n         }\n-        public boolean isBefore(long millisInstant) {\n-            return false;\n-        }\n-        public boolean isBeforeNow() {\n-            return false;\n-        }\n         public boolean isBefore(ReadableInstant instant) {\n             return false;\n         }\n-        public boolean isAfter(long millisInstant) {\n-            return false;\n-        }\n-        public boolean isAfterNow() {\n+        public boolean isBefore(ReadableInterval interval) {\n             return false;\n         }\n         public boolean isAfter(ReadableInstant instant) {\n+            return false;\n+        }\n+        public boolean isAfter(ReadableInterval interval) {\n             return false;\n         }\n         public Interval toInterval() {\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n         assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));\n         assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));\n         \n-        try {\n-            test.contains((ReadableInterval) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+        assertEquals(true, test.contains((ReadableInterval) null));\n     }\n \n     public void testOverlaps_RInterval() {\n         assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));\n         assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));\n         \n-        try {\n-            test.overlaps((ReadableInterval) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+        assertEquals(true, test.overlaps((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));\n         assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));\n         \n-        assertEquals(false, test.isBefore(null));\n+        assertEquals(false, test.isBefore((ReadableInstant) null));\n+    }\n+\n+    public void testIsBefore_RInterval() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));\n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));\n+        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));\n+        \n+        assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));\n+        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));\n+        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));\n+        \n+        assertEquals(false, test.isBefore((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));\n         assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));\n         \n-        assertEquals(false, test.isAfter(null));\n+        assertEquals(false, test.isAfter((ReadableInstant) null));\n+    }\n+\n+    public void testIsAfter_RInterval() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));\n+        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));\n+        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));\n+        \n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));\n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));\n+        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));\n+        \n+        assertEquals(false, test.isAfter((ReadableInterval) null));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n         public boolean overlaps(ReadableInterval interval) {\n             return false;\n         }\n-        public boolean isBefore(long millisInstant) {\n-            return false;\n-        }\n-        public boolean isBeforeNow() {\n-            return false;\n-        }\n         public boolean isBefore(ReadableInstant instant) {\n             return false;\n         }\n-        public boolean isAfter(long millisInstant) {\n-            return false;\n-        }\n-        public boolean isAfterNow() {\n+        public boolean isBefore(ReadableInterval interval) {\n             return false;\n         }\n         public boolean isAfter(ReadableInstant instant) {\n+            return false;\n+        }\n+        public boolean isAfter(ReadableInterval interval) {\n             return false;\n         }\n         public Interval toInterval() {", "timestamp": 1094295666, "metainfo": ""}