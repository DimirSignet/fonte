{"sha": "79b24183d3e4517e3bceb2c2754758bb0e204410", "log": "Rollback to 0.99 for 1.0 release   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n         31,29,31,30,31,30,31,31,30,31,30,31\n     };\n \n-    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n-\n     private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n     private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n \n         // Now create fields that have unique behavior for Gregorian and Julian\n         // chronologies.\n \n-        fields.year = new BasicYearDateTimeField(this);\n+        fields.year = new GJYearDateTimeField(this);\n         fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n \n         // Define one-based centuryOfEra and yearOfCentury.\n     }\n \n     /**\n-     * Sets the year.\n-     * \n-     * @param instant  millis from 1970-01-01T00:00:00Z\n-     * @param year  the year to set\n-     */\n-    long setYear(long instant, int year) {\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final long setYear(long instant, int year) {\n         int thisYear = getYear(instant);\n         int dayOfYear = getDayOfYear(instant, thisYear);\n         int millisOfDay = getMillisOfDay(instant);\n         return instant;\n     }\n \n-    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n-        int minuendYear = getYear(minuendInstant);\n-        int subtrahendYear = getYear(subtrahendInstant);\n-\n-        // Inlined remainder method to avoid duplicate calls to get.\n-        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n-        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n-\n-        // Balance leap year differences on remainders.\n-        if (subtrahendRem >= FEB_29) {\n-            if (isLeapYear(subtrahendYear)) {\n-                if (!isLeapYear(minuendYear)) {\n-                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n-                }\n-            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n-                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n-            }\n-        }\n-\n-        int difference = minuendYear - subtrahendYear;\n-        if (minuendRem < subtrahendRem) {\n-            difference--;\n-        }\n-        return difference;\n-    }\n-\n     abstract boolean isLeapYear(int year);\n \n     abstract long calculateFirstDayOfYearMillis(int year);\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n         return getInstance(zone);\n     }\n \n-    //-----------------------------------------------------------------------\n-    long setYear(long instant, int year) {\n-        // optimsed implementation of set, due to 30 day months\n-        int thisYear = getYear(instant);\n-        int dayOfYear = getDayOfYear(instant, thisYear);\n-        int millisOfDay = getMillisOfDay(instant);\n-\n-        if (dayOfYear > 365) {\n-            // Current year is leap, and day is leap.\n-            if (!isLeapYear(year)) {\n-                // Moving to a non-leap year, leap day doesn't exist.\n-                dayOfYear--;\n-            }\n-        }\n-\n-        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n-        instant += millisOfDay;\n-        return instant;\n-    }\n-\n-    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n-        // optimsed implementation of getDifference, due to 30 day months\n-        int minuendYear = getYear(minuendInstant);\n-        int subtrahendYear = getYear(subtrahendInstant);\n-\n-        // Inlined remainder method to avoid duplicate calls to get.\n-        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n-        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n-\n-        int difference = minuendYear - subtrahendYear;\n-        if (minuendRem < subtrahendRem) {\n-            difference--;\n-        }\n-        return difference;\n-    }\n-\n     long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n         throws IllegalArgumentException\n     {\n         if (getBase() == null) {\n             super.assemble(fields);\n \n-            fields.year = new BasicYearDateTimeField(this);\n+            fields.year = new CopticYearDateTimeField(this);\n             fields.years = fields.year.getDurationField();\n \n             // Coptic, like Julian, has no year zero.\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class CopticYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    private static final long serialVersionUID = 8990199361773280783L;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    CopticYearDateTimeField(BaseGJChronology chronology) {\n+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = get(minuendInstant);\n+        int subtrahendYear = get(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+\n+\t\tBaseGJChronology chrono = iChronology;\n+\n+        int thisYear = chrono.getYear(instant);\n+        int dayOfYear = chrono.getDayOfYear(instant, thisYear);\n+        int millisOfDay = chrono.getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+\t\t\t// Current year is leap, and day is leap.\n+\t\t\tif (!chrono.isLeapYear(year)) {\n+\t\t\t\t// Moving to a non-leap year, leap day doesn't exist.\n+\t\t\t\tdayOfYear--;\n+\t\t\t}\n+        }\n+\n+        instant = chrono.getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * Provides time calculations for the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    private static final long serialVersionUID = -679076949530018869L;\n+\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJYearDateTimeField(BaseGJChronology chronology) {\n+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    /**\n+     * Add the specified year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n+        int newYear = thisYear + years;\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    /**\n+     * Add to the Year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = get(minuendInstant);\n+        int subtrahendYear = get(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);\n+\n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (iChronology.isLeapYear(subtrahendYear)) {\n+                if (!iChronology.isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && iChronology.isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (-292269055,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return iChronology.setYear(instant, year);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}", "timestamp": 1108774465, "metainfo": ""}