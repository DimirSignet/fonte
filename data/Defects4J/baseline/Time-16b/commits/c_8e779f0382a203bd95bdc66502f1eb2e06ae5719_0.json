{"sha": "8e779f0382a203bd95bdc66502f1eb2e06ae5719", "log": "Finished parsing support.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java\n import org.joda.time.DurationField;\n import org.joda.time.DurationType;\n import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadWritableDuration;\n \n /**\n- * \n+ * DurationFormatterBuilder is used for constructing {@link DurationFormatter}s.\n+ * DurationFormatters are built by appending specific fields and separators.\n  *\n+ * <p>\n+ * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n+ * can be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * DurationFormatter yearsAndMonths = new DurationFormatterBuilder()\n+ *     .printZeroAlways()\n+ *     .appendYears()\n+ *     .appendSuffix(\" year\", \" years\")\n+ *     .appendSeparator(\" and \")\n+ *     .printZeroNever()\n+ *     .appendMonths()\n+ *     .appendSuffix(\" month\", \" months\")\n+ *     .toFormatter();\n+ * </pre>\n+ * <p>\n+ * DurationFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n+ *\n+ * @see DurationFormat\n  * @author Brian S O'Neill\n  */\n public class DurationFormatterBuilder {\n     private static final int PRINT_ZERO_MAYBE = 1;\n     private static final int PRINT_ZERO_ALWAYS = 2;\n \n+    private String iAlternate;\n+\n     private int iMinPrintedDigits = 1;\n     private int iPrintZeroSetting;\n+    private int iMaxParsedDigits = 10;\n+    private boolean iRejectSignedValues;\n \n     private DurationFieldAffix iPrefix;\n \n      * printer.\n      */\n     public DurationPrinter toPrinter() {\n-        return toPrinter(iFormatters);\n-    }\n-\n-    /**\n-     * Converts to a DurationPrinter that prints using all the appended\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a DurationParser that parses using all the appended\n      * elements. Subsequent changes to this builder do not affect the returned\n-     * printer.\n-     *\n-     * @param alternate alternate text to print when printer emits no fields\n-     */\n-    public DurationPrinter toPrinter(String alternate) {\n-        DurationPrinter printer = toPrinter();\n-        if (alternate != null) {\n-            return new AlternateSelector(printer, new Literal(alternate));\n-        }\n-        return printer;\n-    }\n-\n-    /**\n-     * Converts to a DurationPrinter that prints using all the appended\n+     * parser.\n+     */\n+    public DurationParser toParser() {\n+        return toFormatter();\n+    }\n+\n+    /**\n+     * Converts to a DurationFormatter that formats using all the appended\n      * elements. Subsequent changes to this builder do not affect the returned\n-     * printer.\n-     *\n-     * @param alternate alternate printer to use when printer emits no fields\n-     */\n-    public DurationPrinter toPrinter(DurationPrinter alternate) {\n-        DurationPrinter printer = toPrinter();\n-        if (alternate != null) {\n-            return new AlternateSelector(printer, alternate);\n-        }\n-        return printer;\n-    }\n-\n-    private static DurationPrinter toPrinter(List formatters) {\n+     * formatter.\n+     */\n+    public DurationFormatter toFormatter() {\n+        DurationFormatter formatter = toFormatter(iFormatters);\n+        if (iAlternate != null) {\n+            formatter = new AlternateSelector(formatter, iAlternate);\n+        }\n+        return formatter;\n+    }\n+\n+    private static DurationFormatter toFormatter(List formatters) {\n         int size = formatters.size();\n         if (size >= 2 && formatters.get(1) instanceof Separator) {\n-            DurationPrinter before = (DurationPrinter) formatters.get(0);\n+            DurationFormatter before = (DurationFormatter) formatters.get(0);\n             if (size == 2) {\n-                // Separator at the end would never print anything.\n+                // Separator at the end would never format anything.\n                 return before;\n             }\n             return ((Separator) formatters.get(1)).finish\n-                (before, toPrinter(formatters.subList(2, size)));\n+                (before, toFormatter(formatters.subList(2, size)));\n         }\n         return createComposite(formatters);\n     }\n-\n-    /**\n-     * Depending on what rules are applied, a parser may not be buildable due\n-     * to ambiguities that may arise during parsing.\n-     */\n-    /*\n-    public boolean canBuildParser() {\n-        // TODO\n-        return true;\n-    }\n-    */\n \n     /**\n      * Clears out all the appended elements, allowing this builder to be\n      * reused.\n      */\n     public void clear() {\n+        iAlternate = null;\n         iMinPrintedDigits = 1;\n         iPrintZeroSetting = PRINT_ZERO_NEVER;\n+        iMaxParsedDigits = 10;\n+        iRejectSignedValues = false;\n         iPrefix = null;\n         iFormatters.clear();\n     }\n     /**\n      * Appends just a printer. With no matching parser, a parser cannot be\n      * built from this DurationFormatterBuilder.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder append(DurationPrinter printer)\n         throws IllegalArgumentException\n      * Instructs the printer to emit specific text, and the parser to expect\n      * it. The parser is case-insensitive.\n      *\n+     * @return this DurationFormatterBuilder\n      * @throws IllegalArgumentException if text is null\n      */\n     public DurationFormatterBuilder appendLiteral(String text) {\n      * Set the minimum digits printed for the next and following appended\n      * fields. By default, the minimum digits printed is one. If the field value\n      * is zero, it is not printed unless a printZero rule is applied.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder minimumPrintedDigits(int minDigits) {\n         iMinPrintedDigits = minDigits;\n     /**\n      * Set the maximum digits parsed for the next and following appended\n      * fields. By default, the maximum digits parsed is ten.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder maximumParsedDigits(int maxDigits) {\n-        // TODO\n+        iMaxParsedDigits = maxDigits;\n         return this;\n     }\n \n     /**\n      * Reject signed values when parsing the next and following appended fields.\n-     */\n-    public DurationFormatterBuilder rejectSignedValues() {\n-        // TODO\n+     *\n+     * @return this DurationFormatterBuilder\n+     */\n+    public DurationFormatterBuilder rejectSignedValues(boolean v) {\n+        iRejectSignedValues = v;\n         return this;\n     }\n \n     /**\n      * Never print zero values for the next and following appended fields. This\n      * is the default setting.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder printZeroNever() {\n         iPrintZeroSetting = PRINT_ZERO_NEVER;\n     /**\n      * Print zero values for the next and following appened fields only if the\n      * duration supports it.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder printZeroMaybe() {\n         iPrintZeroSetting = PRINT_ZERO_MAYBE;\n \n     /**\n      * Always print zero values for the next and following appended fields,\n-     * even if the duration doesn't support it.\n+     * even if the duration doesn't support it. The parser requires values for\n+     * fields that always print zero.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder printZeroAlways() {\n         iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n      * the field is not printed, neither is the prefix.\n      *\n      * @param text text to print before field only if field is printed\n+     * @return this DurationFormatterBuilder\n      * @see #appendSuffix\n      */\n     public DurationFormatterBuilder appendPrefix(String text) {\n      *\n      * @param singularText text to print if field value is one\n      * @param pluralText text to print if field value is not one\n+     * @return this DurationFormatterBuilder\n      * @see #appendSuffix\n      */\n     public DurationFormatterBuilder appendPrefix(String singularText,\n      * the field is not printed, neither is the prefix.\n      *\n      * @param prefix custom prefix\n+     * @return this DurationFormatterBuilder\n      * @see #appendSuffix\n      */\n-    public DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n+    private DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n         if (prefix == null) {\n             throw new IllegalArgumentException();\n         }\n \n     /**\n      * Instruct the printer to emit a numeric years field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendYears() {\n         appendField(1);\n \n     /**\n      * Instruct the printer to emit a numeric years field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendMonths() {\n         appendField(2);\n \n     /**\n      * Instruct the printer to emit a numeric weeks field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendWeeks() {\n         appendField(3);\n \n     /**\n      * Instruct the printer to emit a numeric days field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendDays() {\n         appendField(4);\n \n     /**\n      * Instruct the printer to emit a numeric hours field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendHours() {\n         appendField(5);\n \n     /**\n      * Instruct the printer to emit a numeric minutes field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendMinutes() {\n         appendField(6);\n \n     /**\n      * Instruct the printer to emit a numeric seconds field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendSeconds() {\n         appendField(7);\n \n     /**\n      * Instruct the printer to emit a numeric millis field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendMillis() {\n         appendField(8);\n \n     private void appendField(int type) {\n         iFormatters.add(new FieldFormatter(iMinPrintedDigits, iPrintZeroSetting,\n+                                           iMaxParsedDigits, iRejectSignedValues,\n                                            type, iPrefix, null));\n         iPrefix = null;\n     }\n      * the field is not printed, neither is the suffix.\n      *\n      * @param text text to print after field only if field is printed\n+     * @return this DurationFormatterBuilder\n      * @throws IllegalStateException if no field exists to append to\n      * @see #appendPrefix\n      */\n      *\n      * @param singularText text to print if field value is one\n      * @param pluralText text to print if field value is not one\n+     * @return this DurationFormatterBuilder\n      * @throws IllegalStateException if no field exists to append to\n      * @see #appendPrefix\n      */\n      * the field is not printed, neither is the suffix.\n      *\n      * @param suffix custom suffix\n+     * @return this DurationFormatterBuilder\n      * @throws IllegalStateException if no field exists to append to\n      * @see #appendPrefix\n      */\n-    public DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n+    private DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n         Object f = null;\n         if (iFormatters.size() > 0) {\n             f = iFormatters.get(iFormatters.size() - 1);\n      * <p>\n      * Note: appending a separator discontinues any further work on the latest\n      * appended field.\n+     *\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendSeparator(String text) {\n         return appendSeparator(text, text);\n      *\n      * @param finalText alternate used if this is the final separator\n      * printed\n+     * @return this DurationFormatterBuilder\n      */\n     public DurationFormatterBuilder appendSeparator(String text,\n                                                     String finalText) {\n             // Merge two adjacent separators together.\n             iFormatters.set(i, lastSeparator.merge(text, finalText));\n         } else {\n-            DurationPrinter composite = createComposite(formatters);\n+            DurationFormatter composite = createComposite(formatters);\n             formatters.clear();\n             formatters.add(composite);\n             \n         return this;\n     }\n \n+    /**\n+     * Supply alternate text to print, when no fields are emitted. During\n+     * parsing, the alternate text is compared against first. If the alternate\n+     * text matches (ignoring case), the parser finishes without attempting to\n+     * parse any specific fields.\n+     *\n+     * @return this DurationFormatterBuilder\n+     */\n+    // TODO: Drop support for alternate. Instead, show least significant field\n+    // that is supported.\n+    public DurationFormatterBuilder setAlternate(String text) {\n+        iAlternate = text;\n+        return this;\n+    }\n+\n     private void clearPrefix() throws IllegalStateException {\n         if (iPrefix != null) {\n             throw new IllegalStateException(\"Prefix not followed by field\");\n         iPrefix = null;\n     }\n \n-    private static DurationPrinter createComposite(List formatters) {\n+    private static DurationFormatter createComposite(List formatters) {\n         if (formatters.size() == 1) {\n-            return (DurationPrinter)formatters.get(0);\n+            return (DurationFormatter)formatters.get(0);\n         } else {\n             return new Composite(formatters);\n         }\n     }\n \n+    /**\n+     * Defines a formatted field's prefix or suffix text.\n+     */\n+    private static interface DurationFieldAffix {\n+        int calculatePrintedLength(int value);\n+        \n+        void printTo(StringBuffer buf, int value);\n+        \n+        void printTo(Writer out, int value) throws IOException;\n+        \n+        /**\n+         * @return new position after parsing affix, or ~position of failure\n+         */\n+        int parse(String durationStr, int position);\n+\n+        /**\n+         * @return position where affix starts, or original ~position if not found\n+         */\n+        int scan(String durationStr, int position);\n+    }\n+\n     private static final class SingularAffix implements DurationFieldAffix {\n         private final String iText;\n \n \n         public void printTo(Writer out, int value) throws IOException {\n             out.write(iText);\n+        }\n+\n+        public int parse(String durationStr, int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            if (durationStr.regionMatches(true, position, text, 0, textLength)) {\n+                return position + textLength;\n+            }\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text, 0, textLength)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n         }\n     }\n \n         public void printTo(Writer out, int value) throws IOException {\n             out.write(value == 1 ? iSingularText : iPluralText);\n         }\n+\n+        public int parse(String durationStr, int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            if (durationStr.regionMatches\n+                (true, position, text1, 0, text1.length())) {\n+                return position + text1.length();\n+            }\n+            if (durationStr.regionMatches\n+                (true, position, text2, 0, text2.length())) {\n+                return position + text2.length();\n+            }\n+\n+            return ~position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            int textLength1 = text1.length();\n+            int textLength2 = text2.length();\n+\n+            int sourceLength = durationStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (durationStr.regionMatches(true, pos, text1, 0, textLength1)) {\n+                    return pos;\n+                }\n+                if (durationStr.regionMatches(true, pos, text2, 0, textLength2)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n     }\n \n     private static final class CompositeAffix implements DurationFieldAffix {\n             iLeft.printTo(out, value);\n             iRight.printTo(out, value);\n         }\n+\n+        public int parse(String durationStr, int position) {\n+            position = iLeft.parse(durationStr, position);\n+            if (position >= 0) {\n+                position = iRight.parse(durationStr, position);\n+            }\n+            return position;\n+        }\n+\n+        public int scan(String durationStr, final int position) {\n+            int pos = iLeft.scan(durationStr, position);\n+            if (pos >= 0) {\n+                return iRight.scan(durationStr, pos);\n+            }\n+            return ~position;\n+        }\n     }\n \n     private static final class FieldFormatter extends AbstractDurationFormatter\n-        implements DurationPrinter\n+        implements DurationFormatter\n     {\n         private final int iMinPrintedDigits;\n         private final int iPrintZeroSetting;\n+        private final int iMaxParsedDigits;\n+        private final boolean iRejectSignedValues;\n \n         private final int iFieldType;\n \n         private final DurationFieldAffix iSuffix;\n \n         FieldFormatter(int minPrintedDigits, int printZeroSetting,\n+                       int maxParsedDigits, boolean rejectSignedValues,\n                        int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {\n             iMinPrintedDigits = minPrintedDigits;\n             iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iRejectSignedValues = rejectSignedValues;\n             iFieldType = fieldType;\n             iPrefix = prefix;\n             iSuffix = suffix;\n         FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {\n             iMinPrintedDigits = field.iMinPrintedDigits;\n             iPrintZeroSetting = field.iPrintZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n             iFieldType = field.iFieldType;\n             iPrefix = field.iPrefix;\n             if (field.iSuffix != null) {\n             if ((affix = iSuffix) != null) {\n                 affix.printTo(out, value);\n             }\n+        }\n+\n+        public int parseInto(ReadWritableDuration duration,\n+                             String text, int position) {\n+\n+            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n+\n+            // Shortcut test.\n+            if (position >= text.length()) {\n+                return mustParse ? ~position : position;\n+            }\n+\n+            if (iPrefix != null) {\n+                position = iPrefix.parse(text, position);\n+                if (position >= 0) {\n+                    // If prefix is found, then the parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Prefix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~position;\n+                    }\n+                    return position;\n+                }\n+            }\n+\n+            int suffixPos = -1;\n+            if (iSuffix != null && !mustParse) {\n+                // Pre-scan the suffix, to help determine if this field must be\n+                // parsed.\n+                suffixPos = iSuffix.scan(text, position);\n+                if (suffixPos >= 0) {\n+                    // If suffix is found, then parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Suffix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~suffixPos;\n+                    }\n+                    return suffixPos;\n+                }\n+            }\n+\n+            if (!mustParse && !isSupported(duration.getDurationType())) {\n+                // If parsing is not required and the field is not supported,\n+                // exit gracefully so that another parser can continue on.\n+                return position;\n+            }\n+\n+            int limit;\n+            if (suffixPos > 0) {\n+                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n+            } else {\n+                limit = Math.min(iMaxParsedDigits, text.length() - position);\n+            }\n+\n+            boolean negative = false;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n+                    negative = c == '-';\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            int value;\n+            if (length == 3 && negative) {\n+                value = -FormatUtils.parseTwoDigits(text, position + 1);\n+            } else if (length == 2) {\n+                if (negative) {\n+                    value = text.charAt(position + 1) - '0';\n+                    value = -value;\n+                } else {\n+                    value = FormatUtils.parseTwoDigits(text, position);\n+                }\n+            } else if (length == 1 && !negative) {\n+                value = text.charAt(position) - '0';\n+            } else {\n+                String sub = text.substring(position, position + length);\n+                try {\n+                    value = Integer.parseInt(sub);\n+                } catch (NumberFormatException e) {\n+                    return ~position;\n+                }\n+            }\n+\n+            setFieldValue(duration, value);\n+            position += length;\n+\n+            if (position >= 0 && iSuffix != null) {\n+                position = iSuffix.parse(text, position);\n+            }\n+\n+            return position;\n         }\n \n         /**\n \n             return value & 0xffffffffL;\n         }\n+\n+        boolean isSupported(DurationType type) {\n+            switch (iFieldType) {\n+            default:\n+                return false;\n+            case 1:\n+                return type.years().isSupported();\n+            case 2:\n+                return type.months().isSupported();\n+            case 3:\n+                return type.weeks().isSupported();\n+            case 4:\n+                return type.days().isSupported();\n+            case 5:\n+                return type.hours().isSupported();\n+            case 6:\n+                return type.minutes().isSupported();\n+            case 7:\n+                return type.seconds().isSupported();\n+            case 8:\n+                return type.millis().isSupported();\n+            }\n+        }\n+\n+        void setFieldValue(ReadWritableDuration duration, int value) {\n+            switch (iFieldType) {\n+            default:\n+                break;\n+            case 1:\n+                duration.setYears(value);\n+                break;\n+            case 2:\n+                duration.setMonths(value);\n+                break;\n+            case 3:\n+                duration.setWeeks(value);\n+                break;\n+            case 4:\n+                duration.setDays(value);\n+                break;\n+            case 5:\n+                duration.setHours(value);\n+                break;\n+            case 6:\n+                duration.setMinutes(value);\n+                break;\n+            case 7:\n+                duration.setSeconds(value);\n+                break;\n+            case 8:\n+                duration.setMillis(value);\n+                break;\n+            }\n+        }\n     }\n \n     private static final class Literal extends AbstractDurationFormatter\n-        implements DurationPrinter\n+        implements DurationFormatter\n     {\n         private final String iText;\n \n         public void printTo(Writer out, ReadableDuration duration) throws IOException {\n             out.write(iText);\n         }\n+\n+        public int parseInto(ReadWritableDuration duration,\n+                             String durationStr, int position) {\n+            if (durationStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                return position + iText.length();\n+            }\n+            return ~position;\n+        }\n     }\n \n     private static final class Separator extends AbstractDurationFormatter\n-        implements DurationPrinter\n+        implements DurationFormatter\n     {\n         private final String iText;\n         private final String iFinalText;\n \n-        private final DurationPrinter iBefore;\n-        private final DurationPrinter iAfter;\n+        private final DurationFormatter iBefore;\n+        private final DurationFormatter iAfter;\n \n         Separator(String text, String finalText) {\n             this(text, finalText, null, null);\n         }\n \n         Separator(String text, String finalText,\n-                  DurationPrinter before, DurationPrinter after) {\n+                  DurationFormatter before, DurationFormatter after) {\n             iText = text;\n             iFinalText = finalText;\n             iBefore = before;\n             after.printTo(out, duration);\n         }\n \n+        public int parseInto(ReadWritableDuration duration,\n+                             String durationStr, int position) {\n+            final int oldPos = position;\n+\n+            position = iBefore.parseInto(duration, durationStr, position);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            if (position > oldPos) {\n+                // Since position advanced, this separator is\n+                // allowed. Optionally parse it.\n+                if (durationStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                    position += iText.length();\n+                } else if (iText != iFinalText && durationStr.regionMatches\n+                           (true, position, iFinalText, 0, iFinalText.length())) {\n+                    position += iFinalText.length();\n+                }\n+            }\n+\n+            return iAfter.parseInto(duration, durationStr, position);\n+        }\n+\n         Separator merge(String text, String finalText) {\n             return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);\n         }\n \n-        Separator finish(DurationPrinter before, DurationPrinter after) {\n+        Separator finish(DurationFormatter before, DurationFormatter after) {\n             return new Separator(iText, iFinalText, before, after);\n         }\n     }\n \n     private static final class Composite extends AbstractDurationFormatter\n-        implements DurationPrinter\n+        implements DurationFormatter\n     {\n-        private final DurationPrinter[] iFormatters;\n+        private final DurationFormatter[] iFormatters;\n \n         Composite(List formatters) {\n-            iFormatters = (DurationPrinter[])formatters.toArray\n-                (new DurationPrinter[formatters.size()]);\n+            iFormatters = (DurationFormatter[])formatters.toArray\n+                (new DurationFormatter[formatters.size()]);\n         }\n \n         public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n                 printers[i].printTo(out, duration);\n             }\n         }\n+\n+        public int parseInto(ReadWritableDuration duration,\n+                             String durationStr, int position) {\n+            DurationParser[] parsers = iFormatters;\n+\n+            if (parsers == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = parsers.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = parsers[i].parseInto(duration, durationStr, position);\n+            }\n+            return position;\n+        }\n     }\n \n     private static final class AlternateSelector extends AbstractDurationFormatter\n-        implements DurationPrinter\n+        implements DurationFormatter\n     {\n-        private final DurationPrinter iPrimary;\n-        private final DurationPrinter iAlternate;\n-\n-        AlternateSelector(DurationPrinter primary, DurationPrinter alternate) {\n-            iPrimary = primary;\n+        private final DurationFormatter iFormatter;\n+        private final String iAlternate;\n+\n+        AlternateSelector(DurationFormatter formatter, String alternate) {\n+            iFormatter = formatter;\n             iAlternate = alternate;\n         }\n \n         public int countFieldsToPrint(ReadableDuration duration, int stopAt) {\n-            int count = iPrimary.countFieldsToPrint(duration, stopAt);\n-            if (count <= 0) {\n-                count = iAlternate.countFieldsToPrint(duration, stopAt);\n-            }\n-            return count;\n+            return iFormatter.countFieldsToPrint(duration, stopAt);\n         }\n \n         public int calculatePrintedLength(ReadableDuration duration) {\n-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n-                return iPrimary.calculatePrintedLength(duration);\n+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {\n+                return iFormatter.calculatePrintedLength(duration);\n             } else {\n-                return iAlternate.calculatePrintedLength(duration);\n+                return iAlternate.length();\n             }\n         }\n \n         public void printTo(StringBuffer buf, ReadableDuration duration) {\n-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n-                iPrimary.printTo(buf, duration);\n+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {\n+                iFormatter.printTo(buf, duration);\n             } else {\n-                iAlternate.printTo(buf, duration);\n+                buf.append(iAlternate);\n             }\n         }\n \n         public void printTo(Writer out, ReadableDuration duration) throws IOException {\n-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {\n-                iPrimary.printTo(out, duration);\n+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {\n+                iFormatter.printTo(out, duration);\n             } else {\n-                iAlternate.printTo(out, duration);\n-            }\n+                out.write(iAlternate);\n+            }\n+        }\n+\n+        public int parseInto(ReadWritableDuration duration,\n+                             String durationStr, int position) {\n+            String alt = iAlternate;\n+            int altLength = alt.length();\n+            if (durationStr.regionMatches(true, position, alt, 0, altLength)) {\n+                return position + altLength;\n+            }\n+            return iFormatter.parseInto(duration, durationStr, position);\n         }\n     }\n ", "timestamp": 1071802929, "metainfo": ""}