{"sha": "e3bb5c0e0c1d5a3cb12c444e922ddb00d1f5bccd", "log": "Fix Local Object constructors  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n import org.joda.time.base.AbstractPartial;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.InstantConverter;\n+import org.joda.time.convert.PartialConverter;\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormat;\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateElementParser()}.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateElementParser()}.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalDate(Object instant, DateTimeZone zone) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n         Chronology chronology = converter.getChronology(instant, zone);\n-        long millis = converter.getInstantMillis\n-            (instant, chronology, ISODateTimeFormat.dateParser());\n-        \n-        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        chronology = chronology.withUTC();\n-        chronology.dayOfMonth().roundFloor(localMillis);\n-        iLocalMillis = localMillis;\n-        iChronology = chronology;\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.dateElementParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n     }\n \n     /**\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateElementParser()}.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalDate(Object instant, Chronology chronology) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        Chronology chrono = DateTimeUtils.getChronology\n-            (converter.getChronology(instant, chronology));\n-        long millis = converter.getInstantMillis\n-            (instant, chronology, ISODateTimeFormat.dateParser());\n-        \n-        long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        chrono = chrono.withUTC();\n-        chrono.dayOfMonth().roundFloor(localMillis);\n-        iLocalMillis = localMillis;\n-        iChronology = chrono;\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.dateElementParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n import org.joda.time.base.AbstractPartial;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.InstantConverter;\n+import org.joda.time.convert.PartialConverter;\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.ISODateTimeFormat;\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalDateTime(Object instant, DateTimeZone zone) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n         Chronology chronology = converter.getChronology(instant, zone);\n-        long millis = converter.getInstantMillis(instant, chronology);\n         chronology = DateTimeUtils.getChronology(chronology);\n-        \n-        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        iLocalMillis = localMillis;\n         iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.dateOptionalTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n     }\n \n     /**\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalDateTime(Object instant, Chronology chronology) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        Chronology chrono = DateTimeUtils.getChronology(converter.getChronology(instant, chronology));\n-        long millis = converter.getInstantMillis(instant, chrono);\n-        \n-        long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        iLocalMillis = localMillis;\n-        iChronology = chrono.withUTC();\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.dateOptionalTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n import org.joda.time.base.AbstractPartial;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.InstantConverter;\n+import org.joda.time.convert.PartialConverter;\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.ISODateTimeFormat;\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalTime(Object instant, DateTimeZone zone) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n         Chronology chronology = converter.getChronology(instant, zone);\n-        long millis = converter.getInstantMillis\n-            (instant, chronology, ISODateTimeFormat.timeParser());\n         chronology = DateTimeUtils.getChronology(chronology);\n-        \n-        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        chronology = chronology.withUTC();\n-        chronology.millisOfDay().get(localMillis);\n-        iLocalMillis = localMillis;\n-        iChronology = chronology;\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.timeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n     }\n \n     /**\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public LocalTime(Object instant, Chronology chronology) {\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        Chronology chrono = DateTimeUtils.getChronology\n-            (converter.getChronology(instant, chronology));\n-        long millis = converter.getInstantMillis\n-            (instant, chronology, ISODateTimeFormat.timeParser());\n-        \n-        long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);\n-        chrono = chrono.withUTC();\n-        chrono.millisOfDay().get(localMillis);\n-        iLocalMillis = localMillis;\n-        iChronology = chrono;\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.timeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         return DateTimeUtils.currentTimeMillis();\n     }\n \n-    /**\n-     * Extracts the millis from an object of this convertor's type.\n-     * <p>\n-     * This implementation returns the current time.\n-     * \n-     * @param object  the object to convert\n-     * @param chrono  the chronology to use, which is always non-null\n-     * @param parser  if converting from a String, the given parser is preferred\n-     * @return the millisecond value\n-     * @since 1.3\n-     */\n-    public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) {\n-        return getInstantMillis(object, chrono);\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Extracts the chronology from an object of this convertor's type\n      * Extracts the values of the partial from an object of this converter's type.\n      * The chrono parameter is a hint to the converter, should it require a\n      * chronology to aid in conversion.\n+     * <p>\n+     * This implementation calls {@link #getInstantMillis(Object, Chronology)}.\n      * \n      * @param fieldSource  a partial that provides access to the fields.\n      *  This partial may be incomplete and only getFieldType(int) should be used\n      * Extracts the values of the partial from an object of this converter's type.\n      * The chrono parameter is a hint to the converter, should it require a\n      * chronology to aid in conversion.\n+     * <p>\n+     * This implementation calls {@link #getPartialValues(ReadablePartial, Object, Chronology)}.\n      * \n      * @param fieldSource  a partial that provides access to the fields.\n      *  This partial may be incomplete and only getFieldType(int) should be used\n      * @throws ClassCastException if the object is invalid\n      * @since 1.3\n      */\n-    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono,\n-                                  DateTimeFormatter parser)\n-    {\n-        long instant = getInstantMillis(object, chrono, parser);\n-        return chrono.get(fieldSource, instant);\n+    public int[] getPartialValues(ReadablePartial fieldSource,\n+            Object object, Chronology chrono, DateTimeFormatter parser) {\n+        return getPartialValues(fieldSource, object, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.format.DateTimeFormatter;\n \n /**\n  * InstantConverter defines how an object is converted to milliseconds/chronology.\n      */\n     long getInstantMillis(Object object, Chronology chrono);\n \n-    /**\n-     * Extracts the millis from an object of this converter's type.\n-     * <p>\n-     * The chronology passed in is the result of the call to <code>getChronology</code>.\n-     * \n-     * @param object  the object to convert\n-     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n-     * @param parser  if converting from a String, the given parser is preferred\n-     * @return the millisecond instant\n-     * @throws ClassCastException if the object is invalid\n-     * @throws IllegalArgumentException if object conversion fails\n-     * @since 1.3\n-     */\n-    long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser);\n-\n }\n--- a/JodaTime/src/java/org/joda/time/convert/PartialConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/PartialConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.format.DateTimeFormatter;\n \n  * @since 1.0\n  */\n public interface PartialConverter extends Converter {\n+\n+    /**\n+     * Extracts the chronology from an object of this converter's type\n+     * where the time zone is specified.\n+     * \n+     * @param object  the object to convert\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    Chronology getChronology(Object object, DateTimeZone zone);\n \n     /**\n      * Extracts the chronology from an object of this converter's type\n--- a/JodaTime/src/java/org/joda/time/convert/ReadablePartialConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadablePartialConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n         ReadablePartial input = (ReadablePartial) object;\n         int size = fieldSource.size();\n-        if (input.size() != size) {\n-            throw new IllegalArgumentException(\"Partial field type lists are different\");\n-        }\n         int[] values = new int[size];\n         for (int i = 0; i < size; i++) {\n-            if (fieldSource.getFieldType(i) != input.getFieldType(i)) {\n-                throw new IllegalArgumentException(\"Partial field type lists are different\");\n-            }\n-            values[i] = input.getValue(i);\n+            values[i] = input.get(fieldSource.getFieldType(i));\n         }\n         chrono.validate(fieldSource, values);\n         return values;\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.Period;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n     }\n \n     /**\n-     * Gets the millis, which is the ISO parsed string value.\n-     * \n-     * @param object  the String to convert, must not be null\n-     * @param chrono  the chronology to use, non-null result of getChronology\n-     * @param parser  the given parser is preferred\n-     * @return the millisecond value\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n      * @throws IllegalArgumentException if the value if invalid\n      * @since 1.3\n      */\n-    public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) {\n-        return parser.withChronology(chrono).parseMillis((String) object);\n+    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {\n+        long millis = parser.withChronology(chrono).parseMillis((String) object);\n+        int size = fieldSource.size();\n+        int[] values = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            values[i] = fieldSource.getFieldType(i).getField(chrono).get(millis);\n+        }\n+        chrono.validate(fieldSource, values);\n+        return values;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         tpe, // time parser element\n         dp,  // date parser\n         tp,  // time parser\n-        dtp; // date time parser\n+        dtp, // date time parser\n+        dotp; // date optional time parser\n \n     /**\n      * Constructor.\n     }\n \n     /**\n-     * Returns a generic ISO datetime parser. It accepts formats described by\n-     * the following syntax:\n+     * Returns a generic ISO datetime parser which parses either a date or\n+     * a time or both. It accepts formats described by the following syntax:\n      * <pre>\n      * datetime          = time | (date-element [time | ('T' offset)])\n      * time              = 'T' time-element [offset]\n         return dtp;\n     }\n \n+    /**\n+     * Returns a generic ISO datetime parser where the date is mandatory and\n+     * the time is optional. It accepts formats described by the following syntax:\n+     * <pre>\n+     * datetime          = date-element ['T' time-element [offset]])\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * time-element      = HH [minute-element] | [fraction]\n+     * minute-element    = ':' mm [second-element] | [fraction]\n+     * second-element    = ':' ss [fraction]\n+     * fraction          = ('.' | ',') digit+\n+     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n+     * </pre>\n+     */\n+    public static DateTimeFormatter dateOptionalTimeParser() {\n+        if (dotp == null) {\n+            dotp = new DateTimeFormatterBuilder()\n+                .append(dateElementParser())\n+                .appendOptional(\n+                    new DateTimeFormatterBuilder()\n+                        .appendLiteral('T')\n+                        .append(timeElementParser())\n+                        .appendOptional(offsetElement().getParser())\n+                        .toParser())\n+                .toFormatter();\n+        }\n+        return dotp;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a formatter for a full date as four digit year, two digit month\n--- a/JodaTime/src/test/org/joda/time/TestLocalDateTime_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDateTime_Constructors.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n \n     private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n     private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();\n     private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);\n+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n     private static final int OFFSET_PARIS = PARIS.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n     private static final int OFFSET_MOSCOW = MOSCOW.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n     \n         assertEquals(40, test.getMillisOfSecond());\n     }\n \n+    public void testConstructor_ObjectString1() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1972-04-06\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(0, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString2() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1972-037\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(2, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(0, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString3() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1972-04-06T10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString4() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1972-04-06T10:20\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString5() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1972-04-06T10:20:30.040+06:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(10 + OFFSET_MOSCOW - 6, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectStringEx1() throws Throwable {\n+        try {\n+            new LocalDateTime(\"T10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx2() throws Throwable {\n+        try {\n+            new LocalDateTime(\"T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx3() throws Throwable {\n+        try {\n+            new LocalDateTime(\"1970-04-06T+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalDateTime() throws Throwable {\n+        LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC);\n+        LocalDateTime test = new LocalDateTime(dt);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectLocalDate() throws Throwable {\n+        LocalDate date = new LocalDate(1970, 5, 6);\n+        try {\n+            new LocalDateTime(date);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalTime() throws Throwable {\n+        LocalTime time = new LocalTime(10, 20, 30, 40);\n+        try {\n+            new LocalDateTime(time);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_Object_DateTimeZone() throws Throwable {\n         Date date = new Date(TEST_TIME1);\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Constructors.java\n         assertEquals(9, test.getDayOfMonth());\n     }\n \n+    public void testConstructor_ObjectString1() throws Throwable {\n+        LocalDate test = new LocalDate(\"1972-04-06\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString2() throws Throwable {\n+        LocalDate test = new LocalDate(\"1972-037\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1972, test.getYear());\n+        assertEquals(2, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectStringEx1() throws Throwable {\n+        try {\n+            new LocalDate(\"1970-04-06T10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx2() throws Throwable {\n+        try {\n+            new LocalDate(\"1970-04-06T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx3() throws Throwable {\n+        try {\n+            new LocalDate(\"T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx4() throws Throwable {\n+        try {\n+            new LocalDate(\"1970-04-06T+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalDate() throws Throwable {\n+        LocalDate date = new LocalDate(1970, 4, 6, BUDDHIST_UTC);\n+        LocalDate test = new LocalDate(date);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectLocalTime() throws Throwable {\n+        LocalTime time = new LocalTime(10, 20, 30, 40, BUDDHIST_UTC);\n+        try {\n+            new LocalDate(time);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalDateTime() throws Throwable {\n+        LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC);\n+        LocalDate test = new LocalDate(dt);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectYearMonthDay() throws Throwable {\n+        YearMonthDay date = new YearMonthDay(1970, 4, 6, BUDDHIST_UTC);\n+        LocalDate test = new LocalDate(date);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testConstructor_Object_DateTimeZone() throws Throwable {\n         Date date = new Date(TEST_TIME1);\n         LocalDate test = new LocalDate(date, PARIS);\n--- a/JodaTime/src/test/org/joda/time/TestLocalTime_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalTime_Constructors.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n     private static final JulianChronology JULIAN_LONDON = JulianChronology.getInstance(LONDON);\n     private static final JulianChronology JULIAN_PARIS = JulianChronology.getInstance(PARIS);\n     private static final JulianChronology JULIAN_UTC = JulianChronology.getInstanceUTC();\n+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n     private static final int OFFSET_LONDON = LONDON.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n     private static final int OFFSET_PARIS = PARIS.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n \n         assertEquals(40, test.getMillisOfSecond());\n     }\n \n+    public void testConstructor_ObjectString1() throws Throwable {\n+        LocalTime test = new LocalTime(\"10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString2() throws Throwable {\n+        LocalTime test = new LocalTime(\"10:20:30.040+04:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10 + OFFSET_LONDON - 4, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString3() throws Throwable {\n+        LocalTime test = new LocalTime(\"T10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString4() throws Throwable {\n+        LocalTime test = new LocalTime(\"T10:20:30.040+04:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10 + OFFSET_LONDON - 4, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString5() throws Throwable {\n+        LocalTime test = new LocalTime(\"10:20\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectStringEx1() throws Throwable {\n+        try {\n+            new LocalTime(\"1970-04-06\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx2() throws Throwable {\n+        try {\n+            new LocalTime(\"1970-04-06T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectStringEx3() throws Throwable {\n+        try {\n+            new LocalTime(\"1970-04-06T+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalTime() throws Throwable {\n+        LocalTime time = new LocalTime(10, 20, 30, 40, BUDDHIST_UTC);\n+        LocalTime test = new LocalTime(time);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectLocalDate() throws Throwable {\n+        LocalDate date = new LocalDate(1970, 4, 6, BUDDHIST_UTC);\n+        try {\n+            new LocalTime(date);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor_ObjectLocalDateTime() throws Throwable {\n+        LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC);\n+        LocalTime test = new LocalTime(dt);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectTimeOfDay() throws Throwable {\n+        TimeOfDay time = new TimeOfDay(10, 20, 30, 40, BUDDHIST_UTC);\n+        LocalTime test = new LocalTime(time);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_Object1_DateTimeZone() throws Throwable {\n         Date date = new Date(TEST_TIME1);\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n     public void testGetInstantConverterOKMultipleMatches() {\n         InstantConverter c = new InstantConverter() {\n             public long getInstantMillis(Object object, Chronology chrono) {return 0;}\n-            public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }\n             public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return ReadableDateTime.class;}\n     public void testGetInstantConverterBadMultipleMatches() {\n         InstantConverter c = new InstantConverter() {\n             public long getInstantMillis(Object object, Chronology chrono) {return 0;}\n-            public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }\n             public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Serializable.class;}\n     public void testAddInstantConverter1() {\n         InstantConverter c = new InstantConverter() {\n             public long getInstantMillis(Object object, Chronology chrono) {return 0;}\n-            public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }\n             public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n     public void testAddInstantConverter2() {\n         InstantConverter c = new InstantConverter() {\n             public long getInstantMillis(Object object, Chronology chrono) {return 0;}\n-            public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }\n             public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return String.class;}\n     public void testRemoveInstantConverter2() {\n         InstantConverter c = new InstantConverter() {\n             public long getInstantMillis(Object object, Chronology chrono) {return 0;}\n-            public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }\n             public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         PartialConverter c = new PartialConverter() {\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;}\n+            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return ReadableDateTime.class;}\n         };\n         PartialConverter c = new PartialConverter() {\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;}\n+            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Serializable.class;}\n         };\n         PartialConverter c = new PartialConverter() {\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;}\n+            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         PartialConverter c = new PartialConverter() {\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;}\n+            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return String.class;}\n         };\n         PartialConverter c = new PartialConverter() {\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}\n             public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;}\n+            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}\n             public Chronology getChronology(Object object, Chronology chrono) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };", "timestamp": 1148341430, "metainfo": ""}