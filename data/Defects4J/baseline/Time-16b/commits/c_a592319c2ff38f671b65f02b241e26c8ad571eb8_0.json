{"sha": "a592319c2ff38f671b65f02b241e26c8ad571eb8", "log": "Support printing of partials   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Abstract base class for implementing {@link DateTimePrinter}s,\n     }\n \n     public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n-        DateTimePrinter p = (DateTimePrinter)this;\n+        DateTimePrinter p = (DateTimePrinter) this;\n         StringBuffer buf = new StringBuffer(p.estimatePrintedLength());\n         p.printTo(buf, instant, zone, instantLocal);\n         return buf.toString();\n     }\n \n+    public String print(ReadablePartial partial) {\n+        DateTimePrinter p = (DateTimePrinter) this;\n+        StringBuffer buf = new StringBuffer(p.estimatePrintedLength());\n+        p.printTo(buf, partial);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n         DateTimeParser p = (DateTimeParser)this;\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n import org.joda.time.field.RemainderDateTimeField;\n+import org.joda.time.partial.ReadablePartial;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n             mPrinter.printTo(out, instant, zone, instantLocal);\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial instant) {\n+            mPrinter.printTo(buf, instant);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial instant) throws IOException {\n+            mPrinter.printTo(out, instant);\n+        }\n+\n         public String print(final ReadableInstant instant) {\n             return mPrinter.print(instant);\n         }\n \n         public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n             return mPrinter.print(instant, zone, instantLocal);\n+        }\n+\n+        public String print(ReadablePartial partial) {\n+            return mPrinter.print(partial);\n         }\n \n         public int estimateParsedLength() {\n             throw unsupported();\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n         public String print(final ReadableInstant instant) {\n             throw unsupported();\n         }\n         }\n \n         public String print(final long instant, final DateTimeZone zone, final long instantLocal) {\n+            throw unsupported();\n+        }\n+\n+        public String print(ReadablePartial partial) {\n             throw unsupported();\n         }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.field.MillisDurationField;\n import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.partial.ReadablePartial;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n         public Chronology getChronology() {\n             return iChrono;\n         }\n+\n+        protected void appendUnknownString(StringBuffer buf, int len) {\n+            for (int i = len; --i >= 0;) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        protected void printUnknownString(Writer out, int len) throws IOException {\n+            for (int i = len; --i >= 0;) {\n+                out.write('\\ufffd');\n+            }\n+        }\n     }\n \n     private static class CharacterLiteral extends AbstractFormatter\n             out.write(iValue);\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            out.write(iValue);\n+        }\n+\n         public String print(long instant, DateTimeZone zone, long instantLocal) {\n+            return String.valueOf(iValue);\n+        }\n+\n+        public String print(ReadablePartial partial) {\n             return String.valueOf(iValue);\n         }\n \n             out.write(iValue);\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            out.write(iValue);\n+        }\n+\n         public String print(long instant, DateTimeZone zone, long instantLocal) {\n+            return iValue;\n+        }\n+\n+        public String print(ReadablePartial partial) {\n             return iValue;\n         }\n \n                 out.write('\\ufffd');\n             }\n         }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iField)) {\n+                try {\n+                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iField));\n+                } catch (RuntimeException e) {\n+                    buf.append('\\ufffd');\n+                }\n+            } else {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iField)) {\n+                try {\n+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iField));\n+                } catch (RuntimeException e) {\n+                    out.write('\\ufffd');\n+                }\n+            } else {\n+                out.write('\\ufffd');\n+            }\n+        }\n     }\n \n     private static class PaddedNumber extends NumberFormatter {\n         public void printTo(StringBuffer buf, long instant,\n                             DateTimeZone zone, long instantLocal) {\n             try {\n-                FormatUtils.appendPaddedInteger\n-                    (buf, iField.get(instantLocal), iMinPrintedDigits);\n+                FormatUtils.appendPaddedInteger(buf, iField.get(instantLocal), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n-                for (int i=iMinPrintedDigits; --i>=0; ) {\n-                    buf.append('\\ufffd');\n-                }\n+                appendUnknownString(buf, iMinPrintedDigits);\n             }\n         }\n \n         public void printTo(Writer out, long instant,\n                             DateTimeZone zone, long instantLocal) throws IOException {\n             try {\n-                FormatUtils.writePaddedInteger\n-                    (out, iField.get(instantLocal), iMinPrintedDigits);\n+                FormatUtils.writePaddedInteger(out, iField.get(instantLocal), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n-                for (int i=iMinPrintedDigits; --i>=0; ) {\n-                    out.write('\\ufffd');\n-                }\n+                printUnknownString(out, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iField)) {\n+                try {\n+                    FormatUtils.appendPaddedInteger(buf, partial.get(iField), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    appendUnknownString(buf, iMinPrintedDigits);\n+                }\n+            } else {\n+                appendUnknownString(buf, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iField)) {\n+                try {\n+                    FormatUtils.writePaddedInteger(out, partial.get(iField), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    printUnknownString(out, iMinPrintedDigits);\n+                }\n+            } else {\n+                printUnknownString(out, iMinPrintedDigits);\n             }\n         }\n     }\n                 return -1;\n             }\n         }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            int year = getTwoDigitYear(partial);\n+            if (year < 0) {\n+                buf.append('\\ufffd');\n+                buf.append('\\ufffd');\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, year, 2);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            int year = getTwoDigitYear(partial);\n+            if (year < 0) {\n+                out.write('\\ufffd');\n+                out.write('\\ufffd');\n+            } else {\n+                FormatUtils.writePaddedInteger(out, year, 2);\n+            }\n+        }\n+\n+        private int getTwoDigitYear(ReadablePartial partial) {\n+            if (partial.isSupported(iField)) {\n+                try {\n+                    int year = partial.get(iField);\n+                    if (year < 0) {\n+                        year = -year;\n+                    }\n+                    return year % 100;\n+                } catch (RuntimeException e) {}\n+            } \n+            return -1;\n+        }\n     }\n \n     private static class TextField extends AbstractFormatter\n             }\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            try {\n+                buf.append(print(partial));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            try {\n+                out.write(print(partial));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n         public final String print(long instant, DateTimeZone zone, long instantLocal) {\n             if (iShort) {\n                 return iField.getAsShortText(instantLocal, iLocale);\n             } else {\n                 return iField.getAsText(instantLocal, iLocale);\n+            }\n+        }\n+\n+        public final String print(ReadablePartial partial) {\n+            if (partial.isSupported(iField)) {\n+                if (iShort) {\n+                    return iField.getAsShortText(partial, iLocale);\n+                } else {\n+                    return iField.getAsText(partial, iLocale);\n+                }\n+            } else {\n+                return \"\\ufffd\";\n             }\n         }\n \n             printTo(null, out, instantLocal);\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iField)) {\n+                long millis = partial.resolve(0L, DateTimeZone.UTC);\n+                try {\n+                    printTo(buf, null, millis);\n+                } catch (IOException e) {\n+                    // Not gonna happen.\n+                }\n+            } else {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iField)) {\n+                long millis = partial.resolve(0L, DateTimeZone.UTC);\n+                printTo(null, out, millis);\n+            } else {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n         private void printTo(StringBuffer buf, Writer out, long instantLocal)\n             throws IOException\n         {\n             FormatUtils.writePaddedInteger(out, offset, 3);\n         }\n \n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            // no zone info\n+        }\n+\n         public int estimateParsedLength() {\n             return estimatePrintedLength();\n         }\n                 return zone.getName(instant, this.iLocale);\n             }\n         }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            // no zone info\n+        }\n     }\n \n     private static final class Composite extends AbstractFormatter\n         public void printTo(StringBuffer buf, long instant,\n                             DateTimeZone zone, long instantLocal) {\n             DateTimePrinter[] elements = iPrinters;\n-\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n         public void printTo(Writer out, long instant,\n                             DateTimeZone zone, long instantLocal) throws IOException {\n             DateTimePrinter[] elements = iPrinters;\n-\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n             int len = elements.length;\n             for (int i=0; i<len; i++) {\n                 elements[i].printTo(out, instant, zone, instantLocal);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(buf, partial);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(out, partial);\n             }\n         }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Defines an interface for creating textual representations of datetimes.\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Prints a ReadablePartial.\n+     *\n+     * @param buf  formatted partial is appended to this buffer\n+     * @param partial  partial to format\n+     */\n+    void printTo(StringBuffer buf, ReadablePartial partial);\n+\n+    /**\n+     * Prints a ReadablePartial.\n+     *\n+     * @param out  formatted partial is written out\n+     * @param partial  partial to format\n+     */\n+    void printTo(Writer out, ReadablePartial partial) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Prints a ReadableInstant to a new String, attempting to use the\n      * DateTimeZone supplied by the instant.\n      *\n      */\n     String print(long instant, DateTimeZone zone, long instantLocal);\n     \n+    /**\n+     * Prints a ReadablePartial to a new String.\n+     *\n+     * @param partial  partial to format\n+     * @return the printed result\n+     */\n+    String print(ReadablePartial partial);\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n         hde, // hourOfDay element (HH)\n         mhe, // minuteOfHour element (:mm)\n         sme, // secondOfMinute element (:ss)\n-        fse, // fractionOfSecond element (.SSS)\n+        lse, // millisOfSecond element (.SSS)\n+        fse, // fractionOfSecond element (.SSSSSSSSS)\n         ze,  // zone offset element\n         \n         //y,   // year (same as year element)\n         //h,    // hour (same as hour element)\n         hm,   // hour minute\n         hms,  // hour minute second\n+        hmsl, // hour minute second millis\n         hmsf, // hour minute second fraction\n \n         dh,    // date hour\n         dhm,   // date hour minute\n         dhms,  // date hour minute second\n+        dhmsl, // date hour minute second millis\n         dhmsf, // date hour minute second fraction\n \n         //d,  // date (same as ymd)\n         t,  // time\n+        tt,  // Ttime\n         dt, // date time\n \n         //wd,  // week date (same as wwd)\n \n         bd,  // basic date\n         bt,  // basic time\n+        btt, // basic Ttime\n         bdt, // basic date time\n \n         bwd,  // basic week date\n     public DateTimeFormatter time() {\n         if (t == null) {\n             t = new DateTimeFormatterBuilder(iChrono)\n-                .append(hourMinuteSecondFraction())\n+                .append(hourMinuteSecondMillis())\n                 .append(offsetElement())\n                 .toFormatter();\n         }\n     }\n \n     /**\n-     * Returns a formatter that combines a full date and time, separated by a\n-     * 'T'. (yyyy-MM-dd'T'HH:mm:ss.SSSZ)\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, three digit fraction of second, and\n+     * time zone offset prefixed by 'T'. ('T'HH:mm:ss.SSSZ)\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     */\n+    public DateTimeFormatter tTime() {\n+        if (t == null) {\n+            t = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('T')\n+                .append(time())\n+                .toFormatter();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and time, separated by a 'T'.\n+     * (yyyy-MM-dd'T'HH:mm:ss.SSSZ)\n      */\n     public DateTimeFormatter dateTime() {\n         if (dt == null) {\n             dt = new DateTimeFormatterBuilder(iChrono)\n                 .append(date())\n-                .appendLiteral('T')\n-                .append(time())\n+                .append(tTime())\n                 .toFormatter();\n         }\n         return dt;\n     }\n \n     /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, and time zone offset prefixed by 'T'.\n+     * ('T'HHmmssZ)\n+     * The time zone offset is blank for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     */\n+    public DateTimeFormatter basicTTime() {\n+        if (bt == null) {\n+            bt = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('T')\n+                .append(basicTime())\n+                .toFormatter();\n+        }\n+        return bt;\n+    }\n+\n+    /**\n      * Returns a basic formatter that combines a basic date and time, separated\n      * by a 'T'. (yyyyMMdd'T'HHmmssZ)\n      */\n         if (bdt == null) {\n             bdt = new DateTimeFormatterBuilder(iChrono)\n                 .append(basicDate())\n-                .appendLiteral('T')\n-                .append(basicTime())\n+                .append(basicTTime())\n                 .toFormatter();\n         }\n         return bdt;\n      * hour, two digit second of minute, and three digit fraction of\n      * second. (HH:mm:ss.SSS)\n      */\n+    public DateTimeFormatter hourMinuteSecondMillis() {\n+        if (hmsl == null) {\n+            hmsl = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .append(millisElement())\n+                .toFormatter();\n+        }\n+        return hmsl;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and three digit fraction of\n+     * second. (HH:mm:ss.SSS)\n+     */\n     public DateTimeFormatter hourMinuteSecondFraction() {\n         if (hmsf == null) {\n             hmsf = new DateTimeFormatterBuilder(iChrono)\n      * two digit minute of hour, two digit second of minute, and three digit\n      * fraction of second. (yyyy-MM-dd'T'HH:mm:ss.SSS)\n      */\n+    public DateTimeFormatter dateHourMinuteSecondMillis() {\n+        if (dhmsl == null) {\n+            dhmsl = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(hourMinuteSecondMillis())\n+                .toFormatter();\n+        }\n+        return dhmsl;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, two digit second of minute, and three digit\n+     * fraction of second. (yyyy-MM-dd'T'HH:mm:ss.SSS)\n+     */\n     public DateTimeFormatter dateHourMinuteSecondFraction() {\n         if (dhmsf == null) {\n             dhmsf = new DateTimeFormatterBuilder(iChrono)\n                 .toFormatter();\n         }\n         return sme;\n+    }\n+\n+    private DateTimeFormatter millisElement() {\n+        if (lse == null) {\n+            lse = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('.')\n+                .appendMillisOfSecond(3)\n+                .toFormatter();\n+        }\n+        return lse;\n     }\n \n     private DateTimeFormatter fractionElement() {\n--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java\n         return total;\n     }\n \n-    /**\n-     * Output the time in an ISO8601 format.\n-     * \n-     * @return ISO8601 formatted string\n-     */\n-    public String toString() {\n-        // TODO\n-        return \"\";\n-    }\n-\n }\n--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.format.ISODateTimeFormat;\n \n /**\n  * TimeOfDay is an immutable partial supporting the hour, minute, second\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Output the time in the ISO8601 format THH:mm:ss.SSS.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstanceUTC().tTime().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * The property class for TimeOfDay.\n      */\n     public static class Property extends AbstractPartialFieldProperty {\n--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.format.ISODateTimeFormat;\n \n /**\n  * YearMonthDay is an immutable partial supporting the year, monthOfYear\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Output the time in the ISO8601 format YYYY-MM-DD.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstanceUTC().yearMonthDay().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * The property class for YearMonthDay.\n      */\n     public static class Property extends AbstractPartialFieldProperty {\n--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        // TODO\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(\"T10:20:30.040\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java\n+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        // TODO\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(\"1972-06-09\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1088374894, "metainfo": ""}