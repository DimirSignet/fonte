{"sha": "3920f45c67ee3863820257c4c9550bf3b538e66a", "log": "Proposal for core Holiday representation classes   ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/holiday/src/java/org/joda/time/contrib/holiday/Holiday.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.holiday;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.YearMonthDay;\n+\n+/**\n+ * Holiday defines a specially named day and the rules for creating it.\n+ * The named day may be a holiday, anniversary or other day with\n+ * particular meaning.\n+ *\n+ * @author Al Major\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Holiday {\n+\n+    /** The id of the holiday. */\n+    private String iId;\n+    /** The name of the holiday. */\n+    private Map iNames;\n+    /** The list of HolidayRule objects. */\n+    private List iHolidayRules = new ArrayList();\n+\n+    /**\n+     * Constructor.\n+     */\n+    Holiday() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ID of the holiday.\n+     *\n+     * @return the id of the holiday\n+     */\n+    public String getID() {\n+        return iId;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the name of the holiday.\n+     * This method supports intelligent name lookup by locale.\n+     *\n+     * @param locale  the locale to get the name in\n+     * @return the name of the holiday\n+     */\n+    public String getName(Locale locale) {\n+        String localeStr = locale.toString();\n+        String name = (String) iNames.get(localeStr);\n+        if (name == null && locale.getVariant().length() > 0) {\n+            name = (String) iNames.get(localeStr.substring(0, 5));\n+        }\n+        if (name == null && locale.getCountry().length() > 0) {\n+            name = (String) iNames.get(localeStr.substring(0, 2));\n+        }\n+        if (name == null) {\n+            name = (String) iNames.get(\"en\");\n+        }\n+        if (name == null && iNames.size() > 0) {\n+            name = (String) iNames.values().iterator().next();\n+        }\n+        return name;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the YearMonthDay object for the specified year.\n+     *\n+     * @param year  the year\n+     * @return the YearMonthDay, null if day does not exist for this year\n+     */\n+    public YearMonthDay yearMonthDayForYear(int year) {\n+        MutableDateTime mdt = new MutableDateTime(0L, DateTimeZone.UTC);\n+        for (int i = 0; i < iHolidayRules.size(); i++) {\n+            HolidayRule rule = (HolidayRule) iHolidayRules.get(i);\n+            if (rule.appliesForYear(mdt, year)) {\n+                return new YearMonthDay(rule.applyForYear(mdt, year));\n+            }\n+        }\n+        return null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/holiday/src/java/org/joda/time/contrib/holiday/HolidayRule.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.holiday;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.MutableDateTime;\n+\n+/**\n+ * HolidayRule defines the rules to create a specially named day.\n+ * The named day may be a holiday, anniversary or other day with\n+ * particular meaning.\n+ *\n+ * @author Al Major\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class HolidayRule {\n+\n+    /** The from year, when the rule begins, inclusive. */\n+    private int iFromYear;\n+    /** The to year, when the rule ends, inclusive. */\n+    private int iToYear;\n+    /** The month. */\n+    private int iMonthOfYear;\n+    /** The day of month. */\n+    private int iDayOfMonth;\n+    /** The day of week. */\n+    private int iDayOfWeek;\n+    /** The field week of month. */\n+    private int iWeekOfMonth;\n+    /** The relative days. */\n+    private int iRelativeDays;\n+    /** The weekend adjust. */\n+    private int iWeekendAdjust;\n+\n+    /** The weekend adjust value, to move to the next weekday. */\n+    private static final int WEEKEND_ADJUST_NEXT_WEEKDAY = 0;\n+    /** The weekend adjust value, to move to the next weekday. */\n+    private static final int WEEKEND_ADJUST_PREVIOUS_WEEKDAY = 1;\n+    /** The weekend adjust value, to move to the next weekday. */\n+    private static final int WEEKEND_ADJUST_NEAREST_WEEKDAY = 2;\n+\n+    /**\n+     * Constructor.\n+     */\n+    HolidayRule() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the year that the rule commences (inclusive).\n+     *\n+     * @return the from year, Integer.MIN_VALUE if not used\n+     */\n+    public int getFromYear() {\n+        return iFromYear;\n+    }\n+\n+    /**\n+     * Sets the year that the rule commences (inclusive).\n+     *\n+     * @param year  the from year, Integer.MIN_VALUE if not used\n+     */\n+    void setFromYear(int year) {\n+        iFromYear = year;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the year that the rule ends (inclusive).\n+     *\n+     * @return the to year, Integer.MAX_VALUE if not used\n+     */\n+    public int getToYear() {\n+        return iToYear;\n+    }\n+\n+    /**\n+     * Sets the year that the rule ends (inclusive).\n+     *\n+     * @param year  the to year, Integer.MIN_VALUE if not used\n+     */\n+    void setToYear(int year) {\n+        iToYear = year;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the month of the year of the rule.\n+     *\n+     * @return the month of year, Integer.MIN_VALUE if not used\n+     */\n+    public int getMonthOfYear() {\n+        return iMonthOfYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the day of the month of the rule.\n+     *\n+     * @return the day of month, Integer.MIN_VALUE if not used\n+     */\n+    public int getDayOfMonth() {\n+        return iDayOfMonth;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the day of the week of the rule.\n+     *\n+     * @return the day of week, Integer.MIN_VALUE if not used\n+     */\n+    public int getDayOfWeek() {\n+        return iDayOfWeek;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the week of the month of the rule.\n+     * -1 indicates the last.\n+     *\n+     * @return the week of month, Integer.MIN_VALUE if not used\n+     */\n+    public int getWeekOfMonth() {\n+        return iWeekOfMonth;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the relative days of the rule.\n+     *\n+     * @return the relative days, Integer.MIN_VALUE if not used\n+     */\n+    public int getRelativeDays() {\n+        return iRelativeDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the day of the month of the rule.\n+     *\n+     * @return the weekend adjustment rule, Integer.MIN_VALUE if not used\n+     */\n+    public int getWeekendAdjust() {\n+        return iWeekendAdjust;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this rule apply for the specified year.\n+     *\n+     * @param mdt  working copy MutableDateTime, may be altered, not null\n+     * @param year  the year\n+     * @return true if this rule applies for the specified year\n+     */\n+    boolean appliesForYear(MutableDateTime mdt, int year) {\n+        return (iFromYear <= year && iToYear >= year);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Applies the rules for the specified year.\n+     *\n+     * @param mdt  working copy MutableDateTime, may be altered, not null\n+     * @param year  the year\n+     * @return the MutableDateTime\n+     */\n+    MutableDateTime applyForYear(MutableDateTime mdt, int year) {\n+        mdt.setDate(year, 1, 1);\n+        if (iMonthOfYear != Integer.MIN_VALUE) {\n+            mdt.setMonthOfYear(iMonthOfYear);\n+        }\n+        if (iDayOfMonth != Integer.MIN_VALUE) {\n+            mdt.setDayOfMonth(iDayOfMonth);\n+        }\n+        if (iDayOfWeek != Integer.MIN_VALUE) {\n+            mdt.setDayOfWeek(iDayOfWeek);\n+        }\n+        if (iWeekOfMonth != Integer.MIN_VALUE) {\n+            calculateWeekOfMonth(mdt, iMonthOfYear, iWeekOfMonth);\n+        }\n+        if (iRelativeDays != Integer.MIN_VALUE) {\n+            mdt.addDays(iRelativeDays);\n+        }\n+        if (iWeekendAdjust != Integer.MIN_VALUE) {\n+            calculateWeekendAdjust(mdt, iWeekendAdjust);\n+        }\n+        return mdt;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Perform the weekk of month calculation.\n+     * TODO, move this to a DateTimeField.\n+     *\n+     * @param mdt  the datetime to update\n+     * @param month  the month it should be\n+     * @param week  the week of month\n+     */\n+    private void calculateWeekOfMonth(MutableDateTime mdt, int month, int week) {\n+        if (week > 0) {\n+            while (mdt.getMonthOfYear() >= month) {\n+                mdt.addWeeks(-1);\n+            }\n+            mdt.addWeeks(week);\n+        } else {\n+            while (mdt.getMonthOfYear() <= month) {\n+                mdt.addWeeks(1);\n+            }\n+            mdt.addWeeks(-week);\n+        }\n+    }\n+\n+    /**\n+     * Calculates the weekend adjust field.\n+     *\n+     * @param mdt  the datetime to update\n+     * @param adjust  the adjust value\n+     */\n+    private void calculateWeekendAdjust(MutableDateTime mdt, int adjust) {\n+        // TODO, use proper weekend calculation, not hard coded SatSun\n+        if (mdt.getDayOfWeek() == DateTimeConstants.SATURDAY) {\n+            switch (adjust) {\n+                case WEEKEND_ADJUST_NEXT_WEEKDAY:\n+                    mdt.addDays(2);\n+                    break;\n+                case WEEKEND_ADJUST_PREVIOUS_WEEKDAY:\n+                case WEEKEND_ADJUST_NEAREST_WEEKDAY:\n+                    mdt.addDays(-1);\n+                    break;\n+            }\n+        } else if (mdt.getDayOfWeek() == DateTimeConstants.SUNDAY) {\n+            switch (adjust) {\n+                case WEEKEND_ADJUST_NEXT_WEEKDAY:\n+                case WEEKEND_ADJUST_NEAREST_WEEKDAY:\n+                    mdt.addDays(1);\n+                    break;\n+                case WEEKEND_ADJUST_PREVIOUS_WEEKDAY:\n+                    mdt.addDays(-2);\n+                    break;\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1128870366, "metainfo": ""}