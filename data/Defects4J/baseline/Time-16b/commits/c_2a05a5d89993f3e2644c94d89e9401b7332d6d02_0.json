{"sha": "2a05a5d89993f3e2644c94d89e9401b7332d6d02", "log": "Created MutableDateTime.Property; removed property package.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n import java.util.Locale;\n \n import org.joda.time.base.BaseDateTime;\n-import org.joda.time.property.AbstractReadableInstantFieldProperty;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n \n /**\n  * DateMidnight defines a date where the time component is fixed at midnight.\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n \n import org.joda.time.base.BaseDateTime;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.property.AbstractReadableInstantFieldProperty;\n \n /**\n  * DateTime is the standard implementation of an unmodifiable datetime class.\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import java.util.Locale;\n \n import org.joda.time.base.BaseDateTime;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.property.ReadWritableInstantFieldProperty;\n \n /**\n  * MutableDateTime is the standard implementation of a modifiable datetime class.\n      * \n      * @return the era property\n      */\n-    public ReadWritableInstantFieldProperty era() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().era());\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public ReadWritableInstantFieldProperty centuryOfEra() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public ReadWritableInstantFieldProperty yearOfCentury() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfCentury());\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public ReadWritableInstantFieldProperty yearOfEra() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfEra());\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n     }\n \n     /**\n      * \n      * @return the year property\n      */\n-    public ReadWritableInstantFieldProperty year() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().year());\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n     }\n \n     /**\n      * \n      * @return the year of a week based year property\n      */\n-    public ReadWritableInstantFieldProperty weekyear() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().weekyear());\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n     }\n \n     /**\n      * \n      * @return the month of year property\n      */\n-    public ReadWritableInstantFieldProperty monthOfYear() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().monthOfYear());\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n     }\n \n     /**\n      * \n      * @return the week of a week based year property\n      */\n-    public ReadWritableInstantFieldProperty weekOfWeekyear() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n     }\n \n     /**\n      * \n      * @return the day of year property\n      */\n-    public ReadWritableInstantFieldProperty dayOfYear() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfYear());\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n     }\n \n     /**\n      * \n      * @return the day of month property\n      */\n-    public ReadWritableInstantFieldProperty dayOfMonth() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth());\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n     }\n \n     /**\n      * \n      * @return the day of week property\n      */\n-    public ReadWritableInstantFieldProperty dayOfWeek() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfWeek());\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n     }\n \n     //-----------------------------------------------------------------------\n      * \n      * @return the hour of day property\n      */\n-    public ReadWritableInstantFieldProperty hourOfDay() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfDay());\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n     }\n \n     /**\n      * \n      * @return the minute of day property\n      */\n-    public ReadWritableInstantFieldProperty minuteOfDay() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfDay());\n+    public Property minuteOfDay() {\n+        return new Property(this, getChronology().minuteOfDay());\n     }\n \n     /**\n      * \n      * @return the minute of hour property\n      */\n-    public ReadWritableInstantFieldProperty minuteOfHour() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfHour());\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n     }\n \n     /**\n      * \n      * @return the second of day property\n      */\n-    public ReadWritableInstantFieldProperty secondOfDay() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfDay());\n+    public Property secondOfDay() {\n+        return new Property(this, getChronology().secondOfDay());\n     }\n \n     /**\n      * \n      * @return the second of minute property\n      */\n-    public ReadWritableInstantFieldProperty secondOfMinute() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfMinute());\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n     }\n \n     /**\n      * \n      * @return the millis of day property\n      */\n-    public ReadWritableInstantFieldProperty millisOfDay() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay());\n+    public Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n     }\n \n     /**\n      * \n      * @return the millis of second property\n      */\n-    public ReadWritableInstantFieldProperty millisOfSecond() {\n-        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfSecond());\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n     }\n \n     //-----------------------------------------------------------------------\n         return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n     }\n \n+    /**\n+     * MutableDateTime.Property binds a MutableDateTime to a\n+     * DateTimeField allowing powerful datetime functionality to be easily\n+     * accessed.\n+     * <p>\n+     * The example below shows how to use the property to change the value of a\n+     * MutableDateTime object.\n+     * <pre>\n+     * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123);\n+     * dt.year().add(20);\n+     * dt.second().roundFloor().minute().set(10);\n+     * </pre>\n+     * <p>\n+     * MutableDateTime.Propery itself is thread-safe and immutable, but the\n+     * MutableDateTime being operated on is not.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -4481126543819298617L;\n+        \n+        /** The instant this property is working against */\n+        private final MutableDateTime iInstant;\n+        /** The field this property is working against */\n+        private final DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(MutableDateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the instant being used.\n+         * \n+         * @return the instant\n+         */\n+        public ReadableInstant getReadableInstant() {\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Gets the mutable datetime being used.\n+         * \n+         * @return the mutable datetime\n+         */\n+        public MutableDateTime getMutableDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds a value to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return mutable datetime being used\n+         * @see DateTimeField#add(long,int)\n+         */\n+        public MutableDateTime add(int value) {\n+            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Adds a value to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return mutable datetime being used\n+         * @see DateTimeField#add(long,long)\n+         */\n+        public MutableDateTime add(long value) {\n+            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Adds a value, possibly wrapped, to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return mutable datetime being used\n+         * @see DateTimeField#addWrapField\n+         */\n+        public MutableDateTime addWrapField(int value) {\n+            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets a value.\n+         * \n+         * @param value  the value to set.\n+         * @return mutable datetime being used\n+         * @see DateTimeField#set(long,int)\n+         */\n+        public MutableDateTime set(int value) {\n+            iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Sets a text value.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return mutable datetime being used\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n+         */\n+        public MutableDateTime set(String text, Locale locale) {\n+            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Sets a text value.\n+         * \n+         * @param text  the text value to set\n+         * @return mutable datetime being used\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         * @see DateTimeField#set(long,java.lang.String)\n+         */\n+        public MutableDateTime set(String text) {\n+            set(text, null);\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Round to the lowest whole unit of this field.\n+         *\n+         * @return mutable datetime being used\n+         * @see DateTimeField#roundFloor\n+         */\n+        public MutableDateTime roundFloor() {\n+            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Round to the highest whole unit of this field.\n+         *\n+         * @return mutable datetime being used\n+         * @see DateTimeField#roundCeiling\n+         */\n+        public MutableDateTime roundCeiling() {\n+            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Round to the nearest whole unit of this field, favoring the floor if\n+         * halfway.\n+         *\n+         * @return mutable datetime being used\n+         * @see DateTimeField#roundHalfFloor\n+         */\n+        public MutableDateTime roundHalfFloor() {\n+            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Round to the nearest whole unit of this field, favoring the ceiling if\n+         * halfway.\n+         *\n+         * @return mutable datetime being used\n+         * @see DateTimeField#roundHalfCeiling\n+         */\n+        public MutableDateTime roundHalfCeiling() {\n+            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Round to the nearest whole unit of this field. If halfway, the ceiling\n+         * is favored over the floor only if it makes this field's value even.\n+         *\n+         * @return mutable datetime being used\n+         * @see DateTimeField#roundHalfEven\n+         */\n+        public MutableDateTime roundHalfEven() {\n+            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n import java.util.Locale;\n \n import org.joda.time.base.*;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.property.AbstractPartialFieldProperty;\n \n /**\n  * TimeOfDay is an immutable partial supporting the hour, minute, second\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n import java.util.Locale;\n \n import org.joda.time.base.BasePartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.property.AbstractPartialFieldProperty;\n \n /**\n  * YearMonthDay is an immutable partial supporting the year, monthOfYear\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * AbstractPartialFieldProperty is a base class for binding a\n+ * ReadablePartial to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartialFieldProperty {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPartialFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the partial instant being used.\n+     * \n+     * @return the partial instant\n+     */\n+    public abstract ReadablePartial getReadablePartial();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the partial instant.\n+     * \n+     * @return the current value\n+     */\n+    public abstract int get();\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getReadablePartial(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getReadablePartial(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for this field given the current field values.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getReadablePartial());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for this field given the current field values.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getReadablePartial());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadablePartial#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the field of this property cannot be queried\n+     *  on the specified instant\n+     */\n+    public int compareTo(ReadablePartial instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.util.Locale;\n+import java.io.Serializable;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * AbstractReadableInstantFieldProperty is a base class for binding a\n+ * ReadableInstant to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ * <p>\n+ * AbstractReadableInstantFieldProperty itself is thread-safe and immutable,\n+ * but the ReadableInstant being operated on may be mutable and not\n+ * thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractReadableInstantFieldProperty implements Serializable {\n+    \n+    /** Serialization version. */\n+    private static final long serialVersionUID = 1971226328211649661L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public AbstractReadableInstantFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public abstract ReadableInstant getReadableInstant();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the instant.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     */\n+    public int get() {\n+        return getField().get(getReadableInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getReadableInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public final String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getReadableInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public final String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant  the subtrahend, null means now\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public int getDifference(ReadableInstant instant) {\n+        if (instant == null) {\n+            return getField().getDifference(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis());\n+        }\n+        return getField().getDifference(getReadableInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant  the subtrahend, null means now\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public long getDifferenceAsLong(ReadableInstant instant) {\n+        if (instant == null) {\n+            return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis());\n+        }\n+        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    /**\n+     * Gets whether this field is leap.\n+     * \n+     * @return true if a leap field\n+     * @see DateTimeField#isLeap\n+     */\n+    public boolean isLeap() {\n+        return getField().isLeap(getReadableInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is leap.\n+     * \n+     * @return the amount by which the field is leap\n+     * @see DateTimeField#getLeapAmount\n+     */\n+    public int getLeapAmount() {\n+        return getField().getLeapAmount(getReadableInstant().getMillis());\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return getField().getLeapDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getReadableInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getReadableInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field.\n+     *\n+     * @see DateTimeField#remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder() {\n+        return getField().remainder(getReadableInstant().getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}", "timestamp": 1093237546, "metainfo": ""}