{"sha": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3", "log": "Refactor format package to use late binding of chronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.DateTimeFormatterBuilder;\n+import org.joda.time.format.FormatUtils;\n import org.joda.time.tz.DefaultNameProvider;\n import org.joda.time.tz.FixedDateTimeZone;\n import org.joda.time.tz.NameProvider;\n             if (offset == 0L) {\n                 return DateTimeZone.UTC;\n             } else {\n-                id = offsetFormatter().print(0, UTC, offset);\n+                StringBuffer buf = new StringBuffer();\n+                id = printTimeZone(offset);\n                 return fixedOffsetZone(id, offset);\n             }\n         }\n \n     /**\n      * Get the time zone by the number of hours difference from UTC.\n+     * This method assumes standard length hours.\n      * <p>\n      * This factory is a convenient way of constructing zones with a fixed offset.\n      * \n \n     /**\n      * Get the time zone by the number of hours and minutes difference from UTC.\n+     * This method assumes 60 minutes in an hour, and standard length minutes.\n      * <p>\n      * This factory is a convenient way of constructing zones with a fixed offset.\n      * The minutes value is always positive and in the range 0 to 59.\n         } catch (ArithmeticException ex) {\n             throw new IllegalArgumentException(\"Offset is too large\");\n         }\n-        String id = offsetFormatter().print(0, UTC, offset);\n+        String id = printTimeZone(offset);\n         return fixedOffsetZone(id, offset);\n     }\n \n                 if (offset == 0L) {\n                     return DateTimeZone.UTC;\n                 } else {\n-                    convId = offsetFormatter().print(0, UTC, offset);\n+                    convId = printTimeZone(offset);\n                     return fixedOffsetZone(convId, offset);\n                 }\n             }\n      */\n     private static synchronized DateTimeFormatter offsetFormatter() {\n         if (cOffsetFormatter == null) {\n-            cOffsetFormatter = new DateTimeFormatterBuilder((Chronology)null, null)\n+            cOffsetFormatter = new DateTimeFormatterBuilder()\n                 .appendTimeZoneOffset(null, true, 2, 4)\n                 .toFormatter();\n         }\n         return cOffsetFormatter;\n+    }\n+\n+    /**\n+     * Formats a timezone offset string.\n+     * <p>\n+     * This method is kept separate from the formatting classe to speed and\n+     * simplify startup and classloading.\n+     * \n+     * @param offset  the offset in milliseconds\n+     * @return the time zone string\n+     */\n+    private static String printTimeZone(int offset) {\n+        StringBuffer buf = new StringBuffer();\n+        if (offset >= 0) {\n+            buf.append('+');\n+        } else {\n+            buf.append('-');\n+            offset = -offset;\n+        }\n+\n+        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+        FormatUtils.appendPaddedInteger(buf, hours, 2);\n+        offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+\n+        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+        buf.append(':');\n+        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n+        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+        if (offset == 0) {\n+            return buf.toString();\n+        }\n+\n+        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+        buf.append(':');\n+        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n+        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+        if (offset == 0) {\n+            return buf.toString();\n+        }\n+\n+        buf.append('.');\n+        FormatUtils.appendPaddedInteger(buf, offset, 3);\n+        return buf.toString();\n     }\n \n     // Instance fields and methods\n         if (name != null) {\n             return name;\n         }\n-        return offsetFormatter().print(instant, this);\n+        return printTimeZone(getOffset(instant));\n     }\n \n     /**\n         if (name != null) {\n             return name;\n         }\n-        return offsetFormatter().print(instant, this);\n+        return printTimeZone(getOffset(instant));\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      * @return ISO8601 time formatted string.\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+        return ISODateTimeFormat.getInstance().dateTime().print(this);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n      * @return ISO8601 formatted string\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstanceUTC().tTime().print(this);\n+        return ISODateTimeFormat.getInstance().tTime().print(this);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n      * @return ISO8601 formatted string\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstanceUTC().yearMonthDay().print(this);\n+        return ISODateTimeFormat.getInstance().yearMonthDay().print(this);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance(getChronology()).forPattern(pattern).print(this);\n+        return DateTimeFormat.getInstance().forPattern(pattern).print(this);\n     }\n \n     /**\n         if (pattern == null) {\n             return toString();\n         }\n-        return DateTimeFormat.getInstance(getChronology(), locale).forPattern(pattern).print(this);\n+        return DateTimeFormat.getInstance(locale).forPattern(pattern).print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n      * @return ISO8601 time formatted string.\n      */\n     public String toString() {\n-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+        return ISODateTimeFormat.getInstance().dateTime().print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n import org.joda.time.PeriodType;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadableInterval;\n-import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n      * @return re-parsable string\n      */\n     public String toString() {\n-        DateTimePrinter printer =\n-            ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())\n-            .dateHourMinuteSecondFraction();\n+        DateTimePrinter printer = ISODateTimeFormat.getInstance().dateHourMinuteSecondFraction();\n         StringBuffer buf = new StringBuffer(48);\n-        printer.printTo(buf, getStartMillis());\n+        printer.printTo(buf, getStartMillis(), getChronology());\n         buf.append('/');\n-        printer.printTo(buf, getEndMillis());\n+        printer.printTo(buf, getEndMillis(), getChronology());\n         return buf.toString();\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n         \n         if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n             sb.append(\",cutover=\");\n-            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n             DateTimePrinter printer;\n             if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n-                printer = format.date();\n-            } else {\n-                printer = format.dateTime();\n-            }\n-            printer.printTo(sb, iCutoverMillis);\n+                printer = ISODateTimeFormat.getInstance().date();\n+            } else {\n+                printer = ISODateTimeFormat.getInstance().dateTime();\n+            }\n+            printer.printTo(sb, iCutoverMillis, withUTC());\n         }\n         \n         if (getMinimumDaysInFirstWeek() != 4) {\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n             }\n             buf.append(\" instant is \");\n \n-            DateTimePrinter p = ISODateTimeFormat.getInstance(getBase()).dateTime();\n+            DateTimePrinter p = ISODateTimeFormat.getInstance().dateTime();\n \n             if (iIsLow) {\n                 buf.append(\"below the supported minimum of \");\n-                p.printTo(buf, getLowerLimit());\n+                p.printTo(buf, getLowerLimit().getMillis(), getBase());\n             } else {\n                 buf.append(\"above the supported maximum of \");\n-                p.printTo(buf, getUpperLimit());\n+                p.printTo(buf, getUpperLimit().getMillis(), getBase());\n             }\n             \n             buf.append(\" (\");\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n      */\n     public long getInstantMillis(Object object, Chronology chrono) {\n         String str = (String) object;\n-        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n-        return p.parseMillis(str);\n+        DateTimeParser p = ISODateTimeFormat.getInstance().dateTimeParser();\n+        return p.parseMillis(str, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n             throw new IllegalArgumentException(\"Format invalid: \" + str);\n         }\n \n-        DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n+        DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n         PeriodFormatter periodParser = ISOPeriodFormat.getInstance().standard();\n         long startInstant = 0, endInstant = 0;\n         Period period = null;\n         if (c == 'P' || c == 'p') {\n             period = periodParser.parsePeriod(getPeriodType(leftStr), leftStr);\n         } else {\n-            DateTime start = dateTimeParser.parseDateTime(leftStr);\n+            DateTime start = dateTimeParser.parseDateTime(leftStr, chrono);\n             startInstant = start.getMillis();\n             parsedChrono = start.getChronology();\n         }\n             chrono = (chrono != null ? chrono : parsedChrono);\n             endInstant = chrono.add(period, startInstant, 1);\n         } else {\n-            DateTime end = dateTimeParser.parseDateTime(rightStr);\n+            DateTime end = dateTimeParser.parseDateTime(rightStr, chrono);\n             endInstant = end.getMillis();\n             parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n             chrono = (chrono != null ? chrono : parsedChrono);\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * Abstract base class for implementing {@link DateTimePrinter}s,\n+ * {@link DateTimeParser}s, and {@link DateTimeFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented DateTimePrinter or\n+ * DateTimeFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * DateTimeParser or DateTimeFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ * <p>\n+ * BaseDateTimeFormatter is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BaseDateTimeFormatter {\n+\n+    public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+        return (BoundDateTimePrinter) this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void printTo(StringBuffer buf, ReadableInstant instant) {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(buf, millis, chrono);\n+    }\n+\n+    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(out, millis, chrono);\n+    }\n+\n+    public void printTo(StringBuffer buf, long instant) {\n+        printTo(buf, instant, ISOChronology.getInstance());\n+    }\n+\n+    public void printTo(Writer out, long instant) throws IOException {\n+        printTo(out, instant, ISOChronology.getInstance());\n+    }\n+\n+    public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        printTo(buf, instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    public void printTo(Writer out, long instant, DateTimeZone zone) throws IOException {\n+        zone = DateTimeUtils.getZone(zone);\n+        printTo(out, instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        printTo(buf,\n+                instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n+                instant, chrono);\n+    }\n+\n+    public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        printTo(out,\n+                instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n+                instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public String print(ReadableInstant instant) {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        return print(millis, chrono);\n+    }\n+\n+    public String print(long instant) {\n+        return print(instant, ISOChronology.getInstance());\n+    }\n+\n+    public String print(long instant, DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        return print(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    public String print(long instant, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        return print(instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n+                     instant, chrono);\n+    }\n+\n+    public String print(ReadablePartial partial) {\n+        StringBuffer buf = new StringBuffer(estimatePrintedLength());\n+        printTo(buf, partial);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected int estimatePrintedLength() {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    protected void printTo(StringBuffer buf,\n+                           long instantLocal, Chronology chronoLocal,\n+                           long instant, Chronology chrono) {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    protected void printTo(Writer out,\n+                           long instantLocal, Chronology chronoLocal,\n+                           long instant, Chronology chrono) throws IOException {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    protected String print(long instantLocal, Chronology chronoLocal,\n+                           long instant, Chronology chrono) {\n+        StringBuffer buf = new StringBuffer(estimatePrintedLength());\n+        printTo(buf, instantLocal, chronoLocal, instant, chrono);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"Instant must not be null\");\n+        }\n+\n+        long millis = instant.getMillis();\n+        Chronology chrono = instant.getChronology();\n+        long instantLocal = millis + chrono.getZone().getOffset(millis);\n+\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+        int resultPos = parseInto(bucket, text, position);\n+        instant.setMillis(bucket.computeMillis());\n+        return resultPos;\n+    }\n+\n+    public long parseMillis(String text) {\n+        return parseMillis(text, ISOChronology.getInstance());\n+    }\n+\n+    public long parseMillis(String text, Chronology chrono) {\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono);\n+\n+        int newPos = parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return bucket.computeMillis(true);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    public long parseMillis(String text, long instant) {\n+        return parseMillis(text, instant, ISOChronology.getInstance());\n+    }\n+\n+    public long parseMillis(String text, long instant, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        long instantLocal = instant + chrono.getZone().getOffset(instant);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+\n+        int newPos = parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return bucket.computeMillis();\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    public DateTime parseDateTime(String text) {\n+        return parseDateTime(text, ISOChronology.getInstance());\n+    }\n+\n+    public DateTime parseDateTime(String text, Chronology chrono) {\n+        return new DateTime(parseMillis(text, chrono), chrono);\n+    }\n+\n+    public DateTime parseDateTime(String text, ReadableInstant instant) {\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        return new DateTime(parseMillis(text, millis, chrono), chrono);\n+    }\n+\n+    public MutableDateTime parseMutableDateTime(String text) {\n+        return parseMutableDateTime(text, ISOChronology.getInstance());\n+    }\n+\n+    public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n+        return new MutableDateTime(parseMillis(text, chrono), chrono);\n+    }\n+\n+    public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        return new MutableDateTime(parseMillis(text, millis, chrono), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected int estimateParsedLength() {\n+        throw new UnsupportedOperationException(\"Parsing not supported\");\n+    }\n+\n+    protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        throw new UnsupportedOperationException(\"Parsing not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/BasePeriodFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * Abstract base class for implementing {@link PeriodPrinter}s,\n+ * {@link PeriodParser}s, and {@link PeriodFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented PeriodPrinter or\n+ * PeriodFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * PeriodParser or PeriodFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class BasePeriodFormatter {\n+    \n+    /**\n+     * Returns the exact number of characters produced for the given period.\n+     * \n+     * @param period  the period to use\n+     * @return the estimated length\n+     */\n+    protected int calculatePrintedLength(ReadablePeriod period) {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    /**\n+     * Returns the amount of fields from the given period that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @return amount of fields printed\n+     */\n+    protected int countFieldsToPrint(ReadablePeriod period) {\n+        return countFieldsToPrint(period, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the amount of fields from the given period that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @param stopAt stop counting at this value\n+     * @return amount of fields printed\n+     */\n+    protected int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void printTo(StringBuffer buf, ReadablePeriod period) {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    public String print(ReadablePeriod period) {\n+        StringBuffer buf = new StringBuffer(calculatePrintedLength(period));\n+        printTo(buf, period);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int parseInto(ReadWritablePeriod period, String periodStr, int position) {\n+        throw new UnsupportedOperationException(\"Parsing not supported\");\n+    }\n+\n+    public Period parsePeriod(PeriodType type, String text) {\n+        return parseMutablePeriod(type, text).toPeriod();\n+    }\n+\n+    public MutablePeriod parseMutablePeriod(PeriodType type, String text) {\n+        PeriodParser p = (PeriodParser) this;\n+        MutablePeriod period = new MutablePeriod(0, type);\n+\n+        int newPos = p.parseInto(period, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return period;\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/BoundDateTimePrinter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * Defines an interface, bound to a single chronology, for creating textual\n+ * representations of datetimes.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface BoundDateTimePrinter {\n+    \n+    /**\n+     * Returns another bound printer that uses the specified chronology.\n+     * <p>\n+     * It is the callers resposibility to ensure that the printer is then only\n+     * used with instances of the correct chronology.\n+     * \n+     * @param chrono  the chronology to use, null means ISO\n+     * @return the chronology specific printer\n+     */\n+    BoundDateTimePrinter bindPrinter(Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant, using the chronology of this printer.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  instant to format, null means now\n+     */\n+    void printTo(StringBuffer buf, ReadableInstant instant);\n+\n+    /**\n+     * Prints a ReadableInstant, using the chronology of this printer.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  instant to format, null means now\n+     */\n+    void printTo(Writer out, ReadableInstant instant) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the chronology of this printer.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(StringBuffer buf, long instant);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the chronology of this printer.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(Writer out, long instant) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePartial using the chronology of this printer.\n+     *\n+     * @param buf  formatted partial is appended to this buffer\n+     * @param partial  partial to format\n+     */\n+    void printTo(StringBuffer buf, ReadablePartial partial);\n+\n+    /**\n+     * Prints a ReadablePartial using the chronology of this printer.\n+     *\n+     * @param out  formatted partial is written out\n+     * @param partial  partial to format\n+     */\n+    void printTo(Writer out, ReadablePartial partial) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant to a new String, using the chronology of this printer.\n+     *\n+     * @param instant  instant to format, null means now\n+     * @return the printed result\n+     */\n+    String print(ReadableInstant instant);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the chronology of this printer.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    String print(long instant);\n+\n+    /**\n+     * Prints a ReadablePartial to a new String using the chronology of this printer.\n+     *\n+     * @param partial  partial to format\n+     * @return the printed result\n+     */\n+    String print(ReadablePartial partial);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.RemainderDateTimeField;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * DateTimeFormat provides localized printing and parsing capabilities for all\n      */\n     private static Map cInstanceCache = new HashMap(7);\n \n-    /**\n-     * Gets a formatter provider that works using ISOChronology with UTC in the\n-     * default locale.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the formatter provider that works with the default locale.\n      * \n      * @return a format provider\n      */\n-    public static DateTimeFormat getInstanceUTC() {\n-        return getInstance(ISOChronology.getInstanceUTC(), Locale.getDefault());\n-    }\n-\n-    /**\n-     * Gets a formatter provider that works using ISOChronology with the default\n-     * time zone and the default locale.\n+    public static DateTimeFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Gets an instance of the formatter provider that works with the given locale.\n      * \n-     * @return a format provider\n-     */\n-    public static DateTimeFormat getInstance() {\n-        return getInstance(ISOChronology.getInstance(), Locale.getDefault());\n-    }\n-\n-    /**\n-     * Gets a formatter provider that works using ISOChronology with the\n-     * specified time zone and the default locale.\n-     * \n-     * @param zone  the time zone to use, null for default zone\n-     * @return a format provider\n-     */\n-    public static DateTimeFormat getInstance(final DateTimeZone zone) {\n-        return getInstance(ISOChronology.getInstance(zone), Locale.getDefault());\n-    }\n-\n-    /**\n-     * Gets a formatter provider that works using ISOChronology with the\n-     * specified time zone and locale.\n-     * \n-     * @param zone  the time zone to use, null for default zone\n      * @param locale  the Locale to use, null for default locale\n      * @return a format provider\n      */\n-    public static DateTimeFormat getInstance(final DateTimeZone zone, final Locale locale) {\n-        return getInstance(ISOChronology.getInstance(zone), locale);\n-    }\n-\n-    /**\n-     * Gets a formatter provider that works using the specified chronology and\n-     * the default locale.\n-     * \n-     * @param chrono  the chronology to use, null means ISOChronology in the default time zone\n-     * @return a format provider\n-     */\n-    public static DateTimeFormat getInstance(final Chronology chrono) {\n-        return getInstance(chrono, Locale.getDefault());\n-    }\n-\n-    /**\n-     * Gets a formatter provider that works using the specified chronology and\n-     * locale.\n-     * \n-     * @param chrono  the chronology to use, null means ISOChronology in the default time zone\n-     * @param locale  the Locale to use, null for default locale\n-     * @return a format provider\n-     */\n-    public static synchronized DateTimeFormat getInstance(Chronology chrono, Locale locale) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstance();\n-        }\n+    public synchronized static DateTimeFormat getInstance(Locale locale) {\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        Map map = (Map)cInstanceCache.get(chrono);\n-        if (map == null) {\n-            map = new HashMap(7);\n-            cInstanceCache.put(chrono, map);\n-        }\n-        DateTimeFormat dtf = (DateTimeFormat)map.get(locale);\n+        DateTimeFormat dtf = (DateTimeFormat) cInstanceCache.get(locale);\n         if (dtf == null) {\n-            dtf = new DateTimeFormat(chrono, locale);\n-            map.put(locale, dtf);\n+            dtf = new DateTimeFormat(locale);\n+            cInstanceCache.put(locale, dtf);\n         }\n         return dtf;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Parses the given pattern and appends the rules to the given\n      * DateTimeFormatterBuilder.\n     }\n \n     //-----------------------------------------------------------------------\n-    /** The chronology to use */\n-    private final Chronology iChrono;\n     /** The locale to use */\n     private final Locale iLocale;\n \n     /**\n      * Constructor.\n      * \n-     * @param chrono  the chronology to use, must not be null\n      * @param locale  the locale to use, must not be null\n      */\n-    private DateTimeFormat(final Chronology chrono, final Locale locale) {\n+    private DateTimeFormat(final Locale locale) {\n         super();\n-        iChrono = chrono;\n         iLocale = locale;\n     }\n \n             throw new IllegalArgumentException(\"Invalid pattern specification\");\n         }\n \n-        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iChrono, iLocale);\n+        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iLocale);\n         appendPatternTo(builder, pattern);\n \n         if (builder.canBuildFormatter()) {\n             mPrinter = printer;\n         }\n \n-        public Chronology getChronology() {\n-            return mPrinter.getChronology();\n-        }\n-\n-        public int estimatePrintedLength() {\n-            return mPrinter.estimatePrintedLength();\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            return mPrinter.bindPrinter(chrono);\n         }\n \n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n             mPrinter.printTo(out, instant, zone);\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            mPrinter.printTo(buf, instant, zone, instantLocal);\n-        }\n-\n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal)\n-            throws IOException {\n-            mPrinter.printTo(out, instant, zone, instantLocal);\n+        public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+            mPrinter.printTo(buf, instant, chrono);\n+        }\n+\n+        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n+            mPrinter.printTo(out, instant, chrono);\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial instant) {\n             return mPrinter.print(instant, zone);\n         }\n \n-        public String print(long instant, DateTimeZone zone, long instantLocal) {\n-            return mPrinter.print(instant, zone, instantLocal);\n+        public String print(long instant, Chronology chrono) {\n+            return mPrinter.print(instant, chrono);\n         }\n \n         public String print(ReadablePartial partial) {\n             return 0;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            throw unsupported();\n-        }\n-\n         public int parseInto(ReadWritableInstant instant, String text, int position) {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        public long parseMillis(String text, Chronology chrono) {\n+            throw unsupported();\n+        }\n+\n         public long parseMillis(String text, long instantLocal) {\n             throw unsupported();\n         }\n \n+        public long parseMillis(String text, long instant, Chronology chrono) {\n+            throw unsupported();\n+        }\n+\n         public DateTime parseDateTime(String text) {\n             throw unsupported();\n         }\n \n+        public DateTime parseDateTime(String text, Chronology chrono) {\n+            throw unsupported();\n+        }\n+\n         public DateTime parseDateTime(String text, ReadableInstant instant) {\n             throw unsupported();\n         }\n \n         public MutableDateTime parseMutableDateTime(String text) {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n             throw unsupported();\n         }\n \n             mParser = parser;\n         }\n \n-        public Chronology getChronology() {\n-            return mParser.getChronology();\n-        }\n-\n-        public int estimatePrintedLength() {\n-            return 0;\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            throw unsupported();\n         }\n \n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n             throw unsupported();\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            throw unsupported();\n-        }\n-\n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n             throw unsupported();\n         }\n \n             throw unsupported();\n         }\n \n-        public String print(long instant, DateTimeZone zone, long instantLocal) {\n+        public String print(long instant, Chronology chrono) {\n             throw unsupported();\n         }\n \n         public String print(ReadablePartial partial) {\n             throw unsupported();\n-        }\n-\n-        public int estimateParsedLength() {\n-            return mParser.estimateParsedLength();\n-        }\n-\n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            return mParser.parseInto(bucket, text, position);\n         }\n \n         public int parseInto(ReadWritableInstant instant, String text, int position) {\n             return mParser.parseMillis(text);\n         }\n \n-        public long parseMillis(String text, long instantLocal) {\n-            return mParser.parseMillis(text, instantLocal);\n+        public long parseMillis(String text, Chronology chrono) {\n+            return mParser.parseMillis(text, chrono);\n+        }\n+\n+        public long parseMillis(String text, long instant) {\n+            return mParser.parseMillis(text, instant);\n+        }\n+\n+        public long parseMillis(String text, long instant, Chronology chrono) {\n+            return mParser.parseMillis(text, instant, chrono);\n         }\n \n         public DateTime parseDateTime(String text) {\n             return mParser.parseDateTime(text);\n         }\n \n+        public DateTime parseDateTime(String text, Chronology chrono) {\n+            return mParser.parseDateTime(text, chrono);\n+        }\n+\n         public DateTime parseDateTime(String text, ReadableInstant instant) {\n             return mParser.parseDateTime(text, instant);\n         }\n             return mParser.parseMutableDateTime(text);\n         }\n \n-        public MutableDateTime parseMutableDateTime(String text,\n-                                                    ReadableInstant instant) {\n+        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n+            return mParser.parseMutableDateTime(text, chrono);\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {\n             return mParser.parseMutableDateTime(text, instant);\n         }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n  * Combined interface for printing and parsing.\n  * <p>\n  * See each extended interface for details of the methods.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n+ * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @since 1.0\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.MillisDurationField;\n import org.joda.time.field.PreciseDateTimeField;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.\n  * DateTimeFormatters can be built by appending specific fields or other\n- * formatters.\n+ * formatters. All formatters must extend {@link BaseDateTimeFormatter}.\n  *\n  * <p>\n  * For example, a formatter that prints month and year, like \"January 1970\",\n  * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n  * formatters that it builds are thread-safe and immutable.\n  *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n  * @see DateTimeFormat\n- * @author Brian S O'Neill\n+ * @see ISODateTimeFormat\n  */\n public class DateTimeFormatterBuilder {\n \n-    private final Chronology iChrono;\n-    private final Chronology iChronoUTC;\n+    /** The locale the builder uses. */\n     private final Locale iLocale;\n \n     // Array contents alternate between printers and parsers.\n     private ArrayList iElementPairs;\n     private Object iFormatter;\n \n-    /**\n-     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n-     * default time zone and locale.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a DateTimeFormatterBuilder for the default locale.\n      */\n     public DateTimeFormatterBuilder() {\n-        this(ISOChronology.getInstance());\n-    }\n-\n-    /**\n-     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n-     * given time zone, with the default locale.\n-     */\n-    public DateTimeFormatterBuilder(DateTimeZone zone) {\n-        this(ISOChronology.getInstance(zone));\n-    }\n-\n-    /**\n-     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n-     * given time zone, with any locale.\n-     */\n-    public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {\n-        this(ISOChronology.getInstance(zone), locale);\n-    }\n-\n-    /**\n-     * Creates a DateTimeFormatterBuilder with any chronology and the default\n-     * locale.\n-     *\n-     * @param chrono Chronology to use\n-     */\n-    public DateTimeFormatterBuilder(Chronology chrono) {\n-        this(chrono, Locale.getDefault());\n-    }\n-\n-    /**\n-     * Creates a DateTimeFormatterBuilder with any chronology and locale.\n-     *\n-     * @param chrono Chronology to use, or null for default of ISO\n+        this(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder for the specified locale.\n+     * \n      * @param locale Locale to use, or null for default\n      */\n-    public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {\n-        if (chrono == null) {\n-            if (DateTimeZone.getDefault() == null) {\n-                // See DateTimeZone's static initializer for details on this\n-                // special case.\n-                iChrono = iChronoUTC = null;\n-            } else {\n-                iChrono = iChronoUTC = ISOChronology.getInstance();\n-            }\n-        } else {\n-            iChrono = chrono;\n-            iChronoUTC = chrono.withUTC();\n-        }\n+    public DateTimeFormatterBuilder(Locale locale) {\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n         iElementPairs = new ArrayList();\n     }\n \n-    /**\n-     * Returns the chronology being used by the formatter builder.\n-     */\n-    public Chronology getChronology() {\n-        return iChrono;\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the locale being used by the formatter builder, never null.\n      */\n         return iLocale;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Converts to a DateTimePrinter that prints using all the appended\n      * elements. Subsequent changes to this builder do not affect the returned\n         throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns true if toPrinter can be called without throwing an\n      * UnsupportedOperationException.\n         return isFormatter(getFormatter());\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Clears out all the appended elements, allowing this builder to be\n      * reused.\n         iElementPairs.clear();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Appends another formatter.\n-     *\n-     * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if formatter is null\n-     */\n-    public DateTimeFormatterBuilder append(DateTimeFormatter formatter)\n-        throws IllegalArgumentException\n-    {\n+     * <p>\n+     * The formatter must extend <code>DateTimeFormatterProvider</code>.\n+     * This is an internal class, which all supplied format classes extend.\n+     *\n+     * @param formatter  the formatter to add\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if formatter is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n         if (formatter == null) {\n             throw new IllegalArgumentException(\"No formatter supplied\");\n         }\n+        if (formatter instanceof BaseDateTimeFormatter == false) {\n+            throw new IllegalArgumentException(\"Formatter must extend BaseDateTimeFormatter\");\n+        }\n         return append0(formatter);\n     }\n \n     /**\n      * Appends just a printer. With no matching parser, a parser cannot be\n      * built from this DateTimeFormatterBuilder.\n-     *\n-     * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if printer is null\n-     */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer)\n-        throws IllegalArgumentException\n-    {\n-        if (printer == null) {\n-            throw new IllegalArgumentException(\"No printer supplied\");\n-        }\n+     * <p>\n+     * The printer added must extend <code>BaseDateTimeFormatter</code>.\n+     * This is an internal class, which all supplied format classes extend.\n+     *\n+     * @param printer  the printer to add\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if printer is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n+        checkPrinter(printer);\n         return append0(printer, null);\n     }\n \n     /**\n      * Appends just a parser. With no matching printer, a printer cannot be\n      * built from this builder.\n-     *\n-     * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if parser is null\n+     * <p>\n+     * The parser added must extend <code>BaseDateTimeFormatter</code>.\n+     * This is an internal class, which all supplied format classes extend.\n+     *\n+     * @param parser  the parser to add\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder append(DateTimeParser parser) {\n-        if (parser == null) {\n-            throw new IllegalArgumentException(\"No parser supplied\");\n-        }\n+        checkParser(parser);\n         return append0(null, parser);\n     }\n \n     /**\n      * Appends a printer/parser pair.\n-     *\n-     * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if printer or parser is null\n-     */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n-                                           DateTimeParser parser)\n-        throws IllegalArgumentException\n-    {\n-        if (printer == null) {\n-            throw new IllegalArgumentException(\"No printer supplied\");\n-        }\n-        if (parser == null) {\n-            throw new IllegalArgumentException(\"No parser supplied\");\n-        }\n+     * <p>\n+     * The printer and parser must extend <code>BaseDateTimeFormatter</code>.\n+     * This is an internal class, which all supplied format classes extend.\n+     *\n+     * @param printer  the printer to add\n+     * @param parser  the parser to add\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n+        checkPrinter(printer);\n+        checkParser(parser);\n         return append0(printer, parser);\n     }\n \n      * last of the parser array elements to be null. If the last element is\n      * null, this represents the empty parser. The presence of an empty parser\n      * indicates that the entire array of parse formats is optional.\n-     *\n-     * @return this DateTimeFormatterBuilder\n+     * <p>\n+     * The printer and parsers must extend <code>BaseDateTimeFormatter</code>.\n+     * This is an internal class, which all supplied format classes extend.\n+     *\n+     * @param printer  the printer to add\n+     * @param parsers  the parsers to add\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n      * @throws IllegalArgumentException if any parser element but the last is null\n      */\n-    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n-                                           DateTimeParser[] parsers)\n-        throws IllegalArgumentException\n-    {\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n+        if (printer != null) {\n+            checkPrinter(printer);\n+        }\n         if (parsers == null) {\n             throw new IllegalArgumentException(\"No parsers supplied\");\n         }\n         int length = parsers.length;\n-        if (length == 1) {\n-            if (parsers[0] == null) {\n-                throw new IllegalArgumentException(\"No parser supplied\");\n-            }\n-            return append0(printer, parsers[0]);\n-        }\n-\n-        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n-        int i;\n-        for (i = 0; i < length - 1; i++) {\n-            if ((copyOfParsers[i] = parsers[i]) == null) {\n-                throw new IllegalArgumentException(\"Incomplete parser array\");\n-            }\n-        }\n-        copyOfParsers[i] = parsers[i];\n-\n-        return append0(printer, new MatchingParser(iChrono, copyOfParsers));\n+        BaseDateTimeFormatter[] copyOfParsers = new BaseDateTimeFormatter[length];\n+        for (int i = 0; i < length; i++) {\n+            DateTimeParser parser = parsers[i];\n+            if (i == length - 1 && parser == null) {\n+                // ok\n+            } else {\n+                if (parser == null) {\n+                    throw new IllegalArgumentException(\"Incomplete parser array\");\n+                } else if (parser instanceof BaseDateTimeFormatter == false) {\n+                    throw new IllegalArgumentException(\"Parser must extend BaseDateTimeFormatter\");\n+                }\n+                copyOfParsers[i] = (BaseDateTimeFormatter) parser;\n+            }\n+        }\n+        \n+        return append0(printer, new MatchingParser(copyOfParsers));\n     }\n \n     /**\n      * Appends just a parser element which is optional. With no matching\n      * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n-     *\n-     * @return this DateTimeFormatterBuilder\n-     * @throws IllegalArgumentException if parser is null\n+     * <p>\n+     * The parser must implement <code>BaseDateTimeFormatter</code>.\n+     * This is an internal interface, which all supplied format classes implement.\n+     *\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n+        checkParser(parser);\n+        BaseDateTimeFormatter[] parsers = new BaseDateTimeFormatter[] {\n+            (BaseDateTimeFormatter) parser, null};\n+        return append0(null, new MatchingParser(parsers));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the parser is non null and a provider.\n+     * \n+     * @param parser  the parser to check\n+     */\n+    private void checkParser(DateTimeParser parser) {\n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n-        return append0(null, new MatchingParser(iChrono, new DateTimeParser[] {parser, null}));\n+        if (parser instanceof BaseDateTimeFormatter == false) {\n+            throw new IllegalArgumentException(\"Parser must extend BaseDateTimeFormatter\");\n+        }\n+    }\n+\n+    /**\n+     * Checks if the printer is non null and a provider.\n+     * \n+     * @param printer  the printer to check\n+     */\n+    private void checkPrinter(DateTimePrinter printer) {\n+        if (printer == null) {\n+            throw new IllegalArgumentException(\"No printer supplied\");\n+        }\n+        if (printer instanceof BaseDateTimeFormatter == false) {\n+            throw new IllegalArgumentException(\"Printer must extend BaseDateTimeFormatter\");\n+        }\n     }\n \n     private DateTimeFormatterBuilder append0(Object element) {\n         return this;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Instructs the printer to emit a specific character, and the parser to\n      * expect it. The parser is case-insensitive.\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendLiteral(char c) {\n-        return append0(new CharacterLiteral(iChrono, c));\n+        return append0(new CharacterLiteral(c));\n     }\n \n     /**\n         if (text == null) {\n             throw new IllegalArgumentException(\"Literal must not be null\");\n         }\n-        return append0(new StringLiteral(iChrono, text));\n+        switch (text.length()) {\n+            case 0:\n+                return this;\n+            case 1:\n+                return append0(new CharacterLiteral(text.charAt(0)));\n+            default:\n+                return append0(new StringLiteral(text));\n+        }\n     }\n \n     /**\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n-        DateTimeField field = fieldType.getField(iChronoUTC);\n         if (minDigits <= 1) {\n-            return append0(new UnpaddedNumber(iChrono, field, maxDigits, false));\n+            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n         } else {\n-            return append0(new PaddedNumber(iChrono, field, maxDigits, false, minDigits));\n+            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n         }\n     }\n \n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n-        DateTimeField field = fieldType.getField(iChronoUTC);\n         if (minDigits <= 1) {\n-            return append0(new UnpaddedNumber(iChrono, field, maxDigits, true));\n+            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n         } else {\n-            return append0(new PaddedNumber(iChrono, field, maxDigits, true, minDigits));\n+            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n         }\n     }\n \n         if (fieldType == null) {\n             throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n-        DateTimeField field = fieldType.getField(iChronoUTC);\n-        return append0(new TextField(iChrono, field, iLocale, false));\n+        return append0(new TextField(fieldType, iLocale, false));\n     }\n \n     /**\n         if (fieldType == null) {\n             throw new IllegalArgumentException(\"Field type must not be null\");\n         }\n-        DateTimeField field = fieldType.getField(iChronoUTC);\n-        return append0(new TextField(iChrono, field, iLocale, true));\n+        return append0(new TextField(fieldType, iLocale, true));\n     }\n \n     /**\n         if (minDigits < 0 || maxDigits <= 0) {\n             throw new IllegalArgumentException();\n         }\n-        DateTimeField field = fieldType.getField(iChronoUTC);\n-        return append0(new Fraction(iChrono, field, minDigits, maxDigits));\n+        return append0(new Fraction(fieldType, minDigits, maxDigits));\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n-        DateTimeField field = DateTimeFieldType.year().getField(iChronoUTC);\n-        return append0(new TwoDigitYear(iChrono, field, pivot));\n+        return append0(new TwoDigitYear(pivot));\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n-        return append0(new TimeZonePrinter(iChrono, iLocale, false), null);\n+        return append0(new TimeZonePrinter( iLocale, false), null);\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName() {\n-        return append0(new TimeZonePrinter(iChrono, iLocale, true), null);\n+        return append0(new TimeZonePrinter( iLocale, true), null);\n     }\n \n     /**\n             String zeroOffsetText, boolean showSeparators,\n             int minFields, int maxFields) {\n         return append0(new TimeZoneOffsetFormatter\n-                       (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));\n+                       (zeroOffsetText, showSeparators, minFields, maxFields));\n     }\n \n     /**\n             }\n \n             if (f == null) {\n-                f = new Composite(iChrono, iElementPairs);\n+                f = new Composite(iElementPairs);\n             }\n \n             iFormatter = f;\n         return false;\n     }\n \n-    private static abstract class AbstractFormatter extends AbstractDateTimeFormatter {\n-        protected final Chronology iChrono;\n-\n-        AbstractFormatter(Chronology chrono) {\n-            iChrono = chrono;\n-        }\n-\n-        public Chronology getChronology() {\n-            return iChrono;\n-        }\n-\n-        protected void appendUnknownString(StringBuffer buf, int len) {\n-            for (int i = len; --i >= 0;) {\n-                buf.append('\\ufffd');\n-            }\n-        }\n-\n-        protected void printUnknownString(Writer out, int len) throws IOException {\n-            for (int i = len; --i >= 0;) {\n-                out.write('\\ufffd');\n-            }\n-        }\n-    }\n-\n-    private static class CharacterLiteral extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n+    static void appendUnknownString(StringBuffer buf, int len) {\n+        for (int i = len; --i >= 0;) {\n+            buf.append('\\ufffd');\n+        }\n+    }\n+\n+    static void printUnknownString(Writer out, int len) throws IOException {\n+        for (int i = len; --i >= 0;) {\n+            out.write('\\ufffd');\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class CharacterLiteral\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n         private final char iValue;\n \n-        CharacterLiteral(Chronology chrono, char value) {\n-            super(chrono);\n+        CharacterLiteral(char value) {\n+            super();\n             iValue = value;\n         }\n \n             return 1;\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             out.write(iValue);\n         }\n \n             out.write(iValue);\n         }\n \n-        public String print(long instant, DateTimeZone zone, long instantLocal) {\n+        protected String print(long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             return String.valueOf(iValue);\n         }\n \n             return String.valueOf(iValue);\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return 1;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             if (position >= text.length()) {\n                 return ~position;\n             }\n         }\n     }\n \n-    private static class StringLiteral extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n+    //-----------------------------------------------------------------------\n+    static class StringLiteral\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n         private final String iValue;\n \n-        StringLiteral(Chronology chrono, String value) {\n-            super(chrono);\n+        StringLiteral(String value) {\n+            super();\n             iValue = value;\n         }\n \n             return iValue.length();\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             buf.append(iValue);\n         }\n \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             out.write(iValue);\n         }\n \n             out.write(iValue);\n         }\n \n-        public String print(long instant, DateTimeZone zone, long instantLocal) {\n+        protected String print(long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             return iValue;\n         }\n \n         }\n     }\n \n-    private abstract static class NumberFormatter extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n-        protected final DateTimeField iField;\n+    //-----------------------------------------------------------------------\n+    static abstract class NumberFormatter\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter {\n+        protected final DateTimeFieldType iFieldType;\n         protected final int iMaxParsedDigits;\n         protected final boolean iSigned;\n \n-        NumberFormatter(\n-                Chronology chrono, DateTimeField field,\n+        NumberFormatter(DateTimeFieldType fieldType,\n                 int maxParsedDigits, boolean signed) {\n-            super(chrono);\n-            iField = field;\n+            super();\n+            iFieldType = fieldType;\n             iMaxParsedDigits = maxParsedDigits;\n             iSigned = signed;\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = Math.min(iMaxParsedDigits, text.length() - position);\n \n             boolean negative = false;\n                 }\n             }\n \n-            bucket.saveField(iField, value);\n+            bucket.saveField(iFieldType, value);\n             return position;\n         }\n     }\n \n-    private static class UnpaddedNumber extends NumberFormatter {\n-        UnpaddedNumber(Chronology chrono, DateTimeField field,\n+    //-----------------------------------------------------------------------\n+    static class UnpaddedNumber extends NumberFormatter {\n+\n+        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                        int maxParsedDigits, boolean signed)\n         {\n-            super(chrono, field, maxParsedDigits, signed);\n-        }\n-\n-        public int estimatePrintedLength() {\n+            super(fieldType, maxParsedDigits, signed);\n+        }\n+\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            DateTimeField field = iFieldType.getField(chrono.withUTC());\n+            return new BoundUnpaddedNumber(field, iMaxParsedDigits, iSigned);\n+        }\n+\n+        protected int estimatePrintedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            try {\n+                DateTimeField field = iFieldType.getField(chronoLocal);\n+                FormatUtils.appendUnpaddedInteger(buf, field.get(instantLocal));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            try {\n+                DateTimeField field = iFieldType.getField(chronoLocal);\n+                FormatUtils.writeUnpaddedInteger(out, field.get(instantLocal));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n+                } catch (RuntimeException e) {\n+                    buf.append('\\ufffd');\n+                }\n+            } else {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n+                } catch (RuntimeException e) {\n+                    out.write('\\ufffd');\n+                }\n+            } else {\n+                out.write('\\ufffd');\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class BoundUnpaddedNumber\n+            extends UnpaddedNumber\n+            implements BoundDateTimePrinter {\n+\n+        private final DateTimeField iField;\n+\n+        BoundUnpaddedNumber(DateTimeField field, int maxParsedDigits, boolean signed) {\n+            super(field.getType(), maxParsedDigits, signed);\n+            iField = field;\n+        }\n+\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             try {\n                 FormatUtils.appendUnpaddedInteger(buf, iField.get(instantLocal));\n             } catch (RuntimeException e) {\n             }\n         }\n \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             try {\n                 FormatUtils.writeUnpaddedInteger(out, iField.get(instantLocal));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n         }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField.getType())) {\n-                try {\n-                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iField.getType()));\n-                } catch (RuntimeException e) {\n-                    buf.append('\\ufffd');\n-                }\n-            } else {\n-                buf.append('\\ufffd');\n-            }\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField.getType())) {\n-                try {\n-                    FormatUtils.writeUnpaddedInteger(out, partial.get(iField.getType()));\n-                } catch (RuntimeException e) {\n-                    out.write('\\ufffd');\n-                }\n-            } else {\n-                out.write('\\ufffd');\n-            }\n-        }\n-    }\n-\n-    private static class PaddedNumber extends NumberFormatter {\n-        private final int iMinPrintedDigits;\n-\n-        PaddedNumber(Chronology chrono,\n-                     DateTimeField field, int maxParsedDigits,\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class PaddedNumber extends NumberFormatter {\n+\n+        protected final int iMinPrintedDigits;\n+\n+        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                      boolean signed, int minPrintedDigits)\n         {\n-            super(chrono, field, maxParsedDigits, signed);\n+            super(fieldType, maxParsedDigits, signed);\n             iMinPrintedDigits = minPrintedDigits;\n         }\n \n-        public int estimatePrintedLength() {\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            DateTimeField field = iFieldType.getField(chrono.withUTC());\n+            return new BoundPaddedNumber(field, iMaxParsedDigits, iSigned, iMinPrintedDigits);\n+        }\n+\n+        protected int estimatePrintedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            try {\n+                DateTimeField field = iFieldType.getField(chronoLocal);\n+                FormatUtils.appendPaddedInteger(buf, field.get(instantLocal), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                appendUnknownString(buf, iMinPrintedDigits);\n+            }\n+        }\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            try {\n+                DateTimeField field = iFieldType.getField(chronoLocal);\n+                FormatUtils.writePaddedInteger(out, field.get(instantLocal), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                printUnknownString(out, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    appendUnknownString(buf, iMinPrintedDigits);\n+                }\n+            } else {\n+                appendUnknownString(buf, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    printUnknownString(out, iMinPrintedDigits);\n+                }\n+            } else {\n+                printUnknownString(out, iMinPrintedDigits);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class BoundPaddedNumber\n+            extends PaddedNumber\n+            implements BoundDateTimePrinter {\n+\n+        private final DateTimeField iField;\n+\n+        BoundPaddedNumber(DateTimeField field, int maxParsedDigits,\n+                          boolean signed, int minPrintedDigits)\n+        {\n+            super(field.getType(), maxParsedDigits, signed, minPrintedDigits);\n+            iField = field;\n+        }\n+\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             try {\n                 FormatUtils.appendPaddedInteger(buf, iField.get(instantLocal), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n             }\n         }\n \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             try {\n                 FormatUtils.writePaddedInteger(out, iField.get(instantLocal), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n                 printUnknownString(out, iMinPrintedDigits);\n             }\n         }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField.getType())) {\n-                try {\n-                    FormatUtils.appendPaddedInteger(buf, partial.get(iField.getType()), iMinPrintedDigits);\n-                } catch (RuntimeException e) {\n-                    appendUnknownString(buf, iMinPrintedDigits);\n-                }\n-            } else {\n-                appendUnknownString(buf, iMinPrintedDigits);\n-            }\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField.getType())) {\n-                try {\n-                    FormatUtils.writePaddedInteger(out, partial.get(iField.getType()), iMinPrintedDigits);\n-                } catch (RuntimeException e) {\n-                    printUnknownString(out, iMinPrintedDigits);\n-                }\n-            } else {\n-                printUnknownString(out, iMinPrintedDigits);\n-            }\n-        }\n-    }\n-\n-    private static class TwoDigitYear extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n-        private final DateTimeField iField;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TwoDigitYear\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n         private final int iPivot;\n \n-        TwoDigitYear(Chronology chrono, DateTimeField field, int pivot) {\n-            super(chrono);\n-            iField = field;\n+        TwoDigitYear(int pivot) {\n+            super();\n             iPivot = pivot;\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return 2;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = Math.min(2, text.length() - position);\n             if (limit < 2) {\n                 return ~position;\n \n             year += low + ((year < t) ? 100 : 0) - t;\n \n-            bucket.saveField(iField, year);\n+            bucket.saveField(DateTimeFieldType.year(), year);\n             return position + 2;\n         }\n         \n-        public int estimatePrintedLength() {\n+        protected int estimatePrintedLength() {\n             return 2;\n         }\n \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            int year = getTwoDigitYear(instantLocal);\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            int year = getTwoDigitYear(instantLocal, chronoLocal);\n             if (year < 0) {\n                 buf.append('\\ufffd');\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n-            int year = getTwoDigitYear(instantLocal);\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            int year = getTwoDigitYear(instantLocal, chronoLocal);\n             if (year < 0) {\n                 out.write('\\ufffd');\n                 out.write('\\ufffd');\n             }\n         }\n \n-        private int getTwoDigitYear(long instantLocal) {\n+        private int getTwoDigitYear(long instantLocal, Chronology chronoLocal) {\n             try {\n-                int year = iField.get(instantLocal);\n+                int year = chronoLocal.year().get(instantLocal);\n                 if (year < 0) {\n                     year = -year;\n                 }\n         }\n \n         private int getTwoDigitYear(ReadablePartial partial) {\n-            if (partial.isSupported(iField.getType())) {\n+            if (partial.isSupported(DateTimeFieldType.year())) {\n                 try {\n-                    int year = partial.get(iField.getType());\n+                    int year = partial.get(DateTimeFieldType.year());\n                     if (year < 0) {\n                         year = -year;\n                     }\n         }\n     }\n \n-    private static class TextField extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n-        private final DateTimeField iField;\n+    //-----------------------------------------------------------------------\n+    static class TextField\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n+        private final DateTimeFieldType iFieldType;\n         private final Locale iLocale;\n         private final boolean iShort;\n \n-        TextField(Chronology chrono, DateTimeField field,\n-                  Locale locale, boolean isShort) {\n-            super(chrono);\n-            iField = field;\n+        TextField(DateTimeFieldType fieldType, Locale locale, boolean isShort) {\n+            super();\n+            iFieldType = fieldType;\n             iLocale = locale;\n             iShort = isShort;\n         }\n \n-        public int estimatePrintedLength() {\n+        protected int estimatePrintedLength() {\n+            return iShort ? 6 : 20;\n+        }\n+\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             try {\n-                if (iShort) {\n-                    return iField.getMaximumShortTextLength(iLocale);\n-                } else {\n-                    return iField.getMaximumTextLength(iLocale);\n-                }\n-            } catch (RuntimeException e) {\n-                return 1;\n-            }\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            try {\n-                buf.append(print(instant, zone, instantLocal));\n+                buf.append(print(instantLocal, chronoLocal, instant, chrono));\n             } catch (RuntimeException e) {\n                 buf.append('\\ufffd');\n             }\n         }\n-    \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             try {\n-                out.write(print(instant, zone, instantLocal));\n+                out.write(print(instantLocal, chronoLocal, instant, chrono));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n             }\n         }\n \n-        public final String print(long instant, DateTimeZone zone, long instantLocal) {\n+        protected String print(long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            DateTimeField field = iFieldType.getField(chrono);\n             if (iShort) {\n-                return iField.getAsShortText(instantLocal, iLocale);\n+                return field.getAsShortText(instantLocal, iLocale);\n             } else {\n-                return iField.getAsText(instantLocal, iLocale);\n-            }\n-        }\n-\n-        public final String print(ReadablePartial partial) {\n-            if (partial.isSupported(iField.getType())) {\n+                return field.getAsText(instantLocal, iLocale);\n+            }\n+        }\n+\n+        public String print(ReadablePartial partial) {\n+            if (partial.isSupported(iFieldType)) {\n+                DateTimeField field = iFieldType.getField(partial.getChronology());\n                 if (iShort) {\n-                    return iField.getAsShortText(partial, iLocale);\n+                    return field.getAsShortText(partial, iLocale);\n                 } else {\n-                    return iField.getAsText(partial, iLocale);\n+                    return field.getAsText(partial, iLocale);\n                 }\n             } else {\n                 return \"\\ufffd\";\n             }\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return estimatePrintedLength();\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = text.length();\n             int i = position;\n             for (; i<limit; i++) {\n                 return ~position;\n             }\n \n-            bucket.saveField(iField, text.substring(position, i), iLocale);\n+            bucket.saveField(iFieldType, text.substring(position, i), iLocale);\n \n             return i;\n         }\n     }\n \n-    private static class Fraction extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n-        private final DateTimeField iField;\n-        private final long iRangeMillis;\n-        private final int iMinDigits;\n-        private final int iMaxDigits;\n-\n-        private final long iScalar;\n-\n-        private transient DateTimeField iParseField;\n-\n-        Fraction(Chronology chrono, DateTimeField field,\n-                 int minDigits, int maxDigits) {\n-            super(chrono);\n-            iField = field;\n-            iRangeMillis = field.getDurationField().getUnitMillis();\n-\n+    //-----------------------------------------------------------------------\n+    static class Fraction\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter {\n+\n+        private final DateTimeFieldType iFieldType;\n+        protected int iMinDigits;\n+        protected int iMaxDigits;\n+\n+        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+            super();\n+            iFieldType = fieldType;\n             // Limit the precision requirements.\n             if (maxDigits > 18) {\n                 maxDigits = 18;\n             }\n-\n             iMinDigits = minDigits;\n-\n+            iMaxDigits = maxDigits;\n+        }\n+\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            DateTimeField field = iFieldType.getField(chrono.withUTC());\n+            return new BoundFraction(field, iMinDigits, iMaxDigits);\n+        }\n+\n+        protected int estimatePrintedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            try {\n+                printTo(buf, null, instantLocal, chronoLocal);\n+            } catch (IOException e) {\n+                // Not gonna happen.\n+            }\n+        }\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            printTo(null, out, instantLocal, chronoLocal);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial) {\n+            if (partial.isSupported(iFieldType)) {\n+                long millis = partial.getChronology().set(partial, 0L);\n+                try {\n+                    printTo(buf, null, millis, partial.getChronology());\n+                } catch (IOException e) {\n+                    // Not gonna happen.\n+                }\n+            } else {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+            if (partial.isSupported(iFieldType)) {\n+                long millis = partial.getChronology().set(partial, 0L);\n+                printTo(null, out, millis, partial.getChronology());\n+            } else {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        protected void printTo(StringBuffer buf, Writer out, long instantLocal, Chronology chronoLocal)\n+            throws IOException\n+        {\n+            DateTimeField field = iFieldType.getField(chronoLocal);\n+            int minDigits = iMinDigits;\n+\n+            long fraction;\n+            try {\n+                fraction = field.remainder(instantLocal);\n+            } catch (RuntimeException e) {\n+                if (buf != null) {\n+                    appendUnknownString(buf, minDigits);\n+                } else {\n+                    printUnknownString(out, minDigits);\n+                }\n+                return;\n+            }\n+\n+            if (fraction == 0) {\n+                if (buf != null) {\n+                    while (--minDigits >= 0) {\n+                        buf.append('0');\n+                    }\n+                } else {\n+                    while (--minDigits >= 0) {\n+                        out.write('0');\n+                    }\n+                }\n+                return;\n+            }\n+\n+            String str;\n+            long[] fractionData = getFractionData(fraction, field);\n+            long scaled = fractionData[0];\n+            int maxDigits = (int) fractionData[1];\n+            \n+            if ((scaled & 0x7fffffff) == scaled) {\n+                str = Integer.toString((int) scaled);\n+            } else {\n+                str = Long.toString(scaled);\n+            }\n+\n+            int length = str.length();\n+            int digits = maxDigits;\n+            while (length < digits) {\n+                if (buf != null) {\n+                    buf.append('0');\n+                } else {\n+                    out.write('0');\n+                }\n+                minDigits--;\n+                digits--;\n+            }\n+\n+            if (minDigits < digits) {\n+                // Chop off as many trailing zero digits as necessary.\n+                while (minDigits < digits) {\n+                    if (length <= 1 || str.charAt(length - 1) != '0') {\n+                        break;\n+                    }\n+                    digits--;\n+                    length--;\n+                }\n+                if (length < str.length()) {\n+                    if (buf != null) {\n+                        for (int i=0; i<length; i++) {\n+                            buf.append(str.charAt(i));\n+                        }\n+                    } else {\n+                        for (int i=0; i<length; i++) {\n+                            out.write(str.charAt(i));\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+\n+            if (buf != null) {\n+                buf.append(str);\n+            } else {\n+                out.write(str);\n+            }\n+        }\n+        \n+        private long[] getFractionData(long fraction, DateTimeField field) {\n+            long rangeMillis = field.getDurationField().getUnitMillis();\n             long scalar;\n+            int maxDigits = iMaxDigits;\n             while (true) {\n                 switch (maxDigits) {\n                 default: scalar = 1L; break;\n                 case 17: scalar = 100000000000000000L; break;\n                 case 18: scalar = 1000000000000000000L; break;\n                 }\n-                if (((iRangeMillis * scalar) / scalar) == iRangeMillis) {\n+                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                     break;\n                 }\n                 // Overflowed: scale down.\n                 maxDigits--;\n             }\n-\n+            \n+            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n+        }\n+\n+        protected int estimateParsedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeField field = iFieldType.getField(bucket.getChronology());\n+            \n+            int limit = Math.min(iMaxDigits, text.length() - position);\n+\n+            long value = 0;\n+            long n = field.getDurationField().getUnitMillis() * 10;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+                long nn = n / 10;\n+                value += (c - '0') * nn;\n+                n = nn;\n+            }\n+\n+            value /= 10;\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            if (value > Integer.MAX_VALUE) {\n+                return ~position;\n+            }\n+\n+            DateTimeField parseField = new PreciseDateTimeField(\n+                DateTimeFieldType.millisOfSecond(),\n+                MillisDurationField.INSTANCE,\n+                field.getDurationField());\n+\n+            bucket.saveField(parseField, (int) value);\n+\n+            return position + length;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class BoundFraction\n+            extends Fraction\n+            implements BoundDateTimePrinter {\n+\n+        private final DateTimeField iField;\n+        private final long iScalar;\n+        private final long iRangeMillis;\n+\n+        BoundFraction(DateTimeField field, int minDigits, int maxDigits) {\n+            super(field.getType(), minDigits, maxDigits);\n+            iField = field;\n+            iMinDigits = minDigits;\n+            \n+            long rangeMillis = field.getDurationField().getUnitMillis();\n+            long scalar;\n+            while (true) {\n+                switch (maxDigits) {  // know this is 18 or less\n+                default: scalar = 1L; break;\n+                case 1:  scalar = 10L; break;\n+                case 2:  scalar = 100L; break;\n+                case 3:  scalar = 1000L; break;\n+                case 4:  scalar = 10000L; break;\n+                case 5:  scalar = 100000L; break;\n+                case 6:  scalar = 1000000L; break;\n+                case 7:  scalar = 10000000L; break;\n+                case 8:  scalar = 100000000L; break;\n+                case 9:  scalar = 1000000000L; break;\n+                case 10: scalar = 10000000000L; break;\n+                case 11: scalar = 100000000000L; break;\n+                case 12: scalar = 1000000000000L; break;\n+                case 13: scalar = 10000000000000L; break;\n+                case 14: scalar = 100000000000000L; break;\n+                case 15: scalar = 1000000000000000L; break;\n+                case 16: scalar = 10000000000000000L; break;\n+                case 17: scalar = 100000000000000000L; break;\n+                case 18: scalar = 1000000000000000000L; break;\n+                }\n+                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n+                    break;\n+                }\n+                // Overflowed: scale down.\n+                maxDigits--;\n+            }\n             iMaxDigits = maxDigits;\n             iScalar = scalar;\n-        }\n-\n-        public int estimatePrintedLength() {\n-            return iMaxDigits;\n-        }\n-\n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            try {\n-                printTo(buf, null, instantLocal);\n-            } catch (IOException e) {\n-                // Not gonna happen.\n-            }\n-        }\n-\n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n-            printTo(null, out, instantLocal);\n-        }\n-\n-        public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField.getType())) {\n-                long millis = this.iChrono.withUTC().set(partial, 0L);\n-                try {\n-                    printTo(buf, null, millis);\n-                } catch (IOException e) {\n-                    // Not gonna happen.\n-                }\n-            } else {\n-                buf.append('\\ufffd');\n-            }\n-        }\n-\n-        public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField.getType())) {\n-                long millis = this.iChrono.withUTC().set(partial, 0L);\n-                printTo(null, out, millis);\n-            } else {\n-                out.write('\\ufffd');\n-            }\n-        }\n-\n-        private void printTo(StringBuffer buf, Writer out, long instantLocal)\n+            iRangeMillis = rangeMillis;\n+        }\n+\n+        protected void printTo(StringBuffer buf, Writer out, long instantLocal, Chronology chronoLocal)\n             throws IOException\n         {\n+            DateTimeField field = iField;\n             int minDigits = iMinDigits;\n \n             long fraction;\n             try {\n-                fraction = iField.remainder(instantLocal);\n+                fraction = field.remainder(instantLocal);\n             } catch (RuntimeException e) {\n                 if (buf != null) {\n-                    while (--minDigits >= 0) {\n-                        buf.append('\\ufffd');\n-                    }\n+                    appendUnknownString(buf, minDigits);\n                 } else {\n-                    while (--minDigits >= 0) {\n-                        out.write('\\ufffd');\n-                    }\n+                    printUnknownString(out, minDigits);\n                 }\n                 return;\n             }\n \n             String str;\n             long scaled = fraction * iScalar / iRangeMillis;\n+            int maxDigits = iMaxDigits;\n+            \n             if ((scaled & 0x7fffffff) == scaled) {\n-                str = Integer.toString((int)scaled);\n+                str = Integer.toString((int) scaled);\n             } else {\n                 str = Long.toString(scaled);\n             }\n \n             int length = str.length();\n-            int digits = iMaxDigits;\n-\n+            int digits = maxDigits;\n             while (length < digits) {\n                 if (buf != null) {\n                     buf.append('0');\n                 out.write(str);\n             }\n         }\n-\n-        public int estimateParsedLength() {\n-            return iMaxDigits;\n-        }\n-\n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            int limit = Math.min(iMaxDigits, text.length() - position);\n-\n-            long value = 0;\n-            long n = iRangeMillis * 10;\n-            int length = 0;\n-            while (length < limit) {\n-                char c = text.charAt(position + length);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                length++;\n-                long nn = n / 10;\n-                value += (c - '0') * nn;\n-                n = nn;\n-            }\n-\n-            value /= 10;\n-\n-            if (length == 0) {\n-                return ~position;\n-            }\n-\n-            if (value > Integer.MAX_VALUE) {\n-                return ~position;\n-            }\n-\n-            if (iParseField == null) {\n-                iParseField = new PreciseDateTimeField\n-                    (DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, iField.getDurationField());\n-            }\n-\n-            bucket.saveField(iParseField, (int)value);\n-\n-            return position + length;\n-        }\n-    }\n-\n-    private static class TimeZoneOffsetFormatter extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TimeZoneOffsetFormatter\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n         private final String iZeroOffsetText;\n         private final boolean iShowSeparators;\n         private final int iMinFields;\n         private final int iMaxFields;\n \n-        TimeZoneOffsetFormatter(Chronology chrono,\n-                                String zeroOffsetText,\n+        TimeZoneOffsetFormatter(String zeroOffsetText,\n                                 boolean showSeparators,\n                                 int minFields, int maxFields)\n         {\n-            super(chrono);\n+            super();\n             iZeroOffsetText = zeroOffsetText;\n             iShowSeparators = showSeparators;\n             if (minFields <= 0 || maxFields < minFields) {\n             iMaxFields = maxFields;\n         }\n             \n-        public int estimatePrintedLength() {\n+        protected int estimatePrintedLength() {\n             int est = 1 + iMinFields << 1;\n             if (iShowSeparators) {\n                 est += iMinFields - 1;\n             return est;\n         }\n         \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n             int offset = (int)(instantLocal - instant);\n \n             if (offset == 0 && iZeroOffsetText != null) {\n             FormatUtils.appendPaddedInteger(buf, offset, 3);\n         }\n         \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n             int offset = (int)(instantLocal - instant);\n \n             if (offset == 0 && iZeroOffsetText != null) {\n             // no zone info\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return estimatePrintedLength();\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = text.length() - position;\n \n             zeroOffset:\n         }\n     }\n \n-    private static class TimeZonePrinter extends AbstractFormatter\n-        implements DateTimePrinter \n-    {\n+    //-----------------------------------------------------------------------\n+    static class TimeZonePrinter\n+            extends BaseDateTimeFormatter\n+            implements DateTimePrinter, BoundDateTimePrinter {\n+\n         private final Locale iLocale;\n         private final boolean iShortFormat;\n \n-        TimeZonePrinter(Chronology chrono, Locale locale, boolean shortFormat) {\n-            super(chrono);\n+        TimeZonePrinter(Locale locale, boolean shortFormat) {\n+            super();\n             iLocale = locale;\n             iShortFormat = shortFormat;\n         }\n \n-        public int estimatePrintedLength() {\n+        protected int estimatePrintedLength() {\n             return iShortFormat ? 4 : 20;\n         }\n-        \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            if (zone == null) {\n-                zone = getZone();\n-            }\n-            if (iShortFormat) {\n-                buf.append(zone.getShortName(instant, this.iLocale));\n-            } else {\n-                buf.append(zone.getName(instant, this.iLocale));\n-            }\n-        }\n-        \n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n-            if (zone == null) {\n-                zone = getZone();\n-            }\n-            if (iShortFormat) {\n-                out.write(zone.getShortName(instant, this.iLocale));\n-            } else {\n-                out.write(zone.getName(instant, this.iLocale));\n-            }\n-        }\n-\n-        public String print(long instant, DateTimeZone zone, long instantLocal) {\n-            if (zone == null) {\n-                zone = getZone();\n-            }\n+\n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            buf.append(print(instantLocal, chronoLocal, instant, chrono));\n+        }\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            out.write(print(instantLocal, chronoLocal, instant, chrono));\n+        }\n+\n+        protected String print(long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            DateTimeZone zone = chrono.getZone();\n             if (iShortFormat) {\n                 return zone.getShortName(instant, this.iLocale);\n             } else {\n         }\n     }\n \n-    private static final class Composite extends AbstractFormatter\n-        implements DateTimeFormatter\n-    {\n-        private final DateTimePrinter[] iPrinters;\n-        private final DateTimeParser[] iParsers;\n+    //-----------------------------------------------------------------------\n+    static class Composite\n+            extends BaseDateTimeFormatter\n+            implements DateTimeFormatter, BoundDateTimePrinter {\n+\n+        private final BaseDateTimeFormatter[] iPrinters;\n+        private final BaseDateTimeFormatter[] iParsers;\n \n         private final int iPrintedLengthEstimate;\n         private final int iParsedLengthEstimate;\n \n-        Composite(Chronology chrono, List elementPairs) {\n-            super(chrono);\n+        Composite(List elementPairs) {\n+            super();\n \n             List printerList = new ArrayList();\n             List parserList = new ArrayList();\n                 iPrintedLengthEstimate = 0;\n             } else {\n                 int size = printerList.size();\n-                iPrinters = new DateTimePrinter[size];\n+                iPrinters = new BaseDateTimeFormatter[size];\n                 int printEst = 0;\n                 for (int i=0; i<size; i++) {\n-                    DateTimePrinter printer = (DateTimePrinter)printerList.get(i);\n+                    BaseDateTimeFormatter printer = (BaseDateTimeFormatter) printerList.get(i);\n                     printEst += printer.estimatePrintedLength();\n                     iPrinters[i] = printer;\n                 }\n                 iParsedLengthEstimate = 0;\n             } else {\n                 int size = parserList.size();\n-                iParsers = new DateTimeParser[size];\n+                iParsers = new BaseDateTimeFormatter[size];\n                 int parseEst = 0;\n                 for (int i=0; i<size; i++) {\n-                    DateTimeParser parser = (DateTimeParser)parserList.get(i);\n+                    BaseDateTimeFormatter parser = (BaseDateTimeFormatter) parserList.get(i);\n                     parseEst += parser.estimateParsedLength();\n                     iParsers[i] = parser;\n                 }\n             }\n         }\n \n-        public int estimatePrintedLength() {\n-            return iPrintedLengthEstimate;\n-        }\n-    \n-        public void printTo(StringBuffer buf, long instant,\n-                            DateTimeZone zone, long instantLocal) {\n-            DateTimePrinter[] elements = iPrinters;\n+        private Composite(Composite base, BaseDateTimeFormatter[] printers) {\n+            iPrinters = printers;\n+            iParsers = base.iParsers;\n+            iPrintedLengthEstimate = base.iPrintedLengthEstimate;\n+            iParsedLengthEstimate = base.iParsedLengthEstimate;\n+        }\n+\n+        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n+            BaseDateTimeFormatter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n \n             int len = elements.length;\n-            for (int i=0; i<len; i++) {\n-                elements[i].printTo(buf, instant, zone, instantLocal);\n-            }\n-        }\n-\n-        public void printTo(Writer out, long instant,\n-                            DateTimeZone zone, long instantLocal) throws IOException {\n-            DateTimePrinter[] elements = iPrinters;\n+            BaseDateTimeFormatter[] array = new BaseDateTimeFormatter[len];\n+            for (int i = 0; i < len; i++) {\n+                BoundDateTimePrinter bound = ((DateTimePrinter) elements[i]).bindPrinter(chrono);\n+                array[i] = (BaseDateTimeFormatter) bound;\n+            }\n+            return new Composite(this, array);\n+        }\n+\n+        protected int estimatePrintedLength() {\n+            return iPrintedLengthEstimate;\n+        }\n+    \n+        protected void printTo(StringBuffer buf,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) {\n+            BaseDateTimeFormatter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n \n             int len = elements.length;\n-            for (int i=0; i<len; i++) {\n-                elements[i].printTo(out, instant, zone, instantLocal);\n+            for (int i = 0; i < len; i++) {\n+                elements[i].printTo(buf, instantLocal, chronoLocal, instant, chrono);\n+            }\n+        }\n+\n+        protected void printTo(Writer out,\n+                               long instantLocal, Chronology chronoLocal,\n+                               long instant, Chronology chrono) throws IOException {\n+            BaseDateTimeFormatter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i = 0; i < len; i++) {\n+                elements[i].printTo(out, instantLocal, chronoLocal, instant, chrono);\n             }\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            DateTimePrinter[] elements = iPrinters;\n+            BaseDateTimeFormatter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            DateTimePrinter[] elements = iPrinters;\n+            BaseDateTimeFormatter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n             }\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return iParsedLengthEstimate;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            DateTimeParser[] elements = iParsers;\n-\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            BaseDateTimeFormatter[] elements = iParsers;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n         }\n     }\n \n-    private static final class MatchingParser extends AbstractFormatter\n-        implements DateTimeParser\n-    {\n-        private final DateTimeParser[] iParsers;\n+    //-----------------------------------------------------------------------\n+    static class MatchingParser\n+            extends BaseDateTimeFormatter\n+            implements DateTimeParser {\n+\n+        private final BaseDateTimeFormatter[] iParsers;\n         private final int iParsedLengthEstimate;\n \n-        MatchingParser(Chronology chrono, DateTimeParser[] parsers) {\n-            super(chrono);\n+        MatchingParser(BaseDateTimeFormatter[] parsers) {\n+            super();\n             iParsers = parsers;\n             int est = 0;\n             for (int i=parsers.length; --i>=0 ;) {\n-                DateTimeParser parser = parsers[i];\n+                BaseDateTimeFormatter parser = parsers[i];\n                 if (parser != null) {\n                     int len = parser.estimateParsedLength();\n                     if (len > est) {\n             iParsedLengthEstimate = est;\n         }\n \n-        public int estimateParsedLength() {\n+        protected int estimateParsedLength() {\n             return iParsedLengthEstimate;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            DateTimeParser[] parsers = iParsers;\n+        protected int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            BaseDateTimeFormatter[] parsers = iParsers;\n             int length = parsers.length;\n \n             final Object originalState = bucket.saveState();\n             int bestInvalidPos = position;\n \n             for (int i=0; i<length; i++) {\n-                DateTimeParser parser = parsers[i];\n+                BaseDateTimeFormatter parser = parsers[i];\n                 if (parser == null) {\n                     // The empty parser wins only if nothing is better.\n                     if (bestValidPos <= position) {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.ReadWritableInstant;\n \n /**\n  * Defines an interface for parsing textual representations of datetimes.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n+ * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @see DateTimeFormatter\n public interface DateTimeParser {\n \n     /**\n-     * Returns the Chronology being used by the parser, or null if none.\n-     * \n-     * @return the chronology in use, may be null if none\n-     */\n-    Chronology getChronology();\n-\n-    /**\n-     * Returns the expected maximum number of characters consumed. The actual\n-     * amount should rarely exceed this estimate.\n-     * \n-     * @return the estimated length\n-     */\n-    int estimateParsedLength();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Parse an element from the given text, saving any fields into the given\n-     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n-     * text position. Note that the parse may succeed without fully reading the\n-     * text.\n-     * <p>\n-     * If it fails, the return value is negative. To determine the position\n-     * where the parse failed, apply the one's complement operator (~) on the\n-     * return value.\n-     *\n-     * @param bucket  field are saved into this\n-     * @param text  the text to parse\n-     * @param position  position to start parsing from\n-     * @return new position, negative value means parse failed -\n-     *  apply complement operator (~) to get position of failure\n-     * @throws IllegalArgumentException if any field is out of range\n-     */\n-    int parseInto(DateTimeParserBucket bucket, String text, int position);\n-\n-    /**\n      * Parses a datetime from the given text, at the given position, saving the\n      * result into the fields of the given ReadWritableInstant. If the parse\n      * succeeds, the return value is the new text position. Note that the parse\n      * If it fails, the return value is negative, but the instant may still be\n      * modified. To determine the position where the parse failed, apply the\n      * one's complement operator (~) on the return value.\n+     * <p>\n+     * The parse will use the chronology of the instant.\n      *\n      * @param instant  an instant that will be modified\n-     * @param text  text to parse\n+     * @param text  the text to parse\n      * @param position  position to start parsing from\n      * @return new position, negative value means parse failed -\n      *  apply complement operator (~) to get position of failure\n+     * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     int parseInto(ReadWritableInstant instant, String text, int position);\n     /**\n      * Parses a datetime from the given text, returning the number of\n      * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * <p>\n+     * The parse will use the ISO chronology, and the default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n      *\n      * @param text  text to parse\n      * @return parsed value expressed in milliseconds since the epoch\n      */\n     long parseMillis(String text);\n \n+    /**\n+     * Parses a datetime from the given text, returning the number of\n+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * <p>\n+     * The parse will use the given chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return parsed value expressed in milliseconds since the epoch\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    long parseMillis(String text, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Parses a datetime from the given text, at the given position, returning\n      * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.\n      * An initial millisecond value is passed in, which is relative to the epoch,\n-     * local time.\n-     *\n-     * @param text  text to parse\n-     * @param instantLocal  initial value of instant, relative to the epoch, local time\n+     * local time, and which can default field values.\n+     * <p>\n+     * The parse will use the ISO chronology and default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n+     * @param instant  initial value of instant, relative to the epoch, local time\n      * @return parsed value expressed in milliseconds since the epoch, UTC\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n-    long parseMillis(String text, long instantLocal);\n+    long parseMillis(String text, long instant);\n+\n+    /**\n+     * Parses a datetime from the given text, at the given position, returning\n+     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * An initial millisecond value is passed in, which is relative to the epoch,\n+     * which can default field values.\n+     * <p>\n+     * The parse will use the given chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n+     * @param instant  initial value of instant, relative to the epoch\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return parsed value expressed in milliseconds since the epoch, UTC\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    long parseMillis(String text, long instant, Chronology chrono);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Parses a datetime from the given text, returning a new DateTime.\n-     *\n-     * @param text  text to parse\n+     * <p>\n+     * The parse will use the ISO chronology and default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n      * @return parsed value in a DateTime object\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     DateTime parseDateTime(String text);\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime.\n+     * <p>\n+     * The parse will use the given chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return parsed value in a DateTime object\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    DateTime parseDateTime(String text, Chronology chrono);\n \n     /**\n      * Parses a datetime from the given text, returning a new DateTime, using\n      * the given instant to supply field values that were not parsed.\n-     *\n-     * @param text  text to parse\n+     * <p>\n+     * The parse will use the instant's chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n      * @param instant  initial value of DateTime\n      * @return parsed value in a DateTime object\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     DateTime parseDateTime(String text, ReadableInstant instant);\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Parses a datetime from the given text, returning a new MutableDateTime.\n-     *\n-     * @param text  text to parse\n+     * <p>\n+     * The parse will use the ISO chronology and default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n      * @return parsed value in a MutableDateTime object\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     MutableDateTime parseMutableDateTime(String text);\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime.\n+     * <p>\n+     * The parse will use the given chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return parsed value in a MutableDateTime object\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    MutableDateTime parseMutableDateTime(String text, Chronology chrono);\n \n     /**\n      * Parses a datetime from the given text, returning a new MutableDateTime,\n      * using the given instant to supply field values that were not parsed.\n-     *\n-     * @param text  text to parse\n+     * <p>\n+     * The parse will use the instant's chronology and time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  the text to parse\n      * @param instant  initial value of DateTime\n      * @return parsed value in a MutableDateTime object\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     MutableDateTime parseMutableDateTime(String text, ReadableInstant instant);\n-    \n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n import java.util.Arrays;\n import java.util.Locale;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n \n /**\n+ * Internal class used to build the state during parsing.\n+ * <p>\n  * Allows fields to be saved in any order, but be physically set in a\n  * consistent order. This is useful for parsing against formats that allow\n  * field values to contradict each other.\n  * DateTimeParserBucket is mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public class DateTimeParserBucket {\n \n-    final long iMillis;\n+    private final Chronology iChrono;\n+    private final long iMillis;\n \n     // TimeZone to switch to in computeMillis. If null, use offset.\n     DateTimeZone iZone;\n     private Object iSavedState;\n \n     /**\n+     * Constucts a bucket.\n+     * \n      * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n-     */\n-    public DateTimeParserBucket(long instantLocal) {\n+     * @param chrono  the chronology to use\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono) {\n+        super();\n+        chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n-    }\n-\n+        iChrono = chrono.withUTC();\n+        setZone(chrono.getZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n+     */\n+    public Chronology getChronology() {\n+        return iChrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the time zone used by computeMillis, or null if an offset is\n      * used instead.\n         iOffset = 0;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the time zone offset used by computeMillis, unless\n      * getZone doesn't return null.\n         iZone = null;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Saves a datetime field value.\n+     * \n+     * @param field  the field, whose chronology must match that of this bucket\n+     * @param value  the value\n      */\n     public void saveField(DateTimeField field, int value) {\n         saveField(new SavedField(field, value));\n     }\n \n     /**\n+     * Saves a datetime field value.\n+     * \n+     * @param fieldType  the field type\n+     * @param value  the value\n+     */\n+    public void saveField(DateTimeFieldType fieldType, int value) {\n+        saveField(new SavedField(fieldType.getField(iChrono), value));\n+    }\n+\n+    /**\n      * Saves a datetime field text value.\n-     */\n-    public void saveField(DateTimeField field, String text, Locale locale) {\n-        saveField(new SavedField(field, text, locale));\n+     * \n+     * @param fieldType  the field type\n+     * @param text  the text value\n+     * @param locale  the locale to use\n+     */\n+    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n+        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n     }\n \n     private void saveField(SavedField field) {\n     }\n \n     /**\n-     * Computes the parsed datetime by setting the saved fields. This method is\n-     * idempotent, but it is not thread-safe.\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n      *\n      * @return milliseconds since 1970-01-01T00:00:00Z\n      * @throws IllegalArgumentException if any field is out of range\n     }\n \n     /**\n-     * Computes the parsed datetime by setting the saved fields. This method is\n-     * idempotent, but it is not thread-safe.\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n      *\n      * @param resetFields false by default, but when true, unsaved field values are cleared\n      * @return milliseconds since 1970-01-01T00:00:00Z\n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n \n /**\n  * Defines an interface for creating textual representations of datetimes.\n+ * <p>\n+ * Instances of this interface are provided by the various builder classes.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n+ * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n- * @see DateTimeFormatter\n+ * @author Stephen Colebourne\n  * @see DateTimeFormatterBuilder\n  * @see DateTimeFormat\n+ * @see ISODateTimeFormat\n  * @since 1.0\n  */\n public interface DateTimePrinter {\n-    \n-    /**\n-     * Returns the Chronology being used by the printer, or null if none.\n+\n+    /**\n+     * Returns another printer instance that can only be used with the specified chronology.\n+     * <p>\n+     * The normal DateTimePrinter is a fast implementation of printing dates\n+     * and times, well over twice as fast as the JDK. However, it is possible to\n+     * go even faster by specifying in advance the chronology to use. Note that\n+     * this optimisation should be rarely used, and only when you have identified a\n+     * performance problem.\n+     * <p>\n+     * You should only use this method if you are going to use the printer for the\n+     * returned chronology multiple times, typically storing it in an instance or\n+     * static variable. You should not use this method if you will only use the\n+     * printer once or a few times, as the setup cost will cause performance to be\n+     * worse than using an ordinary printer.\n+     * <p>\n+     * It is the callers resposibility to ensure that the printer is then only\n+     * used with instances of the correct chronology.\n      * \n-     * @return the chronology in use, may be null if none\n-     */\n-    Chronology getChronology();\n-\n-    /**\n-     * Returns the expected maximum number of characters produced. The actual\n-     * amount should rarely exceed this estimate.\n-     * \n-     * @return the estimated length\n-     */\n-    int estimatePrintedLength();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n-     * the instant.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  instant to format\n+     * @param chrono  the chronology to use, null means ISO\n+     * @return the chronology specific printer\n+     */\n+    BoundDateTimePrinter bindPrinter(Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  instant to format, null means now\n      */\n     void printTo(StringBuffer buf, ReadableInstant instant);\n \n     /**\n-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n-     * the instant.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  instant to format\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  instant to format, null means now\n      */\n     void printTo(Writer out, ReadableInstant instant) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n+     * using ISO chronology in the default DateTimeZone.\n      *\n      * @param buf  formatted instant is appended to this buffer\n      * @param instant  millis since 1970-01-01T00:00:00Z\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n+     * using ISO chronology in the default DateTimeZone.\n      *\n      * @param out  formatted instant is written out\n      * @param instant  millis since 1970-01-01T00:00:00Z\n     //-----------------------------------------------------------------------\n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * using ISO chronology in the given DateTimeZone.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  the zone to use, null means default\n      */\n     void printTo(StringBuffer buf, long instant, DateTimeZone zone);\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * using ISO chronology in the given DateTimeZone.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  the zone to use, null means default\n      */\n     void printTo(Writer out, long instant, DateTimeZone zone) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param buf  formatted instant is appended to this buffer\n-     * @param instant  millis since 1970-01-01T00:00:00Z, used by time zone printers\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n-     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n-     */\n-    void printTo(StringBuffer buf, long instant,\n-                 DateTimeZone zone, long instantLocal);\n-\n-    /**\n-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param out  formatted instant is written out\n-     * @param instant millis  since 1970-01-01T00:00:00Z, used by time zone printers\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n-     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n-     */\n-    void printTo(Writer out, long instant,\n-                 DateTimeZone zone, long instantLocal) throws IOException;\n+     * using the given Chronology.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void printTo(StringBuffer buf, long instant, Chronology chrono);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given Chronology.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void printTo(Writer out, long instant, Chronology chrono) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Prints a ReadableInstant to a new String, attempting to use the\n-     * DateTimeZone supplied by the instant.\n-     *\n-     * @param instant  instant to format\n+     * Prints a ReadableInstant to a new String, using the chronology of the instant.\n+     *\n+     * @param instant  instant to format, null means now\n      * @return the printed result\n      */\n     String print(ReadableInstant instant);\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * using the formatter's DateTimeZone.\n+     * using ISO chronology in the default zone.\n      *\n      * @param instant  millis since 1970-01-01T00:00:00Z\n      * @return the printed result\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n+     * using ISO chronology in the given zone.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param zone  the zone to use, null means default\n      * @return the printed result\n      */\n     String print(long instant, DateTimeZone zone);\n \n     /**\n      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n-     * attempting to use the given DateTimeZone.\n-     *\n-     * @param instant  millis since 1970-01-01T00:00:00Z\n-     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null\n-     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time\n-     * @return the printed result\n-     */\n-    String print(long instant, DateTimeZone zone, long instantLocal);\n-    \n+     * using the given chronology.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronoogy to use\n+     * @return the printed result\n+     */\n+    String print(long instant, Chronology chrono);\n+\n     /**\n      * Prints a ReadablePartial to a new String.\n      *\n--- a/JodaTime/src/java/org/joda/time/format/FormatUtils.java\n+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java\n  * FormatUtils is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public class FormatUtils {\n+\n     private static final double LOG_10 = Math.log(10);\n \n+    /**\n+     * Restricted constructor.\n+     */\n     private FormatUtils() {\n     }\n \n         int value = text.charAt(position) - '0';\n         return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';\n     }\n+\n+    static String createErrorMessage(final String text, final int errorPos) {\n+        int sampleLen = errorPos + 20;\n+        String sampleText;\n+        if (text.length() <= sampleLen + 3) {\n+            sampleText = text;\n+        } else {\n+            sampleText = text.substring(0, sampleLen).concat(\"...\");\n+        }\n+        \n+        if (errorPos <= 0) {\n+            return \"Invalid format: \\\"\" + sampleText + '\"';\n+        }\n+        \n+        if (errorPos >= text.length()) {\n+            return \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n+        }\n+        \n+        return \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n+            sampleText.substring(errorPos) + '\"';\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n  */\n package org.joda.time.format;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.joda.time.Chronology;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * ISODateTimeFormat provides factory methods for the ISO8601 standard.\n  */\n public class ISODateTimeFormat {\n \n-    /**\n-     * Cache that maps Chronology instances to instances.\n-     */\n-    private static Map cCache = new HashMap(7);\n-\n-    /**\n-     * Gets an instance of a format provider that uses the ISOChronology in UTC.\n+    /** The singleton instance. */\n+    private static final ISODateTimeFormat INSTANCE = new ISODateTimeFormat();\n+\n+    /**\n+     * Gets an instance of a the format provider.\n      * \n      * @return a format provider\n      */\n-    public static ISODateTimeFormat getInstanceUTC() {\n-        return getInstance(ISOChronology.getInstanceUTC());\n-    }\n-\n-    /**\n-     * Gets an instance of a format provider that uses the ISOChronology\n-     * in the default time zone.\n-     * \n-     * @return a format provider\n-     */\n     public static ISODateTimeFormat getInstance() {\n-        return getInstance(ISOChronology.getInstance());\n-    }\n-\n-    /**\n-     * Gets an instance of a format provider that uses the ISOChronology\n-     * in the specified time zone.\n-     * \n-     * @return a format provider\n-     */\n-    public static ISODateTimeFormat getInstance(final DateTimeZone zone) {\n-        return getInstance(ISOChronology.getInstance(zone));\n-    }\n-\n-    /**\n-     * Gets an instance of a format provider that uses the specified chronology.\n-     * \n-     * @param chrono  the chronology to use, null means default chronology\n-     * @return a format provider\n-     */\n-    public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstance();\n-        }\n-        ISODateTimeFormat instance = (ISODateTimeFormat)cCache.get(chrono);\n-        if (instance == null) {\n-            instance = new ISODateTimeFormat(chrono);\n-            cCache.put(chrono, instance);\n-        }\n-        return instance;\n+        return INSTANCE;\n     }\n \n     //-----------------------------------------------------------------------\n-    private final Chronology iChrono;\n-\n     private transient DateTimeFormatter\n         ye,  // year element (yyyy)\n         mye, // monthOfYear element (-MM)\n      * \n      * @param chrono  the chronology to use, must not be null\n      */\n-    private ISODateTimeFormat(final Chronology chrono) {\n-        iChrono = chrono;\n+    private ISODateTimeFormat() {\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public DateTimeParser dateParser() {\n         if (dp == null) {\n-            dp = new DateTimeFormatterBuilder(iChrono)\n+            dp = new DateTimeFormatterBuilder()\n                 .append(dateElementParser())\n                 .appendOptional\n-                (new DateTimeFormatterBuilder(iChrono)\n+                (new DateTimeFormatterBuilder()\n                  .appendLiteral('T')\n                  .append(offsetElement())\n                  .toParser())\n      */\n     public DateTimeParser dateElementParser() {\n         if (dpe == null) {\n-            dpe = new DateTimeFormatterBuilder(iChrono)\n+            dpe = new DateTimeFormatterBuilder()\n                 .append(null, new DateTimeParser[] {\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .append(yearElement())\n                     .appendOptional\n-                    (new DateTimeFormatterBuilder(iChrono)\n+                    (new DateTimeFormatterBuilder()\n                      .append(monthElement())\n                      .appendOptional(dayOfMonthElement())\n                      .toParser())\n                     .toParser(),\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .append(weekyearElement())\n                     .append(weekElement())\n                     .appendOptional(dayOfWeekElement())\n                     .toParser(),\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .append(yearElement())\n                     .append(dayOfYearElement())\n                     .toParser()\n      */\n     public DateTimeParser timeParser() {\n         if (tp == null) {\n-            tp = new DateTimeFormatterBuilder(iChrono)\n+            tp = new DateTimeFormatterBuilder()\n                 .appendOptional\n-                (new DateTimeFormatterBuilder(iChrono)\n+                (new DateTimeFormatterBuilder()\n                  .appendLiteral('T')\n                  .toParser())\n                 .append(timeElementParser())\n     public DateTimeParser timeElementParser() {\n         if (tpe == null) {\n             // Decimal point can be either '.' or ','\n-            DateTimeParser decimalPoint = new DateTimeFormatterBuilder(iChrono)\n+            DateTimeParser decimalPoint = new DateTimeFormatterBuilder()\n                 .append(null, new DateTimeParser[] {\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .appendLiteral('.')\n                     .toParser(),\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .appendLiteral(',')\n                     .toParser()\n                 })\n                 .toParser();\n \n-            tpe = new DateTimeFormatterBuilder(iChrono)\n+            tpe = new DateTimeFormatterBuilder()\n                 // time-element\n                 .append(hourElement())\n                 .append\n                 (null, new DateTimeParser[] {\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     // minute-element\n                     .append(minuteElement())\n                     .append\n                     (null, new DateTimeParser[] {\n-                        new DateTimeFormatterBuilder(iChrono)\n+                        new DateTimeFormatterBuilder()\n                         // second-element\n                         .append(secondElement())\n                         // second fraction\n-                        .appendOptional(new DateTimeFormatterBuilder(iChrono)\n+                        .appendOptional(new DateTimeFormatterBuilder()\n                                         .append(decimalPoint)\n                                         .appendFractionOfSecond(1, 9)\n                                         .toParser())\n                         .toParser(),\n                         // minute fraction\n-                        new DateTimeFormatterBuilder(iChrono)\n+                        new DateTimeFormatterBuilder()\n                         .append(decimalPoint)\n                         .appendFractionOfMinute(1, 9)\n                         .toParser(),\n                     })\n                     .toParser(),\n                     // hour fraction\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .append(decimalPoint)\n                     .appendFractionOfHour(1, 9)\n                     .toParser(),\n         if (dtp == null) {\n             // This is different from the general time parser in that the 'T'\n             // is required.\n-            DateTimeParser time = new DateTimeFormatterBuilder(iChrono)\n+            DateTimeParser time = new DateTimeFormatterBuilder()\n                 .appendLiteral('T')\n                 .append(timeElementParser())\n                 .appendOptional(offsetElement())\n                 .toParser();\n \n-            dtp = new DateTimeFormatterBuilder(iChrono)\n+            dtp = new DateTimeFormatterBuilder()\n                 .append(null, new DateTimeParser[] {\n                     time,\n-                    new DateTimeFormatterBuilder(iChrono)\n+                    new DateTimeFormatterBuilder()\n                     .append(dateElementParser())\n                     .append(null, new DateTimeParser[] {\n                         time,\n-                        new DateTimeFormatterBuilder(iChrono)\n+                        new DateTimeFormatterBuilder()\n                         .appendLiteral('T')\n                         .append(offsetElement())\n                         .toParser(),\n      */\n     public DateTimeFormatter time() {\n         if (t == null) {\n-            t = new DateTimeFormatterBuilder(iChrono)\n+            t = new DateTimeFormatterBuilder()\n                 .append(hourMinuteSecondMillis())\n                 .append(offsetElement())\n                 .toFormatter();\n      */\n     public DateTimeFormatter timeNoMillis() {\n         if (tx == null) {\n-            tx = new DateTimeFormatterBuilder(iChrono)\n+            tx = new DateTimeFormatterBuilder()\n                 .append(hourMinuteSecond())\n                 .append(offsetElement())\n                 .toFormatter();\n      */\n     public DateTimeFormatter tTime() {\n         if (tt == null) {\n-            tt = new DateTimeFormatterBuilder(iChrono)\n+            tt = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n                 .append(time())\n                 .toFormatter();\n      */\n     public DateTimeFormatter tTimeNoMillis() {\n         if (ttx == null) {\n-            ttx = new DateTimeFormatterBuilder(iChrono)\n+            ttx = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n                 .append(timeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter dateTime() {\n         if (dt == null) {\n-            dt = new DateTimeFormatterBuilder(iChrono)\n+            dt = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(tTime())\n                 .toFormatter();\n      */\n     public DateTimeFormatter dateTimeNoMillis() {\n         if (dtx == null) {\n-            dtx = new DateTimeFormatterBuilder(iChrono)\n+            dtx = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(tTimeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter weekDateTime() {\n         if (wdt == null) {\n-            wdt = new DateTimeFormatterBuilder(iChrono)\n+            wdt = new DateTimeFormatterBuilder()\n                 .append(weekDate())\n                 .append(tTime())\n                 .toFormatter();\n      */\n     public DateTimeFormatter weekDateTimeNoMillis() {\n         if (wdtx == null) {\n-            wdtx = new DateTimeFormatterBuilder(iChrono)\n+            wdtx = new DateTimeFormatterBuilder()\n                 .append(weekDate())\n                 .append(tTimeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicDate() {\n         if (bd == null) {\n-            bd = new DateTimeFormatterBuilder(iChrono)\n+            bd = new DateTimeFormatterBuilder()\n                 .appendYear(4, 4)\n                 .appendMonthOfYear(2)\n                 .appendDayOfMonth(2)\n      */\n     public DateTimeFormatter basicTime() {\n         if (bt == null) {\n-            bt = new DateTimeFormatterBuilder(iChrono)\n+            bt = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n                 .appendMinuteOfHour(2)\n                 .appendSecondOfMinute(2)\n      */\n     public DateTimeFormatter basicTimeNoMillis() {\n         if (btx == null) {\n-            btx = new DateTimeFormatterBuilder(iChrono)\n+            btx = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n                 .appendMinuteOfHour(2)\n                 .appendSecondOfMinute(2)\n      */\n     public DateTimeFormatter basicTTime() {\n         if (btt == null) {\n-            btt = new DateTimeFormatterBuilder(iChrono)\n+            btt = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n                 .append(basicTime())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicTTimeNoMillis() {\n         if (bttx == null) {\n-            bttx = new DateTimeFormatterBuilder(iChrono)\n+            bttx = new DateTimeFormatterBuilder()\n                 .append(literalTElement())\n                 .append(basicTimeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicDateTime() {\n         if (bdt == null) {\n-            bdt = new DateTimeFormatterBuilder(iChrono)\n+            bdt = new DateTimeFormatterBuilder()\n                 .append(basicDate())\n                 .append(basicTTime())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicDateTimeNoMillis() {\n         if (bdtx == null) {\n-            bdtx = new DateTimeFormatterBuilder(iChrono)\n+            bdtx = new DateTimeFormatterBuilder()\n                 .append(basicDate())\n                 .append(basicTTimeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicWeekDate() {\n         if (bwd == null) {\n-            bwd = new DateTimeFormatterBuilder(iChrono)\n+            bwd = new DateTimeFormatterBuilder()\n                 .appendWeekyear(4, 4)\n                 .appendLiteral('W')\n                 .appendWeekOfWeekyear(2)\n      */\n     public DateTimeFormatter basicWeekDateTime() {\n         if (bwdt == null) {\n-            bwdt = new DateTimeFormatterBuilder(iChrono)\n+            bwdt = new DateTimeFormatterBuilder()\n                 .append(basicWeekDate())\n                 .append(basicTTime())\n                 .toFormatter();\n      */\n     public DateTimeFormatter basicWeekDateTimeNoMillis() {\n         if (bwdtx == null) {\n-            bwdtx = new DateTimeFormatterBuilder(iChrono)\n+            bwdtx = new DateTimeFormatterBuilder()\n                 .append(basicWeekDate())\n                 .append(basicTTimeNoMillis())\n                 .toFormatter();\n      */\n     public DateTimeFormatter yearMonth() {\n         if (ym == null) {\n-            ym = new DateTimeFormatterBuilder(iChrono)\n+            ym = new DateTimeFormatterBuilder()\n                 .append(yearElement())\n                 .append(monthElement())\n                 .toFormatter();\n      */\n     public DateTimeFormatter yearMonthDay() {\n         if (ymd == null) {\n-            ymd = new DateTimeFormatterBuilder(iChrono)\n+            ymd = new DateTimeFormatterBuilder()\n                 .append(yearElement())\n                 .append(monthElement())\n                 .append(dayOfMonthElement())\n      */\n     public DateTimeFormatter weekyearWeek() {\n         if (ww == null) {\n-            ww = new DateTimeFormatterBuilder(iChrono)\n+            ww = new DateTimeFormatterBuilder()\n                 .append(weekyearElement())\n                 .append(weekElement())\n                 .toFormatter();\n      */\n     public DateTimeFormatter weekyearWeekDay() {\n         if (wwd == null) {\n-            wwd = new DateTimeFormatterBuilder(iChrono)\n+            wwd = new DateTimeFormatterBuilder()\n                 .append(weekyearElement())\n                 .append(weekElement())\n                 .append(dayOfWeekElement())\n      */\n     public DateTimeFormatter hourMinute() {\n         if (hm == null) {\n-            hm = new DateTimeFormatterBuilder(iChrono)\n+            hm = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n                 .append(minuteElement())\n                 .toFormatter();\n      */\n     public DateTimeFormatter hourMinuteSecond() {\n         if (hms == null) {\n-            hms = new DateTimeFormatterBuilder(iChrono)\n+            hms = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n                 .append(minuteElement())\n                 .append(secondElement())\n      */\n     public DateTimeFormatter hourMinuteSecondMillis() {\n         if (hmsl == null) {\n-            hmsl = new DateTimeFormatterBuilder(iChrono)\n+            hmsl = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n                 .append(minuteElement())\n                 .append(secondElement())\n      */\n     public DateTimeFormatter hourMinuteSecondFraction() {\n         if (hmsf == null) {\n-            hmsf = new DateTimeFormatterBuilder(iChrono)\n+            hmsf = new DateTimeFormatterBuilder()\n                 .append(hourElement())\n                 .append(minuteElement())\n                 .append(secondElement())\n      */\n     public DateTimeFormatter dateHour() {\n         if (dh == null) {\n-            dh = new DateTimeFormatterBuilder(iChrono)\n+            dh = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(literalTElement())\n                 .append(hour())\n      */\n     public DateTimeFormatter dateHourMinute() {\n         if (dhm == null) {\n-            dhm = new DateTimeFormatterBuilder(iChrono)\n+            dhm = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(literalTElement())\n                 .append(hourMinute())\n      */\n     public DateTimeFormatter dateHourMinuteSecond() {\n         if (dhms == null) {\n-            dhms = new DateTimeFormatterBuilder(iChrono)\n+            dhms = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(literalTElement())\n                 .append(hourMinuteSecond())\n      */\n     public DateTimeFormatter dateHourMinuteSecondMillis() {\n         if (dhmsl == null) {\n-            dhmsl = new DateTimeFormatterBuilder(iChrono)\n+            dhmsl = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(literalTElement())\n                 .append(hourMinuteSecondMillis())\n      */\n     public DateTimeFormatter dateHourMinuteSecondFraction() {\n         if (dhmsf == null) {\n-            dhmsf = new DateTimeFormatterBuilder(iChrono)\n+            dhmsf = new DateTimeFormatterBuilder()\n                 .append(date())\n                 .append(literalTElement())\n                 .append(hourMinuteSecondFraction())\n     //-----------------------------------------------------------------------\n     private DateTimeFormatter yearElement() {\n         if (ye == null) {\n-            ye = new DateTimeFormatterBuilder(iChrono)\n+            ye = new DateTimeFormatterBuilder()\n                 .appendYear(4, 9)\n                 .toFormatter();\n         }\n \n     private DateTimeFormatter monthElement() {\n         if (mye == null) {\n-            mye = new DateTimeFormatterBuilder(iChrono)\n+            mye = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n                 .appendMonthOfYear(2)\n                 .toFormatter();\n \n     private DateTimeFormatter dayOfMonthElement() {\n         if (dme == null) {\n-            dme = new DateTimeFormatterBuilder(iChrono)\n+            dme = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n                 .appendDayOfMonth(2)\n                 .toFormatter();\n \n     private DateTimeFormatter weekyearElement() {\n         if (we == null) {\n-            we = new DateTimeFormatterBuilder(iChrono)\n+            we = new DateTimeFormatterBuilder()\n                 .appendWeekyear(4, 9)\n                 .toFormatter();\n         }\n \n     private DateTimeFormatter weekElement() {\n         if (wwe == null) {\n-            wwe = new DateTimeFormatterBuilder(iChrono)\n+            wwe = new DateTimeFormatterBuilder()\n                 .appendLiteral(\"-W\")\n                 .appendWeekOfWeekyear(2)\n                 .toFormatter();\n \n     private DateTimeFormatter dayOfWeekElement() {\n         if (dwe == null) {\n-            dwe = new DateTimeFormatterBuilder(iChrono)\n+            dwe = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n                 .appendDayOfWeek(1)\n                 .toFormatter();\n \n     private DateTimeFormatter dayOfYearElement() {\n         if (dye == null) {\n-            dye = new DateTimeFormatterBuilder(iChrono)\n+            dye = new DateTimeFormatterBuilder()\n                 .appendLiteral('-')\n                 .appendDayOfYear(3)\n                 .toFormatter();\n     \n     private DateTimeFormatter literalTElement() {\n         if (lte == null) {\n-            lte = new DateTimeFormatterBuilder(iChrono)\n+            lte = new DateTimeFormatterBuilder()\n                 .appendLiteral('T')\n                 .toFormatter();\n         }\n \n     private DateTimeFormatter hourElement() {\n         if (hde == null) {\n-            hde = new DateTimeFormatterBuilder(iChrono)\n+            hde = new DateTimeFormatterBuilder()\n                 .appendHourOfDay(2)\n                 .toFormatter();\n         }\n \n     private DateTimeFormatter minuteElement() {\n         if (mhe == null) {\n-            mhe = new DateTimeFormatterBuilder(iChrono)\n+            mhe = new DateTimeFormatterBuilder()\n                 .appendLiteral(':')\n                 .appendMinuteOfHour(2)\n                 .toFormatter();\n \n     private DateTimeFormatter secondElement() {\n         if (sme == null) {\n-            sme = new DateTimeFormatterBuilder(iChrono)\n+            sme = new DateTimeFormatterBuilder()\n                 .appendLiteral(':')\n                 .appendSecondOfMinute(2)\n                 .toFormatter();\n \n     private DateTimeFormatter millisElement() {\n         if (lse == null) {\n-            lse = new DateTimeFormatterBuilder(iChrono)\n+            lse = new DateTimeFormatterBuilder()\n                 .appendLiteral('.')\n                 .appendMillisOfSecond(3)\n                 .toFormatter();\n \n     private DateTimeFormatter fractionElement() {\n         if (fse == null) {\n-            fse = new DateTimeFormatterBuilder(iChrono)\n+            fse = new DateTimeFormatterBuilder()\n                 .appendLiteral('.')\n                 // Support parsing up to nanosecond precision even though\n                 // those extra digits will be dropped.\n \n     private DateTimeFormatter offsetElement() {\n         if (ze == null) {\n-            ze = new DateTimeFormatterBuilder(iChrono)\n+            ze = new DateTimeFormatterBuilder()\n                 .appendTimeZoneOffset(\"Z\", true, 2, 4)\n                 .toFormatter();\n         }\n--- a/JodaTime/src/java/org/joda/time/format/ISOPeriodFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISOPeriodFormat.java\n  * returns are as well.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see PeriodFormat\n  * @see PeriodFormatterBuilder\n  */\n public class ISOPeriodFormat {\n+\n     private static final ISOPeriodFormat INSTANCE = new ISOPeriodFormat();\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatter.java\n  * Combined interface for printing and parsing.\n  * <p>\n  * See each extended interface for details of the methods.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BasePeriodFormatter}.\n+ * All implementations must extend <code>BasePeriodFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n  * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n  * formatters that it builds are thread-safe and immutable.\n  *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n  * @see PeriodFormat\n- * @author Brian S O'Neill\n  */\n public class PeriodFormatterBuilder {\n     private static final int PRINT_ZERO_RARELY_FIRST = 1;\n         int size = formatters.size();\n         if (size >= 1 && formatters.get(0) instanceof Separator) {\n             Separator sep = (Separator) formatters.get(0);\n-            return sep.finish(toFormatter(formatters.subList(1, size)));\n-        }\n-        return createComposite(formatters);\n+            return sep.finish((BasePeriodFormatter) toFormatter(formatters.subList(1, size)));\n+        }\n+        return (PeriodFormatter) createComposite(formatters);\n     }\n \n     /**\n      *\n      * @return this PeriodFormatterBuilder\n      */\n-    public PeriodFormatterBuilder append(PeriodFormatter formatter)\n-        throws IllegalArgumentException\n-    {\n+    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n         if (formatter == null) {\n             throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        if (formatter instanceof BasePeriodFormatter == false) {\n+            throw new IllegalArgumentException(\"Formatter must extend BasePeriodFormatter\");\n         }\n         clearPrefix();\n         iFormatters.add(formatter);\n         if (lastSeparator != null && formatters.size() == 0) {\n             throw new IllegalStateException(\"Cannot have two adjacent separators\");\n         } else {\n-            PeriodFormatter composite = createComposite(formatters);\n+            BasePeriodFormatter composite = createComposite(formatters);\n             formatters.clear();\n             formatters.add(new Separator(text, finalText, composite, useBefore, useAfter));\n         }\n         iPrefix = null;\n     }\n \n-    private static PeriodFormatter createComposite(List formatters) {\n+    private static BasePeriodFormatter createComposite(List formatters) {\n         switch (formatters.size()) {\n             case 0:\n                 return Literal.EMPTY;\n             case 1:\n-                return (PeriodFormatter) formatters.get(0);\n+                return (BasePeriodFormatter) formatters.get(0);\n             default:\n                 return new Composite(formatters);\n         }\n      * Defines a formatted field's prefix or suffix text.\n      * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n      */\n-    private static interface PeriodFieldAffix {\n+    static interface PeriodFieldAffix {\n         int calculatePrintedLength(int value);\n         \n         void printTo(StringBuffer buf, int value);\n     /**\n      * Implements an affix where the text does not vary by the amount.\n      */\n-    private static final class SimpleAffix implements PeriodFieldAffix {\n+    static class SimpleAffix implements PeriodFieldAffix {\n         private final String iText;\n \n         SimpleAffix(String text) {\n      * Implements an affix where the text varies by the amount of the field.\n      * Only singular (1) and plural (not 1) are supported.\n      */\n-    private static final class PluralAffix implements PeriodFieldAffix {\n+    static class PluralAffix implements PeriodFieldAffix {\n         private final String iSingularText;\n         private final String iPluralText;\n \n     /**\n      * Builds a composite affix by merging two other affix implementations.\n      */\n-    private static final class CompositeAffix implements PeriodFieldAffix {\n+    static class CompositeAffix implements PeriodFieldAffix {\n         private final PeriodFieldAffix iLeft;\n         private final PeriodFieldAffix iRight;\n \n     /**\n      * Formats the numeric value of a field, potentially with prefix/suffix.\n      */\n-    private static final class FieldFormatter extends AbstractPeriodFormatter\n-        implements PeriodFormatter\n-    {\n+    static class FieldFormatter\n+            extends BasePeriodFormatter\n+            implements PeriodFormatter {\n         private final int iMinPrintedDigits;\n         private final int iPrintZeroSetting;\n         private final int iMaxParsedDigits;\n     /**\n      * Handles a simple literal piece of text.\n      */\n-    private static final class Literal extends AbstractPeriodFormatter\n-        implements PeriodFormatter\n-    {\n+    static class Literal\n+            extends BasePeriodFormatter\n+            implements PeriodFormatter {\n         static final Literal EMPTY = new Literal(\"\");\n         private final String iText;\n \n      * Handles a separator, that splits the fields into multiple parts.\n      * For example, the 'T' in the ISO8601 standard.\n      */\n-    private static final class Separator extends AbstractPeriodFormatter\n-        implements PeriodFormatter\n-    {\n+    static class Separator\n+            extends BasePeriodFormatter\n+            implements PeriodFormatter {\n         private final String iText;\n         private final String iFinalText;\n \n         private final boolean iUseBefore;\n         private final boolean iUseAfter;\n \n-        private PeriodFormatter iBefore;\n-        private PeriodFormatter iAfter;\n-\n-        Separator(String text, String finalText, PeriodFormatter before, boolean useBefore, boolean useAfter) {\n+        private BasePeriodFormatter iBefore;\n+        private BasePeriodFormatter iAfter;\n+\n+        Separator(String text, String finalText, BasePeriodFormatter before, boolean useBefore, boolean useAfter) {\n             iText = text;\n             iFinalText = finalText;\n             iBefore = before;\n         }\n \n         public int calculatePrintedLength(ReadablePeriod period) {\n-            PeriodPrinter before = iBefore;\n-            PeriodPrinter after = iAfter;\n+            BasePeriodFormatter before = iBefore;\n+            BasePeriodFormatter after = iAfter;\n             \n             int sum = before.calculatePrintedLength(period)\n                     + after.calculatePrintedLength(period);\n         }\n \n         public void printTo(StringBuffer buf, ReadablePeriod period) {\n-            PeriodPrinter before = iBefore;\n-            PeriodPrinter after = iAfter;\n+            BasePeriodFormatter before = iBefore;\n+            BasePeriodFormatter after = iAfter;\n             \n             before.printTo(buf, period);\n             if (iUseBefore) {\n         }\n \n         public void printTo(Writer out, ReadablePeriod period) throws IOException {\n-            PeriodPrinter before = iBefore;\n-            PeriodPrinter after = iAfter;\n+            BasePeriodFormatter before = iBefore;\n+            BasePeriodFormatter after = iAfter;\n             \n             before.printTo(out, period);\n             if (iUseBefore) {\n             return position;\n         }\n \n-        Separator finish(PeriodFormatter after) {\n+        Separator finish(BasePeriodFormatter after) {\n             iAfter = after;\n             return this;\n         }\n     /**\n      * Composite implementation that merges other fields to create a full pattern.\n      */\n-    private static final class Composite extends AbstractPeriodFormatter\n-        implements PeriodFormatter\n-    {\n-        private final PeriodFormatter[] iFormatters;\n+    static class Composite\n+            extends BasePeriodFormatter\n+            implements PeriodFormatter {\n+        \n+        private final BasePeriodFormatter[] iFormatters;\n \n         Composite(List formatters) {\n-            iFormatters = (PeriodFormatter[])formatters.toArray\n-                (new PeriodFormatter[formatters.size()]);\n+            iFormatters = (BasePeriodFormatter[]) formatters.toArray(\n+                new BasePeriodFormatter[formatters.size()]);\n         }\n \n         public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n             int sum = 0;\n-            PeriodPrinter[] printers = iFormatters;\n+            BasePeriodFormatter[] printers = iFormatters;\n             for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                 sum += printers[i].countFieldsToPrint(period);\n             }\n \n         public int calculatePrintedLength(ReadablePeriod period) {\n             int sum = 0;\n-            PeriodPrinter[] printers = iFormatters;\n+            BasePeriodFormatter[] printers = iFormatters;\n             for (int i=printers.length; --i>=0; ) {\n                 sum += printers[i].calculatePrintedLength(period);\n             }\n         }\n \n         public void printTo(StringBuffer buf, ReadablePeriod period) {\n-            PeriodPrinter[] printers = iFormatters;\n+            BasePeriodFormatter[] printers = iFormatters;\n             int len = printers.length;\n             for (int i=0; i<len; i++) {\n                 printers[i].printTo(buf, period);\n         }\n \n         public void printTo(Writer out, ReadablePeriod period) throws IOException {\n-            PeriodPrinter[] printers = iFormatters;\n+            BasePeriodFormatter[] printers = iFormatters;\n             int len = printers.length;\n             for (int i=0; i<len; i++) {\n                 printers[i].printTo(out, period);\n \n         public int parseInto(ReadWritablePeriod period,\n                              String periodStr, int position) {\n-            PeriodParser[] parsers = iFormatters;\n-\n+            BasePeriodFormatter[] parsers = iFormatters;\n             if (parsers == null) {\n                 throw new UnsupportedOperationException();\n             }\n--- a/JodaTime/src/java/org/joda/time/format/PeriodParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodParser.java\n \n /**\n  * Defines an interface for parsing textual representations of time periods.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BasePeriodFormatter}.\n+ * All implementations must extend <code>BasePeriodFormatter</code>.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see PeriodFormatter\n  * @see PeriodFormatterBuilder\n  * @see PeriodFormat\n- * @since 1.0\n  */\n public interface PeriodParser {\n \n--- a/JodaTime/src/java/org/joda/time/format/PeriodPrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodPrinter.java\n \n /**\n  * Defines an interface for creating textual representations of time periods.\n+ * <p>\n+ * Note: This interface represents a view onto {@link BasePeriodFormatter}.\n+ * All implementations must extend <code>BasePeriodFormatter</code>.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see PeriodFormatter\n  * @see PeriodFormatterBuilder\n  * @see PeriodFormat\n- * @since 1.0\n  */\n public interface PeriodPrinter {\n \n-    /**\n-     * Returns the amount of fields from the given period that this printer\n-     * will print.\n-     * \n-     * @param period  the period to use\n-     * @return amount of fields printed\n-     */\n-    int countFieldsToPrint(ReadablePeriod period);\n-\n-    /**\n-     * Returns the amount of fields from the given period that this printer\n-     * will print.\n-     * \n-     * @param period  the period to use\n-     * @param stopAt stop counting at this value\n-     * @return amount of fields printed\n-     */\n-    int countFieldsToPrint(ReadablePeriod period, int stopAt);\n-\n-    /**\n-     * Returns the exact number of characters produced for the given period.\n-     * \n-     * @param period  the period to use\n-     * @return the estimated length\n-     */\n-    int calculatePrintedLength(ReadablePeriod period);\n-\n-    //-----------------------------------------------------------------------\n     /**\n      * Prints a ReadablePeriod to a StringBuffer.\n      *\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n     }\n \n     static int parseTime(String str) {\n-        DateTimeParser p = ISODateTimeFormat\n-            .getInstance(getLenientISOChronology())\n-            .hourMinuteSecondFraction();\n+        DateTimeParser p = ISODateTimeFormat.getInstance().hourMinuteSecondFraction();\n         MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n         int pos = 0;\n         if (str.startsWith(\"-\")) {\n--- a/JodaTime/src/test/org/joda/time/format/TestPeriodFormatterBuilder.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestPeriodFormatterBuilder.java\n     public void testFormatYears() {\n         PeriodFormatter f = builder.appendYears().toFormatter();\n         assertEquals(\"1\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatMonths() {\n         PeriodFormatter f = builder.appendMonths().toFormatter();\n         assertEquals(\"2\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatWeeks() {\n         PeriodFormatter f = builder.appendWeeks().toFormatter();\n         assertEquals(\"3\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatDays() {\n         PeriodFormatter f = builder.appendDays().toFormatter();\n         assertEquals(\"4\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatHours() {\n         PeriodFormatter f = builder.appendHours().toFormatter();\n         assertEquals(\"5\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatMinutes() {\n         PeriodFormatter f = builder.appendMinutes().toFormatter();\n         assertEquals(\"6\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSeconds() {\n         PeriodFormatter f = builder.appendSeconds().toFormatter();\n         assertEquals(\"7\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSecondsWithMillis() {\n         PeriodFormatter f = builder.appendSecondsWithMillis().toFormatter();\n         Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);\n         assertEquals(\"7.000\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1);\n         assertEquals(\"7.001\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 999);\n         assertEquals(\"7.999\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);\n         assertEquals(\"8.000\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);\n         assertEquals(\"8.001\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, -1);\n         assertEquals(\"6.999\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, -7, 1);\n         assertEquals(\"-6.999\", f.print(p));\n-        assertEquals(6, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, -7, -1);\n         assertEquals(\"-7.001\", f.print(p));\n-        assertEquals(6, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n     }\n \n     public void testFormatSecondsWithOptionalMillis() {\n         PeriodFormatter f = builder.appendSecondsWithOptionalMillis().toFormatter();\n         Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);\n         assertEquals(\"7\", f.print(p));\n-        assertEquals(1, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1);\n         assertEquals(\"7.001\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 999);\n         assertEquals(\"7.999\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);\n         assertEquals(\"8\", f.print(p));\n-        assertEquals(1, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);\n         assertEquals(\"8.001\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, 7, -1);\n         assertEquals(\"6.999\", f.print(p));\n-        assertEquals(5, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, -7, 1);\n         assertEquals(\"-6.999\", f.print(p));\n-        assertEquals(6, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n         \n         p = new Period(0, 0, 0, 0, 0, 0, -7, -1);\n         assertEquals(\"-7.001\", f.print(p));\n-        assertEquals(6, f.calculatePrintedLength(p));\n-        assertEquals(1, f.countFieldsToPrint(p));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(p));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(p));\n     }\n \n     public void testFormatMillis() {\n         PeriodFormatter f = builder.appendMillis().toFormatter();\n         assertEquals(\"8\", f.print(PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatMillis3Digit() {\n         PeriodFormatter f = builder.appendMillis3Digit().toFormatter();\n         assertEquals(\"008\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormatPrefixSimple1() {\n         PeriodFormatter f = builder.appendPrefix(\"Years:\").appendYears().toFormatter();\n         assertEquals(\"Years:1\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatPrefixSimple2() {\n         PeriodFormatter f = builder.appendPrefix(\"Hours:\").appendHours().toFormatter();\n         assertEquals(\"Hours:5\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatPrefixSimple3() {\n     public void testFormatPrefixPlural1() {\n         PeriodFormatter f = builder.appendPrefix(\"Year:\", \"Years:\").appendYears().toFormatter();\n         assertEquals(\"Year:1\", f.print(PERIOD));\n-        assertEquals(6, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatPrefixPlural2() {\n         PeriodFormatter f = builder.appendPrefix(\"Hour:\", \"Hours:\").appendHours().toFormatter();\n         assertEquals(\"Hours:5\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatPrefixPlural3() {\n     public void testFormatSuffixSimple1() {\n         PeriodFormatter f = builder.appendYears().appendSuffix(\" years\").toFormatter();\n         assertEquals(\"1 years\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSuffixSimple2() {\n         PeriodFormatter f = builder.appendHours().appendSuffix(\" hours\").toFormatter();\n         assertEquals(\"5 hours\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSuffixSimple3() {\n     public void testFormatSuffixPlural1() {\n         PeriodFormatter f = builder.appendYears().appendSuffix(\" year\", \" years\").toFormatter();\n         assertEquals(\"1 year\", f.print(PERIOD));\n-        assertEquals(6, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(6, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSuffixPlural2() {\n         PeriodFormatter f = builder.appendHours().appendSuffix(\" hour\", \" hours\").toFormatter();\n         assertEquals(\"5 hours\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatSuffixPlural3() {\n     public void testFormatPrefixSuffix() {\n         PeriodFormatter f = builder.appendPrefix(\"P\").appendYears().appendSuffix(\"Y\").toFormatter();\n         assertEquals(\"P1Y\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormatSeparatorSimple() {\n         PeriodFormatter f = builder.appendYears().appendSeparator(\"T\").appendHours().toFormatter();\n         assertEquals(\"1T5\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"5\", f.print(TIME_PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(TIME_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(TIME_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(TIME_PERIOD));\n         \n         assertEquals(\"1\", f.print(DATE_PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(DATE_PERIOD));\n     }\n \n     public void testFormatSeparatorComplex() {\n             .appendMinutes().appendSeparator(\", \", \" and \")\n             .toFormatter();\n         assertEquals(\"1, 5 and 6\", f.print(PERIOD));\n-        assertEquals(10, f.calculatePrintedLength(PERIOD));\n-        assertEquals(3, f.countFieldsToPrint(PERIOD));\n+        assertEquals(10, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"5 and 6\", f.print(TIME_PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(TIME_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(TIME_PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(TIME_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(TIME_PERIOD));\n         \n         assertEquals(\"1\", f.print(DATE_PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(DATE_PERIOD));\n     }\n \n     public void testFormatSeparatorIfFieldsAfter() {\n         PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsAfter(\"T\").appendHours().toFormatter();\n         assertEquals(\"1T5\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"T5\", f.print(TIME_PERIOD));\n-        assertEquals(2, f.calculatePrintedLength(TIME_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).calculatePrintedLength(TIME_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(TIME_PERIOD));\n         \n         assertEquals(\"1\", f.print(DATE_PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(DATE_PERIOD));\n     }\n \n     public void testFormatSeparatorIfFieldsBefore() {\n         PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsBefore(\"T\").appendHours().toFormatter();\n         assertEquals(\"1T5\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"5\", f.print(TIME_PERIOD));\n-        assertEquals(1, f.calculatePrintedLength(TIME_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).calculatePrintedLength(TIME_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(TIME_PERIOD));\n         \n         assertEquals(\"1T\", f.print(DATE_PERIOD));\n-        assertEquals(2, f.calculatePrintedLength(DATE_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).calculatePrintedLength(DATE_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(DATE_PERIOD));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFormatLiteral() {\n         PeriodFormatter f = builder.appendLiteral(\"HELLO\").toFormatter();\n         assertEquals(\"HELLO\", f.print(PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(PERIOD));\n-        assertEquals(0, f.countFieldsToPrint(PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(0, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatAppendFormatter() {\n         PeriodFormatter base = builder.appendYears().appendLiteral(\"-\").toFormatter();\n         PeriodFormatter f = new PeriodFormatterBuilder().append(base).appendYears().toFormatter();\n         assertEquals(\"1-1\", f.print(PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     public void testFormatMinDigits() {\n         PeriodFormatter f = new PeriodFormatterBuilder().minimumPrintedDigits(4).appendYears().toFormatter();\n         assertEquals(\"0001\", f.print(PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n     }\n \n     //-----------------------------------------------------------------------\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"---0\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"---0\", f.print(EMPTY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n         \n         // test only last instance of same field is output\n         f = new PeriodFormatterBuilder()\n                 .appendYears().appendLiteral(\"-\")\n                 .appendYears().toFormatter();\n         assertEquals(\"-0\", f.print(EMPTY_PERIOD));\n-        assertEquals(2, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n     public void testFormatPrintZeroRarelyLast() {\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"---0\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"---0\", f.print(EMPTY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n     public void testFormatPrintZeroRarelyFirst() {\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"0---\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"0---\", f.print(EMPTY_PERIOD));\n-        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(1, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n     public void testFormatPrintZeroIfSupported() {\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"0---0\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"0-0-0-0\", f.print(EMPTY_PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n     public void testFormatPrintZeroAlways() {\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"0-0-0-0\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1-0-0-4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"0-0-0-0\", f.print(EMPTY_PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n     public void testFormatPrintZeroNever() {\n                 .appendWeeks().appendLiteral(\"-\")\n                 .appendDays().toFormatter();\n         assertEquals(\"1-2-3-4\", f.print(PERIOD));\n-        assertEquals(7, f.calculatePrintedLength(PERIOD));\n-        assertEquals(4, f.countFieldsToPrint(PERIOD));\n+        assertEquals(7, ((BasePeriodFormatter) f).calculatePrintedLength(PERIOD));\n+        assertEquals(4, ((BasePeriodFormatter) f).countFieldsToPrint(PERIOD));\n         \n         assertEquals(\"---\", f.print(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n-        assertEquals(0, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));\n+        assertEquals(0, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));\n         \n         assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n-        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));\n-        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));\n+        assertEquals(5, ((BasePeriodFormatter) f).calculatePrintedLength(YEAR_DAY_PERIOD));\n+        assertEquals(2, ((BasePeriodFormatter) f).countFieldsToPrint(YEAR_DAY_PERIOD));\n         \n         assertEquals(\"---\", f.print(EMPTY_PERIOD));\n-        assertEquals(3, f.calculatePrintedLength(EMPTY_PERIOD));\n-        assertEquals(0, f.countFieldsToPrint(EMPTY_PERIOD));\n+        assertEquals(3, ((BasePeriodFormatter) f).calculatePrintedLength(EMPTY_PERIOD));\n+        assertEquals(0, ((BasePeriodFormatter) f).countFieldsToPrint(EMPTY_PERIOD));\n     }\n \n }", "timestamp": 1099004195, "metainfo": ""}