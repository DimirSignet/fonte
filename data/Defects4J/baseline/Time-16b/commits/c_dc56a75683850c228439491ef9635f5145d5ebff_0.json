{"sha": "dc56a75683850c228439491ef9635f5145d5ebff", "log": "Adjust final methods   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n         }\n     }\n \n-    /**\n-     * Extracts the end millis from an instant ensuring that the millis matches the\n-     * start if both are null.\n-     * \n-     * @param end  the end instant\n-     * @param start  the start instant\n-     * @param startMillis  the start millis, which will be now if start is null\n-     * @return the end millis\n-     */\n-    protected long getEndInstantMillis(ReadableInstant end, ReadableInstant start, long startMillis) {\n-        if (end == null) {\n-            if (start == null) {\n-                return startMillis;\n-            } else {\n-                return DateTimeUtils.currentTimeMillis();\n-            }\n-        } else {\n-            return end.getMillis();\n-        }\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the start of this time interval, which is inclusive, as an Instant.\n      *\n      * @return the start of the time interval\n      */\n-    public Instant getStartInstant() {\n+    public final Instant getStartInstant() {\n         return new Instant(getStartMillis());\n     }\n \n      *\n      * @return the end of the time interval\n      */\n-    public Instant getEndInstant() {\n+    public final Instant getEndInstant() {\n         return new Instant(getEndMillis());\n     }\n \n      * @return the duration of the time interval in milliseconds\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public long getDurationMillis() {\n+    public final long getDurationMillis() {\n         return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n     }\n \n      * @return the duration of the time interval\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public Duration getDuration() {\n+    public final Duration getDuration() {\n         long durMillis = getDurationMillis();\n         if (durMillis == 0) {\n             return Duration.ZERO;\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval contains the millisecond\n      */\n-    public boolean contains(long millisInstant) {\n+    public final boolean contains(long millisInstant) {\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n         return (millisInstant >= thisStart && millisInstant < thisEnd);\n      * \n      * @return true if this time interval contains the current instant\n      */\n-    public boolean containsNow() {\n+    public final boolean containsNow() {\n         return contains(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n      */\n-    public boolean contains(ReadableInstant instant) {\n+    public final boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n             return contains(DateTimeUtils.currentTimeMillis());\n         }\n      * @return true if this time interval contains the time interval\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public boolean contains(ReadableInterval interval) {\n+    public final boolean contains(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      * @return true if the time intervals overlap\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public boolean overlaps(ReadableInterval interval) {\n+    public final boolean overlaps(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is before the instant\n      */\n-    public boolean isBefore(long millisInstant) {\n+    public final boolean isBefore(long millisInstant) {\n         return (getEndMillis() <= millisInstant);\n     }\n \n      * \n      * @return true if this time interval is before the current instant\n      */\n-    public boolean isBeforeNow() {\n+    public final boolean isBeforeNow() {\n         return isBefore(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is before the instant\n      */\n-    public boolean isBefore(ReadableInstant instant) {\n+    public final boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n             return isBefore(DateTimeUtils.currentTimeMillis());\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is after the instant\n      */\n-    public boolean isAfter(long millisInstant) {\n+    public final boolean isAfter(long millisInstant) {\n         return (getStartMillis() > millisInstant);\n     }\n \n      * \n      * @return true if this time interval is after the current instant\n      */\n-    public boolean isAfterNow() {\n+    public final boolean isAfterNow() {\n         return isAfter(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is after the instant\n      */\n-    public boolean isAfter(ReadableInstant instant) {\n+    public final boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n             return isAfter(DateTimeUtils.currentTimeMillis());\n         }\n      *\n      * @return the interval as an Interval object\n      */\n-    public Interval toInterval() {\n+    public final Interval toInterval() {\n         if (this instanceof Interval) {\n             return (Interval) this;\n         }\n      *\n      * @return the time interval as a MutableInterval object\n      */\n-    public MutableInterval toMutableInterval() {\n+    public final MutableInterval toMutableInterval() {\n         return new MutableInterval(getStartMillis(), getEndMillis());\n     }\n \n      *\n      * @return a time period derived from the interval\n      */\n-    public Period toPeriod() {\n+    public final Period toPeriod() {\n         return new Period(getStartMillis(), getEndMillis());\n     }\n \n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public Period toPeriod(PeriodType type) {\n+    public final Period toPeriod(PeriodType type) {\n         return new Period(getStartMillis(), getEndMillis(), type);\n     }\n \n      * @param readableInterval  a readable interval to check against\n      * @return true if the start and end millis are equal\n      */\n-    public boolean equals(Object readableInterval) {\n+    public final boolean equals(Object readableInterval) {\n         if (this == readableInterval) {\n             return true;\n         }\n      *\n      * @return suitable hashcode\n      */\n-    public int hashCode() {\n+    public final int hashCode() {\n         long start = getStartMillis();\n         long end = getEndMillis();\n         int result = 97;\n      *\n      * @return re-parsable string\n      */\n-    public String toString() {\n+    public final String toString() {\n         DateTimePrinter printer =\n             ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())\n             .dateHourMinuteSecondFraction();\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n     /** The end of the period */\n     private final long iEndMillis;\n \n-    /** The cached duration */\n-    private transient Duration iDuration;\n-\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n      */\n     public Interval(ReadableInstant start, ReadableInstant end) {\n         super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        iEndMillis = getEndInstantMillis(end, start, iStartMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        if (start == null && end == null) {\n+            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iStartMillis = DateTimeUtils.getInstantMillis(start);\n+            iEndMillis = DateTimeUtils.getInstantMillis(end);\n+            checkInterval(iStartMillis, iEndMillis);\n+        }\n     }\n \n     /**\n         iStartMillis = DateTimeUtils.getInstantMillis(start);\n         long durationMillis = DateTimeUtils.getDurationMillis(duration);\n         iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n-        if (duration instanceof Duration) {\n-            iDuration = (Duration) duration;\n-        }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n \n         iEndMillis = DateTimeUtils.getInstantMillis(end);\n         long durationMillis = DateTimeUtils.getDurationMillis(duration);\n         iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n-        if (duration instanceof Duration) {\n-            iDuration = (Duration) duration;\n-        }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the duration of this interval.\n-     * <p>\n-     * Where possible, this implementation reuses the same <code>Duration</code> object.\n-     *\n-     * @return the duration of the interval\n-     */\n-    public final Duration getDuration() {\n-        if (iDuration == null) {\n-            iDuration = super.getDuration();\n-        }\n-        return iDuration;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    // Protect against malicious subclasses, ensuring this class is immutable\n-    //-----------------------------------------------------------------------\n-    protected final void checkInterval(long start, long end) {\n-        super.checkInterval(start, end);\n-    }\n-\n-    protected final long getEndInstantMillis(ReadableInstant end, ReadableInstant start, long startMillis) {\n-        return super.getEndInstantMillis(end, start, startMillis);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final long getDurationMillis() {\n-        return super.getDurationMillis();\n-    }\n-\n-    public final Instant getStartInstant() {\n-        return super.getStartInstant();\n-    }\n-\n-    public final Instant getEndInstant() {\n-        return super.getEndInstant();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final boolean contains(long millisInstant) {\n-        return super.contains(millisInstant);\n-    }\n-\n-    public final boolean containsNow() {\n-        return super.containsNow();\n-    }\n-\n-    public final boolean contains(ReadableInstant instant) {\n-        return super.contains(instant);\n-    }\n-\n-    public final boolean contains(ReadableInterval interval) {\n-        return super.contains(interval);\n-    }\n-\n-    public final boolean overlaps(ReadableInterval interval) {\n-        return super.overlaps(interval);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final boolean equals(Object readableInterval) {\n-        return super.equals(readableInterval);\n-    }\n-\n-    public final int hashCode() {\n-        return super.hashCode();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final boolean isAfter(long millisInstant) {\n-        return super.isAfter(millisInstant);\n-    }\n-\n-    public final boolean isAfterNow() {\n-        return super.isAfterNow();\n-    }\n-\n-    public final boolean isAfter(ReadableInstant instant) {\n-        return super.isAfter(instant);\n-    }\n-\n-    public final boolean isBefore(long millisInstant) {\n-        return super.isBefore(millisInstant);\n-    }\n-\n-    public final boolean isBeforeNow() {\n-        return super.isBeforeNow();\n-    }\n-\n-    public final boolean isBefore(ReadableInstant instant) {\n-        return super.isBefore(instant);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final Interval toInterval() {\n-        return super.toInterval();\n-    }\n-\n-    public final MutableInterval toMutableInterval() {\n-        return super.toMutableInterval();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final Period toPeriod() {\n-        return super.toPeriod();\n-    }\n-\n-    public final Period toPeriod(PeriodType type) {\n-        return super.toPeriod(type);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public final String toString() {\n-        return super.toString();\n+     * Creates a new interval with the specified start millisecond instant.\n+     *\n+     * @param startInstant  the start instant for the new interval\n+     * @return an interval with the end from this interval and the specified start\n+     */\n+    public final Interval withStartMillis(long startInstant) {\n+        if (startInstant == getStartMillis()) {\n+            return this;\n+        }\n+        return new Interval(startInstant, getEndMillis());\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start instant.\n+     *\n+     * @param start  the start instant for the new interval, null means now\n+     * @return an interval with the end from this interval and the specified start\n+     */\n+    public final Interval withStartInstant(ReadableInstant start) {\n+        long startMillis = DateTimeUtils.getInstantMillis(start);\n+        return withStartMillis(startMillis);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start millisecond instant.\n+     *\n+     * @param endInstant  the end instant for the new interval\n+     * @return an interval with the start from this interval and the specified end\n+     */\n+    public final Interval withEndMillis(long endInstant) {\n+        if (endInstant == getEndMillis()) {\n+            return this;\n+        }\n+        return new Interval(getStartMillis(), endInstant);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start instant.\n+     *\n+     * @param end  the end instant for the new interval, null means now\n+     * @return an interval with the start from this interval and the specified end\n+     */\n+    public final Interval withEndInstant(ReadableInstant end) {\n+        long endMillis = DateTimeUtils.getInstantMillis(end);\n+        return withEndMillis(endMillis);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n      */\n     public MutableInterval(ReadableInstant start, ReadableInstant end) {\n         super();\n-        iStartMillis = DateTimeUtils.getInstantMillis(start);\n-        iEndMillis = getEndInstantMillis(end, start, iStartMillis);\n-        checkInterval(iStartMillis, iEndMillis);\n+        if (start == null && end == null) {\n+            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iStartMillis = DateTimeUtils.getInstantMillis(start);\n+            iEndMillis = DateTimeUtils.getInstantMillis(end);\n+            checkInterval(iStartMillis, iEndMillis);\n+        }\n     }\n \n     /**\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setInterval(ReadableInstant start, ReadableInstant end) {\n-        long startMillis = DateTimeUtils.getInstantMillis(start);\n-        long endMillis = getEndInstantMillis(end, start, iStartMillis);\n-        setInterval(startMillis, endMillis);\n+        if (start == null && end == null) {\n+            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(start);\n+            long endMillis = DateTimeUtils.getInstantMillis(end);\n+            setInterval(startMillis, endMillis);\n+        }\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1092517413, "metainfo": ""}