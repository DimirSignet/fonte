{"sha": "194de43297ee92161aef886025d5aeba42db637e", "log": "Removed those pesky getDateOnlyMillis and getTimeOnlyMillis methods.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n     Chronology withZone(DateTimeZone zone);\n \n     /**\n-     * Returns a date-only millisecond instant, by clearing the time fields\n-     * from the given instant.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>dayOfYear().roundFloor(instant)</code>.\n-     * \n-     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n-     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part\n-     * cleared\n-     */\n-    long getDateOnlyMillis(long instant);\n-\n-    /**\n-     * Returns a date-only millisecond instant, formed from the given year,\n-     * month, and day values. The set of given values must refer to a valid\n-     * date, or else an IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.\n-     *\n-     * @param year year to use\n-     * @param monthOfYear month to use\n-     * @param dayOfMonth day of month to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z without any time\n-     * part\n-     */\n-    long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException;\n-\n-    /**\n-     * Returns a time-only millisecond instant, by clearing the date fields\n-     * from the given instant.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>dayOfYear().remainder(instant)</code>.\n-     * \n-     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n-     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part\n-     * cleared\n-     */\n-    long getTimeOnlyMillis(long instant);\n-\n-    /**\n-     * Returns a time-only millisecond instant, formed from the given hour,\n-     * minute, second, and millisecond values. The set of given values must\n-     * refer to a valid time, or else an IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation calls upon separate DateTimeFields to\n-     * determine the result. Subclasses are encouraged to provide a more\n-     * efficient implementation.\n-     *\n-     * @param hourOfDay hour to use\n-     * @param minuteOfHour minute to use\n-     * @param secondOfMinute second to use\n-     * @param millisOfSecond millisecond to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z without any date\n-     * part\n-     */\n-    long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                           int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException;\n-\n-    /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * month, day, and millisecond values. The set of given values must refer\n      * to a valid datetime, or else an IllegalArgumentException is thrown.\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n     long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                           int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException;\n \n     /**\n         throws IllegalArgumentException;\n \n     /**\n-     * Returns a datetime millisecond instant, formed from the given year,\n-     * month, day, hour, minute, second, and millisecond values. The set of\n-     * given values must refer to a valid datetime, or else an\n-     * IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation calls upon separate DateTimeFields to\n-     * determine the result. Subclasses are encouraged to provide a more\n-     * efficient implementation.\n-     *\n-     * @param year year to use\n-     * @param monthOfYear month to use\n-     * @param dayOfMonth day of month to use\n-     * @param hourOfDay hour to use\n-     * @param minuteOfHour minute to use\n-     * @param secondOfMinute second to use\n-     * @param millisOfSecond millisecond to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                           int hourOfDay, int minuteOfHour,\n-                           int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException;\n-\n-    /**\n      * Validates whether the fields stored in a partial instant are valid.\n      *\n      * @param instant  the partial instant to validate\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n \n import java.io.Serializable;\n \n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.convert.InstantConverter;\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n-     * @throws IllegalArgumentException if the instant is null or invalid\n+     * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant) {\n         super(instant);\n      *\n      * @param instant  the datetime object, must not be null\n      * @param zone  the time zone, null means default time zone\n-     * @throws IllegalArgumentException if the instant is null or invalid\n+     * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant, DateTimeZone zone) {\n         super(instant, zone);\n      *\n      * @param instant  the datetime object, must not be null\n      * @param chronology  the chronology, null means ISOChronology in default zone\n-     * @throws IllegalArgumentException if the instant is null or invalid\n+     * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant, Chronology chronology) {\n         super(instant, chronology);\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  an object representing an instant\n-     * @throws IllegalArgumentException if the object is null or invalid\n+     * @throws IllegalArgumentException if the object is invalid\n      * @see #setDateTime(Object)\n      */\n     public void setMillis(Object instant) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void setDate(final long instant) {\n-        Chronology c = getChronology();\n-        setMillis(c.getDateOnlyMillis(instant) + c.getTimeOnlyMillis(getMillis()));\n+        setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\n     }\n \n     /**\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  an object representing an instant, time part ignored\n-     * @throws IllegalArgumentException if the object is null or invalid\n+     * @throws IllegalArgumentException if the object is invalid\n      */\n     public void setDate(final Object instant) {\n+        // TODO: Does time zone need to be considered? See setTime(Object)\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         setDate(converter.getInstantMillis(instant));\n     }\n             final int monthOfYear,\n             final int dayOfMonth) {\n         Chronology c = getChronology();\n-        long instant = c.getDateTimeMillis(\n-            year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n-        setDate(instant);\n+        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+        setDate(instantMidnight);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void setTime(final long millis) {\n-        Chronology c = getChronology();\n-        setMillis(c.getDateOnlyMillis(getMillis()) + c.getTimeOnlyMillis(millis));\n+        int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);\n+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n     }\n \n     /**\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  an object representing an instant, date part ignored\n-     * @throws IllegalArgumentException if the object is null or invalid\n+     * @throws IllegalArgumentException if the object is invalid\n      */\n     public void setTime(final Object instant) {\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        setTime(converter.getInstantMillis(instant));\n+        long millis = converter.getInstantMillis(instant);\n+        DateTimeZone zone = converter.getChronology(instant).getZone();\n+        if (zone != null) {\n+            millis = zone.getMillisKeepLocal(DateTimeZone.UTC, millis);\n+        }\n+        setTime(millis);\n     }\n \n     /**\n             final int millisOfSecond) {\n         long instant = getChronology().getDateTimeMillis(\n             getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n-        setTime(instant);\n+        setMillis(instant);\n     }\n \n     //-----------------------------------------------------------------------\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  an object representing an instant\n-     * @throws IllegalArgumentException if the object is null or invalid\n+     * @throws IllegalArgumentException if the object is invalid\n      */\n     public void setDateTime(final Object instant) {\n         setMillis(instant);\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n     public abstract Chronology withZone(DateTimeZone zone);\n \n     /**\n-     * Returns a date-only millisecond instant, by clearing the time fields\n-     * from the given instant.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>dayOfYear().roundFloor(instant)</code>.\n-     * \n-     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n-     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part\n-     * cleared\n-     */\n-    public long getDateOnlyMillis(long instant) {\n-        return dayOfYear().roundFloor(instant);\n-    }\n-\n-    /**\n-     * Returns a date-only millisecond instant, formed from the given year,\n-     * month, and day values. The set of given values must refer to a valid\n-     * date, or else an IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.\n-     *\n-     * @param year year to use\n-     * @param monthOfYear month to use\n-     * @param dayOfMonth day of month to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z without any time\n-     * part\n-     */\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n-    }\n-\n-    /**\n-     * Returns a time-only millisecond instant, by clearing the date fields\n-     * from the given instant.\n-     * <p>\n-     * The default implementation simply returns\n-     * <code>dayOfYear().remainder(instant)</code>.\n-     * \n-     * @param instant the milliseconds from 1970-01-01T00:00:00Z\n-     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part\n-     * cleared\n-     */\n-    public long getTimeOnlyMillis(long instant) {\n-        return dayOfYear().remainder(instant);\n-    }\n-\n-    /**\n-     * Returns a time-only millisecond instant, formed from the given hour,\n-     * minute, second, and millisecond values. The set of given values must\n-     * refer to a valid time, or else an IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation calls upon separate DateTimeFields to\n-     * determine the result. Subclasses are encouraged to provide a more\n-     * efficient implementation.\n-     *\n-     * @param hourOfDay hour to use\n-     * @param minuteOfHour minute to use\n-     * @param secondOfMinute second to use\n-     * @param millisOfSecond millisecond to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z without any date\n-     * part\n-     */\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = hourOfDay().set(0, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * month, day, and millisecond values. The set of given values must refer\n      * to a valid datetime, or else an IllegalArgumentException is thrown.\n     }\n \n     /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n      * Returns a datetime millisecond instant, from from the given instant,\n      * hour, minute, second, and millisecond values. The set of given values\n      * must refer to a valid datetime, or else an IllegalArgumentException is\n                                   int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException\n     {\n-        instant = hourOfDay().set(instant, hourOfDay);\n-        instant = minuteOfHour().set(instant, minuteOfHour);\n-        instant = secondOfMinute().set(instant, secondOfMinute);\n-        return millisOfSecond().set(instant, millisOfSecond);\n-    }\n-\n-    /**\n-     * Returns a datetime millisecond instant, formed from the given year,\n-     * month, day, hour, minute, second, and millisecond values. The set of\n-     * given values must refer to a valid datetime, or else an\n-     * IllegalArgumentException is thrown.\n-     * <p>\n-     * The default implementation calls upon separate DateTimeFields to\n-     * determine the result. Subclasses are encouraged to provide a more\n-     * efficient implementation.\n-     *\n-     * @param year year to use\n-     * @param monthOfYear month to use\n-     * @param dayOfMonth day of month to use\n-     * @param hourOfDay hour to use\n-     * @param minuteOfHour minute to use\n-     * @param secondOfMinute second to use\n-     * @param millisOfSecond millisecond to use\n-     * @return millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = year().set(0, year);\n-        instant = monthOfYear().set(instant, monthOfYear);\n-        instant = dayOfMonth().set(instant, dayOfMonth);\n         instant = hourOfDay().set(instant, hourOfDay);\n         instant = minuteOfHour().set(instant, minuteOfHour);\n         instant = secondOfMinute().set(instant, secondOfMinute);\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n         return DateTimeZone.UTC;\n     }\n \n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-        }\n-\n-        FieldUtils.verifyValueBounds(\"year\", year, getMinYear(), getMaxYear());\n-        FieldUtils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 12);\n-\n-        boolean isLeap = isLeapYear(year);\n-\n-        FieldUtils.verifyValueBounds(\"dayOfMonth\", dayOfMonth, 1,\n-                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n-                                [monthOfYear - 1]);\n-\n-        long instant = getYearMillis(year);\n-\n-        if (monthOfYear > 1) {\n-            instant += \n-                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n-                [monthOfYear - 2];\n-        }\n-\n-        if (dayOfMonth != 1) {\n-            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-\n-        return instant;\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-\n-        FieldUtils.verifyValueBounds(\"hourOfDay\", hourOfDay, 0, 23);\n-        FieldUtils.verifyValueBounds(\"minuteOfHour\", minuteOfHour, 0, 59);\n-        FieldUtils.verifyValueBounds(\"secondOfMinute\", secondOfMinute, 0, 59);\n-        FieldUtils.verifyValueBounds(\"millisOfSecond\", millisOfSecond, 0, 999);\n-\n-        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n-            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n-            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n-            + millisOfSecond;\n-    }\n-\n     public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                         int millisOfDay)\n         throws IllegalArgumentException\n         if ((base = getBase()) != null) {\n             return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n         }\n+\n         FieldUtils.verifyValueBounds(\"millisOfDay\", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n-        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n-    }\n-\n-    public final long getDateTimeMillis(long instant,\n-                                        int hourOfDay, int minuteOfHour,\n-                                        int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateTimeMillis\n-                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-        return getDateOnlyMillis(instant)\n-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n     }\n \n     public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n             return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         }\n-        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)\n-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+\n+        FieldUtils.verifyValueBounds(\"hourOfDay\", hourOfDay, 0, 23);\n+        FieldUtils.verifyValueBounds(\"minuteOfHour\", minuteOfHour, 0, 59);\n+        FieldUtils.verifyValueBounds(\"secondOfMinute\", secondOfMinute, 0, 59);\n+        FieldUtils.verifyValueBounds(\"millisOfSecond\", millisOfSecond, 0, 999);\n+\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n     }\n \n     public final int getMinimumDaysInFirstWeek() {\n         }\n     }\n \n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        FieldUtils.verifyValueBounds(\"year\", year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 12);\n+\n+        boolean isLeap = isLeapYear(year);\n+\n+        FieldUtils.verifyValueBounds(\"dayOfMonth\", dayOfMonth, 1,\n+                                     (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n+                                     [monthOfYear - 1]);\n+\n+        long instant = getYearMillis(year);\n+\n+        if (monthOfYear > 1) {\n+            instant += \n+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n+                [monthOfYear - 2];\n+        }\n+\n+        if (dayOfMonth != 1) {\n+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+\n+        return instant;\n+    }\n+\n     abstract boolean isLeapYear(int year);\n \n     abstract long calculateFirstDayOfYearMillis(int year);\n--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n         return null;\n     }\n \n-    public long getDateOnlyMillis(long instant) {\n-        Chronology base;\n-        if ((base = iBase) != null) {\n-            return base.getDateOnlyMillis(instant);\n-        }\n-        return super.getDateOnlyMillis(instant);\n-    }\n-\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = iBase) != null && (iBaseFlags & 4) == 4) {\n-            // Only call specialized implementation if applicable fields are the same.\n-            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-        }\n-        return super.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-    }\n-\n-    public long getTimeOnlyMillis(long instant) {\n-        Chronology base;\n-        if ((base = iBase) != null) {\n-            return base.getTimeOnlyMillis(instant);\n-        }\n-        return super.getTimeOnlyMillis(instant);\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {\n-            // Only call specialized implementation if applicable fields are the same.\n-            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-        return super.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-    }\n-\n     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                   int millisOfDay)\n         throws IllegalArgumentException\n             return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n         }\n         return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n     }\n \n     public long getDateTimeMillis(long instant,\n         }\n         return super.getDateTimeMillis\n             (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-    }\n-\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n-            // Only call specialized implementation if applicable fields are the same.\n-            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n-                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n-                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n     }\n \n     public final DurationField millis() {\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n         return getInstance(zone);\n     }\n \n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n         throws IllegalArgumentException\n     {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-        }\n-\n         FieldUtils.verifyValueBounds(\"year\", year, getMinYear(), getMaxYear());\n         FieldUtils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 13);\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n         return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n     }\n \n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-        }\n-\n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-\n-        // Time fields are same for Julian and Gregorian.\n-        return iGregorianChronology.getTimeOnlyMillis\n-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-    }\n-\n     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                   int millisOfDay)\n         throws IllegalArgumentException\n         return instant;\n     }\n \n-    public long getDateTimeMillis(long instant,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateTimeMillis\n-                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-\n-        return getDateOnlyMillis(instant)\n-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-    }\n-\n     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                   int hourOfDay, int minuteOfHour,\n                                   int secondOfMinute, int millisOfSecond)\n                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         }\n \n-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)\n-            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        // Assume date is Gregorian.\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        if (instant < iCutoverMillis) {\n+            // Maybe it's Julian.\n+            instant = iJulianChronology.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth,\n+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+            if (instant >= iCutoverMillis) {\n+                // Okay, it's in the illegal cutover gap.\n+                throw new IllegalArgumentException(\"Specified date does not exist\");\n+            }\n+        }\n+        return instant;\n     }\n \n     /**\n         sb.append(\"cutover=\");\n         ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n         DateTimePrinter printer;\n-        if (withUTC().getTimeOnlyMillis(iCutoverMillis) == 0) {\n+        if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n             printer = format.date();\n         } else {\n             printer = format.dateTime();\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n         return getInstance(zone);\n     }\n \n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n         throws IllegalArgumentException\n     {\n-        return super.getDateOnlyMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n+        return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n     }\n \n     boolean isLeapYear(int year) {\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n         return chrono;\n     }\n \n-    public long getDateOnlyMillis(long instant) {\n-        checkLimits(instant, null);\n-        instant = getBase().getDateOnlyMillis(instant);\n-        checkLimits(instant, \"resulting\");\n-        return instant;\n-    }\n-\n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        long instant = getBase().getDateOnlyMillis(year, monthOfYear, dayOfMonth);\n-        checkLimits(instant, \"resulting\");\n-        return instant;\n-    }\n-\n-    public long getTimeOnlyMillis(long instant) {\n-        checkLimits(instant, null);\n-        instant = getBase().getTimeOnlyMillis(instant);\n-        checkLimits(instant, \"resulting\");\n-        return instant;\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = getBase().getTimeOnlyMillis\n-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        checkLimits(instant, \"resulting\");\n-        return instant;\n-    }\n-\n     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                   int millisOfDay)\n         throws IllegalArgumentException\n     {\n         long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = getBase().getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n         checkLimits(instant, null);\n         instant = getBase().getDateTimeMillis\n             (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        checkLimits(instant, \"resulting\");\n-        return instant;\n-    }\n-\n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        long instant = getBase().getDateTimeMillis\n-            (year, monthOfYear, dayOfMonth,\n-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         checkLimits(instant, \"resulting\");\n         return instant;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n         return new ZonedChronology(getBase(), zone);\n     }\n \n-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(getBase().getDateOnlyMillis\n-                          (year, monthOfYear, dayOfMonth));\n-    }\n-\n-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(getBase().getTimeOnlyMillis\n-                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n-    }\n-\n     public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                   int millisOfDay)\n         throws IllegalArgumentException\n     {\n         return localToUTC(getBase().getDateTimeMillis\n                           (year, monthOfYear, dayOfMonth, millisOfDay));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, \n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n     }\n \n     public long getDateTimeMillis(long instant,\n                            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n     }\n \n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        return localToUTC(getBase().getDateTimeMillis\n-                          (year, monthOfYear, dayOfMonth, \n-                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n-    }\n-\n     /**\n      * @param instant instant from 1970-01-01T00:00:00 local time\n+     * @return instant from 1970-01-01T00:00:00Z\n      */\n     private long localToUTC(long instant) {\n         DateTimeZone zone = getZone();", "timestamp": 1090091790, "metainfo": ""}