{"sha": "8ef60672c1dd5407b0761b81408857be44562ecf", "log": "Update API - Instant now ISO UTC - withXxx methods added to lots of classes - uniform set of methods almost complete   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/Examples.java\n+++ b/JodaTime/src/example/org/joda/example/time/Examples.java\n         Instant in = new Instant();\n         System.out.println(\"Millisecond time:     in.getMillis():           \" + in.getMillis());\n         System.out.println(\"ISO string version:   in.toString():            \" + in.toString());\n-        System.out.println(\"No chronology:        in.getChronology():       \" + in.getChronology());\n-        System.out.println(\"No time zone:         in.getDateTimeZone():     \" + in.getZone());\n+        System.out.println(\"ISO chronology:       in.getChronology():       \" + in.getChronology());\n+        System.out.println(\"UTC time zone:        in.getDateTimeZone():     \" + in.getZone());\n         System.out.println(\"Change millis:        in.withMillis(0):         \" + in.withMillis(0L));\n         System.out.println(\"\");\n         System.out.println(\"Convert to Instant:   in.toInstant():           \" + in.toInstant());\n         System.out.println(\"Convert to DateTime:  in.toDateTime():          \" + in.toDateTime());\n         System.out.println(\"Convert to MutableDT: in.toMutableDateTime():   \" + in.toMutableDateTime());\n         System.out.println(\"Convert to Date:      in.toDate():              \" + in.toDate());\n-        System.out.println(\"Convert to Calendar:  in.toCalendar(Locale.UK): \" + in.toCalendar(Locale.UK).toString().substring(0, 46));\n-        System.out.println(\"Convert to GregCal:   in.toGregorianCalendar(): \" + in.toGregorianCalendar().toString().substring(0, 46));\n         System.out.println(\"\");\n         System.out.println(\"                      in2 = new Instant(in.getMillis() + 10)\");\n         Instant in2 = new Instant(in.getMillis() + 10);\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n      */\n     public abstract long add(ReadablePeriod period, long instant, int scalar);\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds the duration to the instant, specifying the number of times to add.\n+     *\n+     * @param instant  the instant to add to\n+     * @param duration  the duration to add\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public abstract long add(long instant, long duration, int scalar);\n+\n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n         return new DateMidnight(millis, getChronology().withZone(newZone));\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the partial set of fields replacing those\n+     * from this instance.\n+     * <p>\n+     * For example, if the partial is a <code>YearMonthDay</code> then the date fields\n+     * would be changed in the returned instance.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public DateMidnight withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withMillis(getChronology().set(partial, getMillis()));\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day of month\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime updated = dt.dayOfMonth().setCopy(6);\n+     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, null ignored\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public DateMidnight withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateTime added = dt.withFieldAdded(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime added = dt.dayOfMonth().addToCopy(6);\n+     * DateTime added = dt.property(DateTimeFieldType.dayOfMonth()).addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, null ignored\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null || amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * To add or subtract on a single field use the properties, for example:\n+     * <pre>\n+     * DateTime added = dt.dayOfMonth().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getMillis(), scalar);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(6);\n+     * DateTime added = dt.plus(Period.hours(6));\n+     * </pre>\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified duration take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(ReadableDuration durationToAdd) {\n+        return withDurationAdded(durationToAdd, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(-6);\n+     * DateTime added = dt.minus(Period.hours(6));\n+     * </pre>\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n     // Date properties\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n import org.joda.time.base.BaseDateTime;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  * DateTime is the standard implementation of an unmodifiable datetime class.\n      * Only the chronology will change, the millis are kept.\n      * The returned object will be either be a new instance or <code>this</code>.\n      *\n-     * @param newChronology  the new chronology\n+     * @param newChronology  the new chronology, null means ISO default\n      * @return a copy of this datetime with a different chronology\n      */\n     public DateTime withChronology(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n         return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n     }\n \n         if (partial == null) {\n             return this;\n         }\n-        return partial.resolveDateTime(this);\n+        return withMillis(getChronology().set(partial, getMillis()));\n     }\n \n     /**\n      * field would be changed in the returned instance.\n      * If the field type is null, then <code>this</code> is returned.\n      * <p>\n-     * An alternative to this method is to use the properties, for example:\n+     * These three lines are equivalent:\n      * <pre>\n-     * DateTime added = dt.hourOfDay().setCopy(6);\n+     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime updated = dt.dayOfMonth().setCopy(6);\n+     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n      * </pre>\n      *\n      * @param fieldType  the field type to set, null ignored\n      * <p>\n      * If the addition is zero or the field is null, then <code>this</code> is returned.\n      * <p>\n-     * An alternative to this method is to use the properties, for example:\n+     * These three lines are equivalent:\n      * <pre>\n-     * DateTime added = dt.hourOfDay().addToCopy(6);\n+     * DateTime added = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime added = dt.dayOfMonth().addToCopy(6);\n+     * DateTime added = dt.property(DateTimeFieldType.dayOfMonth()).addToCopy(6);\n      * </pre>\n      * \n      * @param fieldType  the field type to add to, null ignored\n         if (durationToAdd == 0 || scalar == 0) {\n             return this;\n         }\n-        long add = FieldUtils.safeMultiply(durationToAdd, scalar);\n-        long instant = FieldUtils.safeAdd(getMillis(), add);\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n         return withMillis(instant);\n     }\n \n      */\n     public DateTime minus(ReadablePeriod period) {\n         return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a DateMidnight using the same millis and chronology.\n+     * \n+     * @return a DateMidnight using the same millis and chronology\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return new DateMidnight(getMillis(), getChronology());\n     }\n \n     // Date properties\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n import org.joda.time.base.AbstractInstant;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n-import org.joda.time.format.ISODateTimeFormat;\n \n /**\n  * Instant is the standard implementation of a fully immutable instant in time.\n  * It holds the instant as milliseconds from the Java Epoch of 1970-01-01T00:00:00Z.\n  * <p>\n- * There is no concept of a calendar system, chronology or time zone.\n- * In a fully internationalized program, you may want to ensure methods accept the\n- * ReadableInstant interface as input and return Instant objects.\n+ * The chronology used is always ISO in the UTC time zone.\n+ * This corresponds to the definition of the Java Epoch.\n+ * <p>\n+ * An Instant can be used to compare two <code>DateTime</code> objects:\n+ * <pre>\n+ * boolean sameInstant = dt1.toInstant().equals(dt2.toInstant());\n+ * </pre>\n+ * This code will return true if the two <code>DateTime</code> objects represent\n+ * the same instant regardless of chronology or time zone.\n+ * <p>\n+ * Note that the following code will also perform the same check:\n+ * <pre>\n+ * boolean sameInstant = dt1.isEqual(dt2);\n+ * </pre>\n  * <p>\n  * Instant is thread-safe and immutable.\n  *\n         return (newMillis == iMillis ? this : new Instant(newMillis));\n     }\n \n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this instant with the duration taken away\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this instant with the duration taken away\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant minus(ReadableDuration durationToAdd) {\n+        return withDurationAdded(durationToAdd, -1);\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the milliseconds of the instant.\n     }\n \n     /**\n-     * Gets the chronology of the instant, which is null.\n-     * <p>\n-     * The {@link Chronology} provides conversion from the millisecond\n-     * value to meaningful fields in a particular calendar system. This\n-     * class represents a chronology free view of time, so this method\n-     * returns null.\n-     * \n-     * @return null\n+     * Gets the chronology of the instant, which is ISO in the UTC zone.\n+     * \n+     * @return ISO in the UTC zone\n      */\n     public Chronology getChronology() {\n-        return null;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Output the date time in ISO8601 format using the UTC time zone.\n-     * <p>\n-     * ISO8601 is deliberately used here so that the resulting string can be\n-     * re-parsed by the constructor.\n-     * \n-     * @return ISO8601 date formatted string\n-     */\n-    public String toString() {\n-        return ISODateTimeFormat.getInstanceUTC().dateTime().print(this);\n+        return Chronology.getISOUTC();\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n         return withEndMillis(endMillis);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the specified duration after the start instant.\n+     *\n+     * @param duration  the duration to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the duration is negative\n+     */\n+    public Interval withDurationAfterStart(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        if (durationMillis == toDurationMillis()) {\n+            return this;\n+        }\n+        long startMillis = getStartMillis();\n+        long endMillis = getChronology().add(startMillis, durationMillis, 1);\n+        return new Interval(startMillis, endMillis);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified duration before the end instant.\n+     *\n+     * @param duration  the duration to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the duration is negative\n+     */\n+    public Interval withDurationBeforeEnd(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        if (durationMillis == toDurationMillis()) {\n+            return this;\n+        }\n+        long endMillis = getEndMillis();\n+        long startMillis = getChronology().add(endMillis, durationMillis, -1);\n+        return new Interval(startMillis, endMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the specified period after the start instant.\n+     *\n+     * @param period  the period to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the period is negative\n+     */\n+    public Interval withPeriodAfterStart(ReadablePeriod period) {\n+        if (period == null) {\n+            return this;\n+        }\n+        long startMillis = getStartMillis();\n+        long endMillis = getChronology().add(period, startMillis, 1);\n+        return new Interval(startMillis, endMillis);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified period before the end instant.\n+     *\n+     * @param period  the period to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the period is negative\n+     */\n+    public Interval withPeriodBeforeEnd(ReadablePeriod period) {\n+        if (period == null) {\n+            return this;\n+        }\n+        long endMillis = getEndMillis();\n+        long startMillis = getChronology().add(period, endMillis, -1);\n+        return new Interval(startMillis, endMillis);\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n     boolean isSupported(DateTimeFieldType field);\n \n     /**\n-     * Resolves this partial against another complete millisecond instant to\n-     * create a new full instant specifying the time zone to resolve with.\n-     * <p>\n-     * For example, if this partial represents a time, then the result of this\n-     * method will be the datetime from the specified base instant plus the\n-     * time from this partial set using the time zone specified.\n-     *\n-     * @param baseInstant  source of missing fields\n-     * @param zone  the time zone to use, null means default\n-     * @return the combined instant in milliseconds\n-     */\n-    long resolve(long baseInstant, DateTimeZone zone);\n-\n-    /**\n      * Resolves this partial against another complete instant to create a new\n      * full instant. The combination is performed using the chronology of the\n      * specified instant.\n      * @param baseInstant  the instant that provides the missing fields, null means now\n      * @return the combined datetime\n      */\n-    DateTime resolveDateTime(ReadableInstant baseInstant);\n-\n-    /**\n-     * Resolves this partial into another complete instant setting the relevant\n-     * fields on the writable instant. The combination is performed using the\n-     * chronology of the specified instant.\n-     * <p>\n-     * For example, if this partial represents a time, then the input writable\n-     * instant will be updated with the time from this partial.\n-     *\n-     * @param baseInstant  the instant to set into, must not be null\n-     * @throws IllegalArgumentException if the base instant is null\n-     */\n-    void resolveInto(ReadWritableInstant baseInstant);\n+    DateTime toDateTimeUsing(ReadableInstant baseInstant);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n         }\n     }\n \n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the hour of day (0-23) field value.\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n         }\n     }\n \n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateMidnight in the default time zone.\n+     *\n+     * @return the DateMidnight instance in the default zone\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return toDateMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateMidnight.\n+     *\n+     * @param zone  the zone to get the DateMidnight in, null means default\n+     * @return the DateMidnight instance\n+     */\n+    public DateMidnight toDateMidnight(DateTimeZone zone) {\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), zone);\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the year field value.\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n  */\n package org.joda.time.base;\n \n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n import java.util.Locale;\n \n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableDateTime;\n import org.joda.time.format.DateTimeFormat;\n \n \n     //-----------------------------------------------------------------------\n     /**\n+     * Get the date time as a <code>java.util.Calendar</code>.\n+     * The locale is passed in, enabling Calendar to select the correct\n+     * localized subclass.\n+     * \n+     * @param locale  the locale to get the Calendar for, or default if null\n+     * @return a localized Calendar initialised with this datetime\n+     */\n+    public Calendar toCalendar(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        DateTimeZone zone = getZone();\n+        Calendar cal;\n+        if (zone == null) {\n+            cal = Calendar.getInstance(locale);\n+        } else {\n+            cal = Calendar.getInstance(zone.toTimeZone(), locale);\n+        }\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.GregorianCalendar</code>.\n+     * \n+     * @return a GregorianCalendar initialised with this datetime\n+     */\n+    public GregorianCalendar toGregorianCalendar() {\n+        DateTimeZone zone = getZone();\n+        GregorianCalendar cal;\n+        if (zone == null) {\n+            cal = new GregorianCalendar();\n+        } else {\n+            cal = new GregorianCalendar(zone.toTimeZone());\n+        }\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output the instant using the specified format pattern.\n      *\n      * @param pattern  the pattern specification, null means use <code>toString</code>\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n  */\n package org.joda.time.base;\n \n-import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n         return new Date(getMillis());\n     }\n \n-    /**\n-     * Get the date time as a <code>java.util.Calendar</code>.\n-     * The locale is passed in, enabling Calendar to select the correct\n-     * localized subclass.\n-     * \n-     * @param locale  the locale to get the Calendar for, or default if null\n-     * @return a localized Calendar initialised with this datetime\n-     */\n-    public Calendar toCalendar(Locale locale) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        DateTimeZone zone = getZone();\n-        Calendar cal;\n-        if (zone == null) {\n-            cal = Calendar.getInstance(locale);\n-        } else {\n-            cal = Calendar.getInstance(zone.toTimeZone(), locale);\n-        }\n-        cal.setTime(toDate());\n-        return cal;\n-    }\n-\n-    /**\n-     * Get the date time as a <code>java.util.GregorianCalendar</code>.\n-     * \n-     * @return a GregorianCalendar initialised with this datetime\n-     */\n-    public GregorianCalendar toGregorianCalendar() {\n-        DateTimeZone zone = getZone();\n-        GregorianCalendar cal;\n-        if (zone == null) {\n-            cal = new GregorianCalendar();\n-        } else {\n-            cal = new GregorianCalendar(zone.toTimeZone());\n-        }\n-        cal.setTime(toDate());\n-        return cal;\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n \n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n     public int get(DateTimeFieldType type) {\n+        return getValue(indexOfSupported(type));\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        return (indexOf(type) != -1);\n+    }\n+\n+    /**\n+     * Gets the index of the specified field, or -1 if the field is unsupported.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of the field, -1 if unsupported\n+     */\n+    public int indexOf(DateTimeFieldType type) {\n         for (int i = 0, isize = size(); i < isize; i++) {\n             if (getFieldType(i) == type) {\n-                return getValue(i);\n+                return i;\n             }\n         }\n-        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n-    }\n-\n-    /**\n-     * Checks whether the field specified is supported by this partial.\n-     *\n-     * @param type  the type to check, may be null which returns false\n-     * @return true if the field is supported\n-     */\n-    public boolean isSupported(DateTimeFieldType type) {\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            if (getFieldType(i) == type) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Resolves this partial against another complete millisecond instant to\n-     * create a new full instant specifying the time zone to resolve with.\n-     * <p>\n-     * For example, if this partial represents a time, then the result of this\n-     * method will be the datetime from the specified base instant plus the\n-     * time from this partial set using the time zone specified.\n-     *\n-     * @param baseInstant  source of missing fields\n-     * @param zone  the time zone to use, null means default\n-     * @return the combined instant in milliseconds\n-     */\n-    public long resolve(long baseInstant, DateTimeZone zone) {\n-        Chronology chrono = getChronology().withZone(zone);\n-        return chrono.set(this, baseInstant);\n-    }\n-\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets the index of the specified field, throwing an exception if the\n+     * field is unsupported.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of the field, -1 if unsupported\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    protected int indexOfSupported(DateTimeFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return index;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Resolves this partial against another complete instant to create a new\n      * full instant. The combination is performed using the chronology of the\n      * @param baseInstant  the instant that provides the missing fields, null means now\n      * @return the combined datetime\n      */\n-    public DateTime resolveDateTime(ReadableInstant baseInstant) {\n+    public DateTime toDateTimeUsing(ReadableInstant baseInstant) {\n         Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n         long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n         long resolved = chrono.set(this, instantMillis);\n         return new DateTime(resolved, chrono);\n-    }\n-\n-    /**\n-     * Resolves this partial into another complete instant setting the relevant\n-     * fields on the writable instant. The combination is performed using the\n-     * chronology of the specified instant.\n-     * <p>\n-     * For example, if this partial represents a time, then the input writable\n-     * instant will be updated with the time from this partial.\n-     *\n-     * @param baseInstant  the instant to set into, must not be null\n-     * @throws IllegalArgumentException if the base instant is null\n-     */\n-    public void resolveInto(ReadWritableInstant baseInstant) {\n-        if (baseInstant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n-        long resolved = chrono.set(this, baseInstant.getMillis());\n-        baseInstant.setMillis(resolved);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/BaseDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseDateTime.java\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableDateTime;\n+import org.joda.time.TimeOfDay;\n+import org.joda.time.YearMonthDay;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n         iChronology = checkChronology(chronology);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a YearMonthDay and chronology.\n+     * \n+     * @return a YearMonthDay using the same millis and chronology\n+     */\n+    public YearMonthDay toYearMonthDay() {\n+        return new YearMonthDay(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Get this object as a TimeOfDay and chronology.\n+     * \n+     * @return a TimeOfDay using the same millis and chronology\n+     */\n+    public TimeOfDay toTimeOfDay() {\n+        return new TimeOfDay(getMillis(), getChronology());\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n import org.joda.time.DurationFieldType;\n import org.joda.time.ReadablePartial;\n import org.joda.time.ReadablePeriod;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.field.UnsupportedDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n \n         return instant;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds the duration to the instant, specifying the number of times to add.\n+     *\n+     * @param instant  the instant to add to\n+     * @param duration  the duration to add\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public long add(long instant, long duration, int scalar) {\n+        if (duration == 0 || scalar == 0) {\n+            return instant;\n+        }\n+        long add = FieldUtils.safeMultiply(duration, scalar);\n+        return FieldUtils.safeAdd(instant, add);\n+    }\n+\n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n             if (partial.isSupported(iField.getType())) {\n-                long millis = partial.resolve(0L, DateTimeZone.UTC);\n+                long millis = this.iChrono.withUTC().set(partial, 0L);\n                 try {\n                     printTo(buf, null, millis);\n                 } catch (IOException e) {\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n             if (partial.isSupported(iField.getType())) {\n-                long millis = partial.resolve(0L, DateTimeZone.UTC);\n+                long millis = this.iChrono.withUTC().set(partial, 0L);\n                 printTo(null, out, millis);\n             } else {\n                 out.write('\\ufffd');\n--- a/JodaTime/src/test/org/joda/time/MockPartial.java\n+++ b/JodaTime/src/test/org/joda/time/MockPartial.java\n  */\n package org.joda.time;\n \n-import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeField;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadWritableInstant;\n-import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n     public boolean isSupported(DateTimeFieldType field) {\n         return false;\n     }\n-    public long resolve(long baseMillis, DateTimeZone tz) {\n-        return 0L;\n-    }\n-    public DateTime resolveDateTime(ReadableInstant base) {\n+    public DateTime toDateTimeUsing(ReadableInstant base) {\n         return null;\n-    }\n-    public void resolveInto(ReadWritableInstant base) {\n     }\n     public DateTimeField[] getFields() {\n         return new DateTimeField[0];\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.base.AbstractInstant;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.ISOChronology;\n \n         assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt));\n         \n         Instant i = new Instant(123L);\n-        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(i));\n+        assertEquals(ISOChronology.getInstanceUTC(), DateTimeUtils.getInstantChronology(i));\n+        \n+        AbstractInstant ai = new AbstractInstant() {\n+            public long getMillis() {\n+                return 0L;\n+            }\n+            public Chronology getChronology() {\n+                return null; // testing for this\n+            }\n+        };\n+        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(ai));\n         \n         assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null));\n     }\n--- a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.lang.reflect.Modifier;\n-import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.TimeZone;\n \n     public void testGetMethods() {\n         Instant test = new Instant();\n         \n-        assertEquals(null, test.getChronology());\n-        assertEquals(null, test.getZone());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n+        assertEquals(DateTimeZone.UTC, test.getZone());\n         assertEquals(TEST_TIME_NOW, test.getMillis());\n     }\n \n             return TEST_TIME1;\n         }\n         public Chronology getChronology() {\n-            return null;\n+            return Chronology.getISOUTC();\n         }\n     }\n \n         assertEquals(test.getMillis(), result.getTime());\n     }\n \n-    public void testToCalendar_Locale() {\n-        Instant test = new Instant(TEST_TIME1);\n-        Calendar result = test.toCalendar(null);\n-        assertEquals(test.getMillis(), result.getTime().getTime());\n-        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n-\n-        test = new Instant(TEST_TIME1);\n-        result = test.toCalendar(Locale.UK);\n-        assertEquals(test.getMillis(), result.getTime().getTime());\n-        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n-    }\n-\n-    public void testToGregorianCalendar() {\n-        Instant test = new Instant(TEST_TIME1);\n-        GregorianCalendar result = test.toGregorianCalendar();\n-        assertEquals(test.getMillis(), result.getTime().getTime());\n-        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n-    }\n-\n     //-----------------------------------------------------------------------\n     public void testWithMillis_long() {\n         Instant test = new Instant(TEST_TIME1);\n--- a/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java\n      */\n     public void testConstructor() throws Throwable {\n         Instant test = new Instant();\n-        assertEquals(null, test.getChronology());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n         assertEquals(TEST_TIME_NOW, test.getMillis());\n     }\n \n      */\n     public void testConstructor_long1() throws Throwable {\n         Instant test = new Instant(TEST_TIME1);\n-        assertEquals(null, test.getChronology());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n         assertEquals(TEST_TIME1, test.getMillis());\n     }\n \n      */\n     public void testConstructor_long2() throws Throwable {\n         Instant test = new Instant(TEST_TIME2);\n-        assertEquals(null, test.getChronology());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n         assertEquals(TEST_TIME2, test.getMillis());\n     }\n \n     public void testConstructor_Object() throws Throwable {\n         Date date = new Date(TEST_TIME1);\n         Instant test = new Instant(date);\n-        assertEquals(null, test.getChronology());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n         assertEquals(TEST_TIME1, test.getMillis());\n     }\n \n      */\n     public void testConstructor_nullObject() throws Throwable {\n         Instant test = new Instant((Object) null);\n-        assertEquals(null, test.getChronology());\n+        assertEquals(Chronology.getISOUTC(), test.getChronology());\n         assertEquals(TEST_TIME_NOW, test.getMillis());\n     }\n \n         try {\n             ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n             Instant test = new Instant(new Integer(0));\n-            assertEquals(null, test.getChronology());\n+            assertEquals(Chronology.getISOUTC(), test.getChronology());\n             assertEquals(0L, test.getMillis());\n         } finally {\n             ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, 6);\n-        result = ISOChronology.getInstance().days().add(result, 3);\n-        result = ISOChronology.getInstance().hours().add(result, 1);\n+        result = ISOChronology.getInstanceUTC().months().add(result, 6);\n+        result = ISOChronology.getInstanceUTC().days().add(result, 3);\n+        result = ISOChronology.getInstanceUTC().hours().add(result, 1);\n         \n         Interval test = new Interval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n     }\n \n     public void testConstructor_RI_RP3() throws Throwable {\n-        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getCopticUTC());\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n-        result = Chronology.getISOUTC().months().add(result, 6);\n-        result = Chronology.getISOUTC().days().add(result, 3);\n-        result = Chronology.getISOUTC().hours().add(result, 1);\n+        result = Chronology.getCopticUTC().months().add(result, 6);\n+        result = Chronology.getCopticUTC().days().add(result, 3);\n+        result = Chronology.getCopticUTC().hours().add(result, 1);\n         \n         Interval test = new Interval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, -6);\n-        result = ISOChronology.getInstance().days().add(result, -3);\n-        result = ISOChronology.getInstance().hours().add(result, -1);\n-        \n-        Interval test = new Interval(dur, dt);\n-        assertEquals(result, test.getStartMillis());\n-        assertEquals(dt.getMillis(), test.getEndMillis());\n-    }\n-\n-    public void testConstructor_RP_RI3() throws Throwable {\n-        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n-        long result = TEST_TIME_NOW;\n         result = Chronology.getISOUTC().months().add(result, -6);\n         result = Chronology.getISOUTC().days().add(result, -3);\n         result = Chronology.getISOUTC().hours().add(result, -1);\n+        \n+        Interval test = new Interval(dur, dt);\n+        assertEquals(result, test.getStartMillis());\n+        assertEquals(dt.getMillis(), test.getEndMillis());\n+    }\n+\n+    public void testConstructor_RP_RI3() throws Throwable {\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getCopticUTC());\n+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n+        long result = TEST_TIME_NOW;\n+        result = Chronology.getCopticUTC().months().add(result, -6);\n+        result = Chronology.getCopticUTC().days().add(result, -3);\n+        result = Chronology.getCopticUTC().hours().add(result, -1);\n         \n         Interval test = new Interval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n         Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, 6);\n-        result = ISOChronology.getInstance().hours().add(result, 1);\n+        result = Chronology.getISO().months().add(result, 6);\n+        result = Chronology.getISO().hours().add(result, 1);\n         \n         MutableInterval test = new MutableInterval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, 6);\n-        result = ISOChronology.getInstance().days().add(result, 3);\n-        result = ISOChronology.getInstance().hours().add(result, 1);\n+        result = Chronology.getISOUTC().months().add(result, 6);\n+        result = Chronology.getISOUTC().days().add(result, 3);\n+        result = Chronology.getISOUTC().hours().add(result, 1);\n         \n         MutableInterval test = new MutableInterval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n         Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, -6);\n-        result = ISOChronology.getInstance().hours().add(result, -1);\n+        result = Chronology.getISO().months().add(result, -6);\n+        result = Chronology.getISO().hours().add(result, -1);\n         \n         MutableInterval test = new MutableInterval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstance().months().add(result, -6);\n-        result = ISOChronology.getInstance().days().add(result, -3);\n-        result = ISOChronology.getInstance().hours().add(result, -1);\n+        result = Chronology.getISOUTC().months().add(result, -6);\n+        result = Chronology.getISOUTC().days().add(result, -3);\n+        result = Chronology.getISOUTC().hours().add(result, -1);\n         \n         MutableInterval test = new MutableInterval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n-import org.joda.time.DateTimeUtils;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.MutableDateTime;\n-import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n import org.joda.time.convert.ConverterManager;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testResolve_long() {\n+    public void testResolveDateTime_RI() {\n         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n         DateTime dt = new DateTime(0L);\n         assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n         \n-        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));\n+        DateTime result = test.toDateTimeUsing(dt);\n         assertEquals(10, test.getHourOfDay());\n         assertEquals(20, test.getMinuteOfHour());\n         assertEquals(30, test.getSecondOfMinute());\n         assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n     }\n \n-    public void testResolveDateTime_RI() {\n-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n-        DateTime dt = new DateTime(0L);\n-        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n-        \n-        DateTime result = test.resolveDateTime(dt);\n-        assertEquals(10, test.getHourOfDay());\n-        assertEquals(20, test.getMinuteOfHour());\n-        assertEquals(30, test.getSecondOfMinute());\n-        assertEquals(40, test.getMillisOfSecond());\n-        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n-        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n-    }\n-\n     public void testResolveDateTime_nullRI() {\n         TimeOfDay test = new TimeOfDay(1, 2, 3, 4);\n         DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);\n         \n-        DateTime result = test.resolveDateTime(null);\n+        DateTime result = test.toDateTimeUsing(null);\n         assertEquals(1, test.getHourOfDay());\n         assertEquals(2, test.getMinuteOfHour());\n         assertEquals(3, test.getSecondOfMinute());\n         assertEquals(4, test.getMillisOfSecond());\n         assertEquals(\"1970-01-02T01:02:03.004Z\", result.toString());\n-    }\n-\n-    public void testResolveInto_RWI() {\n-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n-        MutableDateTime mdt = new MutableDateTime(0L);\n-        assertEquals(\"1970-01-01T00:00:00.000Z\", mdt.toString());\n-        \n-        test.resolveInto(mdt);\n-        assertEquals(10, test.getHourOfDay());\n-        assertEquals(20, test.getMinuteOfHour());\n-        assertEquals(30, test.getSecondOfMinute());\n-        assertEquals(40, test.getMillisOfSecond());\n-        assertEquals(\"1970-01-01T10:20:30.040Z\", mdt.toString());\n-    }\n-\n-    public void testResolveInto_nullRWI() {\n-        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n-        \n-        try {\n-            test.resolveInto(null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n-import org.joda.time.DateTimeUtils;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.MutableDateTime;\n-import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testResolve_long() {\n+    public void testResolveDateTime_RI() {\n         YearMonthDay test = new YearMonthDay(1972, 6, 9);\n         DateTime dt = new DateTime(TEST_TIME1);\n         assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n         \n-        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));\n+        DateTime result = test.toDateTimeUsing(dt);\n         check(test, 1972, 6, 9);\n         assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n         assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n     }\n \n-    public void testResolveDateTime_RI() {\n-        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n-        DateTime dt = new DateTime(TEST_TIME1);\n-        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n-        \n-        DateTime result = test.resolveDateTime(dt);\n-        check(test, 1972, 6, 9);\n-        assertEquals(\"1970-04-06T12:24:00.000Z\", dt.toString());\n+    public void testResolveDateTime_nullRI() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);\n+        \n+        DateTime result = test.toDateTimeUsing(null);\n+        check(test, 1972, 6, 9);\n         assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n-    }\n-\n-    public void testResolveDateTime_nullRI() {\n-        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n-        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);\n-        \n-        DateTime result = test.resolveDateTime(null);\n-        check(test, 1972, 6, 9);\n-        assertEquals(\"1972-06-09T12:24:00.000Z\", result.toString());\n-    }\n-\n-    public void testResolveInto_RWI() {\n-        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n-        MutableDateTime mdt = new MutableDateTime(TEST_TIME1);\n-        assertEquals(\"1970-04-06T12:24:00.000Z\", mdt.toString());\n-        \n-        test.resolveInto(mdt);\n-        check(test, 1972, 6, 9);\n-        assertEquals(\"1972-06-09T12:24:00.000Z\", mdt.toString());\n-    }\n-\n-    public void testResolveInto_nullRWI() {\n-        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n-        \n-        try {\n-            test.resolveInto(null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java\n \n     //-----------------------------------------------------------------------\n     public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));\n+        assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));\n         assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L)));\n     }\n ", "timestamp": 1094769956, "metainfo": ""}