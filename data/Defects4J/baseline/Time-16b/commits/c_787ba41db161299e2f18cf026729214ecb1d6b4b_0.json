{"sha": "787ba41db161299e2f18cf026729214ecb1d6b4b", "log": "Add methods to handle time zone differences   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n  */\n package org.joda.time;\n \n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n import org.joda.time.chrono.ISOChronology;\n \n /**\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Converts the instant value to a <code>GregorianCalendar</code>\n+     * adjusting to take into account the different time zone rules.\n+     * <p>\n+     * Note that this method may not be reversible if the zone rules differ\n+     * around a daylight savings, or other, change.\n+     *\n+     * @param instant  the instant to convert\n+     * @return the offset to add to UTC\n+     * @throws IllegalArgumentException if the instant is null\n+     * @since 1.2\n+     */\n+    public static GregorianCalendar toGregorianCalendar(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The zone must not be null\");\n+        }\n+        DateTimeZone zone = instant.getZone();\n+        TimeZone jdkZone = zone.toTimeZone();\n+        GregorianCalendar cal = new GregorianCalendar(jdkZone);\n+        long jdkMillis = zone.getMillisJDKKeepLocal(jdkZone, instant.getMillis());\n+        cal.setTime(new Date(jdkMillis));\n+        return cal;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts a <code>Calendar</code> to a <code>DateTime</code> adjusting\n+     * the millisecond value to preserve the local time.\n+     * <p>\n+     * <code>DateTimeZone</code> and JDK <code>TimeZone</code> have\n+     * different time zone rules. When converting to and from the JDK this\n+     * can cause unexpected and undesired consequences. This method seeks\n+     * to adjust for the differences in the rules by maintaining the same\n+     * field values in the resultant <code>DateTime</code>.\n+     * <p>\n+     * Note that this method may not be reversible if the zone rules differ\n+     * around a daylight savings, or other, change.\n+     *\n+     * @param calendar  the JDK calendar to convert\n+     * @return the converted datetime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @since 1.2\n+     */\n+    public static DateTime toDateTime(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        long millisLocal = calendar.getTime().getTime() +\n+            calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+        DateTimeZone zone = DateTimeZone.forTimeZone(calendar.getTimeZone());\n+        long millis = millisLocal - zone.getOffsetFromLocal(millisLocal);\n+        return new DateTime(millis, zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts a <code>Date</code> to a <code>DateTime</code> adjusting\n+     * the millisecond value to preserve the local time.\n+     * <p>\n+     * <code>DateTimeZone</code> and JDK <code>TimeZone</code> have\n+     * different time zone rules. When converting to and from the JDK this\n+     * can cause unexpected and undesired consequences. This method seeks\n+     * to adjust for the differences in the rules by maintaining the same\n+     * field values in the resultant <code>DateTime</code>.\n+     * <p>\n+     * Note that this method may not be reversible if the zone rules differ\n+     * around a daylight savings, or other, change.\n+     *\n+     * @param date  the JDK date to convert\n+     * @return the converted datetime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @since 1.2\n+     */\n+    public static DateTime toDateTime(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        long millisLocal = date.getTime() - date.getTimezoneOffset() * 60000;\n+        DateTimeZone zone = DateTimeZone.forTimeZone(TimeZone.getDefault());\n+        long millis = millisLocal - zone.getOffsetFromLocal(millisLocal);\n+        return new DateTime(millis, zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Base class defining a millisecond provider.\n      */\n     abstract static class MillisProvider {\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import java.io.Serializable;\n import java.lang.ref.Reference;\n import java.lang.ref.SoftReference;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n+import java.util.SimpleTimeZone;\n import java.util.TimeZone;\n \n import org.joda.time.chrono.BaseChronology;\n         }\n     }\n \n+    /** The method to call as TimeZone.getOffset is only from JDK 1.4. */\n+    private static final Method OFFSET_METHOD;\n+    static {\n+        Method m = null;\n+        try {\n+            m = TimeZone.class.getDeclaredMethod(\"getOffset\", new Class[] {Long.TYPE});\n+        } catch (SecurityException ex) {\n+            // ignore\n+        } catch (NoSuchMethodException ex) {\n+            try {\n+                Method[] ms = TimeZone.class.getDeclaredMethods();\n+                m = TimeZone.class.getDeclaredMethod(\"getOffsets\", new Class[] {Long.TYPE, int[].class});\n+                m.setAccessible(true);\n+            } catch (SecurityException e) {\n+                // ignore\n+            } catch (NoSuchMethodException e) {\n+                // ignore\n+            }\n+        }\n+        OFFSET_METHOD = m;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the default time zone.\n     }\n \n     /**\n+     * Gets the millisecond instant in the equivalent JDK <code>TimeZone</code>\n+     * keeping the same local time.\n+     * <p>\n+     * This method adjusts for time zone difference between the JDK and\n+     * Joda-Time zone rules. The aim of this method is to keep the same\n+     * local time but using the JDK time zone class. The result of this\n+     * method should be used to pass into a <code>Date</code>,\n+     * <code>Calendar</code> or other JDK class.\n+     * See the <a href=\"http://joda-time.sourceforge.net/jdk_conversion.html\">JDK conversion reference</a> for details.\n+     *\n+     * @param instant  the Joda-Time millisecond instant to convert\n+     * @return the JDK millisecond instant with the same local time\n+     * @since 1.2\n+     */\n+    public long getMillisJDKKeepLocal(long instant) {\n+        return getMillisJDKKeepLocal(toTimeZone(), instant);\n+    }\n+\n+    /**\n+     * Gets the millisecond instant in the specified JDK <code>TimeZone</code>\n+     * keeping the same local time. You should typically pass in the\n+     * JDK zone that is returned by {@link #toTimeZone()}.\n+     * <p>\n+     * This method adjusts for time zone difference between the JDK and\n+     * Joda-Time zone rules. The aim of this method is to keep the same\n+     * local time but using the JDK time zone class. The result of this\n+     * method should be used to pass into a <code>Date</code>,\n+     * <code>Calendar</code> or other JDK class.\n+     * See the <a href=\"http://joda-time.sourceforge.net/jdk_conversion.html\">JDK conversion reference</a> for details.\n+     *\n+     * @param jdkZone  the JDK zone to convert to, normally as per toTimezone()\n+     * @param instant  the Joda-Time millisecond instant to convert\n+     * @return the JDK millisecond instant with the same local time\n+     * @since 1.2\n+     */\n+    public long getMillisJDKKeepLocal(TimeZone jdkZone, long instant) {\n+        if (jdkZone == null) {\n+            jdkZone = toTimeZone();\n+        }\n+        Integer val;\n+        if (OFFSET_METHOD == null) {\n+            if (jdkZone instanceof SimpleTimeZone) {\n+                SimpleTimeZone zone = (SimpleTimeZone) jdkZone;\n+                long offset = zone.getRawOffset();\n+                if (zone.inDaylightTime(new Date(instant)))  {\n+                    offset += zone.getDSTSavings();\n+                }\n+                long millisLocal = instant - offset;\n+                return millisLocal + getOffsetFromLocal(millisLocal);\n+            }\n+            return instant;\n+        } else {\n+            try {\n+                val = (Integer) OFFSET_METHOD.invoke(\n+                        jdkZone, new Object[] {new Long(instant)});\n+            } catch (IllegalAccessException ex) {\n+                return instant;\n+            } catch (InvocationTargetException ex) {\n+                return instant;\n+            }\n+        }\n+        long millisLocal = instant - val.intValue();\n+        return millisLocal + getOffsetFromLocal(millisLocal);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns true if this time zone has no transitions.\n      *\n      * @return true if no transitions\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n+import java.util.Date;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Set;\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testGetMillisJDKKeepLocal() {\n+        TimeZone jdkZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Paris\"));\n+            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);\n+            Date date = new Date(70, 0, 1, 2, 30, 0);  // same field values\n+            \n+            System.out.println(dt.getMillis());\n+            System.out.println(date.getTime());\n+            \n+            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(dt.getMillis()));\n+            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(PARIS.toTimeZone(), dt.getMillis()));\n+            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(null, dt.getMillis()));\n+            \n+            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);\n+            date = new Date(70, 0, 1, 2, 30, 0);  // same field values\n+            \n+            System.out.println(dt.getMillis());\n+            System.out.println(date.getTime());\n+            \n+            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(dt.getMillis()));\n+            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(LONDON.toTimeZone(), dt.getMillis()));\n+            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(null, dt.getMillis()));\n+            \n+        } finally {\n+            TimeZone.setDefault(jdkZone);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testIsFixed() {\n         DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n         assertEquals(false, zone.isFixed());\n         DateTime dt = new DateTime(2005, 5, 5, 20, 10, 15, 0, zone);\n         assertEquals(1115313015000L, dt.getMillis());\n     }\n+\n }", "timestamp": 1133725771, "metainfo": ""}