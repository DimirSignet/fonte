{"sha": "1cbee321d8b98ef84af8346d7270ed726c95176c", "log": "Remove deprecations  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n  */\n package org.joda.time;\n \n-import org.joda.time.chrono.BuddhistChronology;\n-import org.joda.time.chrono.CopticChronology;\n-import org.joda.time.chrono.GJChronology;\n-import org.joda.time.chrono.GregorianChronology;\n-import org.joda.time.chrono.ISOChronology;\n-import org.joda.time.chrono.JulianChronology;\n \n /**\n  * Chronology provides access to the individual date time fields for a\n public abstract class Chronology {\n \n     /**\n-     * Gets an instance of the ISOChronology in the default zone.\n-     * <p>\n-     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n-     * This chronology is the default, and is suitable for all normal datetime processing.\n-     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n-     * as it applies the modern Gregorian calendar rules before that date.\n-     *\n-     * @return the ISO chronology\n-     * @deprecated Use ISOChronology.getInstance()\n-     */\n-    public static Chronology getISO() {\n-        return ISOChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the ISOChronology in the UTC zone.\n-     * <p>\n-     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n-     * This chronology is the default, and is suitable for all normal datetime processing.\n-     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n-     * as it applies the modern Gregorian calendar rules before that date.\n-     *\n-     * @return the ISO chronology\n-     * @deprecated Use ISOChronology.getInstanceUTC()\n-     */\n-    public static Chronology getISOUTC() {\n-        return ISOChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the ISOChronology in the specified zone.\n-     * <p>\n-     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n-     * This chronology is the default, and is suitable for all normal datetime processing.\n-     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n-     * as it applies the modern Gregorian calendar rules before that date.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the ISO chronology\n-     * @deprecated Use ISOChronology.getInstance(zone)\n-     */\n-    public static Chronology getISO(DateTimeZone zone) {\n-        return ISOChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the GJChronology in the default zone.\n-     * <p>\n-     * {@link GJChronology} defines all fields using standard meanings.\n-     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n-     * The Gregorian calendar system is used after October 15, 1582, while the\n-     * Julian calendar system is used before.\n-     * <p>\n-     * Unlike <code>GregorianCalendar</code>, this chronology returns a year of -1\n-     * for 1 BCE, -2 for 2 BCE and so on. Thus there is no year zero.\n-     * <p>\n-     * This method uses the standard Julian to Gregorian cutover date of\n-     * October 15th 1582. If you require a cutover on a different date, then use\n-     * the factories on <code>GJChronology</code> itself.\n-     * <p>\n-     * When dealing solely with dates in the modern era, from 1600 onwards,\n-     * we recommend using ISOChronology, which is the default.\n-     *\n-     * @return the GJ chronology\n-     * @deprecated Use GJChronology.getInstance()\n-     */\n-    public static Chronology getGJ() {\n-        return GJChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the GJChronology in the UTC zone.\n-     * <p>\n-     * {@link GJChronology} defines all fields using standard meanings.\n-     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n-     * The Gregorian calendar system is used after October 15, 1582, while the\n-     * Julian calendar system is used before.\n-     * <p>\n-     * Unlike <code>GregorianCalendar</code>, this chronology returns a year of -1\n-     * for 1 BCE, -2 for 2 BCE and so on. Thus there is no year zero.\n-     * <p>\n-     * This method uses the standard Julian to Gregorian cutover date of\n-     * October 15th 1582. If you require a cutover on a different date, then use\n-     * the factories on <code>GJChronology</code> itself.\n-     * <p>\n-     * When dealing solely with dates in the modern era, from 1600 onwards,\n-     * we recommend using ISOChronology, which is the default.\n-     *\n-     * @return the GJ chronology\n-     * @deprecated Use GJChronology.getInstanceUTC()\n-     */\n-    public static Chronology getGJUTC() {\n-        return GJChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the GJChronology in the specified zone.\n-     * <p>\n-     * {@link GJChronology} defines all fields using standard meanings.\n-     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n-     * The Gregorian calendar system is used after October 15, 1582, while the\n-     * Julian calendar system is used before.\n-     * <p>\n-     * Unlike <code>GregorianCalendar</code>, this chronology returns a year of -1\n-     * for 1 BCE, -2 for 2 BCE and so on. Thus there is no year zero.\n-     * <p>\n-     * This method uses the standard Julian to Gregorian cutover date of\n-     * October 15th 1582. If you require a cutover on a different date, then use\n-     * the factories on <code>GJChronology</code> itself.\n-     * <p>\n-     * When dealing solely with dates in the modern era, from 1600 onwards,\n-     * we recommend using ISOChronology, which is the default.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the GJ chronology\n-     * @deprecated Use GJChronology.getInstance(zone)\n-     */\n-    public static Chronology getGJ(DateTimeZone zone) {\n-        return GJChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the GregorianChronology in the default zone.\n-     * <p>\n-     * {@link GregorianChronology} defines all fields using standard meanings.\n-     * It uses the Gregorian calendar rules <i>for all time</i> (proleptic)\n-     * thus it is NOT a replacement for <code>GregorianCalendar</code>.\n-     * For that purpose, you should use {@link #getGJ()}.\n-     * <p>\n-     * The Gregorian calendar system defines a leap year every four years,\n-     * except that every 100 years is not leap, but every 400 is leap.\n-     * <p>\n-     * Technically, this chronology is almost identical to the ISO chronology,\n-     * thus we recommend using ISOChronology instead, which is the default.\n-     *\n-     * @return the Gregorian chronology\n-     * @deprecated Use GregorianChronology.getInstance()\n-     */\n-    public static Chronology getGregorian() {\n-        return GregorianChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the GregorianChronology in the UTC zone.\n-     * <p>\n-     * {@link GregorianChronology} defines all fields using standard meanings.\n-     * It uses the Gregorian calendar rules <i>for all time</i> (proleptic)\n-     * thus it is NOT a replacement for <code>GregorianCalendar</code>.\n-     * For that purpose, you should use {@link #getGJ()}.\n-     * <p>\n-     * The Gregorian calendar system defines a leap year every four years,\n-     * except that every 100 years is not leap, but every 400 is leap.\n-     * <p>\n-     * Technically, this chronology is almost identical to the ISO chronology,\n-     * thus we recommend using ISOChronology instead, which is the default.\n-     *\n-     * @return the Gregorian chronology\n-     * @deprecated Use GregorianChronology.getInstanceUTC()\n-     */\n-    public static Chronology getGregorianUTC() {\n-        return GregorianChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the GregorianChronology in the specified zone.\n-     * <p>\n-     * {@link GregorianChronology} defines all fields using standard meanings.\n-     * It uses the Gregorian calendar rules <i>for all time</i> (proleptic)\n-     * thus it is NOT a replacement for <code>GregorianCalendar</code>.\n-     * For that purpose, you should use {@link #getGJ()}.\n-     * <p>\n-     * The Gregorian calendar system defines a leap year every four years,\n-     * except that every 100 years is not leap, but every 400 is leap.\n-     * <p>\n-     * Technically, this chronology is almost identical to the ISO chronology,\n-     * thus we recommend using ISOChronology instead, which is the default.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the Gregorian chronology\n-     * @deprecated Use GregorianChronology.getInstance(zone)\n-     */\n-    public static Chronology getGregorian(DateTimeZone zone) {\n-        return GregorianChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the JulianChronology in the default zone.\n-     * <p>\n-     * {@link JulianChronology} defines all fields using standard meanings.\n-     * It uses the Julian calendar rules <i>for all time</i> (proleptic).\n-     * The Julian calendar system defines a leap year every four years.\n-     *\n-     * @return the Julian chronology\n-     * @deprecated Use JulianChronology.getInstance()\n-     */\n-    public static Chronology getJulian() {\n-        return JulianChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the JulianChronology in the UTC zone.\n-     * <p>\n-     * {@link JulianChronology} defines all fields using standard meanings.\n-     * It uses the Julian calendar rules <i>for all time</i> (proleptic).\n-     * The Julian calendar system defines a leap year every four years.\n-     *\n-     * @return the Julian chronology\n-     * @deprecated Use JulianChronology.getInstanceUTC()\n-     */\n-    public static Chronology getJulianUTC() {\n-        return JulianChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the JulianChronology in the specified zone.\n-     * <p>\n-     * {@link JulianChronology} defines all fields using standard meanings.\n-     * It uses the Julian calendar rules <i>for all time</i> (proleptic).\n-     * The Julian calendar system defines a leap year every four years.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the Julian chronology\n-     * @deprecated Use JulianChronology.getInstance(zone)\n-     */\n-    public static Chronology getJulian(DateTimeZone zone) {\n-        return JulianChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the BuddhistChronology in the default zone.\n-     * <p>\n-     * {@link BuddhistChronology} defines all fields using standard meanings,\n-     * however the year is offset by 543. The chronology cannot be used before\n-     * year 1 in the Buddhist calendar.\n-     *\n-     * @return the Buddhist chronology\n-     * @deprecated Use BuddhistChronology.getInstance()\n-     */\n-    public static Chronology getBuddhist() {\n-        return BuddhistChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the BuddhistChronology in the UTC zone.\n-     * <p>\n-     * {@link BuddhistChronology} defines all fields using standard meanings,\n-     * however the year is offset by 543. The chronology cannot be used before\n-     * year 1 in the Buddhist calendar.\n-     *\n-     * @return the Buddhist chronology\n-     * @deprecated Use BuddhistChronology.getInstanceUTC()\n-     */\n-    public static Chronology getBuddhistUTC() {\n-        return BuddhistChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the BuddhistChronology in the specified zone.\n-     * <p>\n-     * {@link BuddhistChronology} defines all fields using standard meanings,\n-     * however the year is offset by 543. The chronology cannot be used before\n-     * year 1 in the Buddhist calendar.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the Buddhist chronology\n-     * @deprecated Use BuddhistChronology.getInstance(zone)\n-     */\n-    public static Chronology getBuddhist(DateTimeZone zone) {\n-        return BuddhistChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an instance of the CopticChronology in the default zone.\n-     * <p>\n-     * {@link CopticChronology} defines fields sensibly for the Coptic calendar system.\n-     * The Coptic calendar system defines every fourth year as leap.\n-     * The year is broken down into 12 months, each 30 days in length.\n-     * An extra period at the end of the year is either 5 or 6 days in length\n-     * and is returned as a 13th month.\n-     * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian).\n-     * The chronology cannot be used before the first Coptic year.\n-     *\n-     * @return the Coptic chronology\n-     * @deprecated Use CopticChronology.getInstance()\n-     */\n-    public static Chronology getCoptic() {\n-        return CopticChronology.getInstance();\n-    }\n-\n-    /**\n-     * Gets an instance of the CopticChronology in the UTC zone.\n-     * <p>\n-     * {@link CopticChronology} defines fields sensibly for the Coptic calendar system.\n-     * The Coptic calendar system defines every fourth year as leap.\n-     * The year is broken down into 12 months, each 30 days in length.\n-     * An extra period at the end of the year is either 5 or 6 days in length\n-     * and is returned as a 13th month.\n-     * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian).\n-     * The chronology cannot be used before the first Coptic year.\n-     *\n-     * @return the Coptic chronology\n-     * @deprecated Use CopticChronology.getInstanceUTC()\n-     */\n-    public static Chronology getCopticUTC() {\n-        return CopticChronology.getInstanceUTC();\n-    }\n-\n-    /**\n-     * Gets an instance of the CopticChronology in the specified zone.\n-     * <p>\n-     * {@link CopticChronology} defines fields sensibly for the Coptic calendar system.\n-     * The Coptic calendar system defines every fourth year as leap.\n-     * The year is broken down into 12 months, each 30 days in length.\n-     * An extra period at the end of the year is either 5 or 6 days in length\n-     * and is returned as a 13th month.\n-     * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian).\n-     * The chronology cannot be used before the first Coptic year.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return the Coptic chronology\n-     * @deprecated Use CopticChronology.getInstance(zone)\n-     */\n-    public static Chronology getCoptic(DateTimeZone zone) {\n-        return CopticChronology.getInstance(zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Returns the DateTimeZone that this Chronology operates in, or null if\n      * unspecified.\n      *\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n      * thus calling this method we really have no zone to 'retain' and\n      * hence expect to switch to the default zone.\n      * <p>\n-     * This method definition preserves compatability with earlier versions\n+     * This method definition preserves compatibility with earlier versions\n      * of Joda-Time.\n      *\n      * @return a DateTime using the same millis\n      * thus calling this method we really have no zone to 'retain' and\n      * hence expect to switch to the default zone.\n      * <p>\n-     * This method definition preserves compatability with earlier versions\n+     * This method is deprecated because it is a duplicate of {@link #toDateTime()}.\n+     * However, removing it would cause the superclass implementation to be used,\n+     * which would create silent bugs in any caller depending on this implementation.\n+     * As such, the method itself is not currently planned to be removed.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n      * of Joda-Time.\n      *\n      * @return a DateTime using the same millis with ISOChronology\n      * thus calling this method we really have no zone to 'retain' and\n      * hence expect to switch to the default zone.\n      * <p>\n-     * This method definition preserves compatability with earlier versions\n+     * This method definition preserves compatibility with earlier versions\n      * of Joda-Time.\n      *\n      * @return a MutableDateTime using the same millis\n      * thus calling this method we really have no zone to 'retain' and\n      * hence expect to switch to the default zone.\n      * <p>\n-     * This method definition preserves compatability with earlier versions\n+     * This method is deprecated because it is a duplicate of {@link #toMutableDateTime()}.\n+     * However, removing it would cause the superclass implementation to be used,\n+     * which would create silent bugs in any caller depending on this implementation.\n+     * As such, the method itself is not currently planned to be removed.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n      * of Joda-Time.\n      *\n      * @return a MutableDateTime using the same millis with ISOChronology\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this LocalDate to a full datetime at midnight using the default\n-     * time zone.\n-     * <p>\n-     * This method will throw an exception if the default time zone switches\n-     * to Daylight Savings Time at midnight and this LocalDate represents\n-     * that switchover date. The problem is that there is no such time as\n-     * midnight on the required date, and as such an exception is thrown.\n-     * <p>\n-     * This instance is immutable and unaffected by this method call.\n-     * \n-     * @return this date as a datetime at midnight\n-     * @deprecated Use {@link #toDateTimeAtStartOfDay()} which won't throw an exception\n-     */\n-    public DateTime toDateTimeAtMidnight() {\n-        return toDateTimeAtMidnight(null);\n-    }\n-\n-    /**\n-     * Converts this LocalDate to a full datetime at midnight using the\n-     * specified time zone.\n-     * <p>\n-     * This method will throw an exception if the time zone switches\n-     * to Daylight Savings Time at midnight and this LocalDate represents\n-     * that switchover date. The problem is that there is no such time as\n-     * midnight on the required date, and as such an exception is thrown.\n-     * <p>\n-     * This method uses the chronology from this instance plus the time zone\n-     * specified.\n-     * <p>\n-     * This instance is immutable and unaffected by this method call.\n-     *\n-     * @param zone  the zone to use, null means default zone\n-     * @return this date as a datetime at midnight\n-     * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception\n-     */\n-    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n-        zone = DateTimeUtils.getZone(zone);\n-        Chronology chrono = getChronology().withZone(zone);\n-        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Converts this LocalDate to a full datetime using the default time zone\n      * setting the date fields from this instance and the time fields from\n      * the current time.\n--- a/JodaTime/src/test/org/joda/time/TestChronology.java\n+++ b/JodaTime/src/test/org/joda/time/TestChronology.java\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n \n-    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+//    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     \n     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetISO() {\n-        assertEquals(ISOChronology.getInstance(), Chronology.getISO());\n-    }\n-\n-    public void testGetISOUTC() {\n-        assertEquals(ISOChronology.getInstanceUTC(), Chronology.getISOUTC());\n-    }\n-\n-    public void testGetISO_Zone() {\n-        assertEquals(ISOChronology.getInstance(PARIS), Chronology.getISO(PARIS));\n-        assertEquals(ISOChronology.getInstance(), Chronology.getISO(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetGJ() {\n-        assertEquals(GJChronology.getInstance(), Chronology.getGJ());\n-    }\n-\n-    public void testGetGJUTC() {\n-        assertEquals(GJChronology.getInstanceUTC(), Chronology.getGJUTC());\n-    }\n-\n-    public void testGetGJ_Zone() {\n-        assertEquals(GJChronology.getInstance(PARIS), Chronology.getGJ(PARIS));\n-        assertEquals(GJChronology.getInstance(), Chronology.getGJ(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetGregorian() {\n-        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian());\n-    }\n-\n-    public void testGetGregorianUTC() {\n-        assertEquals(GregorianChronology.getInstanceUTC(), Chronology.getGregorianUTC());\n-    }\n-\n-    public void testGetGregorian_Zone() {\n-        assertEquals(GregorianChronology.getInstance(PARIS), Chronology.getGregorian(PARIS));\n-        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetJulian() {\n-        assertEquals(JulianChronology.getInstance(), Chronology.getJulian());\n-    }\n-\n-    public void testGetJulianUTC() {\n-        assertEquals(JulianChronology.getInstanceUTC(), Chronology.getJulianUTC());\n-    }\n-\n-    public void testGetJulian_Zone() {\n-        assertEquals(JulianChronology.getInstance(PARIS), Chronology.getJulian(PARIS));\n-        assertEquals(JulianChronology.getInstance(), Chronology.getJulian(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetBuddhist() {\n-        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist());\n-    }\n-\n-    public void testGetBuddhistUTC() {\n-        assertEquals(BuddhistChronology.getInstanceUTC(), Chronology.getBuddhistUTC());\n-    }\n-\n-    public void testGetBuddhist_Zone() {\n-        assertEquals(BuddhistChronology.getInstance(PARIS), Chronology.getBuddhist(PARIS));\n-        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetCoptic() {\n-        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic());\n-    }\n-\n-    public void testGetCopticUTC() {\n-        assertEquals(CopticChronology.getInstanceUTC(), Chronology.getCopticUTC());\n-    }\n-\n-    public void testGetCoptic_Zone() {\n-        assertEquals(CopticChronology.getInstance(PARIS), Chronology.getCoptic(PARIS));\n-        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic(null));\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testEqualsHashCode_ISO() {\n         Chronology chrono1 = ISOChronology.getInstanceUTC();\n         Chronology chrono2 = ISOChronology.getInstanceUTC();\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeZoneCutover.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZoneCutover.java\n         assertEquals(\"2007-03-31\", date2.toString());\n     }\n \n-    public void test_LocalDate_toDateTimeAtMidnight_Gaza() {\n-        LocalDate date = new LocalDate(2007, 4, 1);\n-        try {\n-            date.toDateTimeAtMidnight(MOCK_GAZA);\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n-            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n-        }\n-    }\n-\n     public void test_LocalDate_toDateMidnight_Gaza() {\n         LocalDate date = new LocalDate(2007, 4, 1);\n         try {\n         \n         LocalDate date2 = new LocalDate(CUTOVER_TURK - 1, MOCK_TURK);\n         assertEquals(\"2007-03-31\", date2.toString());\n-    }\n-\n-    public void test_LocalDate_toDateTimeAtMidnight_Turk() {\n-        LocalDate date = new LocalDate(2007, 4, 1);\n-        try {\n-            date.toDateTimeAtMidnight(MOCK_TURK);\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n-            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n-        }\n     }\n \n     public void test_LocalDate_toDateMidnight_Turk() {\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n     private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n-    private static final int OFFSET = 1;\n+//    private static final int OFFSET = 1;\n     private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC();\n     private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n     private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);\n     private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);\n     private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();\n-    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+//    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n     private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n-    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n-    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+//    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n+//    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n     private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);\n     private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);\n     private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);\n-    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n+//    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n \n     /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */\n     private static long CUTOVER_GAZA = 1175378400000L;\n     private long TEST_TIME_NOW =\n             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n             \n-    private long TEST_TIME1 =\n-        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n-        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n-        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n-        \n-    private long TEST_TIME2 =\n-        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n-        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n-        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+//    private long TEST_TIME1 =\n+//        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+//        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+//        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+//        \n+//    private long TEST_TIME2 =\n+//        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+//        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+//        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n         \n     private DateTimeZone zone = null;\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDateTimeAtMidnight() {\n-        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n-        \n-        DateTime test = base.toDateTimeAtMidnight();\n-        check(base, 2005, 6, 9);\n-        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testToDateTimeAtMidnight_Zone() {\n-        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n-        \n-        DateTime test = base.toDateTimeAtMidnight(TOKYO);\n-        check(base, 2005, 6, 9);\n-        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n-    }\n-\n-    public void testToDateTimeAtMidnight_nullZone() {\n-        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n-        \n-        DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null);\n-        check(base, 2005, 6, 9);\n-        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testToDateTimeAtCurrentTime() {\n         LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);", "timestamp": 1257592845, "metainfo": ""}