{"sha": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb", "log": "Move to Java 5 with generics  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class DateTimeComparator implements Comparator, Serializable {\n+public class DateTimeComparator implements Comparator<Object>, Serializable {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -6097339773320178364L;\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n  * <p>\n  * The offset differs in the summer because of daylight saving time, or DST.\n- * The folowing definitions of time are generally used:\n+ * The following definitions of time are generally used:\n  * <ul>\n  * <li>UTC - The reference time.\n  * <li>Standard Time - The local time without a daylight saving time offset.\n     /** The instance that is providing time zone names. */\n     private static NameProvider cNameProvider;\n     /** The set of ID strings. */\n-    private static Set cAvailableIDs;\n+    private static Set<String> cAvailableIDs;\n     /** The default time zone. */\n     private static DateTimeZone cDefault;\n     /** A formatter for printing and parsing zones. */\n     private static DateTimeFormatter cOffsetFormatter;\n \n     /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n-    private static Map iFixedOffsetCache;\n+    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n \n     /** Cache of old zone IDs to new zone IDs */\n-    private static Map cZoneIdConversion;\n+    private static Map<String, String> cZoneIdConversion;\n \n     static {\n         setProvider0(null);\n      * <p>\n      * This factory is a convenient way of constructing zones with a fixed offset.\n      * The minutes value is always positive and in the range 0 to 59.\n-     * If constructed with the values (-2, 30), the resultiong zone is '-02:30'.\n+     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n      * \n      * @param hoursOffset  the offset in hours from UTC\n      * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n             return DateTimeZone.UTC;\n         }\n         if (iFixedOffsetCache == null) {\n-            iFixedOffsetCache = new HashMap();\n+            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n         }\n         DateTimeZone zone;\n-        Reference ref = (Reference) iFixedOffsetCache.get(id);\n+        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n         if (ref != null) {\n-            zone = (DateTimeZone) ref.get();\n+            zone = ref.get();\n             if (zone != null) {\n                 return zone;\n             }\n         }\n         zone = new FixedDateTimeZone(id, null, offset, offset);\n-        iFixedOffsetCache.put(id, new SoftReference(zone));\n+        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n         return zone;\n     }\n \n      * \n      * @return an unmodifiable Set of String IDs\n      */\n-    public static Set getAvailableIDs() {\n+    public static Set<String> getAvailableIDs() {\n         return cAvailableIDs;\n     }\n \n         if (provider == null) {\n             provider = getDefaultProvider();\n         }\n-        Set ids = provider.getAvailableIDs();\n+        Set<String> ids = provider.getAvailableIDs();\n         if (ids == null || ids.size() == 0) {\n             throw new IllegalArgumentException\n                 (\"The provider doesn't have any available ids\");\n      * @return the new style id, null if not found\n      */\n     private static synchronized String getConvertedId(String id) {\n-        Map map = cZoneIdConversion;\n+        Map<String, String> map = cZoneIdConversion;\n         if (map == null) {\n             // Backwards compatibility with TimeZone.\n-            map = new HashMap();\n+            map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n             map.put(\"MIT\", \"Pacific/Apia\");\n             map.put(\"HST\", \"Pacific/Honolulu\");\n             map.put(\"NST\", \"Pacific/Auckland\");\n             cZoneIdConversion = map;\n         }\n-        return (String) map.get(id);\n+        return map.get(id);\n     }\n \n     private static int parseOffset(String str) {\n--- a/JodaTime/src/java/org/joda/time/DurationField.java\n+++ b/JodaTime/src/java/org/joda/time/DurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public abstract class DurationField implements Comparable {\n+public abstract class DurationField implements Comparable<DurationField> {\n \n     /**\n      * Get the type of the field.\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object type is not supported\n      */\n-    public abstract int compareTo(Object durationField);\n+    public abstract int compareTo(DurationField durationField);\n \n     /**\n      * Returns a localized unit name of this field, using the given value as an\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     /** The index of the dayOfMonth field in the field array */\n     private static final int DAY_OF_MONTH = 2;\n     /** Set of known duration types. */\n-    private static final Set DATE_DURATION_TYPES = new HashSet();\n+    private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\n     static {\n         DATE_DURATION_TYPES.add(DurationFieldType.days());\n         DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n      *  or if it has field types that don't match\n      * @throws NullPointerException if the partial is null\n      */\n-    public int compareTo(Object partial) {\n+    public int compareTo(ReadablePartial partial) {\n         // override to perform faster\n         if (this == partial) {\n             return 0;\n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      *  or if it has field types that don't match\n      * @throws NullPointerException if the partial is null\n      */\n-    public int compareTo(Object partial) {\n+    public int compareTo(ReadablePartial partial) {\n         // override to perform faster\n         if (this == partial) {\n             return 0;\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     /** The index of the millisOfSecond field in the field array */\n     private static final int MILLIS_OF_SECOND = 3;\n     /** Set of known duration types. */\n-    private static final Set TIME_DURATION_TYPES = new HashSet();\n+    private static final Set<DurationFieldType> TIME_DURATION_TYPES = new HashSet<DurationFieldType>();\n     static {\n         TIME_DURATION_TYPES.add(DurationFieldType.millis());\n         TIME_DURATION_TYPES.add(DurationFieldType.seconds());\n      *  or if it has field types that don't match\n      * @throws NullPointerException if the partial is null\n      */\n-    public int compareTo(Object partial) {\n+    public int compareTo(ReadablePartial partial) {\n         // override to perform faster\n         if (this == partial) {\n             return 0;\n--- a/JodaTime/src/java/org/joda/time/Partial.java\n+++ b/JodaTime/src/java/org/joda/time/Partial.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             }\n             f = new DateTimeFormatter[2];\n             try {\n-                List list = new ArrayList(Arrays.asList(iTypes));\n+                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                 f[0] = ISODateTimeFormat.forFields(list, true, false);\n                 if (list.size() == 0) {\n                     f[1] = f[0];\n--- a/JodaTime/src/java/org/joda/time/PeriodType.java\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = 2274324892792009998L;\n \n     /** Cache of all the known types. */\n-    private static final Map cTypes = new HashMap(32);\n+    private static final Map<PeriodType, Object> cTypes = new HashMap<PeriodType, Object>(32);\n \n     static int YEAR_INDEX = 0;\n     static int MONTH_INDEX = 1;\n                 throw new IllegalArgumentException(\"Types array must not contain null\");\n             }\n         }\n-        Map cache = cTypes;\n-        if (cTypes.isEmpty()) {\n+        Map<PeriodType, Object> cache = cTypes;\n+        if (cache.isEmpty()) {\n             cache.put(standard(), standard());\n             cache.put(yearMonthDayTime(), yearMonthDayTime());\n             cache.put(yearMonthDay(), yearMonthDay());\n             throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\n         }\n         PeriodType type = standard();\n-        List list = new ArrayList(Arrays.asList(types));\n+        List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n         if (list.remove(DurationFieldType.years()) == false) {\n             type = type.withYearsRemoved();\n         }\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public interface ReadableDuration extends Comparable {\n+public interface ReadableDuration extends Comparable<ReadableDuration> {\n \n     /**\n      * Gets the total length of this duration in milliseconds.\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the given object is not supported\n      */\n-    int compareTo(Object obj);\n+    int compareTo(ReadableDuration obj);\n \n     /**\n      * Is the length of this duration equal to the duration passed in.\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public interface ReadableInstant extends Comparable {\n+public interface ReadableInstant extends Comparable<ReadableInstant> {\n \n     /**\n      * Get the value as the number of milliseconds since\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object type is not supported\n      */\n-    int compareTo(Object readableInstant);\n+    int compareTo(ReadableInstant readableInstant);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.Duration;\n import org.joda.time.Period;\n import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n import org.joda.time.format.FormatUtils;\n \n /**\n     /**\n      * Compares this duration with the specified duration based on length.\n      *\n-     * @param obj  a duration to check against\n+     * @param other  a duration to check against\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the given object is not supported\n      */\n-    public int compareTo(Object obj) {\n-        // Comparable contract means we cannot handle null or other types gracefully\n-        ReadableDuration thisDuration = (ReadableDuration) this;\n-        ReadableDuration otherDuration = (ReadableDuration) obj;\n-        \n-        long thisMillis = thisDuration.getMillis();\n-        long otherMillis = otherDuration.getMillis();\n+    public int compareTo(ReadableDuration other) {\n+        long thisMillis = this.getMillis();\n+        long otherMillis = other.getMillis();\n         \n         // cannot do (thisMillis - otherMillis) as it can overflow\n         if (thisMillis < otherMillis) {\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * <p>\n      * All ReadableInstant instances are accepted.\n      *\n-     * @param instant  a readable instant to check against\n+     * @param other  a readable instant to check against\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object type is not supported\n      */\n-    public int compareTo(Object instant) {\n-        if (this == instant) {\n+    public int compareTo(ReadableInstant other) {\n+        if (this == other) {\n             return 0;\n         }\n         \n-        ReadableInstant otherInstant = (ReadableInstant) instant;\n-        \n-        long otherMillis = otherInstant.getMillis();\n+        long otherMillis = other.getMillis();\n         long thisMillis = getMillis();\n         \n         // cannot do (thisMillis - otherMillis) as can overflow\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @since 1.0\n  */\n public abstract class AbstractPartial\n-        implements ReadablePartial, Comparable {\n+        implements ReadablePartial, Comparable<ReadablePartial> {\n \n     //-----------------------------------------------------------------------\n     /**\n      * The cause of this problem is that ReadablePartial doesn't define\n      * the compareTo() method, however we can't change that until v2.0.\n      *\n-     * @param partial  an object to check against\n+     * @param other  an object to check against\n      * @return negative if this is less, zero if equal, positive if greater\n      * @throws ClassCastException if the partial is the wrong class\n      *  or if it has field types that don't match\n      * @throws NullPointerException if the partial is null\n      * @since 1.1\n      */\n-    public int compareTo(Object partial) {\n-        if (this == partial) {\n+    public int compareTo(ReadablePartial other) {\n+        if (this == other) {\n             return 0;\n         }\n-        ReadablePartial other = (ReadablePartial) partial;\n         if (size() != other.size()) {\n             throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n         }\n--- a/JodaTime/src/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseSingleFieldPeriod.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @since 1.4\n  */\n public abstract class BaseSingleFieldPeriod\n-        implements ReadablePeriod, Comparable, Serializable {\n+        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n \n     /** Serialization version. */\n     private static final long serialVersionUID = 9386874258972L;\n      * @throws NullPointerException if the other period is null\n      * @throws ClassCastException if the other period is of a different type\n      */\n-    public int compareTo(Object other) {\n+    public int compareTo(BaseSingleFieldPeriod other) {\n         if (other.getClass() != getClass()) {\n             throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n         }\n-        int otherValue = ((BaseSingleFieldPeriod) other).getValue();\n+        int otherValue = other.getValue();\n         int thisValue = getValue();\n         if (thisValue > otherValue) {\n             return 1;\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final int BUDDHIST_OFFSET = 543;\n \n     /** Cache of zone to chronology */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, BuddhistChronology> cCache = new HashMap<DateTimeZone, BuddhistChronology>();\n \n     /** UTC instance of the chronology */\n     private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n         if (zone == null) {\n             zone = DateTimeZone.getDefault();\n         }\n-        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);\n+        BuddhistChronology chrono = cCache.get(zone);\n         if (chrono == null) {\n             // First create without a lower limit.\n             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final int MAX_YEAR = 292272708;\n \n     /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, CopticChronology[]> cCache = new HashMap<DateTimeZone, CopticChronology[]>();\n \n     /** Singleton instance of a UTC CopticChronology */\n     private static final CopticChronology INSTANCE_UTC;\n         }\n         CopticChronology chrono;\n         synchronized (cCache) {\n-            CopticChronology[] chronos = (CopticChronology[]) cCache.get(zone);\n+            CopticChronology[] chronos = cCache.get(zone);\n             if (chronos == null) {\n                 chronos = new CopticChronology[7];\n                 cCache.put(zone, chronos);\n--- a/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final int MAX_YEAR = 292272984;\n \n     /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, EthiopicChronology[]> cCache = new HashMap<DateTimeZone, EthiopicChronology[]>();\n \n     /** Singleton instance of a UTC EthiopicChronology */\n     private static final EthiopicChronology INSTANCE_UTC;\n         }\n         EthiopicChronology chrono;\n         synchronized (cCache) {\n-            EthiopicChronology[] chronos = (EthiopicChronology[]) cCache.get(zone);\n+            EthiopicChronology[] chronos = cCache.get(zone);\n             if (chronos == null) {\n                 chronos = new EthiopicChronology[7];\n                 cCache.put(zone, chronos);\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n \n     /** Cache of zone to chronology list */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n \n     /**\n      * Factory method returns instances of the default GJ cutover\n \n         GJChronology chrono;\n \n-        ArrayList chronos = (ArrayList)cCache.get(zone);\n+        ArrayList<GJChronology> chronos = cCache.get(zone);\n         if (chronos == null) {\n-            chronos = new ArrayList(2);\n+            chronos = new ArrayList<GJChronology>(2);\n             cCache.put(zone, chronos);\n         } else {\n             for (int i=chronos.size(); --i>=0; ) {\n-                chrono = (GJChronology)chronos.get(i);\n+                chrono = chronos.get(i);\n                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                     cutoverInstant.equals(chrono.getGregorianCutover())) {\n                     \n--- a/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];\n \n-    private static WeakHashMap cCache = new WeakHashMap();\n+    private static WeakHashMap<Locale, GJLocaleSymbols> cCache = new WeakHashMap<Locale, GJLocaleSymbols>();\n \n     public static GJLocaleSymbols forLocale(Locale locale) {\n         if (locale == null) {\n             return symbols;\n         }\n         synchronized (cCache) {\n-            symbols = (GJLocaleSymbols) cCache.get(locale);\n+            symbols = cCache.get(locale);\n             if (symbols == null) {\n                 symbols = new GJLocaleSymbols(locale);\n                 cCache.put(locale, symbols);\n         return a;\n     }\n \n-    private static void addSymbols(TreeMap map, String[] symbols, Integer[] integers) {\n+    private static void addSymbols(TreeMap<String, Integer> map, String[] symbols, Integer[] integers) {\n         for (int i=symbols.length; --i>=0; ) {\n             String symbol = symbols[i];\n             if (symbol != null) {\n         }\n     }\n \n-    private static void addNumerals(TreeMap map, int start, int end, Integer[] integers) {\n+    private static void addNumerals(TreeMap<String, Integer> map, int start, int end, Integer[] integers) {\n         for (int i=start; i<=end; i++) {\n             map.put(String.valueOf(i).intern(), integers[i]);\n         }\n         return max;\n     }\n \n-    private final WeakReference iLocale;\n+    private final WeakReference<Locale> iLocale;\n \n     private final String[] iEras;\n     private final String[] iDaysOfWeek;\n     private final String[] iShortMonths;\n     private final String[] iHalfday;\n \n-    // These map Strings to Integers.\n-    private final TreeMap iParseEras;\n-    private final TreeMap iParseDaysOfWeek;\n-    private final TreeMap iParseMonths;\n+    private final TreeMap<String, Integer> iParseEras;\n+    private final TreeMap<String, Integer> iParseDaysOfWeek;\n+    private final TreeMap<String, Integer> iParseMonths;\n \n     private final int iMaxEraLength;\n     private final int iMaxDayOfWeekLength;\n      * @param locale must not be null\n      */\n     private GJLocaleSymbols(Locale locale) {\n-        iLocale = new WeakReference(locale);\n+        iLocale = new WeakReference<Locale>(locale);\n         \n         DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale);\n         \n             integers[i] = new Integer(i);\n         }\n \n-        iParseEras = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+        iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n         addSymbols(iParseEras, iEras, integers);\n         if (\"en\".equals(locale.getLanguage())) {\n             // Include support for parsing \"BCE\" and \"CE\" if the language is\n             iParseEras.put(\"CE\", integers[1]);\n         }\n \n-        iParseDaysOfWeek = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+        iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n         addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers);\n         addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers);\n         addNumerals(iParseDaysOfWeek, 1, 7, integers);\n \n-        iParseMonths = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+        iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n         addSymbols(iParseMonths, iMonths, integers);\n         addSymbols(iParseMonths, iShortMonths, integers);\n         addNumerals(iParseMonths, 1, 12, integers);\n     }\n \n     public int eraTextToValue(String text) {\n-        Integer era = (Integer) iParseEras.get(text);\n+        Integer era = iParseEras.get(text);\n         if (era != null) {\n             return era.intValue();\n         }\n     }\n \n     public int monthOfYearTextToValue(String text) {\n-        Integer month = (Integer) iParseMonths.get(text);\n+        Integer month = iParseMonths.get(text);\n         if (month != null) {\n             return month.intValue();\n         }\n     }\n \n     public int dayOfWeekTextToValue(String text) {\n-        Integer day = (Integer) iParseDaysOfWeek.get(text);\n+        Integer day = iParseDaysOfWeek.get(text);\n         if (day != null) {\n             return day.intValue();\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final GregorianChronology INSTANCE_UTC;\n \n     /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, GregorianChronology[]> cCache = new HashMap<DateTimeZone, GregorianChronology[]>();\n \n     static {\n         INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n         }\n         GregorianChronology chrono;\n         synchronized (cCache) {\n-            GregorianChronology[] chronos = (GregorianChronology[]) cCache.get(zone);\n+            GregorianChronology[] chronos = cCache.get(zone);\n             if (chronos == null) {\n                 chronos = new GregorianChronology[7];\n                 cCache.put(zone, chronos);\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final ISOChronology[] cFastCache;\n \n     /** Cache of zone to chronology */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, ISOChronology> cCache = new HashMap<DateTimeZone, ISOChronology>();\n     static {\n         cFastCache = new ISOChronology[FAST_CACHE_SIZE];\n         INSTANCE_UTC = new ISOChronology(GregorianChronology.getInstanceUTC());\n             return chrono;\n         }\n         synchronized (cCache) {\n-            chrono = (ISOChronology) cCache.get(zone);\n+            chrono = cCache.get(zone);\n             if (chrono == null) {\n                 chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                 cCache.put(zone, chrono);\n--- a/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long MILLIS_PER_CYCLE = ((19L * 354L + 11L * 355L) * DateTimeConstants.MILLIS_PER_DAY);\n \n     /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, IslamicChronology[]> cCache = new HashMap<DateTimeZone, IslamicChronology[]>();\n \n     /** Singleton instance of a UTC IslamicChronology */\n     private static final IslamicChronology INSTANCE_UTC;\n         }\n         IslamicChronology chrono;\n         synchronized (cCache) {\n-            IslamicChronology[] chronos = (IslamicChronology[]) cCache.get(zone);\n+            IslamicChronology[] chronos = cCache.get(zone);\n             if (chronos == null) {\n                 chronos = new IslamicChronology[4];\n                 cCache.put(zone, chronos);\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final JulianChronology INSTANCE_UTC;\n \n     /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n+    private static final Map<DateTimeZone, JulianChronology[]> cCache = new HashMap<DateTimeZone, JulianChronology[]>();\n \n     static {\n         INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n         }\n         JulianChronology chrono;\n         synchronized (cCache) {\n-            JulianChronology[] chronos = (JulianChronology[]) cCache.get(zone);\n+            JulianChronology[] chronos = cCache.get(zone);\n             if (chronos == null) {\n                 chronos = new JulianChronology[7];\n                 cCache.put(zone, chronos);\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     protected void assemble(Fields fields) {\n         // Keep a local cache of converted fields so as not to create redundant\n         // objects.\n-        HashMap converted = new HashMap();\n+        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n \n         // Convert duration fields...\n \n         fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n     }\n \n-    private DurationField convertField(DurationField field, HashMap converted) {\n+    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n         if (field == null || !field.isSupported()) {\n             return field;\n         }\n         return limitField;\n     }\n \n-    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n+    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n         if (field == null || !field.isSupported()) {\n             return field;\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n /*\n- *  Copyright 2001-2008 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     protected void assemble(Fields fields) {\n         // Keep a local cache of converted fields so as not to create redundant\n         // objects.\n-        HashMap converted = new HashMap();\n+        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n \n         // Convert duration fields...\n \n         fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n     }\n \n-    private DurationField convertField(DurationField field, HashMap converted) {\n+    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n         if (field == null || !field.isSupported()) {\n             return field;\n         }\n         return zonedField;\n     }\n \n-    private DateTimeField convertField(DateTimeField field, HashMap converted) {\n+    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n         if (field == null || !field.isSupported()) {\n             return field;\n         }\n--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return Calendar.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return Calendar.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/Converter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/Converter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * @since 1.0\n  */\n public interface Converter {\n+\n     /**\n      * Returns the object type that this converter supports, which may\n      * specified by a class, superclass, abstract class, interface, or null.\n      * \n      * @return the object type that this converter supports\n      */\n-    Class getSupportedType();\n+    Class<?> getSupportedType();\n+\n }\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterSet.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * @throws IllegalStateException if multiple converters match the type\n      * equally well\n      */\n-    Converter select(Class type) throws IllegalStateException {\n+    Converter select(Class<?> type) throws IllegalStateException {\n         // Check the hashtable first.\n         Entry[] entries = iSelectEntries;\n         int length = entries.length;\n      * Returns the closest matching converter for the given type, but not very\n      * efficiently.\n      */\n-    private static Converter selectSlow(ConverterSet set, Class type) {\n+    private static Converter selectSlow(ConverterSet set, Class<?> type) {\n         Converter[] converters = set.iConverters;\n         int length = converters.length;\n         Converter converter;\n \n         for (int i=length; --i>=0; ) {\n             converter = converters[i];\n-            Class supportedType = converter.getSupportedType();\n+            Class<?> supportedType = converter.getSupportedType();\n \n             if (supportedType == type) {\n                 // Exact match.\n         // Eliminate supertypes.\n         for (int i=length; --i>=0; ) {\n             converter = converters[i];\n-            Class supportedType = converter.getSupportedType();\n+            Class<?> supportedType = converter.getSupportedType();\n             for (int j=length; --j>=0; ) {\n                 if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n                     // Eliminate supertype.\n         msg.append(\"\\\" from remaining set: \");\n         for (int i=0; i<length; i++) {\n             converter = converters[i];\n-            Class supportedType = converter.getSupportedType();\n+            Class<?> supportedType = converter.getSupportedType();\n \n             msg.append(converter.getClass().getName());\n             msg.append('[');\n     }\n \n     static class Entry {\n-        final Class iType;\n+        final Class<?> iType;\n         final Converter iConverter;\n \n-        Entry(Class type, Converter converter) {\n+        Entry(Class<?> type, Converter converter) {\n             iType = type;\n             iConverter = converter;\n         }\n--- a/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return Date.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return Date.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return Long.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return Long.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return null\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return null;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return ReadableDuration.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return ReadableDuration.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return ReadableInstant.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return ReadableInstant.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     /**\n      * Returns ReadableInterval.class.\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return ReadableInterval.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/ReadablePartialConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadablePartialConverter.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return ReadableInstant.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return ReadablePartial.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return ReadablePeriod.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return ReadablePeriod.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * \n      * @return String.class\n      */\n-    public Class getSupportedType() {\n+    public Class<?> getSupportedType() {\n         return String.class;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/BaseDurationField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n package org.joda.time.field;\n \n import java.io.Serializable;\n+\n import org.joda.time.DurationField;\n import org.joda.time.DurationFieldType;\n \n     }\n \n     //------------------------------------------------------------------------\n-    public int compareTo(Object durationField) {\n-        DurationField otherField = (DurationField) durationField;\n+    public int compareTo(DurationField otherField) {\n         long otherMillis = otherField.getUnitMillis();\n         long thisMillis = getUnitMillis();\n         // cannot do (thisMillis - otherMillis) as can overflow\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n package org.joda.time.field;\n \n import java.io.Serializable;\n+\n import org.joda.time.DurationField;\n import org.joda.time.DurationFieldType;\n \n         return iField.getUnitMillis();\n     }\n \n-    public int compareTo(Object durationField) {\n+    public int compareTo(DurationField durationField) {\n         return iField.compareTo(durationField);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/MillisDurationField.java\n+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     }\n \n     //------------------------------------------------------------------------\n-    public int compareTo(Object durationField) {\n-        DurationField otherField = (DurationField) durationField;\n+    public int compareTo(DurationField otherField) {\n         long otherMillis = otherField.getUnitMillis();\n         long thisMillis = getUnitMillis();\n         // cannot do (thisMillis - otherMillis) as can overflow\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = -1934618396111902255L;\n \n     /** The cache of unsupported datetime field instances */\n-    private static HashMap cCache;\n+    private static HashMap<DateTimeFieldType, UnsupportedDateTimeField> cCache;\n \n     /**\n      * Gets an instance of UnsupportedDateTimeField for a specific named field.\n \n         UnsupportedDateTimeField field;\n         if (cCache == null) {\n-            cCache = new HashMap(7);\n+            cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7);\n             field = null;\n         } else {\n-            field = (UnsupportedDateTimeField)cCache.get(type);\n+            field = cCache.get(type);\n             if (field != null && field.getDurationField() != durationField) {\n                 field = null;\n             }\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n import java.io.Serializable;\n import java.util.HashMap;\n+\n import org.joda.time.DurationField;\n import org.joda.time.DurationFieldType;\n \n     private static final long serialVersionUID = -6390301302770925357L;\n \n     /** The cache of unsupported duration field instances */\n-    private static HashMap cCache;\n+    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n \n     /**\n      * Gets an instance of UnsupportedDurationField for a specific named field.\n     public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n         UnsupportedDurationField field;\n         if (cCache == null) {\n-            cCache = new HashMap(7);\n+            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n             field = null;\n         } else {\n-            field = (UnsupportedDurationField) cCache.get(type);\n+            field = cCache.get(type);\n         }\n         if (field == null) {\n             field = new UnsupportedDurationField(type);\n      *\n      * @return zero always\n      */\n-    public int compareTo(Object durationField) {\n+    public int compareTo(DurationField durationField) {\n         return 0;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     static final int DATETIME = 2;\n \n     /** Maps patterns to formatters, patterns don't vary by locale. */\n-    private static final Map cPatternedCache = new HashMap(7);\n+    private static final Map<String, DateTimeFormatter> cPatternedCache = new HashMap<String, DateTimeFormatter>(7);\n     /** Maps patterns to formatters, patterns don't vary by locale. */\n     private static final DateTimeFormatter[] cStyleCache = new DateTimeFormatter[25];\n \n         }\n         DateTimeFormatter formatter = null;\n         synchronized (cPatternedCache) {\n-            formatter = (DateTimeFormatter) cPatternedCache.get(pattern);\n+            formatter = cPatternedCache.get(pattern);\n             if (formatter == null) {\n                 DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                 parsePatternTo(builder, pattern);\n     static class StyleFormatter\n             implements DateTimePrinter, DateTimeParser {\n \n-        private static final Map cCache = new HashMap();  // manual sync\n+        private static final Map<String, DateTimeFormatter> cCache = new HashMap<String, DateTimeFormatter>();  // manual sync\n         \n         private final int iDateStyle;\n         private final int iTimeStyle;\n             String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();\n             DateTimeFormatter f = null;\n             synchronized (cCache) {\n-                f = (DateTimeFormatter) cCache.get(key);\n+                f = cCache.get(key);\n                 if (f == null) {\n                     String pattern = getPattern(locale);\n                     f = DateTimeFormat.forPattern(pattern);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n public class DateTimeFormatterBuilder {\n \n     /** Array of printers and parsers (alternating). */\n-    private ArrayList iElementPairs;\n+    private ArrayList<Object> iElementPairs;\n     /** Cache of the last returned formatter. */\n     private Object iFormatter;\n \n      */\n     public DateTimeFormatterBuilder() {\n         super();\n-        iElementPairs = new ArrayList();\n+        iElementPairs = new ArrayList<Object>();\n     }\n \n     //-----------------------------------------------------------------------\n     static class TextField\n             implements DateTimePrinter, DateTimeParser {\n \n-        private static Map cParseCache = new HashMap();\n+        private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =\n+                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();\n         private final DateTimeFieldType iFieldType;\n         private final boolean iShort;\n \n             return estimatePrintedLength();\n         }\n \n+        @SuppressWarnings(\"unchecked\")\n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             Locale locale = bucket.getLocale();\n             // handle languages which might have non ASCII A-Z or punctuation\n             // bug 1788282\n-            Set validValues = null;\n+            Set<String> validValues = null;\n             int maxLength = 0;\n             synchronized (cParseCache) {\n-                Map innerMap = (Map) cParseCache.get(locale);\n+                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                 if (innerMap == null) {\n-                    innerMap = new HashMap();\n+                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                     cParseCache.put(locale, innerMap);\n                 }\n-                Object[] array = (Object[]) innerMap.get(iFieldType);\n+                Object[] array = innerMap.get(iFieldType);\n                 if (array == null) {\n-                    validValues = new HashSet(32);\n+                    validValues = new HashSet<String>(32);\n                     MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                     Property property = dt.property(iFieldType);\n                     int min = property.getMinimumValueOverall();\n                     array = new Object[] {validValues, new Integer(maxLength)};\n                     innerMap.put(iFieldType, array);\n                 } else {\n-                    validValues = (Set) array[0];\n+                    validValues = (Set<String>) array[0];\n                     maxLength = ((Integer) array[1]).intValue();\n                 }\n             }\n         private final int iPrintedLengthEstimate;\n         private final int iParsedLengthEstimate;\n \n-        Composite(List elementPairs) {\n+        Composite(List<Object> elementPairs) {\n             super();\n \n-            List printerList = new ArrayList();\n-            List parserList = new ArrayList();\n+            List<Object> printerList = new ArrayList<Object>();\n+            List<Object> parserList = new ArrayList<Object>();\n \n             decompose(elementPairs, printerList, parserList);\n \n          * Processes the element pairs, putting results into the given printer\n          * and parser lists.\n          */\n-        private void decompose(List elementPairs, List printerList, List parserList) {\n+        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n             int size = elementPairs.size();\n             for (int i=0; i<size; i+=2) {\n                 Object element = elementPairs.get(i);\n             }\n         }\n \n-        private void addArrayToList(List list, Object[] array) {\n+        private void addArrayToList(List<Object> list, Object[] array) {\n             if (array != null) {\n                 for (int i=0; i<array.length; i++) {\n                     list.add(array[i]);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * java.util.Arrays is called, which will perform a merge sort, which is\n      * faster than insertion sort on large lists.\n      * <p>\n-     * The end result is much greater performace when computeMillis is called.\n+     * The end result is much greater performance when computeMillis is called.\n      * Since the amount of saved fields is small, the insertion sort is a\n      * better choice. Additional performance is gained since there is no extra\n      * array allocation and copying. Also, the insertion sort here does not\n      * perform any casting operations. The version in java.util.Arrays performs\n      * casts within the insertion sort loop.\n      */\n-    private static void sort(Comparable[] array, int high) {\n+    private static void sort(SavedField[] array, int high) {\n         if (high > 10) {\n             Arrays.sort(array, 0, high);\n         } else {\n             for (int i=0; i<high; i++) {\n                 for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n-                    Comparable t = array[j];\n+                    SavedField t = array[j];\n                     array[j] = array[j-1];\n                     array[j-1] = t;\n                 }\n         }\n     }\n     \n-    static class SavedField implements Comparable {\n+    static class SavedField implements Comparable<SavedField> {\n         final DateTimeField iField;\n         final int iValue;\n         final String iText;\n          * null is considered infinite. If the ranges match, then the field\n          * with the longer duration is ordered first.\n          */\n-        public int compareTo(Object obj) {\n-            DateTimeField other = ((SavedField)obj).iField;\n+        public int compareTo(SavedField obj) {\n+            DateTimeField other = obj.iField;\n             int result = compareReverse\n                 (iField.getRangeDurationField(), other.getRangeDurationField());\n             if (result != 0) {\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n /*\n- *  Copyright 2001-2006,2008 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * @since 1.1\n      */\n     public static DateTimeFormatter forFields(\n-        Collection fields,\n+        Collection<DateTimeFieldType> fields,\n         boolean extended,\n         boolean strictISO) {\n         \n         if (fields == null || fields.size() == 0) {\n             throw new IllegalArgumentException(\"The fields must not be null or empty\");\n         }\n-        Set workingFields = new HashSet(fields);\n+        Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);\n         int inputSize = workingFields.size();\n         boolean reducedPrec = false;\n         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n      */\n     private static boolean dateByMonth(\n         DateTimeFormatterBuilder bld,\n-        Collection fields,\n+        Collection<DateTimeFieldType> fields,\n         boolean extended,\n         boolean strictISO) {\n         \n      */\n     private static boolean dateByOrdinal(\n         DateTimeFormatterBuilder bld,\n-        Collection fields,\n+        Collection<DateTimeFieldType> fields,\n         boolean extended,\n         boolean strictISO) {\n         \n      */\n     private static boolean dateByWeek(\n         DateTimeFormatterBuilder bld,\n-        Collection fields,\n+        Collection<DateTimeFieldType> fields,\n         boolean extended,\n         boolean strictISO) {\n         \n      */\n     private static void time(\n         DateTimeFormatterBuilder bld,\n-        Collection fields,\n+        Collection<DateTimeFieldType> fields,\n         boolean extended,\n         boolean strictISO,\n         boolean reducedPrec,\n      * @param strictISO  true if only ISO formats allowed\n      * @since 1.1\n      */\n-    private static void checkNotStrictISO(Collection fields, boolean strictISO) {\n+    private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) {\n         if (strictISO) {\n             throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\n         }\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private PeriodFieldAffix iPrefix;\n \n     // List of Printers and Parsers used to build a final formatter.\n-    private List iElementPairs;\n+    private List<Object> iElementPairs;\n     /** Set to true if the formatter is not a printer. */\n     private boolean iNotPrinter;\n     /** Set to true if the formatter is not a parser. */\n         iRejectSignedValues = false;\n         iPrefix = null;\n         if (iElementPairs == null) {\n-            iElementPairs = new ArrayList();\n+            iElementPairs = new ArrayList<Object>();\n         } else {\n             iElementPairs.clear();\n         }\n         clearPrefix();\n         \n         // optimise zero formatter case\n-        List pairs = iElementPairs;\n+        List<Object> pairs = iElementPairs;\n         if (pairs.size() == 0) {\n             if (useAfter && useBefore == false) {\n                 Separator separator = new Separator(\n     }\n \n     //-----------------------------------------------------------------------\n-    private static PeriodFormatter toFormatter(List elementPairs, boolean notPrinter, boolean notParser) {\n+    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n         if (notPrinter && notParser) {\n             throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n         }\n         }\n     }\n \n-    private static Object[] createComposite(List elementPairs) {\n+    private static Object[] createComposite(List<Object> elementPairs) {\n         switch (elementPairs.size()) {\n             case 0:\n                 return new Object[] {Literal.EMPTY, Literal.EMPTY};\n                 iParsedForms = new String[] {text};\n             } else {\n                 // Filter and reverse sort the parsed forms.\n-                TreeSet parsedSet = new TreeSet(String.CASE_INSENSITIVE_ORDER);\n+                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                 parsedSet.add(text);\n                 parsedSet.add(finalText);\n                 if (variants != null) {\n                         parsedSet.add(variants[i]);\n                     }\n                 }\n-                ArrayList parsedList = new ArrayList(parsedSet);\n+                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                 Collections.reverse(parsedList);\n-                iParsedForms = (String[]) parsedList.toArray(new String[parsedList.size()]);\n+                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n             }\n \n             iBeforePrinter = beforePrinter;\n         private final PeriodPrinter[] iPrinters;\n         private final PeriodParser[] iParsers;\n \n-        Composite(List elementPairs) {\n-            List printerList = new ArrayList();\n-            List parserList = new ArrayList();\n+        Composite(List<Object> elementPairs) {\n+            List<Object> printerList = new ArrayList<Object>();\n+            List<Object> parserList = new ArrayList<Object>();\n \n             decompose(elementPairs, printerList, parserList);\n \n             if (printerList.size() <= 0) {\n                 iPrinters = null;\n             } else {\n-                iPrinters = (PeriodPrinter[]) printerList.toArray(\n+                iPrinters = printerList.toArray(\n                         new PeriodPrinter[printerList.size()]);\n             }\n \n             if (parserList.size() <= 0) {\n                 iParsers = null;\n             } else {\n-                iParsers = (PeriodParser[]) parserList.toArray(\n+                iParsers = parserList.toArray(\n                         new PeriodParser[parserList.size()]);\n             }\n         }\n             return position;\n         }\n \n-        private void decompose(List elementPairs, List printerList, List parserList) {\n+        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n             int size = elementPairs.size();\n             for (int i=0; i<size; i+=2) {\n                 Object element = elementPairs.get(i);\n             }\n         }\n \n-        private void addArrayToList(List list, Object[] array) {\n+        private void addArrayToList(List<Object> list, Object[] array) {\n             if (array != null) {\n                 for (int i=0; i<array.length; i++) {\n                     list.add(array[i]);\n--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     }\n \n     // List of RuleSets.\n-    private final ArrayList iRuleSets;\n+    private final ArrayList<RuleSet> iRuleSets;\n \n     public DateTimeZoneBuilder() {\n-        iRuleSets = new ArrayList(10);\n+        iRuleSets = new ArrayList<RuleSet>(10);\n     }\n \n     /**\n         OfYear ofYear = new OfYear\n             (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n         if (iRuleSets.size() > 0) {\n-            RuleSet lastRuleSet = (RuleSet)iRuleSets.get(iRuleSets.size() - 1);\n+            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n             lastRuleSet.setUpperLimit(year, ofYear);\n         }\n         iRuleSets.add(new RuleSet());\n         if (iRuleSets.size() == 0) {\n             addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);\n         }\n-        return (RuleSet)iRuleSets.get(iRuleSets.size() - 1);\n+        return iRuleSets.get(iRuleSets.size() - 1);\n     }\n     \n     /**\n \n         // Discover where all the transitions occur and store the results in\n         // these lists.\n-        ArrayList transitions = new ArrayList();\n+        ArrayList<Transition> transitions = new ArrayList<Transition>();\n \n         // Tail zone picks up remaining transitions in the form of an endless\n         // DST cycle.\n             \n         int ruleSetCount = iRuleSets.size();\n         for (int i=0; i<ruleSetCount; i++) {\n-            RuleSet rs = (RuleSet)iRuleSets.get(i);\n+            RuleSet rs = iRuleSets.get(i);\n             Transition next = rs.firstTransition(millis);\n             if (next == null) {\n                 continue;\n             return buildFixedZone(id, \"UTC\", 0, 0);\n         }\n         if (transitions.size() == 1 && tailZone == null) {\n-            Transition tr = (Transition)transitions.get(0);\n+            Transition tr = transitions.get(0);\n             return buildFixedZone(id, tr.getNameKey(),\n                                   tr.getWallOffset(), tr.getStandardOffset());\n         }\n         return zone;\n     }\n \n-    private boolean addTransition(ArrayList transitions, Transition tr) {\n+    private boolean addTransition(ArrayList<Transition> transitions, Transition tr) {\n         int size = transitions.size();\n         if (size == 0) {\n             transitions.add(tr);\n             return true;\n         }\n \n-        Transition last = (Transition)transitions.get(size - 1);\n+        Transition last = transitions.get(size - 1);\n         if (!tr.isTransitionFrom(last)) {\n             return false;\n         }\n         // replace last transition with new one.\n         int offsetForLast = 0;\n         if (size >= 2) {\n-            offsetForLast = ((Transition)transitions.get(size - 2)).getWallOffset();\n+            offsetForLast = transitions.get(size - 2).getWallOffset();\n         }\n         int offsetForNew = last.getWallOffset();\n \n         }\n \n         private int iStandardOffset;\n-        private ArrayList iRules;\n+        private ArrayList<Rule> iRules;\n \n         // Optional.\n         private String iInitialNameKey;\n         private OfYear iUpperOfYear;\n \n         RuleSet() {\n-            iRules = new ArrayList(10);\n+            iRules = new ArrayList<Rule>(10);\n             iUpperYear = Integer.MAX_VALUE;\n         }\n \n          */\n         RuleSet(RuleSet rs) {\n             iStandardOffset = rs.iStandardOffset;\n-            iRules = new ArrayList(rs.iRules);\n+            iRules = new ArrayList<Rule>(rs.iRules);\n             iInitialNameKey = rs.iInitialNameKey;\n             iInitialSaveMillis = rs.iInitialSaveMillis;\n             iUpperYear = rs.iUpperYear;\n             }\n \n             // Make a copy before we destroy the rules.\n-            ArrayList copy = new ArrayList(iRules);\n+            ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n \n             // Iterate through all the transitions until firstMillis is\n             // reached. Use the name key and savings for whatever rule reaches\n                         // Find first rule without savings. This way a more\n                         // accurate nameKey is found even though no rule\n                         // extends to the RuleSet's lower limit.\n-                        Iterator it = copy.iterator();\n+                        Iterator<Rule> it = copy.iterator();\n                         while (it.hasNext()) {\n-                            Rule rule = (Rule)it.next();\n+                            Rule rule = it.next();\n                             if (rule.getSaveMillis() == 0) {\n                                 first = new Transition(firstMillis, rule, iStandardOffset);\n                                 break;\n             Rule nextRule = null;\n             long nextMillis = Long.MAX_VALUE;\n             \n-            Iterator it = iRules.iterator();\n+            Iterator<Rule> it = iRules.iterator();\n             while (it.hasNext()) {\n-                Rule rule = (Rule)it.next();\n+                Rule rule = it.next();\n                 long next = rule.next(instant, iStandardOffset, saveMillis);\n                 if (next <= instant) {\n                     it.remove();\n          */\n         public DSTZone buildTailZone(String id) {\n             if (iRules.size() == 2) {\n-                Rule startRule = (Rule)iRules.get(0);\n-                Rule endRule = (Rule)iRules.get(1);\n+                Rule startRule = iRules.get(0);\n+                Rule endRule = iRules.get(1);\n                 if (startRule.getToYear() == Integer.MAX_VALUE &&\n                     endRule.getToYear() == Integer.MAX_VALUE) {\n \n          * @param transitions  the list of Transition objects\n          * @param tailZone  optional zone for getting info beyond precalculated tables\n          */\n-        static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions,\n+        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,\n                                         DSTZone tailZone) {\n             int size = transitions.size();\n             if (size == 0) {\n \n             Transition last = null;\n             for (int i=0; i<size; i++) {\n-                Transition tr = (Transition)transitions.get(i);\n+                Transition tr = transitions.get(i);\n \n                 if (!tr.isTransitionFrom(last)) {\n                     throw new IllegalArgumentException(id);\n             int size = iTransitions.length;\n \n             // Create unique string pool.\n-            Set poolSet = new HashSet();\n+            Set<String> poolSet = new HashSet<String>();\n             for (int i=0; i<size; i++) {\n                 poolSet.add(iNameKeys[i]);\n             }\n                 throw new UnsupportedOperationException(\"String pool is too large\");\n             }\n             String[] pool = new String[poolSize];\n-            Iterator it = poolSet.iterator();\n+            Iterator<String> it = poolSet.iterator();\n             for (int i=0; it.hasNext(); i++) {\n-                pool[i] = (String)it.next();\n+                pool[i] = it.next();\n             }\n \n             // Write out the pool.\n--- a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.text.DateFormatSymbols;\n import java.util.HashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.joda.time.DateTimeUtils;\n \n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n+@SuppressWarnings(\"unchecked\")\n public class DefaultNameProvider implements NameProvider {\n     // locale -> (id -> (nameKey -> [shortName, name]))\n-    private HashMap iByLocaleCache = createCache();\n+    private HashMap<Locale, Map<String, Map<String, Object>>> iByLocaleCache = createCache();\n \n     public DefaultNameProvider() {\n     }\n             return null;\n         }\n \n-        HashMap byIdCache = (HashMap)iByLocaleCache.get(locale);\n+        Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale);\n         if (byIdCache == null) {\n             iByLocaleCache.put(locale, byIdCache = createCache());\n         }\n \n-        HashMap byNameKeyCache = (HashMap)byIdCache.get(id);\n+        Map<String, Object> byNameKeyCache = byIdCache.get(id);\n         if (byNameKeyCache == null) {\n             byIdCache.put(id, byNameKeyCache = createCache());\n             String[][] zoneStrings = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\n--- a/JodaTime/src/java/org/joda/time/tz/Provider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/Provider.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n package org.joda.time.tz;\n \n import java.util.Set;\n+\n import org.joda.time.DateTimeZone;\n \n /**\n  * @since 1.0\n  */\n public interface Provider {\n+\n     /**\n      * Retrieves a DateTimeZone for the given id. All providers must at\n      * least support id \"UTC\".\n      * Returns an unmodifiable set of ids. All providers must at least\n      * support id \"UTC\".\n      */        \n-    Set getAvailableIDs();\n+    Set<String> getAvailableIDs();\n+\n }\n--- a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n import java.util.Collections;\n import java.util.Set;\n+\n import org.joda.time.DateTimeZone;\n \n /**\n     /**\n      * Returns a singleton collection containing only <code>\"UTC\"</code>.\n      */    \n-    public Set getAvailableIDs() {\n+    public Set<String> getAvailableIDs() {\n         return Collections.singleton(\"UTC\");\n     }\n \n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.StringTokenizer;\n import java.util.TreeMap;\n+import java.util.Map.Entry;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n     /**\n      * @param zimap maps string ids to DateTimeZone objects.\n      */\n-    static void writeZoneInfoMap(DataOutputStream dout, Map zimap) throws IOException {\n+    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n         // Build the string pool.\n-        Map idToIndex = new HashMap(zimap.size());\n-        TreeMap indexToId = new TreeMap();\n-\n-        Iterator it = zimap.entrySet().iterator();\n+        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n+        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n+\n         short count = 0;\n-        while (it.hasNext()) {\n-            Map.Entry entry = (Map.Entry)it.next();\n+        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n             String id = (String)entry.getKey();\n             if (!idToIndex.containsKey(id)) {\n-                Short index = new Short(count);\n+                Short index = Short.valueOf(count);\n                 idToIndex.put(id, index);\n                 indexToId.put(index, id);\n                 if (++count == 0) {\n             }\n             id = ((DateTimeZone)entry.getValue()).getID();\n             if (!idToIndex.containsKey(id)) {\n-                Short index = new Short(count);\n+                Short index = Short.valueOf(count);\n                 idToIndex.put(id, index);\n                 indexToId.put(index, id);\n                 if (++count == 0) {\n \n         // Write the string pool, ordered by index.\n         dout.writeShort(indexToId.size());\n-        it = indexToId.values().iterator();\n-        while (it.hasNext()) {\n-            dout.writeUTF((String)it.next());\n+        for (String id : indexToId.values()) {\n+            dout.writeUTF(id);\n         }\n \n         // Write the mappings.\n         dout.writeShort(zimap.size());\n-        it = zimap.entrySet().iterator();\n-        while (it.hasNext()) {\n-            Map.Entry entry = (Map.Entry)it.next();\n-            String id = (String)entry.getKey();\n-            dout.writeShort(((Short)idToIndex.get(id)).shortValue());\n-            id = ((DateTimeZone)entry.getValue()).getID();\n-            dout.writeShort(((Short)idToIndex.get(id)).shortValue());\n+        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n+            String id = entry.getKey();\n+            dout.writeShort(idToIndex.get(id).shortValue());\n+            id = entry.getValue().getID();\n+            dout.writeShort(idToIndex.get(id).shortValue());\n         }\n     }\n \n         int offset = tz.getOffset(millis);\n         String key = tz.getNameKey(millis);\n \n-        List transitions = new ArrayList();\n+        List<Long> transitions = new ArrayList<Long>();\n \n         while (true) {\n             long next = tz.nextTransition(millis);\n                 return false;\n             }\n \n-            transitions.add(new Long(millis));\n+            transitions.add(Long.valueOf(millis));\n \n             offset = nextOffset;\n             key = nextKey;\n \n             millis = prev;\n \n-            long trans = ((Long)transitions.get(i)).longValue();\n+            long trans = transitions.get(i).longValue();\n             \n             if (trans - 1 != millis) {\n                 System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n     }\n \n     // Maps names to RuleSets.\n-    private Map iRuleSets;\n+    private Map<String, RuleSet> iRuleSets;\n \n     // List of Zone objects.\n-    private List iZones;\n+    private List<Zone> iZones;\n \n     // List String pairs to link.\n-    private List iLinks;\n+    private List<String> iLinks;\n \n     public ZoneInfoCompiler() {\n-        iRuleSets = new HashMap();\n-        iZones = new ArrayList();\n-        iLinks = new ArrayList();\n+        iRuleSets = new HashMap<String, RuleSet>();\n+        iZones = new ArrayList<Zone>();\n+        iLinks = new ArrayList<String>();\n     }\n \n     /**\n      * @param outputDir optional directory to write compiled data files to\n      * @param sources optional list of source files to parse\n      */\n-    public Map compile(File outputDir, File[] sources) throws IOException {\n+    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n         if (sources != null) {\n             for (int i=0; i<sources.length; i++) {\n                 BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n             }\n         }\n \n-        Map map = new TreeMap();\n+        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n \n         for (int i=0; i<iZones.size(); i++) {\n-            Zone zone = (Zone)iZones.get(i);\n+            Zone zone = iZones.get(i);\n             DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n             zone.addToBuilder(builder, iRuleSets);\n             final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n \n         for (int pass=0; pass<2; pass++) {\n             for (int i=0; i<iLinks.size(); i += 2) {\n-                String id = (String)iLinks.get(i);\n-                String alias = (String)iLinks.get(i + 1);\n-                DateTimeZone tz = (DateTimeZone)map.get(id);\n+                String id = iLinks.get(i);\n+                String alias = iLinks.get(i + 1);\n+                DateTimeZone tz = map.get(id);\n                 if (tz == null) {\n                     if (pass > 0) {\n                         System.out.println(\"Cannot find time zone '\" + id +\n             OutputStream out = new FileOutputStream(file);\n             DataOutputStream dout = new DataOutputStream(out);\n             // Sort and filter out any duplicates that match case.\n-            Map zimap = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n             zimap.putAll(map);\n             writeZoneInfoMap(dout, zimap);\n             dout.close();\n                 String token = st.nextToken();\n                 if (token.equalsIgnoreCase(\"Rule\")) {\n                     Rule r = new Rule(st);\n-                    RuleSet rs = (RuleSet)iRuleSets.get(r.iName);\n+                    RuleSet rs = iRuleSets.get(r.iName);\n                     if (rs == null) {\n                         rs = new RuleSet(r);\n                         iRuleSets.put(r.iName, rs);\n     }\n \n     private static class RuleSet {\n-        private List iRules;\n+        private List<Rule> iRules;\n \n         RuleSet(Rule rule) {\n-            iRules = new ArrayList();\n+            iRules = new ArrayList<Rule>();\n             iRules.add(rule);\n         }\n \n         void addRule(Rule rule) {\n-            if (!(rule.iName.equals(((Rule)iRules.get(0)).iName))) {\n+            if (!(rule.iName.equals(iRules.get(0).iName))) {\n                 throw new IllegalArgumentException(\"Rule name mismatch\");\n             }\n             iRules.add(rule);\n          */\n         public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n             for (int i=0; i<iRules.size(); i++) {\n-                Rule rule = (Rule)iRules.get(i);\n+                Rule rule = iRules.get(i);\n                 rule.addRecurring(builder, nameFormat);\n             }\n         }\n         /**\n          * Adds zone info to the builder.\n          */\n-        public void addToBuilder(DateTimeZoneBuilder builder, Map ruleSets) {\n+        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n             addToBuilder(this, builder, ruleSets);\n         }\n \n         private static void addToBuilder(Zone zone,\n                                          DateTimeZoneBuilder builder,\n-                                         Map ruleSets)\n+                                         Map<String, RuleSet> ruleSets)\n         {\n             for (; zone != null; zone = zone.iNext) {\n                 builder.setStandardOffset(zone.iOffsetMillis);\n                         builder.setFixedSavings(zone.iFormat, saveMillis);\n                     }\n                     catch (Exception e) {\n-                        RuleSet rs = (RuleSet)ruleSets.get(zone.iRules);\n+                        RuleSet rs = ruleSets.get(zone.iRules);\n                         if (rs == null) {\n                             throw new IllegalArgumentException\n                                 (\"Rules not found: \" + zone.iRules);\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     /** The class loader to use. */\n     private final ClassLoader iLoader;\n     /** Maps ids to strings or SoftReferences to DateTimeZones. */\n-    private final Map iZoneInfoMap;\n+    private final Map<String, Object> iZoneInfoMap;\n \n     /**\n      * ZoneInfoProvider searches the given directory for compiled data files.\n             return loadZoneData(id);\n         }\n \n-        if (obj instanceof SoftReference) {\n-            DateTimeZone tz = (DateTimeZone)((SoftReference)obj).get();\n+        if (obj instanceof SoftReference<?>) {\n+            @SuppressWarnings(\"unchecked\")\n+            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n+            DateTimeZone tz = ref.get();\n             if (tz != null) {\n                 return tz;\n             }\n      * \n      * @return the zone ids\n      */\n-    public synchronized Set getAvailableIDs() {\n+    public synchronized Set<String> getAvailableIDs() {\n         // Return a copy of the keys rather than an umodifiable collection.\n         // This prevents ConcurrentModificationExceptions from being thrown by\n         // some JVMs if zones are opened while this set is iterated over.\n-        return new TreeSet(iZoneInfoMap.keySet());\n+        return new TreeSet<String>(iZoneInfoMap.keySet());\n     }\n \n     /**\n         try {\n             in = openResource(id);\n             DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n-            iZoneInfoMap.put(id, new SoftReference(tz));\n+            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n             return tz;\n         } catch (IOException e) {\n             uncaughtException(e);\n      * @param in  the input stream\n      * @return the map\n      */\n-    private static Map loadZoneInfoMap(InputStream in) throws IOException {\n-        Map map = new TreeMap(String.CASE_INSENSITIVE_ORDER);\n+    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n+        Map<String, Object> map = new TreeMap<String, Object>(String.CASE_INSENSITIVE_ORDER);\n         DataInputStream din = new DataInputStream(in);\n         try {\n             readZoneInfoMap(din, map);\n             } catch (IOException e) {\n             }\n         }\n-        map.put(\"UTC\", new SoftReference(DateTimeZone.UTC));\n+        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n         return map;\n     }\n \n      * @param din  the input stream\n      * @param zimap  gets filled with string id to string id mappings\n      */\n-    private static void readZoneInfoMap(DataInputStream din, Map zimap) throws IOException {\n+    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n         // Read the string pool.\n         int size = din.readUnsignedShort();\n         String[] pool = new String[size];\n--- a/JodaTime/src/test/org/joda/time/TestBaseSingleFieldPeriod.java\n+++ b/JodaTime/src/test/org/joda/time/TestBaseSingleFieldPeriod.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(true, test3.compareTo(test2) > 0);\n         assertEquals(true, test3.compareTo(test3) == 0);\n         \n-        try {\n-            test1.compareTo(\"Hello\");\n-            fail();\n-        } catch (ClassCastException ex) {\n-            // expected\n-        }\n-        try {\n-            test1.compareTo(new Period(0, 0, 0, 21, 0, 0, 0, 0, PeriodType.days()));\n-            fail();\n-        } catch (ClassCastException ex) {\n-            // expected\n-        }\n+//        try {\n+//            test1.compareTo(\"Hello\");\n+//            fail();\n+//        } catch (ClassCastException ex) {\n+//            // expected\n+//        }\n+//        try {\n+//            test1.compareTo(new Period(0, 0, 0, 21, 0, 0, 0, 0, PeriodType.days()));\n+//            fail();\n+//        } catch (ClassCastException ex) {\n+//            // expected\n+//        }\n         try {\n             test1.compareTo(null);\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n     \n     public void testIsEqual() {\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Long(123L));\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Long(123L));\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n \n     public void testIsEqual() {\n--- a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestLocalDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDateTime_Basics.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             test1.compareTo(new YearMonthDay());\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             test1.compareTo(new TimeOfDay());\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n     \n     public void testIsEqual() {\n--- a/JodaTime/src/test/org/joda/time/TestPartial_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPartial_Basics.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             test1.compareTo(new YearMonthDay());\n             fail();\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n-import java.util.Date;\n import java.util.Locale;\n \n import junit.framework.TestCase;\n             test1.compareTo(null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        try {\n-            test1.compareTo(new Date());\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            test1.compareTo(new Date());\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             test1.compareTo(new TimeOfDay());\n             fail();\n--- a/JodaTime/src/test/org/joda/time/field/TestMillisDurationField.java\n+++ b/JodaTime/src/test/org/joda/time/field/TestMillisDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(-1, MillisDurationField.INSTANCE.compareTo(ISOChronology.getInstance().seconds()));\n         DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);\n         assertEquals(1, MillisDurationField.INSTANCE.compareTo(dummy));\n-        try {\n-            MillisDurationField.INSTANCE.compareTo(\"\");\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            MillisDurationField.INSTANCE.compareTo(\"\");\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             MillisDurationField.INSTANCE.compareTo(null);\n             fail();\n--- a/JodaTime/src/test/org/joda/time/field/TestPreciseDurationField.java\n+++ b/JodaTime/src/test/org/joda/time/field/TestPreciseDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));\n         DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);\n         assertEquals(1, iField.compareTo(dummy));\n-        try {\n-            iField.compareTo(\"\");\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            iField.compareTo(\"\");\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             iField.compareTo(null);\n             fail();\n--- a/JodaTime/src/test/org/joda/time/field/TestScaledDurationField.java\n+++ b/JodaTime/src/test/org/joda/time/field/TestScaledDurationField.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));\n         DurationField dummy = new PreciseDurationField(DurationFieldType.minutes(), 0);\n         assertEquals(1, iField.compareTo(dummy));\n-        try {\n-            iField.compareTo(\"\");\n-            fail();\n-        } catch (ClassCastException ex) {}\n+//        try {\n+//            iField.compareTo(\"\");\n+//            fail();\n+//        } catch (ClassCastException ex) {}\n         try {\n             iField.compareTo(null);\n             fail();", "timestamp": 1257378900, "metainfo": ""}