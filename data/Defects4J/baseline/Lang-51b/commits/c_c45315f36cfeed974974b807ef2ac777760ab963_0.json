{"sha": "c45315f36cfeed974974b807ef2ac777760ab963", "log": "An attempt to put together an implementation for bugzilla issue 29163. Tempted to think that split() should not be using the stopTime variable.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n  * <p>It is intended that the output methods {@link #toString()} and {@link #getTime()}\n  * should only be called after stop, split or suspend, however a suitable result will\n  * be returned at other points.</p>\n+\n+1. split(), suspend(), or stop() cannot be invoked twice.\n+2. unsplit() may only be called if the watch has been split()\n+3. resume() may only be called if the watch has been suspend()\n+4. start() cannot be called twice.\n+ \n  *\n  * @author Henri Yandell\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: StopWatch.java,v 1.8 2004/02/18 22:56:42 ggregory Exp $\n+ * @version $Id: StopWatch.java,v 1.9 2004/07/25 07:31:36 bayard Exp $\n  */\n public class StopWatch {\n-    \n+\n+    // running states\n+    private static final int STATE_UNSTARTED = 0;\n+    private static final int STATE_RUNNING   = 1;\n+    private static final int STATE_STOPPED   = 2;\n+    private static final int STATE_SUSPENDED = 3;\n+\n+    // split state\n+    private static final int STATE_UNSPLIT = 10;\n+    private static final int STATE_SPLIT   = 11;\n+\n+    /**\n+     *  The current running state of the StopWatch. \n+     */\n+    private int runningState = STATE_UNSTARTED;\n+\n+    /**\n+     * Whether the stopwatch has a split time recorded. \n+     */\n+    private int splitState   = STATE_UNSPLIT;\n+\n     /**\n      * The start time.\n      */\n      * <p>Start the stopwatch.</p>\n      * \n      * <p>This method starts a new timing session, clearing any previous values.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is already running.\n      */\n     public void start() {\n+        if(this.runningState == STATE_STOPPED) {\n+            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n+        }\n+        if(this.runningState != STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch already started. \");\n+        }\n         stopTime = -1;\n         startTime = System.currentTimeMillis();\n+        this.runningState = STATE_RUNNING;\n     }\n \n     /**\n      * <p>Stop the stopwatch.</p>\n      * \n      * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not running.\n      */\n     public void stop() {\n+        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n         stopTime = System.currentTimeMillis();\n-    }\n-\n-    /**\n-     * <p>Reset the stopwatch.</p>\n+        this.runningState = STATE_STOPPED;\n+    }\n+\n+    /**\n+     * <p>Resets the stopwatch. Stops it if need be. </p>\n      * \n      * <p>This method clears the internal values to allow the object to be reused.</p>\n      */\n     public void reset() {\n+        this.runningState = STATE_UNSTARTED;\n+        this.splitState   = STATE_UNSPLIT;\n         startTime = -1;\n         stopTime = -1;\n     }\n      * <p>This method sets the stop time of the watch to allow a time to be extracted.\n      * The start time is unaffected, enabling {@link #unsplit()} to continue the \n      * timing from the original start point.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not running.\n      */\n     public void split() {\n+        if(this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n         stopTime = System.currentTimeMillis();\n+        this.splitState = STATE_SPLIT;\n     }\n \n     /**\n      * \n      * <p>This method clears the stop time. The start time is unaffected, enabling \n      * timing from the original start point to continue.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch has not been split.\n      */\n     public void unsplit() {\n-        stopTime = -1;\n+        if(this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch has not been split. \");\n+        }\n+        stopTime = -1;\n+        this.splitState = STATE_UNSPLIT;\n     }\n \n     /**\n      * \n      * <p>This method suspends the watch until it is resumed. The watch will not include\n      * time between the suspend and resume calls in the total time.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not currently running.\n      */\n     public void suspend() {\n+        if(this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n+        }\n         stopTime = System.currentTimeMillis();\n+        this.runningState = STATE_SUSPENDED;\n     }\n \n     /**\n      * \n      * <p>This method resumes the watch after it was suspended. The watch will not include\n      * time between the suspend and resume calls in the total time.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch has not been suspended. \n      */\n     public void resume() {\n+        if(this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n+        }\n         startTime += (System.currentTimeMillis() - stopTime);\n         stopTime = -1;\n+        this.runningState = STATE_RUNNING;\n     }\n \n     /**\n      * <p>Get the time on the stopwatch.</p>\n      * \n-     * <p>This is either the time between start and latest split, between start\n-     * and stop, or the time between the start and the moment this method is called.</p>\n+     * <p>This is either the time between the start and the moment this method \n+     * is called, or the amount of time between start and stop.</p>\n      * \n      * @return the time in milliseconds\n      */\n     public long getTime() {\n-        if (stopTime == -1) {\n-            if (startTime == -1) {\n-                return 0;\n-            }\n+        if(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n+            return (this.stopTime - this.startTime);\n+        } else\n+        if(this.runningState == STATE_UNSTARTED) {\n+            return 0;\n+        } else\n+        if(this.runningState == STATE_RUNNING) {\n             return (System.currentTimeMillis() - this.startTime);\n+        }\n+        throw new RuntimeException(\"Illegal running state has occured. \");\n+    }\n+\n+    /**\n+     * <p>Get the split time on the stopwatch.</p>\n+     * \n+     * <p>This is the time between start and latest split. </p>\n+     * \n+     * @return the split time in milliseconds\n+     *\n+     * @throws IllegalStateException if the StopWatch has not yet been split.\n+     */\n+    public long getSplitTime() {\n+        if(this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n         }\n         return (this.stopTime - this.startTime);\n     }\n         return DurationFormatUtils.formatISO(getTime());\n     }\n \n+    /**\n+     * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like,\n+     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * \n+     * @return the split time as a String\n+     */\n+    public String toSplitString() {\n+        return DurationFormatUtils.formatISO(getSplitTime());\n+    }\n+\n }", "timestamp": 1090740696, "metainfo": ""}