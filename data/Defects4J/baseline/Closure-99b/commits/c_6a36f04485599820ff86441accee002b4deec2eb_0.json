{"sha": "6a36f04485599820ff86441accee002b4deec2eb", "log": "Fixes for issues 14 and 16.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    * declared as a simple type and is automatically converted to a union of the\n    * declared type and Undefined.\n    *\n-   * @param parameterName potentially optional parameter name\n+   * @param parameter The parameter's node.\n    * @return {@code true} if the parameter should be treated as an optional\n    * parameter.\n    */\n-  public boolean isOptionalParameter(String parameterName);\n+  public boolean isOptionalParameter(Node parameter);\n \n   /**\n    * This checks whether a given parameter should be treated as a marker\n    * for a variable argument list function. A VarArgs parameter must be the\n    * last parameter in a function declaration.\n    *\n-   * @param parameter The parameter's node, or null if none.\n-   * @param name The name, in case we don't have a node.\n+   * @param parameter The parameter's node.\n    * @return {@code true} if the parameter should be treated as a variable\n    * length parameter.\n    */\n-  public boolean isVarArgsParameter(Node parameter, String name);\n+  public boolean isVarArgsParameter(Node parameter);\n \n   /**\n    * Checks whether a global variable or function name should be treated as\n--- a/src/com/google/javascript/jscomp/CodingConventionAnnotator.java\n+++ b/src/com/google/javascript/jscomp/CodingConventionAnnotator.java\n           JSTypeExpression typeExpr = fnInfo == null ?\n               null : fnInfo.getParameterType(argName);\n \n-          if (convention.isOptionalParameter(argName) ||\n+          if (convention.isOptionalParameter(arg) ||\n               typeExpr != null && typeExpr.isOptionalArg()) {\n             arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n           }\n-          if (convention.isVarArgsParameter(arg, argName) ||\n+          if (convention.isVarArgsParameter(arg) ||\n               typeExpr != null && typeExpr.isVarArgs()) {\n             arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n           }\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n-  public boolean isOptionalParameter(String parameterName) {\n-    return true; // be as lax as possible\n+  public boolean isOptionalParameter(Node parameter) {\n+    // be as lax as possible, but this must be mutually exclusive from\n+    // var_args parameters.\n+    return !isVarArgsParameter(parameter);\n   }\n \n   @Override\n-  public boolean isVarArgsParameter(Node parameter, String name) {\n+  public boolean isVarArgsParameter(Node parameter) {\n     // be as lax as possible\n-    return parameter != null &&\n-        parameter.getParent().getLastChild() == parameter;\n+    return parameter.getParent().getLastChild() == parameter;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n-import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionParamBuilder;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.InstanceObjectType;\n import java.util.List;\n import java.util.Set;\n \n+import javax.annotation.Nullable;\n \n /**\n  * A builder for FunctionTypes, because FunctionTypes are so\n         if (oldParams.hasNext()) {\n           paramBuilder.newParameterFromNode(oldParams.next());\n         } else {\n-          String name = currentParam.getString();\n           warnedAboutArgList |= addParameter(\n               paramBuilder,\n               typeRegistry.getNativeType(UNKNOWN_TYPE),\n               warnedAboutArgList,\n-              codingConvention.isOptionalParameter(name),\n-              codingConvention.isVarArgsParameter(currentParam, name));\n+              codingConvention.isOptionalParameter(currentParam),\n+              codingConvention.isVarArgsParameter(currentParam));\n         }\n       }\n       parametersNode = paramBuilder.build();\n   }\n \n   /**\n-   * Infer the parameter types from the list of arguments in the AST.\n-   */\n-  FunctionTypeBuilder inferParameterTypes(Node argsParent,\n+   * Infer the parameter types from the doc info alone.\n+   */\n+  FunctionTypeBuilder inferParameterTypes(JSDocInfo info) {\n+    // Create a fake args parent.\n+    Node lp = new Node(Token.LP);\n+    for (String name : info.getParameterNames()) {\n+      lp.addChildToBack(Node.newString(Token.NAME, name));\n+    }\n+\n+    return inferParameterTypes(lp, info);\n+  }\n+\n+  /**\n+   * Infer the parameter types from the list of argument names and\n+   * the doc info.\n+   */\n+  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n       @Nullable JSDocInfo info) {\n     if (argsParent == null) {\n-      return inferParameterTypes(info);\n-    }\n-\n-    List<String> argsList = ImmutableList.of();\n-    if (argsParent.getFirstChild() != null) {\n-      argsList = Lists.newArrayList();\n-      for (Node n : argsParent.children()) {\n-        argsList.add(n.getString());\n-      }\n-    }\n-\n-    return inferParameterTypes(argsList, info);\n-  }\n-\n-  /**\n-   * Infer the parameter types from the doc info alone.\n-   */\n-  FunctionTypeBuilder inferParameterTypes(JSDocInfo info) {\n-    return inferParameterTypes(info.getParameterNames(), info);\n-  }\n-\n-  /**\n-   * Infer the parameter types from the list of argument names and\n-   * the doc info.\n-   */\n-  private FunctionTypeBuilder inferParameterTypes(Iterable<String> argList,\n-      @Nullable JSDocInfo info) {\n+      if (info == null) {\n+        return this;\n+      } else {\n+        return inferParameterTypes(info);\n+      }\n+    }\n+\n     // arguments\n     FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n     boolean warnedAboutArgList = false;\n         Sets.<String>newHashSet() :\n         Sets.newHashSet(info.getParameterNames());\n     boolean foundTemplateType = false;\n-    for (String argumentName : argList) {\n+    for (Node arg : argsParent.children()) {\n+      String argumentName = arg.getString();\n       allJsDocParams.remove(argumentName);\n \n       // type from JSDocInfo\n       }\n       warnedAboutArgList |= addParameter(\n           builder, parameterType, warnedAboutArgList,\n-          isOptionalParameter(argumentName, info),\n-          isVarArgsParameter(argumentName, info));\n+          isOptionalParameter(arg, info),\n+          isVarArgsParameter(arg, info));\n     }\n \n     if (templateTypeName != null && !foundTemplateType) {\n     }\n \n     for (String inexistentName : allJsDocParams) {\n-      if (!isVarArgsParameter(inexistentName, info)) {\n-        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n-      }\n+      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n     }\n \n     parametersNode = builder.build();\n    * @return Whether the given param is an optional param.\n    */\n   private boolean isOptionalParameter(\n-      String paramName, @Nullable JSDocInfo info) {\n-    if (codingConvention.isOptionalParameter(paramName)) {\n+      Node param, @Nullable JSDocInfo info) {\n+    if (codingConvention.isOptionalParameter(param)) {\n       return true;\n     }\n \n+    String paramName = param.getString();\n     return info != null && info.hasParameterType(paramName) &&\n         info.getParameterType(paramName).isOptionalArg();\n   }\n \n   /**\n-   * Determine whether this is a var args parameter from just the name and\n-   * annotation. This is the case where we have a stub declaration, with\n-   * no function literal.\n+   * Determine whether this is a var args parameter.\n    * @return Whether the given param is a var args param.\n    */\n   private boolean isVarArgsParameter(\n-      String paramName, @Nullable JSDocInfo info) {\n-    if (codingConvention.isVarArgsParameter(null, paramName)) {\n+      Node param, @Nullable JSDocInfo info) {\n+    if (codingConvention.isVarArgsParameter(param)) {\n       return true;\n     }\n \n+    String paramName = param.getString();\n     return info != null && info.hasParameterType(paramName) &&\n         info.getParameterType(paramName).isVarArgs();\n   }\n--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n    * treated as optional arguments.\n    */\n   @Override\n-  public boolean isOptionalParameter(String parameterName) {\n-    return parameterName.startsWith(OPTIONAL_ARG_PREFIX);\n+  public boolean isOptionalParameter(Node parameter) {\n+    return parameter.getString().startsWith(OPTIONAL_ARG_PREFIX);\n   }\n \n   @Override\n-  public boolean isVarArgsParameter(Node parameter, String name) {\n-    return VAR_ARGS_NAME.equals(name);\n+  public boolean isVarArgsParameter(Node parameter) {\n+    return VAR_ARGS_NAME.equals(parameter.getString());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n       extractForInitializer(n, null, null);\n       splitVarDeclarations(n);\n     }\n-  }\n-\n+\n+    if (n.getType() == Token.FUNCTION) {\n+      moveNamedFunctions(n.getLastChild());\n+    }\n+  }\n \n   /**\n    * Bring the initializers out of FOR loops.  These need to be placed\n         }\n       }\n     }\n+  }\n+\n+  /**\n+   * Move all the functions that are valid at the execution of the first\n+   * statement of the function to the beginning of the function definition.\n+   */\n+  private void moveNamedFunctions(Node functionBody) {\n+    Preconditions.checkState(\n+        functionBody.getParent().getType() == Token.FUNCTION);\n+    Node previous = null;\n+    Node current = functionBody.getFirstChild();\n+    // Skip any declarations at the beginning of the function body, they\n+    // are already in the right place.\n+    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n+      previous = current;\n+      current = current.getNext();\n+    }\n+\n+    // Find any remaining declarations and move them.\n+    Node insertAfter = previous;\n+    while (current != null) {\n+      // Save off the next node as the current node maybe removed.\n+      Node next = current.getNext();\n+      if (NodeUtil.isFunctionDeclaration(current)) {\n+        // Remove the declaration from the body.\n+        Preconditions.checkNotNull(previous);\n+        functionBody.removeChildAfter(previous);\n+\n+        // Readd the function at the top of the function body (after any\n+        // previous declarations).\n+        insertAfter = addToFront(functionBody, current, insertAfter);\n+        compiler.reportCodeChange();\n+      } else {\n+        // Update the previous only if the current node hasn't been moved.\n+        previous = current;\n+      }\n+      current = next;\n+    }\n+  }\n+\n+  /**\n+   * @param after The child node to insert the newChild after, or null if\n+   *     newChild should be added to the front of parent's child list.\n+   * @return The inserted child node.\n+   */\n+  private Node addToFront(Node parent, Node newChild, Node after) {\n+    if (after == null) {\n+      parent.addChildToFront(newChild);\n+    } else {\n+      parent.addChildAfter(newChild, after);\n+    }\n+    return newChild;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       // Record this provide created on a previous pass.\n       providedNodes.put(name, new ProvidedNode(\n           parent, parent.getParent(), t.getModule()));\n+      // Make sure it has the proper prefixes.\n+      maybeProvidePrefixes(parent, parent.getParent(), name);\n     } else {\n       // Remove this provide (from a previous pass) since we have an\n       // replacement already.\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n     Node args = new Node(Token.LP,\n         Node.newString(Token.NAME, \"a\"),\n         Node.newString(Token.NAME, \"b\"));\n-    assertFalse(conv.isVarArgsParameter(args.getFirstChild(), \"a\"));\n-    assertTrue(conv.isVarArgsParameter(args.getLastChild(), \"b\"));\n-    assertTrue(conv.isOptionalParameter(\"a\"));\n-    assertTrue(conv.isOptionalParameter(\"opt_a\"));\n+    Node optArgs = new Node(Token.LP,\n+        Node.newString(Token.NAME, \"opt_a\"),\n+        Node.newString(Token.NAME, \"opt_b\"));\n+\n+    assertFalse(conv.isVarArgsParameter(args.getFirstChild()));\n+    assertTrue(conv.isVarArgsParameter(args.getLastChild()));\n+    assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild()));\n+    assertTrue(conv.isVarArgsParameter(optArgs.getLastChild()));\n+\n+    assertTrue(conv.isOptionalParameter(args.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(args.getLastChild()));\n+    assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(optArgs.getLastChild()));\n   }\n \n   public void testInlineName() {\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   public void test(JSSourceFile[] externs, String js, String expected,\n                    DiagnosticType error,\n                    DiagnosticType warning, String description) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = createCompiler();\n     lastCompiler = compiler;\n \n     BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry());\n    */\n   public void test(String[] js, String[] expected, DiagnosticType error,\n                    DiagnosticType warning, String description) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = createCompiler();\n     lastCompiler = compiler;\n \n     JSSourceFile[] inputs = new JSSourceFile[js.length];\n    */\n   public void test(JSModule[] modules, String[] expected,\n                    DiagnosticType error, DiagnosticType warning) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = createCompiler();\n     lastCompiler = compiler;\n \n     compiler.init(externsInputs, modules, getOptions());\n    * Parses expected js inputs and returns the root of the parse tree.\n    */\n   private Node parseExpectedJs(String[] expected) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = createCompiler();\n     JSSourceFile[] inputs = new JSSourceFile[expected.length];\n     for (int i = 0; i < expected.length; i++) {\n       inputs[i] = JSSourceFile.fromCode(\"expected\" + i, expected[i]);\n     @Override\n     public void printSummary() {}\n   }\n+\n+  private Compiler createCompiler() {\n+    Compiler compiler = new Compiler();\n+    compiler.setCodingConvention(getCodingConvention());\n+    return compiler;\n+  }\n+\n+  protected CodingConvention getCodingConvention() {\n+    return new GoogleCodingConvention();\n+  }\n }\n--- a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java\n public class GoogleCodingConventionTest extends TestCase {\n   private GoogleCodingConvention conv = new GoogleCodingConvention();\n \n-\n   public void testVarAndOptionalParams() {\n     Node args = new Node(Token.LP,\n         Node.newString(Token.NAME, \"a\"),\n         Node.newString(Token.NAME, \"b\"));\n-    assertFalse(conv.isVarArgsParameter(args.getFirstChild(), \"a\"));\n-    assertFalse(conv.isVarArgsParameter(args.getLastChild(), \"b\"));\n-    assertFalse(conv.isOptionalParameter(\"a\"));\n-    assertTrue(conv.isOptionalParameter(\"opt_a\"));\n+    Node optArgs = new Node(Token.LP,\n+        Node.newString(Token.NAME, \"opt_a\"),\n+        Node.newString(Token.NAME, \"opt_b\"));\n+\n+    assertFalse(conv.isVarArgsParameter(args.getFirstChild()));\n+    assertFalse(conv.isVarArgsParameter(args.getLastChild()));\n+    assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild()));\n+    assertFalse(conv.isVarArgsParameter(optArgs.getLastChild()));\n+\n+    assertFalse(conv.isOptionalParameter(args.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(args.getLastChild()));\n+    assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));\n+    assertTrue(conv.isOptionalParameter(optArgs.getLastChild()));\n   }\n \n   public void testInlineName() {\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"for(; c < b;) foo()\");\n   }\n \n+  public void testMoveFunctions1() throws Exception {\n+    test(\"function f() { if (x) return; foo(); function foo() {} }\",\n+         \"function f() {function foo() {} if (x) return; foo(); }\");\n+    test(\"function f() { \" +\n+            \"function foo() {} \" +\n+            \"if (x) return;\" +\n+            \"foo(); \" +\n+            \"function bar() {} \" +\n+         \"}\",\n+         \"function f() {\" +\n+           \"function foo() {}\" +\n+           \"function bar() {}\" +\n+           \"if (x) return;\" +\n+           \"foo();\" +\n+         \"}\");\n+  }\n+\n+  public void testMoveFunctions2() throws Exception {\n+    testSame(\"function f() { function foo() {} }\");\n+    testSame(\"function f() { f(); a:function bar() {} }\");\n+    testSame(\"function f() { f(); {function bar() {}}}\");\n+    testSame(\"function f() { f(); if (true) {function bar() {}}}\");\n+  }\n \n   public void testMakeLocalNamesUnique() {\n     if (!Normalize.MAKE_LOCAL_NAMES_UNIQUE) {\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n public class ProcessClosurePrimitivesTest extends CompilerTestCase {\n   private String additionalCode;\n   private String additionalEndCode;\n+  private boolean addAdditionalNamespace;\n \n   @Override protected void setUp() {\n     additionalCode = null;\n     additionalEndCode = null;\n+    addAdditionalNamespace = false;\n   }\n \n   @Override public CompilerPass getProcessor(final Compiler compiler) {\n                 JSSourceFile.fromCode(\"additionalcode\", additionalCode);\n             Node scriptNode = root.getFirstChild();\n             Node newScriptNode = new CompilerInput(file).getAstRoot(compiler);\n+            if (addAdditionalNamespace) {\n+              newScriptNode.getFirstChild()\n+                  .putBooleanProp(Node.IS_NAMESPACE, true);\n+            }\n             while (newScriptNode.getLastChild() != null) {\n               Node lastChild = newScriptNode.getLastChild();\n               newScriptNode.removeChild(lastChild);\n                 JSSourceFile.fromCode(\"additionalendcode\", additionalEndCode);\n             Node scriptNode = root.getFirstChild();\n             Node newScriptNode = new CompilerInput(file).getAstRoot(compiler);\n+            if (addAdditionalNamespace) {\n+              newScriptNode.getFirstChild()\n+                  .putBooleanProp(Node.IS_NAMESPACE, true);\n+            }\n             while (newScriptNode.getFirstChild() != null) {\n               Node firstChild = newScriptNode.getFirstChild();\n               newScriptNode.removeChild(firstChild);\n          \"var a={};a.A={};\");\n   }\n \n+  // Tests a case where code is reordered after processing provides and then\n+  // provides are processed again.\n+  public void testReorderedProvides() {\n+    additionalCode = \"a.B = {};\";  // as if a.B was after a.A originally\n+    addAdditionalNamespace = true;\n+    test(\"goog.provide('a.A'); a.A = {};\",\n+         \"var a={};a.B={};a.A={};\");\n+  }\n+\n+  // Another version of above.\n+  public void testReorderedProvides2() {\n+    additionalEndCode = \"a.B = {};\";\n+    addAdditionalNamespace = true;\n+    test(\"goog.provide('a.A'); a.A = {};\",\n+         \"var a={};a.A={};a.B={};\");\n+  }\n+\n   public void testInvalidProvide() {\n     test(\"goog.provide('a.class');\", null, INVALID_PROVIDE_ERROR);\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n  */\n public class TypeCheckFunctionCheckTest extends CompilerTestCase {\n \n+  private CodingConvention convention = null;\n+\n   public TypeCheckFunctionCheckTest() {\n     parseTypeInfo = true;\n     enableTypeCheck(CheckLevel.ERROR);\n   }\n \n   @Override\n+  protected CodingConvention getCodingConvention() {\n+    return convention;\n+  }\n+\n+  @Override\n   protected int getNumRepetitions() {\n     // TypeCheck will only run once, regardless of what this returns.\n     // We return 1 so that the framework only expects 1 warning.\n     return 1;\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    convention = new GoogleCodingConvention();\n   }\n \n   public void testFunctionAritySimple() {\n              WRONG_ARGUMENT_COUNT);\n   }\n \n+  public void testFunctionWithDefaultCodingConvention() {\n+    convention = new DefaultCodingConvention();\n+    testSame(\"var foo = function(x) {}; foo(1, 2);\");\n+    testSame(\"var foo = function(opt_x) {}; foo(1, 2);\");\n+    testSame(\"var foo = function(var_args) {}; foo(1, 2);\");\n+  }\n+\n   public void assertOk(String params, String arguments) {\n     assertWarning(params, arguments, null);\n   }", "timestamp": 1257966343, "metainfo": ""}