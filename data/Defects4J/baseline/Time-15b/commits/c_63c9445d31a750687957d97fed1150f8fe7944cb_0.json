{"sha": "63c9445d31a750687957d97fed1150f8fe7944cb", "log": "Start testing LocalDate   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.ISODateTimeFormat;\n \n     /**\n      * Converts this LocalDate to a full datetime at midnight using the\n      * default time zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @return this date as a datetime at midnight\n      */\n      * <p>\n      * This method uses the chronology from this instance plus the time zone\n      * specified.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @param zone  the zone to use, null means default zone\n      * @return this date as a datetime at midnight\n      * Converts this LocalDate to a full datetime using the default time zone\n      * setting the date fields from this instance and the time fields from\n      * the current time.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @return this date as a datetime with the time as the current time\n      */\n      * <p>\n      * This method uses the chronology from this instance plus the time zone\n      * specified.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @param zone  the zone to use, null means default zone\n      * @return this date as a datetime with the time as the current time\n     //-----------------------------------------------------------------------\n     /**\n      * Converts this LocalDate to a DateMidnight in the default time zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @return the DateMidnight instance in the default zone\n      */\n \n     /**\n      * Converts this LocalDate to a DateMidnight.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n      *\n      * @param zone  the zone to get the DateMidnight in, null means default zone\n      * @return the DateMidnight instance\n         zone = DateTimeUtils.getZone(zone);\n         Chronology chrono = getChronology().withZone(zone);\n         return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using a LocalTime to fill in the\n+     * missing fields and using the default time zone.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * LocalDate. The chronology of the time must match.\n+     * If the time is null, the current time in the date's chronology is used.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @return the DateTime instance\n+     * @throws IllegalArgumentException if the chronology of the time does not match\n+     */\n+    public DateTime toDateTimeDefaultZone(LocalTime time) {\n+        return toDateTime(time, null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a LocalTime to fill in the\n+     * missing fields.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * LocalDate plus the time zone. The chronology of the time must match.\n+     * If the time is null, the current time in the date's chronology is used.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @param zone  the zone to get the DateTime in, null means default\n+     * @return the DateTime instance\n+     * @throws IllegalArgumentException if the chronology of the time does not match\n+     */\n+    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n+        if (time != null && getChronology() != time.getChronology()) {\n+            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n+        }\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instant = DateTimeUtils.currentTimeMillis();\n+        instant = chrono.set(this, instant);\n+        if (time != null) {\n+            instant = chrono.set(time, instant);\n+        }\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole day\n+     * in the default time zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return a interval over the day\n+     */\n+    public Interval toIntervalDefaultZone() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole day.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        return toDateMidnight(zone).toInterval();\n     }\n \n     //-----------------------------------------------------------------------\n      * period instances. Adding one field is best achieved using methods\n      * like {@link #withFieldAdded(DurationFieldType, int)}\n      * or {@link #plusYears(int)}.\n-     * Unsupported fields are ignored.\n+     * <p>\n+     * Unsupported time fields are ignored, thus adding a period of 24 hours\n+     * will not have any effect.\n      *\n      * @param period  the period to add to this one, null means zero\n      * @param scalar  the amount of times to add, such as -1 to subtract once\n         if (period == null || scalar == 0) {\n             return this;\n         }\n-        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        long instant = getLocalMillis();\n+        Chronology chrono = getChronology();\n+        for (int i = 0; i < period.size(); i++) {\n+            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n+            DurationFieldType type = period.getFieldType(i);\n+            if (isSupported(type)) {\n+                instant = type.getField(chrono).add(instant, value);\n+            }\n+        }\n         return withLocalMillis(instant);\n     }\n \n      * This method is typically used to add complex period instances.\n      * Adding one field is best achieved using methods\n      * like {@link #plusYears(int)}.\n-     * Unsupported fields are ignored.\n+     * <p>\n+     * Unsupported time fields are ignored, thus adding a period of 24 hours\n+     * will not have any effect.\n      *\n      * @param period  the period to add to this one, null means zero\n      * @return a copy of this date with the period added\n      * This method is typically used to subtract complex period instances.\n      * Subtracting one field is best achieved using methods\n      * like {@link #minusYears(int)}.\n+     * <p>\n+     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n+     * will not have any effect.\n      *\n      * @param period  the period to reduce this instant by\n      * @return a copy of this LocalDate with the period taken away\n \n     /**\n      * Get the weekyear field value.\n-     *\n-     * @return the year of a week based year\n+     * <p>\n+     * The weekyear is the year that matches with the weekOfWeekyear field.\n+     * In the standard ISO8601 week algorithm, the first week of the year\n+     * is that in which at least 4 days are in the year. As a result of this\n+     * definition, day 1 of the first week may be in the previous year.\n+     * The weekyear allows you to query the effective year for that day.\n+     *\n+     * @return the weekyear\n      */\n     public int getWeekyear() {\n         return getChronology().weekyear().get(getLocalMillis());\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Sets the era field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * era changed.\n+     *\n+     * @param era  the era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withEra(int era) {\n+        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n+    }\n+\n+    /**\n+     * Sets the century of era field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * century of era changed.\n+     *\n+     * @param centuryOfEra  the centurey of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withCenturyOfEra(int centuryOfEra) {\n+        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n+    }\n+\n+    /**\n+     * Sets the year of era field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of era changed.\n+     *\n+     * @param yearOfEra  the year of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYearOfEra(int yearOfEra) {\n+        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n+    }\n+\n+    /**\n+     * Sets the year of century field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of century changed.\n+     *\n+     * @param year of century  the year of century to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYearOfCentury(int yearOfCentury) {\n+        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n+    }\n+\n+    /**\n+     * Sets the year field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYear(int year) {\n+        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n+    }\n+\n+    /**\n+     * Sets the weekyear field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * weekyear changed.\n+     *\n+     * @param weekyear  the weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withWeekyear(int weekyear) {\n+        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Sets the month of year field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withMonthOfYear(int monthOfYear) {\n+        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Sets the week of weekyear field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * week of weekyear changed.\n+     *\n+     * @param weekOfWeekyear  the week of weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n+        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Sets the day of year field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of year changed.\n+     *\n+     * @param dayOfYear  the day of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfYear(int dayOfYear) {\n+        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Sets the day of month field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfMonth(int dayOfMonth) {\n+        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Sets the day of week field in a copy of this LocalDate, leaving this\n+     * instance unchanged.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of week changed.\n+     *\n+     * @param dayOfWeek  the day of week to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfWeek(int dayOfWeek) {\n+        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Get the era property.\n      *\n      * @return the era property\n     }\n \n     /**\n-     * Get the year of a week based year property.\n-     *\n-     * @return the year of a week based year property\n+     * Get the weekyear property.\n+     *\n+     * @return the weekyear property\n      */\n     public Property weekyear() {\n         return new Property(this, getChronology().weekyear());\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         suite.addTest(TestInterval_Constructors.suite());\n         suite.addTest(TestInterval_Basics.suite());\n         \n+//        suite.addTest(TestLocalTime_Basics.suite());\n+//        suite.addTest(TestLocalTime_Constructors.suite());\n+//        suite.addTest(TestLocalTime_Properties.suite());\n+        \n+//        suite.addTest(TestLocalDate_Basics.suite());\n+        \n         suite.addTest(TestMutableInterval_Constructors.suite());\n         suite.addTest(TestMutableInterval_Basics.suite());\n         suite.addTest(TestMutableInterval_Updates.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * This class is a Junit unit test for LocalDate.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestLocalDate_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final int OFFSET = 1;\n+    private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC();\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n+    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);\n+    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);\n+    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();\n+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n+    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);\n+    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestLocalDate_Basics.class);\n+    }\n+\n+    public TestLocalDate_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet_DateTimeFieldType() {\n+        LocalDate test = LocalDate.nowDefaultZone();\n+        assertEquals(1970, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(2, test.get(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(24, test.get(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(1970, test.get(DateTimeFieldType.weekyear()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        LocalDate test = LocalDate.nowDefaultZone();\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testGetFieldType_int() {\n+        LocalDate test = LocalDate.now(COPTIC_PARIS);\n+        assertSame(DateTimeFieldType.year(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));\n+        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        LocalDate test = LocalDate.now(COPTIC_PARIS);\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertSame(DateTimeFieldType.year(), fields[0]);\n+        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);\n+        assertSame(DateTimeFieldType.dayOfMonth(), fields[2]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField_int() {\n+        LocalDate test = LocalDate.now(COPTIC_PARIS);\n+        assertSame(COPTIC_UTC.year(), test.getField(0));\n+        assertSame(COPTIC_UTC.monthOfYear(), test.getField(1));\n+        assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        LocalDate test = LocalDate.now(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(COPTIC_UTC.year(), fields[0]);\n+        assertSame(COPTIC_UTC.monthOfYear(), fields[1]);\n+        assertSame(COPTIC_UTC.dayOfMonth(), fields[2]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue_int() {\n+        LocalDate test = LocalDate.nowDefaultZone();\n+        assertEquals(1970, test.getValue(0));\n+        assertEquals(6, test.getValue(1));\n+        assertEquals(9, test.getValue(2));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        LocalDate test = LocalDate.nowDefaultZone();\n+        int[] values = test.getValues();\n+        assertEquals(1970, values[0]);\n+        assertEquals(6, values[1]);\n+        assertEquals(9, values[2]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported_DateTimeFieldType() {\n+        LocalDate test = LocalDate.now(COPTIC_PARIS);\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.weekyear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.yearOfCentury()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.yearOfEra()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.centuryOfEra()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.weekyearOfCentury()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.era()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(false, test.isSupported((DateTimeFieldType) null));\n+    }\n+\n+    public void testIsSupported_DurationFieldType() {\n+        LocalDate test = new LocalDate(1970, 6, 9);\n+        assertEquals(true, test.isSupported(DurationFieldType.eras()));\n+        assertEquals(true, test.isSupported(DurationFieldType.centuries()));\n+        assertEquals(true, test.isSupported(DurationFieldType.years()));\n+        assertEquals(true, test.isSupported(DurationFieldType.months()));\n+        assertEquals(true, test.isSupported(DurationFieldType.weekyears()));\n+        assertEquals(true, test.isSupported(DurationFieldType.weeks()));\n+        assertEquals(true, test.isSupported(DurationFieldType.days()));\n+        \n+        assertEquals(false, test.isSupported(DurationFieldType.hours()));\n+        assertEquals(false, test.isSupported((DurationFieldType) null));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        LocalDate test1 = new LocalDate(1970, 6, 9, COPTIC_PARIS);\n+        LocalDate test2 = new LocalDate(1970, 6, 9, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        LocalDate test3 = new LocalDate(1971, 6, 9);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(true, test1.equals(new YearMonthDay(1970, 6, 9, COPTIC_PARIS)));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartial {\n+        public Chronology getChronology() {\n+            return COPTIC_UTC;\n+        }\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                COPTIC_UTC.year(),\n+                COPTIC_UTC.monthOfYear(),\n+                COPTIC_UTC.dayOfMonth(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {1970, 6, 9};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        LocalDate test1 = new LocalDate(2005, 6, 2);\n+        LocalDate test1a = new LocalDate(2005, 6, 2);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        LocalDate test2 = new LocalDate(2005, 7, 2);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(),\n+            DateTimeFieldType.monthOfYear(),\n+            DateTimeFieldType.dayOfMonth(),\n+        };\n+        int[] values = new int[] {2005, 6, 2};\n+        Partial p = new Partial(types, values);\n+        assertEquals(0, test1.compareTo(p));\n+        assertEquals(0, test1.compareTo(new YearMonthDay(2005, 6, 2)));\n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            test1.compareTo(new TimeOfDay());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        Partial partial = new Partial()\n+            .with(DateTimeFieldType.centuryOfEra(), 1)\n+            .with(DateTimeFieldType.halfdayOfDay(), 0)\n+            .with(DateTimeFieldType.dayOfMonth(), 9);\n+        try {\n+            new LocalDate(1970, 6, 9).compareTo(partial);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_LocalDate() {\n+        LocalDate test1 = new LocalDate(2005, 6, 2);\n+        LocalDate test1a = new LocalDate(2005, 6, 2);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        LocalDate test2 = new LocalDate(2005, 7, 2);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            new LocalDate(2005, 7, 2).isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_LocalDate() {\n+        LocalDate test1 = new LocalDate(2005, 6, 2);\n+        LocalDate test1a = new LocalDate(2005, 6, 2);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        LocalDate test2 = new LocalDate(2005, 7, 2);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            new LocalDate(2005, 7, 2).isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_LocalDate() {\n+        LocalDate test1 = new LocalDate(2005, 6, 2);\n+        LocalDate test1a = new LocalDate(2005, 6, 2);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        LocalDate test2 = new LocalDate(2005, 7, 2);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            new LocalDate(2005, 7, 2).isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithField_DateTimeFieldType_int_1() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        LocalDate result = test.withField(DateTimeFieldType.year(), 2006);\n+        \n+        assertEquals(new LocalDate(2004, 6, 9), test);\n+        assertEquals(new LocalDate(2006, 6, 9), result);\n+    }\n+\n+    public void testWithField_DateTimeFieldType_int_2() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        try {\n+            test.withField(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_DateTimeFieldType_int_3() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        try {\n+            test.withField(DateTimeFieldType.hourOfDay(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_DateTimeFieldType_int_4() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        LocalDate result = test.withField(DateTimeFieldType.year(), 2004);\n+        assertEquals(new LocalDate(2004, 6, 9), test);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldAdded_DurationFieldType_int_1() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        LocalDate result = test.withFieldAdded(DurationFieldType.years(), 6);\n+        \n+        assertEquals(new LocalDate(2004, 6, 9), test);\n+        assertEquals(new LocalDate(2010, 6, 9), result);\n+    }\n+\n+    public void testWithFieldAdded_DurationFieldType_int_2() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        try {\n+            test.withFieldAdded(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_DurationFieldType_int_3() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        try {\n+            test.withFieldAdded(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_DurationFieldType_int_4() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        LocalDate result = test.withFieldAdded(DurationFieldType.years(), 0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithFieldAdded_DurationFieldType_int_5() {\n+        LocalDate test = new LocalDate(2004, 6, 9);\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_RP() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.plus(new Period(1, 2, 3, 4, 29, 6, 7, 8));\n+        LocalDate expected = new LocalDate(2003, 7, 28, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.plus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusYears_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.plusYears(1);\n+        LocalDate expected = new LocalDate(2003, 5, 3, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.plusYears(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusMonths_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.plusMonths(1);\n+        LocalDate expected = new LocalDate(2002, 6, 3, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.plusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusWeeks_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.plusWeeks(1);\n+        LocalDate expected = new LocalDate(2002, 5, 10, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.plusWeeks(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusDays_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.plusDays(1);\n+        LocalDate expected = new LocalDate(2002, 5, 4, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.plusDays(0);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinus_RP() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n+        \n+        // TODO breaks because it subtracts millis now, and thus goes\n+        // into the previous day\n+        \n+        LocalDate expected = new LocalDate(2001, 3, 26, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.minus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusYears_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.minusYears(1);\n+        LocalDate expected = new LocalDate(2001, 5, 3, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.minusYears(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusMonths_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.minusMonths(1);\n+        LocalDate expected = new LocalDate(2002, 4, 3, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.minusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusWeeks_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.minusWeeks(1);\n+        LocalDate expected = new LocalDate(2002, 4, 26, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.minusWeeks(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusDays_int() {\n+        LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n+        LocalDate result = test.minusDays(1);\n+        LocalDate expected = new LocalDate(2002, 5, 2, BUDDHIST_LONDON);\n+        assertEquals(expected, result);\n+        \n+        result = test.minusDays(0);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetters() {\n+        LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC);\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        assertEquals(160, test.getDayOfYear());\n+        assertEquals(2, test.getDayOfWeek());\n+        assertEquals(24, test.getWeekOfWeekyear());\n+        assertEquals(1970, test.getWeekyear());\n+        assertEquals(70, test.getYearOfCentury());\n+        assertEquals(20, test.getCenturyOfEra());\n+        assertEquals(1970, test.getYearOfEra());\n+        assertEquals(DateTimeConstants.AD, test.getEra());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithers() {\n+        LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC);\n+        check(test.withYear(2000), 2000, 6, 9);\n+        check(test.withMonthOfYear(2), 1970, 2, 9);\n+        check(test.withDayOfMonth(2), 1970, 6, 2);\n+        check(test.withDayOfYear(6), 1970, 1, 6);\n+        check(test.withDayOfWeek(6), 1970, 6, 13);\n+        check(test.withWeekOfWeekyear(6), 1970, 2, 3);\n+        check(test.withWeekyear(1971), 1971, 6, 15);\n+        check(test.withYearOfCentury(60), 1960, 6, 9);\n+        check(test.withCenturyOfEra(21), 2070, 6, 9);\n+        check(test.withYearOfEra(1066), 1066, 6, 9);\n+        check(test.withEra(DateTimeConstants.BC), -1970, 6, 9);\n+        try {\n+            test.withMonthOfYear(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.withMonthOfYear(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtMidnight() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnightDefaultZone();\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtMidnight_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnight(TOKYO);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n+    }\n+\n+    public void testToDateTimeAtMidnight_nullZone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtCurrentTime() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTimeAtCurrentTimeDefaultZone();\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtCurrentTime_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTimeAtCurrentTime(TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTimeAtCurrentTime_nullZone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTimeAtCurrentTime((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeDefaultZone_LocalTime() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n+        \n+        DateTime test = base.toDateTimeDefaultZone(tod);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTimeDefaultZone_nullLocalTime() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_LONDON).getMillis();\n+        DateTimeUtils.setCurrentMillisFixed(now);\n+        \n+        DateTime test = base.toDateTimeDefaultZone((LocalTime) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_LocalTime_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n+        \n+        DateTime test = base.toDateTime(tod, TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_LocalTime_nullZone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n+        \n+        DateTime test = base.toDateTime(tod, null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullLocalTime_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_TOKYO).getMillis();\n+        DateTimeUtils.setCurrentMillisFixed(now);\n+        \n+        DateTime test = base.toDateTime((LocalTime) null, TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_wrongChronoLocalTime_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        LocalTime tod = new LocalTime(12, 13, 14, 15, BUDDHIST_TOKYO);\n+        \n+        try {\n+            base.toDateTime(tod, LONDON);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateMidnight() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnightDefaultZone();\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateMidnight_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnight(TOKYO);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);\n+    }\n+\n+    public void testToDateMidnight_nullZone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnight((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        LocalDate base = new LocalDate(2005, 6, 9);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInterval() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toIntervalDefaultZone();\n+        check(base, 2005, 6, 9);\n+        DateTime start = base.toDateTimeAtMidnightDefaultZone();\n+        DateTime end = start.plus(Period.days(1));\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInterval_Zone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toInterval(TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime start = base.toDateTimeAtMidnight(TOKYO);\n+        DateTime end = start.plus(Period.days(1));\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToInterval_nullZone() {\n+        LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        Interval test = base.toInterval(null);\n+        check(base, 2005, 6, 9);\n+        DateTime start = base.toDateTimeAtMidnight(LONDON);\n+        DateTime end = start.plus(Period.days(1));\n+        Interval expected = new Interval(start, end);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        LocalDate test = new LocalDate(2005, 6, 9, GJ_UTC);\n+        assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n+        assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n+        assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n+        assertEquals(test.dayOfYear(), test.property(DateTimeFieldType.dayOfYear()));\n+        assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));\n+        assertEquals(test.weekyear(), test.property(DateTimeFieldType.weekyear()));\n+        assertEquals(test.yearOfCentury(), test.property(DateTimeFieldType.yearOfCentury()));\n+        assertEquals(test.yearOfEra(), test.property(DateTimeFieldType.yearOfEra()));\n+        assertEquals(test.centuryOfEra(), test.property(DateTimeFieldType.centuryOfEra()));\n+        assertEquals(test.era(), test.property(DateTimeFieldType.era()));\n+        try {\n+            test.property(DateTimeFieldType.millisOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        LocalDate test = new LocalDate(1972, 6, 9, COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        LocalDate result = (LocalDate) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        LocalDate test = new LocalDate(2002, 6, 9);\n+        assertEquals(\"2002-06-09\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        LocalDate test = new LocalDate(2002, 6, 9);\n+        assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"2002-06-09\", test.toString((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        LocalDate test = new LocalDate(1970, 6, 9);\n+        assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"mar. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"1970-06-09\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"1970-06-09\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_DTFormatter() {\n+        LocalDate test = new LocalDate(2002, 6, 9);\n+        assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n+        assertEquals(\"2002-06-09\", test.toString((DateTimeFormatter) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(LocalDate test, int hour, int min, int sec) {\n+        assertEquals(hour, test.getYear());\n+        assertEquals(min, test.getMonthOfYear());\n+        assertEquals(sec, test.getDayOfMonth());\n+    }\n+}", "timestamp": 1139605404, "metainfo": ""}