{"sha": "aab3dfbd40e9e22755a376bdd2aa2af88ba356ac", "log": "Reformat classes to Joda-Time codeing standards   ", "commit": "\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneSupport.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneSupport.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.io.IOException;\n \n /**\n  * Support for tag handlers for &lt;timeZone&gt;.\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public abstract class DateTimeZoneSupport extends BodyTagSupport {\n-  public static final String FMT_TIME_ZONE = \"org.joda.time.dateTimeZone\";\n \n-  protected Object value;                      // 'value' attribute\n-  private DateTimeZone dateTimeZone;\n+    /** The config key for the time zone. */\n+    public static final String FMT_TIME_ZONE = \"org.joda.time.dateTimeZone\";\n \n-  public DateTimeZoneSupport() {\n-    super();\n-    init();\n-  }\n+    /** The value attribute. */\n+    protected Object value;\n \n-  private void init() {\n-    value = null;\n-  }\n+    /** The zone. */\n+    private DateTimeZone dateTimeZone;\n \n-  public DateTimeZone getDateTimeZone() {\n-    return dateTimeZone;\n-  }\n+    /**\n+     * Constructor.\n+     */\n+    public DateTimeZoneSupport() {\n+        super();\n+        init();\n+    }\n \n+    private void init() {\n+        value = null;\n+    }\n \n-  public int doStartTag() throws JspException {\n-    if (value == null) {\n-      dateTimeZone = DateTimeZone.UTC;\n-    } \n-    else if (value instanceof String) {\n-      try {\n-        dateTimeZone = DateTimeZone.forID((String) value);\n-      }\n-      catch(IllegalArgumentException iae) {\n-        dateTimeZone = DateTimeZone.UTC;\n-      }\n+    public DateTimeZone getDateTimeZone() {\n+        return dateTimeZone;\n     }\n-    else {\n-      dateTimeZone = (DateTimeZone) value;\n+\n+    public int doStartTag() throws JspException {\n+        if (value == null) {\n+            dateTimeZone = DateTimeZone.UTC;\n+        } else if (value instanceof String) {\n+            try {\n+                dateTimeZone = DateTimeZone.forID((String) value);\n+            } catch (IllegalArgumentException iae) {\n+                dateTimeZone = DateTimeZone.UTC;\n+            }\n+        } else {\n+            dateTimeZone = (DateTimeZone) value;\n+        }\n+        return EVAL_BODY_BUFFERED;\n     }\n-    return EVAL_BODY_BUFFERED;\n-  }\n \n-  public int doEndTag() throws JspException {\n-    try {\n-      pageContext.getOut().print(bodyContent.getString());\n-    } \n-    catch (IOException ioe) {\n-      throw new JspTagException(ioe.toString(), ioe);\n+    public int doEndTag() throws JspException {\n+        try {\n+            pageContext.getOut().print(bodyContent.getString());\n+        } catch (IOException ioe) {\n+            throw new JspTagException(ioe.toString(), ioe);\n+        }\n+        return EVAL_PAGE;\n     }\n-    return EVAL_PAGE;\n-  }\n \n-  // Releases any resources we may have (or inherit)\n-  public void release() {\n-    init();\n-  }\n+    // Releases any resources we may have (or inherit)\n+    public void release() {\n+        init();\n+    }\n \n-  /*\n-  * Determines and returns the time zone to be used by the given action.\n-  *\n-  * <p> If the given action is nested inside a &lt;dateTimeZone&gt; action,\n-  * the time zone is taken from the enclosing &lt;dateTimeZone&gt; action.\n-  *\n-  * <p> Otherwise, the time zone configuration setting\n-  * <tt>org.joda.time.FMT_TIME_ZONE</tt> is used.\n-  *\n-  * @param pageContext the page containing the action for which the\n-  * time zone needs to be determined\n-  * @param fromTag the action for which the time zone needs to be\n-  * determined\n-  *\n-  * @return the time zone, or <tt>null</tt> if the given action is not \n-  * nested inside a &lt;dateTimeZone&gt; action and no time zone configuration\n-  * setting exists\n-  */\n-  static DateTimeZone getDateTimeZone(PageContext pc, Tag fromTag) {\n-    DateTimeZone tz = null;\n+    /**\n+     * Determines and returns the time zone to be used by the given action.\n+     * <p>\n+     * If the given action is nested inside a &lt;dateTimeZone&gt; action,\n+     * the time zone is taken from the enclosing &lt;dateTimeZone&gt; action.\n+     * <p>\n+     * Otherwise, the time zone configuration setting\n+     * <tt>org.joda.time.FMT_TIME_ZONE</tt> is used.\n+     * \n+     * @param pageContext  the page containing the action for which the time zone\n+     *  needs to be determined\n+     * @param fromTag  the action for which the time zone needs to be determined\n+     * \n+     * @return the time zone, or <tt> null </tt> if the given action is not\n+     * nested inside a &lt;dateTimeZone&gt; action and no time zone configuration\n+     * setting exists\n+     */\n+    static DateTimeZone getDateTimeZone(PageContext pc, Tag fromTag) {\n+        DateTimeZone tz = null;\n \n-    Tag t = findAncestorWithClass(fromTag, DateTimeZoneSupport.class);\n-    if (t != null) {\n-      // use time zone from parent <timeZone> tag\n-      DateTimeZoneSupport parent = (DateTimeZoneSupport) t;\n-      tz = parent.getDateTimeZone();\n-    } \n-    else {\n-      // get time zone from configuration setting\n-      Object obj = Config.find(pc, FMT_TIME_ZONE);\n-      if (obj != null) {\n-        if (obj instanceof DateTimeZone) {\n-          tz = (DateTimeZone) obj;\n-        } \n-        else {\n-          try {\n-            tz = DateTimeZone.forID((String) obj);\n-          }\n-          catch(IllegalArgumentException iae) {\n-            tz = DateTimeZone.UTC;\n-          }\n+        Tag t = findAncestorWithClass(fromTag, DateTimeZoneSupport.class);\n+        if (t != null) {\n+            // use time zone from parent <timeZone> tag\n+            DateTimeZoneSupport parent = (DateTimeZoneSupport) t;\n+            tz = parent.getDateTimeZone();\n+        } else {\n+            // get time zone from configuration setting\n+            Object obj = Config.find(pc, FMT_TIME_ZONE);\n+            if (obj != null) {\n+                if (obj instanceof DateTimeZone) {\n+                    tz = (DateTimeZone) obj;\n+                } else {\n+                    try {\n+                        tz = DateTimeZone.forID((String) obj);\n+                    } catch (IllegalArgumentException iae) {\n+                        tz = DateTimeZone.UTC;\n+                    }\n+                }\n+            }\n         }\n-      }\n+\n+        return tz;\n     }\n-    \n-    return tz;\n-  }\n+\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneTag.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneTag.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import javax.servlet.jsp.JspTagException;\n \n /**\n- * <p>A handler for &lt;dateTimeZone&gt.\n+ * A handler for &lt;dateTimeZone&gt.\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n-\n public class DateTimeZoneTag extends DateTimeZoneSupport {\n \n-  // for tag attribute\n-  public void setValue(Object value) throws JspTagException {\n-    this.value = value;\n-  }\n-  \n+    // for tag attribute\n+    public void setValue(Object value) throws JspTagException {\n+        this.value = value;\n+    }\n+\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatSupport.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatSupport.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */ \n-\n package org.joda.time.contrib.jsptag;\n \n import java.io.IOException;\n /**\n  * Support for tag handlers for &lt;formatDate&gt;, the date and time\n  * formatting tag in JSTL 1.0.\n+ *\n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n-\n public abstract class FormatSupport extends TagSupport {\n \n-  protected Object value;                      // 'value' attribute\n-  protected String pattern;                    // 'pattern' attribute\n-  protected String style;                      // 'style' attribute\n-  protected DateTimeZone dateTimeZone;         // 'dateTimeZone' attribute\n-  protected Locale locale;                     // 'locale' attribute\n+    /** The value attribute. */\n+    protected Object value;\n+    /** The pattern attribute. */\n+    protected String pattern;\n+    /** The style attribute. */\n+    protected String style;\n+    /** The dateTimeZone attribute. */\n+    protected DateTimeZone dateTimeZone;\n+    /** The locale attribute. */\n+    protected Locale locale;\n+    /** The var attribute. */\n+    private String var;\n+    /** The scope attribute. */\n+    private int scope;\n \n-  private String var;                          // 'var' attribute\n-  private int scope;                           // 'scope' attribute\n-\n-\n-  public FormatSupport() {\n-    super();\n-    init();\n-  }\n-\n-  private void init() {\n-    var = null;\n-    value = null;\n-    pattern = null;\n-    style = null;\n-    dateTimeZone = null;\n-    locale = null;\n-    scope = PageContext.PAGE_SCOPE;\n-  }\n-\n-  public void setVar(String var) {\n-    this.var = var;\n-  }\n-\n-  public void setScope(String scope) {\n-    this.scope = Util.getScope(scope);\n-  }\n-\n-  /*\n-   * Formats the given instant or partial.\n-   */\n-  public int doEndTag() throws JspException {\n-    if (value == null) {\n-      if (var != null) {\n-        pageContext.removeAttribute(var, scope);\n-      }\n-      return EVAL_PAGE;\n+    /**\n+     * Constructor.\n+     */\n+    public FormatSupport() {\n+        super();\n+        init();\n     }\n \n-    // Create formatter\n-    DateTimeFormatter formatter;\n-    if (pattern != null) {\n-      formatter = DateTimeFormat.forPattern(pattern);\n-    }\n-    else if (style != null) {\n-      formatter = DateTimeFormat.forStyle(style);\n-    }\n-    else {\n-      // use a medium date (no time) style by default; same as jstl\n-      formatter = DateTimeFormat.mediumDate();\n+    private void init() {\n+        var = null;\n+        value = null;\n+        pattern = null;\n+        style = null;\n+        dateTimeZone = null;\n+        locale = null;\n+        scope = PageContext.PAGE_SCOPE;\n     }\n \n-    // set formatter locale\n-    Locale locale = this.locale;\n-    if (locale == null) {\n-      locale = Util.getFormattingLocale(pageContext, this, true,\n-        DateFormat.getAvailableLocales());\n-    }\n-    if (locale != null) {\n-      formatter = formatter.withLocale(locale);\n+    public void setVar(String var) {\n+        this.var = var;\n     }\n \n-    // set formatter timezone\n-    DateTimeZone tz = this.dateTimeZone;\n-    if (tz == null) {\n-      tz = DateTimeZoneSupport.getDateTimeZone(pageContext, this);\n-    }\n-    if (tz != null) {\n-      formatter = formatter.withZone(tz);\n+    public void setScope(String scope) {\n+        this.scope = Util.getScope(scope);\n     }\n \n-    // format value\n-    String formatted;\n-    if (value instanceof ReadableInstant) {\n-      formatted = formatter.print((ReadableInstant) value);\n-    }\n-    else {\n-      formatted = formatter.print((ReadablePartial) value);\n+    /*\n+     * Formats the given instant or partial.\n+     */\n+    public int doEndTag() throws JspException {\n+        if (value == null) {\n+            if (var != null) {\n+                pageContext.removeAttribute(var, scope);\n+            }\n+            return EVAL_PAGE;\n+        }\n+\n+        // Create formatter\n+        DateTimeFormatter formatter;\n+        if (pattern != null) {\n+            formatter = DateTimeFormat.forPattern(pattern);\n+        } else if (style != null) {\n+            formatter = DateTimeFormat.forStyle(style);\n+        } else {\n+            // use a medium date (no time) style by default; same as jstl\n+            formatter = DateTimeFormat.mediumDate();\n+        }\n+\n+        // set formatter locale\n+        Locale locale = this.locale;\n+        if (locale == null) {\n+            locale = Util.getFormattingLocale(pageContext, this, true,\n+                    DateFormat.getAvailableLocales());\n+        }\n+        if (locale != null) {\n+            formatter = formatter.withLocale(locale);\n+        }\n+\n+        // set formatter timezone\n+        DateTimeZone tz = this.dateTimeZone;\n+        if (tz == null) {\n+            tz = DateTimeZoneSupport.getDateTimeZone(pageContext, this);\n+        }\n+        if (tz != null) {\n+            formatter = formatter.withZone(tz);\n+        }\n+\n+        // format value\n+        String formatted;\n+        if (value instanceof ReadableInstant) {\n+            formatted = formatter.print((ReadableInstant) value);\n+        } else {\n+            formatted = formatter.print((ReadablePartial) value);\n+        }\n+\n+        if (var != null) {\n+            pageContext.setAttribute(var, formatted, scope);\n+        } else {\n+            try {\n+                pageContext.getOut().print(formatted);\n+            } catch (IOException ioe) {\n+                throw new JspTagException(ioe.toString(), ioe);\n+            }\n+        }\n+\n+        return EVAL_PAGE;\n     }\n \n-    if (var != null) {\n-      pageContext.setAttribute(var, formatted, scope);\n-    } \n-    else {\n-      try {\n-        pageContext.getOut().print(formatted);\n-      } \n-      catch (IOException ioe) {\n-        throw new JspTagException(ioe.toString(), ioe);\n-      }\n+    // Releases any resources we may have (or inherit)\n+    public void release() {\n+        init();\n     }\n \n-    return EVAL_PAGE;\n-  }\n-\n-  // Releases any resources we may have (or inherit)\n-  public void release() {\n-    init();\n-  }\n-\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatTag.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatTag.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.util.Locale;\n import org.joda.time.DateTimeZone;\n \n /**\n- * <p>A handler for &lt;format&gt; that supports rtexprvalue-based\n- * attributes.</p>\n+ * <p>\n+ * A handler for &lt;format&gt; that supports rtexprvalue-based attributes.\n+ * </p>\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public class FormatTag extends FormatSupport {\n \n-  // 'value' attribute\n-  public void setValue(Object value) throws JspTagException {\n-    this.value = value;\n-  }\n+    /**\n+     * Sets the value attribute.\n+     * \n+     * @param value  the value\n+     */\n+    public void setValue(Object value) throws JspTagException {\n+        this.value = value;\n+    }\n \n-  // 'style' attribute\n-  public void setStyle(String style) throws JspTagException {\n-    this.style = style;\n-  }\n+    /**\n+     * Sets the style attribute.\n+     * \n+     * @param style  the style\n+     */\n+    public void setStyle(String style) throws JspTagException {\n+        this.style = style;\n+    }\n \n-  // 'pattern' attribute\n-  public void setPattern(String pattern) throws JspTagException {\n-    this.pattern = pattern;\n-  }\n+    /**\n+     * Sets the pattern attribute.\n+     * \n+     * @param pattern  the pattern\n+     */\n+    public void setPattern(String pattern) throws JspTagException {\n+        this.pattern = pattern;\n+    }\n \n-  // 'dateTimeZone' attribute\n-  public void setDateTimeZone(Object dtz) throws JspTagException {\n-    if (dtz == null || dtz instanceof String && \n-      ((String) dtz).length() == 0) {\n-      this.dateTimeZone = null;\n+    /**\n+     * Sets the zone attribute.\n+     * \n+     * @param dtz  the zone\n+     */\n+    public void setDateTimeZone(Object dtz) throws JspTagException {\n+        if (dtz == null || dtz instanceof String\n+                && ((String) dtz).length() == 0) {\n+            this.dateTimeZone = null;\n+        } else if (dtz instanceof DateTimeZone) {\n+            this.dateTimeZone = (DateTimeZone) dtz;\n+        } else {\n+            try {\n+                this.dateTimeZone = DateTimeZone.forID((String) dtz);\n+            } catch (IllegalArgumentException iae) {\n+                this.dateTimeZone = DateTimeZone.UTC;\n+            }\n+        }\n     }\n-    else if (dtz instanceof DateTimeZone) {\n-      this.dateTimeZone = (DateTimeZone) dtz;\n+\n+    /**\n+     * Sets the style attribute.\n+     * \n+     * @param loc  the locale\n+     */\n+    public void setLocale(Object loc) throws JspTagException {\n+        if (loc == null\n+                || (loc instanceof String && ((String) loc).length() == 0)) {\n+            this.locale = null;\n+        } else if (loc instanceof Locale) {\n+            this.locale = (Locale) loc;\n+        } else {\n+            this.locale = Util.parseLocale((String) loc);\n+        }\n     }\n-    else {\n-      try {\n-        String s = (String) dtz;\n-        this.dateTimeZone = DateTimeZone.forID((String) dtz);\n-      }\n-      catch(IllegalArgumentException iae) {\n-        this.dateTimeZone = DateTimeZone.UTC;\n-      }\n-    }\n-  }\n-\n-  // 'locale' attribute\n-  public void setLocale(Object loc) throws JspTagException {\n-    if (loc == null || \n-      (loc instanceof String && ((String) loc).length() == 0)) {\n-      this.locale = null;\n-    }\n-    else if (loc instanceof Locale) {\n-      this.locale = (Locale) loc;\n-    } \n-    else {\n-      this.locale = Util.parseLocale((String) loc);\n-    }\n-  }\n \n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/JodaTagLibraryValidator.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/JodaTagLibraryValidator.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.io.IOException;\n-import java.util.Map;\n import java.util.Vector;\n \n import javax.servlet.jsp.tagext.PageData;\n-import javax.servlet.jsp.tagext.TagData;\n import javax.servlet.jsp.tagext.TagLibraryValidator;\n import javax.servlet.jsp.tagext.ValidationMessage;\n import javax.xml.parsers.ParserConfigurationException;\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.DefaultHandler;\n \n-//import org.apache.taglibs.standard.lang.support.ExpressionEvaluator;\n-//import org.apache.taglibs.standard.lang.support.ExpressionEvaluatorManager;\n-\n /**\n- * <p>A SAX-based TagLibraryValidator for the Joda tags.  Currently implements \n- * the following checks:</p>\n+ * <p>\n+ * A SAX-based TagLibraryValidator for the Joda tags. Currently implements the\n+ * following checks:\n+ * </p>\n  * \n  * <ul>\n- *   <li>Tag bodies that must either be empty or non-empty given\n- *      particular attributes.</li>\n- *   <li>Expression syntax validation (NOTE: this has been disabled; per my\n- *       understanding, it shouldn't be needed in JSP 2.0+ containers; see \n- *       notes in source code for more information).\n+ * <li>Tag bodies that must either be empty or non-empty given particular\n+ * attributes.</li>\n+ * <li>Expression syntax validation (NOTE: this has been disabled; per my\n+ * understanding, it shouldn't be needed in JSP 2.0+ containers; see notes in\n+ * source code for more information).\n  * </ul>\n  * \n  * @author Shawn Bayern\n  * @author Jim Newsham\n  */\n public class JodaTagLibraryValidator extends TagLibraryValidator {\n-  \n-  /*\n-   * Expression syntax validation has been disabled since when I ported this \n-   * code over from Jakarta Taglib, I wanted to reduce dependencies.  As I\n-   * understand it, JSP 2.0 containers take over the responsibility of handling\n-   * EL code (both in attribute tags, and externally), so this shouldn't be a\n-   * problem unless you're using something old.  If you want to restore this\n-   * validation, you must uncomment the various lines in this source, include\n-   * the Jakarta Taglib's standard.jar library at build and runtime, and \n-   * (I believe, but don't know specifically) make a legacy-style tld which \n-   * describes which attributes should be validated.  Have a look at fmt.tld, \n-   * fmt-1.0.tld, fmt-1.0-rt.tld in standard.jar for an example of this.\n-   */\n-   \n-\n-  //*********************************************************************\n-  // Implementation Overview\n-\n-  /*\n-  * We essentially just run the page through a SAX parser, handling\n-  * the callbacks that interest us.  We collapse <jsp:text> elements\n-  * into the text they contain, since this simplifies processing\n-  * somewhat.  Even a quick glance at the implementation shows its\n-  * necessary, tree-oriented nature:  multiple Stacks, an understanding\n-  * of 'depth', and so on all are important as we recover necessary\n-  * state upon each callback.  This TLV demonstrates various techniques,\n-  * from the general \"how do I use a SAX parser for a TLV?\" to\n-  * \"how do I read my init parameters and then validate?\"  But also,\n-  * the specific SAX methodology was kept as general as possible to\n-  * allow for experimentation and flexibility.\n-  */\n-\n-\n-  //*********************************************************************\n-  // Constants\n-\n-  // tag names\n-  private static final String SET_DATETIMEZONE = \"setDateTimeZone\";\n-  private static final String PARSE_DATETIME = \"parseDateTime\";\n-  private static final String JSP_TEXT = \"jsp:text\";\n-\n-  // attribute names\n-  private static final String VALUE = \"value\";\n-\n-  // parameter names\n-  //private final String EXP_ATT_PARAM = \"expressionAttributes\";\n-\n-  // attributes\n-  private static final String VAR = \"var\";\n-  private static final String SCOPE = \"scope\";  \n-\n-  //scopes\n-  private static final String PAGE_SCOPE = \"page\";        \n-  private static final String REQUEST_SCOPE = \"request\";  \n-  private static final String SESSION_SCOPE = \"session\";  \n-  private static final String APPLICATION_SCOPE = \"application\";\n-\n-  // Relevant URIs\n-  private final String JSP = \"http://java.sun.com/JSP/Page\"; \n-\n-\n-  //*********************************************************************\n-  // Validation and configuration state (protected)\n-\n-  private String uri;    // our taglib's uri (as passed by JSP container on XML View)\n-  private String prefix;  // our taglib's prefix\n-  private Vector messageVector;  // temporary error messages\n-  private Map config;    // configuration (Map of Sets)\n-  private boolean failed;  // have we failed >0 times?\n-  private String lastElementId;  // the last element we've seen\n-\n-  //*********************************************************************\n-  // Constructor and lifecycle management\n-\n-  public JodaTagLibraryValidator() {\n-    init();\n-  }\n-\n-  private void init() {\n-    messageVector = null;\n-    prefix = null;\n-    config = null;\n-  }\n-\n-  public void release() {\n-    super.release();\n-    init();\n-  }\n-\n-\n-  public synchronized ValidationMessage[] validate(String prefix, String uri, \n-    PageData page) {\n-    try {\n-      this.uri = uri;\n-      // initialize\n-      messageVector = new Vector();\n-\n-      // save the prefix\n-      this.prefix = prefix;\n-\n-      // parse parameters if necessary\n-      /*\n-      try {\n-        if (config == null) {\n-          configure((String) getInitParameters().get(EXP_ATT_PARAM));\n-        }\n-      } \n-      catch (NoSuchElementException ex) {\n-        // parsing error\n-        return vmFromString(Resources.getMessage(\"TLV_PARAMETER_ERROR\",\n-          EXP_ATT_PARAM));\n-      }\n-      */\n-\n-      DefaultHandler h = new Handler();\n-\n-      // parse the page\n-      SAXParserFactory f = SAXParserFactory.newInstance();\n-      f.setValidating(false);\n-      f.setNamespaceAware(true);\n-      SAXParser p = f.newSAXParser();\n-      p.parse(page.getInputStream(), h);\n-\n-      if (messageVector.size() == 0) {\n-        return null;\n-      }\n-      else {\n-        return vmFromVector(messageVector);\n-      }\n-    } \n-    catch (SAXException ex) {\n-      return vmFromString(ex.toString());\n-    } \n-    catch (ParserConfigurationException ex) {\n-      return vmFromString(ex.toString());\n-    } \n-    catch (IOException ex) {\n-      return vmFromString(ex.toString());\n-    }\n-  }\n-\n-  /*\n-  // delegate validation to the appropriate expression language\n-  private String validateExpression(String elem, String att, String expr) {\n-    // let's just use the cache kept by the ExpressionEvaluatorManager\n-    ExpressionEvaluator current;\n-    try {\n-      current = ExpressionEvaluatorManager.getEvaluatorByName(\n-        ExpressionEvaluatorManager.EVALUATOR_CLASS);\n-    } \n-    catch (JspException ex) {\n-      // (using JspException here feels ugly, but it's what EEM uses)\n-      return ex.getMessage();\n-    }\n-    String response = current.validate(att, expr);\n-    return (response == null) \n-      ? null : \"tag = '\" + elem + \"' / attribute = '\" + att + \"': \" + response;\n-  }\n-   */\n-\n-  // utility methods to help us match elements in our tagset\n-  private boolean isTag(String tagUri, String tagLn, String matchUri,\n-    String matchLn) {\n-    if (tagUri == null || tagLn == null || matchUri == null || \n-      matchLn == null) {\n-      return false;\n-    }\n-    // match beginning of URI since some suffix *_rt tags can\n-    // be nested in EL enabled tags as defined by the spec\n-    if (tagUri.length() > matchUri.length()) {\n-      return (tagUri.startsWith(matchUri) && tagLn.equals(matchLn));\n-    } \n-    else {\n-      return (matchUri.startsWith(tagUri) && tagLn.equals(matchLn));\n-    }\n-  }\n-\n-  private boolean isJspTag(String tagUri, String tagLn, String target) {\n-    return isTag(tagUri, tagLn, JSP, target);\n-  }\n-\n-  private boolean isJodaTag(String tagUri, String tagLn, String target) {\n-    return isTag(tagUri, tagLn, this.uri, target);\n-  }\n-\n-  // utility method to determine if an attribute exists\n-  private boolean hasAttribute(Attributes a, String att) {\n-    return (a.getValue(att) != null);\n-  }\n-\n-  /*\n-  * method to assist with failure [ as if it's not easy enough\n-  * already :-) ]\n-  */\n-  private void fail(String message) {\n-    failed = true;\n-    messageVector.add(new ValidationMessage(lastElementId, message));\n-  }\n-\n-  // returns true if the given attribute name is specified, false otherwise\n-  private boolean isSpecified(TagData data, String attributeName) {\n-    return (data.getAttribute(attributeName) != null);\n-  }\n-\n-  // returns true if the 'scope' attribute is valid\n-  protected boolean hasNoInvalidScope(Attributes a) {\n-    String scope = a.getValue(SCOPE);\n-    if ((scope != null) && !scope.equals(PAGE_SCOPE) &&\n-      !scope.equals(REQUEST_SCOPE) && !scope.equals(SESSION_SCOPE) &&\n-      !scope.equals(APPLICATION_SCOPE)) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  // returns true if the 'var' attribute is empty\n-  protected boolean hasEmptyVar(Attributes a) {\n-    return \"\".equals(a.getValue(VAR));\n-  }\n-\n-  // returns true if the 'scope' attribute is present without 'var'\n-  protected boolean hasDanglingScope(Attributes a) {\n-    return (a.getValue(SCOPE) != null && a.getValue(VAR) == null);\n-  }\n-\n-  // retrieves the local part of a QName\n-  protected String getLocalPart(String qname) {\n-    int colon = qname.indexOf(\":\");\n-    return (colon == -1) ? qname : qname.substring(colon + 1);\n-  }\n-\n-  // parses our configuration parameter for element:attribute pairs\n-  /*\n-  private void configure(String info) {\n-    // construct our configuration map\n-    config = new HashMap();\n-\n-    // leave the map empty if we have nothing to configure\n-    if (info == null) {\n-      return;\n-    }\n-\n-    // separate parameter into space-separated tokens and store them\n-    StringTokenizer st = new StringTokenizer(info);\n-    while (st.hasMoreTokens()) {\n-      String pair = st.nextToken();\n-      StringTokenizer pairTokens = new StringTokenizer(pair, \":\");\n-      String element = pairTokens.nextToken();\n-      String attribute = pairTokens.nextToken();\n-      Object atts = config.get(element);\n-      if (atts == null) {\n-        atts = new HashSet();\n-        config.put(element, atts);\n-      }\n-      ((Set) atts).add(attribute);\n-    }\n-  }\n-  */\n-\n-  // constructs a ValidationMessage[] from a single String and no ID\n-  private static ValidationMessage[] vmFromString(String message) {\n-    return new ValidationMessage[] { new ValidationMessage(null, message) };\n-  }\n-\n-  // constructs a ValidationMessage[] from a ValidationMessage Vector\n-  private static ValidationMessage[] vmFromVector(Vector v) {\n-    ValidationMessage[] vm = new ValidationMessage[v.size()];\n-    for (int i = 0; i < vm.length; i++) {\n-      vm[i] = (ValidationMessage) v.get(i);\n-    }\n-    return vm;\n-  }\n-\n-  /**\n-   * SAX event handler.\n-   */\n-  private class Handler extends DefaultHandler {\n-    // parser state\n-    private int depth = 0;\n-    private String lastElementName = null;\n-    private boolean bodyNecessary = false;\n-    private boolean bodyIllegal = false;\n-\n-    // process under the existing context (state), then modify it\n-    public void startElement(String ns, String ln, String qn, Attributes a) {\n-      // substitute our own parsed 'ln' if it's not provided\n-      if (ln == null) {\n-        ln = getLocalPart(qn);\n-      }\n-\n-      // for simplicity, we can ignore <jsp:text> for our purposes\n-      // (don't bother distinguishing between it and its characters)\n-      if (qn.equals(JSP_TEXT)) {\n-        return;\n-      }\n-\n-      // check body-related constraint\n-      if (bodyIllegal) {\n-        fail(Resources.getMessage(\"TLV_ILLEGAL_BODY\", lastElementName));\n-      }\n-\n-      // validate expression syntax if we need to\n-      /*\n-      Set expAtts;\n-      if (qn.startsWith(prefix + \":\") && (expAtts = (Set) config.get(ln)) != null) {\n-        for (int i = 0; i < a.getLength(); i++) {\n-          String attName = a.getLocalName(i);\n-          if (expAtts.contains(attName)) {\n-            String vMsg = validateExpression(ln, attName, a.getValue(i));\n-            if (vMsg != null) {\n-              fail(vMsg);\n-            }\n-          }\n-        }\n-      }\n-      */\n-\n-      // validate attributes\n-      if (qn.startsWith(prefix + \":\") && !hasNoInvalidScope(a)) {\n-        fail(Resources.getMessage(\"TLV_INVALID_ATTRIBUTE\", SCOPE, qn, \n-          a.getValue(SCOPE)));\n-      }\n-      if (qn.startsWith(prefix + \":\") && hasEmptyVar(a)) {\n-        fail(Resources.getMessage(\"TLV_EMPTY_VAR\", qn));\n-      }\n-      if (qn.startsWith(prefix + \":\") && !isJodaTag(ns, ln, SET_DATETIMEZONE) &&\n-        hasDanglingScope(a)) {\n-        fail(Resources.getMessage(\"TLV_DANGLING_SCOPE\", qn));\n-      }\n-\n-      // now, modify state\n-\n-      // set up a check against illegal attribute/body combinations\n-      bodyIllegal = false;\n-      bodyNecessary = false;\n-      if (isJodaTag(ns, ln,  PARSE_DATETIME)) {\n-        if (hasAttribute(a, VALUE)) {\n-          bodyIllegal = true;\n-        }\n-        else {\n-          bodyNecessary = true;\n-        }\n-      } \n-\n-      // record the most recent tag (for error reporting)\n-      lastElementName = qn;\n-      lastElementId = a.getValue(JSP, \"id\");\n-\n-      // we're a new element, so increase depth\n-      depth++;\n-    }\n-\n-    public void characters(char[] ch, int start, int length) {\n-      bodyNecessary = false;    // body is no longer necessary!\n-\n-      // ignore strings that are just whitespace\n-      String s = new String(ch, start, length).trim();\n-      if (s.equals(\"\")) {\n-        return;\n-      }\n-\n-      // check and update body-related constraints\n-      if (bodyIllegal) {\n-        fail(Resources.getMessage(\"TLV_ILLEGAL_BODY\", lastElementName));\n-      }\n-    }\n-\n-    public void endElement(String ns, String ln, String qn) {\n-      // consistently, we ignore JSP_TEXT\n-      if (qn.equals(JSP_TEXT)) {\n-        return;\n-      }\n-\n-      // handle body-related invariant\n-      if (bodyNecessary) {\n-        fail(Resources.getMessage(\"TLV_MISSING_BODY\", lastElementName));\n-      }\n-      bodyIllegal = false;  // reset: we've left the tag\n-\n-      // update our depth\n-      depth--;\n-    }\n-  }\n+\n+    /*\n+     * Expression syntax validation has been disabled since when I ported this\n+     * code over from Jakarta Taglib, I wanted to reduce dependencies. As I\n+     * understand it, JSP 2.0 containers take over the responsibility of\n+     * handling EL code (both in attribute tags, and externally), so this\n+     * shouldn't be a problem unless you're using something old. If you want to\n+     * restore this validation, you must uncomment the various lines in this\n+     * source, include the Jakarta Taglib's standard.jar library at build and\n+     * runtime, and (I believe, but don't know specifically) make a legacy-style\n+     * tld which describes which attributes should be validated. Have a look at\n+     * fmt.tld, fmt-1.0.tld, fmt-1.0-rt.tld in standard.jar for an example of\n+     * this.\n+     */\n+\n+    // *********************************************************************\n+    // Implementation Overview\n+    /*\n+     * We essentially just run the page through a SAX parser, handling the\n+     * callbacks that interest us. We collapse <jsp:text> elements into the text\n+     * they contain, since this simplifies processing somewhat. Even a quick\n+     * glance at the implementation shows its necessary, tree-oriented nature:\n+     * multiple Stacks, an understanding of 'depth', and so on all are important\n+     * as we recover necessary state upon each callback. This TLV demonstrates\n+     * various techniques, from the general \"how do I use a SAX parser for a\n+     * TLV?\" to \"how do I read my init parameters and then validate?\" But also,\n+     * the specific SAX methodology was kept as general as possible to allow for\n+     * experimentation and flexibility.\n+     */\n+\n+    // *********************************************************************\n+    // Constants\n+    // tag names\n+    private static final String SET_DATETIMEZONE = \"setDateTimeZone\";\n+\n+    private static final String PARSE_DATETIME = \"parseDateTime\";\n+\n+    private static final String JSP_TEXT = \"jsp:text\";\n+\n+    // attribute names\n+    private static final String VALUE = \"value\";\n+\n+    // parameter names\n+    // private final String EXP_ATT_PARAM = \"expressionAttributes\";\n+\n+    // attributes\n+    private static final String VAR = \"var\";\n+\n+    private static final String SCOPE = \"scope\";\n+\n+    // scopes\n+    private static final String PAGE_SCOPE = \"page\";\n+\n+    private static final String REQUEST_SCOPE = \"request\";\n+\n+    private static final String SESSION_SCOPE = \"session\";\n+\n+    private static final String APPLICATION_SCOPE = \"application\";\n+\n+    // Relevant URIs\n+    private final String JSP = \"http://java.sun.com/JSP/Page\";\n+\n+    // *********************************************************************\n+    // Validation and configuration state (protected)\n+\n+    private String uri; // our taglib's uri (as passed by JSP container on XML\n+                        // View)\n+\n+    private String prefix; // our taglib's prefix\n+\n+    private Vector messageVector; // temporary error messages\n+\n+//    private Map config; // configuration (Map of Sets)\n+//\n+//    private boolean failed; // have we failed >0 times?\n+\n+    private String lastElementId; // the last element we've seen\n+\n+    // *********************************************************************\n+    // Constructor and lifecycle management\n+\n+    public JodaTagLibraryValidator() {\n+        init();\n+    }\n+\n+    private void init() {\n+        messageVector = null;\n+        prefix = null;\n+//        config = null;\n+    }\n+\n+    public void release() {\n+        super.release();\n+        init();\n+    }\n+\n+    public synchronized ValidationMessage[] validate(String prefix, String uri,\n+            PageData page) {\n+        try {\n+            this.uri = uri;\n+            // initialize\n+            messageVector = new Vector();\n+\n+            // save the prefix\n+            this.prefix = prefix;\n+\n+            // parse parameters if necessary\n+            /*\n+             * try { if (config == null) { configure((String)\n+             * getInitParameters().get(EXP_ATT_PARAM)); } } catch\n+             * (NoSuchElementException ex) { // parsing error return\n+             * vmFromString(Resources.getMessage(\"TLV_PARAMETER_ERROR\",\n+             * EXP_ATT_PARAM)); }\n+             */\n+\n+            DefaultHandler h = new Handler();\n+\n+            // parse the page\n+            SAXParserFactory f = SAXParserFactory.newInstance();\n+            f.setValidating(false);\n+            f.setNamespaceAware(true);\n+            SAXParser p = f.newSAXParser();\n+            p.parse(page.getInputStream(), h);\n+\n+            if (messageVector.size() == 0) {\n+                return null;\n+            } else {\n+                return vmFromVector(messageVector);\n+            }\n+        } catch (SAXException ex) {\n+            return vmFromString(ex.toString());\n+        } catch (ParserConfigurationException ex) {\n+            return vmFromString(ex.toString());\n+        } catch (IOException ex) {\n+            return vmFromString(ex.toString());\n+        }\n+    }\n+\n+    /*\n+     * // delegate validation to the appropriate expression language private\n+     * String validateExpression(String elem, String att, String expr) { //\n+     * let's just use the cache kept by the ExpressionEvaluatorManager\n+     * ExpressionEvaluator current; try { current =\n+     * ExpressionEvaluatorManager.getEvaluatorByName(\n+     * ExpressionEvaluatorManager.EVALUATOR_CLASS); } catch (JspException ex) { //\n+     * (using JspException here feels ugly, but it's what EEM uses) return\n+     * ex.getMessage(); } String response = current.validate(att, expr); return\n+     * (response == null) ? null : \"tag = '\" + elem + \"' / attribute = '\" + att +\n+     * \"': \" + response; }\n+     */\n+\n+    // utility methods to help us match elements in our tagset\n+    private boolean isTag(String tagUri, String tagLn, String matchUri,\n+            String matchLn) {\n+        if (tagUri == null || tagLn == null || matchUri == null\n+                || matchLn == null) {\n+            return false;\n+        }\n+        // match beginning of URI since some suffix *_rt tags can\n+        // be nested in EL enabled tags as defined by the spec\n+        if (tagUri.length() > matchUri.length()) {\n+            return (tagUri.startsWith(matchUri) && tagLn.equals(matchLn));\n+        } else {\n+            return (matchUri.startsWith(tagUri) && tagLn.equals(matchLn));\n+        }\n+    }\n+\n+//    private boolean isJspTag(String tagUri, String tagLn, String target) {\n+//        return isTag(tagUri, tagLn, JSP, target);\n+//    }\n+\n+    private boolean isJodaTag(String tagUri, String tagLn, String target) {\n+        return isTag(tagUri, tagLn, this.uri, target);\n+    }\n+\n+    // utility method to determine if an attribute exists\n+    private boolean hasAttribute(Attributes a, String att) {\n+        return (a.getValue(att) != null);\n+    }\n+\n+    /*\n+     * method to assist with failure [ as if it's not easy enough already :-) ]\n+     */\n+    private void fail(String message) {\n+//        failed = true;\n+        messageVector.add(new ValidationMessage(lastElementId, message));\n+    }\n+\n+//    // returns true if the given attribute name is specified, false otherwise\n+//    private boolean isSpecified(TagData data, String attributeName) {\n+//        return (data.getAttribute(attributeName) != null);\n+//    }\n+\n+    // returns true if the 'scope' attribute is valid\n+    protected boolean hasNoInvalidScope(Attributes a) {\n+        String scope = a.getValue(SCOPE);\n+        if ((scope != null) && !scope.equals(PAGE_SCOPE)\n+                && !scope.equals(REQUEST_SCOPE) && !scope.equals(SESSION_SCOPE)\n+                && !scope.equals(APPLICATION_SCOPE)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    // returns true if the 'var' attribute is empty\n+    protected boolean hasEmptyVar(Attributes a) {\n+        return \"\".equals(a.getValue(VAR));\n+    }\n+\n+    // returns true if the 'scope' attribute is present without 'var'\n+    protected boolean hasDanglingScope(Attributes a) {\n+        return (a.getValue(SCOPE) != null && a.getValue(VAR) == null);\n+    }\n+\n+    // retrieves the local part of a QName\n+    protected String getLocalPart(String qname) {\n+        int colon = qname.indexOf(\":\");\n+        return (colon == -1) ? qname : qname.substring(colon + 1);\n+    }\n+\n+    // parses our configuration parameter for element:attribute pairs\n+    /*\n+     * private void configure(String info) { // construct our configuration map\n+     * config = new HashMap();\n+     *  // leave the map empty if we have nothing to configure if (info == null) {\n+     * return; }\n+     *  // separate parameter into space-separated tokens and store them\n+     * StringTokenizer st = new StringTokenizer(info); while\n+     * (st.hasMoreTokens()) { String pair = st.nextToken(); StringTokenizer\n+     * pairTokens = new StringTokenizer(pair, \":\"); String element =\n+     * pairTokens.nextToken(); String attribute = pairTokens.nextToken(); Object\n+     * atts = config.get(element); if (atts == null) { atts = new HashSet();\n+     * config.put(element, atts); } ((Set) atts).add(attribute); } }\n+     */\n+\n+    // constructs a ValidationMessage[] from a single String and no ID\n+    private static ValidationMessage[] vmFromString(String message) {\n+        return new ValidationMessage[] { new ValidationMessage(null, message) };\n+    }\n+\n+    // constructs a ValidationMessage[] from a ValidationMessage Vector\n+    private static ValidationMessage[] vmFromVector(Vector v) {\n+        ValidationMessage[] vm = new ValidationMessage[v.size()];\n+        for (int i = 0; i < vm.length; i++) {\n+            vm[i] = (ValidationMessage) v.get(i);\n+        }\n+        return vm;\n+    }\n+\n+    /**\n+     * SAX event handler.\n+     */\n+    private class Handler extends DefaultHandler {\n+        // parser state\n+        private int depth = 0;\n+\n+        private String lastElementName = null;\n+\n+        private boolean bodyNecessary = false;\n+\n+        private boolean bodyIllegal = false;\n+\n+        // process under the existing context (state), then modify it\n+        public void startElement(String ns, String ln, String qn, Attributes a) {\n+            // substitute our own parsed 'ln' if it's not provided\n+            if (ln == null) {\n+                ln = getLocalPart(qn);\n+            }\n+\n+            // for simplicity, we can ignore <jsp:text> for our purposes\n+            // (don't bother distinguishing between it and its characters)\n+            if (qn.equals(JSP_TEXT)) {\n+                return;\n+            }\n+\n+            // check body-related constraint\n+            if (bodyIllegal) {\n+                fail(Resources.getMessage(\"TLV_ILLEGAL_BODY\", lastElementName));\n+            }\n+\n+            // validate expression syntax if we need to\n+            /*\n+             * Set expAtts; if (qn.startsWith(prefix + \":\") && (expAtts = (Set)\n+             * config.get(ln)) != null) { for (int i = 0; i < a.getLength();\n+             * i++) { String attName = a.getLocalName(i); if\n+             * (expAtts.contains(attName)) { String vMsg =\n+             * validateExpression(ln, attName, a.getValue(i)); if (vMsg != null) {\n+             * fail(vMsg); } } } }\n+             */\n+\n+            // validate attributes\n+            if (qn.startsWith(prefix + \":\") && !hasNoInvalidScope(a)) {\n+                fail(Resources.getMessage(\"TLV_INVALID_ATTRIBUTE\", SCOPE, qn, a\n+                        .getValue(SCOPE)));\n+            }\n+            if (qn.startsWith(prefix + \":\") && hasEmptyVar(a)) {\n+                fail(Resources.getMessage(\"TLV_EMPTY_VAR\", qn));\n+            }\n+            if (qn.startsWith(prefix + \":\")\n+                    && !isJodaTag(ns, ln, SET_DATETIMEZONE)\n+                    && hasDanglingScope(a)) {\n+                fail(Resources.getMessage(\"TLV_DANGLING_SCOPE\", qn));\n+            }\n+\n+            // now, modify state\n+\n+            // set up a check against illegal attribute/body combinations\n+            bodyIllegal = false;\n+            bodyNecessary = false;\n+            if (isJodaTag(ns, ln, PARSE_DATETIME)) {\n+                if (hasAttribute(a, VALUE)) {\n+                    bodyIllegal = true;\n+                } else {\n+                    bodyNecessary = true;\n+                }\n+            }\n+\n+            // record the most recent tag (for error reporting)\n+            lastElementName = qn;\n+            lastElementId = a.getValue(JSP, \"id\");\n+\n+            // we're a new element, so increase depth\n+            depth++;\n+        }\n+\n+        public void characters(char[] ch, int start, int length) {\n+            bodyNecessary = false; // body is no longer necessary!\n+\n+            // ignore strings that are just whitespace\n+            String s = new String(ch, start, length).trim();\n+            if (s.equals(\"\")) {\n+                return;\n+            }\n+\n+            // check and update body-related constraints\n+            if (bodyIllegal) {\n+                fail(Resources.getMessage(\"TLV_ILLEGAL_BODY\", lastElementName));\n+            }\n+        }\n+\n+        public void endElement(String ns, String ln, String qn) {\n+            // consistently, we ignore JSP_TEXT\n+            if (qn.equals(JSP_TEXT)) {\n+                return;\n+            }\n+\n+            // handle body-related invariant\n+            if (bodyNecessary) {\n+                fail(Resources.getMessage(\"TLV_MISSING_BODY\", lastElementName));\n+            }\n+            bodyIllegal = false; // reset: we've left the tag\n+\n+            // update our depth\n+            depth--;\n+        }\n+    }\n+\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeSupport.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeSupport.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.io.IOException;\n import org.joda.time.format.DateTimeFormatter;\n \n /**\n- * Support for tag handlers for &lt;parseDate&gt;, the date and time\n- * parsing tag in JSTL 1.0.\n+ * Support for tag handlers for &lt;parseDate&gt;, the date and time parsing tag\n+ * in JSTL 1.0.\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public abstract class ParseDateTimeSupport extends BodyTagSupport {\n \n-  protected String value;                      // 'value' attribute\n-  protected boolean valueSpecified;         // status\n-  protected String pattern;                    // 'pattern' attribute\n-  protected String style;                      // 'style' attribute\n-  protected DateTimeZone dateTimeZone;         // 'dateTimeZone' attribute\n-  protected Locale locale;                     // 'locale' attribute\n+    /** The value attribute. */\n+    protected String value;\n+    /** Status of the value. */\n+    protected boolean valueSpecified;\n+    /** The pattern attribute. */\n+    protected String pattern;\n+    /** The style attribute. */\n+    protected String style;\n+    /** The zone attribute. */\n+    protected DateTimeZone dateTimeZone;\n+    /** The locale attribute. */\n+    protected Locale locale;\n+    /** The var attribute. */\n+    private String var;\n+    /** The scope attribute. */\n+    private int scope;\n \n-  private String var;                          // 'var' attribute\n-  private int scope;                           // 'scope' attribute\n-\n-  public ParseDateTimeSupport() {\n-    super();\n-    init();\n-  }\n-\n-  private void init() {\n-    value = null;\n-    valueSpecified = false;\n-    pattern = null;\n-    style = null;\n-    dateTimeZone = null;\n-    locale = null;\n-    scope = PageContext.PAGE_SCOPE;\n-  }\n-\n-  public void setVar(String var) {\n-    this.var = var;\n-  }\n-\n-  public void setScope(String scope) {\n-    this.scope = Util.getScope(scope);\n-  }\n-\n-  public int doEndTag() throws JspException {\n-    String input = null;\n-\n-    // determine the input by...\n-    if (valueSpecified) {\n-      // ... reading 'value' attribute\n-      input = value;\n-    } \n-    else {\n-      // ... retrieving and trimming our body\n-      if (bodyContent != null && bodyContent.getString() != null)\n-      input = bodyContent.getString().trim();\n+    /**\n+     * Constructor.\n+     */\n+    public ParseDateTimeSupport() {\n+        super();\n+        init();\n     }\n \n-    if ((input == null) || input.equals(\"\")) {\n-      if (var != null) {\n-        pageContext.removeAttribute(var, scope);\n-      }\n-      return EVAL_PAGE;\n+    private void init() {\n+        value = null;\n+        valueSpecified = false;\n+        pattern = null;\n+        style = null;\n+        dateTimeZone = null;\n+        locale = null;\n+        scope = PageContext.PAGE_SCOPE;\n     }\n \n-    // Create formatter\n-    DateTimeFormatter formatter;\n-    if (pattern != null) {\n-      formatter = DateTimeFormat.forPattern(pattern);\n-    }\n-    else if (style != null) {\n-      formatter = DateTimeFormat.forStyle(style);\n-    }\n-    else {\n-      formatter = DateTimeFormat.fullDateTime();\n+    public void setVar(String var) {\n+        this.var = var;\n     }\n \n-    // set formatter locale\n-    Locale locale = this.locale;\n-    if (locale == null) {\n-      locale = Util.getFormattingLocale(pageContext, this, true,\n-        DateFormat.getAvailableLocales());\n-    }\n-    if (locale != null) {\n-      formatter = formatter.withLocale(locale);\n+    public void setScope(String scope) {\n+        this.scope = Util.getScope(scope);\n     }\n \n-    // set formatter timezone\n-    DateTimeZone tz = this.dateTimeZone;\n-    if (tz == null) {\n-      tz = DateTimeZoneSupport.getDateTimeZone(pageContext, this);\n-    }\n-    if (tz != null) {\n-      formatter = formatter.withZone(tz);\n+    public int doEndTag() throws JspException {\n+        String input = null;\n+\n+        // determine the input by...\n+        if (valueSpecified) {\n+            // ... reading 'value' attribute\n+            input = value;\n+        } else {\n+            // ... retrieving and trimming our body\n+            if (bodyContent != null && bodyContent.getString() != null)\n+                input = bodyContent.getString().trim();\n+        }\n+\n+        if ((input == null) || input.equals(\"\")) {\n+            if (var != null) {\n+                pageContext.removeAttribute(var, scope);\n+            }\n+            return EVAL_PAGE;\n+        }\n+\n+        // Create formatter\n+        DateTimeFormatter formatter;\n+        if (pattern != null) {\n+            formatter = DateTimeFormat.forPattern(pattern);\n+        } else if (style != null) {\n+            formatter = DateTimeFormat.forStyle(style);\n+        } else {\n+            formatter = DateTimeFormat.fullDateTime();\n+        }\n+\n+        // set formatter locale\n+        Locale locale = this.locale;\n+        if (locale == null) {\n+            locale = Util.getFormattingLocale(pageContext, this, true,\n+                    DateFormat.getAvailableLocales());\n+        }\n+        if (locale != null) {\n+            formatter = formatter.withLocale(locale);\n+        }\n+\n+        // set formatter timezone\n+        DateTimeZone tz = this.dateTimeZone;\n+        if (tz == null) {\n+            tz = DateTimeZoneSupport.getDateTimeZone(pageContext, this);\n+        }\n+        if (tz != null) {\n+            formatter = formatter.withZone(tz);\n+        }\n+\n+        // Parse date\n+        DateTime parsed = null;\n+        try {\n+            parsed = formatter.parseDateTime(input);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JspException(Resources.getMessage(\n+                    \"PARSE_DATE_PARSE_ERROR\", input), iae);\n+        }\n+\n+        if (var != null) {\n+            pageContext.setAttribute(var, parsed, scope);\n+        } else {\n+            try {\n+                pageContext.getOut().print(parsed);\n+            } catch (IOException ioe) {\n+                throw new JspTagException(ioe.toString(), ioe);\n+            }\n+        }\n+\n+        return EVAL_PAGE;\n     }\n \n-    // Parse date\n-    DateTime parsed = null;\n-    try {\n-      parsed = formatter.parseDateTime(input);\n-    } \n-    catch (IllegalArgumentException iae) {\n-      throw new JspException(Resources.getMessage(\"PARSE_DATE_PARSE_ERROR\", \n-        input), iae);\n+    // Releases any resources we may have (or inherit)\n+    public void release() {\n+        init();\n     }\n \n-    if (var != null) {\n-      pageContext.setAttribute(var, parsed, scope);  \n-    }\n-    else {\n-      try {\n-        pageContext.getOut().print(parsed);\n-      } \n-      catch (IOException ioe) {\n-        throw new JspTagException(ioe.toString(), ioe);\n-      }\n-    }\n-\n-    return EVAL_PAGE;\n-  }\n-\n-  // Releases any resources we may have (or inherit)\n-  public void release() {\n-    init();\n-  }\n-\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeTag.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeTag.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.util.Locale;\n import org.joda.time.DateTimeZone;\n \n /**\n- * <p>A handler for &lt;parseDate&gt; that supports rtexprvalue-based\n- * attributes.</p>\n+ * <p>\n+ * A handler for &lt;parseDate&gt; that supports rtexprvalue-based attributes.\n+ * </p>\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n \n public class ParseDateTimeTag extends ParseDateTimeSupport {\n \n-  // 'value' attribute\n-  public void setValue(String value) throws JspTagException {\n-    this.value = value;\n-    this.valueSpecified = true;\n-  }\n+    /**\n+     * Sets the value attribute.\n+     * \n+     * @param value  the value\n+     */\n+    public void setValue(String value) throws JspTagException {\n+        this.value = value;\n+        this.valueSpecified = true;\n+    }\n \n-  // 'style' attribute\n-  public void setStyle(String style) throws JspTagException {\n-    this.style = style;\n-  }\n+    /**\n+     * Sets the style attribute.\n+     * \n+     * @param style  the style\n+     */\n+    public void setStyle(String style) throws JspTagException {\n+        this.style = style;\n+    }\n \n-  // 'pattern' attribute\n-  public void setPattern(String pattern) throws JspTagException {\n-    this.pattern = pattern;\n-  }\n+    /**\n+     * Sets the pattern attribute.\n+     * \n+     * @param pattern  the pattern\n+     */\n+    public void setPattern(String pattern) throws JspTagException {\n+        this.pattern = pattern;\n+    }\n \n-  // 'dateTimeZone' attribute\n-  public void setDateTimeZone(Object dtz) throws JspTagException {\n-    if (dtz == null || dtz instanceof String && ((String) dtz).length() == 0) {\n-      this.dateTimeZone = null;\n+    /**\n+     * Sets the zone attribute.\n+     * \n+     * @param dtz  the zone\n+     */\n+    public void setDateTimeZone(Object dtz) throws JspTagException {\n+        if (dtz == null || dtz instanceof String\n+                && ((String) dtz).length() == 0) {\n+            this.dateTimeZone = null;\n+        } else if (dtz instanceof DateTimeZone) {\n+            this.dateTimeZone = (DateTimeZone) dtz;\n+        } else {\n+            try {\n+                this.dateTimeZone = DateTimeZone.forID((String) dtz);\n+            } catch (IllegalArgumentException iae) {\n+                this.dateTimeZone = DateTimeZone.UTC;\n+            }\n+        }\n     }\n-    else if (dtz instanceof DateTimeZone) {\n-      this.dateTimeZone = (DateTimeZone) dtz;\n+\n+    /**\n+     * Sets the style attribute.\n+     * \n+     * @param loc  the locale\n+     */\n+    public void setLocale(Object loc) throws JspTagException {\n+        if (loc == null\n+                || (loc instanceof String && ((String) loc).length() == 0)) {\n+            this.locale = null;\n+        } else if (loc instanceof Locale) {\n+            this.locale = (Locale) loc;\n+        } else {\n+            locale = Util.parseLocale((String) loc);\n+        }\n     }\n-    else {\n-      try {\n-        String s = (String) dtz;\n-        this.dateTimeZone = DateTimeZone.forID((String) dtz);\n-      }\n-      catch(IllegalArgumentException iae) {\n-        this.dateTimeZone = DateTimeZone.UTC;\n-      }\n-    }\n-  }\n \n-  // 'locale' attribute\n-  public void setLocale(Object loc) throws JspTagException {\n-    if (loc == null || \n-      (loc instanceof String && ((String) loc).length() == 0)) {\n-      this.locale = null;\n-    }\n-    else if (loc instanceof Locale) {\n-      this.locale = (Locale) loc;\n-    } \n-    else {\n-      locale = Util.parseLocale((String) loc);\n-    }\n-  }\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Resources.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Resources.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */ \n-\n package org.joda.time.contrib.jsptag;\n \n import java.text.MessageFormat;\n     // Static data\n \n     /** The location of our resources. */\n-    private static final String RESOURCE_LOCATION\n-  = \"org.joda.time.contrib.jsptag.Resources\";\n+    private static final String RESOURCE_LOCATION = \"org.joda.time.contrib.jsptag.Resources\";\n \n     /** Our class-wide ResourceBundle. */\n-    private static ResourceBundle rb =\n-  ResourceBundle.getBundle(RESOURCE_LOCATION);\n+    private static ResourceBundle rb = ResourceBundle.getBundle(RESOURCE_LOCATION);\n \n \n     //*********************************************************************\n     /** Retrieves a message with no arguments. */\n     public static String getMessage(String name)\n       throws MissingResourceException {\n-  return rb.getString(name);\n+        return rb.getString(name);\n     }\n \n     /** Retrieves a message with arbitrarily many arguments. */\n     public static String getMessage(String name, Object[] a)\n       throws MissingResourceException {\n-  String res = rb.getString(name);\n-  return MessageFormat.format(res, a);\n+        String res = rb.getString(name);\n+        return MessageFormat.format(res, a);\n     }\n \n     /** Retrieves a message with one argument. */\n     public static String getMessage(String name, Object a1)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1 });\n+        return getMessage(name, new Object[] { a1 });\n     }\n \n     /** Retrieves a message with two arguments. */\n     public static String getMessage(String name, Object a1, Object a2)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1, a2 });\n+        return getMessage(name, new Object[] { a1, a2 });\n     }\n \n     /** Retrieves a message with three arguments. */\n             Object a2,\n             Object a3)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1, a2, a3 });\n+        return getMessage(name, new Object[] { a1, a2, a3 });\n     }\n \n     /** Retrieves a message with four arguments. */\n             Object a3,\n             Object a4)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1, a2, a3, a4 });\n+        return getMessage(name, new Object[] { a1, a2, a3, a4 });\n     }\n \n     /** Retrieves a message with five arguments. */\n             Object a4,\n             Object a5)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1, a2, a3, a4, a5 });\n+        return getMessage(name, new Object[] { a1, a2, a3, a4, a5 });\n     }\n \n     /** Retrieves a message with six arguments. */\n             Object a5,\n             Object a6)\n       throws MissingResourceException {\n-  return getMessage(name, new Object[] { a1, a2, a3, a4, a5, a6 });\n+        return getMessage(name, new Object[] { a1, a2, a3, a4, a5, a6 });\n     }\n \n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneSupport.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneSupport.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import javax.servlet.jsp.JspException;\n \n /**\n  * Support for tag handlers for &lt;setDateTimeZone&gt;.\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public abstract class SetDateTimeZoneSupport extends TagSupport {\n \n-  protected Object value;                      // 'value' attribute\n-  private int scope;                           // 'scope' attribute\n-  private String var;                          // 'var' attribute\n+    /** The value attribute. */\n+    protected Object value;\n+    /** The scope attribute. */\n+    private int scope;\n+    /** The var attribute. */\n+    private String var;\n \n-  public SetDateTimeZoneSupport() {\n-    super();\n-    init();\n-  }\n-\n-  // resets local state\n-  private void init() {\n-    value = null;\n-    var = null;\n-    scope = PageContext.PAGE_SCOPE;\n-  }\n-\n-  public void setScope(String scope) {\n-    this.scope = Util.getScope(scope);\n-  }\n-\n-  public void setVar(String var) {\n-    this.var = var;\n-  }\n-\n-  public int doEndTag() throws JspException {\n-    DateTimeZone dateTimeZone = null;\n-    if (value == null) {\n-      dateTimeZone = DateTimeZone.UTC;\n-    }\n-    else if (value instanceof String) {\n-      try {\n-        dateTimeZone = DateTimeZone.forID((String) value);\n-      }\n-      catch(IllegalArgumentException iae) {\n-        dateTimeZone = DateTimeZone.UTC;\n-      }\n-    } \n-    else {\n-      dateTimeZone = (DateTimeZone) value;\n+    /**\n+     * Constructor.\n+     */\n+    public SetDateTimeZoneSupport() {\n+        super();\n+        init();\n     }\n \n-    if (var != null) {\n-      pageContext.setAttribute(var, dateTimeZone, scope);\n-    } \n-    else {\n-      Config.set(pageContext, DateTimeZoneSupport.FMT_TIME_ZONE, \n-      dateTimeZone, scope);\n+    // resets local state\n+    private void init() {\n+        value = null;\n+        var = null;\n+        scope = PageContext.PAGE_SCOPE;\n     }\n \n-    return EVAL_PAGE;\n-  }\n+    public void setScope(String scope) {\n+        this.scope = Util.getScope(scope);\n+    }\n \n-  // Releases any resources we may have (or inherit)\n-  public void release() {\n-    init();\n-  }\n-  \n+    public void setVar(String var) {\n+        this.var = var;\n+    }\n+\n+    public int doEndTag() throws JspException {\n+        DateTimeZone dateTimeZone = null;\n+        if (value == null) {\n+            dateTimeZone = DateTimeZone.UTC;\n+        } else if (value instanceof String) {\n+            try {\n+                dateTimeZone = DateTimeZone.forID((String) value);\n+            } catch (IllegalArgumentException iae) {\n+                dateTimeZone = DateTimeZone.UTC;\n+            }\n+        } else {\n+            dateTimeZone = (DateTimeZone) value;\n+        }\n+\n+        if (var != null) {\n+            pageContext.setAttribute(var, dateTimeZone, scope);\n+        } else {\n+            Config.set(pageContext, DateTimeZoneSupport.FMT_TIME_ZONE,\n+                    dateTimeZone, scope);\n+        }\n+\n+        return EVAL_PAGE;\n+    }\n+\n+    // Releases any resources we may have (or inherit)\n+    public void release() {\n+        init();\n+    }\n+\n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneTag.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneTag.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import javax.servlet.jsp.JspTagException;\n \n /**\n- * <p>A handler for &lt;setDateTimeZone&gt; that supports rtexprvalue-based\n- * attributes.</p>\n+ * <p>\n+ * A handler for &lt;setDateTimeZone&gt; that supports rtexprvalue-based\n+ * attributes.\n+ * </p>\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public class SetDateTimeZoneTag extends SetDateTimeZoneSupport {\n \n-  // for tag attribute\n-  public void setValue(Object value) throws JspTagException {\n-    this.value = value;\n-  }\n+    /**\n+     * Sets the value attribute.\n+     * \n+     * @param value  the value\n+     */\n+    public void setValue(Object value) throws JspTagException {\n+        this.value = value;\n+    }\n \n }\n--- a/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Util.java\n+++ b/JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Util.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n-\n+ */\n package org.joda.time.contrib.jsptag;\n \n import java.text.DateFormat;\n import javax.servlet.jsp.tagext.Tag;\n \n /**\n- * <p>Utilities in support of tag-handler classes.</p>\n+ * <p>\n+ * Utilities in support of tag-handler classes.\n+ * </p>\n+ * \n  * @author Jan Luehe\n  * @author Jim Newsham\n  */\n public class Util {\n \n-  private static final String REQUEST = \"request\";   \n-  private static final String SESSION = \"session\";   \n-  private static final String APPLICATION = \"application\"; \n-  private static final char HYPHEN = '-';\n-  private static final char UNDERSCORE = '_';\n-\n-  private static final Locale EMPTY_LOCALE = new Locale(\"\", \"\");\n-\n-  static final String REQUEST_CHAR_SET =\n-    \"javax.servlet.jsp.jstl.fmt.request.charset\";\n-  \n-  /*\n-  * Converts the given string description of a scope to the corresponding\n-  * PageContext constant.\n-  *\n-  * The validity of the given scope has already been checked by the\n-  * appropriate TLV.\n-  *\n-  * @param scope String description of scope\n-  *\n-  * @return PageContext constant corresponding to given scope description\n-  */\n-  public static int getScope(String scope) {\n-    int ret = PageContext.PAGE_SCOPE; // default\n-\n-    if (REQUEST.equalsIgnoreCase(scope))\n-      ret = PageContext.REQUEST_SCOPE;\n-    else if (SESSION.equalsIgnoreCase(scope))\n-      ret = PageContext.SESSION_SCOPE;\n-    else if (APPLICATION.equalsIgnoreCase(scope))\n-      ret = PageContext.APPLICATION_SCOPE;\n-\n-    return ret;\n-  }\n-\n-  /**\n-  * HttpServletRequest.getLocales() returns the server's default locale \n-  * if the request did not specify a preferred language.\n-  * We do not want this behavior, because it prevents us from using\n-  * the fallback locale. \n-  * We therefore need to return an empty Enumeration if no preferred \n-  * locale has been specified. This way, the logic for the fallback \n-  * locale will be able to kick in.\n-  */\n-  public static Enumeration getRequestLocales(HttpServletRequest request) {        \n-    Enumeration values = request.getHeaders(\"accept-language\");\n-    if (values.hasMoreElements()) {\n-      // At least one \"accept-language\". Simply return\n-      // the enumeration returned by request.getLocales().\n-      // System.out.println(\"At least one accept-language\");\n-      return request.getLocales();\n-    } \n-    else {\n-      // No header for \"accept-language\". Simply return\n-      // the empty enumeration.\n-      // System.out.println(\"No accept-language\");\n-      return values;\n-    }\n-  }\n-\n-  /**\n-  * See parseLocale(String, String) for details.\n-  */\n-  public static Locale parseLocale(String locale) {\n-    return parseLocale(locale, null);\n-  }\n-\n-  /**\n-  * Parses the given locale string into its language and (optionally)\n-  * country components, and returns the corresponding\n-  * <tt>java.util.Locale</tt> object.\n-  *\n-  * If the given locale string is null or empty, the runtime's default\n-  * locale is returned.\n-  *\n-  * @param locale the locale string to parse\n-  * @param variant the variant\n-  *\n-  * @return <tt>java.util.Locale</tt> object corresponding to the given\n-  * locale string, or the runtime's default locale if the locale string is\n-  * null or empty\n-  *\n-  * @throws IllegalArgumentException if the given locale does not have a\n-  * language component or has an empty country component\n-  */\n-  public static Locale parseLocale(String locale, String variant) {\n-    Locale ret = null;\n-    String language = locale;\n-    String country = null;\n-    int index = -1;\n-\n-    if (((index = locale.indexOf(HYPHEN)) > -1)\n-      || ((index = locale.indexOf(UNDERSCORE)) > -1)) {\n-      language = locale.substring(0, index);\n-      country = locale.substring(index+1);\n-    }\n-\n-    if ((language == null) || (language.length() == 0)) {\n-      throw new IllegalArgumentException(\n-      Resources.getMessage(\"LOCALE_NO_LANGUAGE\"));\n-    }\n-\n-    if (country == null) {\n-      if (variant != null)\n-        ret = new Locale(language, \"\", variant);\n-      else\n-        ret = new Locale(language, \"\");\n-    } \n-    else if (country.length() > 0) {\n-      if (variant != null)\n-        ret = new Locale(language, country, variant);\n-      else\n-        ret = new Locale(language, country);\n-    } \n-    else {\n-      throw new IllegalArgumentException(\n-      Resources.getMessage(\"LOCALE_EMPTY_COUNTRY\"));\n-    }\n-\n-    return ret;\n-  }\n-\n-\n-  /*\n-  * Stores the given locale in the response object of the given page\n-  * context, and stores the locale's associated charset in the\n-  * javax.servlet.jsp.jstl.fmt.request.charset session attribute, which\n-  * may be used by the <requestEncoding> action in a page invoked by a\n-  * form included in the response to set the request charset to the same as\n-  * the response charset (this makes it possible for the container to\n-  * decode the form parameter values properly, since browsers typically\n-  * encode form field values using the response's charset).\n-  *\n-  * @param pageContext the page context whose response object is assigned\n-  * the given locale\n-  * @param locale the response locale\n-  */\n-  static void setResponseLocale(PageContext pc, Locale locale) {\n-    // set response locale\n-    ServletResponse response = pc.getResponse();\n-    response.setLocale(locale);\n-\n-    // get response character encoding and store it in session attribute\n-    if (pc.getSession() != null) {\n-      try {\n-        pc.setAttribute(REQUEST_CHAR_SET, response.getCharacterEncoding(),\n-          PageContext.SESSION_SCOPE);\n-      } \n-      catch (IllegalStateException ex) { \n-        // invalidated session ignored\n-      }\n-    }\n-  }\n-\n-  /*\n-  * Returns the formatting locale to use with the given formatting action\n-  * in the given page.\n-  *\n-  * @param pc The page context containing the formatting action\n-  * @param fromTag The formatting action\n-  * @param format <tt>true</tt> if the formatting action is of type\n-  * <formatXXX> (as opposed to <parseXXX>), and <tt>false</tt> otherwise\n-  * (if set to <tt>true</tt>, the formatting locale that is returned by\n-  * this method is used to set the response locale).\n-  *\n-  * @param avail the array of available locales\n-  *\n-  * @return the formatting locale to use\n-  */\n-  static Locale getFormattingLocale(PageContext pc, Tag fromTag, \n-    boolean format, Locale[] avail) {\n-\n-    LocalizationContext locCtxt = null;\n-\n-    /*\n-    // Get formatting locale from enclosing <fmt:bundle>\n-    Tag parent = findAncestorWithClass(fromTag, BundleSupport.class);\n-    if (parent != null) {\n-    /*\n-    * use locale from localization context established by parent\n-    * <fmt:bundle> action, unless that locale is null\n-    * /\n-    locCtxt = ((BundleSupport) parent).getLocalizationContext();\n-    if (locCtxt.getLocale() != null) {\n-    if (format) {\n-    setResponseLocale(pc, locCtxt.getLocale());\n-    }\n-    return locCtxt.getLocale();\n-    }\n-    }\n-    */\n-\n-    // Use locale from default I18N localization context, unless it is null\n-    if ((locCtxt = getLocalizationContext(pc)) != null) {\n-      if (locCtxt.getLocale() != null) {\n-        if (format) {\n-          setResponseLocale(pc, locCtxt.getLocale());\n-        }\n-        return locCtxt.getLocale();\n-      }\n-    }\n-\n-    /*\n-    * Establish formatting locale by comparing the preferred locales\n-    * (in order of preference) against the available formatting\n-    * locales, and determining the best matching locale.\n-    */\n-    Locale match = null;\n-    Locale pref = getLocale(pc, Config.FMT_LOCALE);\n-    if (pref != null) {\n-      // Preferred locale is application-based\n-      match = findFormattingMatch(pref, avail);\n-    } \n-    else {\n-      // Preferred locales are browser-based \n-      match = findFormattingMatch(pc, avail);\n-    }\n-    if (match == null) {\n-      //Use fallback locale.\n-      pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n-      if (pref != null) {\n-        match = findFormattingMatch(pref, avail);\n-      }\n-    }\n-    if (format && (match != null)) {\n-      setResponseLocale(pc, match);\n-    }\n-\n-    return match;\n-  }\n-\n-  /**\n-  * Setup the available formatting locales that will be used\n-  * by getFormattingLocale(PageContext).\n-  */\n-  static Locale[] availableFormattingLocales;\n-  static {\n-    Locale[] dateLocales = DateFormat.getAvailableLocales();\n-    Locale[] numberLocales = NumberFormat.getAvailableLocales();\n-    Vector vec = new Vector(dateLocales.length);\n-    for (int i=0; i<dateLocales.length; i++) {\n-      for (int j=0; j<numberLocales.length; j++) {\n-        if (dateLocales[i].equals(numberLocales[j])) {\n-          vec.add(dateLocales[i]);\n-          break;\n-        }\n-      }\n-    }\n-    availableFormattingLocales = new Locale[vec.size()];\n-    availableFormattingLocales = (Locale[])vec.toArray(availableFormattingLocales);\n-    /*\n-    for (int i=0; i<availableFormattingLocales.length; i++) {\n-    System.out.println(\"AvailableLocale[\" + i + \"] \" + availableFormattingLocales[i]);\n-    }\n-    */\n-  }\n-\n-  /*\n-  * Returns the formatting locale to use when <fmt:message> is used\n-  * with a locale-less localization context.\n-  *\n-  * @param pc The page context containing the formatting action\n-  * @return the formatting locale to use\n-  */\n-  static Locale getFormattingLocale(PageContext pc) {\n-    /*\n-    * Establish formatting locale by comparing the preferred locales\n-    * (in order of preference) against the available formatting\n-    * locales, and determining the best matching locale.\n-    */\n-    Locale match = null;\n-    Locale pref = getLocale(pc, Config.FMT_LOCALE);\n-    if (pref != null) {\n-      // Preferred locale is application-based\n-      match = findFormattingMatch(pref, availableFormattingLocales);\n-    }\n-    else {\n-      // Preferred locales are browser-based \n-      match = findFormattingMatch(pc, availableFormattingLocales);\n-    }\n-    if (match == null) {\n-      //Use fallback locale.\n-      pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n-      if (pref != null) {\n-        match = findFormattingMatch(pref, availableFormattingLocales);\n-      }\n-    }\n-    if (match != null) {\n-      setResponseLocale(pc, match);\n-    }\n-\n-    return match;\n-  }\n-\n-  /*\n-  * Returns the locale specified by the named scoped attribute or context\n-  * configuration parameter.\n-  *\n-  * <p> The named scoped attribute is searched in the page, request,\n-  * session (if valid), and application scope(s) (in this order). If no such\n-  * attribute exists in any of the scopes, the locale is taken from the\n-  * named context configuration parameter.\n-  *\n-  * @param pageContext the page in which to search for the named scoped\n-  * attribute or context configuration parameter\n-  * @param name the name of the scoped attribute or context configuration\n-  * parameter\n-  *\n-  * @return the locale specified by the named scoped attribute or context\n-  * configuration parameter, or <tt>null</tt> if no scoped attribute or\n-  * configuration parameter with the given name exists\n-  */\n-  static Locale getLocale(PageContext pageContext, String name) {\n-    Locale loc = null;\n-\n-    Object obj = Config.find(pageContext, name);\n-    if (obj != null) {\n-      if (obj instanceof Locale) {\n-        loc = (Locale) obj;\n-      }\n-      else {\n-        loc = parseLocale((String) obj);\n-      }\n-    }\n-\n-    return loc;\n-  }\n-\n-\n-  //*********************************************************************\n-  // Private utility methods\n-\n-  /*\n-  * Determines the client's preferred locales from the request, and compares\n-  * each of the locales (in order of preference) against the available\n-  * locales in order to determine the best matching locale.\n-  *\n-  * @param pageContext Page containing the formatting action\n-  * @param avail Available formatting locales\n-  *\n-  * @return Best matching locale, or <tt>null</tt> if no match was found\n-  */\n-  private static Locale findFormattingMatch(PageContext pageContext,\n-    Locale[] avail) {\n-    Locale match = null;\n-    for (Enumeration enum_ = \n-      Util.getRequestLocales((HttpServletRequest)pageContext.getRequest());\n-      enum_.hasMoreElements(); ) {\n-      Locale locale = (Locale)enum_.nextElement();\n-      match = findFormattingMatch(locale, avail);\n-      if (match != null) {\n-        break;\n-      }\n-    }\n-\n-    return match;\n-  }\n-\n-  /*\n-  * Returns the best match between the given preferred locale and the\n-  * given available locales.\n-  *\n-  * The best match is given as the first available locale that exactly\n-  * matches the given preferred locale (\"exact match\"). If no exact match\n-  * exists, the best match is given to an available locale that meets\n-  * the following criteria (in order of priority):\n-  *  - available locale's variant is empty and exact match for both\n-  *    language and country\n-  *  - available locale's variant and country are empty, and exact match \n-  *    for language.\n-  *\n-  * @param pref the preferred locale\n-  * @param avail the available formatting locales\n-  *\n-  * @return Available locale that best matches the given preferred locale,\n-  * or <tt>null</tt> if no match exists\n-  */\n-  private static Locale findFormattingMatch(Locale pref, Locale[] avail) {\n-    Locale match = null;\n-    boolean langAndCountryMatch = false;\n-    for (int i=0; i<avail.length; i++) {\n-      if (pref.equals(avail[i])) {\n-        // Exact match\n-        match = avail[i];\n-        break;\n-      } \n-      else if (!\"\".equals(pref.getVariant()) &&\n-        \"\".equals(avail[i].getVariant()) &&\n-        pref.getLanguage().equals(avail[i].getLanguage()) &&\n-        pref.getCountry().equals(avail[i].getCountry())) {\n-        // Language and country match; different variant\n-        match = avail[i];\n-        langAndCountryMatch = true;\n-      } \n-      else if (!langAndCountryMatch &&\n-        pref.getLanguage().equals(avail[i].getLanguage()) &&\n-        (\"\".equals(avail[i].getCountry()))) {\n-        // Language match\n+    private static final String REQUEST = \"request\";\n+\n+    private static final String SESSION = \"session\";\n+\n+    private static final String APPLICATION = \"application\";\n+\n+    private static final char HYPHEN = '-';\n+\n+    private static final char UNDERSCORE = '_';\n+\n+    private static final Locale EMPTY_LOCALE = new Locale(\"\", \"\");\n+\n+    static final String REQUEST_CHAR_SET = \"javax.servlet.jsp.jstl.fmt.request.charset\";\n+\n+    /**\n+     * Converts the given string description of a scope to the corresponding\n+     * PageContext constant.\n+     * \n+     * The validity of the given scope has already been checked by the\n+     * appropriate TLV.\n+     * \n+     * @param scope String description of scope\n+     * \n+     * @return PageContext constant corresponding to given scope description\n+     */\n+    public static int getScope(String scope) {\n+        int ret = PageContext.PAGE_SCOPE; // default\n+\n+        if (REQUEST.equalsIgnoreCase(scope)) {\n+            ret = PageContext.REQUEST_SCOPE;\n+        } else if (SESSION.equalsIgnoreCase(scope)) {\n+            ret = PageContext.SESSION_SCOPE;\n+        } else if (APPLICATION.equalsIgnoreCase(scope)) {\n+            ret = PageContext.APPLICATION_SCOPE;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * HttpServletRequest.getLocales() returns the server's default locale if\n+     * the request did not specify a preferred language. We do not want this\n+     * behavior, because it prevents us from using the fallback locale. We\n+     * therefore need to return an empty Enumeration if no preferred locale has\n+     * been specified. This way, the logic for the fallback locale will be able\n+     * to kick in.\n+     */\n+    public static Enumeration getRequestLocales(HttpServletRequest request) {\n+        Enumeration values = request.getHeaders(\"accept-language\");\n+        if (values.hasMoreElements()) {\n+            // At least one \"accept-language\". Simply return\n+            // the enumeration returned by request.getLocales().\n+            // System.out.println(\"At least one accept-language\");\n+            return request.getLocales();\n+        } else {\n+            // No header for \"accept-language\". Simply return\n+            // the empty enumeration.\n+            // System.out.println(\"No accept-language\");\n+            return values;\n+        }\n+    }\n+\n+    /**\n+     * See parseLocale(String, String) for details.\n+     */\n+    public static Locale parseLocale(String locale) {\n+        return parseLocale(locale, null);\n+    }\n+\n+    /**\n+     * Parses the given locale string into its language and (optionally) country\n+     * components, and returns the corresponding <tt>java.util.Locale</tt>\n+     * object.\n+     * \n+     * If the given locale string is null or empty, the runtime's default locale\n+     * is returned.\n+     * \n+     * @param locale the locale string to parse\n+     * @param variant the variant\n+     * \n+     * @return <tt>java.util.Locale</tt> object corresponding to the given\n+     * locale string, or the runtime's default locale if the locale string is\n+     * null or empty\n+     * \n+     * @throws IllegalArgumentException if the given locale does not have a\n+     * language component or has an empty country component\n+     */\n+    public static Locale parseLocale(String locale, String variant) {\n+        Locale ret = null;\n+        String language = locale;\n+        String country = null;\n+        int index = -1;\n+\n+        if (((index = locale.indexOf(HYPHEN)) > -1)\n+                || ((index = locale.indexOf(UNDERSCORE)) > -1)) {\n+            language = locale.substring(0, index);\n+            country = locale.substring(index + 1);\n+        }\n+\n+        if ((language == null) || (language.length() == 0)) {\n+            throw new IllegalArgumentException(Resources\n+                    .getMessage(\"LOCALE_NO_LANGUAGE\"));\n+        }\n+\n+        if (country == null) {\n+            if (variant != null) {\n+                ret = new Locale(language, \"\", variant);\n+            } else {\n+                ret = new Locale(language, \"\");\n+            }\n+        } else if (country.length() > 0) {\n+            if (variant != null) {\n+                ret = new Locale(language, country, variant);\n+            } else {\n+                ret = new Locale(language, country);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(Resources\n+                    .getMessage(\"LOCALE_EMPTY_COUNTRY\"));\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Stores the given locale in the response object of the given page context,\n+     * and stores the locale's associated charset in the\n+     * javax.servlet.jsp.jstl.fmt.request.charset session attribute, which may\n+     * be used by the <requestEncoding> action in a page invoked by a form\n+     * included in the response to set the request charset to the same as the\n+     * response charset (this makes it possible for the container to decode the\n+     * form parameter values properly, since browsers typically encode form\n+     * field values using the response's charset).\n+     * \n+     * @param pageContext the page context whose response object is assigned the\n+     * given locale\n+     * @param locale the response locale\n+     */\n+    static void setResponseLocale(PageContext pc, Locale locale) {\n+        // set response locale\n+        ServletResponse response = pc.getResponse();\n+        response.setLocale(locale);\n+\n+        // get response character encoding and store it in session attribute\n+        if (pc.getSession() != null) {\n+            try {\n+                pc.setAttribute(REQUEST_CHAR_SET, response\n+                        .getCharacterEncoding(), PageContext.SESSION_SCOPE);\n+            } catch (IllegalStateException ex) {\n+                // invalidated session ignored\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the formatting locale to use with the given formatting action in\n+     * the given page.\n+     * \n+     * @param pc The page context containing the formatting action @param\n+     * fromTag The formatting action @param format <tt>true</tt> if the\n+     * formatting action is of type <formatXXX> (as opposed to <parseXXX>), and\n+     * <tt>false</tt> otherwise (if set to <tt>true</tt>, the formatting\n+     * locale that is returned by this method is used to set the response\n+     * locale).\n+     * \n+     * @param avail the array of available locales\n+     * \n+     * @return the formatting locale to use\n+     */\n+    static Locale getFormattingLocale(PageContext pc, Tag fromTag,\n+            boolean format, Locale[] avail) {\n+\n+        LocalizationContext locCtxt = null;\n+\n+        /*\n+         * // Get formatting locale from enclosing <fmt:bundle> Tag parent =\n+         * findAncestorWithClass(fromTag, BundleSupport.class); if (parent !=\n+         * null) { /* use locale from localization context established by parent\n+         * <fmt:bundle> action, unless that locale is null / locCtxt =\n+         * ((BundleSupport) parent).getLocalizationContext(); if\n+         * (locCtxt.getLocale() != null) { if (format) { setResponseLocale(pc,\n+         * locCtxt.getLocale()); } return locCtxt.getLocale(); } }\n+         */\n+\n+        // Use locale from default I18N localization context, unless it is null\n+        if ((locCtxt = getLocalizationContext(pc)) != null) {\n+            if (locCtxt.getLocale() != null) {\n+                if (format) {\n+                    setResponseLocale(pc, locCtxt.getLocale());\n+                }\n+                return locCtxt.getLocale();\n+            }\n+        }\n+\n+        /*\n+         * Establish formatting locale by comparing the preferred locales (in\n+         * order of preference) against the available formatting locales, and\n+         * determining the best matching locale.\n+         */\n+        Locale match = null;\n+        Locale pref = getLocale(pc, Config.FMT_LOCALE);\n+        if (pref != null) {\n+            // Preferred locale is application-based\n+            match = findFormattingMatch(pref, avail);\n+        } else {\n+            // Preferred locales are browser-based\n+            match = findFormattingMatch(pc, avail);\n+        }\n         if (match == null) {\n-          match = avail[i];\n-        }\n-      }\n-    }\n-    return match;\n-  }\n-\n-  /**\n-  * Gets the default I18N localization context.\n-  *\n-  * @param pc Page in which to look up the default I18N localization context\n-  */    \n-  public static LocalizationContext getLocalizationContext(PageContext pc) {\n-    LocalizationContext locCtxt = null;\n-\n-    Object obj = Config.find(pc, Config.FMT_LOCALIZATION_CONTEXT);\n-    if (obj == null) {\n-      return null;\n-    }\n-\n-    if (obj instanceof LocalizationContext) {\n-      locCtxt = (LocalizationContext) obj;\n-    } \n-    else {\n-      // localization context is a bundle basename\n-      locCtxt = getLocalizationContext(pc, (String) obj);\n-    }\n-\n-    return locCtxt;\n-  }\n-\n-  /**\n-  * Gets the resource bundle with the given base name, whose locale is\n-  * determined as follows:\n-  *\n-  * Check if a match exists between the ordered set of preferred\n-  * locales and the available locales, for the given base name.\n-  * The set of preferred locales consists of a single locale\n-  * (if the <tt>javax.servlet.jsp.jstl.fmt.locale</tt> configuration\n-  * setting is present) or is equal to the client's preferred locales\n-  * determined from the client's browser settings.\n-  *\n-  * <p> If no match was found in the previous step, check if a match\n-  * exists between the fallback locale (given by the\n-  * <tt>javax.servlet.jsp.jstl.fmt.fallbackLocale</tt> configuration\n-  * setting) and the available locales, for the given base name.\n-  *\n-  * @param pageContext Page in which the resource bundle with the\n-  * given base name is requested\n-  * @param basename Resource bundle base name\n-  *\n-  * @return Localization context containing the resource bundle with the\n-  * given base name and the locale that led to the resource bundle match,\n-  * or the empty localization context if no resource bundle match was found\n-  */\n-  public static LocalizationContext getLocalizationContext(PageContext pc,\n-    String basename) {\n-    LocalizationContext locCtxt = null;\n-    ResourceBundle bundle = null;\n-\n-    if ((basename == null) || basename.equals(\"\")) {\n-      return new LocalizationContext();\n-    }\n-\n-    // Try preferred locales\n-    Locale pref = getLocale(pc, Config.FMT_LOCALE);\n-    if (pref != null) {\n-      // Preferred locale is application-based\n-      bundle = findMatch(basename, pref);\n-      if (bundle != null) {\n-        locCtxt = new LocalizationContext(bundle, pref);\n-      }\n-    }\n-    else {\n-      // Preferred locales are browser-based\n-      locCtxt = findMatch(pc, basename);\n-    }\n-\n-    if (locCtxt == null) {\n-      // No match found with preferred locales, try using fallback locale\n-      pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n-      if (pref != null) {\n-        bundle = findMatch(basename, pref);\n-        if (bundle != null) {\n-          locCtxt = new LocalizationContext(bundle, pref);\n-        }\n-      }\n-    }\n-\n-    if (locCtxt == null) {\n-      // try using the root resource bundle with the given basename\n-      try {\n-        bundle = ResourceBundle.getBundle(basename, EMPTY_LOCALE,\n-        Thread.currentThread().getContextClassLoader());\n-        if (bundle != null) {\n-          locCtxt = new LocalizationContext(bundle, null);\n-        }\n-      } \n-      catch (MissingResourceException mre) {\n-        // do nothing\n-      }\n-    }\n-\n-    if (locCtxt != null) {\n-      // set response locale\n-      if (locCtxt.getLocale() != null) {\n-        setResponseLocale(pc, locCtxt.getLocale());\n-      }\n-    } \n-    else {\n-      // create empty localization context\n-      locCtxt = new LocalizationContext();\n-    }\n-\n-    return locCtxt;\n-  }\n-\n-  /*\n-  * Determines the client's preferred locales from the request, and compares\n-  * each of the locales (in order of preference) against the available\n-  * locales in order to determine the best matching locale.\n-  *\n-  * @param pageContext the page in which the resource bundle with the\n-  * given base name is requested\n-  * @param basename the resource bundle's base name\n-  *\n-  * @return the localization context containing the resource bundle with\n-  * the given base name and best matching locale, or <tt>null</tt> if no\n-  * resource bundle match was found\n-  */\n-  private static LocalizationContext findMatch(PageContext pageContext,\n-    String basename) {\n-    LocalizationContext locCtxt = null;\n-\n-    // Determine locale from client's browser settings.\n-    for (Enumeration enum_ = \n-      Util.getRequestLocales((HttpServletRequest)pageContext.getRequest());\n-      enum_.hasMoreElements(); ) {\n-      Locale pref = (Locale) enum_.nextElement();\n-      ResourceBundle match = findMatch(basename, pref);\n-      if (match != null) {\n-        locCtxt = new LocalizationContext(match, pref);\n-        break;\n-      }\n-    }\n-\n-    return locCtxt;\n-  }\n-\n-  /*\n-  * Gets the resource bundle with the given base name and preferred locale.\n-  * \n-  * This method calls java.util.ResourceBundle.getBundle(), but ignores\n-  * its return value unless its locale represents an exact or language match\n-  * with the given preferred locale.\n-  *\n-  * @param basename the resource bundle base name\n-  * @param pref the preferred locale\n-  *\n-  * @return the requested resource bundle, or <tt>null</tt> if no resource\n-  * bundle with the given base name exists or if there is no exact- or\n-  * language-match between the preferred locale and the locale of\n-  * the bundle returned by java.util.ResourceBundle.getBundle().\n-  */\n-  private static ResourceBundle findMatch(String basename, Locale pref) {\n-    ResourceBundle match = null;\n-\n-    try {\n-      ResourceBundle bundle = ResourceBundle.getBundle(basename, pref,\n-       Thread.currentThread().getContextClassLoader());\n-      Locale avail = bundle.getLocale();\n-      if (pref.equals(avail)) {\n-        // Exact match\n-        match = bundle;\n-      } \n-      else {\n+            // Use fallback locale.\n+            pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n+            if (pref != null) {\n+                match = findFormattingMatch(pref, avail);\n+            }\n+        }\n+        if (format && (match != null)) {\n+            setResponseLocale(pc, match);\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Setup the available formatting locales that will be used by\n+     * getFormattingLocale(PageContext).\n+     */\n+    static Locale[] availableFormattingLocales;\n+    static {\n+        Locale[] dateLocales = DateFormat.getAvailableLocales();\n+        Locale[] numberLocales = NumberFormat.getAvailableLocales();\n+        Vector vec = new Vector(dateLocales.length);\n+        for (int i = 0; i < dateLocales.length; i++) {\n+            for (int j = 0; j < numberLocales.length; j++) {\n+                if (dateLocales[i].equals(numberLocales[j])) {\n+                    vec.add(dateLocales[i]);\n+                    break;\n+                }\n+            }\n+        }\n+        availableFormattingLocales = new Locale[vec.size()];\n+        availableFormattingLocales = (Locale[]) vec\n+                .toArray(availableFormattingLocales);\n         /*\n-        * We have to make sure that the match we got is for\n-        * the specified locale. The way ResourceBundle.getBundle()\n-        * works, if a match is not found with (1) the specified locale,\n-        * it tries to match with (2) the current default locale as \n-        * returned by Locale.getDefault() or (3) the root resource \n-        * bundle (basename).\n-        * We must ignore any match that could have worked with (2) or (3).\n-        * So if an exact match is not found, we make the following extra\n-        * tests:\n-        *     - avail locale must be equal to preferred locale\n-        *     - avail country must be empty or equal to preferred country\n-        *       (the equality match might have failed on the variant)\n-        */\n-        if (pref.getLanguage().equals(avail.getLanguage())\n-          && (\"\".equals(avail.getCountry()) || \n-          pref.getCountry().equals(avail.getCountry()))) {\n-          /*\n-          * Language match.\n-          * By making sure the available locale does not have a \n-          * country and matches the preferred locale's language, we\n-          * rule out \"matches\" based on the container's default\n-          * locale. For example, if the preferred locale is \n-          * \"en-US\", the container's default locale is \"en-UK\", and\n-          * there is a resource bundle (with the requested base\n-          * name) available for \"en-UK\", ResourceBundle.getBundle()\n-          * will return it, but even though its language matches\n-          * that of the preferred locale, we must ignore it,\n-          * because matches based on the container's default locale\n-          * are not portable across different containers with\n-          * different default locales.\n-          */\n-          match = bundle;\n-        }\n-      }\n-    }\n-    catch (MissingResourceException mre) {\n-    }\n-\n-    return match;\n-  }\n+         * for (int i=0; i<availableFormattingLocales.length; i++) {\n+         * System.out.println(\"AvailableLocale[\" + i + \"] \" +\n+         * availableFormattingLocales[i]); }\n+         */\n+    }\n+\n+    /**\n+     * Returns the formatting locale to use when <fmt:message> is used with a\n+     * locale-less localization context.\n+     * \n+     * @param pc The page context containing the formatting action @return the\n+     * formatting locale to use\n+     */\n+    static Locale getFormattingLocale(PageContext pc) {\n+        /*\n+         * Establish formatting locale by comparing the preferred locales (in\n+         * order of preference) against the available formatting locales, and\n+         * determining the best matching locale.\n+         */\n+        Locale match = null;\n+        Locale pref = getLocale(pc, Config.FMT_LOCALE);\n+        if (pref != null) {\n+            // Preferred locale is application-based\n+            match = findFormattingMatch(pref, availableFormattingLocales);\n+        } else {\n+            // Preferred locales are browser-based\n+            match = findFormattingMatch(pc, availableFormattingLocales);\n+        }\n+        if (match == null) {\n+            // Use fallback locale.\n+            pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n+            if (pref != null) {\n+                match = findFormattingMatch(pref, availableFormattingLocales);\n+            }\n+        }\n+        if (match != null) {\n+            setResponseLocale(pc, match);\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Returns the locale specified by the named scoped attribute or context\n+     * configuration parameter.\n+     * \n+     * <p> The named scoped attribute is searched in the page, request, session\n+     * (if valid), and application scope(s) (in this order). If no such\n+     * attribute exists in any of the scopes, the locale is taken from the named\n+     * context configuration parameter.\n+     * \n+     * @param pageContext the page in which to search for the named scoped\n+     * attribute or context configuration parameter @param name the name of the\n+     * scoped attribute or context configuration parameter\n+     * \n+     * @return the locale specified by the named scoped attribute or context\n+     * configuration parameter, or <tt>null</tt> if no scoped attribute or\n+     * configuration parameter with the given name exists\n+     */\n+    static Locale getLocale(PageContext pageContext, String name) {\n+        Locale loc = null;\n+\n+        Object obj = Config.find(pageContext, name);\n+        if (obj != null) {\n+            if (obj instanceof Locale) {\n+                loc = (Locale) obj;\n+            } else {\n+                loc = parseLocale((String) obj);\n+            }\n+        }\n+\n+        return loc;\n+    }\n+\n+    // *********************************************************************\n+    // Private utility methods\n+\n+    /**\n+     * Determines the client's preferred locales from the request, and compares\n+     * each of the locales (in order of preference) against the available\n+     * locales in order to determine the best matching locale.\n+     * \n+     * @param pageContext Page containing the formatting action @param avail\n+     * Available formatting locales\n+     * \n+     * @return Best matching locale, or <tt>null</tt> if no match was found\n+     */\n+    private static Locale findFormattingMatch(PageContext pageContext,\n+            Locale[] avail) {\n+        Locale match = null;\n+        for (Enumeration enum_ = Util\n+                .getRequestLocales((HttpServletRequest) pageContext\n+                        .getRequest()); enum_.hasMoreElements();) {\n+            Locale locale = (Locale) enum_.nextElement();\n+            match = findFormattingMatch(locale, avail);\n+            if (match != null) {\n+                break;\n+            }\n+        }\n+\n+        return match;\n+    }\n+\n+    /**\n+     * Returns the best match between the given preferred locale and the given\n+     * available locales.\n+     * \n+     * The best match is given as the first available locale that exactly\n+     * matches the given preferred locale (\"exact match\"). If no exact match\n+     * exists, the best match is given to an available locale that meets the\n+     * following criteria (in order of priority): - available locale's variant\n+     * is empty and exact match for both language and country - available\n+     * locale's variant and country are empty, and exact match for language.\n+     * \n+     * @param pref the preferred locale @param avail the available formatting\n+     * locales\n+     * \n+     * @return Available locale that best matches the given preferred locale, or\n+     * <tt>null</tt> if no match exists\n+     */\n+    private static Locale findFormattingMatch(Locale pref, Locale[] avail) {\n+        Locale match = null;\n+        boolean langAndCountryMatch = false;\n+        for (int i = 0; i < avail.length; i++) {\n+            if (pref.equals(avail[i])) {\n+                // Exact match\n+                match = avail[i];\n+                break;\n+            } else if (!\"\".equals(pref.getVariant())\n+                    && \"\".equals(avail[i].getVariant())\n+                    && pref.getLanguage().equals(avail[i].getLanguage())\n+                    && pref.getCountry().equals(avail[i].getCountry())) {\n+                // Language and country match; different variant\n+                match = avail[i];\n+                langAndCountryMatch = true;\n+            } else if (!langAndCountryMatch\n+                    && pref.getLanguage().equals(avail[i].getLanguage())\n+                    && (\"\".equals(avail[i].getCountry()))) {\n+                // Language match\n+                if (match == null) {\n+                    match = avail[i];\n+                }\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n+     * Gets the default I18N localization context.\n+     * \n+     * @param pc Page in which to look up the default I18N localization context\n+     */\n+    public static LocalizationContext getLocalizationContext(PageContext pc) {\n+        LocalizationContext locCtxt = null;\n+\n+        Object obj = Config.find(pc, Config.FMT_LOCALIZATION_CONTEXT);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        if (obj instanceof LocalizationContext) {\n+            locCtxt = (LocalizationContext) obj;\n+        } else {\n+            // localization context is a bundle basename\n+            locCtxt = getLocalizationContext(pc, (String) obj);\n+        }\n+\n+        return locCtxt;\n+    }\n+\n+    /**\n+     * Gets the resource bundle with the given base name, whose locale is\n+     * determined as follows:\n+     * \n+     * Check if a match exists between the ordered set of preferred locales and\n+     * the available locales, for the given base name. The set of preferred\n+     * locales consists of a single locale (if the\n+     * <tt>javax.servlet.jsp.jstl.fmt.locale</tt> configuration setting is\n+     * present) or is equal to the client's preferred locales determined from\n+     * the client's browser settings.\n+     * \n+     * <p>\n+     * If no match was found in the previous step, check if a match exists\n+     * between the fallback locale (given by the\n+     * <tt>javax.servlet.jsp.jstl.fmt.fallbackLocale</tt> configuration\n+     * setting) and the available locales, for the given base name.\n+     * \n+     * @param pageContext Page in which the resource bundle with the given base\n+     * name is requested\n+     * @param basename Resource bundle base name\n+     * \n+     * @return Localization context containing the resource bundle with the\n+     * given base name and the locale that led to the resource bundle match, or\n+     * the empty localization context if no resource bundle match was found\n+     */\n+    public static LocalizationContext getLocalizationContext(PageContext pc,\n+            String basename) {\n+        LocalizationContext locCtxt = null;\n+        ResourceBundle bundle = null;\n+\n+        if ((basename == null) || basename.equals(\"\")) {\n+            return new LocalizationContext();\n+        }\n+\n+        // Try preferred locales\n+        Locale pref = getLocale(pc, Config.FMT_LOCALE);\n+        if (pref != null) {\n+            // Preferred locale is application-based\n+            bundle = findMatch(basename, pref);\n+            if (bundle != null) {\n+                locCtxt = new LocalizationContext(bundle, pref);\n+            }\n+        } else {\n+            // Preferred locales are browser-based\n+            locCtxt = findMatch(pc, basename);\n+        }\n+\n+        if (locCtxt == null) {\n+            // No match found with preferred locales, try using fallback locale\n+            pref = getLocale(pc, Config.FMT_FALLBACK_LOCALE);\n+            if (pref != null) {\n+                bundle = findMatch(basename, pref);\n+                if (bundle != null) {\n+                    locCtxt = new LocalizationContext(bundle, pref);\n+                }\n+            }\n+        }\n+\n+        if (locCtxt == null) {\n+            // try using the root resource bundle with the given basename\n+            try {\n+                bundle = ResourceBundle.getBundle(basename, EMPTY_LOCALE,\n+                        Thread.currentThread().getContextClassLoader());\n+                if (bundle != null) {\n+                    locCtxt = new LocalizationContext(bundle, null);\n+                }\n+            } catch (MissingResourceException mre) {\n+                // do nothing\n+            }\n+        }\n+\n+        if (locCtxt != null) {\n+            // set response locale\n+            if (locCtxt.getLocale() != null) {\n+                setResponseLocale(pc, locCtxt.getLocale());\n+            }\n+        } else {\n+            // create empty localization context\n+            locCtxt = new LocalizationContext();\n+        }\n+\n+        return locCtxt;\n+    }\n+\n+    /**\n+     * Determines the client's preferred locales from the request, and compares\n+     * each of the locales (in order of preference) against the available\n+     * locales in order to determine the best matching locale.\n+     * \n+     * @param pageContext the page in which the resource bundle with the given\n+     * base name is requested @param basename the resource bundle's base name\n+     * \n+     * @return the localization context containing the resource bundle with the\n+     * given base name and best matching locale, or <tt>null</tt> if no\n+     * resource bundle match was found\n+     */\n+    private static LocalizationContext findMatch(PageContext pageContext,\n+            String basename) {\n+        LocalizationContext locCtxt = null;\n+\n+        // Determine locale from client's browser settings.\n+        for (Enumeration enum_ = Util\n+                .getRequestLocales((HttpServletRequest) pageContext\n+                        .getRequest()); enum_.hasMoreElements();) {\n+            Locale pref = (Locale) enum_.nextElement();\n+            ResourceBundle match = findMatch(basename, pref);\n+            if (match != null) {\n+                locCtxt = new LocalizationContext(match, pref);\n+                break;\n+            }\n+        }\n+\n+        return locCtxt;\n+    }\n+\n+    /**\n+     * Gets the resource bundle with the given base name and preferred locale.\n+     * \n+     * This method calls java.util.ResourceBundle.getBundle(), but ignores its\n+     * return value unless its locale represents an exact or language match with\n+     * the given preferred locale.\n+     * \n+     * @param basename the resource bundle base name @param pref the preferred\n+     * locale\n+     * \n+     * @return the requested resource bundle, or <tt>null</tt> if no resource\n+     * bundle with the given base name exists or if there is no exact- or\n+     * language-match between the preferred locale and the locale of the bundle\n+     * returned by java.util.ResourceBundle.getBundle().\n+     */\n+    private static ResourceBundle findMatch(String basename, Locale pref) {\n+        ResourceBundle match = null;\n+\n+        try {\n+            ResourceBundle bundle = ResourceBundle.getBundle(basename, pref,\n+                    Thread.currentThread().getContextClassLoader());\n+            Locale avail = bundle.getLocale();\n+            if (pref.equals(avail)) {\n+                // Exact match\n+                match = bundle;\n+            } else {\n+                /*\n+                 * We have to make sure that the match we got is for the\n+                 * specified locale. The way ResourceBundle.getBundle() works,\n+                 * if a match is not found with (1) the specified locale, it\n+                 * tries to match with (2) the current default locale as\n+                 * returned by Locale.getDefault() or (3) the root resource\n+                 * bundle (basename). We must ignore any match that could have\n+                 * worked with (2) or (3). So if an exact match is not found, we\n+                 * make the following extra tests: - avail locale must be equal\n+                 * to preferred locale - avail country must be empty or equal to\n+                 * preferred country (the equality match might have failed on\n+                 * the variant)\n+                 */\n+                if (pref.getLanguage().equals(avail.getLanguage())\n+                        && (\"\".equals(avail.getCountry()) || pref.getCountry()\n+                                .equals(avail.getCountry()))) {\n+                    /*\n+                     * Language match. By making sure the available locale does\n+                     * not have a country and matches the preferred locale's\n+                     * language, we rule out \"matches\" based on the container's\n+                     * default locale. For example, if the preferred locale is\n+                     * \"en-US\", the container's default locale is \"en-UK\", and\n+                     * there is a resource bundle (with the requested base name)\n+                     * available for \"en-UK\", ResourceBundle.getBundle() will\n+                     * return it, but even though its language matches that of\n+                     * the preferred locale, we must ignore it, because matches\n+                     * based on the container's default locale are not portable\n+                     * across different containers with different default\n+                     * locales.\n+                     */\n+                    match = bundle;\n+                }\n+            }\n+        } catch (MissingResourceException mre) {\n+        }\n+\n+        return match;\n+    }\n \n }", "timestamp": 1124316446, "metainfo": ""}