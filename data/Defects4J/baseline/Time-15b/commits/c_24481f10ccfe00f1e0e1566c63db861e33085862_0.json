{"sha": "24481f10ccfe00f1e0e1566c63db861e33085862", "log": "Use DateTimeFieldType in ReadablePartial   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n /**\n  * Defines an partial time that does not support every datetime field.\n  * <p>\n- * A <code>ReadablePartial</code> supports a set of fields which be be a\n- * subset of those on the chronology.\n- * A <code>ReadablePartial</code> cannot be compared to a <code>ReadableInstant</code>.\n+ * A <code>ReadablePartial</code> supports a subset of those fields on the chronology.\n+ * It cannot be compared to a <code>ReadableInstant</code>, as it does not fully\n+ * specify an instant in time. The time it does specify is a local time, and does\n+ * not include a time zone.\n  * <p>\n  * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>\n  * using one of the <code>resolve</code> methods. These work by providing a full base\n- * instant that can be used to 'fill in the gaps'.\n+ * instant that can be used to 'fill in the gaps' and specify a time zone.\n  *\n  * @author Stephen Colebourne\n  */\n      *\n      * @return the number of fields supported\n      */\n-    int getFieldSize();\n-\n-    /**\n-     * Gets the field at the specified index.\n+    int size();\n+\n+    /**\n+     * Gets the field type at the specified index.\n      *\n      * @param index  the index to retrieve\n      * @return the field at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n+    DateTimeFieldType getFieldType(int index);\n+\n+    /**\n+     * Gets the field at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n     DateTimeField getField(int index);\n-\n-    /**\n-     * Gets an array of the fields that this partial supports.\n-     * <p>\n-     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n-     *\n-     * @return the fields supported in an array that may be altered, largest to smallest\n-     */\n-    DateTimeField[] getFields();\n \n     /**\n      * Gets the value at the specified index.\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     int getValue(int index);\n-\n-    /**\n-     * Gets an array of the value of each of the fields that this partial supports.\n-     * <p>\n-     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n-     * Each value corresponds to the same array index as <code>getFields()</code>\n-     *\n-     * @return the current values of each field in an array that may be altered, largest to smallest\n-     */\n-    int[] getValues();\n \n     /**\n      * Gets the chronology of the partial which is never null.\n     Chronology getChronology();\n \n     /**\n-     * Get the value of one of the fields of a datetime.\n-     * <p>\n-     * The field specified must be one of those that is supported by the partial.\n-     *\n-     * @param field  a DateTimeField instance that is supported by this partial\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeFieldType instance that is supported by this partial\n      * @return the value of that field\n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n-    int get(DateTimeField field);\n-\n-    /**\n-     * Checks whether the field specified is supported by this partial.\n+    int get(DateTimeFieldType field);\n+\n+    /**\n+     * Checks whether the field type specified is supported by this partial.\n      *\n      * @param field  the field to check, may be null which returns false\n      * @return true if the field is supported\n      */\n-    boolean isSupported(DateTimeField field);\n+    boolean isSupported(DateTimeFieldType field);\n \n     /**\n      * Resolves this partial against another complete millisecond instant to\n      * on the supported fields, chronology and values.\n      * <p>\n      * Two instances of ReadablePartial are equal if they have the same\n-     * chronology, same fields in same order and same values.\n+     * chronology, same field types (in same order) and same values.\n      *\n      * @param partial  the object to compare to\n      * @return true if equal\n      *  int total = 157;\n      *  for (int i = 0; i < fields.length; i++) {\n      *      total = 23 * total + values[i];\n-     *      total = 23 * total + fields[i].hashCode();\n+     *      total = 23 * total + fieldTypes[i].hashCode();\n      *  }\n      *  total += chronology.hashCode();\n      *  return total;\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3633353405803318660L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.hourOfDay(),\n+        DateTimeFieldType.minuteOfHour(),\n+        DateTimeFieldType.secondOfMinute(),\n+        DateTimeFieldType.millisOfSecond(),\n+    };\n \n     /** The index of the hourOfDay field in the field array */\n     public static final int HOUR_OF_DAY = 0;\n      * \n      * @return the field count\n      */\n-    public int getFieldSize() {\n+    public int size() {\n         return 4;\n     }\n \n         }\n     }\n \n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the hour of day (0-23) field value.\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n \n     /** Serialization version */\n     private static final long serialVersionUID = 797544782896179L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.year(),\n+        DateTimeFieldType.monthOfYear(),\n+        DateTimeFieldType.dayOfMonth(),\n+    };\n \n     /** The index of the year field in the field array */\n     public static final int YEAR = 0;\n      * \n      * @return the field count\n      */\n-    public int getFieldSize() {\n+    public int size() {\n         return 3;\n     }\n \n         }\n     }\n \n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Year, Month, Day\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the year field value.\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadWritableInstant;\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the field type at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field type\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return getField(index, getChronology()).getType();\n+    }\n+\n+    /**\n+     * Gets an array of the field types that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        DateTimeFieldType[] result = new DateTimeFieldType[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getFieldType(i);\n+        }\n+        return result;\n+    }\n+\n+    /**\n      * Gets the field at the specifed index.\n      * \n      * @param index  the index\n      * @return the fields supported in an array that may be altered, largest to smallest\n      */\n     public DateTimeField[] getFields() {\n-        DateTimeField[] result = new DateTimeField[getFieldSize()];\n+        DateTimeField[] result = new DateTimeField[size()];\n         for (int i = 0; i < result.length; i++) {\n             result[i] = getField(i);\n         }\n      * @return the current values of each field in an array that may be altered, largest to smallest\n      */\n     public int[] getValues() {\n-        int[] result = new int[getFieldSize()];\n+        int[] result = new int[size()];\n         for (int i = 0; i < result.length; i++) {\n             result[i] = getValue(i);\n         }\n      * <p>\n      * The field specified must be one of those that is supported by the partial.\n      *\n-     * @param field  a DateTimeField instance that is supported by this partial\n+     * @param type  a DateTimeFieldType instance that is supported by this partial\n      * @return the value of that field\n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n-    public int get(DateTimeField field) {\n-        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n-            if (getField(i) == field) {\n+    public int get(DateTimeFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) == type) {\n                 return getValue(i);\n             }\n         }\n-        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n+        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n     }\n \n     /**\n      * Checks whether the field specified is supported by this partial.\n      *\n-     * @param field  the field to check, may be null which returns false\n+     * @param type  the type to check, may be null which returns false\n      * @return true if the field is supported\n      */\n-    public boolean isSupported(DateTimeField field) {\n-        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n-            if (getField(i) == field) {\n+    public boolean isSupported(DateTimeFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) == type) {\n                 return true;\n             }\n         }\n      */\n     protected long resolve(long baseInstant, Chronology chrono) {\n         long millis = baseInstant;\n-        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n             millis = getField(i, chrono).set(millis, getValue(i));\n         }\n         return millis;\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this ReadablePartial with another returning true if the chronology,\n-     * fields and values are equal.\n+     * field types and values are equal.\n      *\n      * @param partial  an object to check against\n      * @return true if fields and values are equal\n             return false;\n         }\n         ReadablePartial other = (ReadablePartial) partial;\n-        if (getFieldSize() != other.getFieldSize()) {\n+        if (size() != other.size()) {\n             return false;\n         }\n-        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n-            if (getValue(i) != other.getValue(i) || getField(i) != other.getField(i)) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n                 return false;\n             }\n         }\n      */\n     public int hashCode() {\n         int total = 157;\n-        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n             total = 23 * total + getValue(i);\n-            total = 23 * total + getField(i).hashCode();\n+            total = 23 * total + getFieldType(i).hashCode();\n         }\n         total += getChronology().hashCode();\n         return total;\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n      * @param chrono  the chronology to use\n      */\n     protected int[] initValues(long instant, Chronology chrono) {\n-        int[] values = new int[getFieldSize()];\n+        int[] values = new int[size()];\n         for (int i = 0; i < values.length; i++) {\n             values[i] = getField(i, chrono).get(instant);\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n      * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}\n      * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.\n      *\n-     * @param instant  the partial instant to validate\n+     * @param partial  the partial instant to validate\n      * @param values  the values to validate, not null\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    public void validate(ReadablePartial instant, int[] values) {\n-        DateTimeField[] fields = instant.getFields();\n+    public void validate(ReadablePartial partial, int[] values) {\n         // check values in standard range, catching really stupid cases like -1\n         // this means that the second check will not hit trouble\n-        for (int i = 0; i < fields.length; i++) {\n-            if (values[i] < fields[i].getMinimumValue()) {\n-                throw new IllegalArgumentException(\"Value \" + values[i] +\n-                        \" for \" + fields[i].getName() + \" is less than minimum\");\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            int value = values[i];\n+            DateTimeField field = partial.getField(i);\n+            if (value < field.getMinimumValue()) {\n+                throw new IllegalArgumentException(\"Value \" + value +\n+                        \" for \" + field.getName() + \" is less than minimum\");\n             }\n-            if (values[i] > fields[i].getMaximumValue()) {\n-                throw new IllegalArgumentException(\"Value \" + values[i] +\n-                        \" for \" + fields[i].getName() + \" is greater than maximum\");\n+            if (value > field.getMaximumValue()) {\n+                throw new IllegalArgumentException(\"Value \" + value +\n+                        \" for \" + field.getName() + \" is greater than maximum\");\n             }\n         }\n-        // check values in specific range, catching really cases like 30th Feb\n-        for (int i = 0; i < fields.length; i++) {\n-            if (values[i] < fields[i].getMinimumValue(instant, values)) {\n-                throw new IllegalArgumentException(\"Value \" + values[i] +\n-                        \" for \" + fields[i].getName() + \" is less than minimum\");\n+        // check values in specific range, catching really odd cases like 30th Feb\n+        for (int i = 0; i < size; i++) {\n+            int value = values[i];\n+            DateTimeField field = partial.getField(i);\n+            if (value < field.getMinimumValue(partial, values)) {\n+                throw new IllegalArgumentException(\"Value \" + value +\n+                        \" for \" + field.getName() + \" is less than minimum\");\n             }\n-            if (values[i] > fields[i].getMaximumValue(instant, values)) {\n-                throw new IllegalArgumentException(\"Value \" + values[i] +\n-                        \" for \" + fields[i].getName() + \" is greater than maximum\");\n+            if (value > field.getMaximumValue(partial, values)) {\n+                throw new IllegalArgumentException(\"Value \" + value +\n+                        \" for \" + field.getName() + \" is greater than maximum\");\n             }\n         }\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n  */\n package org.joda.time.chrono;\n \n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n \t\treturn iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;\n     }\n \n-    public int getMaximumValue(ReadablePartial instant) {\n-        if (instant.isSupported(iChronology.monthOfYear())) {\n-            int month = instant.get(iChronology.monthOfYear());\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.monthOfYear())) {\n+            // find month\n+            int month = partial.get(DateTimeFieldType.monthOfYear());\n             if (month <= 12) {\n                 return 30;\n             }\n-            if (instant.isSupported(iChronology.year())) {\n-                int year = instant.get(iChronology.year());\n+            // 13th month, so check year\n+            if (partial.isSupported(DateTimeFieldType.year())) {\n+                int year = partial.get(DateTimeFieldType.year());\n                 return iChronology.isLeapYear(year) ? 6 : 5;\n             }\n             return 6;\n         return 30;\n     }\n \n-    public int getMaximumValue(ReadablePartial instant, int[] values) {\n-        DateTimeField[] fields = instant.getFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            if (fields[i] == iChronology.monthOfYear()) {\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            // find month\n+            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\n                 int month = values[i];\n                 if (month <= 12) {\n                     return 30;\n                 }\n-                for (int j = 0; j < fields.length; j++) {\n-                    if (fields[j] == iChronology.year()) {\n+                // 13th month, so check year\n+                for (int j = 0; j < size; j++) {\n+                    if (partial.getFieldType(j) == DateTimeFieldType.year()) {\n                         int year = values[j];\n                         return iChronology.isLeapYear(year) ? 6 : 5;\n                     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n  */\n package org.joda.time.chrono;\n \n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n         return iChronology.getDaysInYearMonth(thisYear, thisMonth);\n     }\n \n-    public int getMaximumValue(ReadablePartial instant) {\n-        if (instant.isSupported(iChronology.monthOfYear())) {\n-            int month = instant.get(iChronology.monthOfYear());\n-            if (instant.isSupported(iChronology.year())) {\n-                int year = instant.get(iChronology.year());\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.monthOfYear())) {\n+            int month = partial.get(DateTimeFieldType.monthOfYear());\n+            if (partial.isSupported(DateTimeFieldType.year())) {\n+                int year = partial.get(DateTimeFieldType.year());\n                 return iChronology.getDaysInYearMonth(year, month);\n             }\n             return iChronology.getDaysInMonthMax(month);\n         return 31;\n     }\n \n-    public int getMaximumValue(ReadablePartial instant, int[] values) {\n-        DateTimeField[] fields = instant.getFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            if (fields[i] == iChronology.monthOfYear()) {\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\n                 int month = values[i];\n-                for (int j = 0; j < fields.length; j++) {\n-                    if (fields[j] == iChronology.year()) {\n+                for (int j = 0; j < size; j++) {\n+                    if (partial.getFieldType(j) == DateTimeFieldType.year()) {\n                         int year = values[j];\n                         return iChronology.getDaysInYearMonth(year, month);\n                     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n  */\n package org.joda.time.chrono;\n \n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n         return iChronology.getDaysInYear(year);\n     }\n \n-    public int getMaximumValue(ReadablePartial instant) {\n-        if (instant.isSupported(iChronology.year())) {\n-            int year = instant.get(iChronology.year());\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.year())) {\n+            int year = partial.get(DateTimeFieldType.year());\n             return iChronology.getDaysInYear(year);\n         }\n         return 366;\n     }\n \n-    public int getMaximumValue(ReadablePartial instant, int[] values) {\n-        DateTimeField[] fields = instant.getFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            if (fields[i] == iChronology.year()) {\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.year()) {\n                 int year = values[i];\n                 return iChronology.getDaysInYear(year);\n             }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n         return iChronology.getWeeksInYear(weekyear);\n     }\n \n-    public int getMaximumValue(ReadablePartial instant) {\n-        if (instant.isSupported(iChronology.weekyear())) {\n-            int weekyear = instant.get(iChronology.weekyear());\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.weekyear())) {\n+            int weekyear = partial.get(DateTimeFieldType.weekyear());\n             return iChronology.getWeeksInYear(weekyear);\n         }\n         return 53;\n     }\n \n-    public int getMaximumValue(ReadablePartial instant, int[] values) {\n-        DateTimeField[] fields = instant.getFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            if (fields[i] == iChronology.weekyear()) {\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) {\n                 int weekyear = values[i];\n                 return iChronology.getWeeksInYear(weekyear);\n             }\n--- a/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n \n import java.util.Locale;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DurationField;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n     public abstract DateTimeField getField();\n \n     /**\n+     * Gets the field type being used.\n+     * \n+     * @return the field type\n+     */\n+    public DateTimeFieldType getFieldType() {\n+        return getField().getType();\n+    }\n+\n+    /**\n      * Gets the name of the field.\n      * \n      * @return the field name\n     /**\n      * Compare this field to the same field on another instant.\n      * <p>\n-     * The {@link #get()} method is used to obtain the value to compare for\n-     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n-     * is used for the specified instant.\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other instant will be queried\n+     * whether in the same chronology or not.\n      * \n      * @param instant  the instant to compare to\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n-     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the instant is null or the instant\n+     *  doesn't support the field of this property\n      */\n     public int compareTo(ReadableInstant instant) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n         int thisValue = get();\n-        int otherValue = instant.get(getField());\n+        Chronology chrono = DateTimeUtils.getChronology(instant.getChronology());\n+        int otherValue = chrono.getField(getFieldType()).get(instant.getMillis());\n         if (thisValue < otherValue) {\n             return -1;\n         } else if (thisValue > otherValue) {\n     /**\n      * Compare this field to the same field on another partial instant.\n      * <p>\n-     * The {@link #get()} method is used to obtain the value to compare for\n-     * this instant and the {@link ReadablePartial#get(DateTimeField)} method\n-     * is used for the specified instant.\n-     * \n-     * @param instant  the instant to compare to\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param partial  the partial to compare to\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if the field of this property cannot be queried\n      *  on the specified instant\n      */\n-    public int compareTo(ReadablePartial instant) {\n-        if (instant == null) {\n+    public int compareTo(ReadablePartial partial) {\n+        if (partial == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n         int thisValue = get();\n-        int otherValue = instant.get(getField());\n+        int otherValue = partial.get(getFieldType());\n         if (thisValue < otherValue) {\n             return -1;\n         } else if (thisValue > otherValue) {\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n      * @return the text value of the field\n      */\n     public final String getAsText(ReadablePartial partial, Locale locale) {\n-        return getAsText(partial, partial.get(this), locale);\n+        return getAsText(partial, partial.get(getType()), locale);\n     }\n \n     /**\n      * @return the text value of the field\n      */\n     public final String getAsShortText(ReadablePartial partial, Locale locale) {\n-        return getAsShortText(partial, partial.get(this), locale);\n+        return getAsShortText(partial, partial.get(getType()), locale);\n     }\n \n     /**\n      * the month is set to February, the day would be invalid. Instead, the day\n      * would be changed to the closest value - the 28th/29th February as appropriate.\n      * \n-     * @param instant  the partial instant\n+     * @param partial  the partial instant\n      * @param fieldIndex  the index of this field in the instant\n      * @param values  the values to update\n      * @param newValue  the value to set, in the units of the field\n      * @return the updated values\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n-        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n+    public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) {\n+        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values));\n         values[fieldIndex] = newValue;\n         \n         // may need to adjust smaller fields\n-        if (fieldIndex < instant.getFieldSize()) {\n-            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {\n-                DateTimeField field = instant.getField(i);\n-                if (values[i] > field.getMaximumValue(instant, values)) {\n-                    values[i] = field.getMaximumValue(instant, values);\n+        if (fieldIndex < partial.size()) {\n+            for (int i = fieldIndex + 1; i < partial.size(); i++) {\n+                DateTimeField field = partial.getField(i);\n+                if (values[i] > field.getMaximumValue(partial, values)) {\n+                    values[i] = field.getMaximumValue(partial, values);\n                 }\n-                if (values[i] < field.getMinimumValue(instant, values)) {\n-                    values[i] = field.getMinimumValue(instant, values);\n+                if (values[i] < field.getMinimumValue(partial, values)) {\n+                    values[i] = field.getMinimumValue(partial, values);\n                 }\n             }\n         }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 try {\n-                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iField));\n+                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iField.getType()));\n                 } catch (RuntimeException e) {\n                     buf.append('\\ufffd');\n                 }\n         }\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 try {\n-                    FormatUtils.writeUnpaddedInteger(out, partial.get(iField));\n+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iField.getType()));\n                 } catch (RuntimeException e) {\n                     out.write('\\ufffd');\n                 }\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 try {\n-                    FormatUtils.appendPaddedInteger(buf, partial.get(iField), iMinPrintedDigits);\n+                    FormatUtils.appendPaddedInteger(buf, partial.get(iField.getType()), iMinPrintedDigits);\n                 } catch (RuntimeException e) {\n                     appendUnknownString(buf, iMinPrintedDigits);\n                 }\n         }\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 try {\n-                    FormatUtils.writePaddedInteger(out, partial.get(iField), iMinPrintedDigits);\n+                    FormatUtils.writePaddedInteger(out, partial.get(iField.getType()), iMinPrintedDigits);\n                 } catch (RuntimeException e) {\n                     printUnknownString(out, iMinPrintedDigits);\n                 }\n         }\n \n         private int getTwoDigitYear(ReadablePartial partial) {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 try {\n-                    int year = partial.get(iField);\n+                    int year = partial.get(iField.getType());\n                     if (year < 0) {\n                         year = -year;\n                     }\n         }\n \n         public final String print(ReadablePartial partial) {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 if (iShort) {\n                     return iField.getAsShortText(partial, iLocale);\n                 } else {\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 long millis = partial.resolve(0L, DateTimeZone.UTC);\n                 try {\n                     printTo(buf, null, millis);\n         }\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            if (partial.isSupported(iField)) {\n+            if (partial.isSupported(iField.getType())) {\n                 long millis = partial.resolve(0L, DateTimeZone.UTC);\n                 printTo(null, out, millis);\n             } else {\n--- a/JodaTime/src/test/org/joda/time/MockPartial.java\n+++ b/JodaTime/src/test/org/joda/time/MockPartial.java\n     public Chronology getChronology() {\n         return ISOChronology.getInstance();\n     }\n-    public int getFieldSize() {\n+    public int size() {\n         return getFields().length;\n+    }\n+    public DateTimeFieldType getFieldType(int index) {\n+        return getFields()[index].getType();\n     }\n     public DateTimeField getField(int index) {\n         return getFields()[index];\n     public int getValue(int index) {\n         return getValues()[index];\n     }\n-    public int get(DateTimeField field) {\n+    public int get(DateTimeFieldType field) {\n         return 0;\n     }\n-    public boolean isSupported(DateTimeField field) {\n+    public boolean isSupported(DateTimeFieldType field) {\n         return false;\n     }\n     public long resolve(long baseMillis, DateTimeZone tz) {\n--- a/JodaTime/src/test/org/joda/time/TestAbstractPartial.java\n+++ b/JodaTime/src/test/org/joda/time/TestAbstractPartial.java\n             }\n         }\n \n-        public int getFieldSize() {\n+        public int size() {\n             return 2;\n         }\n         \n--- a/JodaTime/src/test/org/joda/time/TestAllPackages.java\n+++ b/JodaTime/src/test/org/joda/time/TestAllPackages.java\n         suite.addTest(org.joda.time.chrono.TestAll.suite());\n         suite.addTest(org.joda.time.chrono.gj.TestAll.suite());\n         suite.addTest(org.joda.time.convert.TestAll.suite());\n+        suite.addTest(org.joda.time.format.TestAll.suite());\n         suite.addTest(org.joda.time.tz.TestAll.suite());\n         return suite;\n     }\n--- a/JodaTime/src/test/org/joda/time/TestBasePartial.java\n+++ b/JodaTime/src/test/org/joda/time/TestBasePartial.java\n             }\n         }\n \n-        public int getFieldSize() {\n+        public int size() {\n             return 2;\n         }\n         \n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay.java\n     //-----------------------------------------------------------------------\n     public void testGet() {\n         TimeOfDay test = new TimeOfDay();\n-        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));\n-        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));\n-        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));\n-        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));\n         try {\n             test.get(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         try {\n-            test.get(ISOChronology.getInstance().dayOfMonth());\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            test.get(ISOChronology.getInstance(PARIS).hourOfDay());\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n-//        try {\n-//            test.get(JulianChronology.getInstance().hourOfDay());\n-//            fail();\n-//        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testGetFieldSize() {\n+            test.get(DateTimeFieldType.dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n         TimeOfDay test = new TimeOfDay();\n-        assertEquals(4, test.getFieldSize());\n+        assertEquals(4, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));\n+        assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2));\n+        assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(5);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        TimeOfDay test = new TimeOfDay();\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);\n+        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);\n+        assertSame(DateTimeFieldType.secondOfMinute(), fields[2]);\n+        assertSame(DateTimeFieldType.millisOfSecond(), fields[3]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n     }\n \n     public void testGetField() {\n \n     public void testIsSupported() {\n         TimeOfDay test = new TimeOfDay();\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));\n-        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n-        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));\n     }\n \n     public void testEqualsHashCode() {\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay.java\n     //-----------------------------------------------------------------------\n     public void testGet() {\n         YearMonthDay test = new YearMonthDay();\n-        assertEquals(1970, test.get(ISOChronology.getInstance().year()));\n-        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n-        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(1970, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n         try {\n             test.get(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         try {\n-            test.get(ISOChronology.getInstance().hourOfDay());\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            test.get(ISOChronology.getInstance(PARIS).year());\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n-//        try {\n-//            test.get(GregorianChronology.getInstance().year());\n-//            fail();\n-//        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testGetFieldSize() {\n+            test.get(DateTimeFieldType.hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n         YearMonthDay test = new YearMonthDay();\n-        assertEquals(3, test.getFieldSize());\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertSame(DateTimeFieldType.year(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));\n+        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        YearMonthDay test = new YearMonthDay();\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertSame(DateTimeFieldType.year(), fields[0]);\n+        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);\n+        assertSame(DateTimeFieldType.dayOfMonth(), fields[2]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n     }\n \n     public void testGetField() {\n \n     public void testIsSupported() {\n         YearMonthDay test = new YearMonthDay();\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().year()));\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().monthOfYear()));\n-        assertEquals(true, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n-        assertEquals(false, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n-        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));\n     }\n \n     public void testEqualsHashCode() {", "timestamp": 1094173987, "metainfo": ""}