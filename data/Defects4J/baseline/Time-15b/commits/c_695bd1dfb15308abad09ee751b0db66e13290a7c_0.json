{"sha": "695bd1dfb15308abad09ee751b0db66e13290a7c", "log": "Format classes to correct coding standards  ", "commit": "\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/AbstractStringBasedJodaType.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/AbstractStringBasedJodaType.java\n  * @author gjoseph\n  */\n public abstract class AbstractStringBasedJodaType implements UserType, Serializable {\n-    private static final int[] SQL_TYPES = new int[]{Types.VARCHAR};\n+\n+    private static final int[] SQL_TYPES = new int[] { Types.VARCHAR };\n \n     public int[] sqlTypes() {\n         return SQL_TYPES;\n         if (x == null || y == null) {\n             return false;\n         }\n-        // why do this !? .. TODO : maybe we need to check types ?\n-        // Period px = (Period) x;\n-        // Period py = (Period) y;\n-\n         return x.equals(y);\n     }\n \n     public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java\n \n /**\n  * Persist {@link org.joda.time.DateTime} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentDateTime implements EnhancedUserType, Serializable\n-{\n+public class PersistentDateTime implements EnhancedUserType, Serializable {\n+\n     public final static PersistentDateTime INSTANCE = new PersistentDateTime();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIMESTAMP,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.TIMESTAMP, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return DateTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         DateTime dtx = (DateTime) x;\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n \n         return new DateTime(timestamp);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((DateTime) value).toDate(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new DateTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new DateTime(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n import org.joda.time.DateTimeZone;\n \n /**\n- * Persist {@link org.joda.time.DateTime} via hibernate.\n- * The timezone will be stored in an extra column.\n- *\n+ * Persist {@link org.joda.time.DateTime} via hibernate. The timezone will be\n+ * stored in an extra column.\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentDateTimeTZ implements UserType, Serializable\n-{\n+public class PersistentDateTimeTZ implements UserType, Serializable {\n+\n     public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIMESTAMP,\n-        Types.VARCHAR,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.TIMESTAMP, Types.VARCHAR, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return DateTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         DateTime dtx = (DateTime) x;\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, strings[0]);\n         Object timezone = Hibernate.STRING.nullSafeGet(resultSet, strings[1]);\n-        if (timestamp == null || timezone == null)\n-        {\n+        if (timestamp == null || timezone == null) {\n             return null;\n         }\n \n         return new DateTime(timestamp, DateTimeZone.forID(timezone.toString()));\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-            Hibernate.STRING.nullSafeSet(preparedStatement, null, index+1);\n-        }\n-        else\n-        {\n+            Hibernate.STRING.nullSafeSet(preparedStatement, null, index + 1);\n+        } else {\n             DateTime dt = (DateTime) value;\n \n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, dt.toDate(), index);\n-            Hibernate.STRING.nullSafeSet(preparedStatement, dt.getZone().getID(), index+1);\n+            Hibernate.STRING.nullSafeSet(preparedStatement, dt.getZone().getID(), index + 1);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new DateTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDuration.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDuration.java\n /**\n  * Converts a org.joda.time.Duration to and from Sql for Hibernate.\n  * It simply stores the value as a varchar using Duration.toString.\n- *\n+ * \n  * @author gjoseph\n  */\n public class PersistentDuration extends AbstractStringBasedJodaType {\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstant.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstant.java\n \n /**\n  * Persist {@link org.joda.time.Instant} via hibernate as a TIMESTAMP.\n- *\n+ * \n  * @author Olav Reinert (oreinert@sourceforge.net)\n  */\n-public class PersistentInstant implements EnhancedUserType\n-{\n+public class PersistentInstant implements EnhancedUserType {\n+\n     public final static PersistentInstant INSTANCE = new PersistentInstant();\n \n-    private static final int[] SQL_TYPES = new int[] {Types.TIMESTAMP};\n+    private static final int[] SQL_TYPES = new int[] { Types.TIMESTAMP };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return Instant.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         Instant ix = (Instant) x;\n         Instant iy = (Instant) y;\n-\n         return ix.equals(iy);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, names[0]);\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String name) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String name) throws SQLException {\n         Object value = Hibernate.TIMESTAMP.nullSafeGet(resultSet, name);\n-        if (value == null)\n-        {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new Instant(value);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((Instant) value).toDate(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new Instant(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable serializable, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable serializable, Object value) throws HibernateException {\n         return serializable;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n     // __________ EnhancedUserType ____________________\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new Instant(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstantAsBigInt.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstantAsBigInt.java\n \n /**\n  * Persist {@link org.joda.time.Instant} via hibernate as a BIGINT.\n- *\n+ * \n  * @author Martin Grove (marting@optrak.co.uk))\n  */\n-public class PersistentInstantAsBigInt implements EnhancedUserType, Serializable\n-{\n+public class PersistentInstantAsBigInt implements EnhancedUserType, Serializable {\n+\n     public final static PersistentInstantAsBigInt INSTANCE = new PersistentInstantAsBigInt();\n \n-    private static final int[] SQL_TYPES = new int[] {Types.BIGINT};\n+    private static final int[] SQL_TYPES = new int[] { Types.BIGINT };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return Instant.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         Instant ix = (Instant) x;\n         Instant iy = (Instant) y;\n-\n         return ix.equals(iy);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, names[0]);\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String name) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String name) throws HibernateException, SQLException {\n         Object value = Hibernate.LONG.nullSafeGet(resultSet, name);\n-        if (value == null)\n-        {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new Instant(value);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.LONG.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n-            Hibernate.LONG.nullSafeSet(preparedStatement, new Long(((Instant)value).getMillis()), index);\n+        } else {\n+            Hibernate.LONG.nullSafeSet(preparedStatement, new Long(((Instant) value).getMillis()), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new Instant(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n-        return (Serializable)value;\n+    public Serializable disassemble(Object value) throws HibernateException {\n+        return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable serializable, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable serializable, Object value) throws HibernateException {\n         return serializable;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n     // __________ EnhancedUserType ____________________\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new Instant(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInterval.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInterval.java\n /**\n  * Persist {@link org.joda.time.Interval} via hibernate. Internally, this class\n  * collaborates with {@link org.joda.time.contrib.hibernate.PersistentDateTime}\n- * to convert the start and end components of an Interval to and from the \n- * database correspondents.  This class allows clients to execute hibernate or\n- * JPA queries using the attribute names \"start\" and \"end.\"  For example,\n- * <br />\n+ * to convert the start and end components of an Interval to and from the\n+ * database correspondents. This class allows clients to execute hibernate or\n+ * JPA queries using the attribute names \"start\" and \"end.\" For example,\n  * <br />\n  * <blockquote>\n  * \"from Foo where :date is between barInterval.start and barInterval.end\"\n  * </blockquote>\n- *\n+ * \n  * @author Christopher R. Gardner (chris_gardner76@yahoo.com)\n  */\n-public class PersistentInterval implements CompositeUserType, Serializable\n-{\n-    private static final String[] PROPERTY_NAMES = new String[]\n-    {\n-        \"start\",\n-        \"end\"\n-    };\n-    \n-    private static final Type[] TYPES = new Type[]\n-    { \n-        Hibernate.TIMESTAMP,\n-        Hibernate.TIMESTAMP\n-    };\n+public class PersistentInterval implements CompositeUserType, Serializable {\n \n-    public Object assemble(Serializable cached, SessionImplementor session,\n-            Object owner) throws HibernateException\n-    {\n+    private static final String[] PROPERTY_NAMES = new String[] { \"start\", \"end\" };\n+\n+    private static final Type[] TYPES = new Type[] { Hibernate.TIMESTAMP, Hibernate.TIMESTAMP };\n+\n+    public Object assemble(Serializable cached, SessionImplementor session, Object owner) throws HibernateException {\n         return cached;\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n+    public Object deepCopy(Object value) throws HibernateException {\n         return value;\n     }\n \n-    public Serializable disassemble(Object value, SessionImplementor session)\n-            throws HibernateException\n-    {\n+    public Serializable disassemble(Object value, SessionImplementor session) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y) { return true; }\n-        if (x == null || y == null) { return false; }\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n+            return true;\n+        }\n+        if (x == null || y == null) {\n+            return false;\n+        }\n         return x.equals(y);\n     }\n \n-    public String[] getPropertyNames()\n-    {\n+    public String[] getPropertyNames() {\n         return PROPERTY_NAMES;\n     }\n \n-    public Type[] getPropertyTypes()\n-    {\n+    public Type[] getPropertyTypes() {\n         return TYPES;\n     }\n \n-    public Object getPropertyValue(Object component, int property)\n-            throws HibernateException\n-    {\n+    public Object getPropertyValue(Object component, int property) throws HibernateException {\n         Interval interval = (Interval) component;\n-        return (property == 0) ? interval.getStart().toDate() : interval\n-                .getEnd().toDate();\n+        return (property == 0) ? interval.getStart().toDate() : interval.getEnd().toDate();\n     }\n \n-    public int hashCode(Object x) throws HibernateException\n-    {\n+    public int hashCode(Object x) throws HibernateException {\n         return x.hashCode();\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] names,\n-            SessionImplementor session, Object owner)\n-            throws HibernateException, SQLException\n-    {\n-        if (resultSet == null)\n-        {\n+    public Object nullSafeGet(ResultSet resultSet, String[] names, SessionImplementor session, Object owner)\n+            throws HibernateException, SQLException {\n+        if (resultSet == null) {\n             return null;\n         }\n         PersistentDateTime pst = new PersistentDateTime();\n         return new Interval(start, end);\n     }\n \n-    public void nullSafeSet(PreparedStatement statement, Object value,\n-            int index, SessionImplementor session) throws HibernateException,\n-            SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement statement, Object value, int index, SessionImplementor session)\n+            throws HibernateException, SQLException {\n+        if (value == null) {\n             statement.setNull(index, Hibernate.TIMESTAMP.sqlType());\n             statement.setNull(index + 1, Hibernate.TIMESTAMP.sqlType());\n             return;\n         return new Timestamp(time.getMillis());\n     }\n \n-    public Object replace(Object original, Object target,\n-            SessionImplementor session, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, SessionImplementor session, Object owner)\n+            throws HibernateException {\n         return original;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return Interval.class;\n     }\n \n-    public void setPropertyValue(Object component, int property, Object value)\n-            throws HibernateException\n-    {\n+    public void setPropertyValue(Object component, int property, Object value) throws HibernateException {\n         throw new UnsupportedOperationException(\"Immutable Interval\");\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java\n \n /**\n  * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentLocalDate implements EnhancedUserType, Serializable\n-{\n+public class PersistentLocalDate implements EnhancedUserType, Serializable {\n+\n     public final static PersistentLocalDate INSTANCE = new PersistentLocalDate();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.DATE,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.DATE, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return LocalDate.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         LocalDate dtx = (LocalDate) x;\n         LocalDate dty = (LocalDate) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.DATE.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n-\n         return new LocalDate(timestamp);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.DATE.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             Hibernate.DATE.nullSafeSet(preparedStatement, ((LocalDate) value).toDateTimeAtStartOfDay().toDate(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new LocalDate(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new LocalDate(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java\n \n /**\n  * Persist {@link org.joda.time.LocalDateTime} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentLocalDateTime implements EnhancedUserType, Serializable\n-{\n+public class PersistentLocalDateTime implements EnhancedUserType, Serializable {\n+\n     public final static PersistentLocalDateTime INSTANCE = new PersistentLocalDateTime();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIMESTAMP,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.TIMESTAMP, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return LocalDateTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         LocalDateTime dtx = (LocalDateTime) x;\n         LocalDateTime dty = (LocalDateTime) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n-\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n-\n         return new LocalDateTime(timestamp);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((LocalDateTime) value).toDateTime().toDate(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new LocalDateTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new LocalDateTime(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java\n \n /**\n  * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentLocalTimeAsString implements EnhancedUserType, Serializable\n-{\n+public class PersistentLocalTimeAsString implements EnhancedUserType, Serializable {\n+\n     public final static PersistentLocalTimeAsString INSTANCE = new PersistentLocalTimeAsString();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.VARCHAR,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.VARCHAR, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return LocalTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         LocalTime dtx = (LocalTime) x;\n         LocalTime dty = (LocalTime) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.STRING.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n \n         return new LocalTime(timestamp.toString());\n     }\n \n-\n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.STRING.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             LocalTime lt = ((LocalTime) value);\n-\n             Hibernate.STRING.nullSafeSet(preparedStatement, lt.toString(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new LocalTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new LocalTime(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java\n  * Persist {@link org.joda.time.LocalDate} via hibernate.\n  * This uses a simple integer to store the time as milliseconds since 1970-1-1.\n  * The milliseconds will survive.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentLocalTimeAsTime implements EnhancedUserType, Serializable\n-{\n+public class PersistentLocalTimeAsTime implements EnhancedUserType, Serializable {\n+\n     public final static PersistentLocalTimeAsTime INSTANCE = new PersistentLocalTimeAsTime();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIME,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.TIME, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return LocalTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         LocalTime dtx = (LocalTime) x;\n         LocalTime dty = (LocalTime) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.TIME.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n \n         return new LocalTime(timestamp, DateTimeZone.UTC);\n     }\n \n-\n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIME.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             LocalTime lt = ((LocalTime) value);\n             Time time = new Time(lt.getMillisOfDay());\n-\n             Hibernate.TIME.nullSafeSet(preparedStatement, time, index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new LocalTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new LocalTime(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java\n \n /**\n  * Persist {@link org.joda.time.LocalDate} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentLocalTimeExact implements EnhancedUserType, Serializable\n-{\n+public class PersistentLocalTimeExact implements EnhancedUserType, Serializable {\n+\n     public final static PersistentLocalTimeExact INSTANCE = new PersistentLocalTimeExact();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.INTEGER,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.INTEGER, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return LocalTime.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         LocalTime dtx = (LocalTime) x;\n         LocalTime dty = (LocalTime) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object timestamp = Hibernate.INTEGER.nullSafeGet(resultSet, string);\n-        if (timestamp == null)\n-        {\n+        if (timestamp == null) {\n             return null;\n         }\n \n         return LocalTime.fromMillisOfDay(((Number) timestamp).intValue());\n     }\n \n-\n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.INTEGER.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             LocalTime lt = ((LocalTime) value);\n-\n             Hibernate.INTEGER.nullSafeSet(preparedStatement, new Integer(lt.getMillisOfDay()), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new LocalTime(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new LocalTime(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentPeriod.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentPeriod.java\n /**\n  * Converts a org.joda.time.Period to and from Sql for Hibernate.\n  * It simply stores and retrieves the value as a varchar using Period.toString.\n- *\n+ * \n  * @author gjoseph\n  */\n public class PersistentPeriod extends AbstractStringBasedJodaType {\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java\n  * Persist {@link org.joda.time.TimeOfDay} via hibernate.\n  * This uses java.sql.Time and the time datatype of your database.\n  * Notice: You might loose the milliseconds part.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentTimeOfDay implements EnhancedUserType, Serializable\n-{\n+public class PersistentTimeOfDay implements EnhancedUserType, Serializable {\n+\n     private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+\n     public final static PersistentTimeOfDay INSTANCE = new PersistentTimeOfDay();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.TIME,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.TIME, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return TimeOfDay.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         TimeOfDay dtx = (TimeOfDay) x;\n         TimeOfDay dty = (TimeOfDay) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object date = Hibernate.TIME.nullSafeGet(resultSet, string);\n-        if (date == null)\n-        {\n+        if (date == null) {\n             return null;\n         }\n \n         return new TimeOfDay(date);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.TIME.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n-            Hibernate.TIME.nullSafeSet(preparedStatement, new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);\n+        } else {\n+            Hibernate.TIME.nullSafeSet(preparedStatement,\n+                    new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new TimeOfDay(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new TimeOfDay(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java\n  * Persist {@link org.joda.time.TimeOfDay} via hibernate.\n  * This uses a simple integer to store the time as milliseconds since 1970-1-1.\n  * The milliseconds will survive.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentTimeOfDayExact implements EnhancedUserType, Serializable\n-{\n+public class PersistentTimeOfDayExact implements EnhancedUserType, Serializable {\n+\n     private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+\n     public final static PersistentTimeOfDayExact INSTANCE = new PersistentTimeOfDayExact();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.INTEGER,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.INTEGER, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return TimeOfDay.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         TimeOfDay dtx = (TimeOfDay) x;\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         int value = resultSet.getInt(string);\n-        if (resultSet.wasNull())\n-        {\n+        if (resultSet.wasNull()) {\n             return null;\n         }\n-\n         return new TimeOfDay(value);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             preparedStatement.setNull(index, SQL_TYPES[0]);\n-        }\n-        else\n-        {\n+        } else {\n             preparedStatement.setInt(index, (int) ((TimeOfDay) value).toDateTime(timeBase).getMillis());\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new TimeOfDay(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new TimeOfDay(string);\n     }\n+\n }\n--- a/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java\n \n /**\n  * Persist {@link org.joda.time.YearMonthDay} via hibernate.\n- *\n+ * \n  * @author Mario Ivankovits (mario@ops.co.at)\n  */\n-public class PersistentYearMonthDay implements EnhancedUserType, Serializable\n-{\n+public class PersistentYearMonthDay implements EnhancedUserType, Serializable {\n+\n     public final static PersistentYearMonthDay INSTANCE = new PersistentYearMonthDay();\n \n-    private static final int[] SQL_TYPES = new int[]\n-    {\n-        Types.DATE,\n-    };\n+    private static final int[] SQL_TYPES = new int[] { Types.DATE, };\n \n-    public int[] sqlTypes()\n-    {\n+    public int[] sqlTypes() {\n         return SQL_TYPES;\n     }\n \n-    public Class returnedClass()\n-    {\n+    public Class returnedClass() {\n         return YearMonthDay.class;\n     }\n \n-    public boolean equals(Object x, Object y) throws HibernateException\n-    {\n-        if (x == y)\n-        {\n+    public boolean equals(Object x, Object y) throws HibernateException {\n+        if (x == y) {\n             return true;\n         }\n-        if (x == null || y == null)\n-        {\n+        if (x == null || y == null) {\n             return false;\n         }\n         YearMonthDay dtx = (YearMonthDay) x;\n         YearMonthDay dty = (YearMonthDay) y;\n-\n         return dtx.equals(dty);\n     }\n \n-    public int hashCode(Object object) throws HibernateException\n-    {\n+    public int hashCode(Object object) throws HibernateException {\n         return object.hashCode();\n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {\n         return nullSafeGet(resultSet, strings[0]);\n \n     }\n \n-    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n-    {\n+    public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException {\n         Object date = Hibernate.DATE.nullSafeGet(resultSet, string);\n-        if (date == null)\n-        {\n+        if (date == null) {\n             return null;\n         }\n-\n         return new YearMonthDay(date);\n     }\n \n-    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n-    {\n-        if (value == null)\n-        {\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {\n+        if (value == null) {\n             Hibernate.DATE.nullSafeSet(preparedStatement, null, index);\n-        }\n-        else\n-        {\n+        } else {\n             Hibernate.DATE.nullSafeSet(preparedStatement, ((YearMonthDay) value).toDateMidnight().toDate(), index);\n         }\n     }\n \n-    public Object deepCopy(Object value) throws HibernateException\n-    {\n-        if (value == null)\n-        {\n+    public Object deepCopy(Object value) throws HibernateException {\n+        if (value == null) {\n             return null;\n         }\n-\n         return new YearMonthDay(value);\n     }\n \n-    public boolean isMutable()\n-    {\n+    public boolean isMutable() {\n         return false;\n     }\n \n-    public Serializable disassemble(Object value) throws HibernateException\n-    {\n+    public Serializable disassemble(Object value) throws HibernateException {\n         return (Serializable) value;\n     }\n \n-    public Object assemble(Serializable cached, Object value) throws HibernateException\n-    {\n+    public Object assemble(Serializable cached, Object value) throws HibernateException {\n         return cached;\n     }\n \n-    public Object replace(Object original, Object target, Object owner) throws HibernateException\n-    {\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException {\n         return original;\n     }\n \n-    public String objectToSQLString(Object object)\n-    {\n+    public String objectToSQLString(Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public String toXMLString(Object object)\n-    {\n+    public String toXMLString(Object object) {\n         return object.toString();\n     }\n \n-    public Object fromXMLString(String string)\n-    {\n+    public Object fromXMLString(String string) {\n         return new YearMonthDay(string);\n     }\n+\n }", "timestamp": 1257634855, "metainfo": ""}