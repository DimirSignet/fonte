{"sha": "d622c13df8065b16bc6038538f23a5ee05d7d5fe", "log": "Add Period.toStandard*() methods  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n import java.io.Serializable;\n \n import org.joda.time.base.BasePeriod;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * An immutable time period specifying a set of duration field values.\n         return plusMillis(-millis);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period to a period in weeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard weeks in this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @throws ArithmeticException if the number of weeks is too large to be represented\n+     * @since 1.5\n+     */\n+    public Weeks toStandardWeeks() {\n+        checkYearsAndMonths(\"Weeks\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n+        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n+        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n+        return Weeks.weeks(FieldUtils.safeToInt(weeks));\n+    }\n+\n+    /**\n+     * Converts this period to a period in days assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard days in this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @throws ArithmeticException if the number of days is too large to be represented\n+     * @since 1.5\n+     */\n+    public Days toStandardDays() {\n+        checkYearsAndMonths(\"Days\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n+        long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n+        days = FieldUtils.safeAdd(days, getDays());\n+        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n+        return Days.days(FieldUtils.safeToInt(days));\n+    }\n+\n+    /**\n+     * Converts this period to a period in hours assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard hours in this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     * @since 1.5\n+     */\n+    public Hours toStandardHours() {\n+        checkYearsAndMonths(\"Hours\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n+        hours = FieldUtils.safeAdd(hours, getHours());\n+        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n+        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n+        return Hours.hours(FieldUtils.safeToInt(hours));\n+    }\n+\n+    /**\n+     * Converts this period to a period in minutes assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard minutes in this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     * @since 1.5\n+     */\n+    public Minutes toStandardMinutes() {\n+        checkYearsAndMonths(\"Minutes\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n+        minutes = FieldUtils.safeAdd(minutes, getMinutes());\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n+        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n+    }\n+\n+    /**\n+     * Converts this period to a period in seconds assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard seconds in this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     * @since 1.5\n+     */\n+    public Seconds toStandardSeconds() {\n+        checkYearsAndMonths(\"Seconds\");\n+        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n+        seconds = FieldUtils.safeAdd(seconds, getSeconds());\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n+        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period to a duration assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a duration equivalent to this period\n+     * @throws IllegalStateException if the period contains years or months\n+     * @since 1.5\n+     */\n+    public Duration toStandardDuration() {\n+        checkYearsAndMonths(\"Duration\");\n+        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n+        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+        return new Duration(millis);\n+    }\n+\n+    /**\n+     * Check that there are no years or months in the period.\n+     * \n+     * @param destintionType  the destination type, not null\n+     */\n+    private void checkYearsAndMonths(String destintionType) {\n+        if (getMonths() != 0) {\n+            throw new IllegalStateException(\"Cannot convert to \" + destintionType + \" as this period contains months and months vary in length\");\n+        }\n+        if (getYears() != 0) {\n+            throw new IllegalStateException(\"Cannot convert to \" + destintionType + \" as this period contains years and years vary in length\");\n+        }\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n import java.io.ByteArrayOutputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.math.BigInteger;\n import java.util.Arrays;\n import java.util.Locale;\n import java.util.TimeZone;\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n \n-    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    //private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     \n     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testToStandardWeeks() {\n+        Period test = new Period(0, 0, 3, 4, 5, 6, 7, 8);\n+        assertEquals(3, test.toStandardWeeks().getWeeks());\n+        \n+        test = new Period(0, 0, 3, 7, 0, 0, 0, 0);\n+        assertEquals(4, test.toStandardWeeks().getWeeks());\n+        \n+        test = new Period(0, 0, 0, 6, 23, 59, 59, 1000);\n+        assertEquals(1, test.toStandardWeeks().getWeeks());\n+        \n+        test = new Period(0, 0, Integer.MAX_VALUE, 0, 0, 0, 0, 0);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardWeeks().getWeeks());\n+        \n+        test = new Period(0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        long intMax = Integer.MAX_VALUE;\n+        BigInteger expected = BigInteger.valueOf(intMax);\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_DAY));\n+        expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK));\n+        assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n+        assertEquals(expected.longValue(), test.toStandardWeeks().getWeeks());\n+        \n+        test = new Period(0, 0, Integer.MAX_VALUE, 7, 0, 0, 0, 0);\n+        try {\n+            test.toStandardWeeks();\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardWeeks_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardWeeks();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardWeeks();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardWeeks().getWeeks());\n+    }\n+\n+    public void testToStandardWeeks_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardWeeks();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardWeeks();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardWeeks().getWeeks());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardDays() {\n+        Period test = new Period(0, 0, 0, 4, 5, 6, 7, 8);\n+        assertEquals(4, test.toStandardDays().getDays());\n+        \n+        test = new Period(0, 0, 1, 4, 0, 0, 0, 0);\n+        assertEquals(11, test.toStandardDays().getDays());\n+        \n+        test = new Period(0, 0, 0, 0, 23, 59, 59, 1000);\n+        assertEquals(1, test.toStandardDays().getDays());\n+        \n+        test = new Period(0, 0, 0, Integer.MAX_VALUE, 0, 0, 0, 0);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardDays().getDays());\n+        \n+        test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        long intMax = Integer.MAX_VALUE;\n+        BigInteger expected = BigInteger.valueOf(intMax);\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR));\n+        expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY));\n+        assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n+        assertEquals(expected.longValue(), test.toStandardDays().getDays());\n+        \n+        test = new Period(0, 0, 0, Integer.MAX_VALUE, 24, 0, 0, 0);\n+        try {\n+            test.toStandardDays();\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardDays_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardDays();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardDays();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardDays().getDays());\n+    }\n+\n+    public void testToStandardDays_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardDays();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardDays();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardDays().getDays());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardHours() {\n+        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8);\n+        assertEquals(5, test.toStandardHours().getHours());\n+        \n+        test = new Period(0, 0, 0, 1, 5, 0, 0, 0);\n+        assertEquals(29, test.toStandardHours().getHours());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 59, 59, 1000);\n+        assertEquals(1, test.toStandardHours().getHours());\n+        \n+        test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 0, 0, 0);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardHours().getHours());\n+        \n+        test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        long intMax = Integer.MAX_VALUE;\n+        BigInteger expected = BigInteger.valueOf(intMax);\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n+        expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR));\n+        assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n+        assertEquals(expected.longValue(), test.toStandardHours().getHours());\n+        \n+        test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 60, 0, 0);\n+        try {\n+            test.toStandardHours();\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardHours_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardHours();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardHours();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardHours().getHours());\n+    }\n+\n+    public void testToStandardHours_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardHours();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardHours();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardHours().getHours());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardMinutes() {\n+        Period test = new Period(0, 0, 0, 0, 0, 6, 7, 8);\n+        assertEquals(6, test.toStandardMinutes().getMinutes());\n+        \n+        test = new Period(0, 0, 0, 0, 1, 6, 0, 0);\n+        assertEquals(66, test.toStandardMinutes().getMinutes());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, 59, 1000);\n+        assertEquals(1, test.toStandardMinutes().getMinutes());\n+        \n+        test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 0, 0);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardMinutes().getMinutes());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        long intMax = Integer.MAX_VALUE;\n+        BigInteger expected = BigInteger.valueOf(intMax);\n+        expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n+        expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE));\n+        assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n+        assertEquals(expected.longValue(), test.toStandardMinutes().getMinutes());\n+        \n+        test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 60, 0);\n+        try {\n+            test.toStandardMinutes();\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardMinutes_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardMinutes();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardMinutes();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardMinutes().getMinutes());\n+    }\n+\n+    public void testToStandardMinutes_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardMinutes();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardMinutes();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardMinutes().getMinutes());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardSeconds() {\n+        Period test = new Period(0, 0, 0, 0, 0, 0, 7, 8);\n+        assertEquals(7, test.toStandardSeconds().getSeconds());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 1, 3, 0);\n+        assertEquals(63, test.toStandardSeconds().getSeconds());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, 0, 1000);\n+        assertEquals(1, test.toStandardSeconds().getSeconds());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 0);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardSeconds().getSeconds());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, 20, Integer.MAX_VALUE);\n+        long expected = 20;\n+        expected += ((long) Integer.MAX_VALUE) / DateTimeConstants.MILLIS_PER_SECOND;\n+        assertEquals(expected, test.toStandardSeconds().getSeconds());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 1000);\n+        try {\n+            test.toStandardSeconds();\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardSeconds_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardSeconds();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardSeconds();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardSeconds().getSeconds());\n+    }\n+\n+    public void testToStandardSeconds_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardSeconds();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardSeconds();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardSeconds().getSeconds());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardDuration() {\n+        Period test = new Period(0, 0, 0, 0, 0, 0, 0, 8);\n+        assertEquals(8, test.toStandardDuration().getMillis());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, 1, 20);\n+        assertEquals(1020, test.toStandardDuration().getMillis());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 0, 0, Integer.MAX_VALUE);\n+        assertEquals(Integer.MAX_VALUE, test.toStandardDuration().getMillis());\n+        \n+        test = new Period(0, 0, 0, 0, 0, 10, 20, Integer.MAX_VALUE);\n+        long expected = Integer.MAX_VALUE;\n+        expected += 10L * ((long) DateTimeConstants.MILLIS_PER_MINUTE);\n+        expected += 20L * ((long) DateTimeConstants.MILLIS_PER_SECOND);\n+        assertEquals(expected, test.toStandardDuration().getMillis());\n+        \n+        // proof that overflow does not occur\n+        BigInteger intMax = BigInteger.valueOf(Integer.MAX_VALUE);\n+        BigInteger exp = intMax;\n+        exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_SECOND)));\n+        exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE)));\n+        exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR)));\n+        exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY)));\n+        exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK)));\n+        assertTrue(exp.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n+//        test = new Period(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+//        try {\n+//            test.toStandardDuration();\n+//            fail();\n+//        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testToStandardDuration_years() {\n+        Period test = Period.years(1);\n+        try {\n+            test.toStandardDuration();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(-1);\n+        try {\n+            test.toStandardDuration();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.years(0);\n+        assertEquals(0, test.toStandardDuration().getMillis());\n+    }\n+\n+    public void testToStandardDuration_months() {\n+        Period test = Period.months(1);\n+        try {\n+            test.toStandardDuration();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(-1);\n+        try {\n+            test.toStandardDuration();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        test = Period.months(0);\n+        assertEquals(0, test.toStandardDuration().getMillis());\n+    }\n+\n }", "timestamp": 1187951109, "metainfo": ""}