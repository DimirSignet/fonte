{"sha": "a88a7cdd4c263492a40848c7b02e34ade0b7d833", "log": "DateTime.Property defined as inner class.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import java.util.Locale;\n \n import org.joda.time.format.ISODateTimeFormat;\n-import org.joda.time.property.DateTimeFieldProperty;\n+import org.joda.time.property.AbstractReadableInstantFieldProperty;\n \n /**\n  * DateTime is the standard implementation of an unmodifiable datetime class.\n      * \n      * @return the era property\n      */\n-    public final DateTimeFieldProperty era() {\n-        return new DateTimeFieldProperty(this, getChronology().era());\n+    public final Property era() {\n+        return new Property(this, getChronology().era());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public final DateTimeFieldProperty centuryOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    public final Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public final DateTimeFieldProperty yearOfCentury() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    public final Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n     }\n \n     /**\n      * \n      * @return the year of era property\n      */\n-    public final DateTimeFieldProperty yearOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n+    public final Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n     }\n \n     /**\n      * \n      * @return the year property\n      */\n-    public final DateTimeFieldProperty year() {\n-        return new DateTimeFieldProperty(this, getChronology().year());\n+    public final Property year() {\n+        return new Property(this, getChronology().year());\n     }\n \n     /**\n      * \n      * @return the year of a week based year property\n      */\n-    public final DateTimeFieldProperty weekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekyear());\n+    public final Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n     }\n \n     /**\n      * \n      * @return the month of year property\n      */\n-    public final DateTimeFieldProperty monthOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n+    public final Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n     }\n \n     /**\n      * \n      * @return the week of a week based year property\n      */\n-    public final DateTimeFieldProperty weekOfWeekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    public final Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n     }\n \n     /**\n      * \n      * @return the day of year property\n      */\n-    public final DateTimeFieldProperty dayOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n+    public final Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n     }\n \n     /**\n      * \n      * @return the day of month property\n      */\n-    public final DateTimeFieldProperty dayOfMonth() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    public final Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n     }\n \n     /**\n      * \n      * @return the day of week property\n      */\n-    public final DateTimeFieldProperty dayOfWeek() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());\n+    public final Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n     }\n \n     // Time properties\n      * \n      * @return the hour of day property\n      */\n-    public final DateTimeFieldProperty hourOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n+    public final Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n     }\n \n     /**\n      * \n      * @return the minute of day property\n      */\n-    public final DateTimeFieldProperty minuteOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    public final Property minuteOfDay() {\n+        return new Property(this, getChronology().minuteOfDay());\n     }\n \n     /**\n      * \n      * @return the minute of hour property\n      */\n-    public final DateTimeFieldProperty minuteOfHour() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    public final Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n     }\n \n     /**\n      * \n      * @return the second of day property\n      */\n-    public final DateTimeFieldProperty secondOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n+    public final Property secondOfDay() {\n+        return new Property(this, getChronology().secondOfDay());\n     }\n \n     /**\n      * \n      * @return the second of minute property\n      */\n-    public final DateTimeFieldProperty secondOfMinute() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    public final Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n     }\n \n     /**\n      * \n      * @return the millis of day property\n      */\n-    public final DateTimeFieldProperty millisOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n+    public final Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n     }\n \n     /**\n      * \n      * @return the millis of second property\n      */\n-    public final DateTimeFieldProperty millisOfSecond() {\n-        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());\n+    public final Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n     }\n \n     // Output\n     protected final void setChronology(Chronology chronology) {\n     }\n \n+    /**\n+     * DateTime.Property binds a DateTime to a DateTimeField allowing powerful\n+     * datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateTime - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * DateTime dt20 = dt.year().addToCopy(20);\n+     * </pre>\n+     * Serious modification of dates (ie. more than just changing one or two fields)\n+     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n+     * <p>\n+     * DateTime.Propery itself is thread-safe and immutable, as well as the\n+     * DateTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        static final long serialVersionUID = -6983323811635733510L;\n+        \n+        /** The instant this property is working against */\n+        private final DateTime iInstant;\n+        /** The field this property is working against */\n+        private final DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(DateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the instant being used.\n+         * \n+         * @return the instant\n+         */\n+        public ReadableInstant getReadableInstant() {\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Gets the datetime being used.\n+         * \n+         * @return the datetime\n+         */\n+        public DateTime getDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addToCopy(int value) {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.add(instant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addToCopy(long value) {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.add(instant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this DateTime.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addWrapFieldToCopy(int value) {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.addWrapField(instant.getMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime setCopy(int value) {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.set(instant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the DateTime to a parsed text value.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateTime setCopy(String text, Locale locale) {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.set(instant.getMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the DateTime to a parsed text value.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public final DateTime setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this DateTime.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundFloorCopy() {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.roundFloor(instant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this DateTime.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundCeilingCopy() {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.roundCeiling(instant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+         * favoring the floor if halfway.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfFloorCopy() {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.roundHalfFloor(instant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+         * favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfCeilingCopy() {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * DateTime.  If halfway, the ceiling is favored over the floor only if\n+         * it makes this field's value even.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfEvenCopy() {\n+            DateTime instant = iInstant;\n+            return instant.withMillis(iField.roundHalfEven(instant.getMillis()));\n+        }\n+    }\n+\n }", "timestamp": 1089868625, "metainfo": ""}