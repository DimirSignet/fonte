{"sha": "99af0da006022513fbb260c2c3a8648eb3059406", "log": "Create base subpackage   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.base.BaseDateTime;\n import org.joda.time.property.AbstractReadableInstantFieldProperty;\n \n /**\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class DateMidnight extends AbstractDateTime\n+public final class DateMidnight\n+        extends BaseDateTime\n         implements ReadableDateTime, Serializable {\n     \n     /** Serialization lock */\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @param chronology  the chronology to use, not null\n      */\n-    protected long round(long instant, Chronology chronology) {\n+    protected long checkInstant(long instant, Chronology chronology) {\n         return chronology.dayOfMonth().roundFloor(instant);\n     }\n \n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this instant with different millis\n      */\n-    public final DateMidnight withMillis(long newMillis) {\n+    public DateMidnight withMillis(long newMillis) {\n         Chronology chrono = getChronology();\n-        newMillis = round(newMillis, chrono);\n+        newMillis = checkInstant(newMillis, chrono);\n         return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n     }\n \n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n      */\n-    public final DateMidnight withChronology(Chronology newChronology) {\n+    public DateMidnight withChronology(Chronology newChronology) {\n         return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n     }\n \n      * @param newZone  the new time zone, null means default\n      * @return a copy of this instant with a different time zone\n      */\n-    public final DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n+    public DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n         newZone = (newZone == null ? DateTimeZone.getDefault() : newZone);\n         DateTimeZone originalZone = getZone();\n         originalZone = (originalZone == null ? DateTimeZone.getDefault() : originalZone);\n      * \n      * @return the era property\n      */\n-    public final Property era() {\n+    public Property era() {\n         return new Property(this, getChronology().era());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property centuryOfEra() {\n+    public Property centuryOfEra() {\n         return new Property(this, getChronology().centuryOfEra());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property yearOfCentury() {\n+    public Property yearOfCentury() {\n         return new Property(this, getChronology().yearOfCentury());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property yearOfEra() {\n+    public Property yearOfEra() {\n         return new Property(this, getChronology().yearOfEra());\n     }\n \n      * \n      * @return the year property\n      */\n-    public final Property year() {\n+    public Property year() {\n         return new Property(this, getChronology().year());\n     }\n \n      * \n      * @return the year of a week based year property\n      */\n-    public final Property weekyear() {\n+    public Property weekyear() {\n         return new Property(this, getChronology().weekyear());\n     }\n \n      * \n      * @return the month of year property\n      */\n-    public final Property monthOfYear() {\n+    public Property monthOfYear() {\n         return new Property(this, getChronology().monthOfYear());\n     }\n \n      * \n      * @return the week of a week based year property\n      */\n-    public final Property weekOfWeekyear() {\n+    public Property weekOfWeekyear() {\n         return new Property(this, getChronology().weekOfWeekyear());\n     }\n \n      * \n      * @return the day of year property\n      */\n-    public final Property dayOfYear() {\n+    public Property dayOfYear() {\n         return new Property(this, getChronology().dayOfYear());\n     }\n \n      * \n      * @return the day of month property\n      */\n-    public final Property dayOfMonth() {\n+    public Property dayOfMonth() {\n         return new Property(this, getChronology().dayOfMonth());\n     }\n \n      * \n      * @return the day of week property\n      */\n-    public final Property dayOfWeek() {\n+    public Property dayOfWeek() {\n         return new Property(this, getChronology().dayOfWeek());\n     }\n \n-    // Output\n     //-----------------------------------------------------------------------\n-    /**\n-     * Output the date time in ISO8601 format (yyyy-MM-dd'T'00:00:00.000Z).\n-     * \n-     * @return ISO8601 time formatted string.\n-     */\n-    public final String toString() {\n-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n-     */\n-    protected final void setMillis(long millis) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n-     */\n-    protected final void setChronology(Chronology chronology) {\n-    }\n-\n     /**\n      * DateMidnight.Property binds a DateMidnight to a DateTimeField allowing powerful\n      * datetime functionality to be easily accessed.\n      * @author Brian S O'Neill\n      * @since 1.0\n      */\n-    public static class Property extends AbstractReadableInstantFieldProperty {\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n     \n         /** Serialization lock */\n         private static final long serialVersionUID = 257629620L;\n          * @return a copy of the DateMidnight with the field value changed\n          * @throws IllegalArgumentException if the text value isn't valid\n          */\n-        public final DateMidnight setCopy(String text) {\n+        public DateMidnight setCopy(String text) {\n             return setCopy(text, null);\n         }\n \n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n import java.io.Serializable;\n import java.util.Locale;\n \n+import org.joda.time.base.BaseDateTime;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.AbstractReadableInstantFieldProperty;\n \n /**\n  * @since 1.0\n  * @see MutableDateTime\n  */\n-public class DateTime extends AbstractDateTime\n+public final class DateTime\n+        extends BaseDateTime\n         implements ReadableDateTime, Serializable {\n-    \n+\n     /** Serialization lock */\n     private static final long serialVersionUID = -5171125899451703815L;\n \n-    // Constructors\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs an instance set to the current system millisecond time\n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this datetime with different millis\n      */\n-    public final DateTime withMillis(long newMillis) {\n+    public DateTime withMillis(long newMillis) {\n         return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n     }\n \n      * @param newChronology  the new chronology\n      * @return a copy of this datetime with a different chronology\n      */\n-    public final DateTime withChronology(Chronology newChronology) {\n+    public DateTime withChronology(Chronology newChronology) {\n         return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n     }\n \n      * @return a copy of this datetime with a different time zone\n      * @see #withZoneRetainFields\n      */\n-    public final DateTime withZone(DateTimeZone newDateTimeZone) {\n+    public DateTime withZone(DateTimeZone newDateTimeZone) {\n         return withChronology(getChronology().withZone(newDateTimeZone));\n     }\n \n      * @return a copy of this datetime with a different time zone\n      * @see #withZone\n      */\n-    public final DateTime withZoneRetainFields(DateTimeZone newZone) {\n+    public DateTime withZoneRetainFields(DateTimeZone newZone) {\n         newZone = (newZone == null ? DateTimeZone.getDefault() : newZone);\n         DateTimeZone originalZone = getZone();\n         originalZone = (originalZone == null ? DateTimeZone.getDefault() : originalZone);\n      * @return a copy of this datetime with a different date\n      * @throws IllegalArgumentException if any value if invalid\n      */\n-    public final DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n+    public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n         Chronology chrono = getChronology();\n         long instant = getMillis();\n         instant = chrono.year().set(instant, year);\n      * @return a copy of this datetime with a different time\n      * @throws IllegalArgumentException if any value if invalid\n      */\n-    public final DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+    public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n         Chronology chrono = getChronology();\n         long instant = getMillis();\n         instant = chrono.hourOfDay().set(instant, hourOfDay);\n      * @return a copy of this datetime with a different set of fields\n      * @throws IllegalArgumentException if any value if invalid\n      */\n-    public final DateTime withFields(ReadablePartial partial) {\n+    public DateTime withFields(ReadablePartial partial) {\n         if (partial == null) {\n             return this;\n         }\n      * @return a copy of this datetime with the duration added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withDurationAdded(long durationToAdd) {\n+    public DateTime withDurationAdded(long durationToAdd) {\n         return withDurationAdded(durationToAdd, 1);\n     }\n \n      * @return a copy of this datetime with the duration added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withDurationAdded(long durationToAdd, int scalar) {\n+    public DateTime withDurationAdded(long durationToAdd, int scalar) {\n         if (durationToAdd == 0 || scalar == 0) {\n             return this;\n         }\n      * @return a copy of this datetime with the duration added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withDurationAdded(ReadableDuration durationToAdd) {\n+    public DateTime withDurationAdded(ReadableDuration durationToAdd) {\n         if (durationToAdd == null) {\n             return this;\n         }\n      * @return a copy of this datetime with the duration added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+    public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n         if (durationToAdd == null || scalar == 0) {\n             return this;\n         }\n      * @return a copy of this datetime with the period added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withPeriodAdded(ReadablePeriod periodToAdd) {\n+    public DateTime withPeriodAdded(ReadablePeriod periodToAdd) {\n         return withPeriodAdded(periodToAdd, 1);\n     }\n \n      * @return a copy of this datetime with the period added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public final DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {\n+    public DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {\n         if (periodToAdd == null || scalar == 0) {\n             return this;\n         }\n      * \n      * @return the era property\n      */\n-    public final Property era() {\n+    public Property era() {\n         return new Property(this, getChronology().era());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property centuryOfEra() {\n+    public Property centuryOfEra() {\n         return new Property(this, getChronology().centuryOfEra());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property yearOfCentury() {\n+    public Property yearOfCentury() {\n         return new Property(this, getChronology().yearOfCentury());\n     }\n \n      * \n      * @return the year of era property\n      */\n-    public final Property yearOfEra() {\n+    public Property yearOfEra() {\n         return new Property(this, getChronology().yearOfEra());\n     }\n \n      * \n      * @return the year property\n      */\n-    public final Property year() {\n+    public Property year() {\n         return new Property(this, getChronology().year());\n     }\n \n      * \n      * @return the year of a week based year property\n      */\n-    public final Property weekyear() {\n+    public Property weekyear() {\n         return new Property(this, getChronology().weekyear());\n     }\n \n      * \n      * @return the month of year property\n      */\n-    public final Property monthOfYear() {\n+    public Property monthOfYear() {\n         return new Property(this, getChronology().monthOfYear());\n     }\n \n      * \n      * @return the week of a week based year property\n      */\n-    public final Property weekOfWeekyear() {\n+    public Property weekOfWeekyear() {\n         return new Property(this, getChronology().weekOfWeekyear());\n     }\n \n      * \n      * @return the day of year property\n      */\n-    public final Property dayOfYear() {\n+    public Property dayOfYear() {\n         return new Property(this, getChronology().dayOfYear());\n     }\n \n      * \n      * @return the day of month property\n      */\n-    public final Property dayOfMonth() {\n+    public Property dayOfMonth() {\n         return new Property(this, getChronology().dayOfMonth());\n     }\n \n      * \n      * @return the day of week property\n      */\n-    public final Property dayOfWeek() {\n+    public Property dayOfWeek() {\n         return new Property(this, getChronology().dayOfWeek());\n     }\n \n      * \n      * @return the hour of day property\n      */\n-    public final Property hourOfDay() {\n+    public Property hourOfDay() {\n         return new Property(this, getChronology().hourOfDay());\n     }\n \n      * \n      * @return the minute of day property\n      */\n-    public final Property minuteOfDay() {\n+    public Property minuteOfDay() {\n         return new Property(this, getChronology().minuteOfDay());\n     }\n \n      * \n      * @return the minute of hour property\n      */\n-    public final Property minuteOfHour() {\n+    public Property minuteOfHour() {\n         return new Property(this, getChronology().minuteOfHour());\n     }\n \n      * \n      * @return the second of day property\n      */\n-    public final Property secondOfDay() {\n+    public Property secondOfDay() {\n         return new Property(this, getChronology().secondOfDay());\n     }\n \n      * \n      * @return the second of minute property\n      */\n-    public final Property secondOfMinute() {\n+    public Property secondOfMinute() {\n         return new Property(this, getChronology().secondOfMinute());\n     }\n \n      * \n      * @return the millis of day property\n      */\n-    public final Property millisOfDay() {\n+    public Property millisOfDay() {\n         return new Property(this, getChronology().millisOfDay());\n     }\n \n      * \n      * @return the millis of second property\n      */\n-    public final Property millisOfSecond() {\n+    public Property millisOfSecond() {\n         return new Property(this, getChronology().millisOfSecond());\n     }\n \n-    // Output\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n-     * \n-     * @return ISO8601 time formatted string.\n-     */\n-    public final String toString() {\n-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n-     */\n-    protected final void setMillis(long millis) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n-     */\n-    protected final void setChronology(Chronology chronology) {\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * DateTime.Property binds a DateTime to a DateTimeField allowing powerful\n      * datetime functionality to be easily accessed.\n      * @author Brian S O'Neill\n      * @since 1.0\n      */\n-    public static class Property extends AbstractReadableInstantFieldProperty {\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n         \n         /** Serialization version */\n         private static final long serialVersionUID = -6983323811635733510L;\n          * @return a copy of the DateTime with the field value changed\n          * @throws IllegalArgumentException if the text value isn't valid\n          */\n-        public final DateTime setCopy(String text) {\n+        public DateTime setCopy(String text) {\n             return setCopy(text, null);\n         }\n         \n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the zone handling null.\n+     * <p>\n+     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n+     * will be returned. Otherwise, the chronology is returned.\n+     * \n+     * @param chrono  the chronology to use, null means the default zone\n+     * @return the chronology, or default if null\n+     */\n+    public static final DateTimeZone getZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            return DateTimeZone.getDefault();\n+        }\n+        return zone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets the millisecond duration from the specified duration object handling null.\n      * <p>\n      * If the duration object is <code>null</code>, zero will be returned.\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.AbstractInstant;\n+import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n-import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class Instant extends AbstractInstant\n+public final class Instant\n+        extends AbstractInstant\n         implements ReadableInstant, Serializable {\n \n     /** Serialization lock */\n      * @return a copy of this instant with different millis\n      */\n     public Instant withMillis(long newMillis) {\n-        return newMillis == iMillis ? this : new Instant(newMillis);\n+        return (newMillis == iMillis ? this : new Instant(newMillis));\n     }\n \n     // Accessors\n     // Output\n     //-----------------------------------------------------------------------\n     /**\n-     * Output the date time in ISO8601 format.\n+     * Output the date time in ISO8601 format using the UTC time zone.\n      * <p>\n      * ISO8601 is deliberately used here so that the resulting string can be\n      * re-parsed by the constructor.\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.BaseDateTime;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n  * @since 1.0\n  * @see DateTime\n  */\n-public class MutableDateTime extends AbstractDateTime\n+public class MutableDateTime\n+        extends BaseDateTime\n         implements ReadWritableDateTime, Cloneable, Serializable {\n \n     /** Serialization version */\n     /** The mode of rounding */\n     private int iRoundingMode;\n \n-    // Constructors\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs an instance set to the current system millisecond time\n      * If the object contains no chronology, <code>ISOChronology</code>\n      * in the default time zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n-     * @param instant  the datetime object, must not be null\n+     * @param instant  the datetime object, null means now\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant) {\n      * If the object contains no chronology, <code>ISOChronology</code> is used.\n      * If the specified time zone is null, the default zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n-     * @param instant  the datetime object, must not be null\n+     * @param instant  the datetime object, null means now\n      * @param zone  the time zone, null means default time zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n \n     /**\n      * Constructs an instance from an Object that represents a datetime,\n-     * using the specifed chronology.\n+     * using the specified chronology.\n      * <p>\n      * If the chronology is null, ISOChronology in the default time zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n-     * @param instant  the datetime object, must not be null\n+     * @param instant  the datetime object, null means now\n      * @param chronology  the chronology, null means ISOChronology in default zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n         super(year, monthOfYear, dayOfMonth,\n               hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n     }\n-    \n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the field used for rounding this instant, returning null if rounding\n      * is not enabled.\n     //-----------------------------------------------------------------------\n     /**\n      * Set the milliseconds of the datetime.\n+     * <p>\n+     * All changes to the millisecond field occurs via this method.\n      *\n      * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n      * datetime to\n      * @see #setDateTime(Object)\n      */\n     public void setMillis(Object instant) {\n-        super.setMillis(instant);\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        setMillis(converter.getInstantMillis(instant));  // set via this class not super\n     }\n \n     // Add\n      * Add an amount of time to the datetime.\n      * \n      * @param duration  the millis to add\n-     */\n-    public void add(final long duration) {\n-        setMillis(getMillis() + duration);\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(long duration) {\n+        setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super\n     }\n \n     /**\n      * @throws IllegalArgumentException if the duration is invalid\n      * @throws ArithmeticException if the result exceeds the capacity of the instant\n      */\n-    public void add(final Object duration) {\n+    public void add(Object duration) {\n         add(duration, 1);\n     }\n \n      * @throws IllegalArgumentException if the duration is invalid\n      * @throws ArithmeticException if the result exceeds the capacity of the instant\n      */\n-    public void add(final Object duration, final int scalar) {\n-        // TODO Change from Object to individual methods\n-        if (duration instanceof ReadableDuration) {\n-            ReadableDuration d = (ReadableDuration) duration;\n-            add(FieldUtils.safeMultiply(d.getMillis(), scalar));\n-        } else if (duration instanceof ReadablePeriod) {\n+    public void add(Object duration, int scalar) {\n+        if (duration instanceof ReadablePeriod) {\n             ReadablePeriod d = (ReadablePeriod) duration;\n             d.addInto(this, scalar);\n         } else {\n     //-----------------------------------------------------------------------\n     /**\n      * Set the chronology of the datetime.\n+     * <p>\n+     * All changes to the chronology occur via this method.\n      * \n      * @param chronology  the chronology to use, null means ISOChronology in default zone\n      */\n      * @see #setZoneRetainFields\n      */\n     public void setZone(DateTimeZone zone) {\n-        super.setZone(zone);\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology();\n+        if (chrono.getZone() != zone) {\n+            setChronology(chrono.withZone(zone));  // set via this class not super\n+        }\n     }\n \n     /**\n      * @see #setZone\n      */\n     public void setZoneRetainFields(DateTimeZone zone) {\n-        super.setZoneRetainFields(zone);\n+        zone = DateTimeUtils.getZone(zone);\n+        DateTimeZone originalZone = getZone();\n+        originalZone = (originalZone == null ? DateTimeZone.getDefault() : originalZone);\n+        if (zone == originalZone) {\n+            return;\n+        }\n+        \n+        long millis = originalZone.getMillisKeepLocal(zone, getMillis());\n+        setChronology(getChronology().withZone(zone));  // set via this class not super\n+        setMillis(millis);\n     }\n \n     // Field based\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.format.DateTimeFormat;\n+\n+/**\n+ * AbstractDateTime provides the common behaviour for datetime classes.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * Whenever you want to implement <code>ReadableDateTime</code> you should\n+ * extend this class.\n+ * <p>\n+ * AbstractDateTime subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractDateTime\n+        extends AbstractInstant\n+        implements ReadableDateTime {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDateTime() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.getInstance(getChronology()).forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.getInstance(getChronology(), locale).forPattern(pattern).print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractInstant provides the common behaviour for instant classes.\n+ * <p>\n+ * This class has no concept of a chronology, all methods work on the\n+ * millisecond instant.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInstant} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * Whenever you want to implement <code>ReadableInstant</code> you should\n+ * extend this class.\n+ * <p>\n+ * AbstractInstant itself is thread-safe and immutable, but subclasses may be\n+ * mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractInstant implements ReadableInstant {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractInstant() {\n+        super();\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the time zone of the datetime from the chronology, or null if there\n+     * isn't any chronology.\n+     * \n+     * @return the DateTimeZone that the datetime is using\n+     */\n+    public DateTimeZone getZone() {\n+        Chronology chrono = getChronology();\n+        return (chrono != null ? chrono.getZone() : null);\n+    }\n+\n+    /**\n+     * Get the value of the specified field.\n+     * <p>\n+     * This could be used to get a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * Instant dt = new Instant();\n+     * int gjYear = dt.get(GJChronology.getInstance().year());\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField subclass to use\n+     * @return the value\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public int get(DateTimeField field) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The DateTimeField must not be null\");\n+        }\n+        return field.get(getMillis());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an Instant.\n+     * \n+     * @return an Instant using the same millis\n+     */\n+    public Instant toInstant() {\n+        if (this instanceof Instant) {\n+            return (Instant) this;\n+        }\n+        return new Instant(this);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime() {\n+        if (this instanceof DateTime) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (this instanceof DateTime && getZone() == zone) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        if (this instanceof DateTime && getChronology() == chronology) {\n+            return (DateTime) this;\n+        }\n+        return new DateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO immutable DateTime. The purpose of\n+     * this method is to guarantee that an externally received DateTime\n+     * object does not have any backdoors that allow it to be modified.\n+     * <p>\n+     * If this object is already a DateTime, whose chronology is\n+     * {@link ISOChronology ISO}, and the time zone came from the default\n+     * {@link org.joda.time.tz.Provider provider}, then this object is cast to\n+     * a DateTime and returned. Otherwise, a new trusted DateTime is returned.\n+     * \n+     * @return a trusted ISO DateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is not trusted, and\n+     * no matching trusted time zone can be found.\n+     */\n+    public DateTime toTrustedISODateTime() {\n+        DateTimeZone zone = getZone();\n+        if (zone == null) {\n+            return new DateTime(this, (Chronology)null);\n+        }\n+\n+        DateTimeZone trusted = DateTimeZone.getInstance(zone.getID());\n+        \n+        if (zone == trusted &&\n+            getClass() == DateTime.class &&\n+            getChronology().getClass() == ISOChronology.class) {\n+            return (DateTime) this;\n+        }\n+        \n+        return new DateTime(this, ISOChronology.getInstance(trusted));\n+    }\n+\n+    // NOTE: Although the toMutableDateTime methods could check to see if this\n+    // is already a MutableDateTime and return this casted, it makes it too\n+    // easy to mistakenly modify ReadableDateTime input parameters. Always\n+    // returning a copy prevents this.\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime() {\n+        return new MutableDateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return new MutableDateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        return new MutableDateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Date</code>.\n+     * \n+     * @return a Date initialised with this datetime\n+     */\n+    public Date toDate() {\n+        return new Date(getMillis());\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Calendar</code>.\n+     * The locale is passed in, enabling Calendar to select the correct\n+     * localized subclass.\n+     * \n+     * @param locale  the locale to get the Calendar for, or default if null\n+     * @return a localized Calendar initialised with this datetime\n+     */\n+    public Calendar toCalendar(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        DateTimeZone zone = getZone();\n+        Calendar cal;\n+        if (zone == null) {\n+            cal = Calendar.getInstance(locale);\n+        } else {\n+            cal = Calendar.getInstance(zone.toTimeZone(), locale);\n+        }\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.GregorianCalendar</code>.\n+     * \n+     * @return a GregorianCalendar initialised with this datetime\n+     */\n+    public GregorianCalendar toGregorianCalendar() {\n+        DateTimeZone zone = getZone();\n+        GregorianCalendar cal;\n+        if (zone == null) {\n+            cal = new GregorianCalendar();\n+        } else {\n+            cal = new GregorianCalendar(zone.toTimeZone());\n+        }\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant and the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     * <p>\n+     * See {@link #isEqual(ReadableInstant)} for an equals method that\n+     * ignores the Chronology.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableInstant) {\n+        // must be to fulfil ReadableInstant contract\n+        if (this == readableInstant) {\n+            return true;\n+        }\n+        if (readableInstant instanceof ReadableInstant) {\n+            ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n+            if (getMillis() == otherInstant.getMillis()) {\n+                Chronology chrono = getChronology();\n+                if (chrono == otherInstant.getChronology()) {\n+                    return true;\n+                }\n+                if (chrono != null && chrono.equals(otherInstant.getChronology())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        // must be to fulfil ReadableInstant contract\n+        return\n+            ((int) (getMillis() ^ (getMillis() >>> 32))) +\n+            (getChronology() == null ? 0 : getChronology().hashCode());\n+    }\n+\n+    /**\n+     * Compares this object with the specified object for ascending\n+     * millisecond instant order. This ordering is inconsistent with\n+     * equals, as it ignores the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param instant  a readable instant to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    public int compareTo(Object instant) {\n+        if (this == instant) {\n+            return 0;\n+        }\n+\n+        ReadableInstant otherInstant = (ReadableInstant) instant;\n+\n+        long otherMillis = otherInstant.getMillis();\n+        long thisMillis = getMillis();\n+\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Is the millisecond value after the millisecond passed in.\n+     *\n+     * @param instant  an instant to check against, null returns false\n+     * @return true if the instant is after the instant passed in\n+     */\n+    public boolean isAfter(ReadableInstant instant) {\n+        if (instant == null) {\n+            return false;\n+        }\n+        return (getMillis() > instant.getMillis());\n+    }\n+\n+    /**\n+     * Is the millisecond value before the millisecond passed in.\n+     *\n+     * @param instant  an instant to check against, null returns false\n+     * @return true if the instant is before the instant passed in\n+     */\n+    public boolean isBefore(ReadableInstant instant) {\n+        if (instant == null) {\n+            return false;\n+        }\n+        return (getMillis() < instant.getMillis());\n+    }\n+\n+    /**\n+     * Is the millisecond value equal to the millisecond passed in.\n+     *\n+     * @param instant  an instant to check against, null returns false\n+     * @return true if the instant is equal to the instant passed in\n+     */\n+    public boolean isEqual(ReadableInstant instant) {\n+        if (instant == null) {\n+            return false;\n+        }\n+        return (getMillis() == instant.getMillis());\n+    }\n+\n+    // Output    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BaseDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * BaseDateTime is an abstract implementation of ReadableDateTime that stores\n+ * data in <code>long</code> and <code>Chronology</code> fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * BaseDateTime subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Kandarp Shah\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class BaseDateTime\n+        extends AbstractDateTime\n+        implements ReadableDateTime, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -6728882245981L;\n+\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private long iMillis;\n+    /** The chronology to use */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     */\n+    public BaseDateTime() {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public BaseDateTime(DateTimeZone zone) {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public BaseDateTime(long instant) {\n+        this(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public BaseDateTime(long instant, DateTimeZone zone) {\n+        this(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(long instant, Chronology chronology) {\n+        super();\n+        iChronology = checkChronology(chronology);\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public BaseDateTime(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = checkChronology(converter.getChronology(instant));\n+        iMillis = checkInstant(converter.getInstantMillis(instant), iChronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public BaseDateTime(Object instant, DateTimeZone zone) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = checkChronology(converter.getChronology(instant, zone));\n+        iMillis = checkInstant(converter.getInstantMillis(instant, zone), iChronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public BaseDateTime(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = checkChronology(converter.getChronology(instant, chronology));\n+        iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        iChronology = checkChronology(chronology);\n+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the specified chronology before storing it, potentially altering it.\n+     * This method must not access any instance variables.\n+     * <p>\n+     * This implementation converts nulls to ISOChronology in the default zone.\n+     *\n+     * @param chronology  the chronology to use, may be null\n+     * @return the chronology to store in this datetime, not null\n+     */\n+    protected Chronology checkChronology(Chronology chronology) {\n+        return DateTimeUtils.getChronology(chronology);\n+    }\n+\n+    /**\n+     * Checks the specified instant before storing it, potentially altering it.\n+     * This method must not access any instance variables.\n+     * <p>\n+     * This implementation simply returns the instant.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param chronology  the chronology to use, not null\n+     * @return the instant to store in this datetime\n+     */\n+    protected long checkInstant(long instant, Chronology chronology) {\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the milliseconds of the datetime.\n+     * <p>\n+     * All changes to the millisecond field occurs via this method.\n+     * Override and block this method to make a subclass immutable.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to\n+     */\n+    protected void setMillis(long instant) {\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    /**\n+     * Sets the chronology of the datetime.\n+     * <p>\n+     * All changes to the chronology field occurs via this method.\n+     * Override and block this method to make a subclass immutable.\n+     *\n+     * @param chronology  the chronology to set\n+     */\n+    protected void setChronology(Chronology chronology) {\n+        iChronology = checkChronology(chronology);\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/ClassLoadTest.java\n+++ b/JodaTime/src/test/org/joda/time/ClassLoadTest.java\n  */\n package org.joda.time;\n \n-import org.joda.time.AbstractDateTime;\n-import org.joda.time.AbstractInstant;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.ReadableDateTime;\n+import org.joda.time.base.AbstractDateTime;\n+import org.joda.time.base.AbstractInstant;\n \n /**\n  * This class displays what the ClassLoader is up to.\n--- a/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.base.AbstractInstant;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n \n         assertEquals(test.getMillis(), result.getMillis());\n         assertEquals(ISOChronology.getInstance(), result.getChronology());\n \n-        test = new MockUntrustedDateMidnight(TEST_TIME1_UTC);\n-        result = test.toTrustedISODateTime();\n-        assertSame(DateTime.class, result.getClass());\n-        assertSame(ISOChronology.class, result.getChronology().getClass());\n-        assertEquals(test.getMillis(), result.getMillis());\n-        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+//        test = new MockUntrustedDateMidnight(TEST_TIME1_UTC);\n+//        result = test.toTrustedISODateTime();\n+//        assertSame(DateTime.class, result.getClass());\n+//        assertSame(ISOChronology.class, result.getChronology().getClass());\n+//        assertEquals(test.getMillis(), result.getMillis());\n+//        assertEquals(ISOChronology.getInstance(), result.getChronology());\n \n         test = new DateMidnight(TEST_TIME1_UTC, new MockUntrustedZone(\"Europe/Paris\"));\n         result = test.toTrustedISODateTime();\n         assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n     }\n \n-    static class MockUntrustedDateMidnight extends DateMidnight {\n-        MockUntrustedDateMidnight(long millis) {\n-            super(millis);\n-        }\n-    }\n+//    static class MockUntrustedDateMidnight extends DateMidnight {\n+//        MockUntrustedDateMidnight(long millis) {\n+//            super(millis);\n+//        }\n+//    }\n \n     static class MockUntrustedZone extends DateTimeZone {\n         MockUntrustedZone(String id) {\n         assertSame(test, result);\n     }\n     \n-    public void testImmutable() {\n-        MockChangeDateMidnight test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n-        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n-        test.testSetMillis();\n-        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n-        \n-        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n-        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n-        test.testSetMillisObject();\n-        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n-        \n-        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetChronology();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        \n-        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetZone();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        \n-        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetZoneRetainFields();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-    }\n-    \n-    static class MockChangeDateMidnight extends DateMidnight {\n-        MockChangeDateMidnight(long instant) {\n-            super(instant);\n-        }\n-        public void testSetMillis() {\n-            setMillis(0L);\n-        }\n-        public void testSetMillisObject() {\n-            setMillis(new Date(0L));\n-        }\n-        public void testSetChronology() {\n-            setChronology(GregorianChronology.getInstance(PARIS));\n-        }\n-        public void testSetZone() {\n-            setZone(PARIS);\n-        }\n-        public void testSetZoneRetainFields() {\n-            setZoneRetainFields(PARIS);\n-        }\n-    }\n-\n }\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.base.AbstractInstant;\n import org.joda.time.chrono.AbstractChronology;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.GregorianChronology;\n         assertSame(DateTime.class, result.getClass());\n         assertSame(ISOChronology.class, result.getChronology().getClass());\n \n-        test = new MockUntrustedDateTime(TEST_TIME1);\n-        result = test.toTrustedISODateTime();\n-        assertSame(DateTime.class, result.getClass());\n-        assertSame(ISOChronology.class, result.getChronology().getClass());\n-        assertEquals(test.getMillis(), result.getMillis());\n-        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+//        test = new MockUntrustedDateTime(TEST_TIME1);\n+//        result = test.toTrustedISODateTime();\n+//        assertSame(DateTime.class, result.getClass());\n+//        assertSame(ISOChronology.class, result.getChronology().getClass());\n+//        assertEquals(test.getMillis(), result.getMillis());\n+//        assertEquals(ISOChronology.getInstance(), result.getChronology());\n \n         test = new DateTime(TEST_TIME1, new MockUntrustedZone(\"Europe/Paris\"));\n         result = test.toTrustedISODateTime();\n         assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n     }\n \n-    static class MockUntrustedDateTime extends DateTime {\n-        MockUntrustedDateTime(long millis) {\n-            super(millis);\n-        }\n-    }\n+//    static class MockUntrustedDateTime extends DateTime {\n+//        MockUntrustedDateTime(long millis) {\n+//            super(millis);\n+//        }\n+//    }\n \n     static class MockUntrustedZone extends DateTimeZone {\n         MockUntrustedZone(String id) {\n         assertEquals(expected, result);\n     }\n     \n-    //-----------------------------------------------------------------------\n-    public void testImmutable() {\n-        MockChangeDateTime test = new MockChangeDateTime(TEST_TIME_NOW);\n-        assertEquals(TEST_TIME_NOW, test.getMillis());\n-        test.testSetMillis();\n-        assertEquals(TEST_TIME_NOW, test.getMillis());\n-        \n-        test = new MockChangeDateTime(TEST_TIME_NOW);\n-        assertEquals(TEST_TIME_NOW, test.getMillis());\n-        test.testSetMillisObject();\n-        assertEquals(TEST_TIME_NOW, test.getMillis());\n-        \n-        test = new MockChangeDateTime(TEST_TIME_NOW);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetChronology();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        \n-        test = new MockChangeDateTime(TEST_TIME_NOW);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetZone();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        \n-        test = new MockChangeDateTime(TEST_TIME_NOW);\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-        test.testSetZoneRetainFields();\n-        assertEquals(ISOChronology.getInstance(), test.getChronology());\n-    }\n-    \n-    static class MockChangeDateTime extends DateTime {\n-        MockChangeDateTime(long instant) {\n-            super(instant);\n-        }\n-        public void testSetMillis() {\n-            setMillis(0L);\n-        }\n-        public void testSetMillisObject() {\n-            setMillis(new Date(0L));\n-        }\n-        public void testSetChronology() {\n-            setChronology(GregorianChronology.getInstance(PARIS));\n-        }\n-        public void testSetZone() {\n-            setZone(PARIS);\n-        }\n-        public void testSetZoneRetainFields() {\n-            setZoneRetainFields(PARIS);\n-        }\n-    }\n+//    //-----------------------------------------------------------------------\n+//    public void testImmutable() {\n+//        MockChangeDateTime test = new MockChangeDateTime(TEST_TIME_NOW);\n+//        assertEquals(TEST_TIME_NOW, test.getMillis());\n+//        try {\n+//            test.testSetMillis();\n+//            fail();\n+//        } catch (UnsupportedOperationException ex) {}\n+//        assertEquals(TEST_TIME_NOW, test.getMillis());\n+//        \n+//        test = new MockChangeDateTime(TEST_TIME_NOW);\n+//        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+//        try {\n+//            test.testSetChronology();\n+//            fail();\n+//        } catch (UnsupportedOperationException ex) {}\n+//        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+//    }\n+//    \n+//    static class MockChangeDateTime extends DateTime {\n+//        MockChangeDateTime(long instant) {\n+//            super(instant);\n+//        }\n+//        public void testSetMillis() {\n+//            setMillis(0L);\n+//        }\n+//        public void testSetChronology() {\n+//            setChronology(GregorianChronology.getInstance(PARIS));\n+//        }\n+//    }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.base.AbstractInstant;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n \n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.base.AbstractInstant;\n import org.joda.time.chrono.AbstractChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;", "timestamp": 1093036842, "metainfo": ""}