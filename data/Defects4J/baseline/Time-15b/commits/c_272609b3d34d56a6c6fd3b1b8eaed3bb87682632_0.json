{"sha": "272609b3d34d56a6c6fd3b1b8eaed3bb87682632", "log": "Add new method addWrapPartial that is useful for TimeOfDay   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n     public abstract int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n \n     /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping the whole partial if the maximum size of the partial is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n+     * If ths limit is reached by the addition, this method will wrap back to\n+     * 00:00:00.000. In fact, you would generally only use this method for\n+     * classes that have a limitation such as this.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 10:20:30 add 20 minutes is 10:40:30<br>\n+     * 10:20:30 add 45 minutes is 11:05:30<br>\n+     * 10:20:30 add 16 hours is 02:20:30<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the partial\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public abstract int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n+\n+    /**\n      * Adds a value (which may be negative) to the millis value,\n      * wrapping within this field.\n      * <p>\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n  * Joda Software License, Version 1.0\n  *\n  *\n- * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * Copyright (c) 2001-2005 Stephen Colebourne.  \n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n      * 2001-01-31 add two months is 2001-03-31<br>\n      * \n      * @param instant  the partial instant\n-     * @param fieldIndex  the index of this field in the instant\n+     * @param fieldIndex  the index of this field in the partial\n      * @param values  the values of the partial instant which should be updated\n      * @param valueToAdd  the value to add, in the units of the field\n      * @return the passed in values\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n-            valueToAdd -= (max + 1) - values[fieldIndex];\n-            values = nextField.add(instant, fieldIndex - 1, values, 1);\n-            values[fieldIndex] = getMinimumValue(instant, values);\n+            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n+            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n         }\n         while (valueToAdd < 0) {\n             int min = getMinimumValue(instant, values);\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n-            valueToAdd -= (min - 1) - values[fieldIndex];\n-            values = nextField.add(instant, fieldIndex - 1, values, -1);\n-            values[fieldIndex] = getMaximumValue(instant, values);\n+            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.add(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n+            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n+        }\n+        \n+        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping the whole partial if the maximum size of the partial is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n+     * If ths limit is reached by the addition, this method will wrap back to\n+     * 00:00:00.000. In fact, you would generally only use this method for\n+     * classes that have a limitation such as this.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 10:20:30 add 20 minutes is 10:40:30<br>\n+     * 10:20:30 add 45 minutes is 11:05:30<br>\n+     * 10:20:30 add 16 hours is 02:20:30<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the partial\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        if (valueToAdd == 0) {\n+            return values;\n+        }\n+        // there are more efficient algorithms than this (especially for time only fields)\n+        // trouble is when dealing with days and months, so we use this technique of\n+        // adding/removing one from the larger field at a time\n+        DateTimeField nextField = null;\n+        \n+        while (valueToAdd > 0) {\n+            int max = getMaximumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed <= max) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    valueToAdd -= (max + 1) - values[fieldIndex];\n+                    values[fieldIndex] = getMinimumValue(instant, values);\n+                    continue;\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                // test only works if this field is UTC (ie. local)\n+                if (getRangeDurationField() != nextField.getDurationField()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n+            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n+        }\n+        while (valueToAdd < 0) {\n+            int min = getMinimumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed >= min) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    valueToAdd -= (min - 1) - values[fieldIndex];\n+                    values[fieldIndex] = getMaximumValue(instant, values);\n+                    continue;\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                if (getRangeDurationField() != nextField.getDurationField()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n+            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n         }\n         \n         return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n  * Joda Software License, Version 1.0\n  *\n  *\n- * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * Copyright (c) 2001-2005 Stephen Colebourne.  \n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n         return iField.add(instant, fieldIndex, values, valueToAdd);\n     }\n \n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return iField.addWrapPartial(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n     public long addWrapField(long instant, int value) {\n         return iField.addWrapField(instant, value);\n     }\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n  * Joda Software License, Version 1.0\n  *\n  *\n- * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * Copyright (c) 2001-2005 Stephen Colebourne.  \n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n      *\n      * @throws UnsupportedOperationException\n      */\n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n     public long addWrapField(long instant, int value) {\n         throw unsupported();\n     }", "timestamp": 1106782346, "metainfo": ""}