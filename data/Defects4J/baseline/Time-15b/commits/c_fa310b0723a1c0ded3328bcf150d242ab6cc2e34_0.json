{"sha": "fa310b0723a1c0ded3328bcf150d242ab6cc2e34", "log": "Add isXxx() methods Optimise by using DateTimeUtils   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.Instant;\n import org.joda.time.MutableDateTime;\n      * @return a DateTime using the same millis\n      */\n     public DateTime toDateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n+        zone = DateTimeUtils.getZone(zone);\n         if (this instanceof DateTime && getZone() == zone) {\n             return (DateTime) this;\n         }\n      * @return a DateTime using the same millis\n      */\n     public DateTime toDateTime(Chronology chronology) {\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n+        chronology = DateTimeUtils.getChronology(chronology);\n         if (this instanceof DateTime && getChronology() == chronology) {\n             return (DateTime) this;\n         }\n      * @return a MutableDateTime using the same millis\n      */\n     public MutableDateTime toMutableDateTime(DateTimeZone zone) {\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n         return new MutableDateTime(this, zone);\n     }\n \n      * @return a MutableDateTime using the same millis\n      */\n     public MutableDateTime toMutableDateTime(Chronology chronology) {\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n         return new MutableDateTime(this, chronology);\n     }\n \n         if (this == instant) {\n             return 0;\n         }\n-\n+        \n         ReadableInstant otherInstant = (ReadableInstant) instant;\n-\n+        \n         long otherMillis = otherInstant.getMillis();\n         long thisMillis = getMillis();\n-\n+        \n         // cannot do (thisMillis - otherMillis) as can overflow\n         if (thisMillis == otherMillis) {\n             return 0;\n         }\n     }\n \n-    /**\n-     * Is the millisecond value after the millisecond passed in.\n-     *\n-     * @param instant  an instant to check against, null returns false\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant after the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is after the instant passed in\n+     */\n+    public boolean isAfter(long instant) {\n+        return (getMillis() > instant);\n+    }\n+\n+    /**\n+     * Is this instant after the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is after the current instant\n+     */\n+    public boolean isAfterNow() {\n+        return isAfter(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant after the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n      * @return true if the instant is after the instant passed in\n      */\n     public boolean isAfter(ReadableInstant instant) {\n-        if (instant == null) {\n-            return false;\n-        }\n-        return (getMillis() > instant.getMillis());\n-    }\n-\n-    /**\n-     * Is the millisecond value before the millisecond passed in.\n-     *\n-     * @param instant  an instant to check against, null returns false\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isAfter(instantMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant before the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is before the instant passed in\n+     */\n+    public boolean isBefore(long instant) {\n+        return (getMillis() < instant);\n+    }\n+\n+    /**\n+     * Is this instant before the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is before the current instant\n+     */\n+    public boolean isBeforeNow() {\n+        return isBefore(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant before the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n      * @return true if the instant is before the instant passed in\n      */\n     public boolean isBefore(ReadableInstant instant) {\n-        if (instant == null) {\n-            return false;\n-        }\n-        return (getMillis() < instant.getMillis());\n-    }\n-\n-    /**\n-     * Is the millisecond value equal to the millisecond passed in.\n-     *\n-     * @param instant  an instant to check against, null returns false\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isBefore(instantMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant equal to the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is before the instant passed in\n+     */\n+    public boolean isEqual(long instant) {\n+        return (getMillis() == instant);\n+    }\n+\n+    /**\n+     * Is this instant equal to the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is before the current instant\n+     */\n+    public boolean isEqualNow() {\n+        return isEqual(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant equal to the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n      * @return true if the instant is equal to the instant passed in\n      */\n     public boolean isEqual(ReadableInstant instant) {\n-        if (instant == null) {\n-            return false;\n-        }\n-        return (getMillis() == instant.getMillis());\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isEqual(instantMillis);\n     }\n \n     // Output    ", "timestamp": 1093040784, "metainfo": ""}