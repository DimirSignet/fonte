{"sha": "b6272b13444f16bd60245a5ff8f339e8fee1c64d", "log": "More comments.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n  * formatters.\n  *\n  * <p>\n- * For example, a formatter that prints month and year, like \"January 1970\", can\n- * be constructed as follows:\n+ * For example, a formatter that prints month and year, like \"January 1970\",\n+ * can be constructed as follows:\n  * <p>\n  * <pre>\n  * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n     /**\n      * Appends another formatter.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if formatter is null\n      */\n     public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)\n      * Appends just a printer. With no matching parser, a parser cannot be\n      * built from this DateTimeFormatterBuilder.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if printer is null\n      */\n     public DateTimeFormatterBuilder append(final DateTimePrinter printer)\n      * Appends just a parser. With no matching printer, a printer cannot be\n      * built from this builder.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if parser is null\n      */\n     public DateTimeFormatterBuilder append(final DateTimeParser parser) {\n     /**\n      * Appends a printer/parser pair.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if printer or parser is null\n      */\n     public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n      * null, this represents the empty parser. The presence of an empty parser\n      * indicates that the entire array of parse formats is optional.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if any parser element but the last is null\n      */\n     public DateTimeFormatterBuilder append(final DateTimePrinter printer,\n      * Appends just a parser element which is optional. With no matching\n      * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if parser is null\n      */\n     public DateTimeFormatterBuilder appendOptional(final DateTimeParser parser) {\n     /**\n      * Instructs the printer to emit a specific character, and the parser to\n      * expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendLiteral(final char c) {\n         return append0(new CharacterLiteral(iChrono, c));\n      * Instructs the printer to emit specific text, and the parser to expect\n      * it. The parser is case-insensitive.\n      *\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if text is null\n      */\n     public DateTimeFormatterBuilder appendLiteral(final String text) {\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if field is null\n      */\n     public DateTimeFormatterBuilder appendNumeric(\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if field is null\n      */\n     public DateTimeFormatterBuilder appendSignedNumeric(\n      * parser to expect text.\n      *\n      * @param field field should operate in UTC or be time zone agnostic\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendText(final DateTimeField field) {\n         return append0(new TextField(iChrono, field, iLocale, false));\n      * parser to expect text.\n      *\n      * @param field field should operate in UTC or be time zone agnostic\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n         return append0(new TextField(iChrono, field, iLocale, true));\n      * @param field field should operate in UTC or be time zone agnostic\n      * @param minDigits minumum number of digits to print.\n      * @param maxDigits maximum number of digits to print or parse.\n+     * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if field's duration is not precise\n      */\n     public DateTimeFormatterBuilder appendFraction(\n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, final int maxDigits) {\n         return appendFraction(iChronoUTC.secondOfDay(), minDigits, maxDigits);\n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, final int maxDigits) {\n         return appendFraction(iChronoUTC.minuteOfDay(), minDigits, maxDigits);\n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final int maxDigits) {\n         return appendFraction(iChronoUTC.hourOfDay(), minDigits, maxDigits);\n     /**\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final int maxDigits) {\n         return appendFraction(iChronoUTC.dayOfYear(), minDigits, maxDigits);\n      * Instructs the printer to emit a numeric millisOfSecond field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {\n         return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);\n      * Instructs the printer to emit a numeric millisOfDay field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);\n      * Instructs the printer to emit a numeric secondOfMinute field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {\n         return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);\n      * Instructs the printer to emit a numeric secondOfDay field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);\n      * Instructs the printer to emit a numeric minuteOfHour field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {\n         return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);\n      * Instructs the printer to emit a numeric minuteOfDay field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);\n      * Instructs the printer to emit a numeric hourOfDay field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);\n      * Instructs the printer to emit a numeric clockhourOfDay field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {\n         return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);\n      * Instructs the printer to emit a numeric hourOfHalfday field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {\n         return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);\n      * Instructs the printer to emit a numeric clockhourOfHalfday field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {\n         return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n      * Instructs the printer to emit a numeric dayOfWeek field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);\n      * Instructs the printer to emit a numeric dayOfMonth field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);\n      * Instructs the printer to emit a numeric dayOfYear field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n         return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);\n      * Instructs the printer to emit a numeric weekOfWeekyear field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {\n         return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {\n         return appendNumeric\n      * Instructs the printer to emit a numeric monthOfYear field.\n      *\n      * @param minDigits minumum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {\n         return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {\n         return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);\n      * @param minDigits minumum number of digits to <i>print</i>\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {\n         return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {\n         return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n      * @param minDigits minumum number of digits to print\n      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n      * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {\n         return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);\n     /**\n      * Instructs the printer to emit a locale-specific AM/PM text, and the\n      * parser to expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n         return appendText(iChronoUTC.halfdayOfDay());\n     /**\n      * Instructs the printer to emit a locale-specific dayOfWeek text. The\n      * parser will accept a long or short dayOfWeek text, case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekText() {\n         return appendText(iChronoUTC.dayOfWeek());\n      * Instructs the printer to emit a short locale-specific dayOfWeek\n      * text. The parser will accept a long or short dayOfWeek text,\n      * case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n         return appendShortText(iChronoUTC.dayOfWeek());\n      * Instructs the printer to emit a short locale-specific monthOfYear\n      * text. The parser will accept a long or short monthOfYear text,\n      * case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearText() { \n         return appendText(iChronoUTC.monthOfYear());\n     /**\n      * Instructs the printer to emit a locale-specific monthOfYear text. The\n      * parser will accept a long or short monthOfYear text, case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n         return appendShortText(iChronoUTC.monthOfYear());\n     /**\n      * Instructs the printer to emit a locale-specific era text (BC/AD), and\n      * the parser to expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendEraText() {\n         return appendText(iChronoUTC.era());\n      * Instructs the printer to emit a locale-specific time zone name. A\n      * parser cannot be created from this builder if a time zone name is\n      * appended.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n         return append0(new TimeZonePrinter(iChrono, iLocale, false), null);\n      * Instructs the printer to emit a short locale-specific time zone\n      * name. A parser cannot be created from this builder if time zone\n      * name is appended.\n+     *\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName() {\n         return append0(new TimeZonePrinter(iChrono, iLocale, true), null);\n      * @param minFields minimum number of fields to print, stopping when no\n      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n      * @param maxFields maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneOffset(\n             final String zeroOffsetText, final boolean showSeparators,", "timestamp": 1071802899, "metainfo": ""}