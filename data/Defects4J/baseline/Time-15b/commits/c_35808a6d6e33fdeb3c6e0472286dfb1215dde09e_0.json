{"sha": "35808a6d6e33fdeb3c6e0472286dfb1215dde09e", "log": "Fixed overflow when getting year field from instants at Long.MAX_VALUE and LONG.MIN_VALUE.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicChronology.java\n         // represents the start of that year. Then verify estimate and fix if\n         // necessary.\n \n-        long unitMillis = getAverageMillisPerYear();\n-        long i2 = instant + getApproxMillisAtEpoch();\n+        // Initial estimate uses values divided by two to avoid overflow.\n+        long unitMillis = getAverageMillisPerYearDividedByTwo();\n+        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n         if (i2 < 0) {\n             i2 = i2 - unitMillis + 1;\n         }\n         int year = (int) (i2 / unitMillis);\n \n-        long yearStart;\n-        try {\n-            yearStart = getYearMillis(year);\n-        } catch (ArithmeticException e) {\n-            if (instant > 0) {\n-                throw new ArithmeticException(\"Instant too large: \" + instant);\n-            } else {\n-                throw new ArithmeticException(\"Instant too small: \" + instant);\n-            }\n-        }\n-\n+        long yearStart = getYearMillis(year);\n         long diff = instant - yearStart;\n \n         if (diff < 0) {\n     abstract long getAverageMillisPerYear();\n \n     /**\n+     * Gets an average value for the milliseconds per year, divided by two.\n+     * \n+     * @return the millis per year divided by two\n+     */\n+    abstract long getAverageMillisPerYearDividedByTwo();\n+\n+    /**\n      * Gets an average value for the milliseconds per month.\n      * \n      * @return the millis per month\n \n     /**\n      * Returns a constant representing the approximate number of milliseconds\n-     * elapsed from year 0 of this chronology. This constant <em>must</em> be\n-     * defined as:\n+     * elapsed from year 0 of this chronology, divided by two. This constant\n+     * <em>must</em> be defined as:\n      * <pre>\n-     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch\n+     *    (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2\n      * </pre>\n      * where epoch is 1970-01-01 (Gregorian).\n      */\n-    abstract long getApproxMillisAtEpoch();\n+    abstract long getApproxMillisAtEpochDividedByTwo();\n \n     /**\n      * Sets the year from an instant and year.\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n     }\n \n     //-----------------------------------------------------------------------\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     long getAverageMillisPerMonth() {\n         return MILLIS_PER_MONTH;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n     /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292269337;\n \n-    /**\n-     * The highest year that can be fully supported.\n-     * Although calculateFirstDayOfYearMillis can go higher without\n-     * overflowing, the getYear method overflows when it adds the\n-     * approximate millis at the epoch.\n-     */\n-    private static final int MAX_YEAR = 292271022;\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272708;\n \n     /** Cache of zone to chronology arrays */\n     private static final Map cCache = new HashMap();\n \n     //-----------------------------------------------------------------------\n     long calculateFirstDayOfYearMillis(int year) {\n-        if (year > MAX_YEAR) {\n-            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n-        }\n-        if (year < MIN_YEAR) {\n-            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n-        }\n-\n         // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n         // Calculate relative to the nearest leap year and account for the\n         // difference later.\n     }\n \n     //-----------------------------------------------------------------------\n-    long getApproxMillisAtEpoch() {\n-        return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n     /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292269337;\n \n-    /**\n-     * The highest year that can be fully supported.\n-     * Although calculateFirstDayOfYearMillis can go higher without\n-     * overflowing, the getYear method overflows when it adds the\n-     * approximate millis at the epoch.\n-     */\n-    private static final int MAX_YEAR = 292271022;\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272984;\n \n     /** Cache of zone to chronology arrays */\n     private static final Map cCache = new HashMap();\n \n     //-----------------------------------------------------------------------\n     long calculateFirstDayOfYearMillis(int year) {\n-        if (year > MAX_YEAR) {\n-            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n-        }\n-        if (year < MIN_YEAR) {\n-            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n-        }\n-\n         // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.\n         // Calculate relative to the nearest leap year and account for the\n         // difference later.\n     }\n \n     //-----------------------------------------------------------------------\n-    long getApproxMillisAtEpoch() {\n-        return 1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n \n     private static final int DAYS_0000_TO_1970 = 719527;\n \n-    // The lowest year that can be fully supported.\n+    /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292275054;\n \n-    // The highest year that can be fully supported. Although\n-    // calculateFirstDayOfYearMillis can operate on years up to 292278994\n-    // without overflowing, the getYear method overflows when it adds the\n-    // approximate millis at the epoch.\n-    private static final int MAX_YEAR = 292277023;\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292278993;\n \n     /** Singleton instance of a UTC GregorianChronology */\n     private static final GregorianChronology INSTANCE_UTC;\n     }\n \n     long calculateFirstDayOfYearMillis(int year) {\n-        if (year > MAX_YEAR) {\n-            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n-        }\n-        if (year < MIN_YEAR) {\n-            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n-        }\n-\n         // Initial value is just temporary.\n         int leapYears = year / 100;\n         if (year < 0) {\n         return MILLIS_PER_YEAR;\n     }\n \n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n     long getAverageMillisPerMonth() {\n         return MILLIS_PER_MONTH;\n     }\n \n-    long getApproxMillisAtEpoch() {\n-        return 1970L * MILLIS_PER_YEAR;\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1970L * MILLIS_PER_YEAR) / 2;\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java\n     }\n \n     //-----------------------------------------------------------------------\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     long getAverageMillisPerMonth() {\n         return MILLIS_PER_MONTH;\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    long getApproxMillisAtEpoch() {\n+    long getApproxMillisAtEpochDividedByTwo() {\n         // Epoch 1970-01-01 ISO = 1389-10-22 Islamic\n-        return -MILLIS_YEAR_1;\n+        return (-MILLIS_YEAR_1) / 2;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n     private static final long MILLIS_PER_MONTH =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n-    // The lowest year that can be fully supported.\n+    /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292269054;\n \n-    // The highest year that can be fully supported. Although\n-    // calculateFirstDayOfYearMillis can go higher without overflowing, the\n-    // getYear method overflows when it adds the approximate millis at the\n-    // epoch.\n-    private static final int MAX_YEAR = 292271022;\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272992;\n \n     /** Singleton instance of a UTC JulianChronology */\n     private static final JulianChronology INSTANCE_UTC;\n     }\n \n     long calculateFirstDayOfYearMillis(int year) {\n-        if (year > MAX_YEAR) {\n-            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n-        }\n-        if (year < MIN_YEAR) {\n-            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n-        }\n-\n         // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n         // Calculate relative to the nearest leap year and account for the\n         // difference later.\n         return MILLIS_PER_YEAR;\n     }\n \n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n     long getAverageMillisPerMonth() {\n         return MILLIS_PER_MONTH;\n     }\n \n-    long getApproxMillisAtEpoch() {\n-        return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n     }\n \n     protected void assemble(Fields fields) {\n--- a/JodaTime/src/test/org/joda/time/TestDateMidnight_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Properties.java\n         assertEquals(9, test.year().getMaximumShortTextLength(null));\n         assertEquals(-292275054, test.year().getMinimumValue());\n         assertEquals(-292275054, test.year().getMinimumValueOverall());\n-        assertEquals(292277023, test.year().getMaximumValue());\n-        assertEquals(292277023, test.year().getMaximumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n         assertEquals(9, test.year().getMaximumShortTextLength(null));\n         assertEquals(-292275054, test.year().getMinimumValue());\n         assertEquals(-292275054, test.year().getMinimumValueOverall());\n-        assertEquals(292277023, test.year().getMaximumValue());\n-        assertEquals(292277023, test.year().getMaximumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n     }\n \n     public void testPropertyLeapYear() {\n         assertEquals(292277023, copy.getYear());\n         \n         try {\n-            test.year().addToCopy(292277023 - 2004 + 1);\n+            test.year().addToCopy(292278993 - 2004 + 1);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         copy = test.year().addWrapFieldToCopy(0);\n         assertEquals(2004, copy.getYear());\n         \n-        copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);\n+        copy = test.year().addWrapFieldToCopy(292278993 - 2004 + 1);\n         assertEquals(-292275054, copy.getYear());\n         \n         copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1);\n-        assertEquals(292277023, copy.getYear());\n+        assertEquals(292278993, copy.getYear());\n     }\n \n     public void testPropertySetYear() {\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Properties.java\n         LocalDate test = new LocalDate(1972, 6, 9);\n         assertEquals(-292275054, test.year().getMinimumValue());\n         assertEquals(-292275054, test.year().getMinimumValueOverall());\n-        assertEquals(292277023, test.year().getMaximumValue());\n-        assertEquals(292277023, test.year().getMaximumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n     }\n \n     public void testPropertyPlusYear() {\n         copy = test.year().plus(0);\n         check(copy, 1972, 6, 9);\n         \n-        copy = test.year().plus(292277023 - 1972);\n-        check(copy, 292277023, 6, 9);\n-        \n-        try {\n-            test.year().plus(292277023 - 1972 + 1);\n+        copy = test.year().plus(292278993 - 1972);\n+        check(copy, 292278993, 6, 9);\n+        \n+        try {\n+            test.year().plus(292278993 - 1972 + 1);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         check(test, 1972, 6, 9);\n         copy = test.year().plusWrapField(0);\n         check(copy, 1972, 6, 9);\n         \n-        copy = test.year().plusWrapField(292277023 - 1972 + 1);\n+        copy = test.year().plusWrapField(292278993 - 1972 + 1);\n         check(copy, -292275054, 6, 9);\n         \n         copy = test.year().plusWrapField(-292275054 - 1972 - 1);\n-        check(copy, 292277023, 6, 9);\n+        check(copy, 292278993, 6, 9);\n     }\n \n     public void testPropertyWithYear() {\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Properties.java\n         assertEquals(9, test.year().getMaximumShortTextLength(null));\n         assertEquals(-292275054, test.year().getMinimumValue());\n         assertEquals(-292275054, test.year().getMinimumValueOverall());\n-        assertEquals(292277023, test.year().getMaximumValue());\n-        assertEquals(292277023, test.year().getMaximumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n     }\n \n     public void testPropertyAddYear() {\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n         YearMonthDay test = new YearMonthDay(1972, 6, 9);\n         assertEquals(-292275054, test.year().getMinimumValue());\n         assertEquals(-292275054, test.year().getMinimumValueOverall());\n-        assertEquals(292277023, test.year().getMaximumValue());\n-        assertEquals(292277023, test.year().getMaximumValueOverall());\n+        assertEquals(292278993, test.year().getMaximumValue());\n+        assertEquals(292278993, test.year().getMaximumValueOverall());\n     }\n \n     public void testPropertyAddYear() {\n         check(copy, 292277023, 6, 9);\n         \n         try {\n-            test.year().addToCopy(292277023 - 1972 + 1);\n+            test.year().addToCopy(292278993 - 1972 + 1);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         check(test, 1972, 6, 9);\n         copy = test.year().addWrapFieldToCopy(0);\n         check(copy, 1972, 6, 9);\n         \n-        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);\n+        copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1);\n         check(copy, -292275054, 6, 9);\n         \n         copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);\n-        check(copy, 292277023, 6, 9);\n+        check(copy, 292278993, 6, 9);\n     }\n \n     public void testPropertySetYear() {\n--- a/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n         } catch (IllegalFieldValueException e) {\n         }\n \n-        try {\n-            chrono.year().get(Long.MAX_VALUE);\n-            fail();\n-        } catch (ArithmeticException e) {\n-        }\n+        assertEquals(maxYear + 1, chrono.year().get(Long.MAX_VALUE));\n     }\n \n     public void testMinYear() {\n         } catch (IllegalFieldValueException e) {\n         }\n \n-        try {\n-            chrono.year().get(Long.MIN_VALUE);\n-            fail();\n-        } catch (ArithmeticException e) {\n-        }\n+        assertEquals(minYear - 1, chrono.year().get(Long.MIN_VALUE));\n     }\n \n     public void testCutoverAddYears() {", "timestamp": 1142804763, "metainfo": ""}