{"sha": "7ae214c8dfb443e848c2be7ab9da930c1a7fcd56", "log": "Refine partial API and add tests   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n     boolean isSupported(DateTimeFieldType field);\n \n     /**\n-     * Resolves this partial against another complete instant to create a new\n-     * full instant. The combination is performed using the chronology of the\n-     * specified instant.\n+     * Converts this partial to a full datetime using the specified time zone and\n+     * filing in any gaps using the current datetime.\n+     * <p>\n+     * This method obtains the current datetime, creates a chronology from that\n+     * on this instance plus the time zone specified, and then sets the fields\n+     * from this instant on top.\n      * <p>\n      * For example, if this partial represents a time, then the result of this\n      * method will be the datetime from the specified base instant plus the\n      * time from this partial.\n      *\n+     * @param zone  the zone to use, null means default\n+     * @return the combined datetime\n+     */\n+    DateTime toDateTime(DateTimeZone zone);\n+\n+    /**\n+     * Converts this partial to a full datetime by resolving it against another\n+     * datetime.\n+     * <p>\n+     * This method takes the specified datetime and sets the fields from this\n+     * instant on top. The chronology from the base instant is used.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n      * @param baseInstant  the instant that provides the missing fields, null means now\n      * @return the combined datetime\n      */\n-    DateTime toDateTimeUsing(ReadableInstant baseInstant);\n+    DateTime toDateTime(ReadableInstant baseInstant);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n public final class TimeOfDay\n         extends BasePartial\n         implements ReadablePartial, Serializable {\n+    // NOTE: No toDateTime(YearMonthDay) as semantics are confusing when\n+    // different chronologies\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3633353405803318660L;\n         DateTimeFieldType.millisOfSecond(),\n     };\n \n+    /** Constant for midnight. */\n+    public static final TimeOfDay MIDNIGHT = new TimeOfDay(0, 0, 0, 0);\n+\n     /** The index of the hourOfDay field in the field array */\n     public static final int HOUR_OF_DAY = 0;\n     /** The index of the minuteOfHour field in the field array */\n     }\n \n     /**\n-     * Constructs a TimeOfDay with specified fields, values and chronology.\n+     * Constructs a TimeOfDay with chronology from this instance and new values.\n      *\n      * @param partial  the partial to base this new instance on\n      * @param values  the new set of values\n      */\n     TimeOfDay(TimeOfDay partial, int[] values) {\n         super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    TimeOfDay(TimeOfDay partial, Chronology chrono) {\n+        super(partial, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     /**\n      * Creates a new TimeOfDay instance with the specified chronology.\n-     * <p>\n-     * This period instance is immutable and unaffected by this method call.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as TimeOfDay\n+     * operates without a time zone.\n      *\n      * @param newChronology  the new chronology, null means ISO\n      * @return a copy of this datetime with a different chronology\n      */\n-    public TimeOfDay withChronology(Chronology newChronology) {\n+    public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n         newChronology = DateTimeUtils.getChronology(newChronology);\n         newChronology = newChronology.withUTC();\n         if (newChronology == getChronology()) {\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n     }\n \n     /**\n-     * Constructs a YearMonthDay with specified fields, values and chronology.\n+     * Constructs a YearMonthDay with chronology from this instance and new values.\n      *\n      * @param partial  the partial to base this new instance on\n      * @param values  the new set of values\n      */\n     YearMonthDay(YearMonthDay partial, int[] values) {\n         super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    YearMonthDay(YearMonthDay partial, Chronology chrono) {\n+        super(partial, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     /**\n      * Creates a new YearMonthDay instance with the specified chronology.\n-     * <p>\n-     * This period instance is immutable and unaffected by this method call.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as TimeOfDay\n+     * operates without a time zone.\n      *\n      * @param newChronology  the new chronology, null means ISO\n      * @return a copy of this datetime with a different chronology\n      */\n-    public YearMonthDay withChronology(Chronology newChronology) {\n+    public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n         newChronology = DateTimeUtils.getChronology(newChronology);\n         newChronology = newChronology.withUTC();\n         if (newChronology == getChronology()) {\n      * @return the DateMidnight instance\n      */\n     public DateMidnight toDateMidnight(DateTimeZone zone) {\n-        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields and using the default time zone.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time) {\n+        return toDateTime(time, null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @param zone  the zone to get the DateTime in, null means default\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instant = DateTimeUtils.currentTimeMillis();\n+        instant = chrono.set(this, instant);\n+        if (time != null) {\n+            instant = chrono.set(time, instant);\n+        }\n+        return new DateTime(instant, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n \n \n     //-----------------------------------------------------------------------\n     /**\n+     * Converts this partial to a full datetime using the specified time zone and\n+     * filing in any gaps using the current datetime.\n+     * <p>\n+     * This method obtains the current datetime, creates a chronology from that\n+     * on this instance plus the time zone specified, and then sets the fields\n+     * from this instant on top.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return the combined datetime\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    /**\n      * Resolves this partial against another complete instant to create a new\n      * full instant. The combination is performed using the chronology of the\n      * specified instant.\n      * @param baseInstant  the instant that provides the missing fields, null means now\n      * @return the combined datetime\n      */\n-    public DateTime toDateTimeUsing(ReadableInstant baseInstant) {\n+    public DateTime toDateTime(ReadableInstant baseInstant) {\n         Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n         long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n         long resolved = chrono.set(this, instantMillis);\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n import java.io.Serializable;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.InstantConverter;\n         iValues = values;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using the current date to fill in the\n+     * missing fields and using the default time zone.\n+     *\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime() {\n+        return toDateTime((DateTimeZone) null);\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this property to another.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (object instanceof AbstractPartialFieldProperty) {\n+            AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n+            if (get() == other.get() &&\n+                getFieldType() == other.getFieldType() &&\n+                getReadablePartial().getChronology() == other.getReadablePartial().getChronology()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output a debugging string.\n      * \n      * @return debugging string\n--- a/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this property to another.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (object instanceof AbstractReadableInstantFieldProperty) {\n+            AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n+            if (get() == other.get() &&\n+                getFieldType() == other.getFieldType() &&\n+                getReadableInstant().getChronology() == other.getReadableInstant().getChronology()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Output a debugging string.\n      * \n      * @return debugging string\n--- a/JodaTime/src/test/org/joda/time/MockPartial.java\n+++ b/JodaTime/src/test/org/joda/time/MockPartial.java\n     public static final ReadablePartial EMPTY_INSTANCE = new MockPartial();\n     \n     public Chronology getChronology() {\n-        return ISOChronology.getInstance();\n+        return ISOChronology.getInstanceUTC();\n     }\n     public int size() {\n         return getFields().length;\n     public boolean isSupported(DateTimeFieldType field) {\n         return false;\n     }\n-    public DateTime toDateTimeUsing(ReadableInstant base) {\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        return null;\n+    }\n+    public DateTime toDateTime(ReadableInstant base) {\n         return null;\n     }\n     public DateTimeField[] getFields() {\n--- a/JodaTime/src/test/org/joda/time/TestAbstractPartial.java\n+++ b/JodaTime/src/test/org/joda/time/TestAbstractPartial.java\n import junit.framework.TestSuite;\n \n import org.joda.time.base.AbstractPartial;\n-import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n \n /**\n  * This class is a Junit unit test for YearMonthDay.\n \n     public void testGetField() throws Throwable {\n         MockPartial mock = new MockPartial();\n-        assertEquals(BuddhistChronology.getInstance().year(), mock.getField(0));\n-        assertEquals(BuddhistChronology.getInstance().monthOfYear(), mock.getField(1));\n+        assertEquals(Chronology.getBuddhistUTC().year(), mock.getField(0));\n+        assertEquals(Chronology.getBuddhistUTC().monthOfYear(), mock.getField(1));\n         \n         try {\n             mock.getField(-1);\n         assertEquals(2, vals.length);\n         assertEquals(DateTimeFieldType.year(), vals[0]);\n         assertEquals(DateTimeFieldType.monthOfYear(), vals[1]);\n+    }\n+\n+    public void testGetPropertyEquals() throws Throwable {\n+        MockPartial mock = new MockPartial();\n+        YearMonthDay ymd = new YearMonthDay(1970, 2, 1, Chronology.getBuddhist());\n+        \n+        MockProperty0 prop0 = new MockProperty0();\n+        assertEquals(true, prop0.equals(prop0));\n+        assertEquals(true, prop0.equals(new MockProperty0()));\n+        assertEquals(false, prop0.equals(new MockProperty1()));\n+        assertEquals(false, prop0.equals(new MockProperty0Val()));\n+        assertEquals(false, prop0.equals(new MockProperty0Field()));\n+        assertEquals(false, prop0.equals(new MockProperty0Chrono()));\n+        assertEquals(false, prop0.equals(\"\"));\n+        assertEquals(false, prop0.equals(null));\n     }\n \n     //-----------------------------------------------------------------------\n         }\n \n         public Chronology getChronology() {\n-            return BuddhistChronology.getInstance();\n+            return Chronology.getBuddhistUTC();\n+        }\n+    }\n+    \n+    static class MockProperty0 extends AbstractPartialFieldProperty {\n+        MockPartial partial = new MockPartial();\n+        public DateTimeField getField() {\n+            return partial.getField(0);\n+        }\n+        public ReadablePartial getReadablePartial() {\n+            return partial;\n+        }\n+        public int get() {\n+            return partial.getValue(0);\n+        }\n+    }\n+    static class MockProperty1 extends AbstractPartialFieldProperty {\n+        MockPartial partial = new MockPartial();\n+        public DateTimeField getField() {\n+            return partial.getField(1);\n+        }\n+        public ReadablePartial getReadablePartial() {\n+            return partial;\n+        }\n+        public int get() {\n+            return partial.getValue(1);\n+        }\n+    }\n+    static class MockProperty0Field extends MockProperty0 {\n+        public DateTimeField getField() {\n+            return Chronology.getBuddhistUTC().hourOfDay();\n+        }\n+    }\n+    static class MockProperty0Val extends MockProperty0 {\n+        public int get() {\n+            return 99;\n+        }\n+    }\n+    static class MockProperty0Chrono extends MockProperty0 {\n+        public ReadablePartial getReadablePartial() {\n+            return new MockPartial() {\n+                public Chronology getChronology() {\n+                    return Chronology.getISOUTC();\n+                }\n+            };\n         }\n     }\n }\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestMutablePeriod_Basics.suite());\n         suite.addTest(TestMutablePeriod_Updates.suite());\n         \n+        suite.addTest(TestTimeOfDay_Basics.suite());\n+        suite.addTest(TestTimeOfDay_Constructors.suite());\n+        suite.addTest(TestTimeOfDay_Properties.suite());\n+        \n+        suite.addTest(TestYearMonthDay_Basics.suite());\n+        suite.addTest(TestYearMonthDay_Constructors.suite());\n+        suite.addTest(TestYearMonthDay_Properties.suite());\n+        \n         suite.addTest(TestAbstractPartial.suite());\n         suite.addTest(TestBasePartial.suite());\n-        suite.addTest(TestTimeOfDay.suite());\n-        suite.addTest(TestYearMonthDay.suite());\n         \n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+    private static final int OFFSET = 1;\n+    private static final Chronology COPTIC_PARIS = Chronology.getCoptic(PARIS);\n+    private static final Chronology COPTIC_LONDON = Chronology.getCoptic(LONDON);\n+    private static final Chronology COPTIC_TOKYO = Chronology.getCoptic(TOKYO);\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology ISO_PARIS = Chronology.getISO(PARIS);\n+    private static final Chronology ISO_LONDON = Chronology.getISO(LONDON);\n+    private static final Chronology ISO_TOKYO = Chronology.getISO(TOKYO);\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology BUDDHIST_PARIS = Chronology.getBuddhist(PARIS);\n+    private static final Chronology BUDDHIST_LONDON = Chronology.getBuddhist(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = Chronology.getBuddhist(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay_Basics.class);\n+    }\n+\n+    public TestTimeOfDay_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10 + OFFSET, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(4, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);\n+        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));\n+        assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2));\n+        assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(5);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);\n+        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);\n+        assertSame(DateTimeFieldType.secondOfMinute(), fields[2]);\n+        assertSame(DateTimeFieldType.millisOfSecond(), fields[3]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField() {\n+        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);\n+        assertSame(Chronology.getCopticUTC().hourOfDay(), test.getField(0));\n+        assertSame(Chronology.getCopticUTC().minuteOfHour(), test.getField(1));\n+        assertSame(Chronology.getCopticUTC().secondOfMinute(), test.getField(2));\n+        assertSame(Chronology.getCopticUTC().millisOfSecond(), test.getField(3));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(5);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(Chronology.getCopticUTC().hourOfDay(), fields[0]);\n+        assertSame(Chronology.getCopticUTC().minuteOfHour(), fields[1]);\n+        assertSame(Chronology.getCopticUTC().secondOfMinute(), fields[2]);\n+        assertSame(Chronology.getCopticUTC().millisOfSecond(), fields[3]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        assertEquals(10, test.getValue(0));\n+        assertEquals(20, test.getValue(1));\n+        assertEquals(30, test.getValue(2));\n+        assertEquals(40, test.getValue(3));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(5);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        int[] values = test.getValues();\n+        assertEquals(10, values[0]);\n+        assertEquals(20, values[1]);\n+        assertEquals(30, values[2]);\n+        assertEquals(40, values[3]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported() {\n+        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);\n+        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        TimeOfDay test3 = new TimeOfDay(15, 20, 30, 40);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartial {\n+        public Chronology getChronology() {\n+            return Chronology.getCopticUTC();\n+        }\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                Chronology.getCopticUTC().hourOfDay(),\n+                Chronology.getCopticUTC().minuteOfHour(),\n+                Chronology.getCopticUTC().secondOfMinute(),\n+                Chronology.getCopticUTC().millisOfSecond(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {10, 20, 30, 40};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithChronologyRetainFields_Chrono() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        TimeOfDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n+        check(base, 10, 20, 30, 40);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 10, 20, 30, 40);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_sameChrono() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        TimeOfDay test = base.withChronologyRetainFields(COPTIC_TOKYO);\n+        assertSame(base, test);\n+    }\n+\n+    public void testWithChronologyRetainFields_nullChrono() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        TimeOfDay test = base.withChronologyRetainFields(null);\n+        check(base, 10, 20, 30, 40);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 10, 20, 30, 40);\n+        assertEquals(ISO_UTC, test.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime();\n+        check(base, 10, 20, 30, 40);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.hourOfDay().setCopy(10);\n+        expected = expected.minuteOfHour().setCopy(20);\n+        expected = expected.secondOfMinute().setCopy(30);\n+        expected = expected.millisOfSecond().setCopy(40);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_Zone() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime(TOKYO);\n+        check(base, 10, 20, 30, 40);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n+        expected = expected.hourOfDay().setCopy(10);\n+        expected = expected.minuteOfHour().setCopy(20);\n+        expected = expected.secondOfMinute().setCopy(30);\n+        expected = expected.millisOfSecond().setCopy(40);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullZone() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((DateTimeZone) null);\n+        check(base, 10, 20, 30, 40);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.hourOfDay().setCopy(10);\n+        expected = expected.minuteOfHour().setCopy(20);\n+        expected = expected.secondOfMinute().setCopy(30);\n+        expected = expected.millisOfSecond().setCopy(40);\n+        assertEquals(expected, test);\n+    }\n+\n+    // Removed as too complex\n+//    /**\n+//     * Merges two partial together, taking account of the different chronologies.\n+//     *\n+//     * @param main  the main partial\n+//     * @param base  the partial to use as a base to merge on top of\n+//     * @param instant  the instant to start from and to use for missing fields\n+//     * @return the merged instant\n+//     */\n+//    public long merge(ReadablePartial main, ReadablePartial base, long instant) {\n+//        DateTimeZone zone = main.getChronology().getZone();\n+//        instant = base.getChronology().withZone(zone).set(base, instant);\n+//        return set(main, instant);\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    /**\n+//     * Converts this object to a DateTime using a YearMonthDay to fill in the\n+//     * missing fields and using the default time zone.\n+//     * This instance is immutable and unaffected by this method call.\n+//     * <p>\n+//     * The resulting chronology is determined by the chronology of this\n+//     * TimeOfDay plus the time zone.\n+//     * <p>\n+//     * This method makes use of the chronology of the specified YearMonthDay\n+//     * in the calculation. This can be significant when mixing chronologies.\n+//     * If the YearMonthDay is in the same chronology as this instance the\n+//     * method will perform exactly as you might expect.\n+//     * <p>\n+//     * If the chronologies differ, then both this TimeOfDay and the YearMonthDay\n+//     * are converted to the destination chronology and then merged. As a result\n+//     * it may be the case that the year, monthOfYear and dayOfMonth fields on\n+//     * the result are different from the values returned by the methods on the\n+//     * YearMonthDay.\n+//     * <p>\n+//     * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that\n+//     * ignores the chronology.\n+//     *\n+//     * @param date  the date to use, null means today\n+//     * @return the DateTime instance\n+//     */\n+//    public DateTime toDateTime(YearMonthDay date) {\n+//        return toDateTime(date, null);\n+//    }\n+//\n+//    /**\n+//     * Converts this object to a DateTime using a YearMonthDay to fill in the\n+//     * missing fields.\n+//     * This instance is immutable and unaffected by this method call.\n+//     * <p>\n+//     * The resulting chronology is determined by the chronology of this\n+//     * TimeOfDay plus the time zone.\n+//     * <p>\n+//     * This method makes use of the chronology of the specified YearMonthDay\n+//     * in the calculation. This can be significant when mixing chronologies.\n+//     * If the YearMonthDay is in the same chronology as this instance the\n+//     * method will perform exactly as you might expect.\n+//     * <p>\n+//     * If the chronologies differ, then both this TimeOfDay and the YearMonthDay\n+//     * are converted to the destination chronology and then merged. As a result\n+//     * it may be the case that the year, monthOfYear and dayOfMonth fields on\n+//     * the result are different from the values returned by the methods on the\n+//     * YearMonthDay.\n+//     * <p>\n+//     * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that\n+//     * ignores the chronology and just assigns the fields.\n+//     *\n+//     * @param date  the date to use, null means today\n+//     * @param zone  the zone to get the DateTime in, null means default\n+//     * @return the DateTime instance\n+//     */\n+//    public DateTime toDateTime(YearMonthDay date, DateTimeZone zone) {\n+//        Chronology chrono = getChronology().withZone(zone);\n+//        if (date == null) {\n+//            DateTime dt = new DateTime(chrono);\n+//            return dt.withFields(this);\n+//        } else {\n+//            long millis = chrono.merge(this, date, DateTimeUtils.currentTimeMillis());\n+//            return new DateTime(millis, chrono);\n+//        }\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    public void testToDateTime_YMD() {\n+//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_TOKYO);\n+//        \n+//        DateTime test = base.toDateTime(ymd);\n+//        check(base, 10, 20, 30, 40);\n+//        DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON);\n+//        expected = expected.hourOfDay().setCopy(10);\n+//        expected = expected.minuteOfHour().setCopy(20);\n+//        expected = expected.secondOfMinute().setCopy(30);\n+//        expected = expected.millisOfSecond().setCopy(40);\n+//        assertEquals(expected, test);\n+//    }\n+//\n+//    public void testToDateTime_nullYMD() {\n+//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+//        \n+//        DateTime test = base.toDateTime((YearMonthDay) null);\n+//        check(base, 10, 20, 30, 40);\n+//        DateTime expected = new DateTime(COPTIC_LONDON);\n+//        expected = expected.hourOfDay().setCopy(10);\n+//        expected = expected.minuteOfHour().setCopy(20);\n+//        expected = expected.secondOfMinute().setCopy(30);\n+//        expected = expected.millisOfSecond().setCopy(40);\n+//        assertEquals(expected, test);\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    public void testToDateTime_YMD_Zone() {\n+//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON);\n+//        \n+//        DateTime test = base.toDateTime(ymd, TOKYO);\n+//        check(base, 10, 20, 30, 40);\n+//        DateTime expected = new DateTime(ymd.toDateMidnight(TOKYO), COPTIC_TOKYO);\n+//        expected = expected.hourOfDay().setCopy(10);\n+//        expected = expected.minuteOfHour().setCopy(20);\n+//        expected = expected.secondOfMinute().setCopy(30);\n+//        expected = expected.millisOfSecond().setCopy(40);\n+//        assertEquals(expected, test);\n+//    }\n+//\n+//    public void testToDateTime_YMD_nullZone() {\n+//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON);\n+//        \n+//        DateTime test = base.toDateTime(ymd, null);\n+//        check(base, 10, 20, 30, 40);\n+//        DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON);\n+//        expected = expected.hourOfDay().setCopy(10);\n+//        expected = expected.minuteOfHour().setCopy(20);\n+//        expected = expected.secondOfMinute().setCopy(30);\n+//        expected = expected.millisOfSecond().setCopy(40);\n+//        assertEquals(expected, test);\n+//    }\n+//\n+//    public void testToDateTime_nullYMD_Zone() {\n+//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n+//        \n+//        DateTime test = base.toDateTime((YearMonthDay) null, TOKYO);\n+//        check(base, 10, 20, 30, 40);\n+//        DateTime expected = new DateTime(COPTIC_TOKYO);\n+//        expected = expected.hourOfDay().setCopy(10);\n+//        expected = expected.minuteOfHour().setCopy(20);\n+//        expected = expected.secondOfMinute().setCopy(30);\n+//        expected = expected.millisOfSecond().setCopy(40);\n+//        assertEquals(expected, test);\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        DateTime dt = new DateTime(0L); // LONDON zone\n+        assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 10, 20, 30, 40);\n+        assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040+01:00\", test.toString());\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        TimeOfDay base = new TimeOfDay(1, 2, 3, 4);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 1, 2, 3, 4);\n+        assertEquals(\"1970-01-02T01:02:03.004+01:00\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay()));\n+        assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n+        try {\n+            test.property(DateTimeFieldType.millisOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        TimeOfDay result = (TimeOfDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(\"T10:20:30.040\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {\n+        assertEquals(hour, test.getHourOfDay());\n+        assertEquals(min, test.getMinuteOfHour());\n+        assertEquals(sec, test.getSecondOfMinute());\n+        assertEquals(milli, test.getMillisOfSecond());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay_Constructors extends TestCase {\n+\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final int OFFSET = 1;\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay_Constructors.class);\n+    }\n+\n+    public TestTimeOfDay_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstantMidnight() throws Throwable {\n+        TimeOfDay test = TimeOfDay.MIDNIGHT;\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(0, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Chronology) null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(5 + OFFSET, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(5 + OFFSET, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0));\n+            assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+            assertEquals(0 + OFFSET, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10 + OFFSET, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+            assertEquals(0 + OFFSET, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int)\n+     */\n+    public void testConstructor_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int)\n+     */\n+    public void testConstructor_int_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);\n+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Properties.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay_Properties extends TestCase {\n+\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay_Properties.class);\n+    }\n+\n+    public TestTimeOfDay_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n+        assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n+        assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n+        assertSame(test, test.hourOfDay().getReadablePartial());\n+        assertSame(test, test.hourOfDay().getTimeOfDay());\n+        assertEquals(10, test.hourOfDay().get());\n+        assertEquals(\"10\", test.hourOfDay().getAsText());\n+        assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText());\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n+        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n+        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n+        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.hourOfDay().getMinimumValue());\n+        assertEquals(0, test.hourOfDay().getMinimumValueOverall());\n+        assertEquals(23, test.hourOfDay().getMaximumValue());\n+        assertEquals(23, test.hourOfDay().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(13);\n+        check(copy, 23, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().addToCopy(14);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addToCopy(-10);\n+        check(copy, 0, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().addToCopy(-11);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(18);\n+        check(copy, 4, 20, 30, 40);\n+        \n+        copy = test.hourOfDay().addWrapFieldToCopy(-15);\n+        check(copy, 19, 20, 30, 40);\n+    }\n+\n+    public void testPropertySetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+        \n+        try {\n+            test.hourOfDay().setCopy(24);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.hourOfDay().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.hourOfDay().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToHour() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n+        assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n+        assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n+        assertSame(test, test.minuteOfHour().getReadablePartial());\n+        assertSame(test, test.minuteOfHour().getTimeOfDay());\n+        assertEquals(20, test.minuteOfHour().get());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n+        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n+        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n+        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.minuteOfHour().getMinimumValue());\n+        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());\n+        assertEquals(59, test.minuteOfHour().getMaximumValue());\n+        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(39);\n+        check(copy, 10, 59, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(40);\n+        check(copy, 11, 0, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(1 * 60 + 45);\n+        check(copy, 12, 5, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(13 * 60 + 39);\n+        check(copy, 23, 59, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().addToCopy(13 * 60 + 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-9);\n+        check(copy, 10, 11, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-19);\n+        check(copy, 10, 1, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-20);\n+        check(copy, 10, 0, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-21);\n+        check(copy, 9, 59, 30, 40);\n+        \n+        copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));\n+        check(copy, 0, 0, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().addToCopy(-(10 * 60 + 21));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.minuteOfHour().addWrapFieldToCopy(49);\n+        check(copy, 10, 9, 30, 40);\n+        \n+        copy = test.minuteOfHour().addWrapFieldToCopy(-47);\n+        check(copy, 10, 33, 30, 40);\n+    }\n+\n+    public void testPropertySetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+        \n+        try {\n+            test.minuteOfHour().setCopy(60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.minuteOfHour().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.minuteOfHour().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToMinute() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n+        assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n+        assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n+        assertSame(test, test.secondOfMinute().getReadablePartial());\n+        assertSame(test, test.secondOfMinute().getTimeOfDay());\n+        assertEquals(30, test.secondOfMinute().get());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n+        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n+        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n+        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.secondOfMinute().getMinimumValue());\n+        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());\n+        assertEquals(59, test.secondOfMinute().getMaximumValue());\n+        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 39, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(29);\n+        check(copy, 10, 20, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(30);\n+        check(copy, 10, 21, 0, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(39 * 60 + 29);\n+        check(copy, 10, 59, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(39 * 60 + 30);\n+        check(copy, 11, 0, 0, 40);\n+        \n+        try {\n+            test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-9);\n+        check(copy, 10, 20, 21, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-30);\n+        check(copy, 10, 20, 0, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-31);\n+        check(copy, 10, 19, 59, 40);\n+        \n+        copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));\n+        check(copy, 0, 0, 0, 40);\n+        \n+        try {\n+            test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 39, 40);\n+        \n+        copy = test.secondOfMinute().addWrapFieldToCopy(49);\n+        check(copy, 10, 20, 19, 40);\n+        \n+        copy = test.secondOfMinute().addWrapFieldToCopy(-47);\n+        check(copy, 10, 20, 43, 40);\n+    }\n+\n+    public void testPropertySetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 12, 40);\n+        \n+        try {\n+            test.secondOfMinute().setCopy(60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.secondOfMinute().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.secondOfMinute().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 12, 40);\n+    }\n+\n+    public void testPropertyCompareToSecond() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n+        assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n+        assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n+        assertSame(test, test.millisOfSecond().getReadablePartial());\n+        assertSame(test, test.millisOfSecond().getTimeOfDay());\n+        assertEquals(40, test.millisOfSecond().get());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n+        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n+        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n+        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.millisOfSecond().getMinimumValue());\n+        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());\n+        assertEquals(999, test.millisOfSecond().getMaximumValue());\n+        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 49);\n+        \n+        copy = test.millisOfSecond().addToCopy(959);\n+        check(copy, 10, 20, 30, 999);\n+        \n+        copy = test.millisOfSecond().addToCopy(960);\n+        check(copy, 10, 20, 31, 0);\n+        \n+        copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);\n+        check(copy, 23, 59, 59, 999);\n+        \n+        try {\n+            test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.millisOfSecond().addToCopy(-9);\n+        check(copy, 10, 20, 30, 31);\n+        \n+        copy = test.millisOfSecond().addToCopy(-40);\n+        check(copy, 10, 20, 30, 0);\n+        \n+        copy = test.millisOfSecond().addToCopy(-41);\n+        check(copy, 10, 20, 29, 999);\n+        \n+        copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));\n+        check(copy, 0, 0, 0, 0);\n+        \n+        try {\n+            test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 49);\n+        \n+        copy = test.millisOfSecond().addWrapFieldToCopy(995);\n+        check(copy, 10, 20, 30, 35);\n+        \n+        copy = test.millisOfSecond().addWrapFieldToCopy(-47);\n+        check(copy, 10, 20, 30, 993);\n+    }\n+\n+    public void testPropertySetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 12);\n+        \n+        try {\n+            test.millisOfSecond().setCopy(1000);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.millisOfSecond().setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay copy = test.millisOfSecond().setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 20, 30, 12);\n+    }\n+\n+    public void testPropertyCompareToMilli() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {\n+        assertEquals(hour, test.getHourOfDay());\n+        assertEquals(min, test.getMinuteOfHour());\n+        assertEquals(sec, test.getSecondOfMinute());\n+        assertEquals(milli, test.getMillisOfSecond());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for YearMonthDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonthDay_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+    private static final int OFFSET = 1;\n+    private static final Chronology COPTIC_PARIS = Chronology.getCoptic(PARIS);\n+    private static final Chronology COPTIC_LONDON = Chronology.getCoptic(LONDON);\n+    private static final Chronology COPTIC_TOKYO = Chronology.getCoptic(TOKYO);\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology ISO_PARIS = Chronology.getISO(PARIS);\n+    private static final Chronology ISO_LONDON = Chronology.getISO(LONDON);\n+    private static final Chronology ISO_TOKYO = Chronology.getISO(TOKYO);\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology BUDDHIST_PARIS = Chronology.getBuddhist(PARIS);\n+    private static final Chronology BUDDHIST_LONDON = Chronology.getBuddhist(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = Chronology.getBuddhist(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonthDay_Basics.class);\n+    }\n+\n+    public TestYearMonthDay_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(1970, test.get(DateTimeFieldType.year()));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);\n+        assertSame(DateTimeFieldType.year(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));\n+        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertSame(DateTimeFieldType.year(), fields[0]);\n+        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);\n+        assertSame(DateTimeFieldType.dayOfMonth(), fields[2]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField() {\n+        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);\n+        assertSame(COPTIC_UTC.year(), test.getField(0));\n+        assertSame(COPTIC_UTC.monthOfYear(), test.getField(1));\n+        assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(COPTIC_UTC.year(), fields[0]);\n+        assertSame(COPTIC_UTC.monthOfYear(), fields[1]);\n+        assertSame(COPTIC_UTC.dayOfMonth(), fields[2]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue() {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(1970, test.getValue(0));\n+        assertEquals(6, test.getValue(1));\n+        assertEquals(9, test.getValue(2));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(3);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        YearMonthDay test = new YearMonthDay();\n+        int[] values = test.getValues();\n+        assertEquals(1970, values[0]);\n+        assertEquals(6, values[1]);\n+        assertEquals(9, values[2]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported() {\n+        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        YearMonthDay test1 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS);\n+        YearMonthDay test2 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        YearMonthDay test3 = new YearMonthDay(1971, 6, 9);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartial {\n+        public Chronology getChronology() {\n+            return COPTIC_UTC;\n+        }\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                COPTIC_UTC.year(),\n+                COPTIC_UTC.monthOfYear(),\n+                COPTIC_UTC.dayOfMonth(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {1970, 6, 9};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithChronologyRetainFields_Chrono() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        YearMonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n+        check(base, 2005, 6, 9);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 2005, 6, 9);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_sameChrono() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        YearMonthDay test = base.withChronologyRetainFields(COPTIC_TOKYO);\n+        assertSame(base, test);\n+    }\n+\n+    public void testWithChronologyRetainFields_nullChrono() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        YearMonthDay test = base.withChronologyRetainFields(null);\n+        check(base, 2005, 6, 9);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 2005, 6, 9);\n+        assertEquals(ISO_UTC, test.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime();\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_Zone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime(TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullZone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_TOD() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);\n+        \n+        DateTime test = base.toDateTime(tod);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullTOD() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_LONDON).getMillis();\n+        DateTimeUtils.setCurrentMillisFixed(now);\n+        \n+        DateTime test = base.toDateTime((TimeOfDay) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_TOD_Zone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);\n+        \n+        DateTime test = base.toDateTime(tod, TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_TOD_nullZone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);\n+        \n+        DateTime test = base.toDateTime(tod, null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullTOD_Zone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n+        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_TOKYO).getMillis();\n+        DateTimeUtils.setCurrentMillisFixed(now);\n+        \n+        DateTime test = base.toDateTime((TimeOfDay) null, TOKYO);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateMidnight() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnight();\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateMidnight_Zone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnight(TOKYO);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);\n+    }\n+\n+    public void testToDateMidnight_nullZone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateMidnight test = base.toDateMidnight((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 2005, 6, 9);\n+        DateTime expected = dt;\n+        expected = expected.year().setCopy(2005);\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(9);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        YearMonthDay test = new YearMonthDay(2005, 6, 9);\n+        assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n+        assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n+        assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n+        try {\n+            test.property(DateTimeFieldType.millisOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9, COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        YearMonthDay result = (YearMonthDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(\"1972-06-09\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(YearMonthDay test, int hour, int min, int sec) {\n+        assertEquals(hour, test.getYear());\n+        assertEquals(min, test.getMonthOfYear());\n+        assertEquals(sec, test.getDayOfMonth());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for YearMonthDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonthDay_Constructors extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    private static final Chronology GREGORIAN_UTC = Chronology.getGregorianUTC();\n+    private static final Chronology GREGORIAN_PARIS = Chronology.getGregorian(PARIS);\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonthDay_Constructors.class);\n+    }\n+\n+    public TestYearMonthDay_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        YearMonthDay test = new YearMonthDay();\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Chronology) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME2);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME2, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1971, test.getYear());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            YearMonthDay test = new YearMonthDay(new Integer(0));\n+            assertEquals(ISO_UTC, test.getChronology());\n+            assertEquals(1970, test.getYear());\n+            assertEquals(1, test.getMonthOfYear());\n+            assertEquals(1, test.getDayOfMonth());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Object) null, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        YearMonthDay test = new YearMonthDay(date, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay((Object) null, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            YearMonthDay test = new YearMonthDay(new Integer(0), GREGORIAN_PARIS);\n+            assertEquals(ISO_UTC, test.getChronology());\n+            assertEquals(1970, test.getYear());\n+            assertEquals(1, test.getMonthOfYear());\n+            assertEquals(1, test.getDayOfMonth());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new YearMonthDay(Integer.MIN_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(Integer.MAX_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 0, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 13, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 31);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new YearMonthDay(1970, 7, 31);\n+        try {\n+            new YearMonthDay(1970, 7, 32);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 0, 9, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 13, 9, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 0, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new YearMonthDay(1970, 6, 31, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new YearMonthDay(1970, 7, 31, GREGORIAN_PARIS);\n+        try {\n+            new YearMonthDay(1970, 7, 32, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for YearMonthDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYearMonthDay_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYearMonthDay_Properties.class);\n+    }\n+\n+    public TestYearMonthDay_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().year(), test.year().getField());\n+        assertEquals(\"year\", test.year().getName());\n+        assertEquals(\"Property[year]\", test.year().toString());\n+        assertSame(test, test.year().getReadablePartial());\n+        assertSame(test, test.year().getYearMonthDay());\n+        assertEquals(1972, test.year().get());\n+        assertEquals(\"1972\", test.year().getAsText());\n+        assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n+        assertEquals(\"1972\", test.year().getAsShortText());\n+        assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().years(), test.year().getDurationField());\n+        assertEquals(null, test.year().getRangeDurationField());\n+        assertEquals(9, test.year().getMaximumTextLength(null));\n+        assertEquals(9, test.year().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(-292275054, test.year().getMinimumValue());\n+        assertEquals(-292275054, test.year().getMinimumValueOverall());\n+        assertEquals(292277023, test.year().getMaximumValue());\n+        assertEquals(292277023, test.year().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().addToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1981, 6, 9);\n+        \n+        copy = test.year().addToCopy(0);\n+        check(copy, 1972, 6, 9);\n+        \n+        copy = test.year().addToCopy(292277023 - 1972);\n+        check(copy, 292277023, 6, 9);\n+        \n+        try {\n+            test.year().addToCopy(292277023 - 1972 + 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6, 9);\n+        \n+        copy = test.year().addToCopy(-1972);\n+        check(copy, 0, 6, 9);\n+        \n+        copy = test.year().addToCopy(-1973);\n+        check(copy, -1, 6, 9);\n+        \n+        try {\n+            test.year().addToCopy(-292275054 - 1972 - 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 1972, 6, 9);\n+    }\n+\n+    public void testPropertyAddWrapFieldYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().addWrapFieldToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1981, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(0);\n+        check(copy, 1972, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);\n+        check(copy, -292275054, 6, 9);\n+        \n+        copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);\n+        check(copy, 292277023, 6, 9);\n+    }\n+\n+    public void testPropertySetYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 12, 6, 9);\n+    }\n+\n+    public void testPropertySetTextYear() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.year().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 12, 6, 9);\n+    }\n+\n+    public void testPropertyCompareToYear() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(test2) < 0);\n+        assertEquals(true, test2.year().compareTo(test1) > 0);\n+        assertEquals(true, test1.year().compareTo(test1) == 0);\n+        try {\n+            test1.year().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(dt2) < 0);\n+        assertEquals(true, test2.year().compareTo(dt1) > 0);\n+        assertEquals(true, test1.year().compareTo(dt1) == 0);\n+        try {\n+            test1.year().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n+        assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n+        assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n+        assertSame(test, test.monthOfYear().getReadablePartial());\n+        assertSame(test, test.monthOfYear().getYearMonthDay());\n+        assertEquals(6, test.monthOfYear().get());\n+        assertEquals(\"June\", test.monthOfYear().getAsText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n+        assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n+        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n+        test = new YearMonthDay(1972, 7, 9);\n+        assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(1, test.monthOfYear().getMinimumValue());\n+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n+        assertEquals(12, test.monthOfYear().getMaximumValue());\n+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().addToCopy(6);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(7);\n+        check(copy, 1973, 1, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(-5);\n+        check(copy, 1972, 1, 9);\n+        \n+        copy = test.monthOfYear().addToCopy(-6);\n+        check(copy, 1971, 12, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().addToCopy(1);\n+        check(copy, 1972, 2, 29);\n+        \n+        copy = test.monthOfYear().addToCopy(2);\n+        check(copy, 1972, 3, 31);\n+        \n+        copy = test.monthOfYear().addToCopy(3);\n+        check(copy, 1972, 4, 30);\n+        \n+        test = new YearMonthDay(1971, 1, 31);\n+        copy = test.monthOfYear().addToCopy(1);\n+        check(copy, 1971, 2, 28);\n+    }\n+\n+    public void testPropertyAddWrapFieldMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 10, 9);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(8);\n+        check(copy, 1972, 2, 9);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(-8);\n+        check(copy, 1972, 10, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().addWrapFieldToCopy(1);\n+        check(copy, 1972, 2, 29);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(2);\n+        check(copy, 1972, 3, 31);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(3);\n+        check(copy, 1972, 4, 30);\n+        \n+        test = new YearMonthDay(1971, 1, 31);\n+        copy = test.monthOfYear().addWrapFieldToCopy(1);\n+        check(copy, 1971, 2, 28);\n+    }\n+\n+    public void testPropertySetMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        test = new YearMonthDay(1972, 1, 31);\n+        copy = test.monthOfYear().setCopy(2);\n+        check(copy, 1972, 2, 29);\n+        \n+        try {\n+            test.monthOfYear().setCopy(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.monthOfYear().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMonth() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.monthOfYear().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().setCopy(\"December\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+        \n+        copy = test.monthOfYear().setCopy(\"Dec\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 12, 9);\n+    }\n+\n+    public void testPropertyCompareToMonth() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n+        assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n+        assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n+        assertSame(test, test.dayOfMonth().getReadablePartial());\n+        assertSame(test, test.dayOfMonth().getYearMonthDay());\n+        assertEquals(9, test.dayOfMonth().get());\n+        assertEquals(\"9\", test.dayOfMonth().getAsText());\n+        assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n+        assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n+        assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n+        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n+        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n+        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        assertEquals(1, test.dayOfMonth().getMinimumValue());\n+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n+        assertEquals(30, test.dayOfMonth().getMaximumValue());\n+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n+        test = new YearMonthDay(1972, 7, 9);\n+        assertEquals(31, test.dayOfMonth().getMaximumValue());\n+        test = new YearMonthDay(1972, 2, 9);\n+        assertEquals(29, test.dayOfMonth().getMaximumValue());\n+        test = new YearMonthDay(1971, 2, 9);\n+        assertEquals(28, test.dayOfMonth().getMaximumValue());\n+    }\n+\n+    public void testPropertyAddDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().addToCopy(9);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 18);\n+        \n+        copy = test.dayOfMonth().addToCopy(21);\n+        check(copy, 1972, 6, 30);\n+        \n+        copy = test.dayOfMonth().addToCopy(22);\n+        check(copy, 1972, 7, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 30);\n+        check(copy, 1972, 7, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 31);\n+        check(copy, 1972, 8, 1);\n+\n+        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);\n+        check(copy, 1972, 12, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);\n+        check(copy, 1973, 1, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-8);\n+        check(copy, 1972, 6, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-9);\n+        check(copy, 1972, 5, 31);\n+        \n+        copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);\n+        check(copy, 1972, 1, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);\n+        check(copy, 1971, 12, 31);\n+    }\n+\n+    public void testPropertyAddWrapFieldDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 30);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(22);\n+        check(copy, 1972, 6, 1);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);\n+        check(copy, 1972, 6, 27);\n+        \n+        test = new YearMonthDay(1972, 7, 9);\n+        copy = test.dayOfMonth().addWrapFieldToCopy(21);\n+        check(copy, 1972, 7, 30);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(22);\n+        check(copy, 1972, 7, 31);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(23);\n+        check(copy, 1972, 7, 1);\n+    \n+        copy = test.dayOfMonth().addWrapFieldToCopy(-12);\n+        check(copy, 1972, 7, 28);\n+    }\n+\n+    public void testPropertySetDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().setCopy(12);\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 12);\n+        \n+        try {\n+            test.dayOfMonth().setCopy(31);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.dayOfMonth().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextDay() {\n+        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n+        YearMonthDay copy = test.dayOfMonth().setCopy(\"12\");\n+        check(test, 1972, 6, 9);\n+        check(copy, 1972, 6, 12);\n+    }\n+\n+    public void testPropertyCompareToDay() {\n+        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);\n+        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(YearMonthDay test, int hour, int min, int sec) {\n+        assertEquals(hour, test.getYear());\n+        assertEquals(min, test.getMonthOfYear());\n+        assertEquals(sec, test.getDayOfMonth());\n+    }\n+}", "timestamp": 1094916139, "metainfo": ""}