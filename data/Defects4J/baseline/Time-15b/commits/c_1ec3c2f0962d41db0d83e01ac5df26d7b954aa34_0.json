{"sha": "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34", "log": "Support parsing of date-time zone names like BST or British Summer Time  Fix code to avoid source and binary incompatibility", "commit": "\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffset() != null) {\n-            int parsedOffset = bucket.getOffset();\n+        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n+            int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n             chrono = chrono.withZone(parsedZone);\n         } else if (bucket.getZone() != null) {\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (bucket.getOffset() != null) {  // treat withOffsetParsed() as being true\n-                    int parsedOffset = bucket.getOffset();\n+                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n+                    int parsedOffset = bucket.getOffsetInteger();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n                 } else if (bucket.getZone() != null) {\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getOffset() != null) {\n-                    int parsedOffset = bucket.getOffset();\n+                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n+                    int parsedOffset = bucket.getOffsetInteger();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n                 } else if (bucket.getZone() != null) {\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getOffset() != null) {\n-                    int parsedOffset = bucket.getOffset();\n+                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n+                    int parsedOffset = bucket.getOffsetInteger();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n                 } else if (bucket.getZone() != null) {\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n                             break zeroOffset;\n                         }\n                     }\n-                    bucket.setOffset(0);\n+                    bucket.setOffset(Integer.valueOf(0));\n                     return position;\n                 }\n                 if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n-                    bucket.setOffset(0);\n+                    bucket.setOffset(Integer.valueOf(0));\n                     return position + iZeroOffsetParseText.length();\n                 }\n             }\n                 }\n             }\n \n-            bucket.setOffset(negative ? -offset : offset);\n+            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n             return position;\n         }\n \n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n     private final Chronology iChrono;\n     private final long iMillis;\n     \n-    // TimeZone to switch to in computeMillis. If null, use offset.\n+    /** The parsed zone, initialised to formatter zone. */\n     private DateTimeZone iZone;\n+    /** The parsed offset. */\n     private Integer iOffset;\n     /** The locale to use for parsing. */\n     private Locale iLocale;\n \n     /**\n      * Set a time zone to be used when computeMillis is called.\n-     *\n-     * @param zone the date time zone to operate in, not null\n      */\n     public void setZone(DateTimeZone zone) {\n         iSavedState = null;\n     //-----------------------------------------------------------------------\n     /**\n      * Returns the time zone offset in milliseconds used by computeMillis.\n-     */\n-    public Integer getOffset() {\n+     * @deprecated use Integer version\n+     */\n+    @Deprecated\n+    public int getOffset() {\n+        return (iOffset != null ? iOffset : 0);\n+    }\n+\n+    /**\n+     * Returns the time zone offset in milliseconds used by computeMillis.\n+     */\n+    public Integer getOffsetInteger() {\n         return iOffset;\n+    }\n+\n+    /**\n+     * Set a time zone offset to be used when computeMillis is called.\n+     * @deprecated use Integer version\n+     */\n+    @Deprecated\n+    public void setOffset(int offset) {\n+        iSavedState = null;\n+        iOffset = offset;\n     }\n \n     /**", "timestamp": 1312107075, "metainfo": ""}