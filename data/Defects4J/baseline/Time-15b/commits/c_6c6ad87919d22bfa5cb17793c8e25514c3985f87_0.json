{"sha": "6c6ad87919d22bfa5cb17793c8e25514c3985f87", "log": "Add MonthDay, from Chris Pheby  ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MonthDay.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * MonthDay is an immutable partial supporting the monthOfYear and dayOfMonth fields.\n+ * <p>\n+ * NOTE: This class only supports the two fields listed above.\n+ * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n+ * <p>\n+ * Calculations on MonthDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * One use case for this class is to store a birthday without the year (to avoid\n+ * storing the age of the person).\n+ * This class can be used as the gMonthDay type in XML Schema.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * MonthDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Chris Pheby\n+ * @since 2.0\n+ */\n+public final class MonthDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2954560699050434609L;\n+\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.monthOfYear(),\n+        DateTimeFieldType.dayOfMonth(), };\n+\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 0;\n+    /** The index of the day field in the field array */\n+    public static final int DAY_OF_MONTH = 1;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MonthDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the MonthDay.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a MonthDay with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created MonthDay, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n+     */\n+    public static MonthDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the MonthDay.\n+     * <p>\n+     * This factory method always creates a MonthDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created MonthDay, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static MonthDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new MonthDay(date.getMonth() + 1, date.getDate());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MonthDay with the current monthOfYear, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     */\n+    public MonthDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with the current month-day, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current month-day.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     */\n+    public MonthDay(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with the current month-day, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MonthDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from an Object that represents some form of time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MonthDay(Object instant) {\n+        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from an Object that represents some form of time,\n+     * using the specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MonthDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with specified year and month\n+     * using <code>ISOChronology</code>.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public MonthDay(int monthOfYear, int dayOfMonth) {\n+        this(monthOfYear, dayOfMonth, null);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified monthOfYear and dayOfMonth\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(new int[] {monthOfYear, dayOfMonth}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    MonthDay(MonthDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    MonthDay(MonthDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is two.\n+     * The supported fields are MonthOfYear and DayOfMonth.\n+     * Note that only these fields may be queried.\n+     *\n+     * @return the field count, two\n+     */\n+    public int size() {\n+        return 2;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field, never null\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+        case MONTH_OF_YEAR:\n+            return chrono.monthOfYear();\n+        case DAY_OF_MONTH:\n+            return chrono.dayOfMonth();\n+        default:\n+            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index, never null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Month, Day.\n+     *\n+     * @return the array of field types (cloned), largest to smallest, never null\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as MonthDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this month-day with a different chronology, never null\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public MonthDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            MonthDay newMonthDay = new MonthDay(this, newChronology);\n+            newChronology.validate(newMonthDay, getValues());\n+            return newMonthDay;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * MonthDay updated = md.dayOfMonth().setCopy(6);\n+     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public MonthDay withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n+     * MonthDay added = md.plusDays(6);\n+     * MonthDay added = md.dayOfMonth().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusMonths(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new month-day exceeds the capacity\n+     */\n+    public MonthDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day plus the specified number of months.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from December to January.\n+     * The day will be adjusted to the last valid value if necessary.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay added = md.plusMonths(6);\n+     * MonthDay added = md.plus(Period.months(6));\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new month-day plus the increased months, never null\n+     */\n+    public MonthDay plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day plus the specified number of days.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from December to January.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay added = md.plusDays(6);\n+     * MonthDay added = md.plus(Period.days(6));\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new month-day plus the increased days, never null\n+     */\n+    public MonthDay plusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusMonths(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away, never null\n+     * @throws ArithmeticException if the new month-day exceeds the capacity\n+     */\n+    public MonthDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day minus the specified number of months.\n+     * <p>\n+     * This MonthDay instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from January to December.\n+     * The day will be adjusted to the last valid value if necessary.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay subtracted = md.minusMonths(6);\n+     * MonthDay subtracted = md.minus(Period.months(6));\n+     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new month-day minus the increased months, never null\n+     */\n+    public MonthDay minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day minus the specified number of months.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from January to December.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay subtracted = md.minusDays(6);\n+     * MonthDay subtracted = md.minus(Period.days(6));\n+     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new month-day minus the increased days, never null\n+     */\n+    public MonthDay minusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same month-day and chronology.\n+     *\n+     * @param year  the year to use, valid for chronology\n+     * @return a LocalDate with the same month-day and chronology, never null\n+     */\n+    public LocalDate toLocalDate(int year) {\n+        return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getValue(DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the month of year field updated.\n+     * <p>\n+     * MonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public MonthDay withMonthOfYear(int monthOfYear) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the day of month field updated.\n+     * <p>\n+     * MonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOMonth  the day of month to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public MonthDay withDayOfMonth(int dayOfMonth) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the month of year field property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field property which provides access to advanced functionality.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the month-day in ISO8601 format (--MM-dd).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        List<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>();\n+        fields.add(DateTimeFieldType.monthOfYear());\n+        fields.add(DateTimeFieldType.dayOfMonth());\n+        return ISODateTimeFormat.forFields(fields, true, true).print(this);\n+    }\n+\n+    /**\n+     * Output the month-day using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the month-day using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>MonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Chris Pheby\n+     * @since 2.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final MonthDay iBase;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(MonthDay partial, int fieldIndex) {\n+            super();\n+            iBase = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iBase.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public MonthDay getMonthDay() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iBase.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this MonthDay.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay addToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this MonthDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the MonthDay.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay setCopy(int value) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, value);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the MonthDay to a parsed text value.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public MonthDay setCopy(String text, Locale locale) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the MonthDay to a parsed text value.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public MonthDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestYearMonth_Constructors.suite());\n         suite.addTest(TestYearMonth_Properties.suite());\n         \n+        suite.addTest(TestMonthDay_Basics.suite());\n+        suite.addTest(TestMonthDay_Constructors.suite());\n+        suite.addTest(TestMonthDay_Properties.suite());\n+        \n         suite.addTest(TestPartial_Basics.suite());\n         suite.addTest(TestPartial_Constructors.suite());\n         suite.addTest(TestPartial_Properties.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestMonthDay_Basics.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Basics} \n+ */\n+public class TestMonthDay_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n+//    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);\n+    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);\n+    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();\n+//    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+//    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n+//    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+//    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);\n+//    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestMonthDay_Basics.class);\n+    }\n+\n+    public TestMonthDay_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        MonthDay test = new MonthDay();\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.year());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        MonthDay test = new MonthDay();\n+        assertEquals(2, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        MonthDay test = new MonthDay(COPTIC_PARIS);\n+        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(1));\n+\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        MonthDay test = new MonthDay(COPTIC_PARIS);\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertEquals(2, fields.length);\n+        assertSame(DateTimeFieldType.monthOfYear(), fields[0]);\n+        assertSame(DateTimeFieldType.dayOfMonth(), fields[1]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField() {\n+        MonthDay test = new MonthDay(COPTIC_PARIS);\n+        assertSame(COPTIC_UTC.monthOfYear(), test.getField(0));\n+        assertSame(COPTIC_UTC.dayOfMonth(), test.getField(1));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        MonthDay test = new MonthDay(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertEquals(2, fields.length);\n+        assertSame(COPTIC_UTC.monthOfYear(), fields[0]);\n+        assertSame(COPTIC_UTC.dayOfMonth(), fields[1]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue() {\n+        MonthDay test = new MonthDay();\n+        assertEquals(6, test.getValue(0));\n+        assertEquals(9, test.getValue(1));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        MonthDay test = new MonthDay();\n+        int[] values = test.getValues();\n+        assertEquals(2, values.length);\n+        assertEquals(6, values[0]);\n+        assertEquals(9, values[1]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported() {\n+        MonthDay test = new MonthDay(COPTIC_PARIS);\n+        assertEquals(false, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        MonthDay test1 = new MonthDay(10, 6, COPTIC_PARIS);\n+        MonthDay test2 = new MonthDay(10, 6, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        MonthDay test3 = new MonthDay(10, 6);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockMD()));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockMD extends MockPartial {\n+        \n+        @Override\n+        public Chronology getChronology() {\n+            return COPTIC_UTC;\n+        }\n+        \n+        @Override\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                COPTIC_UTC.monthOfYear(),\n+                COPTIC_UTC.dayOfMonth()\n+            };\n+        }\n+        \n+        @Override\n+        public int[] getValues() {\n+            return new int[] {10, 6};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        MonthDay test1 = new MonthDay(6, 6);\n+        MonthDay test1a = new MonthDay(6, 6);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        MonthDay test2 = new MonthDay(6, 7);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.monthOfYear(),\n+            DateTimeFieldType.dayOfMonth()\n+        };\n+        int[] values = new int[] {6, 6};\n+        Partial p = new Partial(types, values);\n+        assertEquals(0, test1.compareTo(p));\n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new LocalTime());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        Partial partial = new Partial()\n+            .with(DateTimeFieldType.centuryOfEra(), 1)\n+            .with(DateTimeFieldType.halfdayOfDay(), 0)\n+            .with(DateTimeFieldType.dayOfMonth(), 9);\n+        try {\n+            new MonthDay(10, 6).compareTo(partial);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_MD() {\n+        MonthDay test1 = new MonthDay(6, 6);\n+        MonthDay test1a = new MonthDay(6, 6);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        MonthDay test2 = new MonthDay(6, 7);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            new MonthDay(6, 7).isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_MD() {\n+        MonthDay test1 = new MonthDay(6, 6);\n+        MonthDay test1a = new MonthDay(6, 6);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        MonthDay test2 = new MonthDay(6, 7);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            new MonthDay(6, 7).isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_MD() {\n+        MonthDay test1 = new MonthDay(6, 6);\n+        MonthDay test1a = new MonthDay(6, 6);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        MonthDay test2 = new MonthDay(6, 7);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            new MonthDay(6, 7).isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testWithChronologyRetainFields_Chrono() {\n+        MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n+        MonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n+        check(base, 6, 6);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 6, 6);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_sameChrono() {\n+        MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n+        MonthDay test = base.withChronologyRetainFields(COPTIC_TOKYO);\n+        assertSame(base, test);\n+    }\n+\n+    public void testWithChronologyRetainFields_nullChrono() {\n+        MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n+        MonthDay test = base.withChronologyRetainFields(null);\n+        check(base, 6, 6);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 6, 6);\n+        assertEquals(ISO_UTC, test.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithField() {\n+        MonthDay test = new MonthDay(9, 6);\n+        MonthDay result = test.withField(DateTimeFieldType.monthOfYear(), 10);\n+        \n+        assertEquals(new MonthDay(9, 6), test);\n+        assertEquals(new MonthDay(10, 6), result);\n+    }\n+\n+    public void testWithField_nullField() {\n+        MonthDay test = new MonthDay(9, 6);\n+        try {\n+            test.withField(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_unknownField() {\n+        MonthDay test = new MonthDay(9, 6);\n+        try {\n+            test.withField(DateTimeFieldType.hourOfDay(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithField_same() {\n+        MonthDay test = new MonthDay(9, 6);\n+        MonthDay result = test.withField(DateTimeFieldType.monthOfYear(), 9);\n+        assertEquals(new MonthDay(9, 6), test);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldAdded() {\n+        MonthDay test = new MonthDay(9, 6);\n+        MonthDay result = test.withFieldAdded(DurationFieldType.months(), 1);\n+        \n+        assertEquals(new MonthDay(9, 6), test);\n+        assertEquals(new MonthDay(10, 6), result);\n+    }\n+\n+    public void testWithFieldAdded_nullField_zero() {\n+        MonthDay test = new MonthDay(9, 6);\n+        try {\n+            test.withFieldAdded(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_nullField_nonZero() {\n+        MonthDay test = new MonthDay(9, 6);\n+        try {\n+            test.withFieldAdded(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithFieldAdded_zero() {\n+        MonthDay test = new MonthDay(9, 6);\n+        MonthDay result = test.withFieldAdded(DurationFieldType.months(), 0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithFieldAdded_unknownField() {\n+        MonthDay test = new MonthDay(9, 6);\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_RP() {\n+        MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n+        MonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n+        MonthDay expected = new MonthDay(8, 9, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.plus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusMonths_int() {\n+        MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n+        MonthDay result = test.plusMonths(1);\n+        MonthDay expected = new MonthDay(7, 5, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testPlusMonths_int_same() {\n+        MonthDay test = new MonthDay(6, 5, ISO_UTC);\n+        MonthDay result = test.plusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlusMonths_int_wrap() {\n+        MonthDay test = new MonthDay(6, 5, ISO_UTC);\n+        MonthDay result = test.plusMonths(10);\n+        MonthDay expected = new MonthDay(4, 5, ISO_UTC);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testPlusMonths_int_adjust() {\n+        MonthDay test = new MonthDay(7, 31, ISO_UTC);\n+        MonthDay result = test.plusMonths(2);\n+        MonthDay expected = new MonthDay(9, 30, ISO_UTC);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testPlusDays_int() {\n+        MonthDay test = new MonthDay(5, 10, BuddhistChronology.getInstance());\n+        MonthDay result = test.plusDays(1);\n+        MonthDay expected = new MonthDay(5, 11, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testPlusDays_same() {\n+        MonthDay test = new MonthDay(5, 10, BuddhistChronology.getInstance());\n+        MonthDay result = test.plusDays(0);\n+        assertSame(test, result);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMinus_RP() {\n+        MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n+        MonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n+        MonthDay expected = new MonthDay(5, 4, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+        \n+        result = test.minus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusMonths_int() {\n+        MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n+        MonthDay result = test.minusMonths(1);\n+        MonthDay expected = new MonthDay(5, 5, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testMinusMonths_int_same() {\n+        MonthDay test = new MonthDay(6, 5, ISO_UTC);\n+        MonthDay result = test.minusMonths(0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinusMonths_int_wrap() {\n+        MonthDay test = new MonthDay(6, 5, ISO_UTC);\n+        MonthDay result = test.minusMonths(10);\n+        MonthDay expected = new MonthDay(8, 5, ISO_UTC);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testMinusMonths_int_adjust() {\n+        MonthDay test = new MonthDay(7, 31, ISO_UTC);\n+        MonthDay result = test.minusMonths(3);\n+        MonthDay expected = new MonthDay(4, 30, ISO_UTC);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testMinusDays_int() {\n+        MonthDay test = new MonthDay(5, 11, BuddhistChronology.getInstance());\n+        MonthDay result = test.minusDays(1);\n+        MonthDay expected = new MonthDay(5, 10, BuddhistChronology.getInstance());\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testMinusDays_same() {\n+        MonthDay test = new MonthDay(5, 11, BuddhistChronology.getInstance());\n+        MonthDay result = test.minusDays(0);\n+        assertSame(test, result);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToLocalDate() {\n+        MonthDay base = new MonthDay(6, 6, COPTIC_UTC);\n+        LocalDate test = base.toLocalDate(2009);\n+        assertEquals(new LocalDate(2009, 6, 6, COPTIC_UTC), test);\n+        try {\n+            base.toLocalDate(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 6, 6);\n+        DateTime expected = dt;\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(6);\n+        assertEquals(expected, test);\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        MonthDay base = new MonthDay(6, 6);\n+        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 6, 6);\n+        DateTime expected = dt;\n+        expected = expected.monthOfYear().setCopy(6);\n+        expected = expected.dayOfMonth().setCopy(6);\n+        assertEquals(expected, test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithers() {\n+        MonthDay test = new MonthDay(10, 6);\n+        check(test.withMonthOfYear(5), 5, 6);\n+        check(test.withDayOfMonth(2), 10, 2);\n+        try {\n+            test.withMonthOfYear(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.withMonthOfYear(13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        MonthDay test = new MonthDay(6, 6);\n+        assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n+        assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n+        try {\n+            test.property(DateTimeFieldType.millisOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        MonthDay test = new MonthDay(5, 6, COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        MonthDay result = (MonthDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        MonthDay test = new MonthDay(5, 6);\n+        assertEquals(\"--05-06\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        MonthDay test = new MonthDay(5, 6);\n+        assertEquals(\"05 \\ufffd\\ufffd\", test.toString(\"MM HH\"));\n+        assertEquals(\"--05-06\", test.toString((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        MonthDay test = new MonthDay(5, 6);\n+        assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"--05-06\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"--05-06\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_DTFormatter() {\n+        MonthDay test = new MonthDay(5, 6);\n+        assertEquals(\"05 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"MM HH\")));\n+        assertEquals(\"--05-06\", test.toString((DateTimeFormatter) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(MonthDay test, int month, int day) {\n+        assertEquals(month, test.getMonthOfYear());\n+        assertEquals(day, test.getDayOfMonth());\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestMonthDay_Constructors.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Constuctors} \n+ */\n+public class TestMonthDay_Constructors extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+    private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();\n+    private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);\n+    \n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestMonthDay_Constructors.class);\n+    }\n+\n+    public TestMonthDay_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromCalendarFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        MonthDay expected = new MonthDay(2, 3);\n+        assertEquals(expected, MonthDay.fromCalendarFields(cal));\n+        try {\n+            MonthDay.fromCalendarFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromDateFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        MonthDay expected = new MonthDay(2, 3);\n+        assertEquals(expected, MonthDay.fromDateFields(cal.getTime()));\n+        try {\n+            MonthDay.fromDateFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        MonthDay test = new MonthDay();\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone)\n+     */\n+    public void testConstructor_DateTimeZone() throws Throwable {\n+        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        // 23:59 in London is 00:59 the following day in Paris\n+        \n+        MonthDay test = new MonthDay(LONDON);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(30, test.getDayOfMonth());\n+        \n+        test = new MonthDay(PARIS);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(7, test.getMonthOfYear());\n+        assertEquals(1, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone=null)\n+     */\n+    public void testConstructor_nullDateTimeZone() throws Throwable {\n+        DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n+        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n+        // 23:59 in London is 00:59 the following day in Paris\n+        \n+        MonthDay test = new MonthDay((DateTimeZone) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(30, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        MonthDay test = new MonthDay(GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        MonthDay test = new MonthDay((Chronology) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        MonthDay test = new MonthDay(TEST_TIME1);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        MonthDay test = new MonthDay(TEST_TIME2);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        MonthDay test = new MonthDay(TEST_TIME1, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        MonthDay test = new MonthDay(TEST_TIME2, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(5, test.getMonthOfYear());\n+        assertEquals(7, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        MonthDay test = new MonthDay(TEST_TIME1, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        MonthDay test = new MonthDay(date);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_nullObject() throws Throwable {\n+        MonthDay test = new MonthDay((Object) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString1() throws Throwable {\n+        MonthDay test = new MonthDay(\"1972-12\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(12, test.getMonthOfYear());\n+        assertEquals(1, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString2() throws Throwable {\n+        MonthDay test = new MonthDay(\"1972-12-01T+14:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(11, test.getMonthOfYear());  // timezone\n+        assertEquals(30, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString3() throws Throwable {\n+        MonthDay test = new MonthDay(\"1972-12-03T10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(12, test.getMonthOfYear());\n+        assertEquals(3, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString4() throws Throwable {\n+        MonthDay test = new MonthDay(\"1972-12-01T10:20:30.040+14:00\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(11, test.getMonthOfYear());  // timezone\n+        assertEquals(30, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectString5() throws Throwable {\n+        MonthDay test = new MonthDay(\"10\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1, test.getMonthOfYear());\n+        assertEquals(1, test.getDayOfMonth());\n+    }\n+\n+    public void testConstructor_ObjectStringEx1() throws Throwable {\n+        try {\n+            new MonthDay(\"T10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx2() throws Throwable {\n+        try {\n+            new MonthDay(\"T10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx3() throws Throwable {\n+        try {\n+            new MonthDay(\"10:20:30.040\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConstructor_ObjectStringEx4() throws Throwable {\n+        try {\n+            new MonthDay(\"10:20:30.040+14:00\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        MonthDay test = new MonthDay(date, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        MonthDay test = new MonthDay((Object) null, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        MonthDay test = new MonthDay(date, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        MonthDay test = new MonthDay((Object) null, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int)\n+     */\n+    public void testConstructor_int_int() throws Throwable {\n+        MonthDay test = new MonthDay(6, 30);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(30, test.getDayOfMonth());\n+        try {\n+            new MonthDay(Integer.MIN_VALUE, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(Integer.MAX_VALUE, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(1970, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(1970, 13);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_Chronology() throws Throwable {\n+        MonthDay test = new MonthDay(6, 30, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(30, test.getDayOfMonth());\n+        try {\n+            new MonthDay(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(1970, 0, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MonthDay(1970, 13, GREGORIAN_PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_nullChronology() throws Throwable {\n+        MonthDay test = new MonthDay(6, 30, null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(30, test.getDayOfMonth());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestMonthDay_Properties.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n+\n+/**\n+ * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Propeties} \n+ */\n+public class TestMonthDay_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n+\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestMonthDay_Properties.class);\n+    }\n+\n+    public TestMonthDay_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMonthOfYear() {\n+        MonthDay test = new MonthDay(9, 6);\n+        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n+        assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n+        assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n+        assertSame(test, test.monthOfYear().getReadablePartial());\n+        assertSame(test, test.monthOfYear().getMonthDay());\n+        assertEquals(9, test.monthOfYear().get());\n+        assertEquals(\"9\", test.monthOfYear().getAsString());\n+        assertEquals(\"September\", test.monthOfYear().getAsText());\n+        assertEquals(\"septembre\", test.monthOfYear().getAsText(Locale.FRENCH));\n+        assertEquals(\"Sep\", test.monthOfYear().getAsShortText());\n+        assertEquals(\"sept.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n+        // assertEquals(test.getChronology().days(), test.dayOfMonth().getRangeDurationField());\n+        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n+        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMonthOfYear() {\n+        MonthDay test = new MonthDay(10, 6);\n+        assertEquals(1, test.monthOfYear().getMinimumValue());\n+        assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n+        assertEquals(12, test.monthOfYear().getMaximumValue());\n+        assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddMonthOfYear() {\n+        MonthDay test = new MonthDay(3, 6);\n+        MonthDay copy = test.monthOfYear().addToCopy(9);\n+        check(test, 3, 6);\n+        check(copy, 12, 6);\n+        \n+        copy = test.monthOfYear().addToCopy(0);\n+        check(copy, 3, 6);\n+\n+        check(test, 3, 6);\n+        \n+        copy = test.monthOfYear().addToCopy(-3);\n+        check(copy, 12, 6);\n+        check(test, 3, 6);\n+    }\n+\n+    public void testPropertyAddWrapFieldMonthOfYear() {\n+        MonthDay test = new MonthDay(5, 6);\n+        MonthDay copy = test.monthOfYear().addWrapFieldToCopy(2);\n+        check(test, 5, 6);\n+        check(copy, 7, 6);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(2);\n+        check(copy, 7, 6);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(292278993 - 4 + 1);\n+        check(copy, 11, 6);\n+        \n+        copy = test.monthOfYear().addWrapFieldToCopy(-292275054 - 4 - 1);\n+        check(copy, 6, 6);\n+    }\n+\n+    public void testPropertySetMonthOfYear() {\n+        MonthDay test = new MonthDay(10, 6);\n+        MonthDay copy = test.monthOfYear().setCopy(12);\n+        check(test, 10, 6);\n+        check(copy, 12, 6);\n+    }\n+\n+    public void testPropertySetTextMonthOfYear() {\n+        MonthDay test = new MonthDay(10, 6);\n+        MonthDay copy = test.monthOfYear().setCopy(\"12\");\n+        check(test, 10, 6);\n+        check(copy, 12, 6);\n+    }\n+\n+    public void testPropertyCompareToMonthOfYear() {\n+        MonthDay test1 = new MonthDay(TEST_TIME1);\n+        MonthDay test2 = new MonthDay(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);\n+        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);\n+        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);\n+        try {\n+            test1.monthOfYear().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n+        assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n+        assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n+        assertSame(test, test.dayOfMonth().getReadablePartial());\n+        assertSame(test, test.dayOfMonth().getMonthDay());\n+        assertEquals(6, test.dayOfMonth().get());\n+        assertEquals(\"6\", test.dayOfMonth().getAsString());\n+        assertEquals(\"6\", test.dayOfMonth().getAsText());\n+        assertEquals(\"6\", test.dayOfMonth().getAsText(Locale.FRENCH));\n+        assertEquals(\"6\", test.dayOfMonth().getAsShortText());\n+        assertEquals(\"6\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n+        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n+        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n+        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n+        test = new MonthDay(4, 7);\n+        assertEquals(\"7\", test.dayOfMonth().getAsText(Locale.FRENCH));\n+        assertEquals(\"7\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        assertEquals(1, test.dayOfMonth().getMinimumValue());\n+        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n+        assertEquals(30, test.dayOfMonth().getMaximumValue());\n+        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        MonthDay copy = test.dayOfMonth().addToCopy(6);\n+        check(test, 4, 6);\n+        check(copy, 4, 12);\n+        \n+        copy = test.dayOfMonth().addToCopy(7);\n+        check(copy, 4, 13);\n+        \n+        copy = test.dayOfMonth().addToCopy(-5);\n+        check(copy, 4, 1);\n+        \n+        copy = test.dayOfMonth().addToCopy(-6);\n+        check(copy, 3, 31);\n+    }\n+\n+    public void testPropertyAddWrapFieldDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        MonthDay copy = test.dayOfMonth().addWrapFieldToCopy(4);\n+        check(test, 4, 6);\n+        check(copy, 4, 10);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(8);\n+        check(copy, 4, 14);\n+        \n+        copy = test.dayOfMonth().addWrapFieldToCopy(-8);\n+        check(copy, 4, 28);\n+    }\n+\n+    public void testPropertySetDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        MonthDay copy = test.dayOfMonth().setCopy(12);\n+        check(test, 4, 6);\n+        check(copy, 4, 12);\n+        \n+        try {\n+            test.dayOfMonth().setCopy(33);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.dayOfMonth().setCopy(0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextDayOfMonth() {\n+        MonthDay test = new MonthDay(4, 6);\n+        MonthDay copy = test.dayOfMonth().setCopy(\"12\");\n+        check(test, 4, 6);\n+        check(copy, 4, 12);\n+        \n+        copy = test.dayOfMonth().setCopy(\"2\");\n+        check(test, 4, 6);\n+        check(copy, 4, 2);\n+        \n+        copy = test.dayOfMonth().setCopy(\"4\");\n+        check(test, 4, 6);\n+        check(copy, 4, 4);\n+    }\n+\n+    public void testPropertyCompareToDayOfMonth() {\n+        MonthDay test1 = new MonthDay(TEST_TIME1);\n+        MonthDay test2 = new MonthDay(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);\n+        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);\n+        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);\n+        try {\n+            test1.dayOfMonth().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyEquals() {\n+        MonthDay test1 = new MonthDay(11, 11);\n+        MonthDay test2 = new MonthDay(11, 12);\n+        MonthDay test3 = new MonthDay(11, 11, CopticChronology.getInstanceUTC());\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear()));\n+        assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear()));\n+        \n+        assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n+        assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear()));\n+        \n+        assertEquals(false, test1.dayOfMonth().equals(null));\n+        assertEquals(false, test1.dayOfMonth().equals(\"any\"));\n+        \n+        // chrono\n+        assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth()));\n+    }\n+\n+    public void testPropertyHashCode() {\n+        MonthDay test1 = new MonthDay(5, 11);\n+        MonthDay test2 = new MonthDay(5, 12);\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(false, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode());\n+        assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeLenient() {\n+        MonthDay test1 = new MonthDay(5, 6, LenientChronology.getInstance(COPTIC_PARIS));\n+        MonthDay test2 = new MonthDay(5, 6, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        MonthDay test1 = new MonthDay(5, 6, StrictChronology.getInstance(COPTIC_PARIS));\n+        MonthDay test2 = new MonthDay(5, 6, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(MonthDay test, int monthOfYear, int dayOfMonth) {\n+        assertEquals(monthOfYear, test.getMonthOfYear());\n+        assertEquals(dayOfMonth, test.getDayOfMonth());\n+    }\n+}", "timestamp": 1266152832, "metainfo": ""}