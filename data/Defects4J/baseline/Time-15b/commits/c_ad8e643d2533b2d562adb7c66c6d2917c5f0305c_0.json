{"sha": "ad8e643d2533b2d562adb7c66c6d2917c5f0305c", "log": "Refactor Duration to create MillisDuration for millisecond based durations   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n \n     /** Serialization version */\n     private static final long serialVersionUID = -2110953284060001145L;\n-\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkArgument(DurationField field, String name) {\n-        if (!field.isSupported()) {\n-            throw new IllegalArgumentException\n-                (\"Duration does not support field \\\"\" + name + '\"');\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkSupport(DurationField field, String name) {\n-        if (!field.isSupported()) {\n-            throw new UnsupportedOperationException\n-                (\"Duration does not support field \\\"\" + name + '\"');\n-        }\n-    }\n+    /** Millis cache is currently unknown */\n+    private static final int STATE_UNKNOWN = 0;\n+    /** Millis cache is not calculable */\n+    private static final int STATE_NOT_CALCULABLE = 1;\n+    /** Millis cache has been calculated and is valid */\n+    private static final int STATE_CALCULATED = 2;\n+    /** Total millis is the master field, fields always accurate */\n+    private static final int STATE_TOTAL_MILLIS_MASTER = -1;\n \n     /** The duration type that allocates the duration to fields */\n     private final DurationType iType;\n+    /** The object state */\n+    private int iState;\n     /** The total milliseconds, if known */\n     private long iTotalMillis;\n-    /** The milliseoond status, 0=unknown, 1=imprecise, 2=precise */\n-    private int iTotalMillisState;\n-\n+    /** Value for years */\n     private int iYears;\n+    /** Value for months */\n     private int iMonths;\n+    /** Value for weeks */\n     private int iWeeks;\n+    /** Value for days */\n     private int iDays;\n+    /** Value for hours */\n     private int iHours;\n+    /** Value for minutes */\n     private int iMinutes;\n+    /** Value for seconds */\n     private int iSeconds;\n+    /** Value for millis */\n     private int iMillis;\n \n     /**\n-     * Creates a zero length duration of the specified type.\n-     *\n-     * @param type  which set of fields this duration supports, null means millis type\n-     */\n-    public AbstractDuration(DurationType type) {\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractDuration(long duration, DurationType type, boolean totalMillisMaster) {\n         super();\n-        type = (type == null ? DurationType.getMillisType() : type);\n+        type = init(type, totalMillisMaster);\n         iType = type;\n         // Only call a private method\n-        setTotalMillis(type, 0L);\n+        setTotalMillis(type, duration);\n+    }\n+\n+    /**\n+     * Creates a duration from a set of field values.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports\n+     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n+     * @throws IllegalArgumentException if duration type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractDuration(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            DurationType type, boolean totalMillisMaster) {\n+        super();\n+        type = init(type, totalMillisMaster);\n+        iType = type;\n+        // Only call a private method\n+        setDuration(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractDuration(long startInstant, long endInstant, DurationType type, boolean totalMillisMaster) {\n+        super();\n+        type = init(type, totalMillisMaster);\n+        iType = type;\n+        // Only call a private method\n+        setTotalMillis(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports\n+     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n+     * @throws IllegalArgumentException if duration type is invalid\n+     */\n+    public AbstractDuration(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type, boolean totalMillisMaster) {\n+        super();\n+        type = init(type, totalMillisMaster);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n+            // Only call a private method\n+            setTotalMillis(type, start, end);\n+        }\n     }\n \n     /**\n      *\n      * @param duration  duration to convert\n      * @param type  which set of fields this duration supports, null means use type from object\n+     * @param totalMillisMaster  true if the total millis is master, false if the fields are\n      * @throws IllegalArgumentException if duration is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    public AbstractDuration(Object duration, DurationType type) {\n+    public AbstractDuration(Object duration, DurationType type, boolean totalMillisMaster) {\n         super();\n         DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n         type = (type == null ? converter.getDurationType(duration) : type);\n+        type = init(type, totalMillisMaster);\n         iType = type;\n         if (type.isPrecise() && converter.isPrecise(duration)) {\n             // Only call a private method\n         }\n     }\n \n-    /**\n-     * Creates a duration from a set of field values.\n-     *\n-     * @param years  amount of years in this duration, which must be zero if unsupported\n-     * @param months  amount of months in this duration, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n-     * @param days  amount of days in this duration, which must be zero if unsupported\n-     * @param hours  amount of hours in this duration, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n-     * @param type  which set of fields this duration supports, null means AllType\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    public AbstractDuration(int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis,\n-                            DurationType type) {\n-        super();\n-        type = (type == null ? DurationType.getAllType() : type);\n-        iType = type;\n-        // Only call a private method\n-        setDuration(type, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this duration supports, null means AllType\n-     */\n-    public AbstractDuration(long startInstant, long endInstant, DurationType type) {\n-        super();\n-        type = (type == null ? DurationType.getAllType() : type);\n-        iType = type;\n-        // Only call a private method\n-        setTotalMillis(type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param startInstant  interval start, null means now\n-     * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this duration supports, null means AllType\n-     */\n-    public AbstractDuration(\n-            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type) {\n-        super();\n-        type = (type == null ? DurationType.getAllType() : type);\n-        if (startInstant == null && endInstant == null) {\n-            iType = type;\n-        } else {\n-            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n-            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n-            iType = type;\n-            // Only call a private method\n-            setTotalMillis(type, start, end);\n-        }\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration. If any supported\n-     * fields are imprecise, an UnsupportedOperationException is thrown. The\n-     * exception to this is when the specified duration is zero.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports, null means MillisType\n-     */\n-    public AbstractDuration(long duration, DurationType type) {\n-        super();\n-        type = (type == null ? DurationType.getMillisType() : type);\n-        iType = type;\n-        setTotalMillis(type, duration); // Only call a private method\n-    }\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check\n+     * @param totalMillisMaster  true if total millis should be master\n+     * @return the duration type, not null\n+     * @throws IllegalArgumentException if the duration type is invalid\n+     */\n+    private DurationType init(DurationType type, boolean totalMillisMaster) {\n+        if (totalMillisMaster) {\n+            iState = STATE_TOTAL_MILLIS_MASTER;\n+        }\n+        type = checkDurationType(type);\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The duration type must not be null\");\n+        }\n+        if (totalMillisMaster && type.isPrecise() == false) {\n+            throw new IllegalArgumentException(\"The duration type must be precise: \" + type);\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is invalid\n+     */\n+    protected abstract DurationType checkDurationType(DurationType type);\n \n     //-----------------------------------------------------------------------\n     /**\n     }\n \n     /**\n+     * Is this duration based on a millisecond duration and thus performs\n+     * all calculations using the total millisecond value.\n+     * <p>\n+     * Durations operate either using the total milliseconds as the master and the\n+     * field values as derived, or vice versa. This method returns true if the\n+     * total millis field is the master.\n+     * <p>\n+     * If true, {@link #isPrecise()} will always return true, {@link #getTotalMillis()}\n+     * and {@link #compareTo(Object)} methods will never throw an exception and the\n+     * add methods will add using the total milliseconds value.\n+     * See {@link MillisDuration} for details.\n+     *\n+     * @return true if the duration is based on total milliseconds\n+     */\n+    public final boolean isTotalMillisBased() {\n+        return (iState == STATE_TOTAL_MILLIS_MASTER);\n+    }\n+\n+    /**\n      * Gets the total length of this duration in milliseconds, \n      * failing if the duration is imprecise.\n      *\n      * @return the total length of the duration in milliseconds.\n      * @throws IllegalStateException if the duration is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n      */\n     public final long getTotalMillis() {\n-        int state = iTotalMillisState;\n-        if (state == 0) {\n+        int state = iState;\n+        if (state == STATE_TOTAL_MILLIS_MASTER) {\n+            return iTotalMillis;\n+        }\n+        if (state == STATE_UNKNOWN) {\n             state = updateTotalMillis();\n         }\n-        if (state != 2) {\n+        if (state != STATE_CALCULATED) {\n             throw new IllegalStateException(\"Duration is imprecise\");\n         }\n         return iTotalMillis;\n      * @return true if the duration is precise\n      */\n     public final boolean isPrecise() {\n-        int state = iTotalMillisState;\n-        if (state == 0) {\n+        int state = iState;\n+        if (state == STATE_TOTAL_MILLIS_MASTER) {\n+            return true;\n+        }\n+        if (state == STATE_UNKNOWN) {\n             state = updateTotalMillis();\n         }\n-        return state == 2;\n-    }\n-\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this duration is precise.\n-     *\n-     * @return new state\n-     */\n-    private int updateTotalMillis() {\n-        final DurationType type = iType;\n-\n-        boolean isPrecise = true;\n-        long totalMillis = 0;\n-\n-        DurationField field;\n-        int value; // used to lock fields against threading issues\n-        value = iYears;\n-        if (value != 0) {\n-            field = type.years();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iMonths;\n-        if (value != 0) {\n-            field = type.months();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iWeeks;\n-        if (value != 0) {\n-            field = type.weeks();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iDays;\n-        if (value != 0) {\n-            field = type.days();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iHours;\n-        if (value != 0) {\n-            field = type.hours();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iMinutes;\n-        if (value != 0) {\n-            field = type.minutes();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iSeconds;\n-        if (value != 0) {\n-            field = type.seconds();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        value = iMillis;\n-        if (value != 0) {\n-            field = type.millis();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-\n-        if (isPrecise) {\n-            iTotalMillis = totalMillis;\n-            return iTotalMillisState = 2;\n-        } else {\n-            iTotalMillis = totalMillis;\n-            return iTotalMillisState = 1;\n-        }\n+        return (state == STATE_CALCULATED);\n     }\n \n     //-----------------------------------------------------------------------\n         return ISODurationFormat.getInstance().standard().print(this);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field, String name) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Duration does not support field \\\"\" + name + '\"');\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkSupport(DurationField field, String name) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Duration does not support field \\\"\" + name + '\"');\n+        }\n+    }\n+\n     /**\n      * Sets all the fields in one go from another ReadableDuration.\n      * <p>\n      * This method is private to prevent subclasses from overriding.\n      */\n     private void setDuration(DurationType type, ReadableDuration duration) {\n-        setDuration(type,\n-                    duration.getYears(), duration.getMonths(),\n-                    duration.getWeeks(), duration.getDays(),\n-                    duration.getHours(), duration.getMinutes(),\n-                    duration.getSeconds(), duration.getMillis());\n-        if (type.equals(duration.getDurationType()) && duration.isPrecise()) {\n-            iTotalMillis = duration.getTotalMillis();\n-            iTotalMillisState = 2;\n+        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+            if (duration.isPrecise() == false) {\n+                throw new IllegalArgumentException(\"The duration to copy from must be precise\");\n+            }\n+            setTotalMillis(type, duration.getTotalMillis());\n+        } else {\n+            setDuration(type,\n+                        duration.getYears(), duration.getMonths(),\n+                        duration.getWeeks(), duration.getDays(),\n+                        duration.getHours(), duration.getMinutes(),\n+                        duration.getSeconds(), duration.getMillis());\n+            if (type.equals(duration.getDurationType()) && duration.isPrecise()) {\n+                iTotalMillis = duration.getTotalMillis();\n+                iState = STATE_CALCULATED;\n+            }\n         }\n     }\n \n             checkArgument(type.millis(), \"millis\");\n         }\n         \n+        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+            updateTotalMillis(years, months, weeks, days, hours, minutes, seconds, millis);\n+        } else {\n+            iState = STATE_UNKNOWN;\n+        }\n         // assign fields in one block to reduce threading issues\n         iYears = years;\n         iMonths = months;\n         iMinutes = minutes;\n         iSeconds = seconds;\n         iMillis = millis;\n-\n-        iTotalMillisState = 0;\n     }\n \n     /**\n      */\n     private void setTotalMillis(DurationType type, long startInstant, long endInstant) {\n         long baseTotalMillis = (endInstant - startInstant);\n+        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+            setTotalMillis(type, baseTotalMillis);\n+            return;\n+        }\n         int years = 0, months = 0, weeks = 0, days = 0;\n         int hours = 0, minutes = 0, seconds = 0, millis = 0;\n         DurationField field;\n         iMillis = millis;\n         // (end - start) is excess to be discarded\n         iTotalMillis = baseTotalMillis - (endInstant - startInstant);\n-        iTotalMillisState = 2;\n+        iState = STATE_CALCULATED;\n     }\n \n     /**\n     private void setTotalMillis(DurationType type, long duration) {\n         if (duration == 0) {\n             iTotalMillis = duration;\n-            iTotalMillisState = 2;\n+            if (iState != STATE_TOTAL_MILLIS_MASTER) {\n+                iState = STATE_CALCULATED;\n+            }\n \n             iYears = 0;\n             iMonths = 0;\n         iMillis = millis;\n         // (end - start) is excess to be discarded\n         iTotalMillis = duration - (duration - startInstant);\n-        iTotalMillisState = 2;\n+        if (iState != STATE_TOTAL_MILLIS_MASTER) {\n+            iState = STATE_CALCULATED;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this duration is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    private int updateTotalMillis() {\n+        return updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n+    }\n+\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this duration is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    private int updateTotalMillis(int years, int months, int weeks, int days,\n+                                  int hours, int minutes, int seconds, int millis) {\n+        final DurationType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        if (years != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            }\n+        }\n+        if (months != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            }\n+        }\n+        if (weeks != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n+            }\n+        }\n+        if (days != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n+            }\n+        }\n+        if (hours != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n+            }\n+        }\n+        if (minutes != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n+            }\n+        }\n+        if (seconds != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n+            }\n+        }\n+        if (millis != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n+            }\n+        }\n+        \n+        iTotalMillis = totalMillis;\n+        if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+            return STATE_TOTAL_MILLIS_MASTER;\n+        } else if (isPrecise) {\n+            return iState = STATE_CALCULATED;\n+        } else {\n+            return iState = STATE_NOT_CALCULABLE;\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * \n      * @param duration  the duration, in milliseconds\n      * @throws IllegalStateException if the duration is imprecise\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void add(long duration) {\n-        setTotalMillis(getTotalMillis() + duration);\n+        setTotalMillis(FieldUtils.safeAdd(getTotalMillis(), duration));\n     }\n     \n     /**\n     \n     /**\n      * Normalizes all the field values in this duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n      *\n      * @throws IllegalStateException if this duration is imprecise\n      */\n             if (years != 0) {\n                 checkSupport(iType.years(), \"years\");\n             }\n-            iYears = years;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(years, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n+                iYears = years;\n+            } else {\n+                iYears = years;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified years to the number of years in the duration.\n      * \n      * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addYears(int years) {\n-        setYears(getYears() + years);\n+        setYears(FieldUtils.safeAdd(getYears(), years));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setMonths(int months) {\n         if (months != iMonths) {\n             if (months != 0) {\n                 checkSupport(iType.months(), \"months\");\n             }\n-            iMonths = months;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, months, iWeeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n+                iMonths = months;\n+            } else {\n+                iMonths = months;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified months to the number of months in the duration.\n      * \n      * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addMonths(int months) {\n-        setMonths(getMonths() + months);\n+        setMonths(FieldUtils.safeAdd(getMonths(), months));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setWeeks(int weeks) {\n         if (weeks != iWeeks) {\n             if (weeks != 0) {\n                 checkSupport(iType.weeks(), \"weeks\");\n             }\n-            iWeeks = weeks;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, weeks, iDays, iHours, iMinutes, iSeconds, iMillis);\n+                iWeeks = weeks;\n+            } else {\n+                iWeeks = weeks;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified weeks to the number of weeks in the duration.\n      * \n      * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addWeeks(int weeks) {\n-        setWeeks(getWeeks() + weeks);\n+        setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setDays(int days) {\n         if (days != iDays) {\n             if (days != 0) {\n                 checkSupport(iType.days(), \"days\");\n             }\n-            iDays = days;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, iWeeks, days, iHours, iMinutes, iSeconds, iMillis);\n+                iDays = days;\n+            } else {\n+                iDays = days;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified days to the number of days in the duration.\n      * \n      * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addDays(int days) {\n-        setDays(getDays() + days);\n+        setDays(FieldUtils.safeAdd(getDays(), days));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setHours(int hours) {\n         if (hours != iHours) {\n             if (hours != 0) {\n                 checkSupport(iType.hours(), \"hours\");\n             }\n-            iHours = hours;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, iWeeks, iDays, hours, iMinutes, iSeconds, iMillis);\n+                iHours = hours;\n+            } else {\n+                iHours = hours;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified hours to the number of hours in the duration.\n      * \n      * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addHours(int hours) {\n-        setHours(getHours() + hours);\n+        setHours(FieldUtils.safeAdd(getHours(), hours));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setMinutes(int minutes) {\n         if (minutes != iMinutes) {\n             if (minutes != 0) {\n                 checkSupport(iType.minutes(), \"minutes\");\n             }\n-            iMinutes = minutes;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, minutes, iSeconds, iMillis);\n+                iMinutes = minutes;\n+            } else {\n+                iMinutes = minutes;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified minutes to the number of minutes in the duration.\n      * \n      * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addMinutes(int minutes) {\n-        setMinutes(getMinutes() + minutes);\n+        setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setSeconds(int seconds) {\n         if (seconds != iSeconds) {\n             if (seconds != 0) {\n                 checkSupport(iType.seconds(), \"seconds\");\n             }\n-            iSeconds = seconds;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, seconds, iMillis);\n+                iSeconds = seconds;\n+            } else {\n+                iSeconds = seconds;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified seconds to the number of seconds in the duration.\n      * \n      * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addSeconds(int seconds) {\n-        setSeconds(getSeconds() + seconds);\n+        setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n     }\n \n     //-----------------------------------------------------------------------\n      * all lower subclasses are also immutable.\n      * \n      * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n      */\n     protected void setMillis(int millis) {\n         if (millis != iMillis) {\n             if (millis != 0) {\n                 checkSupport(iType.millis(), \"millis\");\n             }\n-            iMillis = millis;\n-            iTotalMillisState = 0;\n+            if (iState == STATE_TOTAL_MILLIS_MASTER) {\n+                updateTotalMillis(iYears, iMonths, iWeeks, iDays, iHours, iMinutes, iSeconds, millis);\n+                iMillis = millis;\n+            } else {\n+                iMillis = millis;\n+                iState = STATE_UNKNOWN;\n+            }\n         }\n     }\n \n      * Adds the specified millis to the number of millis in the duration.\n      * \n      * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported.\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the duration\n      */\n     protected void addMillis(int millis) {\n-        setMillis(getMillis() + millis);\n+        setMillis(FieldUtils.safeAdd(getMillis(), millis));\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n                 duration = new Duration(getStartInstant(), getEndInstant(), type);\n             }\n         } else {\n-            duration = duration.withDurationType(type);\n+            duration = duration.withDurationTypeUsingTotalMillis(type);\n         }\n         return duration;\n     }\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n import java.io.Serializable;\n \n /**\n- * Standard immutable duration implementation split on any set of fields.\n+ * An immutable duration that defines and adds durations based on individual field values.\n  * <p>\n  * A duration can be divided into a number of fields, such as hours and seconds.\n  * The way in which that divide occurs is controlled by the DurationType class.\n- * Commonly use types are MillisType, which assigns all values to the millis field,\n- * and AllType, which spreads values across all fields.\n- * <p>\n- * A duration has a concept of being <i>precise</i>.\n- * A precise duration is a fixed number of milliseconds long.\n- * Whether a particular duration instance is precise depends on the constructor\n- * used and the duration type specified.\n+ * <p>\n+ * <code>Duration</code> can uses any duration type to split the milliseconds into fields.\n+ * The {@link DurationType#getAllType() All} type is used by default.\n+ * <code>All</code> uses the ISO chronology and divide the duration into years, months,\n+ * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n+ * <p>\n+ * This class performs calculations using the individual fields.\n+ * The {@link ReadableDuration#isTotalMillisBased} method will always return false.\n+ * The total milliseconds may be calculated so long as the value of all imprecise\n+ * fields in the duration type are set to zero.\n+ * <p>\n+ * When this duration is added to an instant, the effect is of adding each field in turn.\n+ * As a result, this duration takes into account daylight savings time.\n+ * Adding a duration of 1 day to the day before daylight savings starts will only add\n+ * 23 hours rather than 24 to ensure that the time remains the same.\n+ * If this is not the behaviour you want, then see {@link MillisDuration}.\n  * <p>\n  * Duration is thread-safe and immutable, provided that the DurationType is as well.\n  * All standard DurationType classes supplied are thread-safe and immutable.\n  * @since 1.0\n  * @see MutableDuration\n  */\n-public class Duration extends AbstractDuration implements ReadableDuration, Serializable {\n+public class Duration\n+        extends AbstractDuration\n+        implements ReadableDuration, Serializable {\n \n     /** Constant representing zero millisecond duration */\n-    public static final Duration ZERO = new Duration();\n+    public static final Duration ZERO = new Duration(0L);\n \n     /** Serialization version */\n     private static final long serialVersionUID = 741052353876488155L;\n \n     /**\n-     * Creates a zero length millisecond duration using MillisType.\n-     * This constructor creates a precise duration because\n-     * MillisType in ISOChronology UTC is precise.\n-     */\n-    public Duration() {\n-        super((DurationType) null);\n-    }\n-\n-    /**\n-     * Creates a zero length duration.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param type  which set of fields this duration supports, null means millis type\n-     */\n-    public Duration(DurationType type) {\n-        super(type);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n-     */\n-    public Duration(Object duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use converter\n-     * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n-     */\n-    public Duration(Object duration, DurationType type) {\n-        super(duration, type);\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values using DayHourType.\n-     * This constructor creates a precise duration because\n-     * DayHourType in ISOChronology UTC is precise.\n-     *\n-     * @param days  amount of days in this duration\n+     * Creates a duration from the given millisecond duration using AllType.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public Duration(long duration) {\n+        super(duration, null, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     */\n+    public Duration(long duration, DurationType type) {\n+        super(duration, type, false);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n+     * This constructor creates a precise duration.\n+     *\n      * @param hours  amount of hours in this duration\n      * @param minutes  amount of minutes in this duration\n      * @param seconds  amount of seconds in this duration\n      * @param millis  amount of milliseconds in this duration\n      */\n-    public Duration(int days, int hours, int minutes, int seconds, int millis) {\n-        super(0, 0, 0, days, hours, minutes, seconds, millis, DurationType.getDayHourType());\n+    public Duration(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null, false);\n     }\n \n     /**\n      * Create a duration from a set of field values using AllType.\n-     * AllType using ISOChronology in UTC is an imprecise duration type\n-     * unless the year, month and week fields are zero.\n      *\n      * @param years  amount of years in this duration\n      * @param months  amount of months in this duration\n      */\n     public Duration(int years, int months, int weeks, int days,\n                     int hours, int minutes, int seconds, int millis) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null, false);\n     }\n \n     /**\n      * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n      * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n      * @param type  which set of fields this duration supports, null means AllType\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public Duration(int years, int months, int weeks, int days,\n                     int hours, int minutes, int seconds, int millis, DurationType type) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type, false);\n     }\n \n     /**\n      * @param endInstant  interval end, in milliseconds\n      */\n     public Duration(long startInstant, long endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, false);\n     }\n \n     /**\n      * @param type  which set of fields this duration supports, null means AllType\n      */\n     public Duration(long startInstant, long endInstant, DurationType type) {\n-        super(startInstant, endInstant, type);\n+        super(startInstant, endInstant, type, false);\n     }\n \n     /**\n      * @param endInstant  interval end, null means now\n      */\n     public Duration(ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, false);\n     }\n \n     /**\n      * @param type  which set of fields this duration supports, null means AllType\n      */\n     public Duration(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n-        super(startInstant, endInstant, type);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration using MillisType.\n-     * This constructor creates a precise duration because\n-     * MillisType in ISOChronology UTC is precise.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    public Duration(long duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     * @throws UnsupportedOperationException if any fields are imprecise\n-     */\n-    public Duration(long duration, DurationType type) {\n-        super(duration, type);\n+        super(startInstant, endInstant, type, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Duration(Object duration) {\n+        super(duration, null, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Duration(Object duration, DurationType type) {\n+        super(duration, type, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    protected final DurationType checkDurationType(DurationType type) {\n+        if (type == null) {\n+            return DurationType.getAllType();\n+        }\n+        return type;\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the new duration instance\n      * @throws IllegalStateException if this duration is imprecise\n      */\n-    public Duration withDurationType(DurationType type) {\n+    public Duration withDurationTypeUsingTotalMillis(DurationType type) {\n         if (type == null) {\n             type = DurationType.getAllType();\n         }\n         return new Duration(getTotalMillis(), type);\n     }\n \n+    /**\n+     * Creates a new Duration instance with the same field values but\n+     * different DurationType.\n+     * \n+     * @param type  the duration type to use, null means AllType\n+     * @return the new duration instance\n+     * @throws IllegalArgumentException if the new duration won't accept all of the current fields\n+     */\n+    public Duration withDurationTypeUsingFields(DurationType type) {\n+        if (type == null) {\n+            type = DurationType.getAllType();\n+        }\n+        if (type.equals(getDurationType())) {\n+            return this;\n+        }\n+        return new Duration(getYears(), getMonths(), getWeeks(), getDays(),\n+                    getHours(), getMinutes(), getSeconds(), getMillis(), type);\n+    }\n+\n+    /**\n+     * Creates a new Duration instance with the same total milliseconds but\n+     * all the fields normalized to be within their standard ranges.\n+     * \n+     * @return the new duration instance\n+     * @throws IllegalStateException if this duration is imprecise\n+     */\n+    public Duration withFieldsNormalized() {\n+        return new Duration(getTotalMillis(), getDurationType());\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n-    protected final void normalize() {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n     protected final void setYears(int years) {\n     }\n \n--- a/JodaTime/src/java/org/joda/time/DurationType.java\n+++ b/JodaTime/src/java/org/joda/time/DurationType.java\n  * <li>YearMonth - the duration is expressed using all fields except weeks\n  * <li>YearWeek - the duration is expressed using all fields except months\n  * <li>AverageYearMonth - as YearMonth, but years and months have fixed average lengths\n- * <li>PreciseAll - as All, but years are fixed at 365 days\n- *  and months are fixed at 30 days\n- * <li>PreciseYearMonth - as YearMonth, but years are fixed at 365 days\n- *  and months are fixed at 30 days\n- * <li>PreciseYearWeek - as YearWeek, but years are fixed at 365 days\n+ * <li>PreciseAll - defines years as 365 days, months as 30 days, weeks as 7 days,\n+ * days as 24 hours and all the time fields\n+ * <li>PreciseDayHour - defines days as 24 hours and all the time fields\n+ * <li>PreciseYearDay - defines years as 365 days, days as 24 hours and all the time fields\n+ * <li>PreciseYearWeek - defines years as 365 days, weeks as 7 days,\n+ * days as 24 hours and all the time fields\n+ * <li>PreciseYearMonth - defines years as 365 days, months as 30 days,\n+ * days as 24 hours and all the time fields\n  * </ul>\n  *\n  * <p>\n     private static final DurationType YEAR_MONTH_TYPE;\n     private static final DurationType YEAR_WEEK_TYPE;\n     private static final DurationType AVERAGE_YEAR_MONTH_TYPE;\n+    private static final DurationType PRECISE_DAY_HOUR_TYPE;\n+    private static final DurationType PRECISE_YEAR_DAY_TYPE;\n+    private static final DurationType PRECISE_YEAR_WEEK_TYPE;\n+    private static final DurationType PRECISE_YEAR_MONTH_TYPE;\n     private static final DurationType PRECISE_ALL_TYPE;\n-    private static final DurationType PRECISE_YEAR_MONTH_TYPE;\n-    private static final DurationType PRECISE_YEAR_WEEK_TYPE;\n \n     static {\n         MILLIS_TYPE = new MillisType();\n         DAY_HOUR_TYPE = new DayHourType(ISOChronology.getInstanceUTC());\n-        ALL_TYPE = new AllType(ISOChronology.getInstanceUTC());\n         YEAR_MONTH_TYPE = new YearMonthType(ISOChronology.getInstanceUTC());\n         YEAR_WEEK_TYPE = new YearWeekType(ISOChronology.getInstanceUTC());\n         AVERAGE_YEAR_MONTH_TYPE = new AverageYearMonthType(ISOChronology.getInstanceUTC());\n+        ALL_TYPE = new AllType(ISOChronology.getInstanceUTC());\n+        PRECISE_DAY_HOUR_TYPE = new PreciseDayHourType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_DAY_TYPE = new PreciseYearDayType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_WEEK_TYPE = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n+        PRECISE_YEAR_MONTH_TYPE = new PreciseYearMonthType(ISOChronology.getInstanceUTC());\n         PRECISE_ALL_TYPE = new PreciseAllType(ISOChronology.getInstanceUTC());\n-        PRECISE_YEAR_MONTH_TYPE = new PreciseYearMonthType(ISOChronology.getInstanceUTC());\n-        PRECISE_YEAR_WEEK_TYPE = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n     }\n \n     /**\n      * Returns a DurationType of only a milliseconds field using the ISOChronology.\n+     * When using this type, the maximum millisecond value that can be stored is\n+     * typically limited by a 32 bit int.\n      */\n     public static DurationType getMillisType() {\n         return MILLIS_TYPE;\n     }\n \n     /**\n-     * Returns a precise DurationType using the ISOChronology of:\n+     * Returns a precise DurationType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getPreciseDayHourType() {\n+        return PRECISE_DAY_HOUR_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise DurationType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>days (fixed at 24 hours)\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getPreciseYearDayType() {\n+        return PRECISE_YEAR_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise DurationType using the ISOChronology in UTC of:\n      *\n      * <ul>\n      * <li>years (fixed at 365 days)\n      * <li>months (fixed at 30 days)\n-     * <li>weeks\n-     * <li>days\n+     * <li>weeks (fixed at 7 days)\n+     * <li>days (fixed at 24 hours)\n      * <li>hours\n      * <li>minutes\n      * <li>seconds\n     }\n \n     /**\n-     * Returns a precise DurationType using the ISOChronology of:\n+     * Returns a precise DurationType using the ISOChronology in UTC of:\n      *\n      * <ul>\n      * <li>years (fixed at 365 days)\n      * <li>months (fixed at 30 days)\n-     * <li>days\n+     * <li>days (fixed at 24 hours)\n      * <li>hours\n      * <li>minutes\n      * <li>seconds\n     }\n \n     /**\n-     * Returns a precise DurationType using the ISOChronology of:\n+     * Returns a precise DurationType using the ISOChronology in UTC of:\n      *\n      * <ul>\n      * <li>years (fixed at 365 days)\n-     * <li>weeks\n-     * <li>days\n+     * <li>weeks (fixed at 7 days)\n+     * <li>days (fixed at 24 hours)\n      * <li>hours\n      * <li>minutes\n      * <li>seconds\n     }\n \n     //-----------------------------------------------------------------------\n-    private static final class MillisType extends DurationType {\n+    private static class MillisType extends DurationType {\n         private static final long serialVersionUID = -4314867016852780422L;\n \n-        public MillisType() {\n+        MillisType() {\n         }\n \n         public boolean isPrecise() {\n \n         protected final Chronology iChronology;\n \n-        public DayHourType(Chronology chrono) {\n+        DayHourType(Chronology chrono) {\n             iChronology = chrono;\n         }\n \n         }\n     }\n \n-    private static final class AllType extends DayHourType {\n+    private static class AllType extends DayHourType {\n         private static final long serialVersionUID = -359769822629866L;\n \n-        public AllType(Chronology chrono) {\n+        AllType(Chronology chrono) {\n             super(chrono);\n         }\n \n         }\n     }\n \n-    private static final class YearMonthType extends DayHourType {\n+    private static class YearMonthType extends DayHourType {\n         private static final long serialVersionUID = -1336767257680877683L;\n \n-        public YearMonthType(Chronology chrono) {\n+        YearMonthType(Chronology chrono) {\n             super(chrono);\n         }\n \n         }\n     }\n \n-    private static final class YearWeekType extends DayHourType {\n+    private static class YearWeekType extends DayHourType {\n         private static final long serialVersionUID = 1347170237843447098L;\n \n-        public YearWeekType(Chronology chrono) {\n+        YearWeekType(Chronology chrono) {\n             super(chrono);\n         }\n \n         }\n     }\n \n-    private static final class AverageYearMonthType extends DayHourType {\n+    private static class AverageYearMonthType extends DayHourType {\n         private static final long serialVersionUID = -1629017135050918461L;\n \n         private final DurationField iYears;\n         private final DurationField iMonths;\n         \n-        public AverageYearMonthType(Chronology chrono) {\n+        AverageYearMonthType(Chronology chrono) {\n             super(chrono);\n             iYears = new PreciseDurationField(\"AverageYears\", chrono.years().getUnitMillis());\n             iMonths = new PreciseDurationField(\"AverageMonths\", chrono.months().getUnitMillis());\n         }\n     }\n \n-    private static final class PreciseAllType extends DayHourType {\n-        private static final long serialVersionUID = 43967269280186L;\n+    //-----------------------------------------------------------------------\n+    private static class PreciseDayHourType extends DurationType {\n+        private static final long serialVersionUID = 216528691637527857L;\n+\n+        protected final Chronology iChronology;\n+\n+        PreciseDayHourType(Chronology chrono) {\n+            iChronology = chrono;\n+        }\n+\n+        public final Chronology getChronology() {\n+            return iChronology;\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return true;\n+        }\n+\n+        public final DurationField days() {\n+            return iChronology.days();\n+        }\n+\n+        public final DurationField hours() {\n+            return iChronology.hours();\n+        }\n+\n+        public final DurationField minutes() {\n+            return iChronology.minutes();\n+        }\n+\n+        public final DurationField seconds() {\n+            return iChronology.seconds();\n+        }\n+\n+        public final DurationField millis() {\n+            return iChronology.millis();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseDayHourType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseDayHourType\";\n+        }\n+    }\n+\n+    private static class PreciseYearDayType extends PreciseDayHourType {\n+        private static final long serialVersionUID = -2553285612358L;\n \n         private final DurationField iYears;\n-        private final DurationField iMonths;\n-        \n-        public PreciseAllType(Chronology chrono) {\n+        \n+        PreciseYearDayType(Chronology chrono) {\n             super(chrono);\n             iYears = new ScaledDurationField(chrono.days(), \"PreciseYears\", 365);\n-            iMonths = new ScaledDurationField(chrono.days(), \"PreciseMonths\", 30);\n+            // rely on days/weeks to be precise because only ISO UTC used\n         }\n \n         public DurationType withChronology(Chronology chrono) {\n \n         public boolean isPrecise() {\n             return years().isPrecise()\n-                && months().isPrecise()\n-                && weeks().isPrecise()\n                 && super.isPrecise();\n         }\n \n             return iYears;\n         }\n \n+        private Object readResolve() {\n+            return getPreciseYearDayType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearDayType\";\n+        }\n+    }\n+\n+    private static class PreciseYearWeekType extends PreciseYearDayType {\n+        private static final long serialVersionUID = -2040324323318740267L;\n+\n+        PreciseYearWeekType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseYearWeekType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearWeekType\";\n+        }\n+    }\n+\n+    private static class PreciseYearMonthType extends PreciseYearDayType {\n+        private static final long serialVersionUID = 1203161678926193794L;\n+\n+        private final DurationField iMonths;\n+        \n+        PreciseYearMonthType(Chronology chrono) {\n+            super(chrono);\n+            iMonths = new ScaledDurationField(chrono.days(), \"PreciseMonths\", 30);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return months().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n         public DurationField months() {\n             return iMonths;\n         }\n \n+        private Object readResolve() {\n+            return getPreciseYearMonthType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearMonthType\";\n+        }\n+    }\n+\n+    private static class PreciseAllType extends PreciseYearMonthType {\n+        private static final long serialVersionUID = 43967269280186L;\n+\n+        PreciseAllType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n         public DurationField weeks() {\n             return iChronology.weeks();\n         }\n         }\n     }\n \n-    private static final class PreciseYearMonthType extends DayHourType {\n-        private static final long serialVersionUID = 1203161678926193794L;\n-\n-        private final DurationField iYears;\n-        private final DurationField iMonths;\n-        \n-        public PreciseYearMonthType(Chronology chrono) {\n-            super(chrono);\n-            iYears = new ScaledDurationField(chrono.days(), \"PreciseYears\", 365);\n-            iMonths = new ScaledDurationField(chrono.days(), \"PreciseMonths\", 30);\n-        }\n-\n-        public DurationType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && months().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iYears;\n-        }\n-\n-        public DurationField months() {\n-            return iMonths;\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseYearMonthType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseYearMonthType\";\n-        }\n-    }\n-\n-    private static final class PreciseYearWeekType extends DayHourType {\n-        private static final long serialVersionUID = -2040324323318740267L;\n-\n-        private final DurationField iYears;\n-        \n-        public PreciseYearWeekType(Chronology chrono) {\n-            super(chrono);\n-            iYears = new ScaledDurationField(chrono.days(), \"PreciseYears\", 365);\n-        }\n-\n-        public DurationType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && weeks().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iYears;\n-        }\n-\n-        public DurationField weeks() {\n-            return iChronology.weeks();\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseYearWeekType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseYearWeekType\";\n-        }\n-    }\n-\n-    private static final class MaskedType extends DurationType {\n+    //-----------------------------------------------------------------------\n+    private static class MaskedType extends DurationType {\n         private static final long serialVersionUID = 940106774669244586L;\n \n         public static DurationType mask(DurationType type, int mask) {\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MillisDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A precise immutable duration that defines and adds durations based on milliseconds.\n+ * <p>\n+ * A precise duration is one that is defined primarily by a fixed number of milliseconds.\n+ * The fields, such as hours and seconds, are provided for convenience.\n+ * The {@link ReadableDuration#isTotalMillisBased} method will always return true.\n+ * <p>\n+ * <code>MillisDuration</code> uses any precise duration type to split the milliseconds\n+ * into fields.\n+ * The {@link DurationType#getPreciseAllType() PreciseAll} type is used by default.\n+ * <code>PreciseAll</code> uses the ISO chronology and fixes\n+ * days at 24 hours, weeks at 7 days, months at 30 days and years at 365 days.\n+ * <p>\n+ * When a precise duration is added to an instant the millisecond value of the instant\n+ * is added. The field values are not used. If the addition to the instant crosses a\n+ * daylight savings boundary the effect may be unexpected.\n+ * <p>\n+ * For example, consider a <code>MillisDuration</code> of 1 day.\n+ * This actually represents <code>24 * 60 * 60 * 1000</code> milliseconds.\n+ * When you add this to a <code>DateTime</code> just before daylight savings changes\n+ * the result will be to add the milliseconds. Thus the result will be one hour\n+ * different on the following day.\n+ * <pre>\n+ * MillisDuration dur = new MillisDuration(0, 0, 0, 1, 0, 0, 0, 0); // 1 'day'\n+ * DateTime dt = new DateTime(2004, 3, 27, 12, 0, 0, 0); // before DST\n+ * DateTime result = new DateTime(dur.addTo(dt, 1)); // after DST\n+ * // result:  2004-03-27T12:00:00 -> 2004-03-28T13:00:00 \n+ * // note: result time is 13:00, as 1 day is always 24 hours in MillisDuration\n+ * </pre>\n+ * If this behaviour is not what you want then you should use {@link Duration}.\n+ * <p>\n+ * MillisDuration is thread-safe and immutable, provided that the DurationType is as well.\n+ * All standard DurationType classes supplied are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see Duration\n+ * @see MutableDuration\n+ */\n+public class MillisDuration\n+        extends AbstractDuration\n+        implements ReadableDuration, Serializable {\n+\n+    /** Constant representing zero millisecond duration */\n+    public static final MillisDuration ZERO = new MillisDuration(0L);\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5727916780257544L;\n+\n+    /**\n+     * Creates a duration from the given millisecond duration using PreciseAllType.\n+     * <p>\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MillisDuration(long duration) {\n+        super(duration, null, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     * <p>\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports, null means PreciseAllType\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    public MillisDuration(long duration, DurationType type) {\n+        super(duration, type, true);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using PreciseAllType.\n+     *\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public MillisDuration(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null, true);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using PreciseAllType.\n+     *\n+     * @param years  amount of years in this duration\n+     * @param months  amount of months in this duration\n+     * @param weeks  amount of weeks in this duration\n+     * @param days  amount of days in this duration\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     * @throws ArithmeticException if the total millis is too large for a <code>long</code>\n+     */\n+    public MillisDuration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null, true);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports, null means PreciseAllType\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     * @throws ArithmeticException if the total millis is too large for a <code>long</code>\n+     */\n+    public MillisDuration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using PreciseAllType.\n+     * <p>\n+     * This constructor is a convenience for the single <code>long</code> constructor.\n+     * The start and end instant play non role in determining the field values.\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public MillisDuration(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     * <p>\n+     * This constructor is a convenience for the single <code>long</code> constructor.\n+     * The start and end instant play non role in determining the field values.\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports, null means PreciseAllType\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    public MillisDuration(long startInstant, long endInstant, DurationType type) {\n+        super(startInstant, endInstant, type, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using PreciseAllType.\n+     * <p>\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public MillisDuration(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     * <p>\n+     * This constructor is a convenience for the single <code>long</code> constructor.\n+     * The start and end instant play non role in determining the field values.\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports, null means PreciseAllType\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    public MillisDuration(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+        super(startInstant, endInstant, type, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     * <p>\n+     * This constructor is a convenience for the single <code>long</code> constructor.\n+     * The start and end instant play non role in determining the field values.\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MillisDuration(Object duration) {\n+        super(duration, null, true);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     * <p>\n+     * The duration created using this constructor will always have normalized fields.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MillisDuration(Object duration, DurationType type) {\n+        super(duration, type, true);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    protected final DurationType checkDurationType(DurationType type) {\n+        if (type == null) {\n+            return DurationType.getPreciseAllType();\n+        }\n+        if (type.isPrecise() == false) {\n+            throw new IllegalArgumentException(\"The duration type must be precise: \" + type);\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new MillisDuration instance with the same total milliseconds but\n+     * different DurationType, which must be precise.\n+     * \n+     * @param type  the duration type to use, null means PreciseAllType\n+     * @return the new duration instance\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    public MillisDuration withDurationType(DurationType type) {\n+        type = checkDurationType(type);\n+        if (type.equals(getDurationType())) {\n+            return this;\n+        }\n+        return new MillisDuration(getTotalMillis(), type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setDuration(ReadableDuration duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setDuration(int years, int months, int weeks, int days,\n+                                     int hours, int minutes, int seconds, int millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTotalMillis(long startInstant, long endInstant) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setTotalMillis(long duration) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setYears(int years) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMonths(int months) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setWeeks(int weeks) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setDays(int days) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setHours(int hours) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMinutes(int minutes) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setSeconds(int seconds) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n+     */\n+    protected final void setMillis(int millis) {\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/MutableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java\n  * @since 1.0\n  * @see Duration\n  */\n-public class MutableDuration extends AbstractDuration\n-    implements ReadWritableDuration, Cloneable, Serializable {\n-\n-    static final long serialVersionUID = 3436451121567212165L;\n-\n-    /**\n-     * Creates a zero length millisecond duration using MillisType.\n-     * This constructor creates a precise duration because\n-     * MillisType in ISOChronology UTC is precise.\n+public class MutableDuration\n+        extends AbstractDuration\n+        implements ReadWritableDuration, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3436451121567212165L;\n+\n+    /**\n+     * Creates a zero-length duration using AllType.\n      */\n     public MutableDuration() {\n-        super((DurationType) null);\n-    }\n-\n-    /**\n-     * Creates a zero length duration.\n+        super(0L, null, false);\n+    }\n+\n+    /**\n+     * Creates a zero-length duration using the specified duration type.\n+     *\n+     * @param type  which set of fields this duration supports\n+     */\n+    public MutableDuration(DurationType type) {\n+        super(0L, type, false);\n+    }\n+\n+    /**\n+     * Creates a zero-length duration using the specified duration type.\n+     * <p>\n+     * This constructor enables the created object to be based on total miliseconds\n+     * rather than the more normal fields. A total millisecond based duration\n+     * performs all calculations using the total millis and is always precise.\n+     *\n+     * @param type  which set of fields this duration supports\n+     * @param totalMillisBased  true if duration treats the total millis as the master field\n+     * @throws IllegalArgumentException if the duration type is imprecise and totalMillisBased is true\n+     */\n+    public MutableDuration(DurationType type, boolean totalMillisBased) {\n+        super(0L, type, totalMillisBased);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration using AllType.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MutableDuration(long duration) {\n+        super(duration, null, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n+     */\n+    public MutableDuration(long duration, DurationType type) {\n+        super(duration, type, false);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n      * This constructor creates a precise duration.\n      *\n-     * @param type  which set of fields this duration supports, null means millis type\n-     */\n-    public MutableDuration(DurationType type) {\n-        super(type);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n-     */\n-    public MutableDuration(Object duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a duration from the specified object using the\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n-     *\n-     * @param duration  duration to convert\n-     * @param type  which set of fields this duration supports, null means use converter\n-     * @throws IllegalArgumentException if duration is invalid\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n-     */\n-    public MutableDuration(Object duration, DurationType type) {\n-        super(duration, type);\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values using DayHourType.\n-     * This constructor creates a precise duration because\n-     * DayHourType in ISOChronology UTC is precise.\n-     *\n-     * @param days  amount of days in this duration\n      * @param hours  amount of hours in this duration\n      * @param minutes  amount of minutes in this duration\n      * @param seconds  amount of seconds in this duration\n      * @param millis  amount of milliseconds in this duration\n      */\n-    public MutableDuration(int days, int hours, int minutes, int seconds, int millis) {\n-        super(0, 0, 0, days, hours, minutes, seconds, millis, DurationType.getDayHourType());\n+    public MutableDuration(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, null, false);\n     }\n \n     /**\n      * Create a duration from a set of field values using AllType.\n-     * AllType using ISOChronology in UTC is an imprecise duration type\n-     * unless the year, month and week fields are zero.\n      *\n      * @param years  amount of years in this duration\n      * @param months  amount of months in this duration\n      */\n     public MutableDuration(int years, int months, int weeks, int days,\n                     int hours, int minutes, int seconds, int millis) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null, false);\n     }\n \n     /**\n      * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n      * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n      * @param type  which set of fields this duration supports, null means AllType\n-     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public MutableDuration(int years, int months, int weeks, int days,\n                     int hours, int minutes, int seconds, int millis, DurationType type) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type, false);\n     }\n \n     /**\n      * @param endInstant  interval end, in milliseconds\n      */\n     public MutableDuration(long startInstant, long endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, false);\n     }\n \n     /**\n      * @param type  which set of fields this duration supports, null means AllType\n      */\n     public MutableDuration(long startInstant, long endInstant, DurationType type) {\n-        super(startInstant, endInstant, type);\n+        super(startInstant, endInstant, type, false);\n     }\n \n     /**\n      * @param endInstant  interval end, null means now\n      */\n     public MutableDuration(ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, false);\n     }\n \n     /**\n      * @param type  which set of fields this duration supports, null means AllType\n      */\n     public MutableDuration(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n-        super(startInstant, endInstant, type);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration using MillisType.\n-     * This constructor creates a precise duration because\n-     * MillisType in ISOChronology UTC is precise.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    public MutableDuration(long duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration.\n-     * This constructor creates a precise duration.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     * @throws UnsupportedOperationException if any fields are imprecise\n-     */\n-    public MutableDuration(long duration, DurationType type) {\n-        super(duration, type);\n+        super(startInstant, endInstant, type, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(Object duration) {\n+        super(duration, null, false);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(Object duration, DurationType type) {\n+        super(duration, type, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a duration type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the duration type is not precise\n+     */\n+    protected DurationType checkDurationType(DurationType type) {\n+        if (type == null) {\n+            if (isTotalMillisBased()) {\n+                return DurationType.getPreciseAllType();\n+            } else {\n+                return DurationType.getAllType();\n+            }\n+        }\n+        return type;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n     DurationType getDurationType();\n \n     /**\n+     * Is this duration based on a millisecond duration and thus performs\n+     * all calculations using the total millisecond value.\n+     * <p>\n+     * Durations operate either using the total milliseconds as the master and the\n+     * field values as derived, or vice versa. This method returns true if the\n+     * total millis field is the master. The effect is to control how the duration\n+     * manages addition over the daylight savings boundary.\n+     * <p>\n+     * If true, {@link #isPrecise()} will always return true, {@link #getTotalMillis()}\n+     * and {@link #compareTo(Object)} methods will never throw an exception and the\n+     * add methods will add using the total milliseconds value.\n+     * See {@link MillisDuration} for details.\n+     *\n+     * @return true if the duration is based on total milliseconds\n+     */\n+    boolean isTotalMillisBased();\n+\n+    /**\n      * Gets the total length of this duration in milliseconds, \n      * failing if the duration is imprecise.\n      *\n     int getMillis();\n \n     /**\n-     * Get this object as an immutable Duration. This can be useful if you\n+     * Gets this object as an immutable Duration. This can be useful if you\n      * don't trust the implementation of the interface to be well-behaved, or\n      * to get a guaranteed immutable object.\n      * \n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n     }\n \n     /**\n-     * Returns the millis duration type.\n+     * Returns null to allow the caller to determine the best type.\n      *\n      * @param object  the object to examine\n-     * @return the millis duration type\n+     * @return null\n      */\n     public DurationType getDurationType(Object object) {\n-        return DurationType.getMillisType();\n+        return null;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDurationType.java\n+++ b/JodaTime/src/test/org/joda/time/TestDurationType.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testPreciseDayHourType() throws Exception {\n+        DurationType type = DurationType.getPreciseDayHourType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getPreciseDayHourType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"PreciseDayHourType\", type.getName());\n+        assertEquals(\"DurationType[PreciseDayHourType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearDayType() throws Exception {\n+        DurationType type = DurationType.getPreciseYearDayType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getPreciseYearDayType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseYearDayType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearDayType\", type.getName());\n+        assertEquals(\"DurationType[PreciseYearDayType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testPreciseYearWeekType() throws Exception {\n         DurationType type = DurationType.getPreciseYearWeekType();\n         assertEquals(true, type.years().isSupported());\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationType() {\n-        Duration test = new Duration();\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        Duration test = new Duration(0L);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+    }\n+\n+    public void testGetIsTotalMillisBased() {\n+        Duration test = new Duration(123L);\n+        assertEquals(false, test.isTotalMillisBased());\n+        test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testGetTotalMillis() {\n     }\n \n     public void testGetMethods() {\n-        Duration test = new Duration();\n+        Duration test = new Duration(0L);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getDays());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getDays());\n         assertEquals(0, test.getHours());\n     \n     class MockDuration extends AbstractDuration {\n         public MockDuration(long value) {\n-            super(value, null);\n+            super(value, null, false);\n+        }\n+        protected DurationType checkDurationType(DurationType type) {\n+            return DurationType.getAllType();\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     public void testConstant() {\n         assertEquals(0L, Duration.ZERO.getTotalMillis());\n-        assertEquals(DurationType.getMillisType(), Duration.ZERO.getDurationType());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testWithDurationType1() {\n+        assertEquals(DurationType.getAllType(), Duration.ZERO.getDurationType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithDurationTypeUsingTotalMillis1() {\n         Duration test = new Duration(123L);\n-        Duration result = test.withDurationType(DurationType.getMillisType());\n+        Duration result = test.withDurationTypeUsingTotalMillis(DurationType.getAllType());\n         assertSame(test, result);\n     }\n \n-    public void testWithDurationType2() {\n+    public void testWithDurationTypeUsingTotalMillis2() {\n         Duration test = new Duration(3123L);\n-        Duration result = test.withDurationType(DurationType.getDayHourType());\n+        Duration result = test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n         assertEquals(DurationType.getDayHourType(), result.getDurationType());\n     }\n \n-    public void testWithDurationType3() {\n+    public void testWithDurationTypeUsingTotalMillis3() {\n         Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n         try {\n-            test.withDurationType(DurationType.getDayHourType());\n+            test.withDurationTypeUsingTotalMillis(DurationType.getDayHourType());\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n-    public void testWithDurationType4() {\n+    public void testWithDurationTypeUsingTotalMillis4() {\n         Duration test = new Duration(3123L);\n-        Duration result = test.withDurationType(null);\n+        Duration result = test.withDurationTypeUsingTotalMillis(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n         assertEquals(3123L, result.getTotalMillis());\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testWithDurationTypeUsingFields1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.withDurationTypeUsingFields(DurationType.getAllType());\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithDurationTypeUsingFields2() {\n+        Duration test = new Duration(3123L);\n+        Duration result = test.withDurationTypeUsingFields(DurationType.getDayHourType());\n+        assertEquals(3, result.getSeconds());\n+        assertEquals(123, result.getMillis());\n+        assertEquals(3123L, result.getTotalMillis());\n+        assertEquals(DurationType.getDayHourType(), result.getDurationType());\n+    }\n+\n+    public void testWithDurationTypeUsingFields3() {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        try {\n+            test.withDurationTypeUsingFields(DurationType.getDayHourType());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testWithDurationTypeUsingFields4() {\n+        Duration test = new Duration(3123L);\n+        Duration result = test.withDurationTypeUsingFields(null);\n+        assertEquals(3, result.getSeconds());\n+        assertEquals(123, result.getMillis());\n+        assertEquals(3123L, result.getTotalMillis());\n+        assertEquals(DurationType.getAllType(), result.getDurationType());\n+    }\n+\n+    public void testWithDurationTypeUsingFields5() {\n+        Duration test = new Duration(1, 2, 0, 4, 5, 6, 7, 8, DurationType.getAllType());\n+        Duration result = test.withDurationTypeUsingFields(DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), result.getDurationType());\n+        assertEquals(1, result.getYears());\n+        assertEquals(2, result.getMonths());\n+        assertEquals(0, result.getWeeks());\n+        assertEquals(4, result.getDays());\n+        assertEquals(5, result.getHours());\n+        assertEquals(6, result.getMinutes());\n+        assertEquals(7, result.getSeconds());\n+        assertEquals(8, result.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldsNormalized1() {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getPreciseAllType());\n+        Duration result = test.withFieldsNormalized();\n+        assertEquals(1, result.getYears());\n+        assertEquals(2, result.getMonths());\n+        assertEquals(3, result.getWeeks());\n+        assertEquals(4, result.getDays());\n+        assertEquals(5, result.getHours());\n+        assertEquals(7, result.getMinutes());\n+        assertEquals(1, result.getSeconds());\n+        assertEquals(8, result.getMillis());\n+    }\n+\n+    public void testWithFieldsNormalized2() {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 61, 8, DurationType.getAllType());\n+        try {\n+            test.withFieldsNormalized();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testImmutable() {\n         MockChangeDuration test = new MockChangeDuration(111L);\n         test.testSetDuration_RD();\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n     /**\n      * Test constructor ()\n      */\n-    public void testConstructor1() throws Throwable {\n-        Duration test = new Duration();\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+    public void testZERO() throws Throwable {\n+        Duration test = Duration.ZERO;\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (DurationType)\n-     */\n-    public void testConstructor_DurationType1() throws Throwable {\n-        Duration test = new Duration(DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_DurationType2() throws Throwable {\n-        Duration test = new Duration((DurationType) null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (Object)\n-     */\n-    public void testConstructor_Object1() throws Throwable {\n-        Duration test = new Duration(\"P1Y2M3D\");\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(3, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.getTotalMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_Object2() throws Throwable {\n-        Duration test = new Duration((Object) null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object3() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object4() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration base = new Duration(dt1, dt2);  // AllType and precise\n-        Duration test = new Duration(base);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (Object)\n-     */\n-    public void testConstructor_Object_DurationType1() throws Throwable {\n-        Duration test = new Duration(\"P1Y2M3D\", DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(3, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.getTotalMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_Object_DurationType2() throws Throwable {\n-        Duration test = new Duration((Object) null, DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object_DurationType3() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object_DurationType4() throws Throwable {\n-        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (5ints)\n-     */\n-    public void testConstructor_5int1() throws Throwable {\n-        Duration test = new Duration(4, 5, 6, 7, 8);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+    public void testConstructor_long1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n         assertEquals(true, test.isPrecise());\n-        assertEquals(4 * DateTimeConstants.MILLIS_PER_DAY +\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_DurationType1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getMillisType());\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(length, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getDayHourType());\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType4() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getAllType().withMillisRemoved());\n+        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length - 8, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (4ints)\n+     */\n+    public void testConstructor_4int1() throws Throwable {\n+        Duration test = new Duration(5, 6, 7, 8);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(\n             5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long1() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object1() throws Throwable {\n+        Duration test = new Duration(\"P1Y2M3D\");\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n         assertEquals(0, test.getHours());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testConstructor_long_DurationType1() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_Object2() throws Throwable {\n+        Duration test = new Duration((Object) null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getHours());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType2() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getMillisType());\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object3() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object4() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration base = new Duration(dt1, dt2);  // AllType and precise\n+        Duration test = new Duration(base);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object_DurationType1() throws Throwable {\n+        Duration test = new Duration(\"P1Y2M3D\", DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n         assertEquals(0, test.getHours());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType3() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType4() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Duration test = new Duration(length, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length - 8, test.getTotalMillis());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_Object_DurationType2() throws Throwable {\n+        Duration test = new Duration((Object) null, DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType3() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType4() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Basics.java\n     //-----------------------------------------------------------------------\n     public void testGetDurationType() {\n         MutableDuration test = new MutableDuration();\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+    }\n+\n+    public void testGetIsTotalMillisBased() {\n+        MutableDuration test = new MutableDuration(123L);\n+        assertEquals(false, test.isTotalMillisBased());\n+        test = new MutableDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testGetTotalMillis() {\n     \n     class MockMutableDuration extends AbstractDuration {\n         public MockMutableDuration(long value) {\n-            super(value, null);\n+            super(value, null, false);\n+        }\n+        protected DurationType checkDurationType(DurationType type) {\n+            return DurationType.getAllType();\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Constructors.java\n      */\n     public void testConstructor1() throws Throwable {\n         MutableDuration test = new MutableDuration();\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(0, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(0, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(0, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_DurationType2() throws Throwable {\n         MutableDuration test = new MutableDuration((DurationType) null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (Object)\n-     */\n-    public void testConstructor_Object1() throws Throwable {\n-        MutableDuration test = new MutableDuration(\"P1Y2M3D\");\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(3, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n+    public void testConstructor_DurationType_boolean1() throws Throwable {\n+        MutableDuration test = new MutableDuration(null, true);\n+        assertEquals(DurationType.getPreciseAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0L, test.getTotalMillis());\n+        assertEquals(true, test.isTotalMillisBased());\n+    }\n+\n+    public void testConstructor_DurationType_boolean2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(null, false);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0L, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n+    }\n+\n+    public void testConstructor_DurationType_boolean3() throws Throwable {\n         try {\n-            test.getTotalMillis();\n+            new MutableDuration(DurationType.getAllType(), true);\n             fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_Object2() throws Throwable {\n-        MutableDuration test = new MutableDuration((Object) null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object3() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object4() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration base = new Duration(dt1, dt2);  // AllType and precise\n-        MutableDuration test = new MutableDuration(base);\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(1, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(1, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (Object)\n-     */\n-    public void testConstructor_Object_DurationType1() throws Throwable {\n-        MutableDuration test = new MutableDuration(\"P1Y2M3D\", DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(3, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.getTotalMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testConstructor_Object_DurationType2() throws Throwable {\n-        MutableDuration test = new MutableDuration((Object) null, DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object_DurationType3() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n-        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_Object_DurationType4() throws Throwable {\n-        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(2, test.getMinutes());\n-        assertEquals(3, test.getSeconds());\n-        assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Test constructor (5ints)\n-     */\n-    public void testConstructor_5int1() throws Throwable {\n-        MutableDuration test = new MutableDuration(4, 5, 6, 7, 8);\n-        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(length);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n         assertEquals(true, test.isPrecise());\n-        assertEquals(4 * DateTimeConstants.MILLIS_PER_DAY +\n+        assertEquals(length, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_DurationType1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(length, null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n+    }\n+\n+    public void testConstructor_long_DurationType2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(length, DurationType.getMillisType());\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(length, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(length, DurationType.getAllType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType4() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutableDuration test = new MutableDuration(length, DurationType.getAllType().withMillisRemoved());\n+        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length - 8, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (4ints)\n+     */\n+    public void testConstructor_4int1() throws Throwable {\n+        MutableDuration test = new MutableDuration(5, 6, 7, 8);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(\n             5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n             7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     //-----------------------------------------------------------------------\n             test.getTotalMillis();\n             fail();\n         } catch (IllegalStateException ex) {}\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     //-----------------------------------------------------------------------\n             test.getTotalMillis();\n             fail();\n         } catch (IllegalStateException ex) {}\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_8int__DurationType2() throws Throwable {\n         assertEquals(1, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         assertEquals(1, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_long_long_DurationType2() throws Throwable {\n         assertEquals(1, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_RI_RI2() throws Throwable {\n         assertEquals(1, test.getMillis());\n         assertEquals(true, test.isPrecise());\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+        assertEquals(false, test.isTotalMillisBased());\n     }\n \n     public void testConstructor_RI_RI_DurationType2() throws Throwable {\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor_long1() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testConstructor_long_DurationType1() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, null);\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType2() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getMillisType());\n-        assertEquals(DurationType.getMillisType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType3() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getAllType());\n-        assertEquals(DurationType.getAllType(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.getTotalMillis());\n-    }\n-\n-    public void testConstructor_long_DurationType4() throws Throwable {\n-        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n-                5 * DateTimeConstants.MILLIS_PER_HOUR +\n-                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutableDuration test = new MutableDuration(length, DurationType.getAllType().withMillisRemoved());\n-        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length - 8, test.getTotalMillis());\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object1() throws Throwable {\n+        MutableDuration test = new MutableDuration(\"P1Y2M3D\");\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        assertEquals(false, test.isTotalMillisBased());\n+    }\n+\n+    public void testConstructor_Object2() throws Throwable {\n+        MutableDuration test = new MutableDuration((Object) null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object3() throws Throwable {\n+        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object4() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration base = new Duration(dt1, dt2);  // AllType and precise\n+        MutableDuration test = new MutableDuration(base);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object_DurationType1() throws Throwable {\n+        MutableDuration test = new MutableDuration(\"P1Y2M3D\", DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        assertEquals(false, test.isTotalMillisBased());\n+    }\n+\n+    public void testConstructor_Object_DurationType2() throws Throwable {\n+        MutableDuration test = new MutableDuration((Object) null, DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType3() throws Throwable {\n+        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType4() throws Throwable {\n+        MutableDuration test = new MutableDuration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestMutableDuration_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDuration_Updates.java\n     }\n \n     public void testSetDuration_8ints2() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n         try {\n             test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);\n             fail();\n     }\n \n     public void testSetDuration_8ints3() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n         test.setDuration(0, 0, 0, 0, 0, 0, 0, 18);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testSetDuration_RD2() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n         try {\n             test.setDuration(new MutableDuration(11, 12, 13, 14, 15, 16, 17, 18));\n             fail();\n     }\n \n     public void testSetDuration_RD3() {\n-        MutableDuration test = new MutableDuration(100L);\n+        MutableDuration test = new MutableDuration(100L, DurationType.getMillisType());\n         test.setDuration(new MutableDuration(0, 0, 0, 0, 0, 0, 0, 18));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     }\n \n     public void testNormalize2() {\n-        MutableDuration test = new MutableDuration(1, 14, 0, 34, 29, 66, 67, 1008, DurationType.getPreciseYearMonthType());\n+        MutableDuration test = new MutableDuration(1, 14, 0, 36, 29, 66, 67, 1008, DurationType.getPreciseYearMonthType());\n+        //   365 + 14*30 + 6 days\n+        // extra year created from 12 months of 30 days plus 5 extra days\n+        // 2*365 +  2*30 + 1 day\n         test.normalize();\n         assertEquals(2, test.getYears());\n         assertEquals(3, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(5, test.getDays());\n+        assertEquals(2, test.getDays());\n         assertEquals(6, test.getHours());\n         assertEquals(7, test.getMinutes());\n         assertEquals(8, test.getSeconds());\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n     }\n \n     public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getMillisType(), NullConverter.INSTANCE.getDurationType(null));\n+        assertEquals(null, NullConverter.INSTANCE.getDurationType(null));\n     }\n \n     public void testIsPrecise_Object() throws Exception {\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n     }\n \n     public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getMillisType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(123L)));\n+        assertEquals(DurationType.getMillisType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(123L, DurationType.getMillisType())));\n         assertEquals(DurationType.getAllType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(1, 2, 0, 1, 0, 0, 0, 0)));\n     }\n ", "timestamp": 1091389062, "metainfo": ""}