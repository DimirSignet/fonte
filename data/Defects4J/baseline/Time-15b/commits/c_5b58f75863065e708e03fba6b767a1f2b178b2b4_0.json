{"sha": "5b58f75863065e708e03fba6b767a1f2b178b2b4", "log": "Changed comments to reference 'period' instead of 'duration'   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormat.java\n \n /**\n  * PeriodFormat provides basic printing and parsing capabilities for\n- * durations. Eventually, this class will also support localization.\n+ * periods. Eventually, this class will also support localization.\n  * <p>\n  * PeriodFormat is thread-safe and immutable, and the formatters it returns\n  * are as well.\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n     private int iMaxParsedDigits;\n     private boolean iRejectSignedValues;\n \n-    private DurationFieldAffix iPrefix;\n+    private PeriodFieldAffix iPrefix;\n \n     // List of PeriodFormatters used to build a final formatter.\n     private List iFormatters;\n \n     /**\n      * Print zero values for the next and following appened fields only if the\n-     * duration supports it.\n+     * period supports it.\n      *\n      * @return this PeriodFormatterBuilder\n      */\n \n     /**\n      * Always print zero values for the next and following appended fields,\n-     * even if the duration doesn't support it. The parser requires values for\n+     * even if the period doesn't support it. The parser requires values for\n      * fields that always print zero.\n      *\n      * @return this PeriodFormatterBuilder\n      * @return this PeriodFormatterBuilder\n      * @see #appendSuffix\n      */\n-    private PeriodFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n+    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n         if (prefix == null) {\n             throw new IllegalArgumentException();\n         }\n      * @throws IllegalStateException if no field exists to append to\n      * @see #appendPrefix\n      */\n-    private PeriodFormatterBuilder appendSuffix(DurationFieldAffix suffix) {\n+    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n         final Object originalField;\n         if (iFormatters.size() > 0) {\n             originalField = iFormatters.get(iFormatters.size() - 1);\n      * selected.\n      * <p>\n      * It starts from the last appended field, and moves towards the first,\n-     * stopping until it finds a field that is supported by the duration being\n+     * stopping until it finds a field that is supported by the period being\n      * printed. If no supported fields are found, then no fields are printed.\n      * <p>\n      * This setting is the default.\n      * selected.\n      * <p>\n      * It starts from the first appended field, and moves towards the last,\n-     * stopping until it finds a field that is supported by the duration being\n+     * stopping until it finds a field that is supported by the period being\n      * printed. If no supported fields are found, then no fields are printed.\n      *\n      * @return this PeriodFormatterBuilder\n      * Defines a formatted field's prefix or suffix text.\n      * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n      */\n-    private static interface DurationFieldAffix {\n+    private static interface PeriodFieldAffix {\n         int calculatePrintedLength(int value);\n         \n         void printTo(StringBuffer buf, int value);\n         /**\n          * @return new position after parsing affix, or ~position of failure\n          */\n-        int parse(String durationStr, int position);\n+        int parse(String periodStr, int position);\n \n         /**\n          * @return position where affix starts, or original ~position if not found\n          */\n-        int scan(String durationStr, int position);\n+        int scan(String periodStr, int position);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Implements an affix where the text does not vary by the amount.\n      */\n-    private static final class SimpleAffix implements DurationFieldAffix {\n+    private static final class SimpleAffix implements PeriodFieldAffix {\n         private final String iText;\n \n         SimpleAffix(String text) {\n             out.write(iText);\n         }\n \n-        public int parse(String durationStr, int position) {\n+        public int parse(String periodStr, int position) {\n             String text = iText;\n             int textLength = text.length();\n-            if (durationStr.regionMatches(true, position, text, 0, textLength)) {\n+            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                 return position + textLength;\n             }\n             return ~position;\n         }\n \n-        public int scan(String durationStr, final int position) {\n+        public int scan(String periodStr, final int position) {\n             String text = iText;\n             int textLength = text.length();\n-            int sourceLength = durationStr.length();\n+            int sourceLength = periodStr.length();\n             for (int pos = position; pos < sourceLength; pos++) {\n-                if (durationStr.regionMatches(true, pos, text, 0, textLength)) {\n+                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                     return pos;\n                 }\n             }\n      * Implements an affix where the text varies by the amount of the field.\n      * Only singular (1) and plural (not 1) are supported.\n      */\n-    private static final class PluralAffix implements DurationFieldAffix {\n+    private static final class PluralAffix implements PeriodFieldAffix {\n         private final String iSingularText;\n         private final String iPluralText;\n \n             out.write(value == 1 ? iSingularText : iPluralText);\n         }\n \n-        public int parse(String durationStr, int position) {\n+        public int parse(String periodStr, int position) {\n             String text1 = iPluralText;\n             String text2 = iSingularText; \n \n                 text2 = temp;\n             }\n \n-            if (durationStr.regionMatches\n+            if (periodStr.regionMatches\n                 (true, position, text1, 0, text1.length())) {\n                 return position + text1.length();\n             }\n-            if (durationStr.regionMatches\n+            if (periodStr.regionMatches\n                 (true, position, text2, 0, text2.length())) {\n                 return position + text2.length();\n             }\n             return ~position;\n         }\n \n-        public int scan(String durationStr, final int position) {\n+        public int scan(String periodStr, final int position) {\n             String text1 = iPluralText;\n             String text2 = iSingularText; \n \n             int textLength1 = text1.length();\n             int textLength2 = text2.length();\n \n-            int sourceLength = durationStr.length();\n+            int sourceLength = periodStr.length();\n             for (int pos = position; pos < sourceLength; pos++) {\n-                if (durationStr.regionMatches(true, pos, text1, 0, textLength1)) {\n+                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                     return pos;\n                 }\n-                if (durationStr.regionMatches(true, pos, text2, 0, textLength2)) {\n+                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                     return pos;\n                 }\n             }\n     /**\n      * Builds a composite affix by merging two other affix implementations.\n      */\n-    private static final class CompositeAffix implements DurationFieldAffix {\n-        private final DurationFieldAffix iLeft;\n-        private final DurationFieldAffix iRight;\n-\n-        CompositeAffix(DurationFieldAffix left, DurationFieldAffix right) {\n+    private static final class CompositeAffix implements PeriodFieldAffix {\n+        private final PeriodFieldAffix iLeft;\n+        private final PeriodFieldAffix iRight;\n+\n+        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n             iLeft = left;\n             iRight = right;\n         }\n             iRight.printTo(out, value);\n         }\n \n-        public int parse(String durationStr, int position) {\n-            position = iLeft.parse(durationStr, position);\n+        public int parse(String periodStr, int position) {\n+            position = iLeft.parse(periodStr, position);\n             if (position >= 0) {\n-                position = iRight.parse(durationStr, position);\n+                position = iRight.parse(periodStr, position);\n             }\n             return position;\n         }\n \n-        public int scan(String durationStr, final int position) {\n-            int pos = iLeft.scan(durationStr, position);\n+        public int scan(String periodStr, final int position) {\n+            int pos = iLeft.scan(periodStr, position);\n             if (pos >= 0) {\n-                return iRight.scan(durationStr, pos);\n+                return iRight.scan(periodStr, pos);\n             }\n             return ~position;\n         }\n \n         private final int iFieldType;\n \n-        private final DurationFieldAffix iPrefix;\n-        private final DurationFieldAffix iSuffix;\n+        private final PeriodFieldAffix iPrefix;\n+        private final PeriodFieldAffix iSuffix;\n \n         FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                        int maxParsedDigits, boolean rejectSignedValues,\n-                       int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {\n+                       int fieldType, PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n             iMinPrintedDigits = minPrintedDigits;\n             iPrintZeroSetting = printZeroSetting;\n             iMaxParsedDigits = maxParsedDigits;\n             iSuffix = suffix;\n         }\n \n-        FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {\n+        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n             iMinPrintedDigits = field.iMinPrintedDigits;\n             iPrintZeroSetting = field.iPrintZeroSetting;\n             iMaxParsedDigits = field.iMaxParsedDigits;\n                 sum++;\n             }\n \n-            DurationFieldAffix affix;\n+            PeriodFieldAffix affix;\n             if ((affix = iPrefix) != null) {\n                 sum += affix.calculatePrintedLength(value);\n             }\n             }\n             int value = (int)valueLong;\n \n-            DurationFieldAffix affix;\n+            PeriodFieldAffix affix;\n             if ((affix = iPrefix) != null) {\n                 affix.printTo(buf, value);\n             }\n             }\n             int value = (int)valueLong;\n \n-            DurationFieldAffix affix;\n+            PeriodFieldAffix affix;\n             if ((affix = iPrefix) != null) {\n                 affix.printTo(out, value);\n             }\n--- a/JodaTime/src/java/org/joda/time/format/PeriodParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodParser.java\n \n     /**\n      * Parses a period from the given text, at the given position, saving the\n-     * result into the fields of the given ReadWritableDuration. If the parse\n+     * result into the fields of the given ReadWritablePeriod. If the parse\n      * succeeds, the return value is the new text position. Note that the parse\n      * may succeed without fully reading the text.\n      * <p>\n      *\n      * @param type  defines which fields may be parsed\n      * @param periodStr  text to parse\n-     * @return parsed value in a Duration object\n+     * @return parsed value in a Period object\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     Period parsePeriod(PeriodType type, String periodStr);\n      *\n      * @param type  defines which fields may be parsed\n      * @param periodStr  text to parse\n-     * @return parsed value in a MutableDuration object\n+     * @return parsed value in a MutablePeriod object\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     MutablePeriod parseMutablePeriod(PeriodType type, String periodStr);\n--- a/JodaTime/src/java/org/joda/time/format/PeriodPrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodPrinter.java\n public interface PeriodPrinter {\n \n     /**\n-     * Returns the amount of fields from the given duration that this printer\n+     * Returns the amount of fields from the given period that this printer\n      * will print.\n      * \n      * @param period  the period to use\n     int countFieldsToPrint(ReadablePeriod period);\n \n     /**\n-     * Returns the amount of fields from the given duration that this printer\n+     * Returns the amount of fields from the given period that this printer\n      * will print.\n      * \n      * @param period  the period to use\n     int countFieldsToPrint(ReadablePeriod period, int stopAt);\n \n     /**\n-     * Returns the exact number of characters produced for the given duration.\n+     * Returns the exact number of characters produced for the given period.\n      * \n      * @param period  the period to use\n      * @return the estimated length", "timestamp": 1093401683, "metainfo": ""}