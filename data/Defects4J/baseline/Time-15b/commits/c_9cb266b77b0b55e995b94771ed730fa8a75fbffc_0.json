{"sha": "9cb266b77b0b55e995b94771ed730fa8a75fbffc", "log": "Performance enhancement to comparison of LocalDate, LocalTime and LocalDateTime suggested by Francois Staes  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this LocalDate to a full datetime at midnight using the\n-     * default time zone.\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalDate) {\n+            LocalDate other = (LocalDate) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalDate) {\n+            LocalDate other = (LocalDate) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a full datetime at midnight using the default\n+     * time zone.\n      * <p>\n      * This instance is immutable and unaffected by this method call.\n-     *\n+     * \n      * @return this date as a datetime at midnight\n      */\n     public DateTime toDateTimeAtMidnight() {\n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalDateTime) {\n+            LocalDateTime other = (LocalDateTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalDateTime) {\n+            LocalDateTime other = (LocalDateTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Converts this object to a DateTime using the default zone.\n      * \n      * @return <code>this</code>\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalTime) {\n+            LocalTime other = (LocalTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalTime) {\n+            LocalTime other = (LocalTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns a copy of this time with different local millis.\n      * <p>\n      * The returned object will be a new instance of the same type.\n--- a/JodaTime/src/test/org/joda/time/TestLocalDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDateTime_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockInstant()));\n-        assertEquals(false, test1.equals(new YearMonthDay(1970, 6, 9, COPTIC_PARIS)));\n+        Partial partial = new Partial(\n+                new DateTimeFieldType[] {\n+                        DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(),\n+                        DateTimeFieldType.dayOfMonth(), DateTimeFieldType.millisOfDay()},\n+                new int[] {1970, 6, 9, MILLIS_OF_DAY_UTC}, COPTIC_PARIS);\n+        assertEquals(true, test1.equals(partial));\n+        assertEquals(true, test1.hashCode() == partial.hashCode());\n         assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n     \n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockInstant()));\n         assertEquals(true, test1.equals(new YearMonthDay(1970, 6, 9, COPTIC_PARIS)));\n+        assertEquals(true, test1.hashCode() == new YearMonthDay(1970, 6, 9, COPTIC_PARIS).hashCode());\n         assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalTime_Basics.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new TimeOfDay(10, 20, 30, 40, COPTIC_UTC)));\n+        assertEquals(true, test1.hashCode() == new TimeOfDay(10, 20, 30, 40, COPTIC_UTC).hashCode());\n         assertEquals(true, test1.equals(new MockInstant()));\n         assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }", "timestamp": 1172450618, "metainfo": ""}