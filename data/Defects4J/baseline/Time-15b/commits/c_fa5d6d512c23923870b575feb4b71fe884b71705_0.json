{"sha": "fa5d6d512c23923870b575feb4b71fe884b71705", "log": "New factory methods to create YearMonthDay/TimeOfDay from Date/Calendar fields   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n import java.util.Locale;\n \n import org.joda.time.base.BasePartial;\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Constructs a TimeOfDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the TimeOfDay.\n+     * This is useful to ensure that the field values are the same in the\n+     * created TimeOfDay no matter what the time zone is. For example, if\n+     * the Calendar states that the time is 04:29, then the created TimeOfDay\n+     * will always have the time 04:29 irrespective of time zone issues.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a TimeOfDay with ISO chronology.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created TimeOfDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the time is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static TimeOfDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new TimeOfDay(\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the TimeOfDay.\n+     * This is useful to ensure that the field values are the same in the\n+     * created TimeOfDay no matter what the time zone is. For example, if\n+     * the Calendar states that the time is 04:29, then the created TimeOfDay\n+     * will always have the time 04:29 irrespective of time zone issues.\n+     * <p>\n+     * This factory method always creates a TimeOfDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created TimeOfDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static TimeOfDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new TimeOfDay(\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (int) (date.getTime() % 1000)\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Constructs a TimeOfDay from the specified millis of day using the\n      * ISO chronology.\n      * <p>\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n import java.util.Locale;\n \n import org.joda.time.base.BasePartial;\n     /** The index of the dayOfMonth field in the field array */\n     public static final int DAY_OF_MONTH = 2;\n \n-    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonthDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the YearMonthDay.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a YearMonthDay with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created YearMonthDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static YearMonthDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new YearMonthDay(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the YearMonthDay.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method always creates a YearMonthDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created YearMonthDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static YearMonthDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new YearMonthDay(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate()\n+        );\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs a YearMonthDay with the current date, using ISOChronology in\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testFactory_FromCalendarFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        TimeOfDay expected = new TimeOfDay(4, 5, 6, 7);\n+        assertEquals(expected, TimeOfDay.fromCalendarFields(cal));\n+        try {\n+            TimeOfDay.fromCalendarFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromDateFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        TimeOfDay expected = new TimeOfDay(4, 5, 6, 7);\n+        assertEquals(expected, TimeOfDay.fromDateFields(cal.getTime()));\n+        try {\n+            TimeOfDay.fromDateFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Test factory (long)\n      */\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Constructors.java\n  */\n package org.joda.time;\n \n+import java.util.Calendar;\n import java.util.Date;\n+import java.util.GregorianCalendar;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testFactory_FromCalendarFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        YearMonthDay expected = new YearMonthDay(1970, 2, 3);\n+        assertEquals(expected, YearMonthDay.fromCalendarFields(cal));\n+        try {\n+            YearMonthDay.fromCalendarFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_FromDateFields() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n+        cal.set(Calendar.MILLISECOND, 7);\n+        YearMonthDay expected = new YearMonthDay(1970, 2, 3);\n+        assertEquals(expected, YearMonthDay.fromDateFields(cal.getTime()));\n+        try {\n+            YearMonthDay.fromDateFields(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Test constructor ()\n      */", "timestamp": 1133744577, "metainfo": ""}