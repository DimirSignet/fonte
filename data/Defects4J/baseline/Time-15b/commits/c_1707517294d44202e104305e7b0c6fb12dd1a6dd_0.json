{"sha": "1707517294d44202e104305e7b0c6fb12dd1a6dd", "log": "Restored formatting interfaces to provide same functionality as v0.95.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n \n import java.io.IOException;\n import java.io.Writer;\n-import java.util.Arrays;\n-import java.util.Locale;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n-import org.joda.time.DateTimeField;\n-import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n  */\n public abstract class BaseDateTimeFormatter {\n \n+    // Since this class does not implement any interfaces, perform manual\n+    // virtual binding on all delegating calls. That is, if printTo calls\n+    // printTo with different arguments, it will bind to this class instead of\n+    // a virtual method on the DateTimePrinter interface. To accomplish this,\n+    // cast this to proper interface class first.\n+\n     public void printTo(StringBuffer buf, ReadableInstant instant) {\n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n-        printTo(buf, millis, chrono);\n+        ((DateTimePrinter) this).printTo(buf, millis, chrono);\n     }\n \n     public void printTo(Writer out, ReadableInstant instant) throws IOException {\n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n-        printTo(out, millis, chrono);\n+        ((DateTimePrinter) this).printTo(out, millis, chrono);\n     }\n \n     public void printTo(StringBuffer buf, long instant) {\n-        printTo(buf, instant, ISOChronology.getInstance());\n+        ((DateTimePrinter) this).printTo(buf, instant, ISOChronology.getInstance());\n     }\n \n     public void printTo(Writer out, long instant) throws IOException {\n-        printTo(out, instant, ISOChronology.getInstance());\n+        ((DateTimePrinter) this).printTo(out, instant, ISOChronology.getInstance());\n     }\n \n     public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n         zone = DateTimeUtils.getZone(zone);\n-        printTo(buf, instant, ISOChronology.getInstance(zone));\n+        ((DateTimePrinter) this).printTo(buf, instant, ISOChronology.getInstance(zone));\n     }\n \n     public void printTo(Writer out, long instant, DateTimeZone zone) throws IOException {\n         zone = DateTimeUtils.getZone(zone);\n-        printTo(out, instant, ISOChronology.getInstance(zone));\n+        ((DateTimePrinter) this).printTo(out, instant, ISOChronology.getInstance(zone));\n     }\n \n     public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n         chrono = DateTimeUtils.getChronology(chrono);\n-        printTo(buf,\n-                instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n-                instant, chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        ((DateTimePrinter) this).printTo(buf, instant + offset, chrono.withUTC(), offset, zone);\n     }\n \n     public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n         chrono = DateTimeUtils.getChronology(chrono);\n-        printTo(out,\n-                instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n-                instant, chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        ((DateTimePrinter) this).printTo(out, instant + offset, chrono.withUTC(), offset, zone);\n+    }\n+\n     public String print(ReadableInstant instant) {\n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n-        return print(millis, chrono);\n+        return ((DateTimePrinter) this).print(millis, chrono);\n     }\n \n     public String print(long instant) {\n-        return print(instant, ISOChronology.getInstance());\n+        return ((DateTimePrinter) this).print(instant, ISOChronology.getInstance());\n     }\n \n     public String print(long instant, DateTimeZone zone) {\n         zone = DateTimeUtils.getZone(zone);\n-        return print(instant, ISOChronology.getInstance(zone));\n+        return ((DateTimePrinter) this).print(instant, ISOChronology.getInstance(zone));\n     }\n \n     public String print(long instant, Chronology chrono) {\n         chrono = DateTimeUtils.getChronology(chrono);\n-        return print(instant + chrono.getZone().getOffset(instant), chrono.withUTC(),\n-                     instant, chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        return ((DateTimePrinter) this).print(instant + offset, chrono.withUTC(), offset, zone);\n+    }\n+\n+    public String print(long instant, Chronology chrono,\n+                        int displayOffset, DateTimeZone displayZone) {\n+        DateTimePrinter printer = (DateTimePrinter) this;\n+        StringBuffer buf = new StringBuffer(printer.estimatePrintedLength());\n+        printer.printTo(buf, instant, chrono, displayOffset, displayZone);\n+        return buf.toString();\n     }\n \n     public String print(ReadablePartial partial) {\n-        StringBuffer buf = new StringBuffer(estimatePrintedLength());\n-        printTo(buf, partial);\n-        return buf.toString();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    protected int estimatePrintedLength() {\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    protected void printTo(StringBuffer buf,\n-                           long instantLocal, Chronology chronoLocal,\n-                           long instant, Chronology chrono) {\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    protected void printTo(Writer out,\n-                           long instantLocal, Chronology chronoLocal,\n-                           long instant, Chronology chrono) throws IOException {\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    public void printTo(StringBuffer buf, ReadablePartial partial) {\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-        throw new UnsupportedOperationException(\"Printing not supported\");\n-    }\n-\n-    protected String print(long instantLocal, Chronology chronoLocal,\n-                           long instant, Chronology chrono) {\n-        StringBuffer buf = new StringBuffer(estimatePrintedLength());\n-        printTo(buf, instantLocal, chronoLocal, instant, chrono);\n+        DateTimePrinter printer = (DateTimePrinter) this;\n+        StringBuffer buf = new StringBuffer(printer.estimatePrintedLength());\n+        printer.printTo(buf, partial);\n         return buf.toString();\n     }\n \n         Chronology chrono = instant.getChronology();\n         long instantLocal = millis + chrono.getZone().getOffset(millis);\n \n-        ParseBucket bucket = new ParseBucket(instantLocal, chrono);\n-        int resultPos = parseInto(bucket, text, position);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+        int resultPos = ((DateTimeParser) this).parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis());\n         return resultPos;\n     }\n     }\n \n     public long parseMillis(String text, Chronology chrono) {\n-        ParseBucket bucket = new ParseBucket(0, chrono);\n-\n-        int newPos = parseInto(bucket, text, 0);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono);\n+\n+        int newPos = ((DateTimeParser) this).parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 return bucket.computeMillis(true);\n     }\n \n     public long parseMillis(String text, long instant) {\n-        return parseMillis(text, instant, ISOChronology.getInstance());\n+        return ((DateTimeParser) this).parseMillis(text, instant, ISOChronology.getInstance());\n     }\n \n     public long parseMillis(String text, long instant, Chronology chrono) {\n         chrono = DateTimeUtils.getChronology(chrono);\n         long instantLocal = instant + chrono.getZone().getOffset(instant);\n-        ParseBucket bucket = new ParseBucket(instantLocal, chrono);\n-\n-        int newPos = parseInto(bucket, text, 0);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono);\n+\n+        int newPos = ((DateTimeParser) this).parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 return bucket.computeMillis();\n     }\n \n     public DateTime parseDateTime(String text) {\n-        return parseDateTime(text, ISOChronology.getInstance());\n+        return ((DateTimeParser) this).parseDateTime(text, ISOChronology.getInstance());\n     }\n \n     public DateTime parseDateTime(String text, Chronology chrono) {\n-        return new DateTime(parseMillis(text, chrono), chrono);\n+        return new DateTime(((DateTimeParser) this).parseMillis(text, chrono), chrono);\n     }\n \n     public DateTime parseDateTime(String text, ReadableInstant instant) {\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n         long millis = DateTimeUtils.getInstantMillis(instant);\n-        return new DateTime(parseMillis(text, millis, chrono), chrono);\n+        return new DateTime(((DateTimeParser) this).parseMillis(text, millis, chrono), chrono);\n     }\n \n     public MutableDateTime parseMutableDateTime(String text) {\n-        return parseMutableDateTime(text, ISOChronology.getInstance());\n+        return ((DateTimeParser) this).parseMutableDateTime(text, ISOChronology.getInstance());\n     }\n \n     public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n-        return new MutableDateTime(parseMillis(text, chrono), chrono);\n+        return new MutableDateTime(((DateTimeParser) this).parseMillis(text, chrono), chrono);\n     }\n \n     public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n         long millis = DateTimeUtils.getInstantMillis(instant);\n-        return new MutableDateTime(parseMillis(text, millis, chrono), chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    protected int estimateParsedLength() {\n-        throw new UnsupportedOperationException(\"Parsing not supported\");\n-    }\n-\n-    protected int parseInto(ParseBucket bucket, String text, int position) {\n-        throw new UnsupportedOperationException(\"Parsing not supported\");\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Internal class used to build the state during parsing.\n-     * <p>\n-     * Allows fields to be saved in any order, but be physically set in a\n-     * consistent order. This is useful for parsing against formats that allow\n-     * field values to contradict each other.\n-     * <p>\n-     * Field values are applied in an order where the \"larger\" fields are set\n-     * first, making their value less likely to stick.  A field is larger than\n-     * another when it's range duration is longer. If both ranges are the same,\n-     * then the larger field has the longer duration. If it cannot be determined\n-     * which field is larger, then the fields are set in the order they were saved.\n-     * <p>\n-     * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n-     * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n-     * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n-     * <p>\n-     * ParseBucket is mutable and not thread-safe.\n-     *\n-     * @author Brian S O'Neill\n-     * @since 1.0\n-     */\n-    public static class ParseBucket {\n-\n-        private final Chronology iChrono;\n-        private final long iMillis;\n-\n-        // TimeZone to switch to in computeMillis. If null, use offset.\n-        DateTimeZone iZone;\n-        int iOffset;\n-\n-        SavedField[] iSavedFields = new SavedField[8];\n-        int iSavedFieldsCount;\n-        boolean iSavedFieldsShared;\n-\n-        private Object iSavedState;\n-\n-        /**\n-         * Constucts a bucket.\n-         * \n-         * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n-         * @param chrono  the chronology to use\n-         */\n-        public ParseBucket(long instantLocal, Chronology chrono) {\n-            super();\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            iMillis = instantLocal;\n-            iChrono = chrono.withUTC();\n-            setZone(chrono.getZone());\n-        }\n-\n-        //-----------------------------------------------------------------------\n-        /**\n-         * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n-         */\n-        public Chronology getChronology() {\n-            return iChrono;\n-        }\n-\n-        //-----------------------------------------------------------------------\n-        /**\n-         * Returns the time zone used by computeMillis, or null if an offset is\n-         * used instead.\n-         */\n-        public DateTimeZone getZone() {\n-            return iZone;\n-        }\n-\n-        /**\n-         * Set a time zone to be used when computeMillis is called, which\n-         * overrides any set time zone offset.\n-         *\n-         * @param zone the date time zone to operate in, or null if UTC\n-         */\n-        public void setZone(DateTimeZone zone) {\n-            iSavedState = null;\n-            iZone = zone == DateTimeZone.UTC ? null : zone;\n-            iOffset = 0;\n-        }\n-\n-        //-----------------------------------------------------------------------\n-        /**\n-         * Returns the time zone offset used by computeMillis, unless\n-         * getZone doesn't return null.\n-         */\n-        public int getOffset() {\n-            return iOffset;\n-        }\n-\n-        /**\n-         * Set a time zone offset to be used when computeMillis is called, which\n-         * overrides the time zone.\n-         */\n-        public void setOffset(int offset) {\n-            iSavedState = null;\n-            iOffset = offset;\n-            iZone = null;\n-        }\n-\n-        //-----------------------------------------------------------------------\n-        /**\n-         * Saves a datetime field value.\n-         * \n-         * @param field  the field, whose chronology must match that of this bucket\n-         * @param value  the value\n-         */\n-        public void saveField(DateTimeField field, int value) {\n-            saveField(new SavedField(field, value));\n-        }\n-\n-        /**\n-         * Saves a datetime field value.\n-         * \n-         * @param fieldType  the field type\n-         * @param value  the value\n-         */\n-        public void saveField(DateTimeFieldType fieldType, int value) {\n-            saveField(new SavedField(fieldType.getField(iChrono), value));\n-        }\n-\n-        /**\n-         * Saves a datetime field text value.\n-         * \n-         * @param fieldType  the field type\n-         * @param text  the text value\n-         * @param locale  the locale to use\n-         */\n-        public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n-            saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n-        }\n-\n-        private void saveField(SavedField field) {\n-            SavedField[] savedFields = iSavedFields;\n-            int savedFieldsCount = iSavedFieldsCount;\n-\n-            if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n-                // Expand capacity or merely copy if saved fields are shared.\n-                SavedField[] newArray = new SavedField\n-                    [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n-                System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n-                iSavedFields = savedFields = newArray;\n-                iSavedFieldsShared = false;\n-            }\n-\n-            iSavedState = null;\n-            savedFields[savedFieldsCount] = field;\n-            iSavedFieldsCount = savedFieldsCount + 1;\n-        }\n-\n-        /**\n-         * Saves the state of this bucket, returning it in an opaque object. Call\n-         * restoreState to undo any changes that were made since the state was\n-         * saved. Calls to saveState may be nested.\n-         *\n-         * @return opaque saved state, which may be passed to restoreState\n-         */\n-        public Object saveState() {\n-            if (iSavedState == null) {\n-                iSavedState = new SavedState();\n-            }\n-            return iSavedState;\n-        }\n-\n-        /**\n-         * Restores the state of this bucket from a previously saved state. The\n-         * state object passed into this method is not consumed, and it can be used\n-         * later to restore to that state again.\n-         *\n-         * @param savedState opaque saved state, returned from saveState\n-         * @return true state object is valid and state restored\n-         */\n-        public boolean restoreState(Object savedState) {\n-            if (savedState instanceof SavedState) {\n-                if (((SavedState) savedState).restoreState(this)) {\n-                    iSavedState = savedState;\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        /**\n-         * Computes the parsed datetime by setting the saved fields.\n-         * This method is idempotent, but it is not thread-safe.\n-         *\n-         * @return milliseconds since 1970-01-01T00:00:00Z\n-         * @throws IllegalArgumentException if any field is out of range\n-         */\n-        public long computeMillis() {\n-            return computeMillis(false);\n-        }\n-\n-        /**\n-         * Computes the parsed datetime by setting the saved fields.\n-         * This method is idempotent, but it is not thread-safe.\n-         *\n-         * @param resetFields false by default, but when true, unsaved field values are cleared\n-         * @return milliseconds since 1970-01-01T00:00:00Z\n-         * @throws IllegalArgumentException if any field is out of range\n-         */\n-        public long computeMillis(boolean resetFields) {\n-            SavedField[] savedFields = iSavedFields;\n-            int count = iSavedFieldsCount;\n-            if (iSavedFieldsShared) {\n-                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n-                iSavedFieldsShared = false;\n-            }\n-            sort(savedFields, count);\n-\n-            long millis = iMillis;\n-            for (int i=0; i<count; i++) {\n-                millis = savedFields[i].set(millis, resetFields);\n-            }\n-\n-            if (iZone == null) {\n-                millis -= iOffset;\n-            } else {\n-                int offset = iZone.getOffsetFromLocal(millis);\n-                millis -= offset;\n-                if (offset != iZone.getOffset(millis)) {\n-                    throw new IllegalArgumentException\n-                        (\"Illegal instant due to time zone offset transition\");\n-                }\n-            }\n-\n-            return millis;\n-        }\n-\n-        /**\n-         * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n-         * choice since it always creates an internal copy of the array, even if it\n-         * doesn't need to. If the array slice is small enough, an insertion sort\n-         * is chosen instead, but it doesn't need a copy!\n-         * <p>\n-         * This method has a modified version of that insertion sort, except it\n-         * doesn't create an unnecessary array copy. If high is over 10, then\n-         * java.util.Arrays is called, which will perform a merge sort, which is\n-         * faster than insertion sort on large lists.\n-         * <p>\n-         * The end result is much greater performace when computeMillis is called.\n-         * Since the amount of saved fields is small, the insertion sort is a\n-         * better choice. Additional performance is gained since there is no extra\n-         * array allocation and copying. Also, the insertion sort here does not\n-         * perform any casting operations. The version in java.util.Arrays performs\n-         * casts within the insertion sort loop.\n-         */\n-        private static void sort(Comparable[] array, int high) {\n-            if (high > 10) {\n-                Arrays.sort(array, 0, high);\n-            } else {\n-                for (int i=0; i<high; i++) {\n-                    for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n-                        Comparable t = array[j];\n-                        array[j] = array[j-1];\n-                        array[j-1] = t;\n-                    }\n-                }\n-            }\n-        }\n-\n-        class SavedState {\n-            final DateTimeZone iZone;\n-            final int iOffset;\n-            final SavedField[] iSavedFields;\n-            final int iSavedFieldsCount;\n-\n-            SavedState() {\n-                this.iZone = ParseBucket.this.iZone;\n-                this.iOffset = ParseBucket.this.iOffset;\n-                this.iSavedFields = ParseBucket.this.iSavedFields;\n-                this.iSavedFieldsCount = ParseBucket.this.iSavedFieldsCount;\n-            }\n-\n-            boolean restoreState(ParseBucket enclosing) {\n-                if (enclosing != ParseBucket.this) {\n-                    return false;\n-                }\n-                enclosing.iZone = this.iZone;\n-                enclosing.iOffset = this.iOffset;\n-                enclosing.iSavedFields = this.iSavedFields;\n-                if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n-                    // Since count is being restored to a lower count, the\n-                    // potential exists for new saved fields to destroy data being\n-                    // shared by another state. Set this flag such that the array\n-                    // of saved fields is cloned prior to modification.\n-                    enclosing.iSavedFieldsShared = true;\n-                }\n-                enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n-                return true;\n-            }\n-        }\n-\n-        static class SavedField implements Comparable {\n-            final DateTimeField iField;\n-            final int iValue;\n-            final String iText;\n-            final Locale iLocale;\n-\n-            SavedField(DateTimeField field, int value) {\n-                iField = field;\n-                iValue = value;\n-                iText = null;\n-                iLocale = null;\n-            }\n-\n-            SavedField(DateTimeField field, String text, Locale locale) {\n-                iField = field;\n-                iValue = 0;\n-                iText = text;\n-                iLocale = locale;\n-            }\n-\n-            long set(long millis, boolean reset) {\n-                if (iText == null) {\n-                    millis = iField.set(millis, iValue);\n-                } else {\n-                    millis = iField.set(millis, iText, iLocale);\n-                }\n-                if (reset) {\n-                    millis = iField.roundFloor(millis);\n-                }\n-                return millis;\n-            }\n-\n-            /**\n-             * The field with the longer range duration is ordered first, where\n-             * null is considered infinite. If the ranges match, then the field\n-             * with the longer duration is ordered first.\n-             */\n-            public int compareTo(Object obj) {\n-                DateTimeField other = ((SavedField)obj).iField;\n-                int result = compareReverse\n-                    (iField.getRangeDurationField(), other.getRangeDurationField());\n-                if (result != 0) {\n-                    return result;\n-                }\n-                return compareReverse\n-                    (iField.getDurationField(), other.getDurationField());\n-            }\n-\n-            private int compareReverse(Comparable a, Comparable b) {\n-                if (a == null) {\n-                    if (b == null) {\n-                        return 0;\n-                    }\n-                    return -1;\n-                }\n-                if (b == null) {\n-                    return 1;\n-                }\n-                return -a.compareTo(b);\n-            }\n-        }\n-    }\n-\n+        return new MutableDateTime\n+            (((DateTimeParser) this).parseMillis(text, millis, chrono), chrono);\n+    }\n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n      * A fake formatter that can only print.\n      */\n     static class FPrinter implements DateTimeFormatter {\n-        private final DateTimePrinter mPrinter;\n+        private final DateTimePrinter iPrinter;\n \n         FPrinter(DateTimePrinter printer) {\n             super();\n-            mPrinter = printer;\n+            iPrinter = printer;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iPrinter.estimatePrintedLength();\n         }\n \n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n-            mPrinter.printTo(buf, instant);\n+            iPrinter.printTo(buf, instant);\n         }\n \n         public void printTo(Writer out, ReadableInstant instant) throws IOException {\n-            mPrinter.printTo(out, instant);\n+            iPrinter.printTo(out, instant);\n         }\n \n         public void printTo(StringBuffer buf, long instant) {\n-            mPrinter.printTo(buf, instant);\n+            iPrinter.printTo(buf, instant);\n         }\n \n         public void printTo(Writer out, long instant) throws IOException {\n-            mPrinter.printTo(out, instant);\n+            iPrinter.printTo(out, instant);\n         }\n \n         public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {\n-            mPrinter.printTo(buf, instant, zone);\n+            iPrinter.printTo(buf, instant, zone);\n         }\n \n         public void printTo(Writer out, long instant, DateTimeZone zone)\n             throws IOException {\n-            mPrinter.printTo(out, instant, zone);\n+            iPrinter.printTo(out, instant, zone);\n         }\n \n         public void printTo(StringBuffer buf, long instant, Chronology chrono) {\n-            mPrinter.printTo(buf, instant, chrono);\n+            iPrinter.printTo(buf, instant, chrono);\n         }\n \n         public void printTo(Writer out, long instant, Chronology chrono) throws IOException {\n-            mPrinter.printTo(out, instant, chrono);\n+            iPrinter.printTo(out, instant, chrono);\n+        }\n+\n+        public void printTo(StringBuffer buf, long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            iPrinter.printTo(buf, instant, chrono, displayOffset, displayZone);\n+        }\n+\n+        public void printTo(Writer out, long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            iPrinter.printTo(out, instant, chrono, displayOffset, displayZone);\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial instant) {\n-            mPrinter.printTo(buf, instant);\n+            iPrinter.printTo(buf, instant);\n         }\n \n         public void printTo(Writer out, ReadablePartial instant) throws IOException {\n-            mPrinter.printTo(out, instant);\n+            iPrinter.printTo(out, instant);\n         }\n \n         public String print(ReadableInstant instant) {\n-            return mPrinter.print(instant);\n+            return iPrinter.print(instant);\n         }\n \n         public String print(long instant) {\n-            return mPrinter.print(instant);\n+            return iPrinter.print(instant);\n         }\n \n         public String print(long instant, DateTimeZone zone) {\n-            return mPrinter.print(instant, zone);\n+            return iPrinter.print(instant, zone);\n         }\n \n         public String print(long instant, Chronology chrono) {\n-            return mPrinter.print(instant, chrono);\n+            return iPrinter.print(instant, chrono);\n+        }\n+\n+        public String print(long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            return iPrinter.print(instant, chrono, displayOffset, displayZone);\n         }\n \n         public String print(ReadablePartial partial) {\n-            return mPrinter.print(partial);\n+            return iPrinter.print(partial);\n         }\n \n         public int estimateParsedLength() {\n             return 0;\n         }\n \n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            throw unsupported();\n+        }\n+\n         public int parseInto(ReadWritableInstant instant, String text, int position) {\n             throw unsupported();\n         }\n      * A fake formatter that can only parse.\n      */\n     static class FParser implements DateTimeFormatter {\n-        private final DateTimeParser mParser;\n+        private final DateTimeParser iParser;\n \n         FParser(DateTimeParser parser) {\n             super();\n-            mParser = parser;\n+            iParser = parser;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return 0;\n         }\n \n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n             throw unsupported();\n         }\n \n+        public void printTo(StringBuffer buf, long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            throw unsupported();\n+        }\n+\n         public void printTo(StringBuffer buf, ReadablePartial instant) {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        public String print(long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            throw unsupported();\n+        }\n+\n         public String print(ReadablePartial partial) {\n             throw unsupported();\n         }\n \n+        public int estimateParsedLength() {\n+            return iParser.estimateParsedLength();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            return iParser.parseInto(bucket, text, position);\n+        }\n+\n         public int parseInto(ReadWritableInstant instant, String text, int position) {\n-            return mParser.parseInto(instant, text, position);\n+            return iParser.parseInto(instant, text, position);\n         }\n \n         public long parseMillis(String text) {\n-            return mParser.parseMillis(text);\n+            return iParser.parseMillis(text);\n         }\n \n         public long parseMillis(String text, Chronology chrono) {\n-            return mParser.parseMillis(text, chrono);\n+            return iParser.parseMillis(text, chrono);\n         }\n \n         public long parseMillis(String text, long instant) {\n-            return mParser.parseMillis(text, instant);\n+            return iParser.parseMillis(text, instant);\n         }\n \n         public long parseMillis(String text, long instant, Chronology chrono) {\n-            return mParser.parseMillis(text, instant, chrono);\n+            return iParser.parseMillis(text, instant, chrono);\n         }\n \n         public DateTime parseDateTime(String text) {\n-            return mParser.parseDateTime(text);\n+            return iParser.parseDateTime(text);\n         }\n \n         public DateTime parseDateTime(String text, Chronology chrono) {\n-            return mParser.parseDateTime(text, chrono);\n+            return iParser.parseDateTime(text, chrono);\n         }\n \n         public DateTime parseDateTime(String text, ReadableInstant instant) {\n-            return mParser.parseDateTime(text, instant);\n+            return iParser.parseDateTime(text, instant);\n         }\n \n         public MutableDateTime parseMutableDateTime(String text) {\n-            return mParser.parseMutableDateTime(text);\n+            return iParser.parseMutableDateTime(text);\n         }\n \n         public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {\n-            return mParser.parseMutableDateTime(text, chrono);\n+            return iParser.parseMutableDateTime(text, chrono);\n         }\n \n         public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {\n-            return mParser.parseMutableDateTime(text, instant);\n+            return iParser.parseMutableDateTime(text, instant);\n         }\n \n         private UnsupportedOperationException unsupported() {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n  * Combined interface for printing and parsing.\n  * <p>\n  * See each extended interface for details of the methods.\n- * <p>\n- * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n- * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @since 1.0\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n /**\n  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.\n  * DateTimeFormatters can be built by appending specific fields or other\n- * formatters. All formatters must extend {@link BaseDateTimeFormatter}.\n+ * formatters.\n  *\n  * <p>\n  * For example, a formatter that prints month and year, like \"January 1970\",\n     //-----------------------------------------------------------------------\n     /**\n      * Appends another formatter.\n-     * <p>\n-     * The formatter must extend <code>DateTimeFormatterProvider</code>.\n-     * This is an internal class, which all supplied format classes extend.\n      *\n      * @param formatter  the formatter to add\n      * @return this DateTimeFormatterBuilder\n         if (formatter == null) {\n             throw new IllegalArgumentException(\"No formatter supplied\");\n         }\n-        if (formatter instanceof BaseDateTimeFormatter == false) {\n-            throw new IllegalArgumentException(\"Formatter must extend BaseDateTimeFormatter\");\n-        }\n         return append0(formatter);\n     }\n \n     /**\n      * Appends just a printer. With no matching parser, a parser cannot be\n      * built from this DateTimeFormatterBuilder.\n-     * <p>\n-     * The printer added must extend <code>BaseDateTimeFormatter</code>.\n-     * This is an internal class, which all supplied format classes extend.\n      *\n      * @param printer  the printer to add\n      * @return this DateTimeFormatterBuilder\n     /**\n      * Appends just a parser. With no matching printer, a printer cannot be\n      * built from this builder.\n-     * <p>\n-     * The parser added must extend <code>BaseDateTimeFormatter</code>.\n-     * This is an internal class, which all supplied format classes extend.\n      *\n      * @param parser  the parser to add\n      * @return this DateTimeFormatterBuilder\n \n     /**\n      * Appends a printer/parser pair.\n-     * <p>\n-     * The printer and parser must extend <code>BaseDateTimeFormatter</code>.\n-     * This is an internal class, which all supplied format classes extend.\n      *\n      * @param printer  the printer to add\n      * @param parser  the parser to add\n      * last of the parser array elements to be null. If the last element is\n      * null, this represents the empty parser. The presence of an empty parser\n      * indicates that the entire array of parse formats is optional.\n-     * <p>\n-     * The printer and parsers must extend <code>BaseDateTimeFormatter</code>.\n-     * This is an internal class, which all supplied format classes extend.\n      *\n      * @param printer  the printer to add\n      * @param parsers  the parsers to add\n             throw new IllegalArgumentException(\"No parsers supplied\");\n         }\n         int length = parsers.length;\n-        BaseDateTimeFormatter[] copyOfParsers = new BaseDateTimeFormatter[length];\n-        for (int i = 0; i < length; i++) {\n-            DateTimeParser parser = parsers[i];\n-            if (i == length - 1 && parser == null) {\n-                // ok\n-            } else {\n-                if (parser == null) {\n-                    throw new IllegalArgumentException(\"Incomplete parser array\");\n-                } else if (parser instanceof BaseDateTimeFormatter == false) {\n-                    throw new IllegalArgumentException(\"Parser must extend BaseDateTimeFormatter\");\n-                }\n-                copyOfParsers[i] = (BaseDateTimeFormatter) parser;\n-            }\n-        }\n-        \n+        if (length == 1) {\n+            if (parsers[0] == null) {\n+                throw new IllegalArgumentException(\"No parser supplied\");\n+            }\n+            return append0(printer, parsers[0]);\n+        }\n+\n+        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n+        int i;\n+        for (i = 0; i < length - 1; i++) {\n+            if ((copyOfParsers[i] = parsers[i]) == null) {\n+                throw new IllegalArgumentException(\"Incomplete parser array\");\n+            }\n+        }\n+        copyOfParsers[i] = parsers[i];\n+\n         return append0(printer, new MatchingParser(copyOfParsers));\n     }\n \n     /**\n      * Appends just a parser element which is optional. With no matching\n      * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n-     * <p>\n-     * The parser must implement <code>BaseDateTimeFormatter</code>.\n-     * This is an internal interface, which all supplied format classes implement.\n      *\n      * @return this DateTimeFormatterBuilder\n      * @throws IllegalArgumentException if parser is null or of an invalid type\n      */\n     public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n         checkParser(parser);\n-        BaseDateTimeFormatter[] parsers = new BaseDateTimeFormatter[] {\n-            (BaseDateTimeFormatter) parser, null};\n+        DateTimeFormatter[] parsers = new DateTimeFormatter[] {\n+            (DateTimeFormatter) parser, null\n+        };\n         return append0(null, new MatchingParser(parsers));\n     }\n \n         if (parser == null) {\n             throw new IllegalArgumentException(\"No parser supplied\");\n         }\n-        if (parser instanceof BaseDateTimeFormatter == false) {\n-            throw new IllegalArgumentException(\"Parser must extend BaseDateTimeFormatter\");\n-        }\n     }\n \n     /**\n     private void checkPrinter(DateTimePrinter printer) {\n         if (printer == null) {\n             throw new IllegalArgumentException(\"No printer supplied\");\n-        }\n-        if (printer instanceof BaseDateTimeFormatter == false) {\n-            throw new IllegalArgumentException(\"Printer must extend BaseDateTimeFormatter\");\n         }\n     }\n \n             return 1;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             buf.append(iValue);\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n             out.write(iValue);\n         }\n \n             out.write(iValue);\n         }\n \n-        protected String print(long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public String print(long instant, Chronology chrono,\n+                               int displayOffset, DateTimeZone displayZone) {\n             return String.valueOf(iValue);\n         }\n \n             return String.valueOf(iValue);\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return 1;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             if (position >= text.length()) {\n                 return ~position;\n             }\n             return iValue.length();\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             buf.append(iValue);\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n             out.write(iValue);\n         }\n \n             out.write(iValue);\n         }\n \n-        protected String print(long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public String print(long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             return iValue;\n         }\n \n             return iValue.length();\n         }\n \n-        public int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                 return position + iValue.length();\n             }\n             iSigned = signed;\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = Math.min(iMaxParsedDigits, text.length() - position);\n \n             boolean negative = false;\n             super(fieldType, maxParsedDigits, signed);\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             try {\n-                DateTimeField field = iFieldType.getField(chronoLocal);\n-                FormatUtils.appendUnpaddedInteger(buf, field.get(instantLocal));\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n             } catch (RuntimeException e) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n             try {\n-                DateTimeField field = iFieldType.getField(chronoLocal);\n-                FormatUtils.writeUnpaddedInteger(out, field.get(instantLocal));\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n             iMinPrintedDigits = minPrintedDigits;\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iMaxParsedDigits;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             try {\n-                DateTimeField field = iFieldType.getField(chronoLocal);\n-                FormatUtils.appendPaddedInteger(buf, field.get(instantLocal), iMinPrintedDigits);\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n                 appendUnknownString(buf, iMinPrintedDigits);\n             }\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n             try {\n-                DateTimeField field = iFieldType.getField(chronoLocal);\n-                FormatUtils.writePaddedInteger(out, field.get(instantLocal), iMinPrintedDigits);\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n             } catch (RuntimeException e) {\n                 printUnknownString(out, iMinPrintedDigits);\n             }\n             iPivot = pivot;\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return 2;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = Math.min(2, text.length() - position);\n             if (limit < 2) {\n                 return ~position;\n             return position + 2;\n         }\n         \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return 2;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            int year = getTwoDigitYear(instantLocal, chronoLocal);\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            int year = getTwoDigitYear(instant, chrono);\n             if (year < 0) {\n                 buf.append('\\ufffd');\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            int year = getTwoDigitYear(instantLocal, chronoLocal);\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            int year = getTwoDigitYear(instant, chrono);\n             if (year < 0) {\n                 out.write('\\ufffd');\n                 out.write('\\ufffd');\n             }\n         }\n \n-        private int getTwoDigitYear(long instantLocal, Chronology chronoLocal) {\n+        private int getTwoDigitYear(long instant, Chronology chrono) {\n             try {\n-                int year = chronoLocal.year().get(instantLocal);\n+                int year = chrono.year().get(instant);\n                 if (year < 0) {\n                     year = -year;\n                 }\n             iShort = isShort;\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iShort ? 6 : 20;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             try {\n-                buf.append(print(instantLocal, chronoLocal, instant, chrono));\n+                buf.append(print(instant, chrono, displayOffset, displayZone));\n             } catch (RuntimeException e) {\n                 buf.append('\\ufffd');\n             }\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n             try {\n-                out.write(print(instantLocal, chronoLocal, instant, chrono));\n+                out.write(print(instant, chrono, displayOffset, displayZone));\n             } catch (RuntimeException e) {\n                 out.write('\\ufffd');\n             }\n             }\n         }\n \n-        protected String print(long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            DateTimeField field = iFieldType.getField(chronoLocal);\n+        public String print(long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            DateTimeField field = iFieldType.getField(chrono);\n             if (iShort) {\n-                return field.getAsShortText(instantLocal, iLocale);\n+                return field.getAsShortText(instant, iLocale);\n             } else {\n-                return field.getAsText(instantLocal, iLocale);\n+                return field.getAsText(instant, iLocale);\n             }\n         }\n \n             }\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return estimatePrintedLength();\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = text.length();\n             int i = position;\n             for (; i<limit; i++) {\n             iMaxDigits = maxDigits;\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iMaxDigits;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             try {\n-                printTo(buf, null, instantLocal, chronoLocal);\n+                printTo(buf, null, instant, chrono);\n             } catch (IOException e) {\n                 // Not gonna happen.\n             }\n         }\n \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            printTo(null, out, instantLocal, chronoLocal);\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            printTo(null, out, instant, chrono);\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n             }\n         }\n \n-        protected void printTo(StringBuffer buf, Writer out, long instantLocal, Chronology chronoLocal)\n+        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n             throws IOException\n         {\n-            DateTimeField field = iFieldType.getField(chronoLocal);\n+            DateTimeField field = iFieldType.getField(chrono);\n             int minDigits = iMinDigits;\n \n             long fraction;\n             try {\n-                fraction = field.remainder(instantLocal);\n+                fraction = field.remainder(instant);\n             } catch (RuntimeException e) {\n                 if (buf != null) {\n                     appendUnknownString(buf, minDigits);\n             return new long[] {fraction * scalar / rangeMillis, maxDigits};\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return iMaxDigits;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             DateTimeField field = iFieldType.getField(bucket.getChronology());\n             \n             int limit = Math.min(iMaxDigits, text.length() - position);\n             iMaxFields = maxFields;\n         }\n             \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             int est = 1 + iMinFields << 1;\n             if (iShowSeparators) {\n                 est += iMinFields - 1;\n             return est;\n         }\n         \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            int offset = (int)(instantLocal - instant);\n-\n-            if (offset == 0 && iZeroOffsetText != null) {\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            if (displayOffset == 0 && iZeroOffsetText != null) {\n                 buf.append(iZeroOffsetText);\n                 return;\n             }\n-            if (offset >= 0) {\n+            if (displayOffset >= 0) {\n                 buf.append('+');\n             } else {\n                 buf.append('-');\n-                offset = -offset;\n-            }\n-\n-            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+                displayOffset = -displayOffset;\n+            }\n+\n+            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n             FormatUtils.appendPaddedInteger(buf, hours, 2);\n             if (iMaxFields == 1) {\n                 return;\n             }\n-            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n-            if (offset == 0 && iMinFields <= 1) {\n+            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (displayOffset == 0 && iMinFields <= 1) {\n                 return;\n             }\n \n-            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n             if (iShowSeparators) {\n                 buf.append(':');\n             }\n             if (iMaxFields == 2) {\n                 return;\n             }\n-            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n-            if (offset == 0 && iMinFields <= 2) {\n+            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (displayOffset == 0 && iMinFields <= 2) {\n                 return;\n             }\n \n-            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n             if (iShowSeparators) {\n                 buf.append(':');\n             }\n             if (iMaxFields == 3) {\n                 return;\n             }\n-            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n-            if (offset == 0 && iMinFields <= 3) {\n+            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (displayOffset == 0 && iMinFields <= 3) {\n                 return;\n             }\n \n             if (iShowSeparators) {\n                 buf.append('.');\n             }\n-            FormatUtils.appendPaddedInteger(buf, offset, 3);\n+            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n         }\n         \n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            int offset = (int)(instantLocal - instant);\n-\n-            if (offset == 0 && iZeroOffsetText != null) {\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            if (displayOffset == 0 && iZeroOffsetText != null) {\n                 out.write(iZeroOffsetText);\n                 return;\n             }\n-            if (offset >= 0) {\n+            if (displayOffset >= 0) {\n                 out.write('+');\n             } else {\n                 out.write('-');\n-                offset = -offset;\n-            }\n-\n-            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+                displayOffset = -displayOffset;\n+            }\n+\n+            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n             FormatUtils.writePaddedInteger(out, hours, 2);\n             if (iMaxFields == 1) {\n                 return;\n             }\n-            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n-            if (offset == 0 && iMinFields == 1) {\n+            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (displayOffset == 0 && iMinFields == 1) {\n                 return;\n             }\n \n-            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n             if (iShowSeparators) {\n                 out.write(':');\n             }\n             if (iMaxFields == 2) {\n                 return;\n             }\n-            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n-            if (offset == 0 && iMinFields == 2) {\n+            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (displayOffset == 0 && iMinFields == 2) {\n                 return;\n             }\n \n-            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n             if (iShowSeparators) {\n                 out.write(':');\n             }\n             if (iMaxFields == 3) {\n                 return;\n             }\n-            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n-            if (offset == 0 && iMinFields == 3) {\n+            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (displayOffset == 0 && iMinFields == 3) {\n                 return;\n             }\n \n             if (iShowSeparators) {\n                 out.write('.');\n             }\n-            FormatUtils.writePaddedInteger(out, offset, 3);\n+            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n             // no zone info\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return estimatePrintedLength();\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             int limit = text.length() - position;\n \n             zeroOffset:\n             iShortFormat = shortFormat;\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iShortFormat ? 4 : 20;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            buf.append(print(instantLocal, chronoLocal, instant, chrono));\n-        }\n-\n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            out.write(print(instantLocal, chronoLocal, instant, chrono));\n-        }\n-\n-        protected String print(long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            DateTimeZone zone = chrono.getZone();\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            buf.append(print(instant, chrono, displayOffset, displayZone));\n+        }\n+\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            out.write(print(instant, chrono, displayOffset, displayZone));\n+        }\n+\n+        public String print(long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n             if (iShortFormat) {\n-                return zone.getShortName(instant, this.iLocale);\n+                return displayZone.getShortName(instant, this.iLocale);\n             } else {\n-                return zone.getName(instant, this.iLocale);\n+                return displayZone.getName(instant, this.iLocale);\n             }\n         }\n \n             extends BaseDateTimeFormatter\n             implements DateTimeFormatter {\n \n-        private final BaseDateTimeFormatter[] iPrinters;\n-        private final BaseDateTimeFormatter[] iParsers;\n+        private final DateTimePrinter[] iPrinters;\n+        private final DateTimeParser[] iParsers;\n \n         private final int iPrintedLengthEstimate;\n         private final int iParsedLengthEstimate;\n                 iPrintedLengthEstimate = 0;\n             } else {\n                 int size = printerList.size();\n-                iPrinters = new BaseDateTimeFormatter[size];\n+                iPrinters = new DateTimePrinter[size];\n                 int printEst = 0;\n                 for (int i=0; i<size; i++) {\n-                    BaseDateTimeFormatter printer = (BaseDateTimeFormatter) printerList.get(i);\n+                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                     printEst += printer.estimatePrintedLength();\n                     iPrinters[i] = printer;\n                 }\n                 iParsedLengthEstimate = 0;\n             } else {\n                 int size = parserList.size();\n-                iParsers = new BaseDateTimeFormatter[size];\n+                iParsers = new DateTimeParser[size];\n                 int parseEst = 0;\n                 for (int i=0; i<size; i++) {\n-                    BaseDateTimeFormatter parser = (BaseDateTimeFormatter) parserList.get(i);\n+                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                     parseEst += parser.estimateParsedLength();\n                     iParsers[i] = parser;\n                 }\n             }\n         }\n \n-        private Composite(Composite base, BaseDateTimeFormatter[] printers) {\n+        private Composite(Composite base, DateTimeFormatter[] printers) {\n             iPrinters = printers;\n             iParsers = base.iParsers;\n             iPrintedLengthEstimate = base.iPrintedLengthEstimate;\n             iParsedLengthEstimate = base.iParsedLengthEstimate;\n         }\n \n-        protected int estimatePrintedLength() {\n+        public int estimatePrintedLength() {\n             return iPrintedLengthEstimate;\n         }\n \n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            BaseDateTimeFormatter[] elements = iPrinters;\n+        public void printTo(StringBuffer buf,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) {\n+            DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n \n             int len = elements.length;\n             for (int i = 0; i < len; i++) {\n-                elements[i].printTo(buf, instantLocal, chronoLocal, instant, chrono);\n-            }\n-        }\n-\n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            BaseDateTimeFormatter[] elements = iPrinters;\n+                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone);\n+            }\n+        }\n+\n+        public void printTo(Writer out,\n+                            long instant, Chronology chrono,\n+                            int displayOffset, DateTimeZone displayZone) throws IOException {\n+            DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n \n             int len = elements.length;\n             for (int i = 0; i < len; i++) {\n-                elements[i].printTo(out, instantLocal, chronoLocal, instant, chrono);\n+                elements[i].printTo(out, instant, chrono, displayOffset, displayZone);\n             }\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial) {\n-            BaseDateTimeFormatter[] elements = iPrinters;\n+            DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-            BaseDateTimeFormatter[] elements = iPrinters;\n+            DateTimePrinter[] elements = iPrinters;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n             }\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return iParsedLengthEstimate;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n-            BaseDateTimeFormatter[] elements = iParsers;\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] elements = iParsers;\n             if (elements == null) {\n                 throw new UnsupportedOperationException();\n             }\n             extends BaseDateTimeFormatter\n             implements DateTimeParser {\n \n-        private final BaseDateTimeFormatter[] iParsers;\n+        private final DateTimeParser[] iParsers;\n         private final int iParsedLengthEstimate;\n \n-        MatchingParser(BaseDateTimeFormatter[] parsers) {\n+        MatchingParser(DateTimeParser[] parsers) {\n             super();\n             iParsers = parsers;\n             int est = 0;\n             for (int i=parsers.length; --i>=0 ;) {\n-                BaseDateTimeFormatter parser = parsers[i];\n+                DateTimeParser parser = parsers[i];\n                 if (parser != null) {\n                     int len = parser.estimateParsedLength();\n                     if (len > est) {\n             iParsedLengthEstimate = est;\n         }\n \n-        protected int estimateParsedLength() {\n+        public int estimateParsedLength() {\n             return iParsedLengthEstimate;\n         }\n \n-        protected int parseInto(ParseBucket bucket, String text, int position) {\n-            BaseDateTimeFormatter[] parsers = iParsers;\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] parsers = iParsers;\n             int length = parsers.length;\n \n             final Object originalState = bucket.saveState();\n             int bestInvalidPos = position;\n \n             for (int i=0; i<length; i++) {\n-                BaseDateTimeFormatter parser = parsers[i];\n+                DateTimeParser parser = parsers[i];\n                 if (parser == null) {\n                     // The empty parser wins only if nothing is better.\n                     if (bestValidPos <= position) {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n \n /**\n  * Defines an interface for parsing textual representations of datetimes.\n- * <p>\n- * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n- * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @see DateTimeFormatter\n public interface DateTimeParser {\n \n     /**\n+     * Returns the expected maximum number of characters consumed. The actual\n+     * amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n+     */\n+    int estimateParsedLength();\n+\n+    /**\n+     * Parse an element from the given text, saving any fields into the given\n+     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n+     * text position. Note that the parse may succeed without fully reading the\n+     * text.\n+     * <p>\n+     * If it fails, the return value is negative. To determine the position\n+     * where the parse failed, apply the one's complement operator (~) on the\n+     * return value.\n+     *\n+     * @param bucket  field are saved into this\n+     * @param text  the text to parse\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(DateTimeParserBucket bucket, String text, int position);\n+\n+    /**\n      * Parses a datetime from the given text, at the given position, saving the\n      * result into the fields of the given ReadWritableInstant. If the parse\n      * succeeds, the return value is the new text position. Note that the parse\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * DateTimeParserBucket is an advanced class, intended mainly for parser\n+ * implementations. It can also be used during normal parsing operations to\n+ * capture more information about the parse.\n+ * <p>\n+ * This class allows fields to be saved in any order, but be physically set in\n+ * a consistent order. This is useful for parsing against formats that allow\n+ * field values to contradict each other.\n+ * <p>\n+ * Field values are applied in an order where the \"larger\" fields are set\n+ * first, making their value less likely to stick.  A field is larger than\n+ * another when it's range duration is longer. If both ranges are the same,\n+ * then the larger field has the longer duration. If it cannot be determined\n+ * which field is larger, then the fields are set in the order they were saved.\n+ * <p>\n+ * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n+ * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n+ * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n+ * <p>\n+ * DateTimeParserBucket is mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTimeParserBucket {\n+\n+    private final Chronology iChrono;\n+    private final long iMillis;\n+    \n+    // TimeZone to switch to in computeMillis. If null, use offset.\n+    DateTimeZone iZone;\n+    int iOffset;\n+    \n+    SavedField[] iSavedFields = new SavedField[8];\n+    int iSavedFieldsCount;\n+    boolean iSavedFieldsShared;\n+    \n+    private Object iSavedState;\n+    \n+    /**\n+     * Constucts a bucket.\n+     * \n+     * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono) {\n+        super();\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        iMillis = instantLocal;\n+        iChrono = chrono.withUTC();\n+        setZone(chrono.getZone());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n+     */\n+    public Chronology getChronology() {\n+        return iChrono;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the time zone used by computeMillis, or null if an offset is\n+     * used instead.\n+     */\n+    public DateTimeZone getZone() {\n+        return iZone;\n+    }\n+    \n+    /**\n+     * Set a time zone to be used when computeMillis is called, which\n+     * overrides any set time zone offset.\n+     *\n+     * @param zone the date time zone to operate in, or null if UTC\n+     */\n+    public void setZone(DateTimeZone zone) {\n+        iSavedState = null;\n+        iZone = zone == DateTimeZone.UTC ? null : zone;\n+        iOffset = 0;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the time zone offset used by computeMillis, unless\n+     * getZone doesn't return null.\n+     */\n+    public int getOffset() {\n+        return iOffset;\n+    }\n+    \n+    /**\n+     * Set a time zone offset to be used when computeMillis is called, which\n+     * overrides the time zone.\n+     */\n+    public void setOffset(int offset) {\n+        iSavedState = null;\n+        iOffset = offset;\n+        iZone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Saves a datetime field value.\n+     * \n+     * @param field  the field, whose chronology must match that of this bucket\n+     * @param value  the value\n+     */\n+    public void saveField(DateTimeField field, int value) {\n+        saveField(new SavedField(field, value));\n+    }\n+    \n+    /**\n+     * Saves a datetime field value.\n+     * \n+     * @param fieldType  the field type\n+     * @param value  the value\n+     */\n+    public void saveField(DateTimeFieldType fieldType, int value) {\n+        saveField(new SavedField(fieldType.getField(iChrono), value));\n+    }\n+    \n+    /**\n+     * Saves a datetime field text value.\n+     * \n+     * @param fieldType  the field type\n+     * @param text  the text value\n+     * @param locale  the locale to use\n+     */\n+    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n+        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n+    }\n+    \n+    private void saveField(SavedField field) {\n+        SavedField[] savedFields = iSavedFields;\n+        int savedFieldsCount = iSavedFieldsCount;\n+        \n+        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n+            // Expand capacity or merely copy if saved fields are shared.\n+            SavedField[] newArray = new SavedField\n+                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n+            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n+            iSavedFields = savedFields = newArray;\n+            iSavedFieldsShared = false;\n+        }\n+        \n+        iSavedState = null;\n+        savedFields[savedFieldsCount] = field;\n+        iSavedFieldsCount = savedFieldsCount + 1;\n+    }\n+    \n+    /**\n+     * Saves the state of this bucket, returning it in an opaque object. Call\n+     * restoreState to undo any changes that were made since the state was\n+     * saved. Calls to saveState may be nested.\n+     *\n+     * @return opaque saved state, which may be passed to restoreState\n+     */\n+    public Object saveState() {\n+        if (iSavedState == null) {\n+            iSavedState = new SavedState();\n+        }\n+        return iSavedState;\n+    }\n+    \n+    /**\n+     * Restores the state of this bucket from a previously saved state. The\n+     * state object passed into this method is not consumed, and it can be used\n+     * later to restore to that state again.\n+     *\n+     * @param savedState opaque saved state, returned from saveState\n+     * @return true state object is valid and state restored\n+     */\n+    public boolean restoreState(Object savedState) {\n+        if (savedState instanceof SavedState) {\n+            if (((SavedState) savedState).restoreState(this)) {\n+                iSavedState = savedState;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n+     *\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public long computeMillis() {\n+        return computeMillis(false);\n+    }\n+    \n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n+     *\n+     * @param resetFields false by default, but when true, unsaved field values are cleared\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public long computeMillis(boolean resetFields) {\n+        SavedField[] savedFields = iSavedFields;\n+        int count = iSavedFieldsCount;\n+        if (iSavedFieldsShared) {\n+            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+            iSavedFieldsShared = false;\n+        }\n+        sort(savedFields, count);\n+        \n+        long millis = iMillis;\n+        for (int i=0; i<count; i++) {\n+            millis = savedFields[i].set(millis, resetFields);\n+        }\n+        \n+        if (iZone == null) {\n+            millis -= iOffset;\n+        } else {\n+            int offset = iZone.getOffsetFromLocal(millis);\n+            millis -= offset;\n+            if (offset != iZone.getOffset(millis)) {\n+                throw new IllegalArgumentException\n+                    (\"Illegal instant due to time zone offset transition\");\n+            }\n+        }\n+        \n+        return millis;\n+    }\n+    \n+    /**\n+     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n+     * choice since it always creates an internal copy of the array, even if it\n+     * doesn't need to. If the array slice is small enough, an insertion sort\n+     * is chosen instead, but it doesn't need a copy!\n+     * <p>\n+     * This method has a modified version of that insertion sort, except it\n+     * doesn't create an unnecessary array copy. If high is over 10, then\n+     * java.util.Arrays is called, which will perform a merge sort, which is\n+     * faster than insertion sort on large lists.\n+     * <p>\n+     * The end result is much greater performace when computeMillis is called.\n+     * Since the amount of saved fields is small, the insertion sort is a\n+     * better choice. Additional performance is gained since there is no extra\n+     * array allocation and copying. Also, the insertion sort here does not\n+     * perform any casting operations. The version in java.util.Arrays performs\n+     * casts within the insertion sort loop.\n+     */\n+    private static void sort(Comparable[] array, int high) {\n+        if (high > 10) {\n+            Arrays.sort(array, 0, high);\n+        } else {\n+            for (int i=0; i<high; i++) {\n+                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n+                    Comparable t = array[j];\n+                    array[j] = array[j-1];\n+                    array[j-1] = t;\n+                }\n+            }\n+        }\n+    }\n+\n+    class SavedState {\n+        final DateTimeZone iZone;\n+        final int iOffset;\n+        final SavedField[] iSavedFields;\n+        final int iSavedFieldsCount;\n+        \n+        SavedState() {\n+            this.iZone = DateTimeParserBucket.this.iZone;\n+            this.iOffset = DateTimeParserBucket.this.iOffset;\n+            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n+            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n+        }\n+        \n+        boolean restoreState(DateTimeParserBucket enclosing) {\n+            if (enclosing != DateTimeParserBucket.this) {\n+                return false;\n+            }\n+            enclosing.iZone = this.iZone;\n+            enclosing.iOffset = this.iOffset;\n+            enclosing.iSavedFields = this.iSavedFields;\n+            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n+                // Since count is being restored to a lower count, the\n+                // potential exists for new saved fields to destroy data being\n+                // shared by another state. Set this flag such that the array\n+                // of saved fields is cloned prior to modification.\n+                enclosing.iSavedFieldsShared = true;\n+            }\n+            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n+            return true;\n+        }\n+    }\n+    \n+    static class SavedField implements Comparable {\n+        final DateTimeField iField;\n+        final int iValue;\n+        final String iText;\n+        final Locale iLocale;\n+        \n+        SavedField(DateTimeField field, int value) {\n+            iField = field;\n+            iValue = value;\n+            iText = null;\n+            iLocale = null;\n+        }\n+        \n+        SavedField(DateTimeField field, String text, Locale locale) {\n+            iField = field;\n+            iValue = 0;\n+            iText = text;\n+            iLocale = locale;\n+        }\n+        \n+        long set(long millis, boolean reset) {\n+            if (iText == null) {\n+                millis = iField.set(millis, iValue);\n+            } else {\n+                millis = iField.set(millis, iText, iLocale);\n+            }\n+            if (reset) {\n+                millis = iField.roundFloor(millis);\n+            }\n+            return millis;\n+        }\n+        \n+        /**\n+         * The field with the longer range duration is ordered first, where\n+         * null is considered infinite. If the ranges match, then the field\n+         * with the longer duration is ordered first.\n+         */\n+        public int compareTo(Object obj) {\n+            DateTimeField other = ((SavedField)obj).iField;\n+            int result = compareReverse\n+                (iField.getRangeDurationField(), other.getRangeDurationField());\n+            if (result != 0) {\n+                return result;\n+            }\n+            return compareReverse\n+                (iField.getDurationField(), other.getDurationField());\n+        }\n+        \n+        private int compareReverse(Comparable a, Comparable b) {\n+            if (a == null) {\n+                if (b == null) {\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            if (b == null) {\n+                return 1;\n+            }\n+            return -a.compareTo(b);\n+        }\n+    }\n+}\n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n  * Defines an interface for creating textual representations of datetimes.\n  * <p>\n  * Instances of this interface are provided by the various builder classes.\n- * <p>\n- * Note: This interface represents a view onto {@link BaseDateTimeFormatter}.\n- * All implementations must extend <code>BaseDateTimeFormatter</code>.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n public interface DateTimePrinter {\n \n     /**\n+     * Returns the expected maximum number of characters produced. The actual\n+     * amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n+     */\n+    int estimatePrintedLength();\n+\n+    /**\n      * Prints a ReadableInstant, using the chronology supplied by the instant.\n      *\n      * @param buf  formatted instant is appended to this buffer\n      * @param chrono  the chronology to use, null means ISO default\n      */\n     void printTo(Writer out, long instant, Chronology chrono) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given Chronology.\n+     *\n+     * @param buf  formatted instant is appended to this buffer\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  if a time zone is printed, force it to use this one\n+     */\n+    void printTo(StringBuffer buf, long instant, Chronology chrono,\n+                 int displayOffset, DateTimeZone displayZone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given Chronology.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  if a time zone is printed, force it to use this one\n+     */\n+    void printTo(Writer out, long instant, Chronology chrono,\n+                 int displayOffset, DateTimeZone displayZone) throws IOException;\n \n     //-----------------------------------------------------------------------\n     /**\n     String print(long instant, Chronology chrono);\n \n     /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given chronology.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronoogy to use\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  if a time zone is printed, force it to use this one\n+     * @return the printed result\n+     */\n+    String print(long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone);\n+\n+    /**\n      * Prints a ReadablePartial to a new String.\n      *\n      * @param partial  partial to format", "timestamp": 1102911666, "metainfo": ""}