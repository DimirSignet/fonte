{"sha": "82e15b2b9bf43ae8c549fa2be18e2ead6e51f165", "log": "added persister for LocalDate and LocalTime  ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.hibernate.HibernateException;\n+import org.hibernate.Hibernate;\n+import org.joda.time.DateTime;\n+import org.joda.time.LocalDate;\n+\n+import java.sql.Types;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.PreparedStatement;\n+import java.io.Serializable;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalDate implements EnhancedUserType\n+{\n+\tpublic final static PersistentLocalDate INSTANCE = new PersistentLocalDate();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.DATE,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalDate.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalDate dtx = (LocalDate) x;\n+        LocalDate dty = (LocalDate) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.DATE.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new LocalDate(timestamp);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, ((LocalDate) value).toDateMidnight().toDate(), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalDate(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new LocalDate(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.hibernate.HibernateException;\n+import org.hibernate.Hibernate;\n+import org.joda.time.LocalTime;\n+\n+import java.sql.Types;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.PreparedStatement;\n+import java.io.Serializable;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeAsString implements EnhancedUserType\n+{\n+\tpublic final static PersistentLocalTimeAsString INSTANCE = new PersistentLocalTimeAsString();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.VARCHAR,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.STRING.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new LocalTime(timestamp.toString());\n+\t}\n+\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.STRING.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tLocalTime lt = ((LocalTime) value);\n+\n+\t\t\tHibernate.STRING.nullSafeSet(preparedStatement, lt.toString(), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new LocalTime(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.LocalTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.sql.Time;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate\n+ * This uses a simple integer to store the time as milliseconds since 1970-1-1. <br />\n+ * The milliseconds will survive.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeAsTime implements EnhancedUserType\n+{\n+\tpublic final static PersistentLocalTimeAsTime INSTANCE = new PersistentLocalTimeAsTime();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIME,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.TIME.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new LocalTime(timestamp, DateTimeZone.UTC);\n+\t}\n+\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tLocalTime lt = ((LocalTime) value);\n+\t\t\tTime time = new Time(lt.getMillisOfDay());\n+\n+\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, time, index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new LocalTime(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.hibernate.HibernateException;\n+import org.hibernate.Hibernate;\n+import org.joda.time.LocalTime;\n+\n+import java.sql.Types;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.PreparedStatement;\n+import java.io.Serializable;\n+\n+/**\n+ * Persist {@link org.joda.time.LocalDate} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentLocalTimeExact implements EnhancedUserType\n+{\n+\tpublic final static PersistentLocalTimeExact INSTANCE = new PersistentLocalTimeExact();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.INTEGER,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return LocalTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        LocalTime dtx = (LocalTime) x;\n+        LocalTime dty = (LocalTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.INTEGER.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn LocalTime.fromMillisOfDay(((Number) timestamp).intValue());\n+\t}\n+\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.INTEGER.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tLocalTime lt = ((LocalTime) value);\n+\n+\t\t\tHibernate.INTEGER.nullSafeSet(preparedStatement, new Integer(lt.getMillisOfDay()), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new LocalTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new LocalTime(string);\n+\t}\n+}\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Event.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Event.java\n package org.joda.time.contrib.hibernate;\n \n import org.joda.time.DateTime;\n+import org.joda.time.LocalDate;\n+import org.joda.time.LocalTime;\n \n import java.io.Serializable;\n \n {\n     private int id;\n     private DateTime dateTime;\n+\tprivate LocalDate localDate;\n+\tprivate LocalTime localTime;\n+\tprivate LocalTime localTime2;\n+\tprivate LocalTime localTime3;\n \n-    public Event()\n+\tpublic Event()\n     {\n     }\n \n     {\n         this.dateTime = dateTime;\n     }\n+\n+\tpublic LocalDate getLocalDate()\n+\t{\n+\t\treturn localDate;\n+\t}\n+\n+\tpublic void setLocalDate(LocalDate localDate)\n+\t{\n+\t\tthis.localDate = localDate;\n+\t}\n+\n+\tpublic LocalTime getLocalTime()\n+\t{\n+\t\treturn localTime;\n+\t}\n+\n+\tpublic void setLocalTime(LocalTime localTime)\n+\t{\n+\t\tthis.localTime = localTime;\n+\t}\n+\n+\tpublic LocalTime getLocalTime2()\n+\t{\n+\t\treturn localTime2;\n+\t}\n+\n+\tpublic void setLocalTime2(LocalTime localTime2)\n+\t{\n+\t\tthis.localTime2 = localTime2;\n+\t}\n+\n+\tpublic LocalTime getLocalTime3()\n+\t{\n+\t\treturn localTime3;\n+\t}\n+\n+\tpublic void setLocalTime3(LocalTime localTime3)\n+\t{\n+\t\tthis.localTime3 = localTime3;\n+\t}\n }\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/HibernateTestCase.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/HibernateTestCase.java\n \n \tprotected void tearDown() throws Exception\n \t{\n-\t\tthis.factory.close();\n-\t\tthis.factory = null;\n+\t\tif (this.factory != null)\n+\t\t{\n+\t\t\tthis.factory.close();\n+\t\t\tthis.factory = null;\n+\t\t}\n \t}\n \n \tprotected abstract void setupConfiguration(Configuration cfg);\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentLocalDate.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.LocalDate;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentLocalDate extends HibernateTestCase\n+{\n+    private LocalDate[] writeReadTimes = new LocalDate[]\n+    {\n+        new LocalDate(2004, 2, 25),\n+        new LocalDate(1980, 3, 11)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+\t{\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalDate writeReadTime = writeReadTimes[i];\n+\n+            Event event = new Event();\n+            event.setId(i);\n+            event.setLocalDate(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalDate writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Event eventReread = (Event) session.get(Event.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getLocalDate());\n+\n+            // we loose the timezone, so we have to normalize both to offset=0\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime,\n+                eventReread.getLocalDate());\n+\n+            session.close();\n+        }\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/event.hbm.xml\"));\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml\"));\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentLocalTime.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.LocalDate;\n+import org.joda.time.LocalTime;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.Session;\n+import org.hibernate.cfg.Configuration;\n+\n+import java.sql.SQLException;\n+import java.io.File;\n+\n+public class TestPersistentLocalTime extends HibernateTestCase\n+{\n+    private LocalTime[] writeReadTimes = new LocalTime[]\n+    {\n+        new LocalTime(14, 2, 25),\n+        new LocalTime(23, 59, 59, 999),\n+\t\tnew LocalTime(0, 0, 0)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+\t{\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalTime writeReadTime = writeReadTimes[i];\n+\n+            Event event = new Event();\n+            event.setId(i);\n+            event.setLocalTime(writeReadTime);\n+\t\t\tevent.setLocalTime2(writeReadTime);\n+\t\t\tevent.setLocalTime3(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            LocalTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Event eventReread = (Event) session.get(Event.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getLocalTime());\n+\t\t\tassertNotNull(\"get failed - returned null\", eventReread.getLocalTime2());\n+\t\t\tassertNotNull(\"get failed - returned null\", eventReread.getLocalTime3());\n+\n+            // we might loose the millis, depends on database\n+            assertEquals(\"get failed - returned different time (TIME)\",\n+                writeReadTime.getMillisOfDay()/1000,\n+                eventReread.getLocalTime().getMillisOfDay()/1000);\n+\n+\t\t\tassertEquals(\"get failed - returned different time (INT)\",\n+\t\t\t\twriteReadTime.getMillisOfDay(),\n+\t\t\t\teventReread.getLocalTime2().getMillisOfDay());\n+\n+\t\t\tassertEquals(\"get failed - returned different time (STRING)\",\n+\t\t\t\twriteReadTime.getMillisOfDay(),\n+\t\t\t\teventReread.getLocalTime3().getMillisOfDay());\n+\n+\t\t\tsession.close();\n+        }\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/event.hbm.xml\"));\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml\"));\n+\t}\n+}", "timestamp": 1170190825, "metainfo": ""}