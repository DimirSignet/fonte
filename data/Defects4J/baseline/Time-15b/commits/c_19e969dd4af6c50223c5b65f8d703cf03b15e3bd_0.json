{"sha": "19e969dd4af6c50223c5b65f8d703cf03b15e3bd", "log": "Added appendFixedDecimal and appendFixedSignedDecimal methods to DateTimeFormatterBuilder.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n     }\n \n     /**\n+     * Instructs the printer to emit a field value as a fixed-width decimal\n+     * number (smaller numbers will be left-padded with zeros), and the parser\n+     * to expect an unsigned decimal number with the same fixed width.\n+     * \n+     * @param fieldType type of field to append\n+     * @param numDigits the exact number of digits to parse or print, except if\n+     * printed value requires more digits\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n+     * @since 1.4\n+     */\n+    public DateTimeFormatterBuilder appendFixedDecimal(\n+            DateTimeFieldType fieldType, int numDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (numDigits <= 0) {\n+            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n+        }\n+        return append0(new FixedNumber(fieldType, numDigits, false));\n+    }\n+\n+    /**\n      * Instructs the printer to emit a field value as a decimal number, and the\n      * parser to expect a signed decimal number.\n      *\n         } else {\n             return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n         }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a fixed-width decimal\n+     * number (smaller numbers will be left-padded with zeros), and the parser\n+     * to expect an signed decimal number with the same fixed width.\n+     * \n+     * @param fieldType type of field to append\n+     * @param numDigits the exact number of digits to parse or print, except if\n+     * printed value requires more digits\n+     * @return this DateTimeFormatterBuilder\n+     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n+     * @since 1.4\n+     */\n+    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n+            DateTimeFieldType fieldType, int numDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (numDigits <= 0) {\n+            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n+        }\n+        return append0(new FixedNumber(fieldType, numDigits, true));\n     }\n \n     /**\n             } else {\n                 printUnknownString(out, iMinPrintedDigits);\n             }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class FixedNumber extends PaddedNumber {\n+\n+        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n+            super(fieldType, numDigits, signed, numDigits);\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int newPos = super.parseInto(bucket, text, position);\n+            if (newPos < 0) {\n+                return newPos;\n+            }\n+            int expectedPos = position + iMaxParsedDigits;\n+            if (newPos != expectedPos) {\n+                if (iSigned) {\n+                    char c = text.charAt(position);\n+                    if (c == '-' || c == '+') {\n+                        expectedPos++;\n+                    }\n+                }\n+                if (newPos > expectedPos) {\n+                    // The failure is at the position of the first extra digit.\n+                    return ~(expectedPos + 1);\n+                } else if (newPos < expectedPos) {\n+                    // The failure is at the position where the next digit should be.\n+                    return ~newPos;\n+                }\n+            }\n+            return newPos;\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatterBuilder.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatterBuilder.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeFieldType;\n+\n /**\n  * This class is a Junit unit test for DateTimeFormatterBuilder.\n  *\n  * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n  */\n public class TestDateTimeFormatterBuilder extends TestCase {\n \n         assertEquals(\"XYZ\", bld2.toFormatter().print(0L));\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void test_appendFixedDecimal() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n+        bld.appendFixedDecimal(DateTimeFieldType.year(), 4);\n+        DateTimeFormatter f = bld.toFormatter();\n+\n+        assertEquals(\"2007\", f.print(new DateTime(\"2007-01-01\")));\n+        assertEquals(\"0123\", f.print(new DateTime(\"123-01-01\")));\n+        assertEquals(\"0001\", f.print(new DateTime(\"1-2-3\")));\n+        assertEquals(\"99999\", f.print(new DateTime(\"99999-2-3\")));\n+        assertEquals(\"-0099\", f.print(new DateTime(\"-99-2-3\")));\n+        assertEquals(\"0000\", f.print(new DateTime(\"0-2-3\")));\n+\n+        assertEquals(2001, f.parseDateTime(\"2001\").getYear());\n+        try {\n+            f.parseDateTime(\"-2001\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+        try {\n+            f.parseDateTime(\"200\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+        try {\n+            f.parseDateTime(\"20016\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        bld = new DateTimeFormatterBuilder();\n+        bld.appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2);\n+        bld.appendLiteral(':');\n+        bld.appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2);\n+        bld.appendLiteral(':');\n+        bld.appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2);\n+        f = bld.toFormatter();\n+\n+        assertEquals(\"01:02:34\", f.print(new DateTime(\"T1:2:34\")));\n+\n+        DateTime dt = f.parseDateTime(\"01:02:34\");\n+        assertEquals(1, dt.getHourOfDay());\n+        assertEquals(2, dt.getMinuteOfHour());\n+        assertEquals(34, dt.getSecondOfMinute());\n+\n+        try {\n+            f.parseDateTime(\"0145:02:34\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+        try {\n+            f.parseDateTime(\"01:0:34\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_appendFixedSignedDecimal() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n+        bld.appendFixedSignedDecimal(DateTimeFieldType.year(), 4);\n+        DateTimeFormatter f = bld.toFormatter();\n+\n+        assertEquals(\"2007\", f.print(new DateTime(\"2007-01-01\")));\n+        assertEquals(\"0123\", f.print(new DateTime(\"123-01-01\")));\n+        assertEquals(\"0001\", f.print(new DateTime(\"1-2-3\")));\n+        assertEquals(\"99999\", f.print(new DateTime(\"99999-2-3\")));\n+        assertEquals(\"-0099\", f.print(new DateTime(\"-99-2-3\")));\n+        assertEquals(\"0000\", f.print(new DateTime(\"0-2-3\")));\n+\n+        assertEquals(2001, f.parseDateTime(\"2001\").getYear());\n+        assertEquals(-2001, f.parseDateTime(\"-2001\").getYear());\n+        assertEquals(2001, f.parseDateTime(\"+2001\").getYear());\n+        try {\n+            f.parseDateTime(\"20016\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n }", "timestamp": 1188062104, "metainfo": ""}