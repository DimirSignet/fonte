{"sha": "3ec1eb7ff17a6b61975e8ea72930d1ed927d4191", "log": "Require special year field.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n \n     int getMinYear() {\n         // The lowest year that can be fully supported.\n-        return 1;\n+        return -292269337;\n     }\n \n     int getMaxYear() {\n         // The highest year that can be fully supported.\n-        // TODO\n-        return 292272992;\n+        return 292271022;\n     }\n \n     long getAverageMillisPerYear() {\n     protected void assemble(Fields fields) {\n         if (getBase() == null) {\n             super.assemble(fields);\n+\n+            fields.year = new CopticYearDateTimeField(this);\n+            fields.years = fields.year.getDurationField();\n+\n             // Coptic, like Julian, has no year zero.\n             fields.year = new JulianChronology.NoYearZeroField(this, fields.year);\n             fields.weekyear = new JulianChronology.NoWeekyearZeroField(this, fields.weekyear);\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class CopticYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    static final long serialVersionUID = 8990199361773280783L;\n+\n+    private final AbstractGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    CopticYearDateTimeField(AbstractGJChronology chronology) {\n+        super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    public long addWrapped(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = get(minuendInstant);\n+        int subtrahendYear = get(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+\n+\t\tAbstractGJChronology chrono = iChronology;\n+\n+        int thisYear = chrono.getYear(instant);\n+        int dayOfYear = chrono.getDayOfYear(instant, thisYear);\n+        int millisOfDay = chrono.getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+\t\t\t// Current year is leap, and day is leap.\n+\t\t\tif (!chrono.isLeapYear(year)) {\n+\t\t\t\t// Moving to a non-leap year, leap day doesn't exist.\n+\t\t\t\tdayOfYear--;\n+\t\t\t}\n+        }\n+\n+        instant = chrono.getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}", "timestamp": 1075356092, "metainfo": ""}