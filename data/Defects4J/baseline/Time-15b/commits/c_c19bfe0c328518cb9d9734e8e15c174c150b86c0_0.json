{"sha": "c19bfe0c328518cb9d9734e8e15c174c150b86c0", "log": "Simplify complex duration to period conversions   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractPeriod.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractPeriod.java\n      * all lower subclasses are also immutable.\n      * \n      * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     protected void setPeriod(long duration) {\n         setPeriod(iType, duration);\n             return;\n         }\n         \n-        type = type.withChronology(type.getChronology().withUTC());\n         long startInstant = 0;\n         int years = 0, months = 0, weeks = 0, days = 0;\n         int hours = 0, minutes = 0, seconds = 0, millis = 0;\n--- a/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n     /**\n      * Creates a period from the given millisecond duration using AllType.\n      * <p>\n-     * The exact impact of this constructor is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * Only precise fields in the period type will be used.\n+     * For AllType, this is the time fields only.\n+     * The year, month, week and day fields will not be populated.\n+     * The period constructed will always be precise.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n      * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     /**\n      * Creates a period from the given millisecond duration.\n      * <p>\n-     * The exact impact of this constructor is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n      *\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this duration supports\n      * Sets all the fields in one go from a duration dividing the\n      * fields using the period type.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to set, null means zero length\n      */\n      * Sets all the fields in one go from a millisecond duration dividing the\n      * fields using the period type.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n      * \n      * @param duration  the duration, in milliseconds\n      */\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be added to the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be added to the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to add\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n     /**\n      * Creates a period from the given millisecond duration using AllType.\n      * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the period type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the period type.\n+     * Only precise fields in the period type will be used.\n+     * For AllType, this is the time fields only.\n+     * The year, month, week and day fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     /**\n      * Creates a period from the given millisecond duration.\n      * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the period type. This ensures that there are no odd effects caused by\n-     * time zones. The add methods will still use the time zone specific version\n-     * of the period type.\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n      *\n      * @param duration  the duration, in milliseconds\n      * @param type  which set of fields this period supports\n--- a/JodaTime/src/java/org/joda/time/PeriodType.java\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n public abstract class PeriodType implements Serializable {\n     private static final long serialVersionUID = 2274324892792009998L;\n \n+    private static final PeriodType MILLIS_TYPE;\n     private static final PeriodType DAY_HOUR_TYPE;\n+    private static final PeriodType YEAR_DAY_TYPE;\n     private static final PeriodType YEAR_WEEK_TYPE;\n     private static final PeriodType YEAR_MONTH_TYPE;\n     private static final PeriodType ALL_TYPE;\n-    private static final PeriodType MILLIS_TYPE;\n+    private static final PeriodType UTC_DAY_HOUR_TYPE;\n+    private static final PeriodType UTC_YEAR_DAY_TYPE;\n+    private static final PeriodType UTC_YEAR_WEEK_TYPE;\n+    private static final PeriodType UTC_YEAR_MONTH_TYPE;\n+    private static final PeriodType UTC_ALL_TYPE;\n     private static final PeriodType PRECISE_DAY_HOUR_TYPE;\n     private static final PeriodType PRECISE_YEAR_DAY_TYPE;\n     private static final PeriodType PRECISE_YEAR_WEEK_TYPE;\n     private static final PeriodType PRECISE_ALL_TYPE;\n \n     static {\n+        MILLIS_TYPE = new MillisType();\n         DAY_HOUR_TYPE = new DayHourType(ISOChronology.getInstance());\n+        YEAR_DAY_TYPE = new YearDayType(ISOChronology.getInstance());\n         YEAR_WEEK_TYPE = new YearWeekType(ISOChronology.getInstance());\n         YEAR_MONTH_TYPE = new YearMonthType(ISOChronology.getInstance());\n         ALL_TYPE = new AllType(ISOChronology.getInstance());\n-        MILLIS_TYPE = new MillisType();\n+        UTC_DAY_HOUR_TYPE = new DayHourType(ISOChronology.getInstanceUTC());\n+        UTC_YEAR_DAY_TYPE = new YearDayType(ISOChronology.getInstanceUTC());\n+        UTC_YEAR_WEEK_TYPE = new YearWeekType(ISOChronology.getInstanceUTC());\n+        UTC_YEAR_MONTH_TYPE = new YearMonthType(ISOChronology.getInstanceUTC());\n+        UTC_ALL_TYPE = new AllType(ISOChronology.getInstanceUTC());\n         PRECISE_DAY_HOUR_TYPE = new PreciseDayHourType(ISOChronology.getInstanceUTC());\n         PRECISE_YEAR_DAY_TYPE = new PreciseYearDayType(ISOChronology.getInstanceUTC());\n         PRECISE_YEAR_WEEK_TYPE = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n      * <li>milliseconds\n      * </ul>\n      *\n-     * This factory method returns a PeriodType that calculates using any\n-     * Chronology. For best results, the Chronology's time zone should\n-     * be UTC or have fixed offsets.\n+     * This factory method returns a PeriodType that calculates using any Chronology.\n      *\n      * @param chrono Chronology to use for calculations.\n      */\n         if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n             return getDayHourType();\n         }\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getUTCDayHourType();\n+        }\n         return new DayHourType(chrono);\n     }\n \n     /**\n      * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getAllType() {\n+        return ALL_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n      *\n      * <ul>\n      * <li>years\n      * <li>seconds\n      * <li>milliseconds\n      * </ul>\n-     */\n-    public static PeriodType getAllType() {\n-        return ALL_TYPE;\n+     *\n+     * This factory method returns a PeriodType that calculates using any Chronology.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static PeriodType getAllType(Chronology chrono) {\n+        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n+            return getAllType();\n+        }\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getUTCAllType();\n+        }\n+        return new AllType(chrono);\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>days\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getYearDayType() {\n+        return YEAR_DAY_TYPE;\n     }\n \n     /**\n      *\n      * <ul>\n      * <li>years\n-     * <li>months\n-     * <li>weeks\n      * <li>days\n      * <li>hours\n      * <li>minutes\n      * <li>milliseconds\n      * </ul>\n      *\n-     * This factory method returns a PeriodType that calculates using any\n-     * Chronology. For best results, the Chronology's time zone should\n-     * be UTC or have fixed offsets.\n+     * This factory method returns a PeriodType that calculates using any Chronology.\n      *\n      * @param chrono Chronology to use for calculations.\n      */\n-    public static PeriodType getAllType(Chronology chrono) {\n+    public static PeriodType getYearDayType(Chronology chrono) {\n         if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getAllType();\n-        }\n-        return new AllType(chrono);\n+            return getYearDayType();\n+        }\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getUTCYearDayType();\n+        }\n+        return new YearDayType(chrono);\n     }\n \n     /**\n      * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getYearMonthType() {\n+        return YEAR_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n      *\n      * <ul>\n      * <li>years\n      * <li>seconds\n      * <li>milliseconds\n      * </ul>\n-     */\n-    public static PeriodType getYearMonthType() {\n-        return YEAR_MONTH_TYPE;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>days\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any\n-     * Chronology. For best results, the Chronology's time zone should\n-     * be UTC or have fixed offsets.\n+     *\n+     * This factory method returns a PeriodType that calculates using any Chronology.\n      *\n      * @param chrono Chronology to use for calculations.\n      */\n         if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n             return getYearMonthType();\n         }\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getUTCYearMonthType();\n+        }\n         return new YearMonthType(chrono);\n     }\n \n     /**\n      * Returns a PeriodType using the ISOChronology in current time zone of:\n+     *\n+     * <ul>\n+     * <li>years (weekyears)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getYearWeekType() {\n+        return YEAR_WEEK_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType of:\n      *\n      * <ul>\n      * <li>years (weekyears)\n      * <li>seconds\n      * <li>milliseconds\n      * </ul>\n-     */\n-    public static PeriodType getYearWeekType() {\n-        return YEAR_WEEK_TYPE;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>years (weekyears)\n-     * <li>weeks\n-     * <li>days\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any\n-     * Chronology. For best results, the Chronology's time zone should\n-     * be UTC or have fixed offsets.\n+     *\n+     * This factory method returns a PeriodType that calculates using any Chronology.\n      *\n      * @param chrono Chronology to use for calculations.\n      */\n         if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n             return getYearWeekType();\n         }\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getUTCYearWeekType();\n+        }\n         return new YearWeekType(chrono);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a precise PeriodType using the ISOChronology in UTC of:\n      *\n      * <ul>\n-     * <li>days (fixed at 24 hours)\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getUTCDayHourType() {\n+        return UTC_DAY_HOUR_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getUTCYearDayType() {\n+        return UTC_YEAR_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getUTCYearMonthType() {\n+        return UTC_YEAR_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>weeks (precise, fixed at 7 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getUTCYearWeekType() {\n+        return UTC_YEAR_WEEK_TYPE;\n+    }\n+\n+    /**\n+     * Returns a PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks (precise, fixed at 7 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getUTCAllType() {\n+        return UTC_ALL_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n      * </ul>\n      */\n     public static PeriodType getPreciseDayHourType() {\n      * Returns a precise PeriodType using the ISOChronology in UTC of:\n      *\n      * <ul>\n-     * <li>years (fixed at 365 days)\n-     * <li>days (fixed at 24 hours)\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n+     * <li>years (precise, fixed at 365 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n      * </ul>\n      */\n     public static PeriodType getPreciseYearDayType() {\n      * Returns a precise PeriodType using the ISOChronology in UTC of:\n      *\n      * <ul>\n-     * <li>years (fixed at 365 days)\n-     * <li>months (fixed at 30 days)\n-     * <li>weeks (fixed at 7 days)\n-     * <li>days (fixed at 24 hours)\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n+     * <li>years (precise, fixed at 365 days)\n+     * <li>months (precise, fixed at 30 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseYearMonthType() {\n+        return PRECISE_YEAR_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (precise, fixed at 365 days)\n+     * <li>weeks (precise, fixed at 7 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n+     * </ul>\n+     */\n+    public static PeriodType getPreciseYearWeekType() {\n+        return PRECISE_YEAR_WEEK_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise PeriodType using the ISOChronology in UTC of:\n+     *\n+     * <ul>\n+     * <li>years (precise, fixed at 365 days)\n+     * <li>months (precise, fixed at 30 days)\n+     * <li>weeks (precise, fixed at 7 days)\n+     * <li>days (precise, fixed at 24 hours)\n+     * <li>hours (precise)\n+     * <li>minutes (precise)\n+     * <li>seconds (precise)\n+     * <li>milliseconds (precise)\n      * </ul>\n      */\n     public static PeriodType getPreciseAllType() {\n         return PRECISE_ALL_TYPE;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (fixed at 365 days)\n-     * <li>months (fixed at 30 days)\n-     * <li>days (fixed at 24 hours)\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseYearMonthType() {\n-        return PRECISE_YEAR_MONTH_TYPE;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (fixed at 365 days)\n-     * <li>weeks (fixed at 7 days)\n-     * <li>days (fixed at 24 hours)\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseYearWeekType() {\n-        return PRECISE_YEAR_WEEK_TYPE;\n     }\n \n     //-----------------------------------------------------------------------\n         }\n     }\n \n+    private static class YearDayType extends DayHourType {\n+        private static final long serialVersionUID = 6567563546499L;\n+\n+        YearDayType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public PeriodType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return PeriodType.getYearWeekType(chrono);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.weekyears();\n+        }\n+\n+        private Object readResolve() {\n+            return getYearDayType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"YearDayType\";\n+        }\n+    }\n+\n     private static class YearWeekType extends DayHourType {\n         private static final long serialVersionUID = 1347170237843447098L;\n \n--- a/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n      * Sets all the fields in one go from a duration dividing the\n      * fields using the period type.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to set, null means zero length\n      */\n      * Sets all the fields in one go from a millisecond duration dividing the\n      * fields using the period type.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n      * \n      * @param duration  the duration, in milliseconds\n      */\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be added to the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      * Adds a duration to this one by dividing the duration into\n      * fields and then adding each field in turn.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If this period uses the PreciseAll period type then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period uses the All period type then the years and months fields\n-     * will remain as zero, with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be added to the largest\n+     * available precise field.\n      * \n      * @param duration  the duration to add\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n     /**\n      * Converts this duration to a Period instance using the All type.\n      * <p>\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n+     * Only precise fields in the period type will be used.\n+     * For AllType, this is the time fields only.\n+     * The year, month, week and day fields will not be populated.\n+     * The period constructed will always be precise.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If the duration is larger then the years and months fields will remain as zero,\n-     * with the duration allocated to the weeks field.\n-     * Normally, the weeks and days fields are imprecise, but this method\n-     * calculates using the UTC time zone making weeks and days precise.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n+     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n      * \n      * @return a Period created using the millisecond duration from this instance\n      */\n      * Converts this duration to a Period instance specifying a period type\n      * to control how the duration is split into fields.\n      * <p>\n-     * The exact impact of this method is determined by the period type.\n-     * Only precise fields in the period type will be used and the calculation will use UTC.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly. The situation is more complex\n-     * for larger durations.\n-     * <p>\n-     * If the period type is PreciseAll then all fields can be set.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 1 year, 2 months and 5 days using the PreciseAll type.\n-     * <p>\n-     * If the period type is All then the years and months fields will remain as zero,\n-     * with the duration allocated to the weeks and days fields.\n-     * The effect is that a large duration of several years or months will be converted\n-     * to a period including a large number of weeks and zero years and months.\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * 61 weeks and 3 days.\n-     * <p>\n-     * For more control over the conversion process, you should convert the duration\n-     * to an interval by referencing a fixed instant and then obtain the period.\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n      * \n      * @param type  the period type determining how to split the duration into fields\n      * @return a Period created using the millisecond duration from this instance\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long2() throws Throwable {\n         assertEquals(length, test.toDurationMillis());\n     }\n \n+    public void testConstructor_long3() throws Throwable {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        MutablePeriod test = new MutablePeriod(length);\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        // only time fields are precise in AllType\n+        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((450 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_long_PeriodType1() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType2() throws Throwable {\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType4() throws Throwable {\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n-            System.err.println(test);  // TODO\n-        assertEquals(1, test.getYears());  // 365\n-        assertEquals(2, test.getMonths()); // 31 + 30 (Jan + Feb)\n-        assertEquals(3, test.getWeeks());  // 3 * 7\n-        assertEquals(3, test.getDays());   // 3 left (one given to months)\n-        assertEquals(5, test.getHours());\n+        // only time fields are precise\n+        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((450 * 24) + 5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n     }\n \n     public void testAdd_long2() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.getAllType());\n+        long ms =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        test.add(ms);\n+        // only time fields are precise\n+        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((450 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(108, test.getMillis());\n+    }\n+\n+    public void testAdd_long3() {\n         MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n         assertEquals(ms + 100L, test.toDurationMillis());\n     }\n \n-    public void testAdd_long3() {\n+    public void testAdd_long4() {\n         MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n         long ms =0L;\n         test.add(ms);\n         assertEquals(100L, test.toDurationMillis());\n     }\n \n-    public void testAdd_long4() {\n+    public void testAdd_long5() {\n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         test.add(2100L);\n         assertEquals(1, test.getYears());\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long2() throws Throwable {\n         assertEquals(length, test.toDurationMillis());\n     }\n \n+    public void testConstructor_long3() throws Throwable {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Period test = new Period(length);\n+        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        // only time fields are precise in AllType\n+        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((450 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_long_PeriodType1() throws Throwable {\n         long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType2() throws Throwable {\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType4() throws Throwable {", "timestamp": 1091836112, "metainfo": ""}