{"sha": "61c64930304b87d4aa81dca05aba09591b3b2d52", "log": "Fix bug in withChronologyRetainFields because no validation occurred   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n      *\n      * @param newChronology  the new chronology, null means ISO\n      * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n      */\n     public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n         newChronology = DateTimeUtils.getChronology(newChronology);\n         if (newChronology == getChronology()) {\n             return this;\n         } else {\n-            return new TimeOfDay(this, newChronology);\n+            TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\n+            newChronology.validate(newTimeOfDay, getValues());\n+            return newTimeOfDay;\n         }\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the property object for the specified type, which contains many useful methods.\n-     *\n-     * @param type  the field type to get the chronology for\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n      * @return the property object\n      * @throws IllegalArgumentException if the field is null or unsupported\n      */\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n      * This method retains the values of the fields, thus the result will\n      * typically refer to a different instant.\n      * <p>\n-     * The time zone of the specified chronology is ignored, as TimeOfDay\n+     * The time zone of the specified chronology is ignored, as YearMonthDay\n      * operates without a time zone.\n      *\n      * @param newChronology  the new chronology, null means ISO\n      * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n      */\n     public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n         newChronology = DateTimeUtils.getChronology(newChronology);\n         if (newChronology == getChronology()) {\n             return this;\n         } else {\n-            return new YearMonthDay(this, newChronology);\n+            YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\n+            newChronology.validate(newYearMonthDay, getValues());\n+            return newYearMonthDay;\n         }\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the property object for the specified type, which contains many useful methods.\n-     *\n-     * @param type  the field type to get the chronology for\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n      * @return the property object\n      * @throws IllegalArgumentException if the field is null or unsupported\n      */\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n         assertEquals(ISO_UTC, test.getChronology());\n     }\n \n+    public void testWithChronologyRetainFields_invalidInNewChrono() {\n+        YearMonthDay base = new YearMonthDay(2005, 1, 31, ISO_UTC);\n+        try {\n+            base.withChronologyRetainFields(COPTIC_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testWithField1() {\n         YearMonthDay test = new YearMonthDay(2004, 6, 9);", "timestamp": 1118620079, "metainfo": ""}