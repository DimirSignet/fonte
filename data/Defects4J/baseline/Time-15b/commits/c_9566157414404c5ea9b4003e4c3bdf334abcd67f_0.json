{"sha": "9566157414404c5ea9b4003e4c3bdf334abcd67f", "log": "Rework InstantConverter to reduce number of methods   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n      * Constructs an instance from an Object that represents a datetime.\n      * The constructed object will have a local time of midnight.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code>\n-     * in the default time zone is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public DateMidnight(Object instant) {\n-        super(instant);\n+        super(instant, (Chronology) null);\n     }\n \n     /**\n      * forcing the time zone to that specified.\n      * The constructed object will have a local time of midnight.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n      * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * using the specified chronology.\n      * The constructed object will have a local time of midnight.\n      * <p>\n-     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public DateMidnight(Object instant, Chronology chronology) {\n-        super(instant, chronology);\n+        super(instant, DateTimeUtils.getChronology(chronology));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n     /**\n      * Constructs an instance from an Object that represents a datetime.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code>\n-     * in the default time zone is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public DateTime(Object instant) {\n-        super(instant);\n+        super(instant, (Chronology) null);\n     }\n \n     /**\n      * Constructs an instance from an Object that represents a datetime,\n      * forcing the time zone to that specified.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n      * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * Constructs an instance from an Object that represents a datetime,\n      * using the specified chronology.\n      * <p>\n-     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, null means now\n-     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @param chronology  the chronology, null means ISO in default zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public DateTime(Object instant, Chronology chronology) {\n-        super(instant, chronology);\n+        super(instant, DateTimeUtils.getChronology(chronology));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n      */\n     public int compare(Object lhsObj, Object rhsObj) {\n         InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n-        long lhsMillis = conv.getInstantMillis(lhsObj);\n-        Chronology lhsChrono = conv.getChronology(lhsObj);\n+        Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\n+        long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\n         \n         conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n-        long rhsMillis = conv.getInstantMillis(rhsObj);\n-        Chronology rhsChrono = conv.getChronology(rhsObj);\n+        Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\n+        long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\n \n         if (iLowerLimit != null) {\n             lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n     public Instant(Object instant) {\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        iMillis = converter.getInstantMillis(instant);\n+        iMillis = converter.getInstantMillis(instant, Chronology.getISOUTC());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n     /**\n      * Constructs an instance from an Object that represents a datetime.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code>\n-     * in the default time zone is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant) {\n-        super(instant);\n+        super(instant, (Chronology) null);\n     }\n \n     /**\n      * Constructs an instance from an Object that represents a datetime,\n      * forcing the time zone to that specified.\n      * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n      * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * Constructs an instance from an Object that represents a datetime,\n      * using the specified chronology.\n      * <p>\n-     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public MutableDateTime(Object instant, Chronology chronology) {\n-        super(instant, chronology);\n+        super(instant, DateTimeUtils.getChronology(chronology));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/BaseDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseDateTime.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Constructs an instance from an Object that represents a datetime.\n-     * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code>\n-     * in the default time zone is used.\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n-     * @param instant  the datetime object, null means now\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    public BaseDateTime(Object instant) {\n+    public BaseDateTime(Object instant, DateTimeZone zone) {\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        iChronology = checkChronology(converter.getChronology(instant));\n-        iMillis = checkInstant(converter.getInstantMillis(instant), iChronology);\n+        Chronology chrono = checkChronology(converter.getChronology(instant, zone));\n+        iChronology = chrono;\n+        iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);\n     }\n \n     /**\n      * Constructs an instance from an Object that represents a datetime,\n-     * forcing the time zone to that specified.\n-     * <p>\n-     * If the object contains no chronology, <code>ISOChronology</code> is used.\n-     * If the specified time zone is null, the default zone is used.\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n      * <p>\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n-     * @param instant  the datetime object, null means now\n-     * @param zone  the time zone, null means default time zone\n-     * @throws IllegalArgumentException if the instant is invalid\n-     */\n-    public BaseDateTime(Object instant, DateTimeZone zone) {\n-        super();\n-        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n-        iChronology = checkChronology(converter.getChronology(instant, zone));\n-        iMillis = checkInstant(converter.getInstantMillis(instant, zone), iChronology);\n-    }\n-\n-    /**\n-     * Constructs an instance from an Object that represents a datetime,\n-     * using the specified chronology.\n-     * <p>\n-     * If the chronology is null, ISOChronology in the default time zone is used.\n-     * <p>\n-     * The recognised object types are defined in\n-     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n-     * include ReadableInstant, String, Calendar and Date.\n-     *\n-     * @param instant  the datetime object, null means now\n-     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public BaseDateTime(Object instant, Chronology chronology) {\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n      * Once the constructor is complete, all further calculations are performed\n      * without reference to a timezone (by switching to UTC).\n      *\n-     * @param instant  the datetime object, null means use converter\n+     * @param instant  the datetime object\n      * @param chronology  the chronology, null means use converter\n      * @throws IllegalArgumentException if the date is invalid\n      */\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadablePartial;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * AbstractConverter simplifies the process of implementing a converter.\n  * @since 1.0\n  */\n public abstract class AbstractConverter implements Converter {\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n     /**\n      * Extracts the millis from an object of this convertor's type.\n      * <p>\n-     * This implementation calls {@link #getInstantMillis(Object, DateTimeZone)}.\n+     * This implementation returns the current time.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is always non-null\n      * @return the millisecond value\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    public long getInstantMillis(Object object) {\n-        return getInstantMillis(object, (DateTimeZone) null);\n-    }\n-    \n-    /**\n-     * Extracts the millis from an object of this convertor's type.\n-     * <p>\n-     * This implementation calls {@link #getInstantMillis(Object)}.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @param zone  the zone to use, null means default zone\n-     * @return the millisecond value\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    public long getInstantMillis(Object object, DateTimeZone zone) {\n-        return getInstantMillis(object);\n-    }\n-    \n-    /**\n-     * Extracts the millis from an object of this convertor's type.\n-     * <p>\n-     * This implementation calls {@link #getInstantMillis(Object)}.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @param chrono  the chronology to use, null means ISOChronology\n-     * @return the millisecond value\n-     * @throws ClassCastException if the object is invalid\n      */\n     public long getInstantMillis(Object object, Chronology chrono) {\n-        return getInstantMillis(object);\n+        return DateTimeUtils.currentTimeMillis();\n     }\n+\n     //-----------------------------------------------------------------------\n-    \n-    /**\n-     * Extracts the chronology from an object of this convertor's type.\n-     * <p>\n-     * This implementation returns the ISOChronology.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @return the chronology, never null\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    public Chronology getChronology(Object object) {\n-        return ISOChronology.getInstance();\n-    }\n-    \n     /**\n      * Extracts the chronology from an object of this convertor's type\n      * where the time zone is specified.\n      * <p>\n-     * This implementation returns the ISOChronology.\n+     * This implementation returns the ISO chronology.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the object to convert\n      * @param zone  the specified zone to use, null means default zone\n      * @return the chronology, never null\n-     * @throws ClassCastException if the object is invalid\n      */\n     public Chronology getChronology(Object object, DateTimeZone zone) {\n-        return ISOChronology.getInstance(zone);\n+        return Chronology.getISO(zone);\n     }\n-    \n+\n     /**\n      * Extracts the chronology from an object of this convertor's type\n      * where the chronology is specified.\n      * <p>\n      * This implementation returns the chronology specified, or the\n-     * ISOChronology in the default zone if null passed in.\n+     * ISO chronology in the default zone if null passed in.\n      * \n-     * @param object  the object to convert, must not be null\n-     * @param chrono  the chronology to use, null means ISOChronology\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, null means ISO default\n      * @return the chronology, never null\n-     * @throws ClassCastException if the object is invalid\n      */\n     public Chronology getChronology(Object object, Chronology chrono) {\n-        if (chrono == null) {\n-            return ISOChronology.getInstance();\n-        }\n-        return chrono;\n+        return DateTimeUtils.getChronology(chrono);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Extracts the values of the partial from an object of this converter's type.\n      * @param object  the object to convert\n      * @param chrono  the chronology to use, which is the non-null result of getChronology()\n      * @return the array of field values that match the \n-     * @throws ClassCastException if the object is invalid\n      */\n     public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n         long instant = getInstantMillis(object, chrono);\n     /**\n      * Selects a suitable period type for the given object.\n      *\n-     * @param object  the object to examine, must not be null\n+     * @param object  the object to examine\n      * @return the period type, never null\n-     * @throws ClassCastException if the object is invalid\n      */\n     public PeriodType getPeriodType(Object object) {\n         return PeriodType.standard();\n      * <p>\n      * If it is, then the calling code should cast and copy the fields directly.\n      *\n-     * @param object  the object to convert, must not be null\n+     * @param object  the object to convert\n      * @param chrono  the chronology to use, may be null\n      * @return true if the input is a ReadableInterval\n-     * @throws ClassCastException if the object is invalid\n      */\n     public boolean isReadableInterval(Object object, Chronology chrono) {\n         return false;\n--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.GJChronology;\n-import org.joda.time.chrono.GregorianChronology;\n-import org.joda.time.chrono.JulianChronology;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * CalendarConverter converts a java util Calendar to an instant or partial.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the millis, which is the Calendar millis value.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @return the millisecond value\n-     */\n-    public long getInstantMillis(Object object) {\n-        return ((Calendar) object).getTime().getTime();\n-    }\n-\n-    /**\n-     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n+     * Gets the chronology.\n+     * <p>\n+     * If a chronology is specified then it is used.\n+     * Otherwise, it is the GJChronology if a GregorianCalendar is used,\n      * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n      * The time zone is extracted from the calendar if possible, default used if not.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the Calendar to convert, must not be null\n+     * @param chrono  the chronology to use, null means use Calendar\n      * @return the chronology, never null\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n      */\n-    public Chronology getChronology(Object object) {\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono != null) {\n+            return chrono;\n+        }\n         Calendar cal = (Calendar) object;\n         DateTimeZone zone = null;\n         try {\n      * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n      * The time zone specified is used in preference to that on the calendar.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the Calendar to convert, must not be null\n      * @param zone  the specified zone to use, null means default zone\n      * @return the chronology, never null\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n      */\n     public Chronology getChronology(Object object, DateTimeZone zone) {\n         if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n             GregorianCalendar gc = (GregorianCalendar) object;\n             long cutover = gc.getGregorianChange().getTime();\n             if (cutover == Long.MIN_VALUE) {\n-                return GregorianChronology.getInstance(zone);\n+                return Chronology.getGregorian(zone);\n             } else if (cutover == Long.MAX_VALUE) {\n-                return JulianChronology.getInstance(zone);\n+                return Chronology.getJulian(zone);\n             } else {\n                 return GJChronology.getInstance(zone, cutover, 4);\n             }\n         } else {\n-            return ISOChronology.getInstance(zone);\n+            return Chronology.getISO(zone);\n         }\n+    }\n+\n+    /**\n+     * Gets the millis, which is the Calendar millis value.\n+     * \n+     * @param object  the Calendar to convert, must not be null\n+     * @param chrono  the chronology result from getChronology, non-null\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return ((Calendar) object).getTime().getTime();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n \n import java.util.Date;\n \n+import org.joda.time.Chronology;\n+\n /**\n  * DateConverter converts a java util Date to an instant or partial.\n  * The Date is converted to milliseconds in the ISO chronology.\n  */\n final class DateConverter extends AbstractConverter\n         implements InstantConverter, PartialConverter {\n-    \n+\n     /**\n      * Singleton instance.\n      */\n     static final DateConverter INSTANCE = new DateConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n     /**\n      * Gets the millis, which is the Date millis value.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the Date to convert, must not be null\n+     * @param chrono  the non-null result of getChronology\n      * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n      */\n-    public long getInstantMillis(Object object) {\n+    public long getInstantMillis(Object object, Chronology chrono) {\n         return ((Date) object).getTime();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns Date.class.\n     public Class getSupportedType() {\n         return Date.class;\n     }\n-    \n+\n }\n--- a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java\n \n /**\n  * InstantConverter defines how an object is converted to milliseconds/chronology.\n+ * <p>\n+ * The two methods in this interface must be called in order, as the\n+ * <code>getInstantMillis</code> method relies on the result of the\n+ * <code>getChronology</code> method being passed in.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n public interface InstantConverter extends Converter {\n \n-    /**\n-     * Extracts the millis from an object of this converter's type.\n-     * \n-     * @param object  the object to convert\n-     * @return the millisecond instant\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    long getInstantMillis(Object object);\n-    \n-    /**\n-     * Extracts the millis from an object of this converter's type. The zone\n-     * parameter is a hint to the converter, should it require a time zone to\n-     * aid in conversion.\n-     * \n-     * @param object  the object to convert\n-     * @param zone  the zone to use, null means default zone\n-     * @return the millisecond instant\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    long getInstantMillis(Object object, DateTimeZone zone);\n-    \n-    /**\n-     * Extracts the millis from an object of this converter's type. The chrono\n-     * parameter is a hint to the converter, should it require a chronology to\n-     * aid in conversion.\n-     * \n-     * @param object  the object to convert\n-     * @param chrono  the chronology to use, null usually means ISO\n-     * @return the millisecond instant\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    long getInstantMillis(Object object, Chronology chrono);\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Extracts the chronology from an object of this converter's type.\n-     * \n-     * @param object  the object to convert\n-     * @return the chronology, never null\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    Chronology getChronology(Object object);\n-    \n     /**\n      * Extracts the chronology from an object of this converter's type\n      * where the time zone is specified.\n      * @throws ClassCastException if the object is invalid\n      */\n     Chronology getChronology(Object object, DateTimeZone zone);\n-    \n+\n     /**\n      * Extracts the chronology from an object of this converter's type\n-     * where the chronology is specified.\n+     * where the chronology may be specified.\n+     * <p>\n+     * If the chronology is non-null it should be used. If it is null, then the\n+     * object should be queried, and if it has no chronology then ISO default is used.\n      * \n      * @param object  the object to convert\n-     * @param chrono  the chronology to use, null usually means ISO\n+     * @param chrono  the chronology to use, null means use object\n      * @return the chronology, never null\n      * @throws ClassCastException if the object is invalid\n      */\n     Chronology getChronology(Object object, Chronology chrono);\n-    \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this converter's type.\n+     * <p>\n+     * The chronology passed in is the result of the call to <code>getChronology</code>.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the millisecond instant\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    long getInstantMillis(Object object, Chronology chrono);\n+\n }\n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n+\n /**\n  * LongConverter converts a Long to an instant, partial or duration.\n  * The Long value represents milliseconds in the ISO chronology.\n  */\n class LongConverter extends AbstractConverter\n         implements InstantConverter, PartialConverter, DurationConverter {\n-    \n+\n     /**\n      * Singleton instance.\n      */\n     static final LongConverter INSTANCE = new LongConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n     /**\n      * Gets the millisecond instant, which is the Long value.\n      * \n-     * @param object  the object to convert, must not be null\n-     * @return the millisecond instant\n+     * @param object  the Long to convert, must not be null\n+     * @param chrono  the chronology to use, which is always non-null\n+     * @return the millisecond value\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n      */\n-    public long getInstantMillis(Object object) {\n+    public long getInstantMillis(Object object, Chronology chrono) {\n         return ((Long) object).longValue();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the millisecond duration, which is the Long value.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the Long to convert, must not be null\n      * @return the millisecond duration\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n  */\n class NullConverter extends AbstractConverter\n         implements InstantConverter, PartialConverter, DurationConverter, PeriodConverter, IntervalConverter {\n-    \n+\n     /**\n      * Singleton instance.\n      */\n     static final NullConverter INSTANCE = new NullConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the millisecond instant, which is now.\n-     * \n-     * @param object  the object to convert\n-     * @return the millisecond instant of now\n-     */\n-    public long getInstantMillis(Object object) {\n-        return DateTimeUtils.currentTimeMillis();\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n      * Gets the millisecond duration, which is zero.\n      * \n-     * @param object  the object to convert\n+     * @param object  the object to convert, which is null\n      * @return the millisecond duration\n      */\n     public long getDurationMillis(Object object) {\n      * Sets the given ReadWritableDuration to zero milliseconds.\n      *\n      * @param duration duration to get modified\n-     * @param object  the object to convert\n+     * @param object  the object to convert, which is null\n      * @param chrono  the chronology to use\n      * @throws NullPointerException if the duration is null\n      */\n      * type, and sets them into the given ReadWritableInterval.\n      *\n      * @param writableInterval interval to get modified, not null\n-     * @param object  the object to convert, must not be null\n+     * @param object  the object to convert, which is null\n      * @param chrono  the chronology to use, may be null\n      * @throws NullPointerException if the interval is null\n      */\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.ISOChronology;\n      * Singleton instance.\n      */\n     static final ReadableInstantConverter INSTANCE = new ReadableInstantConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Extracts the millis from an object of this convertor's type.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @return the millisecond value\n-     */\n-    public long getInstantMillis(Object object) {\n-        return ((ReadableInstant) object).getMillis();\n-    }\n-    \n-    /**\n-     * Gets the chronology, which is taken from the ReadableInstant.\n-     * If the chronology on the instant is null, the ISOChronology in the\n-     * default time zone is used.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @return the chronology, never null\n-     */\n-    public Chronology getChronology(Object object) {\n-        Chronology chrono = ((ReadableInstant) object).getChronology();\n-        if (chrono == null) {\n-            return ISOChronology.getInstance();\n-        }\n-        return chrono;\n-    }\n-    \n-    /**\n      * Gets the chronology, which is taken from the ReadableInstant.\n      * If the chronology on the instant is null, the ISOChronology in the\n      * specified time zone is used.\n      * If the chronology on the instant is not in the specified zone, it is\n      * adapted.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the ReadableInstant to convert, must not be null\n      * @param zone  the specified zone to use, null means default zone\n      * @return the chronology, never null\n      */\n         return chrono;\n     }\n \n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * <p>\n+     * If the passed in chronology is non-null, it is used.\n+     * Otherwise the chronology from the instant is used.\n+     * \n+     * @param object  the ReadableInstant to convert, must not be null\n+     * @param chrono  the chronology to use, null means use that from object\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ((ReadableInstant) object).getChronology();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the ReadableInstant to convert, must not be null\n+     * @param chrono  the non-null result of getChronology\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return ((ReadableInstant) object).getMillis();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns ReadableInstant.class.\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n import org.joda.time.Period;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n-import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.ISODateTimeFormat;\n     /**\n      * Gets the millis, which is the ISO parsed string value.\n      * \n-     * @param object  the object to convert, must not be null\n-     * @param zone  the zone to use, null means default zone\n+     * @param object  the String to convert, must not be null\n+     * @param chrono  the chronology to use, non-null result of getChronology\n      * @return the millisecond value\n      * @throws IllegalArgumentException if the value if invalid\n      */\n-    public long getInstantMillis(Object object, DateTimeZone zone) {\n+    public long getInstantMillis(Object object, Chronology chrono) {\n         String str = (String) object;\n-        Chronology chrono = ISOChronology.getInstance(zone);\n         DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n         return p.parseMillis(str);\n     }\n \n-    /**\n-     * Gets the millis, which is the ISO parsed string value.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @param chrono  the chronology to use, null means ISOChronology\n-     * @return the millisecond value\n-     * @throws IllegalArgumentException if the value if invalid\n-     */\n-    public long getInstantMillis(Object object, Chronology chrono) {\n-        String str = (String) object;\n-        chrono = getChronology(object, chrono);\n-        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();\n-        return p.parseMillis(str);\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the duration of the string using the standard type.\n      * This matches the toString() method of ReadableDuration.\n      * \n-     * @param object  the object to convert, must not be null\n+     * @param object  the String to convert, must not be null\n      * @throws ClassCastException if the object is invalid\n      */\n     public long getDurationMillis(Object object) {\n      * sets them into the given ReadWritableDuration.\n      *\n      * @param period  period to get modified\n-     * @param object  the object to convert, must not be null\n+     * @param object  the String to convert, must not be null\n      * @param chrono  the chronology to use\n      * @return the millisecond duration\n      * @throws ClassCastException if the object is invalid\n      * Sets the value of the mutable interval from the string.\n      * \n      * @param writableInterval  the interval to set\n-     * @param object  the string to set from\n+     * @param object  the String to convert, must not be null\n      * @param chrono  the chronology to use, may be null\n      */\n     public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n--- a/JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/MockZeroNullIntegerConverter.java\n     \n     public static final InstantConverter INSTANCE = new MockZeroNullIntegerConverter();\n \n-    public long getInstantMillis(Object object) {\n-        return 0;\n-    }\n-\n-    public long getInstantMillis(Object object, DateTimeZone zone) {\n-        return 0;\n-    }\n-\n     public long getInstantMillis(Object object, Chronology chrono) {\n         return 0;\n-    }\n-\n-    public Chronology getChronology(Object object) {\n-        return null;\n     }\n \n     public Chronology getChronology(Object object, DateTimeZone zone) {\n--- a/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetInstantMillis_Object() throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar();\n-        cal.setTime(new Date(123L));\n-        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal));\n-    }\n-\n-    public void testGetInstantMillis_Object_Zone() throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar();\n-        cal.setTime(new Date(123L));\n-        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, PARIS));\n-        assertEquals(123L, cal.getTime().getTime());\n-        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (DateTimeZone) null));\n-        assertEquals(123L, cal.getTime().getTime());\n-    }\n-\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         GregorianCalendar cal = new GregorianCalendar();\n         cal.setTime(new Date(123L));\n         assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));\n         assertEquals(123L, cal.getTime().getTime());\n-        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (Chronology) null));\n-        assertEquals(123L, cal.getTime().getTime());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Paris\"));\n-        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal));\n-        \n-        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n-        cal.setGregorianChange(new Date(0L));\n-        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal));\n-        \n-        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n-        cal.setGregorianChange(new Date(Long.MAX_VALUE));\n-        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));\n-        \n-        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n-        cal.setGregorianChange(new Date(Long.MIN_VALUE));\n-        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));\n-        \n-        cal = new GregorianCalendar(new MockUnknownTimeZone());\n-        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal));\n-        \n-        Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n-        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc));\n-        \n-        try {\n-            Calendar bc = (Calendar) Class.forName(\"sun.util.BuddhistCalendar\").newInstance();\n-            bc.setTimeZone(TimeZone.getTimeZone(\"Europe/Moscow\"));\n-            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc));\n-        } catch (ClassNotFoundException ex) {\n-            // ignore\n-        }\n-    }\n-\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testGetChronology_Object_Zone() throws Exception {\n         GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Paris\"));\n         assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));\n         }\n     }\n \n+    public void testGetChronology_Object_nullChronology() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Paris\"));\n+        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n+        \n+        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n+        cal.setGregorianChange(new Date(0L));\n+        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n+        \n+        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n+        cal.setGregorianChange(new Date(Long.MAX_VALUE));\n+        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n+        \n+        cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n+        cal.setGregorianChange(new Date(Long.MIN_VALUE));\n+        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n+        \n+        cal = new GregorianCalendar(new MockUnknownTimeZone());\n+        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n+        \n+        Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n+        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc, (Chronology) null));\n+        \n+        try {\n+            Calendar bc = (Calendar) Class.forName(\"sun.util.BuddhistCalendar\").newInstance();\n+            bc.setTimeZone(TimeZone.getTimeZone(\"Europe/Moscow\"));\n+            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc, (Chronology) null));\n+        } catch (ClassNotFoundException ex) {\n+            // ignore\n+        }\n+    }\n+\n     public void testGetChronology_Object_Chronology() throws Exception {\n         GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Paris\"));\n         assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN));\n-        assertEquals(ISO, CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetInstantMillis_Object() throws Exception {\n-        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L)));\n-    }\n-\n-    public void testGetInstantMillis_Object_Zone() throws Exception {\n-        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), PARIS));\n-        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (DateTimeZone) null));\n-    }\n-\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));\n         assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L)));\n-    }\n-\n     public void testGetChronology_Object_Zone() throws Exception {\n         assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS));\n         assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null));\n     //-----------------------------------------------------------------------\n     public void testGetPartialValues() throws Exception {\n         TimeOfDay tod = new TimeOfDay();\n-        int[] expected = Chronology.getISO().get(tod, 12345678L);\n-        int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), Chronology.getISO());\n+        int[] expected = Chronology.getCoptic().get(tod, 12345678L);\n+        int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), Chronology.getCoptic());\n         assertEquals(true, Arrays.equals(expected, actual));\n     }\n \n--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetInstantMillis_Object() throws Exception {\n-        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L)));\n-    }\n-\n-    public void testGetInstantMillis_Object_Zone() throws Exception {\n-        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), PARIS));\n-        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (DateTimeZone) null));\n-    }\n-\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN));\n         assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L)));\n-    }\n-\n     public void testGetChronology_Object_Zone() throws Exception {\n         assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS));\n         assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null));\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetInstantMillis_Object() throws Exception {\n-        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null));\n-    }\n-\n-    public void testGetInstantMillis_Object_Zone() throws Exception {\n-        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, PARIS));\n-        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (DateTimeZone) null));\n-    }\n-\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN));\n         assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null));\n-    }\n-\n     public void testGetChronology_Object_Zone() throws Exception {\n         assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS));\n         assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null));\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableInstantConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetInstantMillis_Object() throws Exception {\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L)));\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L)));\n-    }\n-\n-    public void testGetInstantMillis_Object_Zone() throws Exception {\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), PARIS));\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), PARIS));\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (DateTimeZone) null));\n-        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (DateTimeZone) null));\n-    }\n-\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));\n         assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));\n-        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L)));\n-        \n-        MutableDateTime mdt = new MutableDateTime() {\n-            public Chronology getChronology() {\n-                return null; // bad\n-            }\n-        };\n-        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(mdt));\n-    }\n-\n     public void testGetChronology_Object_Zone() throws Exception {\n         assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));\n         assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));\n         assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(mdt, PARIS));\n     }\n \n+    public void testGetChronology_Object_nullChronology() throws Exception {\n+        assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));\n+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));\n+        \n+        MutableDateTime mdt = new MutableDateTime() {\n+            public Chronology getChronology() {\n+                return null; // bad\n+            }\n+        };\n+        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(mdt, (Chronology) null));\n+    }\n+\n     public void testGetChronology_Object_Chronology() throws Exception {\n         assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN));\n         assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN));\n-        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));\n-        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n  */\n public class TestStringConverter extends TestCase {\n \n-    private static final DateTimeZone ONE_HOUR = DateTimeZone.getInstance(\"+01:00\");\n+    private static final DateTimeZone ONE_HOUR = DateTimeZone.getInstance(1);\n+    private static final DateTimeZone EIGHT = DateTimeZone.getInstance(8);\n     private static final DateTimeZone UTC = DateTimeZone.UTC;\n     private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n     private static final Chronology ISO = ISOChronology.getInstance();\n     private static final Chronology JULIAN = JulianChronology.getInstance();\n+    private static final Chronology ISO_EIGHT = ISOChronology.getInstance(EIGHT);\n     private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);\n     \n     private DateTimeZone zone = null;\n     private Locale locale = null;\n \n     //-----------------------------------------------------------------------\n     public void testGetInstantMillis_Object() throws Exception {\n-        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+01:00\"));\n-        \n-        dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-161T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24-3T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24T+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12.5+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24.5+01:00\"));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, ONE_HOUR);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.5+01:00\"));\n+        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-161T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24-3T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24T+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12.5+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24.5+08:00\", ISO_EIGHT));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, EIGHT);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.5+08:00\", ISO_EIGHT));\n         \n         dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\"));\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", ISO));\n     }\n \n     public void testGetInstantMillis_Object_Zone() throws Exception {\n         DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+02:00\", PARIS));\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+02:00\", ISO_PARIS));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", ISO_PARIS));\n         \n         dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+01:00\", (DateTimeZone) null));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", PARIS));\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+01:00\", ISO_LONDON));\n         \n         dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", (DateTimeZone) null));\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", ISO_LONDON));\n     }\n \n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, JulianChronology.getInstance(LONDON));\n         assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+01:00\", JULIAN));\n-        \n-        dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ISOChronology.getInstance(LONDON));\n-        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+01:00\", (Chronology) null));\n     }\n \n     public void testGetInstantMillisInvalid() {\n         try {\n-            StringConverter.INSTANCE.getInstantMillis(\"\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            StringConverter.INSTANCE.getInstantMillis(\"X\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testGetChronology_Object() throws Exception {\n-        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501+01:00\"));\n-        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501\"));\n-    }\n-\n+            StringConverter.INSTANCE.getInstantMillis(\"\", (Chronology) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getInstantMillis(\"X\", (Chronology) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testGetChronology_Object_Zone() throws Exception {\n         assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501+01:00\", PARIS));\n         assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501\", PARIS));", "timestamp": 1095003916, "metainfo": ""}