{"sha": "7921e43100636354324712b59fbe1b9e294a04d7", "log": "Add DateTimeFormatter.parseLocalDate(), .parseLocalTime(), .parseLocalDateTime()  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDate;\n+import org.joda.time.LocalDateTime;\n+import org.joda.time.LocalTime;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n     }\n \n     /**\n+     * Parses only the local date from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local date will be used.\n+     * This means that any parsed time, time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed date, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public LocalDate parseLocalDate(String text) {\n+        return parseLocalDateTime(text).toLocalDate();\n+    }\n+\n+    /**\n+     * Parses only the local time from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local time will be used.\n+     * This means that any parsed date, time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed time, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public LocalTime parseLocalTime(String text) {\n+        return parseLocalDateTime(text).toLocalTime();\n+    }\n+\n+    /**\n+     * Parses only the local date-time from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local date-time will be used.\n+     * This means that any parsed time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed date-time, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public LocalDateTime parseLocalDateTime(String text) {\n+        DateTimeParser parser = requireParser();\n+        \n+        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true, text);\n+                if (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new LocalDateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n      * Parses a datetime from the given text, returning a new DateTime.\n      * <p>\n      * The parse will use the zone and chronology specified on this formatter.\n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2009 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDate;\n+import org.joda.time.LocalDateTime;\n+import org.joda.time.LocalTime;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadablePartial;\n import org.joda.time.chrono.BuddhistChronology;\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testParseLocalDate_simple() {\n+        assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30Z\"));\n+        assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30+18:00\"));\n+        assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30-18:00\"));\n+        assertEquals(new LocalDate(2004, 6, 9, BUDDHIST_PARIS),\n+                g.withChronology(BUDDHIST_PARIS).parseLocalDate(\"2004-06-09T10:20:30Z\"));\n+        try {\n+            g.parseDateTime(\"ABC\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testParseLocalTime_simple() {\n+        assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30Z\"));\n+        assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30+18:00\"));\n+        assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30-18:00\"));\n+        assertEquals(new LocalTime(10, 20, 30, 0, BUDDHIST_PARIS),\n+                g.withChronology(BUDDHIST_PARIS).parseLocalTime(\"2004-06-09T10:20:30Z\"));\n+        try {\n+            g.parseDateTime(\"ABC\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testParseLocalDateTime_simple() {\n+        assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30Z\"));\n+        assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30+18:00\"));\n+        assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30-18:00\"));\n+        assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 0, BUDDHIST_PARIS),\n+                g.withChronology(BUDDHIST_PARIS).parseLocalDateTime(\"2004-06-09T10:20:30Z\"));\n+        try {\n+            g.parseDateTime(\"ABC\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testParseDateTime_simple() {\n         DateTime expect = null;\n         expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);", "timestamp": 1257622476, "metainfo": ""}