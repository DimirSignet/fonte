{"sha": "fa85e52f102ba75426ebf3bb49533009235ee3e0", "log": "Reduced temporary object allocations during parse.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n  */\n package org.joda.time.format;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Locale;\n \n     DateTimeZone iZone;\n     int iOffset;\n \n-    ArrayList iSavedFields = new ArrayList();\n+    SavedField[] iSavedFields = new SavedField[8];\n+    int iSavedFieldsCount;\n+    boolean iSavedFieldsShared;\n+\n+    private Object iSavedState;\n \n     /**\n      * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n      * @param zone the date time zone to operate in, or null if UTC\n      */\n     public void setDateTimeZone(DateTimeZone zone) {\n+        iSavedState = null;\n         iZone = zone == DateTimeZone.UTC ? null : zone;\n         iOffset = 0;\n     }\n      * overrides the time zone.\n      */\n     public void setOffset(int offset) {\n+        iSavedState = null;\n         iOffset = offset;\n         iZone = null;\n     }\n      * Saves a datetime field value.\n      */\n     public void saveField(DateTimeField field, int value) {\n-        iSavedFields.add(new SavedField(field, value));\n+        saveField(new SavedField(field, value));\n     }\n \n     /**\n      * Saves a datetime field text value.\n      */\n     public void saveField(DateTimeField field, String text, Locale locale) {\n-        iSavedFields.add(new SavedField(field, text, locale));\n+        saveField(new SavedField(field, text, locale));\n+    }\n+\n+    private void saveField(SavedField field) {\n+        SavedField[] savedFields = iSavedFields;\n+        int savedFieldsCount = iSavedFieldsCount;\n+\n+        if (savedFieldsCount == savedFields.length) {\n+            SavedField[] newArray = new SavedField[savedFieldsCount * 2];\n+            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n+            iSavedFields = savedFields = newArray;\n+            iSavedFieldsShared = false;\n+        } else if (iSavedFieldsShared) {\n+            iSavedFields = savedFields = (SavedField[])savedFields.clone();\n+            iSavedFieldsShared = false;\n+        }\n+\n+        iSavedState = null;\n+        savedFields[savedFieldsCount] = field;\n+        iSavedFieldsCount = savedFieldsCount + 1;\n     }\n \n     /**\n      * @return opaque saved state, which may be passed to undoChanges\n      */\n     public Object saveState() {\n-        Object state = new SavedState();\n-        iSavedFields = (ArrayList)iSavedFields.clone();\n-        return state;\n+        if (iSavedState == null) {\n+            iSavedState = new SavedState();\n+        }\n+        return iSavedState;\n     }\n \n     /**\n      */\n     public boolean undoChanges(Object savedState) {\n         if (savedState instanceof SavedState) {\n-            return ((SavedState)savedState).revertState(this);\n+            if (((SavedState)savedState).revertState(this)) {\n+                iSavedState = savedState;\n+                return true;\n+            }\n         }\n         return false;\n     }\n \n     /**\n-     * Computes the parsed datetime by setting the saved fields.\n-     * Calling this method does not affect the state of this object.\n+     * Computes the parsed datetime by setting the saved fields. This method is\n+     * idempotent, but it is not thread-safe.\n      *\n      * @return milliseconds since 1970-01-01T00:00:00Z\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     public long computeMillis() {\n-        int length = iSavedFields.size();\n-        SavedField[] savedFields = new SavedField[length];\n-        iSavedFields.toArray(savedFields);\n-\n-        Arrays.sort(savedFields);\n+        SavedField[] savedFields = iSavedFields;\n+        int count = iSavedFieldsCount;\n+        Arrays.sort(savedFields, 0, count);\n \n         long millis = iMillis;\n-        for (int i=0; i<length; i++) {\n+        for (int i=0; i<count; i++) {\n             millis = savedFields[i].set(millis);\n         }\n \n     private class SavedState {\n         final DateTimeZone iZone;\n         final int iOffset;\n-        final ArrayList iSavedFields;\n+        final SavedField[] iSavedFields;\n+        final int iSavedFieldsCount;\n \n         SavedState() {\n             this.iZone = DateTimeParserBucket.this.iZone;\n             this.iOffset = DateTimeParserBucket.this.iOffset;\n             this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n+            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n+            DateTimeParserBucket.this.iSavedFieldsShared = true;\n         }\n \n         boolean revertState(DateTimeParserBucket enclosing) {\n             DateTimeParserBucket.this.iZone = this.iZone;\n             DateTimeParserBucket.this.iOffset = this.iOffset;\n             DateTimeParserBucket.this.iSavedFields = this.iSavedFields;\n+            DateTimeParserBucket.this.iSavedFieldsCount = this.iSavedFieldsCount;\n+            DateTimeParserBucket.this.iSavedFieldsShared = true;\n             return true;\n         }\n     }", "timestamp": 1073273761, "metainfo": ""}