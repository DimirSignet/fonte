{"sha": "ba5b23c9eae7ef4fbe19cf4cfa726d973bbb0149", "log": "Add DateTimeZone.isLocalDateTimeGap  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n         return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n     }\n \n+//    //-----------------------------------------------------------------------\n+//    /**\n+//     * Checks if the given {@link LocalDateTime} is within an overlap.\n+//     * <p>\n+//     * When switching from Daylight Savings Time to standard time there is\n+//     * typically an overlap where the same clock hour occurs twice. This\n+//     * method identifies whether the local datetime refers to such an overlap.\n+//     * \n+//     * @param localDateTime  the time to check, not null\n+//     * @return true if the given datetime refers to an overlap\n+//     */\n+//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n+//        if (isFixed()) {\n+//            return false;\n+//        }\n+//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n+//        // get the offset at instantLocal (first estimate)\n+//        int offsetLocal = getOffset(instantLocal);\n+//        // adjust instantLocal using the estimate and recalc the offset\n+//        int offset = getOffset(instantLocal - offsetLocal);\n+//        // if the offsets differ, we must be near a DST boundary\n+//        if (offsetLocal != offset) {\n+//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n+//            long nextAdjusted = nextTransition(instantLocal - offset);\n+//            if (nextLocal != nextAdjusted) {\n+//                // in DST gap\n+//                return false;\n+//            }\n+//            long diff = Math.abs(offset - offsetLocal);\n+//            DateTime dateTime = localDateTime.toDateTime(this);\n+//            DateTime adjusted = dateTime.plus(diff);\n+//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//                return true;\n+//            }\n+//            adjusted = dateTime.minus(diff);\n+//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//                return true;\n+//            }\n+//            return false;\n+//        }\n+//        return false;\n+//    }\n+//        \n+//        \n+//        DateTime dateTime = null;\n+//        try {\n+//            dateTime = localDateTime.toDateTime(this);\n+//        } catch (IllegalArgumentException ex) {\n+//            return false;  // it is a gap, not an overlap\n+//        }\n+//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n+//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n+//        long offset = Math.max(offset1, offset2);\n+//        if (offset == 0) {\n+//            return false;\n+//        }\n+//        DateTime adjusted = dateTime.plus(offset);\n+//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//            return true;\n+//        }\n+//        adjusted = dateTime.minus(offset);\n+//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//            return true;\n+//        }\n+//        return false;\n+        \n+//        long millis = dateTime.getMillis();\n+//        long nextTransition = nextTransition(millis);\n+//        long previousTransition = previousTransition(millis);\n+//        long deltaToPreviousTransition = millis - previousTransition;\n+//        long deltaToNextTransition = nextTransition - millis;\n+//        if (deltaToNextTransition < deltaToPreviousTransition) {\n+//            int offset = getOffset(nextTransition);\n+//            int standardOffset = getStandardOffset(nextTransition);\n+//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n+//                return true;\n+//            }\n+//        } else  {\n+//            int offset = getOffset(previousTransition);\n+//            int standardOffset = getStandardOffset(previousTransition);\n+//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n+//                return true;\n+//            }\n+//        }\n+//        return false;\n+//    }\n+\n+    /**\n+     * Checks if the given {@link LocalDateTime} is within a gap.\n+     * <p>\n+     * When switching from standard time to Daylight Savings Time there is\n+     * typically a gap where a clock hour is missing. This method identifies\n+     * whether the local datetime refers to such a gap.\n+     * \n+     * @param localDateTime  the time to check, not null\n+     * @return true if the given datetime refers to a gap\n+     */\n+    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n+        if (isFixed()) {\n+            return false;\n+        }\n+        try {\n+            localDateTime.toDateTime(this);\n+            return false;\n+        } catch (IllegalArgumentException ex) {\n+            return true;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns true if this time zone has no transitions.\n      *\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n         assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));\n     }\n \n+//    //-----------------------------------------------------------------------\n+//    public void testIsLocalDateTimeOverlap_Berlin() {\n+//        DateTimeZone zone = DateTimeZone.forID(\"Europe/Berlin\");\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 1, 0)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 1, 59, 59, 99)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 0)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 30)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 59, 59, 99)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 3, 0)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 4, 0)));\n+//        \n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 1, 30)));  // before gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 2, 30)));  // gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 3, 30)));  // after gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 12, 24, 12, 34)));\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    public void testIsLocalDateTimeOverlap_NewYork() {\n+//        DateTimeZone zone = DateTimeZone.forID(\"America/New_York\");\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 0, 0)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 0, 59, 59, 99)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 0)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 30)));\n+//        assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 59, 59, 99)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 2, 0)));\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 3, 0)));\n+//        \n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 1, 30)));  // before gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 2, 30)));  // gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 3, 30)));  // after gap\n+//        assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 12, 24, 12, 34)));\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsLocalDateTimeGap_Berlin() {\n+        DateTimeZone zone = DateTimeZone.forID(\"Europe/Berlin\");\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 0)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 59, 59, 99)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 0)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 30)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 59, 59, 99)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 3, 0)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 4, 0)));\n+        \n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 1, 30)));  // before overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 2, 30)));  // overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 3, 30)));  // after overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsLocalDateTimeGap_NewYork() {\n+        DateTimeZone zone = DateTimeZone.forID(\"America/New_York\");\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 0)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 59, 59, 99)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 0)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 30)));\n+        assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 59, 59, 99)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 3, 0)));\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 4, 0)));\n+        \n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 0, 30)));  // before overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 1, 30)));  // overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 2, 30)));  // after overlap\n+        assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34)));\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testToTimeZone() {\n         DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");", "timestamp": 1225148613, "metainfo": ""}