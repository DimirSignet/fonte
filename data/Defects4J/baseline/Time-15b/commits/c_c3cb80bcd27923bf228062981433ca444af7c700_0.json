{"sha": "c3cb80bcd27923bf228062981433ca444af7c700", "log": "Change constructors to protected   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n     /**\n      * Constructor.\n      */\n-    public AbstractDuration() {\n+    protected AbstractDuration() {\n         super();\n     }\n \n--- a/JodaTime/src/java/org/joda/time/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractPartial.java\n      * being initialised. Once the constructor is complete, all further calculations\n      * are performed without reference to a timezone (by switching to UTC).\n      */\n-    public AbstractPartial() {\n+    protected AbstractPartial() {\n         this(DateTimeUtils.currentTimeMillis(), null);\n     }\n \n      *\n      * @param chronology  the chronology, null means ISOChronology in the default zone\n      */\n-    public AbstractPartial(Chronology chronology) {\n+    protected AbstractPartial(Chronology chronology) {\n         this(DateTimeUtils.currentTimeMillis(), chronology);\n     }\n \n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n      */\n-    public AbstractPartial(long instant) {\n+    protected AbstractPartial(long instant) {\n         this(instant, null);\n     }\n \n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n      * @param chronology  the chronology, null means ISOChronology in the default zone\n      */\n-    public AbstractPartial(long instant, Chronology chronology) {\n+    protected AbstractPartial(long instant, Chronology chronology) {\n         super();\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n      * @param instant  the datetime object, must not be null\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public AbstractPartial(Object instant) {\n+    protected AbstractPartial(Object instant) {\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         long millis = converter.getInstantMillis(instant);\n      * @param chronology  the chronology, null means ISOChronology\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public AbstractPartial(Object instant, Chronology chronology) {\n+    protected AbstractPartial(Object instant, Chronology chronology) {\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         long millis = converter.getInstantMillis(instant, chronology);\n      * @param values  the new set of values\n      * @param chronology  the chronology, null means ISOChronology in the default zone\n      */\n-    public AbstractPartial(int[] values, Chronology chronology) {\n+    protected AbstractPartial(int[] values, Chronology chronology) {\n         super();\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n--- a/JodaTime/src/java/org/joda/time/AbstractPeriod.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractPeriod.java\n     /** The period type that allocates the duration to fields */\n     private final PeriodType iType;\n     /** The object state */\n-    private int iState;\n+    private transient int iState;\n     /** The duration, if known */\n-    private long iDuration;\n+    private transient long iDuration;\n     /** Value for years */\n     private int iYears;\n     /** Value for months */\n      * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    public AbstractPeriod(long duration, PeriodType type) {\n+    protected AbstractPeriod(long duration, PeriodType type) {\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n      * @throws IllegalArgumentException if period type is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    public AbstractPeriod(int years, int months, int weeks, int days,\n+    protected AbstractPeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis,\n                             PeriodType type) {\n         super();\n      * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    public AbstractPeriod(long startInstant, long endInstant, PeriodType type) {\n+    protected AbstractPeriod(long startInstant, long endInstant, PeriodType type) {\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n      * @param type  which set of fields this period supports\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    public AbstractPeriod(\n+    protected AbstractPeriod(\n             ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n         super();\n         type = checkPeriodType(type);\n      * @throws IllegalArgumentException if period is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    public AbstractPeriod(Object period, PeriodType type) {\n+    protected AbstractPeriod(Object period, PeriodType type) {\n         super();\n         PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n         type = (type == null ? converter.getPeriodType(period, false) : type);\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     public final Instant addTo(ReadableInstant instant, int scalar) {\n-        if (instant == null) {\n-            return new Instant(addTo(DateTimeUtils.currentTimeMillis(), scalar));\n-        }\n-        return new Instant(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return new Instant(addTo(instantMillis, scalar, instant.getChronology()));\n     }\n \n     /**", "timestamp": 1092524916, "metainfo": ""}