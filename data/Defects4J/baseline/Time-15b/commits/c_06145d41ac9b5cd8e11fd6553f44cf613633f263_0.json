{"sha": "06145d41ac9b5cd8e11fd6553f44cf613633f263", "log": "Add a compare to method   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n  */\n package org.joda.time.field;\n \n+import java.io.Serializable;\n import java.util.Locale;\n-import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DurationField;\n import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n \n /**\n  * AbstractReadableInstantFieldProperty is a base class for binding a\n     public abstract DateTimeField getField();\n \n     /**\n+     * Gets the field type being used.\n+     * \n+     * @return the field type\n+     */\n+    public DateTimeFieldType getFieldType() {\n+        return getField().getType();\n+    }\n+\n+    /**\n      * Gets the name of the field.\n      * \n      * @return the field name\n     /**\n      * Compare this field to the same field on another instant.\n      * <p>\n-     * The {@link #get()} method is used to obtain the value to compare for\n-     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n-     * is used for the specified instant.\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other instant will be queried\n+     * whether in the same chronology or not.\n      * \n      * @param instant  the instant to compare to\n      * @return negative value if this is less, 0 if equal, or positive value if greater\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n         int thisValue = get();\n-        int otherValue = instant.get(getField());\n+        Chronology chrono = DateTimeUtils.getChronology(instant.getChronology());\n+        int otherValue = getFieldType().getField(chrono).get(instant.getMillis());\n         if (thisValue < otherValue) {\n             return -1;\n         } else if (thisValue > otherValue) {\n         }\n     }\n \n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param partial  the partial to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the field of this property cannot be queried\n+     *  on the specified instant\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = partial.get(getFieldType());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Output a debugging string.\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n         assertEquals(true, test2.year().compareTo(test1) > 0);\n         assertEquals(true, test1.year().compareTo(test1) == 0);\n         try {\n-            test1.year().compareTo(null);\n+            test1.year().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertyCompareToYear2() {\n+        DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        YearMonthDay test2 = new YearMonthDay(2004, 6, 9);\n+        YearMonthDay test3 = new YearMonthDay(2005, 6, 9);\n+        assertEquals(true, test1.year().compareTo(test1) == 0);\n+        assertEquals(true, test2.year().compareTo(test2) == 0);\n+        assertEquals(true, test3.year().compareTo(test3) == 0);\n+        \n+        assertEquals(true, test1.year().compareTo(test2) == 0);\n+        assertEquals(true, test2.year().compareTo(test1) == 0);\n+        assertEquals(true, test1.year().compareTo(test3) < 0);\n+        assertEquals(true, test3.year().compareTo(test1) > 0);\n+        try {\n+            test1.year().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }", "timestamp": 1094376496, "metainfo": ""}