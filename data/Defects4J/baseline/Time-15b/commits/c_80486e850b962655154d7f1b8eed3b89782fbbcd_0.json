{"sha": "80486e850b962655154d7f1b8eed3b89782fbbcd", "log": "Support parsing of date-time zone names like BST or British Summer Time  New API where caller must pas in the lookup table", "commit": "\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n     }\n \n     /**\n-     * Instructs the printer to emit a locale-specific time zone name. A\n-     * parser cannot be created from this builder if a time zone name is\n-     * appended.\n+     * Instructs the printer to emit a locale-specific time zone name.\n+     * Using this method prevents parsing, because time zone names are not unique.\n+     * See {@link #appendTimeZoneName(Map)}.\n      *\n      * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n-        return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);\n+        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n+     * Time zone names are not unique, thus the API forces you to supply the lookup.\n+     * The names are searched in the order of the map, thus it is strongly recommended\n+     * to use a {@code LinkedHashMap} or similar.\n+     *\n+     * @param parseLookup  the table of names, not null\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n+        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n+        return append0(pp, pp);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific time zone name.\n+     * Using this method prevents parsing, because time zone names are not unique.\n+     * See {@link #appendTimeZoneShortName(Map)}.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n+        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n     }\n \n     /**\n      * Instructs the printer to emit a short locale-specific time zone\n-     * name. A parser cannot be created from this builder if time zone\n-     * name is appended.\n-     *\n-     * @return this DateTimeFormatterBuilder, for chaining\n-     */\n-    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n-        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);\n+     * name, providing a lookup for parsing.\n+     * Time zone names are not unique, thus the API forces you to supply the lookup.\n+     * The names are searched in the order of the map, thus it is strongly recommended\n+     * to use a {@code LinkedHashMap} or similar.\n+     *\n+     * @param parseLookup  the table of names, not null\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n+        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n+        return append0(pp, pp);\n     }\n \n     /**\n \n     //-----------------------------------------------------------------------\n     static class TimeZoneName\n-            implements DateTimePrinter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         static final int LONG_NAME = 0;\n         static final int SHORT_NAME = 1;\n \n+        private final Map<String, DateTimeZone> iParseLookup;\n         private final int iType;\n \n-        TimeZoneName(int type) {\n+        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n             super();\n             iType = type;\n+            iParseLookup = parseLookup;\n         }\n \n         public int estimatePrintedLength() {\n \n         public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             // no zone info\n+        }\n+\n+        public int estimateParsedLength() {\n+            return (iType == SHORT_NAME ? 4 : 20);\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            String str = text.substring(position);\n+            for (String name : iParseLookup.keySet()) {\n+                if (str.startsWith(name)) {\n+                    bucket.setZone(iParseLookup.get(name));\n+                    return position + name.length();\n+                }\n+            }\n+            return ~position;\n         }\n     }\n \n--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n  */\n package org.joda.time.format;\n \n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n  */\n public class TestDateTimeFormatterBuilder extends TestCase {\n \n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+\n     public static void main(String[] args) {\n         junit.textui.TestRunner.run(suite());\n     }\n         bld.appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        assertEquals(\"Asia/Tokyo\", f.print(new DateTime(2007, 3, 4, 0, 0, 0, zone)));\n-        assertEquals(zone, f.parseDateTime(\"Asia/Tokyo\").getZone());\n+        assertEquals(\"Asia/Tokyo\", f.print(new DateTime(2007, 3, 4, 0, 0, 0, TOKYO)));\n+        assertEquals(TOKYO, f.parseDateTime(\"Asia/Tokyo\").getZone());\n         try {\n             f.parseDateTime(\"Nonsense\");\n             fail();\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n         assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n     }\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, PARIS);\n         assertEquals(\"2007-03-04 12:30 Europe/Paris\", f.print(dt));\n         assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n         assertEquals(dt, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n         assertEquals(dt.withZone(DateTimeZone.getDefault()), f.parseDateTime(\"2007-03-04 12:30 +09:00\"));\n-        assertEquals(dt, f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(dt, f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +09:00\"));\n         assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00\"));\n     }\n \n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n-        assertEquals(dt, f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n-        assertEquals(dt.withZone(paris), f.withZone(paris).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt, f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt.withZone(PARIS), f.withZone(PARIS).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n         assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n     }\n \n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n         DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n         // parses offset time then adjusts to requested zone\n-        assertEquals(expected.withZone(zone), f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+        assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +07:00\"));\n         // parses offset time returning offset zone\n         assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00\"));\n         // parses offset time then converts to default zone\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n         DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n         // parses offset time then adjusts to parsed zone\n-        assertEquals(expected.withZone(zone), f.parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        assertEquals(expected.withZone(TOKYO), f.parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n         // parses offset time then adjusts to requested zone\n-        assertEquals(expected.withZone(zone), f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n         // parses offset time returning offset zone (ignores zone)\n         assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n     }\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n         \n         LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n         \n         LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n         assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n-        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n         assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n     }\n \n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n-        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n-        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n         assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n         \n         LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n-        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n-        assertEquals(expected, f.withZone(paris).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(expected, f.withZone(PARIS).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n     }\n \n     public void test_localParseWrongOffsetAndZone() {\n             .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n         DateTimeFormatter f = bld.toFormatter();\n         \n-        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n         LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n         // parses offset time then adjusts to parsed zone\n         assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n         // parses offset time then adjusts to requested zone\n-        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n         // parses offset time returning offset zone (ignores zone)\n         assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void test_printParseShortName() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName();\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 GMT\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 BST\", f.print(dt2));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 GMT\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseShortNameWithLookup() {\n+        Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>();\n+        lookup.put(\"GMT\", LONDON);\n+        lookup.put(\"BST\", LONDON);\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName(lookup);\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 GMT\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 BST\", f.print(dt2));\n+        \n+        assertEquals(dt1, f.parseDateTime(\"2011-01-04 12:30 GMT\"));\n+        assertEquals(dt2, f.parseDateTime(\"2011-07-04 12:30 BST\"));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 EST\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_printParseLongName() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneName();\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 Greenwich Mean Time\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 British Summer Time\", f.print(dt2));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 GMT\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseLongNameWithLookup() {\n+        Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>();\n+        lookup.put(\"Greenwich Mean Time\", LONDON);\n+        lookup.put(\"British Summer Time\", LONDON);\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneName(lookup);\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 Greenwich Mean Time\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 British Summer Time\", f.print(dt2));\n+        \n+        assertEquals(dt1, f.parseDateTime(\"2011-01-04 12:30 Greenwich Mean Time\"));\n+        assertEquals(dt2, f.parseDateTime(\"2011-07-04 12:30 British Summer Time\"));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 EST\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n }", "timestamp": 1312028982, "metainfo": ""}