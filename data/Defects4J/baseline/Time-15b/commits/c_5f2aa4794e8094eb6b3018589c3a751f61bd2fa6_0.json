{"sha": "5f2aa4794e8094eb6b3018589c3a751f61bd2fa6", "log": "Create BasePeriod   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n      * will be returned. Otherwise, the chronology is returned.\n      * \n      * @param chrono  the chronology to use, null means ISO in the default zone\n-     * @return the chronology, or ISOChronology if null\n+     * @return the chronology, never null\n      */\n     public static final Chronology getChronology(Chronology chrono) {\n         if (chrono == null) {\n      * Gets the zone handling null.\n      * <p>\n      * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n-     * will be returned. Otherwise, the chronology is returned.\n+     * will be returned. Otherwise, the zone specified is returned.\n      * \n      * @param zone  the time zone to use, null means the default zone\n-     * @return the time zone, or default if null\n+     * @return the time zone, never null\n      */\n     public static final DateTimeZone getZone(DateTimeZone zone) {\n         if (zone == null) {\n             return DateTimeZone.getDefault();\n         }\n         return zone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the period type handling null.\n+     * <p>\n+     * If the zone is <code>null</code>, {@link PeriodType#getAllType()}\n+     * will be returned. Otherwise, the type specified is returned.\n+     * \n+     * @param type  the time zone to use, null means the All type\n+     * @return the type to use, never null\n+     */\n+    public static final PeriodType getPeriodType(PeriodType type) {\n+        if (type == null) {\n+            return PeriodType.getAllType();\n+        }\n+        return type;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n \n import java.io.Serializable;\n \n-import org.joda.time.base.*;\n+import org.joda.time.base.BasePeriod;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * Standard mutable time period implementation.\n  * @see Period\n  */\n public class MutablePeriod\n-        extends AbstractPeriod\n+        extends BasePeriod\n         implements ReadWritablePeriod, Cloneable, Serializable {\n \n     /** Serialization version */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a period type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n-     * \n-     * @param type  the type to check, may be null\n-     * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the period type is not precise\n-     */\n-    protected PeriodType checkPeriodType(PeriodType type) {\n-        if (type == null) {\n-            return PeriodType.getAllType();\n-        }\n-        return type;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Sets all the fields in one go from another ReadablePeriod.\n      * \n      * @param period  the period to set, null means zero length period\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public void setPeriod(ReadablePeriod period) {\n-        super.setPeriod(period);\n+        if (period == null) {\n+            setPeriod(0L);\n+        } else {\n+            setPeriod(\n+                period.getYears(), period.getMonths(),\n+                period.getWeeks(), period.getDays(),\n+                period.getHours(), period.getMinutes(),\n+                period.getSeconds(), period.getMillis());\n+        }\n     }\n \n     /**\n      * @param interval  the interval to set, null means zero length\n      */\n     public void setPeriod(ReadableInterval interval) {\n-        super.setPeriod(interval);\n+        if (interval == null) {\n+            setPeriod(0L);\n+        } else {\n+            setPeriod(interval.getStartMillis(), interval.getEndMillis());\n+        }\n     }\n \n     /**\n      * @param duration  the duration to set, null means zero length\n      */\n     public void setPeriod(ReadableDuration duration) {\n-        super.setPeriod(duration);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setPeriod(durationMillis);\n     }\n \n     /**\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void add(ReadablePeriod period) {\n-        super.add(period);\n+        if (period != null) {\n+            setPeriod(\n+                FieldUtils.safeAdd(getYears(), period.getYears()),\n+                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n+                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n+                FieldUtils.safeAdd(getDays(), period.getDays()),\n+                FieldUtils.safeAdd(getHours(), period.getHours()),\n+                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n+                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n+                FieldUtils.safeAdd(getMillis(), period.getMillis())\n+            );\n+        }\n     }\n \n     /**\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void add(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis) {\n-        super.add(years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Adds an interval to this one by converting it to a period using the same\n-     * period type and then adding each field in turn.\n+                       int hours, int minutes, int seconds, int millis) {\n+        setPeriod(\n+            FieldUtils.safeAdd(getYears(), years),\n+            FieldUtils.safeAdd(getMonths(), months),\n+            FieldUtils.safeAdd(getWeeks(), weeks),\n+            FieldUtils.safeAdd(getDays(), days),\n+            FieldUtils.safeAdd(getHours(), hours),\n+            FieldUtils.safeAdd(getMinutes(), minutes),\n+            FieldUtils.safeAdd(getSeconds(), seconds),\n+            FieldUtils.safeAdd(getMillis(), millis)\n+        );\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n      * \n      * @param interval  the interval to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void add(ReadableInterval interval) {\n-        super.add(interval);\n+        if (interval != null) {\n+            add(interval.toPeriod(getPeriodType()));\n+        }\n     }\n \n     /**\n      * Adds a duration to this one by dividing the duration into\n-     * fields and then adding each field in turn.\n-     * <p>\n-     * When dividing the duration, only precise fields in the period type will be used.\n-     * For large durations, all the remaining duration will be added to the largest\n-     * available precise field.\n+     * fields and calling {@link #add(ReadablePeriod)}.\n      * \n      * @param duration  the duration to add, null means add nothing\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void add(ReadableDuration duration) {\n-        super.add(duration);\n-    }\n-\n-    /**\n-     * Adds a duration to this one by dividing the duration into\n-     * fields and then adding each field in turn.\n-     * <p>\n-     * When dividing the duration, only precise fields in the period type will be used.\n-     * For large durations, all the remaining duration will be added to the largest\n-     * available precise field.\n-     * \n-     * @param duration  the duration to add\n+        if (duration != null) {\n+            add(new Period(duration.getMillis(), getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration, in milliseconds\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void add(long duration) {\n-        super.add(duration);\n+        add(new Period(duration, getPeriodType()));\n     }\n \n     /**\n      * @throws IllegalStateException if this period is imprecise\n      */\n     public void normalize() {\n-        super.normalize();\n+        setPeriod(toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addYears(int years) {\n-        super.addYears(years);\n+        if (years != 0) {\n+            setYears(FieldUtils.safeAdd(getYears(), years));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addMonths(int months) {\n-        super.addMonths(months);\n+        if (months != 0) {\n+            setMonths(FieldUtils.safeAdd(getMonths(), months));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addWeeks(int weeks) {\n-        super.addWeeks(weeks);\n+        if (weeks != 0) {\n+            setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addDays(int days) {\n-        super.addDays(days);\n+        if (days != 0) {\n+            setDays(FieldUtils.safeAdd(getDays(), days));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addHours(int hours) {\n-        super.addHours(hours);\n+        if (hours != 0) {\n+            setHours(FieldUtils.safeAdd(getHours(), hours));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addMinutes(int minutes) {\n-        super.addMinutes(minutes);\n+        if (minutes != 0) {\n+            setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addSeconds(int seconds) {\n-        super.addSeconds(seconds);\n+        if (seconds != 0) {\n+            setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the addition exceeds the capacity of the period\n      */\n     public void addMillis(int millis) {\n-        super.addMillis(millis);\n+        if (millis != 0) {\n+            setMillis(FieldUtils.safeAdd(getMillis(), millis));\n+        }\n     }\n \n     // Misc\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n \n import java.io.Serializable;\n \n-import org.joda.time.base.*;\n+import org.joda.time.base.BasePeriod;\n \n /**\n  * An immutable time period specifying a set of duration field values.\n  * @since 1.0\n  * @see MutablePeriod\n  */\n-public class Period\n-        extends AbstractPeriod\n+public final class Period\n+        extends BasePeriod\n         implements ReadablePeriod, Serializable {\n \n     /** Serialization version */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Validates a period type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n+     * Get this period as an immutable <code>Period</code> object\n+     * by returning <code>this</code>.\n      * \n-     * @param type  the type to check, may be null\n-     * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the period type is not precise\n-     */\n-    protected final PeriodType checkPeriodType(PeriodType type) {\n-        if (type == null) {\n-            return PeriodType.getAllType();\n-        }\n-        return type;\n+     * @return <code>this</code>\n+     */\n+    public Period toPeriod() {\n+        return this;\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the new period instance\n      * @throws IllegalArgumentException if the new period won't accept all of the current fields\n      */\n-    public final Period withPeriodType(PeriodType type) {\n+    public Period withPeriodType(PeriodType type) {\n         if (type == null) {\n             type = PeriodType.getAllType();\n         }\n      * @return the new period instance\n      * @throws IllegalStateException if this period is imprecise\n      */\n-    public final Period withPeriodTypeRetainDuration(PeriodType type) {\n+    public Period withPeriodTypeRetainDuration(PeriodType type) {\n         if (type == null) {\n             type = PeriodType.getAllType();\n         }\n      * @return the new period instance\n      * @throws IllegalStateException if this period is imprecise\n      */\n-    public final Period withFieldsNormalized() {\n+    public Period withFieldsNormalized() {\n         return new Period(toDurationMillis(), getPeriodType());\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setPeriod(ReadablePeriod period) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setPeriod(int years, int months, int weeks, int days,\n-                                       int hours, int minutes, int seconds, int millis) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setPeriod(long startInstant, long endInstant) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setPeriod(long duration) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setYears(int years) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMonths(int months) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setWeeks(int weeks) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setDays(int days) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setHours(int hours) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMinutes(int minutes) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setSeconds(int seconds) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setMillis(int millis) {\n-    }\n-\n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPeriod.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.Duration;\n-import org.joda.time.DurationField;\n import org.joda.time.Instant;\n import org.joda.time.MutablePeriod;\n import org.joda.time.Period;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableInstant;\n-import org.joda.time.ReadWritablePeriod;\n-import org.joda.time.ReadableDuration;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.ReadableInterval;\n import org.joda.time.ReadablePeriod;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.PeriodConverter;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISOPeriodFormat;\n \n /**\n- * AbstractDuration provides the common behaviour for duration classes.\n+ * AbstractPeriod provides the common behaviour for period classes.\n  * <p>\n  * This class should generally not be used directly by API users. The \n- * {@link ReadableDuration} interface should be used when different \n- * kinds of durations are to be referenced.\n+ * {@link ReadablePeriod} interface should be used when different \n+ * kinds of periods are to be referenced.\n  * <p>\n- * AbstractDuration subclasses may be mutable and not thread-safe.\n+ * AbstractPeriod subclasses may be mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n public abstract class AbstractPeriod\n         implements ReadablePeriod, Serializable {\n \n-    /** Serialization version */\n-    private static final long serialVersionUID = -2110953284060001145L;\n-    /** Millis cache is currently unknown */\n-    private static final int STATE_UNKNOWN = 0;\n-    /** Millis cache is not calculable */\n-    private static final int STATE_NOT_CALCULABLE = 1;\n-    /** Millis cache has been calculated and is valid */\n-    private static final int STATE_CALCULATED = 2;\n-\n-    /** The period type that allocates the duration to fields */\n-    private final PeriodType iType;\n-    /** The object state */\n-    private transient int iState;\n-    /** The duration, if known */\n-    private transient long iDuration;\n-    /** Value for years */\n-    private int iYears;\n-    /** Value for months */\n-    private int iMonths;\n-    /** Value for weeks */\n-    private int iWeeks;\n-    /** Value for days */\n-    private int iDays;\n-    /** Value for hours */\n-    private int iHours;\n-    /** Value for minutes */\n-    private int iMinutes;\n-    /** Value for seconds */\n-    private int iSeconds;\n-    /** Value for millis */\n-    private int iMillis;\n-\n-    /**\n-     * Creates a period from the given millisecond duration.\n-     * <p>\n-     * The millisecond duration will be split to fields using a UTC version of\n-     * the period type.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if period type is invalid\n-     */\n-    protected AbstractPeriod(long duration, PeriodType type) {\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPeriod() {\n         super();\n-        type = checkPeriodType(type);\n-        iType = type;\n-        // Only call a private method\n-        setPeriod(type, duration);\n-    }\n-\n-    /**\n-     * Creates a period from a set of field values.\n-     *\n-     * @param years  amount of years in this period, which must be zero if unsupported\n-     * @param months  amount of months in this period, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n-     * @param days  amount of days in this period, which must be zero if unsupported\n-     * @param hours  amount of hours in this period, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n-     * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if period type is invalid\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    protected AbstractPeriod(int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis,\n-                            PeriodType type) {\n-        super();\n-        type = checkPeriodType(type);\n-        iType = type;\n-        // Only call a private method\n-        setPeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Creates a period from the given interval endpoints.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if period type is invalid\n-     */\n-    protected AbstractPeriod(long startInstant, long endInstant, PeriodType type) {\n-        super();\n-        type = checkPeriodType(type);\n-        iType = type;\n-        // Only call a private method\n-        setPeriod(type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a period from the given interval endpoints.\n-     *\n-     * @param startInstant  interval start, null means now\n-     * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this period supports\n-     * @throws IllegalArgumentException if period type is invalid\n-     */\n-    protected AbstractPeriod(\n-            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n-        super();\n-        type = checkPeriodType(type);\n-        if (startInstant == null && endInstant == null) {\n-            iType = type;\n-        } else {\n-            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n-            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n-            iType = type;\n-            // Only call a private method\n-            setPeriod(type, start, end);\n-        }\n-    }\n-\n-    /**\n-     * Creates a new period based on another using the {@link ConverterManager}.\n-     *\n-     * @param period  the period to convert\n-     * @param type  which set of fields this period supports, null means use type from object\n-     * @throws IllegalArgumentException if period is invalid\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    protected AbstractPeriod(Object period, PeriodType type) {\n-        super();\n-        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n-        type = (type == null ? converter.getPeriodType(period, false) : type);\n-        type = checkPeriodType(type);\n-        iType = type;\n-        if (this instanceof ReadWritablePeriod) {\n-            converter.setInto((ReadWritablePeriod) this, period);\n-        } else {\n-            // Only call a private method\n-            setPeriod(type, new MutablePeriod(period, type));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Validates a period type, converting nulls to a default value and\n-     * checking the type is suitable for this instance.\n-     * \n-     * @param type  the type to check, may be null\n-     * @return the validated type to use, not null\n-     * @throws IllegalArgumentException if the period type is invalid\n-     */\n-    protected abstract PeriodType checkPeriodType(PeriodType type);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns the object which defines which fields this period supports.\n-     */\n-    public final PeriodType getPeriodType() {\n-        return iType;\n-    }\n-\n-    /**\n-     * Is this period a precise length of time, or descriptive.\n-     * <p>\n-     * A typical precise period could include millis, seconds, minutes or hours,\n-     * but days, weeks, months and years usually vary in length, resulting in\n-     * an imprecise period.\n-     * <p>\n-     * An imprecise period can be made precise by pairing it with a\n-     * date in a {@link ReadableInterval}.\n-     *\n-     * @return true if the period is precise\n-     */\n-    public final boolean isPrecise() {\n-        int state = iState;\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        return (state == STATE_CALCULATED);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    public final long addTo(long instant, int scalar) {\n+    public long addTo(long instant, int scalar) {\n         return addTo(instant, scalar, null);\n     }\n \n      * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    public final long addTo(long instant, int scalar, Chronology chrono) {\n+    public long addTo(long instant, int scalar, Chronology chrono) {\n         if (isPrecise()) {\n             return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n         }\n         \n-        PeriodType type = iType;\n+        PeriodType type = getPeriodType();\n         if (chrono != null) {\n             type = type.withChronology(chrono);\n         }\n         \n         long value; // used to lock fields against threading issues\n-        value = scaleValue(iYears, scalar);\n+        value = scaleValue(getYears(), scalar);\n         if (value != 0) {\n             instant = type.years().add(instant, value);\n         }\n-        value = scaleValue(iMonths, scalar);\n+        value = scaleValue(getMonths(), scalar);\n         if (value != 0) {\n             instant = type.months().add(instant, value);\n         }\n-        value = scaleValue(iWeeks, scalar);\n+        value = scaleValue(getWeeks(), scalar);\n         if (value != 0) {\n             instant = type.weeks().add(instant, value);\n         }\n-        value = scaleValue(iDays, scalar);\n+        value = scaleValue(getDays(), scalar);\n         if (value != 0) {\n             instant = type.days().add(instant, value);\n         }\n-        value = scaleValue(iHours, scalar);\n+        value = scaleValue(getHours(), scalar);\n         if (value != 0) {\n             instant = type.hours().add(instant, value);\n         }\n-        value = scaleValue(iMinutes, scalar);\n+        value = scaleValue(getMinutes(), scalar);\n         if (value != 0) {\n             instant = type.minutes().add(instant, value);\n         }\n-        value = scaleValue(iSeconds, scalar);\n+        value = scaleValue(getSeconds(), scalar);\n         if (value != 0) {\n             instant = type.seconds().add(instant, value);\n         }\n-        value = scaleValue(iMillis, scalar);\n+        value = scaleValue(getMillis(), scalar);\n         if (value != 0) {\n             instant = type.millis().add(instant, value);\n         }\n      * @return instant with the original value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    public final Instant addTo(ReadableInstant instant, int scalar) {\n+    public Instant addTo(ReadableInstant instant, int scalar) {\n         long instantMillis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant, null);\n         return new Instant(addTo(instantMillis, scalar, chrono));\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    public final void addInto(ReadWritableInstant instant, int scalar) {\n+    public void addInto(ReadWritableInstant instant, int scalar) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the years field part of the period.\n+     * Get this period as an immutable <code>Period</code> object.\n      * \n-     * @return the number of years in the period, zero if unsupported\n-     */\n-    public final int getYears() {\n-        return iYears;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the months field part of the period.\n-     * \n-     * @return the number of months in the period, zero if unsupported\n-     */\n-    public final int getMonths() {\n-        return iMonths;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the weeks field part of the period.\n-     * \n-     * @return the number of weeks in the period, zero if unsupported\n-     */\n-    public final int getWeeks() {\n-        return iWeeks;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the days field part of the period.\n-     * \n-     * @return the number of days in the period, zero if unsupported\n-     */\n-    public final int getDays() {\n-        return iDays;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the hours field part of the period.\n-     * \n-     * @return the number of hours in the period, zero if unsupported\n-     */\n-    public final int getHours() {\n-        return iHours;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the minutes field part of the period.\n-     * \n-     * @return the number of minutes in the period, zero if unsupported\n-     */\n-    public final int getMinutes() {\n-        return iMinutes;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the seconds field part of the period.\n-     * \n-     * @return the number of seconds in the period, zero if unsupported\n-     */\n-    public final int getSeconds() {\n-        return iSeconds;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the millis field part of the period.\n-     * \n-     * @return the number of millis in the period, zero if unsupported\n-     */\n-    public final int getMillis() {\n-        return iMillis;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Get this period as an immutable <code>Period</code> object.\n-     * <p>\n-     * This will either typecast this instance, or create a new <code>Period</code>.\n-     * \n-     * @return a Duration using the same field set and values\n-     */\n-    public final Period toPeriod() {\n-        if (this instanceof Period) {\n-            return (Period) this;\n-        }\n+     * @return a Period using the same field set and values\n+     */\n+    public Period toPeriod() {\n         return new Period(this);\n     }\n \n      * \n      * @return a MutablePeriod using the same field set and values\n      */\n-    public final MutablePeriod toMutablePeriod() {\n+    public MutablePeriod toMutablePeriod() {\n         return new MutablePeriod(this);\n     }\n \n      * @throws IllegalStateException if the period is imprecise\n      * @throws ArithmeticException if the millis exceeds the capacity of the duration\n      */\n-    public final long toDurationMillis() {\n-        int state = iState;\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        if (state != STATE_CALCULATED) {\n-            throw new IllegalStateException(\"Duration is imprecise\");\n-        }\n-        return iDuration;\n-    }\n-\n-    /**\n-     * Gets the total millisecond duration of this period,\n-     * failing if the period is imprecise.\n-     *\n-     * @return the total length of the period in milliseconds.\n-     * @throws IllegalStateException if the period is imprecise\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n-     */\n-    public final Duration toDuration() {\n+    public Duration toDuration() {\n         return new Duration(toDurationMillis());\n     }\n \n      * @return true if all the field values are equal, false if\n      *  not or the period is null or of an incorrect type\n      */\n-    public final boolean equals(Object readablePeriod) {\n+    public boolean equals(Object readablePeriod) {\n         if (this == readablePeriod) {\n             return true;\n         }\n      *\n      * @return a hash code\n      */\n-    public final int hashCode() {\n+    public int hashCode() {\n         int hash = getPeriodType().hashCode();\n         hash = 53 * hash + getYears();\n         hash = 53 * hash + getMonths();\n         return ISOPeriodFormat.getInstance().standard().print(this);\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkArgument(DurationField field) {\n-        if (!field.isSupported()) {\n-            throw new IllegalArgumentException\n-                (\"Time period does not support field '\" + field.getName() + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkSupport(DurationField field) {\n-        if (!field.isSupported()) {\n-            throw new UnsupportedOperationException\n-                (\"Time period does not support field '\" + field.getName() + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from another ReadablePeriod.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param period  the period to set, null means zero length period\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    protected void setPeriod(ReadablePeriod period) {\n-        if (period == null) {\n-            setPeriod(iType, 0L);\n-        } else {\n-            setPeriod(iType, period);\n-        }\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setPeriod(PeriodType type, ReadablePeriod period) {\n-        setPeriod(type,\n-            period.getYears(), period.getMonths(),\n-            period.getWeeks(), period.getDays(),\n-            period.getHours(), period.getMinutes(),\n-            period.getSeconds(), period.getMillis());\n-    }\n-\n-    /**\n-     * Sets all the fields in one go.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param years  amount of years in this period, which must be zero if unsupported\n-     * @param months  amount of months in this period, which must be zero if unsupported\n-     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n-     * @param days  amount of days in this period, which must be zero if unsupported\n-     * @param hours  amount of hours in this period, which must be zero if unsupported\n-     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n-     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n-     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n-     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n-     */\n-    protected void setPeriod(int years, int months, int weeks, int days,\n-                               int hours, int minutes, int seconds, int millis) {\n-        setPeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setPeriod(PeriodType type,\n-                             int years, int months, int weeks, int days,\n-                             int hours, int minutes, int seconds, int millis) {\n-        if (years != 0) {\n-            checkArgument(type.years());\n-        }\n-        if (months != 0) {\n-            checkArgument(type.months());\n-        }\n-        if (weeks != 0) {\n-            checkArgument(type.weeks());\n-        }\n-        if (days != 0) {\n-            checkArgument(type.days());\n-        }\n-        if (hours != 0) {\n-            checkArgument(type.hours());\n-        }\n-        if (minutes != 0) {\n-            checkArgument(type.minutes());\n-        }\n-        if (seconds != 0) {\n-            checkArgument(type.seconds());\n-        }\n-        if (millis != 0) {\n-            checkArgument(type.millis());\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond interval.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     */\n-    protected void setPeriod(long startInstant, long endInstant) {\n-        setPeriod(iType, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     */\n-    private void setPeriod(PeriodType type, long startInstant, long endInstant) {\n-        long baseTotalMillis = (endInstant - startInstant);\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        field = type.years();\n-        if (field.isSupported()) {\n-            years = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported()) {\n-            months = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported()) {\n-            weeks = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported()) {\n-            days = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported()) {\n-            hours = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported()) {\n-            minutes = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported()) {\n-            seconds = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported()) {\n-            millis = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond duration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param duration  the duration, in milliseconds\n-     * @throws ArithmeticException if the set exceeds the capacity of the period\n-     */\n-    protected void setPeriod(long duration) {\n-        setPeriod(iType, duration);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    private void setPeriod(PeriodType type, long duration) {\n-        if (duration == 0) {\n-            iDuration = duration;\n-            iYears = 0;\n-            iMonths = 0;\n-            iWeeks = 0;\n-            iDays = 0;\n-            iHours = 0;\n-            iMinutes = 0;\n-            iSeconds = 0;\n-            iMillis = 0;\n-            iState = STATE_CALCULATED;\n-            return;\n-        }\n-        \n-        long startInstant = 0;\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        \n-        field = type.years();\n-        if (field.isSupported() && field.isPrecise()) {\n-            years = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported() && field.isPrecise()) {\n-            months = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported() && field.isPrecise()) {\n-            weeks = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported() && field.isPrecise()) {\n-            days = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported() && field.isPrecise()) {\n-            hours = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported() && field.isPrecise()) {\n-            minutes = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported() && field.isPrecise()) {\n-            seconds = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported() && field.isPrecise()) {\n-            millis = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from an interval dividing the\n-     * fields using the period type.\n-     * \n-     * @param interval  the interval to set, null means zero length\n-     */\n-    protected void setPeriod(ReadableInterval interval) {\n-        if (interval != null) {\n-            setPeriod(interval.getStartMillis(), interval.getEndMillis());\n-        } else {\n-            setPeriod(0L);\n-        }\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a duration dividing the\n-     * fields using the period type.\n-     * \n-     * @param duration  the duration to set, null means zero length\n-     */\n-    protected void setPeriod(ReadableDuration duration) {\n-        if (duration != null) {\n-            setPeriod(duration.getMillis());\n-        } else {\n-            setPeriod(0L);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this period is precise.\n-     *\n-     * @return new state\n-     * @throws ArithmeticException if the millis exceeds the capacity of the period\n-     */\n-    private int updateTotalMillis() {\n-        final PeriodType type = iType;\n-\n-        boolean isPrecise = true;\n-        long totalMillis = 0;\n-\n-        DurationField field;\n-        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n-        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n-        if (years != 0) {\n-            field = type.years();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n-            }\n-        }\n-        if (months != 0) {\n-            field = type.months();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n-            }\n-        }\n-        if (weeks != 0) {\n-            field = type.weeks();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n-            }\n-        }\n-        if (days != 0) {\n-            field = type.days();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n-            }\n-        }\n-        if (hours != 0) {\n-            field = type.hours();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n-            }\n-        }\n-        if (minutes != 0) {\n-            field = type.minutes();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n-            }\n-        }\n-        if (seconds != 0) {\n-            field = type.seconds();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n-            }\n-        }\n-        if (millis != 0) {\n-            field = type.millis();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n-            }\n-        }\n-        \n-        iDuration = totalMillis;\n-        if (isPrecise) {\n-            return iState = STATE_CALCULATED;\n-        } else {\n-            return iState = STATE_NOT_CALCULABLE;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds a period to this one by adding each field in turn.\n-     * \n-     * @param period  the period to add, null means add nothing\n-     * @throws IllegalArgumentException if the period being added contains a field\n-     * not supported by this period\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void add(ReadablePeriod period) {\n-        if (period != null) {\n-            setPeriod(\n-                FieldUtils.safeAdd(getYears(), period.getYears()),\n-                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n-                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n-                FieldUtils.safeAdd(getDays(), period.getDays()),\n-                FieldUtils.safeAdd(getHours(), period.getHours()),\n-                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n-                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n-                FieldUtils.safeAdd(getMillis(), period.getMillis())\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Adds to each field of this period.\n-     * \n-     * @param years  amount of years to add to this period, which must be zero if unsupported\n-     * @param months  amount of months to add to this period, which must be zero if unsupported\n-     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n-     * @param days  amount of days to add to this period, which must be zero if unsupported\n-     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n-     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n-     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n-     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n-     * @throws IllegalArgumentException if the period being added contains a field\n-     * not supported by this period\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void add(int years, int months, int weeks, int days,\n-                       int hours, int minutes, int seconds, int millis) {\n-        setPeriod(\n-            FieldUtils.safeAdd(getYears(), years),\n-            FieldUtils.safeAdd(getMonths(), months),\n-            FieldUtils.safeAdd(getWeeks(), weeks),\n-            FieldUtils.safeAdd(getDays(), days),\n-            FieldUtils.safeAdd(getHours(), hours),\n-            FieldUtils.safeAdd(getMinutes(), minutes),\n-            FieldUtils.safeAdd(getSeconds(), seconds),\n-            FieldUtils.safeAdd(getMillis(), millis)\n-        );\n-    }\n-\n-    /**\n-     * Adds an interval to this one by dividing the interval into\n-     * fields and calling {@link #add(ReadablePeriod)}.\n-     * \n-     * @param interval  the interval to add, null means add nothing\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void add(ReadableInterval interval) {\n-        if (interval != null) {\n-            add(interval.toPeriod(getPeriodType()));\n-        }\n-    }\n-\n-    /**\n-     * Adds a duration to this one by dividing the duration into\n-     * fields and calling {@link #add(ReadablePeriod)}.\n-     * \n-     * @param duration  the duration to add, null means add nothing\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void add(ReadableDuration duration) {\n-        if (duration != null) {\n-            add(new Period(duration.getMillis(), getPeriodType()));\n-        }\n-    }\n-\n-    /**\n-     * Adds a millisecond duration to this one by dividing the duration into\n-     * fields and calling {@link #add(ReadablePeriod)}.\n-     * \n-     * @param duration  the duration, in milliseconds\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void add(long duration) {\n-        add(new Period(duration, getPeriodType()));\n-    }\n-\n-    /**\n-     * Normalizes all the field values in this period.\n-     * <p>\n-     * This method converts to a milliecond duration and back again.\n-     *\n-     * @throws IllegalStateException if this period is imprecise\n-     */\n-    protected void normalize() {\n-        setPeriod(toDurationMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of years of the period.\n-     * \n-     * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported.\n-     */\n-    protected void setYears(int years) {\n-        if (years != iYears) {\n-            if (years != 0) {\n-                checkSupport(iType.years());\n-            }\n-            iYears = years;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified years to the number of years in the period.\n-     * \n-     * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addYears(int years) {\n-        if (years != 0) {\n-            setYears(FieldUtils.safeAdd(getYears(), years));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of months of the period.\n-     * \n-     * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMonths(int months) {\n-        if (months != iMonths) {\n-            if (months != 0) {\n-                checkSupport(iType.months());\n-            }\n-            iMonths = months;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified months to the number of months in the period.\n-     * \n-     * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addMonths(int months) {\n-        if (months != 0) {\n-            setMonths(FieldUtils.safeAdd(getMonths(), months));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of weeks of the period.\n-     * \n-     * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setWeeks(int weeks) {\n-        if (weeks != iWeeks) {\n-            if (weeks != 0) {\n-                checkSupport(iType.weeks());\n-            }\n-            iWeeks = weeks;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified weeks to the number of weeks in the period.\n-     * \n-     * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addWeeks(int weeks) {\n-        if (weeks != 0) {\n-            setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of days of the period.\n-     * \n-     * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setDays(int days) {\n-        if (days != iDays) {\n-            if (days != 0) {\n-                checkSupport(iType.days());\n-            }\n-            iDays = days;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified days to the number of days in the period.\n-     * \n-     * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addDays(int days) {\n-        if (days != 0) {\n-            setDays(FieldUtils.safeAdd(getDays(), days));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of hours of the period.\n-     * \n-     * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setHours(int hours) {\n-        if (hours != iHours) {\n-            if (hours != 0) {\n-                checkSupport(iType.hours());\n-            }\n-            iHours = hours;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified hours to the number of hours in the period.\n-     * \n-     * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addHours(int hours) {\n-        if (hours != 0) {\n-            setHours(FieldUtils.safeAdd(getHours(), hours));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of minutes of the period.\n-     * \n-     * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMinutes(int minutes) {\n-        if (minutes != iMinutes) {\n-            if (minutes != 0) {\n-                checkSupport(iType.minutes());\n-            }\n-            iMinutes = minutes;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified minutes to the number of minutes in the period.\n-     * \n-     * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addMinutes(int minutes) {\n-        if (minutes != 0) {\n-            setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of seconds of the period.\n-     * \n-     * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setSeconds(int seconds) {\n-        if (seconds != iSeconds) {\n-            if (seconds != 0) {\n-                checkSupport(iType.seconds());\n-            }\n-            iSeconds = seconds;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified seconds to the number of seconds in the period.\n-     * \n-     * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addSeconds(int seconds) {\n-        if (seconds != 0) {\n-            setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of millis of the period.\n-     * \n-     * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMillis(int millis) {\n-        if (millis != iMillis) {\n-            if (millis != 0) {\n-                checkSupport(iType.millis());\n-            }\n-            iMillis = millis;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Adds the specified millis to the number of millis in the period.\n-     * \n-     * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    protected void addMillis(int millis) {\n-        if (millis != 0) {\n-            setMillis(FieldUtils.safeAdd(getMillis(), millis));\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PeriodConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BasePeriod is an abstract implementation of ReadablePeriod that stores\n+ * data in a <code>int</code> and <code>PeriodType</code> fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadablePeriod} interface should be used when different \n+ * kinds of period objects are to be referenced.\n+ * <p>\n+ * BasePeriod subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BasePeriod\n+        extends AbstractPeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+\n+    /** Millis cache is currently unknown */\n+    private static final int STATE_UNKNOWN = 0;\n+    /** Millis cache is not calculable */\n+    private static final int STATE_NOT_CALCULABLE = 1;\n+    /** Millis cache has been calculated and is valid */\n+    private static final int STATE_CALCULATED = 2;\n+\n+    /** The period type that allocates the duration to fields */\n+    private final PeriodType iType;\n+    /** The object state */\n+    private transient int iState;\n+    /** The duration, if known */\n+    private transient long iDuration;\n+    /** Value for years */\n+    private int iYears;\n+    /** Value for months */\n+    private int iMonths;\n+    /** Value for weeks */\n+    private int iWeeks;\n+    /** Value for days */\n+    private int iDays;\n+    /** Value for hours */\n+    private int iHours;\n+    /** Value for minutes */\n+    private int iMinutes;\n+    /** Value for seconds */\n+    private int iSeconds;\n+    /** Value for millis */\n+    private int iMillis;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the period type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(long duration, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, duration);\n+    }\n+\n+    /**\n+     * Creates a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected BasePeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(long startInstant, long endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n+            // Only call a private method\n+            setPeriod(type, start, end);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new period based on another using the {@link ConverterManager}.\n+     *\n+     * @param period  the period to convert\n+     * @param type  which set of fields this period supports, null means use type from object\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected BasePeriod(Object period, PeriodType type) {\n+        super();\n+        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n+        type = (type == null ? converter.getPeriodType(period, false) : type);\n+        type = checkPeriodType(type);\n+        iType = type;\n+        if (this instanceof ReadWritablePeriod) {\n+            converter.setInto((ReadWritablePeriod) this, period);\n+        } else {\n+            // Only call a private method\n+            setPeriod(type, new MutablePeriod(period, type));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is invalid\n+     */\n+    protected PeriodType checkPeriodType(PeriodType type) {\n+        return DateTimeUtils.getPeriodType(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the object which defines which fields this period supports.\n+     */\n+    public PeriodType getPeriodType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A typical precise period could include millis, seconds, minutes or hours,\n+     * but days, weeks, months and years usually vary in length, resulting in\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the period is precise\n+     */\n+    public boolean isPrecise() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        return (state == STATE_CALCULATED);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public long toDurationMillis() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != STATE_CALCULATED) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iDuration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkSupport(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type, ReadablePeriod period) {\n+        setPeriod(type,\n+            period.getYears(), period.getMonths(),\n+            period.getWeeks(), period.getDays(),\n+            period.getHours(), period.getMinutes(),\n+            period.getSeconds(), period.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(int years, int months, int weeks, int days,\n+                               int hours, int minutes, int seconds, int millis) {\n+        setPeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type,\n+                             int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+        if (years != 0) {\n+            checkArgument(type.years());\n+        }\n+        if (months != 0) {\n+            checkArgument(type.months());\n+        }\n+        if (weeks != 0) {\n+            checkArgument(type.weeks());\n+        }\n+        if (days != 0) {\n+            checkArgument(type.days());\n+        }\n+        if (hours != 0) {\n+            checkArgument(type.hours());\n+        }\n+        if (minutes != 0) {\n+            checkArgument(type.minutes());\n+        }\n+        if (seconds != 0) {\n+            checkArgument(type.seconds());\n+        }\n+        if (millis != 0) {\n+            checkArgument(type.millis());\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    protected void setPeriod(long startInstant, long endInstant) {\n+        setPeriod(iType, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long startInstant, long endInstant) {\n+        long baseTotalMillis = (endInstant - startInstant);\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        field = type.years();\n+        if (field.isSupported()) {\n+            years = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported()) {\n+            months = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported()) {\n+            weeks = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported()) {\n+            days = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported()) {\n+            hours = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported()) {\n+            minutes = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported()) {\n+            seconds = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported()) {\n+            millis = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    protected void setPeriod(long duration) {\n+        setPeriod(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long duration) {\n+        if (duration == 0) {\n+            iDuration = duration;\n+            iYears = 0;\n+            iMonths = 0;\n+            iWeeks = 0;\n+            iDays = 0;\n+            iHours = 0;\n+            iMinutes = 0;\n+            iSeconds = 0;\n+            iMillis = 0;\n+            iState = STATE_CALCULATED;\n+            return;\n+        }\n+        \n+        long startInstant = 0;\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        \n+        field = type.years();\n+        if (field.isSupported() && field.isPrecise()) {\n+            years = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported() && field.isPrecise()) {\n+            months = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported() && field.isPrecise()) {\n+            weeks = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported() && field.isPrecise()) {\n+            days = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported() && field.isPrecise()) {\n+            hours = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported() && field.isPrecise()) {\n+            minutes = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported() && field.isPrecise()) {\n+            seconds = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported() && field.isPrecise()) {\n+            millis = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this period is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the period\n+     */\n+    private int updateTotalMillis() {\n+        PeriodType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n+        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n+        if (years != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            }\n+        }\n+        if (months != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            }\n+        }\n+        if (weeks != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n+            }\n+        }\n+        if (days != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n+            }\n+        }\n+        if (hours != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n+            }\n+        }\n+        if (minutes != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n+            }\n+        }\n+        if (seconds != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n+            }\n+        }\n+        if (millis != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n+            }\n+        }\n+        \n+        iDuration = totalMillis;\n+        if (isPrecise) {\n+            return iState = STATE_CALCULATED;\n+        } else {\n+            return iState = STATE_NOT_CALCULABLE;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setYears(int years) {\n+        if (years != iYears) {\n+            if (years != 0) {\n+                checkSupport(iType.years());\n+            }\n+            iYears = years;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMonths(int months) {\n+        if (months != iMonths) {\n+            if (months != 0) {\n+                checkSupport(iType.months());\n+            }\n+            iMonths = months;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setWeeks(int weeks) {\n+        if (weeks != iWeeks) {\n+            if (weeks != 0) {\n+                checkSupport(iType.weeks());\n+            }\n+            iWeeks = weeks;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setDays(int days) {\n+        if (days != iDays) {\n+            if (days != 0) {\n+                checkSupport(iType.days());\n+            }\n+            iDays = days;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setHours(int hours) {\n+        if (hours != iHours) {\n+            if (hours != 0) {\n+                checkSupport(iType.hours());\n+            }\n+            iHours = hours;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMinutes(int minutes) {\n+        if (minutes != iMinutes) {\n+            if (minutes != 0) {\n+                checkSupport(iType.minutes());\n+            }\n+            iMinutes = minutes;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setSeconds(int seconds) {\n+        if (seconds != iSeconds) {\n+            if (seconds != 0) {\n+                checkSupport(iType.seconds());\n+            }\n+            iSeconds = seconds;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMillis(int millis) {\n+        if (millis != iMillis) {\n+            if (millis != 0) {\n+                checkSupport(iType.millis());\n+            }\n+            iMillis = millis;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.base.AbstractPeriod;\n+import org.joda.time.base.BasePeriod;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n         assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n     }\n     \n-    class MockMutablePeriod extends AbstractPeriod {\n+    class MockMutablePeriod extends BasePeriod {\n         public MockMutablePeriod(long value) {\n             super(value, null);\n-        }\n-        protected PeriodType checkPeriodType(PeriodType type) {\n-            return PeriodType.getAllType();\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.base.AbstractPeriod;\n+import org.joda.time.base.BasePeriod;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n         assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n     }\n     \n-    class MockPeriod extends AbstractPeriod {\n+    class MockPeriod extends BasePeriod {\n         public MockPeriod(long value) {\n             super(value, null);\n-        }\n-        protected PeriodType checkPeriodType(PeriodType type) {\n-            return PeriodType.getAllType();\n         }\n     }\n \n         } catch (IllegalStateException ex) {}\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testImmutable() {\n-        MockChangeDuration test = new MockChangeDuration(111L);\n-        test.testSetPeriod_RP();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetPeriod_RD();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetPeriod_ints();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetPeriod_1();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetPeriod_2();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetYears();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetMonths();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetWeeks();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetDays();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetHours();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetMinutes();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetSeconds();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testSetMillis();\n-        assertEquals(111L, test.toDurationMillis());\n-        \n-        test = new MockChangeDuration(111L);\n-        test.testNormalize();\n-        assertEquals(111L, test.toDurationMillis());\n-    }\n-    \n-    static class MockChangeDuration extends Period {\n-        MockChangeDuration(long duration) {\n-            super(duration);\n-        }\n-        public void testSetPeriod_RP() {\n-            setPeriod((ReadablePeriod) null);\n-        }\n-        public void testSetPeriod_RD() {\n-            setPeriod((ReadableDuration) null);\n-        }\n-        public void testSetPeriod_ints() {\n-            setPeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        }\n-        public void testSetPeriod_1() {\n-            setPeriod(123L);\n-        }\n-        public void testSetPeriod_2() {\n-            setPeriod(123L, 321L);\n-        }\n-        public void testSetYears() {\n-            setYears(1);\n-        }\n-        public void testSetMonths() {\n-            setMonths(1);\n-        }\n-        public void testSetWeeks() {\n-            setWeeks(1);\n-        }\n-        public void testSetDays() {\n-            setDays(1);\n-        }\n-        public void testSetHours() {\n-            setHours(1);\n-        }\n-        public void testSetMinutes() {\n-            setMinutes(1);\n-        }\n-        public void testSetSeconds() {\n-            setSeconds(1);\n-        }\n-        public void testSetMillis() {\n-            setMillis(1);\n-        }\n-        public void testNormalize() {\n-            super.normalize();\n-        }\n-    }\n-\n }", "timestamp": 1093123779, "metainfo": ""}