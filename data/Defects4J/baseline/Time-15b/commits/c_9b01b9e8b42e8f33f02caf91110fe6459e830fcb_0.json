{"sha": "9b01b9e8b42e8f33f02caf91110fe6459e830fcb", "log": "Fix bug where some time zones (Australia) use same abbreviated zone name for summer and winter bug 1716305  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.text.DateFormatSymbols;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.Locale;\n import java.util.Set;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n     /**\n      * Processes all the rules and builds a DateTimeZone.\n      *\n-     * @param id time zone id to assign\n+     * @param id  time zone id to assign\n+     * @param outputID  true if the zone id should be output\n      */\n-    public DateTimeZone toDateTimeZone(String id) {\n+    public DateTimeZone toDateTimeZone(String id, boolean outputID) {\n         if (id == null) {\n             throw new IllegalArgumentException();\n         }\n                                   tr.getWallOffset(), tr.getStandardOffset());\n         }\n \n-        PrecalculatedZone zone = new PrecalculatedZone(id, transitions, tailZone);\n+        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n         if (zone.isCachable()) {\n             return CachedDateTimeZone.forZone(zone);\n         }\n      *\n      * @param out output stream to receive encoded DateTimeZone.\n      */\n-    public void writeTo(OutputStream out) throws IOException {\n+    public void writeTo(String zoneID, OutputStream out) throws IOException {\n         if (out instanceof DataOutput) {\n-            writeTo((DataOutput)out);\n+            writeTo(zoneID, (DataOutput)out);\n         } else {\n-            writeTo((DataOutput)new DataOutputStream(out));\n+            writeTo(zoneID, (DataOutput)new DataOutputStream(out));\n         }\n     }\n \n      *\n      * @param out output stream to receive encoded DateTimeZone.\n      */\n-    public void writeTo(DataOutput out) throws IOException {\n-        // The zone id is not written out, so the empty string is okay.\n-        DateTimeZone zone = toDateTimeZone(\"\");\n+    public void writeTo(String zoneID, DataOutput out) throws IOException {\n+        // pass false so zone id is not written out\n+        DateTimeZone zone = toDateTimeZone(zoneID, false);\n \n         if (zone instanceof FixedDateTimeZone) {\n             out.writeByte('F'); // 'F' for fixed\n                                Recurrence.readFrom(in), Recurrence.readFrom(in));\n         }\n \n-        private final int iStandardOffset;\n-        private final Recurrence iStartRecurrence;\n-        private final Recurrence iEndRecurrence;\n+        final int iStandardOffset;\n+        final Recurrence iStartRecurrence;\n+        final Recurrence iEndRecurrence;\n \n         DSTZone(String id, int standardOffset,\n                 Recurrence startRecurrence, Recurrence endRecurrence) {\n                 (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n         }\n \n+        /**\n+         * Factory to create instance from builder.\n+         * \n+         * @param id  the zone id\n+         * @param outputID  true if the zone id should be output\n+         * @param transitions  the list of Transition objects\n+         * @param tailZone  optional zone for getting info beyond precalculated tables\n+         */\n+        static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n+            int size = transitions.size();\n+            if (size == 0) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            long[] trans = new long[size];\n+            int[] wallOffsets = new int[size];\n+            int[] standardOffsets = new int[size];\n+            String[] nameKeys = new String[size];\n+\n+            Transition last = null;\n+            for (int i=0; i<size; i++) {\n+                Transition tr = (Transition)transitions.get(i);\n+\n+                if (!tr.isTransitionFrom(last)) {\n+                    throw new IllegalArgumentException(id);\n+                }\n+\n+                trans[i] = tr.getMillis();\n+                wallOffsets[i] = tr.getWallOffset();\n+                standardOffsets[i] = tr.getStandardOffset();\n+                nameKeys[i] = tr.getNameKey();\n+\n+                last = tr;\n+            }\n+\n+            // Some timezones (Australia) have the same name key for\n+            // summer and winter which messes everything up. Fix it here.\n+            String[] zoneNameData = new String[5];\n+            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n+            for (int j = 0; j < zoneStrings.length; j++) {\n+                String[] set = zoneStrings[j];\n+                if (set != null && set.length == 5 && id.equals(set[0])) {\n+                    zoneNameData = set;\n+                }\n+            }\n+            for (int i = 0; i < nameKeys.length - 1; i++) {\n+                String curNameKey = nameKeys[i];\n+                String nextNameKey = nameKeys[i + 1];\n+                long curOffset = wallOffsets[i];\n+                long nextOffset = wallOffsets[i + 1];\n+                long curStdOffset = standardOffsets[i];\n+                long nextStdOffset = standardOffsets[i + 1];\n+                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n+                if (curOffset != nextOffset &&\n+                        curStdOffset == nextStdOffset &&\n+                        curNameKey.equals(nextNameKey) &&\n+                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&\n+                        curNameKey.equals(zoneNameData[2]) &&\n+                        curNameKey.equals(zoneNameData[4])) {\n+                    \n+                    System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n+                    System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n+                    if (curOffset > nextOffset) {\n+                        nameKeys[i] = (curNameKey + \"-Summer\").intern();\n+                    } else if (curOffset < nextOffset) {\n+                        nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n+                        i++;\n+                    }\n+                }\n+            }\n+            if (tailZone != null) {\n+                if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n+                    System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n+                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n+                        Recurrence r = new Recurrence(\n+                            tailZone.iStartRecurrence.iOfYear,\n+                            tailZone.iStartRecurrence.iNameKey + \"-Summer\",\n+                            tailZone.iStartRecurrence.iSaveMillis);\n+                        tailZone = new DSTZone(\n+                            tailZone.getID(),\n+                            tailZone.iStandardOffset,\n+                            r, tailZone.iEndRecurrence);\n+                    } else {\n+                        Recurrence r = new Recurrence(\n+                            tailZone.iEndRecurrence.iOfYear,\n+                            tailZone.iEndRecurrence.iNameKey + \"-Summer\",\n+                            tailZone.iEndRecurrence.iSaveMillis);\n+                        tailZone = new DSTZone(\n+                            tailZone.getID(),\n+                            tailZone.iStandardOffset,\n+                            tailZone.iEndRecurrence, r);\n+                    }\n+                }\n+            }\n+            \n+            return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n+        }\n+\n         // All array fields have the same length.\n \n         private final long[] iTransitions;\n \n         private final DSTZone iTailZone;\n \n-        PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n+        /**\n+         * Constructor used ONLY for valid input, loaded via static methods.\n+         */\n+        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n                           int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n         {\n             super(id);\n             iWallOffsets = wallOffsets;\n             iStandardOffsets = standardOffsets;\n             iNameKeys = nameKeys;\n-            iTailZone = tailZone;\n-        }\n-\n-        /**\n-         * @param tailZone optional zone for getting info beyond precalculated\n-         * tables.\n-         */\n-        PrecalculatedZone(String id, ArrayList transitions, DSTZone tailZone) {\n-            super(id);\n-\n-            int size = transitions.size();\n-            if (size == 0) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            iTransitions = new long[size];\n-            iWallOffsets = new int[size];\n-            iStandardOffsets = new int[size];\n-            iNameKeys = new String[size];\n-\n-            Transition last = null;\n-            for (int i=0; i<size; i++) {\n-                Transition tr = (Transition)transitions.get(i);\n-\n-                if (!tr.isTransitionFrom(last)) {\n-                    throw new IllegalArgumentException(id);\n-                }\n-\n-                iTransitions[i] = tr.getMillis();\n-                iWallOffsets[i] = tr.getWallOffset();\n-                iStandardOffsets[i] = tr.getStandardOffset();\n-                iNameKeys[i] = tr.getNameKey();\n-\n-                last = tr;\n-            }\n-\n             iTailZone = tailZone;\n         }\n \n--- a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n                 String[] set = zoneStrings[i];\n                 if (set != null && set.length == 5 && id.equals(set[0])) {\n                     byNameKeyCache.put(set[2], new String[] {set[2], set[1]});\n-                    byNameKeyCache.put(set[4], new String[] {set[4], set[3]});\n+                    // need to handle case where summer and winter have the same\n+                    // abbreviation, such as EST in Australia [1716305]\n+                    // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\n+                    if (set[2].equals(set[4])) {\n+                        byNameKeyCache.put(set[4] + \"-Summer\", new String[] {set[4], set[3]});\n+                    } else {\n+                        byNameKeyCache.put(set[4], new String[] {set[4], set[3]});\n+                    }\n+                    break;\n                 }\n             }\n         }\n--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n             Zone zone = (Zone)iZones.get(i);\n             DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n             zone.addToBuilder(builder, iRuleSets);\n-            final DateTimeZone original = builder.toDateTimeZone(zone.iName);\n+            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n             DateTimeZone tz = original;\n             if (test(tz.getID(), tz)) {\n                 map.put(tz.getID(), tz);\n                         file.getParentFile().mkdirs();\n                     }\n                     OutputStream out = new FileOutputStream(file);\n-                    builder.writeTo(out);\n+                    builder.writeTo(zone.iName, out);\n                     out.close();\n \n                     // Test if it can be read back.\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n         assertEquals(1115313015000L, dt.getMillis());\n     }\n \n+    public void testPatchedNameKeysLondon() throws Exception {\n+        // the tz database does not have unique name keys [1716305]\n+        DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n+        \n+        DateTime now = new DateTime();\n+        String str1 = zone.getName(now.getMillis());\n+        String str2 = zone.getName(now.plusMonths(6).getMillis());\n+        assertEquals(false, str1.equals(str2));\n+    }\n+\n+    public void testPatchedNameKeysSydney() throws Exception {\n+        // the tz database does not have unique name keys [1716305]\n+        DateTimeZone zone = DateTimeZone.forID(\"Australia/Sydney\");\n+        \n+        DateTime now = new DateTime();\n+        String str1 = zone.getName(now.getMillis());\n+        String str2 = zone.getName(now.plusMonths(6).getMillis());\n+        assertEquals(false, str1.equals(str2));\n+    }\n+\n+    public void testPatchedNameKeysSydneyHistoric() throws Exception {\n+        // the tz database does not have unique name keys [1716305]\n+        DateTimeZone zone = DateTimeZone.forID(\"Australia/Sydney\");\n+        \n+        DateTime now = new DateTime(1996, 1, 1, 0, 0, 0, 0);\n+        String str1 = zone.getName(now.getMillis());\n+        String str2 = zone.getName(now.plusMonths(6).getMillis());\n+        assertEquals(false, str1.equals(str2));\n+    }\n+\n+    public void testPatchedNameKeysGazaHistoric() throws Exception {\n+        // the tz database does not have unique name keys [1716305]\n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Gaza\");\n+        \n+        DateTime now = new DateTime(1944, 1, 1, 0, 0, 0, 0);\n+        String str1 = zone.getName(now.getMillis());\n+        String str2 = zone.getName(now.plusMonths(6).getMillis());\n+        assertEquals(false, str1.equals(str2));\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/tz/TestBuilder.java\n+++ b/JodaTime/src/test/org/joda/time/tz/TestBuilder.java\n     }\n \n     static DateTimeZone buildAmericaLosAngeles() {\n-        return buildAmericaLosAngelesBuilder().toDateTimeZone(\"America/Los_Angeles\");\n+        return buildAmericaLosAngelesBuilder().toDateTimeZone(\"America/Los_Angeles\", true);\n     }\n \n     private DateTimeZone originalDateTimeZone = null;\n         throws IOException\n     {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        builder.writeTo(out);\n+        builder.writeTo(\"America/Los_Angeles\", out);\n         ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n         DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n         assertEquals(id, tz.getID());\n         DateTimeZoneBuilder builder = new DateTimeZoneBuilder()\n             .setStandardOffset(3600000)\n             .setFixedSavings(\"LMT\", 0);\n-        DateTimeZone tz = builder.toDateTimeZone(\"Test\");\n+        DateTimeZone tz = builder.toDateTimeZone(\"Test\", true);\n \n         for (int i=0; i<2; i++) {\n             assertEquals(\"Test\", tz.getID());", "timestamp": 1179655374, "metainfo": ""}