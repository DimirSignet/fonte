{"sha": "e610c97b456dded9fa022582cf49b911f5509a91", "log": "Constructing TimeOfDay with String value no longer accepts date fields, and 'T' prefix is now optional.    ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public TimeOfDay(Object instant) {\n-        super(instant, null);\n+        super(instant, null, ISODateTimeFormat.timeParser());\n     }\n \n     /**\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n     public TimeOfDay(Object instant, Chronology chronology) {\n-        super(instant, DateTimeUtils.getChronology(chronology));\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.PartialConverter;\n import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n \n /**\n  * BasePartial is an abstract implementation of ReadablePartial that stores\n     }\n \n     /**\n+     * Constructs a partial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology, null means use converter\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @throws IllegalArgumentException if the date is invalid\n+     * @since 1.3\n+     */\n+    protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) {\n+        super();\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iValues = converter.getPartialValues(this, instant, chronology, parser);\n+    }\n+\n+    /**\n      * Constructs a partial with specified time field values and chronology.\n      * <p>\n      * The constructor uses the time zone of the chronology specified.\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n      *  This partial may be incomplete and only getFieldType(int) should be used\n      * @param object  the object to convert\n      * @param chrono  the chronology to use, which is the non-null result of getChronology()\n-     * @return the array of field values that match the \n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n      */\n     public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n         long instant = getInstantMillis(object, chrono);\n+        return chrono.get(fieldSource, instant);\n+    }\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono,\n+                                  DateTimeFormatter parser)\n+    {\n+        long instant = getInstantMillis(object, chrono, parser);\n         return chrono.get(fieldSource, instant);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/PartialConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/PartialConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.ReadablePartial;\n+import org.joda.time.format.DateTimeFormatter;\n \n /**\n  * PartialConverter defines how an object is converted to a ReadablePartial.\n      */\n     int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono);\n \n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono,\n+                           DateTimeFormatter parser);\n+\n }", "timestamp": 1145736928, "metainfo": ""}