{"sha": "8703ffc3c1e71d42a8a41932055a875bf428bf8d", "log": "Flag for property affinity.  R=johnlenz DELTA=68  (56 added, 1 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1139   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Controls which properties get renamed. */\n   public PropertyRenamingPolicy propertyRenaming;\n+\n+  /** Should we use affinity information when generating property names. */\n+  boolean propertyAffinity;\n \n   /** Controls label renaming. */\n   public boolean labelRenaming;\n     // Renaming\n     variableRenaming = VariableRenamingPolicy.OFF;\n     propertyRenaming = PropertyRenamingPolicy.OFF;\n+    propertyAffinity = false;\n     labelRenaming = false;\n     generatePseudoNames = false;\n     shadowVariables = false;\n     this.propertyRenaming = newPropertyPolicy;\n   }\n \n+  public void setPropertyAffinity(boolean useAffinity) {\n+    this.propertyAffinity = useAffinity;\n+  }\n \n   /** Should shadow outer scope variable name during renaming. */\n   public void setShadowVariables(boolean shadow) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n       case ALL_UNQUOTED:\n         RenameProperties rprop = new RenameProperties(\n-            compiler, options.generatePseudoNames, prevPropertyMap,\n-            reservedChars);\n+            compiler, options.propertyAffinity, options.generatePseudoNames,\n+            prevPropertyMap, reservedChars);\n         rprop.process(externs, root);\n         return rprop.getPropertyMap();\n \n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n    *\n    * The graph would have X -> Y with the edge of N.\n    */\n-  private final UndiGraph<Property, PropertyAffinity> affinityGraph =\n-      LinkedUndirectedGraph.createWithoutAnnotations();\n+  private final UndiGraph<Property, PropertyAffinity> affinityGraph;\n \n   // Property names that don't get renamed\n   private final Set<String> externedNames = new HashSet<String>(\n    * Creates an instance.\n    *\n    * @param compiler The JSCompiler\n+   * @param affinity Optimize for affinity information.\n    * @param generatePseudoNames Generate pseudo names. e.g foo -> $foo$ instead\n    *        of compact obfuscated names. This is used for debugging.\n    */\n-  RenameProperties(AbstractCompiler compiler,\n+  RenameProperties(AbstractCompiler compiler, boolean affinity,\n       boolean generatePseudoNames) {\n-    this(compiler, generatePseudoNames, null, null);\n+    this(compiler, affinity, generatePseudoNames, null, null);\n   }\n \n   /**\n    * Creates an instance.\n    *\n    * @param compiler The JSCompiler.\n+   * @param affinity Optimize for affinity information.\n    * @param generatePseudoNames Generate pseudo names. e.g foo -> $foo$ instead\n    *        of compact obfuscated names. This is used for debugging.\n    * @param prevUsedPropertyMap The property renaming map used in a previous\n    *        compilation.\n    */\n-  RenameProperties(AbstractCompiler compiler,\n+  RenameProperties(AbstractCompiler compiler, boolean affinity,\n       boolean generatePseudoNames, VariableMap prevUsedPropertyMap) {\n-    this(compiler, generatePseudoNames, prevUsedPropertyMap, null);\n+    this(compiler, affinity, generatePseudoNames, prevUsedPropertyMap, null);\n   }\n \n   /**\n    * Creates an instance.\n    *\n    * @param compiler The JSCompiler.\n+   * @param affinity Optimize for affinity information.\n    * @param generatePseudoNames Generate pseudo names. e.g foo -> $foo$ instead\n    *        of compact obfuscated names. This is used for debugging.\n    * @param prevUsedPropertyMap The property renaming map used in a previous\n    *   generated names\n    */\n   RenameProperties(AbstractCompiler compiler,\n+      boolean affinity,\n       boolean generatePseudoNames,\n       VariableMap prevUsedPropertyMap,\n       @Nullable char[] reservedCharacters) {\n     this.generatePseudoNames = generatePseudoNames;\n     this.prevUsedPropertyMap = prevUsedPropertyMap;\n     this.reservedCharacters = reservedCharacters;\n+    if (affinity) {\n+      this.affinityGraph = LinkedUndirectedGraph.createWithoutAnnotations();\n+    } else {\n+      this.affinityGraph = null;\n+    }\n   }\n \n   @Override\n     }\n \n     compiler.addToDebugLog(\"JS property assignments:\");\n-    computeAffinityScores();\n+    if (affinityGraph != null) {\n+      computeAffinityScores();\n+    }\n \n     // Assign names, sorted by descending frequency to minimize code size.\n     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n       if (prop == null) {\n         prop = new Property(name);\n         propertyMap.put(name, prop);\n-        affinityGraph.createNode(prop);\n+        if (affinityGraph != null) {\n+          affinityGraph.createNode(prop);\n+        }\n       }\n       prop.numOccurrences++;\n       if (currentHighAffinityProperties != null) {\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n+      if (affinityGraph == null) {\n+        return;\n+      }\n       if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {\n         for (Property p1 : currentHighAffinityProperties) {\n           for (Property p2 : currentHighAffinityProperties) {\n   }\n \n   private class PropertyAffinity {\n+    // This will forever be zero if no affinity information was gathered.\n     private int affinity = 0;\n \n     private PropertyAffinity(int affinity) {\n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n \n   private static boolean generatePseudoNames = false;\n \n+  private static boolean useAffinity = false;\n+\n   private VariableMap prevUsedPropertyMap = null;\n+\n \n   public RenamePropertiesTest() {\n     super(EXTERNS);\n     super.tearDown();\n \n     prevUsedPropertyMap = null;\n+    useAffinity = false;\n   }\n \n   @Override protected int getNumRepetitions() {\n   public void testPropertyAffinity() {\n     // 'y' gets to be 'b' because it appears with z often.\n     // Other wise, 'x' gets to be 'b' because of alphabetical ordering.\n-\n+    useAffinity = true;\n     test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n          \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n          \"function f2() {                      foo.x}\",\n          \"var foo={};foo.c=1;foo.b=2;foo.a=3;\" +\n          \"function f1() { foo.a; foo.a; foo.a; foo.b}\" +\n          \"function f2() {                      foo.c}\");\n+\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+        \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+        \"function f2() { foo.z; foo.z; foo.z; foo.x}\",\n+\n+\n+        \"var foo={};foo.b=1;foo.c=2;foo.a=3;\" +\n+        \"function f1() { foo.a; foo.a; foo.a; foo.c}\" +\n+        \"function f2() { foo.a; foo.a; foo.a; foo.b}\");\n+  }\n+\n+  public void testPropertyAffinityOff() {\n+    useAffinity = false;\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+         \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+         \"function f2() {                      foo.x}\",\n+\n+\n+         \"var foo={};foo.b=1;foo.c=2;foo.a=3;\" +\n+         \"function f1() { foo.a; foo.a; foo.a; foo.c}\" +\n+         \"function f2() {                      foo.b}\");\n \n     test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n         \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return renameProperties =\n-        new RenameProperties(compiler, generatePseudoNames,\n+        new RenameProperties(compiler, useAffinity, generatePseudoNames,\n                              prevUsedPropertyMap);\n   }\n }", "timestamp": 1301497165, "metainfo": ""}