{"sha": "b29d4a8bc7138f9216930edfebed29d42f0dca89", "log": "Change on 2010/04/19 by nick          automatic source-sorting based on closure dependencies.          R=alan         DELTA=98  (89 added, 5 deleted, 4 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=ohwxnh   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   }\n \n   protected void initOptionsFromFlags(CompilerOptions options) {\n-\n     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n \n     diagnosticGroups.setWarningLevels(\n         options, config.jscompOff, CheckLevel.OFF);\n \n     createDefineReplacements(config.define, options);\n+\n+    options.sortClosureDependencies = config.sortClosureDependencies;\n   }\n \n   final protected A getCompiler() {\n       this.charset = charset;\n       return this;\n     }\n+\n+    private boolean sortClosureDependencies = false;\n+\n+    /**\n+     * Sets whether to sort files by their goog.provide/require deps.\n+     */\n+    CommandLineConfig setSortClosureDependencies(boolean newVal) {\n+      this.sortClosureDependencies = newVal;\n+      return this;\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         usage = \"Processes built-ins from the Closure library, such as \"\n         + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n     private boolean process_closure_primitives = true;\n+\n+    @Option(name = \"--sort_closure_dependencies\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Automatically sort dependencies so that a file that \"\n+        + \"goog.provides symbol X will always come before a file that \"\n+        + \"goog.requires symbol X.\")\n+    private boolean sort_closure_dependencies = false;\n \n     // Our own option parser to be backwards-compatible.\n     // It needs to be public because of the crazy reflection that args4j does.\n           .setJscompWarning(flags.jscomp_warning)\n           .setJscompOff(flags.jscomp_off)\n           .setDefine(flags.define)\n-          .setCharset(flags.charset);\n+          .setCharset(flags.charset)\n+          .setSortClosureDependencies(flags.sort_closure_dependencies);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n+import com.google.javascript.jscomp.deps.SortedDependencies;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n   /** Whether to use threads. */\n   private boolean useThreads = true;\n \n-  /** \n+  /**\n    * Whether to assume there are references to the RegExp Global object\n    * properties.\n    */\n   private boolean hasRegExpGlobalReferences = true;\n-  \n+\n   /** The function information map */\n   private FunctionInformationMap functionInformationMap;\n \n   public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n       CompilerOptions options) {\n     initOptions(options);\n-    \n+\n     this.externs = makeCompilerInput(externs, true);\n     this.modules = null;\n     this.moduleGraph = null;\n     initModules(Lists.<JSSourceFile>newArrayList(externs),\n          Lists.<JSModule>newArrayList(modules), options);\n   }\n-  \n+\n   /**\n    * Initializes the instance state needed for a compile job if the sources\n    * are in modules.\n           modules.get(0).getName()));\n     }\n   }\n-  \n+\n   /**\n    * Fill any empty modules with a place holder file. It makes any cross module\n    * motion easier.\n       }\n     }\n   }\n-  \n+\n   static final DiagnosticType DUPLICATE_INPUT_IN_MODULES =\n       DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\",\n           \"Two modules cannot contain the same input, but module {0} and {1} \"\n         Lists.<JSSourceFile>newArrayList(inputs),\n         options);\n   }\n-  \n+\n   /**\n    * Compiles a list of inputs.\n    */\n           return null;\n         }\n         externsRoot.addChildToBack(n);\n+      }\n+\n+      if (options.sortClosureDependencies) {\n+        for (CompilerInput input : inputs) {\n+          input.setCompiler(this);\n+        }\n+\n+        SortedDependencies<CompilerInput> sorter =\n+            new SortedDependencies<CompilerInput>(inputs);\n+        inputs = Lists.newArrayList(sorter.getSortedList());\n       }\n \n       List<CompilerInput> annotatedExterns = Lists.newArrayList();\n             cb.append(\"\\n\");  // Make sure that the label starts on a new line\n           }\n           Preconditions.checkState(root.getType() == Token.SCRIPT);\n-          \n+\n           String delimiter = options.inputDelimiter;\n-          \n+\n           String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n           Preconditions.checkState(sourceName != null);\n           Preconditions.checkState(!sourceName.isEmpty());\n-          \n+\n           delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n             .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n \n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n-    \n+\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * every pass. Only intended for internal development.\n    */\n   DevMode devMode;\n+\n+  //--------------------------------\n+  // Input Options\n+  //--------------------------------\n+\n+  boolean sortClosureDependencies = false;\n \n   //--------------------------------\n   // Checks\n   }\n \n   /**\n+   * Sort inputs by their goog.provide/goog.require calls.\n+   */\n+  public void setSortClosureDependencies(boolean newVal) {\n+    sortClosureDependencies = newVal;\n+  }\n+\n+  /**\n    * Controls how detailed the compilation summary is. Values:\n    *  0 (never print summary), 1 (print summary only if there are\n    * errors or warnings), 2 (print summary if type checking is on,\n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n  */\n public class SortedDependencies<INPUT extends DependencyInfo> {\n \n+  private final List<INPUT> inputs;\n+\n   // A topologically sorted list of the inputs.\n   private final List<INPUT> sortedList;\n \n   private final List<INPUT> noProvides;\n \n   public SortedDependencies(List<INPUT> inputs) {\n+    this.inputs = Lists.newArrayList(inputs);\n+\n     final Map<String, INPUT> provides = Maps.newHashMap();\n     noProvides = Lists.newArrayList();\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n \n+  private boolean useModules = false;\n+\n   private List<String> args = Lists.newArrayList();\n \n   /** Externs for the test */\n     super.setUp();\n     lastCompiler = null;\n     useStringComparison = false;\n+    useModules = false;\n     args.clear();\n   }\n \n     test(new String[] {\"/** @externs */ function f() {}\", \"f(3);\"},\n          new String[] {\"f(3);\"},\n          TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  public void testSourceSortingOff() {\n+    test(new String[] {\n+          \"goog.require('beer');\",\n+          \"goog.provide('beer');\"\n+         }, ProcessClosurePrimitives.LATE_PROVIDE_ERROR);\n+  }\n+\n+  public void testSourceSortingOn() {\n+    args.add(\"--sort_closure_dependencies=true\");\n+    test(new String[] {\n+          \"goog.require('beer');\",\n+          \"goog.provide('beer');\"\n+         },\n+         new String[] {\n+           \"var beer = {};\",\n+           \"\"\n+         });\n   }\n \n   /* Helper functions */\n     CommandLineRunner runner = new CommandLineRunner(argStrings);\n     Compiler compiler = runner.createCompiler();\n     lastCompiler = compiler;\n-    JSSourceFile[] inputs = new JSSourceFile[original.length];\n-    for (int i = 0; i < original.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n-    }\n     CompilerOptions options = runner.createOptions();\n     try {\n       runner.setRunOptions(options);\n     } catch (IOException e) {\n       assert(false);\n     }\n-    compiler.compile(\n-        externs, CompilerTestCase.createModuleChain(original), options);\n+    if (useModules) {\n+      compiler.compile(\n+          externs,\n+          CompilerTestCase.createModuleChain(original),\n+          options);\n+    } else {\n+      JSSourceFile[] inputs = new JSSourceFile[original.length];\n+      for (int i = 0; i < original.length; i++) {\n+        inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+      }\n+      compiler.compile(\n+          externs,\n+          inputs,\n+          options);\n+    }\n     return compiler;\n   }\n ", "timestamp": 1271779200, "metainfo": ""}