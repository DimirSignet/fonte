{"sha": "3235d9f223a9286495b2099a5b3b1e6afb0b46d9", "log": "simplify JSType -> Symbol lookup  R=acleung DELTA=81  (38 added, 11 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3345   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n    */\n   public Symbol getSymbolForScope(SymbolScope scope) {\n     if (scope.isPropertyScope()) {\n-      JSType type = scope.getTypeOfThis();\n-      if (type != null) {\n-        if (type.isGlobalThisType()) {\n-          return globalScope.getSlot(GLOBAL_THIS);\n-        } else if (type.isNominalConstructor()) {\n-          return getSymbolDeclaredBy(type.toMaybeFunctionType());\n-        } else if (type.isFunctionPrototypeType()) {\n-          return getSymbolForInstancesOf(\n-              ((ObjectType) type).getOwnerFunction());\n-        }\n-      }\n-      return null;\n+      return getSymbolForTypeHelper(scope.getTypeOfThis(), false);\n     }\n \n     Node rootNode = scope.getRootNode();\n   /**\n    * Gets all symbols associated with the given type.\n    * For union types, this may be multiple symbols.\n+   * For instance types, this will return the constructor of\n+   * that instance.\n    */\n   public List<Symbol> getAllSymbolsForType(JSType type) {\n     if (type == null) {\n       List<Symbol> result = Lists.newArrayListWithExpectedSize(2);\n       for (JSType alt : unionType.getAlternates()) {\n         // Our type system never has nested unions.\n-        Symbol altSym = getOnlySymbolForType(alt);\n+        Symbol altSym = getSymbolForTypeHelper(alt, true);\n         if (altSym != null) {\n           result.add(altSym);\n         }\n       }\n       return result;\n     }\n-    Symbol result = getOnlySymbolForType(type);\n+    Symbol result = getSymbolForTypeHelper(type, true);\n     return result == null\n         ? ImmutableList.<Symbol>of() : ImmutableList.of(result);\n   }\n \n   /**\n    * Gets all symbols associated with the given type.\n-   * If there are more that one symbol associated with the given type,\n+   * If there is more that one symbol associated with the given type,\n    * return null.\n-   */\n-  private Symbol getOnlySymbolForType(JSType type) {\n+   * @param type The type.\n+   * @param linkToCtor If true, we should link instance types back\n+   *     to their constructor function. If false, we should link\n+   *     instance types back to their prototype. See the comments\n+   *     at the top of this file for more information on how\n+   *     our internal type system is more granular than Symbols.\n+   */\n+  private Symbol getSymbolForTypeHelper(JSType type, boolean linkToCtor) {\n     if (type == null) {\n       return null;\n     }\n \n-    FunctionType fnType = type.toMaybeFunctionType();\n-    if (fnType != null) {\n-      return globalScope.getSlot(\"Function\");\n-    }\n-\n-    ObjectType objType = type.toObjectType();\n-    if (objType != null) {\n-      String name = objType.getReferenceName();\n-\n-      FunctionType ctor = objType.getConstructor();\n-      Node sourceNode = ctor == null ? null : ctor.getSource();\n-      SymbolScope scope = sourceNode == null\n-          ? globalScope : getEnclosingScope(sourceNode);\n-\n-      return scope.getSlot(\n-          (name == null || !objType.isInstanceType())\n-          ? \"Object\" : name);\n-    }\n-\n-    // TODO(nicksantos): Create symbols for value types (number, string).\n-    return null;\n+    if (type.isGlobalThisType()) {\n+      return globalScope.getSlot(GLOBAL_THIS);\n+    } else if (type.isNominalConstructor()) {\n+      return linkToCtor ?\n+          globalScope.getSlot(\"Function\") :\n+          getSymbolDeclaredBy(type.toMaybeFunctionType());\n+    } else if (type.isFunctionPrototypeType()) {\n+      FunctionType ownerFn = ((ObjectType) type).getOwnerFunction();\n+      return linkToCtor ?\n+          getSymbolDeclaredBy(ownerFn) :\n+          getSymbolForInstancesOf(ownerFn);\n+    } else if (type.isInstanceType()) {\n+      FunctionType ownerFn = ((ObjectType) type).getConstructor();\n+      return linkToCtor ?\n+          getSymbolDeclaredBy(ownerFn) :\n+          getSymbolForInstancesOf(ownerFn);\n+    } else if (type.isFunctionType()) {\n+      return linkToCtor ?\n+          globalScope.getSlot(\"Function\") :\n+          globalScope.getSlot(\"Function.prototype\");\n+    } else if (type.autoboxesTo() != null) {\n+      return getSymbolForTypeHelper(type.autoboxesTo(), linkToCtor);\n+    } else {\n+      return null;\n+    }\n   }\n \n   public String toDebugString() {\n    * <code>\n    * SymbolTable symbolTale = for(\"var x = new Foo();\");\n    * Symbol x = symbolTable.getGlobalScope().getSlot(\"x\");\n-   * Symbol type = symbolTable.getOnlySymbolForType(x.getType());\n+   * Symbol type = symbolTable.getAllSymbolsForType(x.getType()).get(0);\n    * </code>\n    *\n    * Then type.getPropertyScope() will have the properties of the\n           // primitive type (like {string}). Autobox it to check.\n           JSType type = registry.getType(n.getString());\n           JSType autobox = type == null ? null : type.autoboxesTo();\n-          symbol = autobox == null ? null : getOnlySymbolForType(autobox);\n+          symbol = autobox == null\n+              ? null : getSymbolForTypeHelper(autobox, true);\n         }\n         if (symbol != null) {\n           symbol.defineReferenceAt(n);\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(\n         Lists.newArrayList(fn), table.getAllSymbolsForTypeOf(foo));\n     assertEquals(\n-        Lists.newArrayList(obj), table.getAllSymbolsForTypeOf(fooPrototype));\n+        Lists.newArrayList(foo), table.getAllSymbolsForTypeOf(fooPrototype));\n     assertEquals(\n         foo,\n         table.getSymbolDeclaredBy(\n         getGlobalVar(table, \"DomHelper.prototype.method\");\n     assertEquals(\n         3, Iterables.size(table.getReferences(method)));\n+  }\n+\n+  public void testSuperClassMethodReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {};\" +\n+        \"goog.inherits = function(a, b) {};\" +\n+        \"/** @constructor */ var A = function(){};\" +\n+        \"/** method */ A.prototype.method = function() {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {A}\\n\" +\n+        \" */\\n\" +\n+        \"var B = function(){};\\n\" +\n+        \"goog.inherits(B, A);\" +\n+        \"/** method */ B.prototype.method = function() {\" +\n+        \"  B.superClass_.method();\" +\n+        \"};\");\n+\n+    Symbol methodA =\n+        getGlobalVar(table, \"A.prototype.method\");\n+    assertEquals(\n+        2, Iterables.size(table.getReferences(methodA)));\n   }\n \n   public void testFieldReferences() throws Exception {", "timestamp": 1317152284, "metainfo": ""}