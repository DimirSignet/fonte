{"sha": "2f8852d6fe2ba025215b2ab36b2379870d34bee0", "log": "Change on 2010/05/20 by nick          optimize disk I/O a bit by skipping goog.provides/requires         after actual JS. This is consistent with what the other         dependency tools do.         Also, force the caller to use a Reader for file contents.          R=andrew         DELTA=66  (50 added, 8 deleted, 8 changed)  Change on 2010/05/20 by nick          some more regexp-fu to catch a case i missed         (where you have \"/**\\n\", so there's no matching char after          the second star)          R=andrew         DELTA=68  (40 added, 14 deleted, 14 changed)  Change on 2010/05/20 by nick          open-source the i18n tests          R=john         DELTA=55  (42 added, 3 deleted, 10 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=10001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.StringReader;\n import java.util.List;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n   public List<DependencyInfo> parseFile(String filePath, String fileContents) {\n     depInfos = Lists.newArrayList();\n     logger.info(\"Parsing Dep: \" + filePath);\n-    doParse(filePath, fileContents);\n+    doParse(filePath, new StringReader(fileContents));\n \n     return depInfos;\n   }\n    *     goog.addDependency().\n    */\n   @Override\n-  protected void parseLine(String line) throws ParseException {\n+  protected boolean parseLine(String line) throws ParseException {\n     depMatcher.reset(line);\n     // See if the line looks like: goog.addDependency(...)\n     if (depMatcher.matches()) {\n       }\n       depInfos.add(depInfo);\n     }\n+\n+    return true;\n   }\n }\n--- a/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n     }\n   }\n \n-  /** Patterns for stripping JavaScript comments from source files. */\n-  private static final Pattern COMMENT = Pattern.compile(\n-      \"//.*\" + // single-line comment\n-      \"|/\\\\*([^\\\\*]*(\\\\*+[^/\\\\*])?)*(\\\\*+/)?\" // start of multi-line comment\n-      );\n-  private static final Pattern END_MULTILINE_COMMENT =\n-      Pattern.compile(\".*?\\\\*/\");\n-\n   /** Pattern for matching JavaScript string literals. */\n   private static final Pattern STRING_LITERAL_PATTERN = Pattern.compile(\n       \"\\\\s*(?:'((?:\\\\\\\\'|[^'])*?)'|\\\"((?:\\\\\\\\\\\"|[^\\\"])*?)\\\")\\\\s*\");\n-\n-  /** Matchers for comments. */\n-  private Matcher commentMatcher = COMMENT.matcher(\"\");\n-\n-  private Matcher endMultilineCommentMatcher =\n-      END_MULTILINE_COMMENT.matcher(\"\");\n \n   /** Matcher used in the parsing string literals. */\n   private Matcher valueMatcher = STRING_LITERAL_PATTERN.matcher(\"\");\n   }\n \n   /**\n-   * @see parseLine(String, Reader)\n-   */\n-  void doParse(String filePath, String fileContents) {\n-    doParse(filePath, new StringReader(fileContents));\n-  }\n-\n-  /**\n    * Performs the line-by-line parsing of the given fileContents. This method\n    * strips out Javascript comments and then uses the abstract parseLine()\n    * method to do the line parsing.\n         try {\n           String revisedLine = line;\n           if (inMultilineComment) {\n-            endMultilineCommentMatcher.reset(line);\n-            if (endMultilineCommentMatcher.lookingAt()) {\n-              revisedLine = endMultilineCommentMatcher.replaceFirst(\"\");\n+            int endOfComment = revisedLine.indexOf(\"*/\");\n+            if (endOfComment != -1) {\n+              revisedLine = revisedLine.substring(endOfComment + 2);\n               inMultilineComment = false;\n             } else {\n               revisedLine = \"\";\n           }\n \n           if (!inMultilineComment) {\n-            commentMatcher.reset(line);\n-            if (commentMatcher.find()) {\n-              do {\n-                if (// The last match hit a /**-style comment.\n-                    commentMatcher.group(1) != null &&\n-                    // The /**-style comment didn't close.\n-                    commentMatcher.group(3) == null) {\n+            while (true) {\n+              int startOfLineComment = revisedLine.indexOf(\"//\");\n+              int startOfMultilineComment = revisedLine.indexOf(\"/*\");\n+              if (startOfLineComment != -1 &&\n+                  (startOfMultilineComment == -1 ||\n+                   startOfLineComment < startOfMultilineComment)) {\n+                revisedLine = revisedLine.substring(0, startOfLineComment);\n+                break;\n+              } else if (startOfMultilineComment != -1) {\n+                int endOfMultilineComment = revisedLine.indexOf(\"*/\",\n+                    startOfMultilineComment + 2);\n+                if (endOfMultilineComment == -1) {\n+                  revisedLine = revisedLine.substring(\n+                      0, startOfMultilineComment);\n                   inMultilineComment = true;\n+                  break;\n+                } else {\n+                  revisedLine =\n+                      revisedLine.substring(0, startOfMultilineComment) +\n+                      revisedLine.substring(endOfMultilineComment + 2);\n                 }\n-              } while (commentMatcher.find());\n-\n-              revisedLine = commentMatcher.replaceAll(\"\");\n+              } else {\n+                break;\n+              }\n             }\n           }\n \n           if (!revisedLine.isEmpty()) {\n-            parseLine(revisedLine);\n+            if (!parseLine(revisedLine)) {\n+              break;\n+            }\n           }\n         } catch (ParseException e) {\n           // Inform the error handler of the exception.\n    * Called for each line of the file being parsed.\n    *\n    * @param line The line to parse.\n+   * @return true to keep going, false otherwise.\n    * @throws ParseException Should be thrown to signify a problem with the line.\n    */\n-  abstract void parseLine(String line) throws ParseException;\n+  abstract boolean parseLine(String line) throws ParseException;\n \n   /**\n    * Parses a JS string literal.\n--- a/src/com/google/javascript/jscomp/deps/JsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileParser.java\n \n package com.google.javascript.jscomp.deps;\n \n+import com.google.common.base.CharMatcher;\n import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.ErrorManager;\n \n+import java.io.BufferedReader;\n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n import java.util.logging.Logger;\n import java.util.regex.Matcher;\n   private List<String> provides;\n   private List<String> requires;\n \n+  private boolean shortcutMode = false;\n+\n   /**\n    * Constructor\n    *\n    */\n   public JsFileParser(ErrorManager errorManager) {\n     super(errorManager);\n+  }\n+\n+  public void setShortcutMode(boolean mode) {\n+    this.shortcutMode = mode;\n   }\n \n   /**\n    */\n   public DependencyInfo parseFile(String filePath, String closureRelativePath)\n       throws IOException {\n-    return parseFile(filePath, closureRelativePath,\n-        Files.toString(new File(filePath), Charsets.UTF_8));\n+    return parseReader(filePath, closureRelativePath, new FileReader(filePath));\n   }\n \n   /**\n    */\n   public DependencyInfo parseFile(String filePath, String closureRelativePath,\n       String fileContents) {\n+    return parseReader(filePath, closureRelativePath,\n+        new StringReader(fileContents));\n+  }\n+\n+  private DependencyInfo parseReader(String filePath,\n+      String closureRelativePath, Reader fileContents) {\n     provides = Lists.newArrayList();\n     requires = Lists.newArrayList();\n \n    * information.\n    */\n   @Override\n-  protected void parseLine(String line) throws ParseException {\n+  protected boolean parseLine(String line) throws ParseException {\n+    boolean hasProvidesOrRequires = false;\n+\n     // Iterate over the provides/requires.\n     googMatcher.reset(line);\n     while (googMatcher.find()) {\n+      hasProvidesOrRequires = true;\n+\n       // See if it's a require or provide.\n       boolean isRequire = googMatcher.group(1).charAt(0) == 'r';\n       // Parse the param.\n         provides.add(arg);\n       }\n     }\n+\n+    return !shortcutMode || hasProvidesOrRequires ||\n+        CharMatcher.WHITESPACE.matchesAllOf(line);\n   }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/JsMessageTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import junit.framework.*;\n+\n+/**\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+public class JsMessageTest extends TestCase {\n+\n+  public void testIsEmpty() {\n+    assertTrue(new JsMessage.Builder().build().isEmpty());\n+    assertTrue(new JsMessage.Builder().appendStringPart(\"\").build().isEmpty());\n+    assertTrue(new JsMessage.Builder().appendStringPart(\"\")\n+        .appendStringPart(\"\").build().isEmpty());\n+    assertFalse(new JsMessage.Builder().appendStringPart(\"s\")\n+        .appendStringPart(\"\").build().isEmpty());\n+    assertFalse(new JsMessage.Builder().appendPlaceholderReference(\"3\")\n+        .build().isEmpty());\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import static com.google.javascript.jscomp.JsMessage.Style;\n+import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE;\n+import static com.google.javascript.jscomp.JsMessage.Style.LEGACY;\n+import static com.google.javascript.jscomp.JsMessage.Style.RELAX;\n+import static com.google.javascript.jscomp.JsMessageVisitor.isLowerCamelCaseWithNumericSuffixes;\n+import static com.google.javascript.jscomp.JsMessageVisitor.toLowerCamelCaseWithNumericSuffixes;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * Test for {@link JsMessageVisitor}.\n+ *\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+public class JsMessageVisitorTest extends TestCase {\n+\n+  private Compiler compiler;\n+  private List<JsMessage> messages;\n+  private boolean allowLegacyMessages;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    messages = Lists.newLinkedList();\n+    allowLegacyMessages = true;\n+  }\n+\n+  public void testJsMessageOnVar() {\n+    extractMessagesSafely(\n+        \"/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')\");\n+    assertEquals(0, compiler.getWarningCount());\n+    assertEquals(1, messages.size());\n+\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_HELLO\", msg.getKey());\n+    assertEquals(\"Hello\", msg.getDesc());\n+  }\n+\n+  public void testJsMessageOnProperty() {\n+    extractMessagesSafely(\"/** @desc a */ \" +\n+        \"pint.sub.MSG_MENU_MARK_AS_UNREAD = goog.getMsg('a')\");\n+    assertEquals(0, compiler.getWarningCount());\n+    assertEquals(1, messages.size());\n+\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_MENU_MARK_AS_UNREAD\", msg.getKey());\n+    assertEquals(\"a\", msg.getDesc());\n+  }\n+\n+  public void testOrphanedJsMessage() {\n+    extractMessagesSafely(\"goog.getMsg('a')\");\n+    assertEquals(1, compiler.getWarningCount());\n+    assertEquals(0, messages.size());\n+\n+    JSError warn = compiler.getWarnings()[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_NODE_IS_ORPHANED, warn.getType());\n+  }\n+\n+  public void testMessageWithoutDescription() {\n+    extractMessagesSafely(\"var MSG_HELLO = goog.getMsg('a')\");\n+    assertEquals(1, compiler.getWarningCount());\n+    assertEquals(1, messages.size());\n+\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_HELLO\", msg.getKey());\n+\n+    assertEquals(JsMessageVisitor.MESSAGE_HAS_NO_DESCRIPTION,\n+        compiler.getWarnings()[0].getType());\n+  }\n+\n+  public void testIncorrectMessageReporting() {\n+    extractMessages(\"var MSG_HELLO = goog.getMsg('a' + + 'b')\");\n+    assertEquals(1, compiler.getErrorCount());\n+    assertEquals(0, compiler.getWarningCount());\n+    assertEquals(0, messages.size());\n+\n+    JSError mailformedTreeError = compiler.getErrors()[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED,\n+        mailformedTreeError.getType());\n+    assertEquals(\"Message parse tree malformed. \"\n+        + \"STRING or ADD node expected; found: POS\",\n+        mailformedTreeError.description);\n+  }\n+\n+  public void testEmptyMessage() {\n+    // This is an edge case. Empty messages are useless, but shouldn't fail\n+    extractMessagesSafely(\"var MSG_EMPTY = '';\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_EMPTY\", msg.getKey());\n+    assertEquals(\"\", msg.toString());\n+  }\n+\n+  public void testConcatOfStrings() {\n+    extractMessagesSafely(\"var MSG_NOTEMPTY = 'aa' + 'bbb' \\n + ' ccc';\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_NOTEMPTY\", msg.getKey());\n+    assertEquals(\"aabbb ccc\", msg.toString());\n+  }\n+\n+  public void testLegacyFormatDescription() {\n+    extractMessagesSafely(\"var MSG_SILLY = 'silly test message';\\n\"\n+        + \"var MSG_SILLY_HELP = 'help text';\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_SILLY\", msg.getKey());\n+    assertEquals(\"help text\", msg.getDesc());\n+    assertEquals(\"silly test message\", msg.toString());\n+  }\n+\n+  public void testLegacyFormatParametizedFunction() {\n+    extractMessagesSafely(\"var MSG_SILLY = function(one, two) {\"\n+        + \"  return one + ', ' + two + ', buckle my shoe';\"\n+        + \"};\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_SILLY\", msg.getKey());\n+    assertEquals(null, msg.getDesc());\n+    assertEquals(\"{$one}, {$two}, buckle my shoe\", msg.toString());\n+  }\n+\n+  public void testLegacyMessageWithDescAnnotation() {\n+    // Well, is was better do not allow legacy messages with @desc annotations,\n+    // but people love to mix styles so we need to check @desc also.\n+    extractMessagesSafely(\n+        \"/** @desc The description */ var MSG_A = 'The Message';\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(1, compiler.getWarningCount());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_A\", msg.getKey());\n+    assertEquals(\"The Message\", msg.toString());\n+    assertEquals(\"The description\", msg.getDesc());\n+  }\n+\n+  public void testLegacyMessageWithDescAnnotationAndHelpVar() {\n+    // Well, is was better do not allow legacy messages with @desc annotations,\n+    // but people love to mix styles so we need to check @desc also.\n+    extractMessagesSafely(\n+        \"var MSG_A_HELP = 'This is a help var';\\n\" +\n+        \"/** @desc The description in @desc*/ var MSG_A = 'The Message';\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(1, compiler.getWarningCount());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_A\", msg.getKey());\n+    assertEquals(\"The Message\", msg.toString());\n+    assertEquals(\"The description in @desc\", msg.getDesc());\n+  }\n+\n+  public void testClosureMessageWithHelpPostfix() {\n+    extractMessagesSafely(\"/** @desc help text */\\n\"\n+        + \"var MSG_FOO_HELP = goog.getMsg('Help!');\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_FOO_HELP\", msg.getKey());\n+    assertEquals(\"help text\", msg.getDesc());\n+    assertEquals(\"Help!\", msg.toString());\n+  }\n+\n+  public void testClosureMessageWithoutGoogGetmsg() {\n+    allowLegacyMessages = false;\n+\n+    extractMessages(\"var MSG_FOO_HELP = 'I am a bad message';\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX,\n+        error.getType());\n+  }\n+\n+  public void testClosureFormatParametizedFunction() {\n+    extractMessagesSafely(\"/** @desc help text */\"\n+        + \"var MSG_SILLY = goog.getMsg('{$adjective} ' + 'message', \"\n+        + \"{'adjective': 'silly'});\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_SILLY\", msg.getKey());\n+    assertEquals(\"help text\", msg.getDesc());\n+    assertEquals(\"{$adjective} message\", msg.toString());\n+  }\n+\n+  public void testHugeMessage() {\n+    extractMessagesSafely(\"/**\" +\n+        \" * @desc A message with lots of stuff.\\n\" +\n+        \" * @hidden\\n\" +\n+        \" */\" +\n+        \"var MSG_HUGE = goog.getMsg(\" +\n+        \"    '{$startLink_1}Google{$endLink}' +\" +\n+        \"    '{$startLink_2}blah{$endLink}{$boo}{$foo_001}{$boo}' +\" +\n+        \"    '{$foo_002}{$xxx_001}{$image}{$image_001}{$xxx_002}',\" +\n+        \"    {'startLink_1': '<a href=http://www.google.com/>',\" +\n+        \"     'endLink': '</a>',\" +\n+        \"     'startLink_2': '<a href=\\\"' + opt_data.url + '\\\">',\" +\n+        \"     'boo': opt_data.boo,\" +\n+        \"     'foo_001': opt_data.foo,\" +\n+        \"     'foo_002': opt_data.boo.foo,\" +\n+        \"     'xxx_001': opt_data.boo + opt_data.foo,\" +\n+        \"     'image': htmlTag7,\" +\n+        \"     'image_001': opt_data.image,\" +\n+        \"     'xxx_002': foo.callWithOnlyTopLevelKeys(\" +\n+        \"         bogusFn, opt_data, null, 'bogusKey1',\" +\n+        \"         opt_data.moo, 'bogusKey2', param10)});\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_HUGE\", msg.getKey());\n+    assertEquals(\"A message with lots of stuff.\", msg.getDesc());\n+    assertTrue(msg.isHidden());\n+    assertEquals(\"{$startLink_1}Google{$endLink}{$startLink_2}blah{$endLink}\" +\n+        \"{$boo}{$foo_001}{$boo}{$foo_002}{$xxx_001}{$image}\" +\n+        \"{$image_001}{$xxx_002}\", msg.toString());\n+  }\n+\n+  public void testUnnamedGoogleMessage() {\n+    extractMessagesSafely(\"var MSG_UNNAMED_2 = goog.getMsg('Hullo');\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(null, msg.getDesc());\n+    assertEquals(\"MSG_16LJMYKCXT84X\", msg.getKey());\n+    assertEquals(\"MSG_16LJMYKCXT84X\", msg.getId());\n+  }\n+\n+  public void testEmptyTextMessage() {\n+    extractMessagesSafely(\"/** @desc text */ var MSG_FOO = goog.getMsg('');\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(1, compiler.getWarningCount());\n+    assertEquals(\"Message value of MSG_FOO is just an empty string. \"\n+        + \"Empty messages are forbidden.\",\n+        compiler.getWarnings()[0].description);\n+  }\n+\n+  public void testEmptyTextComplexMessage() {\n+    extractMessagesSafely(\"/** @desc text */ var MSG_BAR = goog.getMsg(\"\n+        + \"'' + '' + ''     + ''\\n+'');\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(1, compiler.getWarningCount());\n+    assertEquals(\"Message value of MSG_BAR is just an empty string. \"\n+        + \"Empty messages are forbidden.\",\n+        compiler.getWarnings()[0].description);\n+  }\n+\n+  public void testMessageIsNoUnnamed() {\n+    extractMessagesSafely(\"var MSG_UNNAMED_ITEM = goog.getMsg('Hullo');\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_UNNAMED_ITEM\", msg.getKey());\n+    assertFalse(msg.isHidden());\n+  }\n+\n+  public void testMsgVarWithoutAssignment() {\n+    extractMessages(\"var MSG_SILLY;\");\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_HAS_NO_VALUE, error.getType());\n+  }\n+\n+  public void testRegularVarWithoutAssignment() {\n+    extractMessagesSafely(\"var SILLY;\");\n+\n+    assertTrue(messages.isEmpty());\n+  }\n+\n+  public void itIsNotImplementedYet_testMsgPropertyWithoutAssignment() {\n+    extractMessages(\"goog.message.MSG_SILLY_PROP;\");\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(\"Message MSG_SILLY_PROP has no value\", error.description);\n+  }\n+\n+  public void testMsgVarWithIncorrectRightSide() {\n+    extractMessages(\"var MSG_SILLY = 0;\");\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(\"Message parse tree malformed. Cannot parse value of \"\n+        + \"message MSG_SILLY\", error.description);\n+  }\n+\n+  public void testIncorrectMessage() {\n+    extractMessages(\"DP_DatePicker.MSG_DATE_SELECTION = {};\");\n+\n+    assertEquals(0, messages.size());\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(\"Message parse tree malformed. \"+\n+                 \"Message must be initialized using goog.getMsg function.\",\n+                 error.description);\n+  }\n+\n+  public void testUnrecognizedFunction() {\n+    allowLegacyMessages = false;\n+    extractMessages(\"DP_DatePicker.MSG_DATE_SELECTION = somefunc('a')\");\n+\n+    assertEquals(0, messages.size());\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(\"Message parse tree malformed. \"+\n+                 \"Message initialized using unrecognized function. \" +\n+                 \"Please use goog.getMsg() instead.\",\n+                 error.description);\n+  }\n+\n+  public void testExtractPropertyMessage() {\n+    extractMessagesSafely(\"/**\"\n+        + \" * @desc A message that demonstrates placeholders\\n\"\n+        + \" * @hidden\\n\"\n+        + \" */\"\n+        + \"a.b.MSG_SILLY = goog.getMsg(\\n\"\n+        + \"    '{$adjective} ' + '{$someNoun}',\\n\"\n+        + \"    {'adjective': adj, 'someNoun': noun});\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_SILLY\", msg.getKey());\n+    assertEquals(\"{$adjective} {$someNoun}\", msg.toString());\n+    assertEquals(\"A message that demonstrates placeholders\", msg.getDesc());\n+    assertTrue(msg.isHidden());\n+  }\n+\n+  public void testAlmostButNotExternalMessage() {\n+    extractMessagesSafely(\n+        \"/** @desc External */ var MSG_EXTERNAL = goog.getMsg('External');\");\n+    assertEquals(0, compiler.getWarningCount());\n+    assertEquals(1, messages.size());\n+    assertFalse(messages.get(0).isExternal());\n+    assertEquals(\"MSG_EXTERNAL\", messages.get(0).getKey());\n+  }\n+\n+  public void testExternalMessage() {\n+    extractMessagesSafely(\"var MSG_EXTERNAL_111 = goog.getMsg('Hello World');\");\n+    assertEquals(0, compiler.getWarningCount());\n+    assertEquals(1, messages.size());\n+    assertTrue(messages.get(0).isExternal());\n+    assertEquals(\"111\", messages.get(0).getId());\n+  }\n+\n+  public void testIsValidMessageNameStrict() {\n+    JsMessageVisitor visitor = new DummyJsVisitor(CLOSURE);\n+\n+    assertTrue(visitor.isMessageName(\"MSG_HELLO\", true));\n+    assertTrue(visitor.isMessageName(\"MSG_\", true));\n+    assertTrue(visitor.isMessageName(\"MSG_HELP\", true));\n+    assertTrue(visitor.isMessageName(\"MSG_FOO_HELP\", true));\n+\n+    assertFalse(visitor.isMessageName(\"_FOO_HELP\", true));\n+    assertFalse(visitor.isMessageName(\"MSGFOOP\", true));\n+  }\n+\n+  public void testIsValidMessageNameRelax() {\n+    JsMessageVisitor visitor = new DummyJsVisitor(RELAX);\n+\n+    assertFalse(visitor.isMessageName(\"MSG_HELP\", false));\n+    assertFalse(visitor.isMessageName(\"MSG_FOO_HELP\", false));\n+  }\n+\n+  public void testIsValidMessageNameLegacy() {\n+    theseAreLegacyMessageNames(new DummyJsVisitor(RELAX));\n+    theseAreLegacyMessageNames(new DummyJsVisitor(LEGACY));\n+  }\n+\n+  private void theseAreLegacyMessageNames(JsMessageVisitor visitor) {\n+    assertTrue(visitor.isMessageName(\"MSG_HELLO\", false));\n+    assertTrue(visitor.isMessageName(\"MSG_\", false));\n+\n+    assertFalse(visitor.isMessageName(\"MSG_HELP\", false));\n+    assertFalse(visitor.isMessageName(\"MSG_FOO_HELP\", false));\n+    assertFalse(visitor.isMessageName(\"_FOO_HELP\", false));\n+    assertFalse(visitor.isMessageName(\"MSGFOOP\", false));\n+  }\n+\n+  public void testUnexistedPlaceholders() {\n+    extractMessages(\"var MSG_FOO = goog.getMsg('{$foo}:', {});\");\n+\n+    assertEquals(0, messages.size());\n+    JSError[] errors = compiler.getErrors();\n+    assertEquals(1, errors.length);\n+    JSError error = errors[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType());\n+    assertEquals(\"Message parse tree malformed. Unrecognized message \"\n+        + \"placeholder referenced: foo\", error.description);\n+  }\n+\n+  public void testUnusedReferenesAreNotOK() {\n+    extractMessages(\"/** @desc AA */ \"\n+        + \"var MSG_FOO = goog.getMsg('lalala:', {foo:1});\");\n+    assertEquals(0, messages.size());\n+    JSError[] errors = compiler.getErrors();\n+    assertEquals(1, errors.length);\n+    JSError error = errors[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType());\n+    assertEquals(\"Message parse tree malformed. Unused message placeholder: \"\n+        + \"foo\", error.description);\n+  }\n+\n+  public void testDuplicatePlaceHoldersAreBad() {\n+    extractMessages(\"var MSG_FOO = goog.getMsg(\"\n+        + \"'{$foo}:', {'foo': 1, 'foo' : 2});\");\n+\n+    assertEquals(0, messages.size());\n+    JSError[] errors = compiler.getErrors();\n+    assertEquals(1, errors.length);\n+    JSError error = errors[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType());\n+    assertEquals(\"Message parse tree malformed. Duplicate placeholder \"\n+        + \"name: foo\", error.description);\n+  }\n+\n+  public void testDuplicatePlaceholderReferencesAreOk() {\n+    extractMessagesSafely(\"var MSG_FOO = goog.getMsg(\"\n+        + \"'{$foo}:, {$foo}', {'foo': 1});\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"{$foo}:, {$foo}\", msg.toString());\n+  }\n+\n+  public void testCamelcasePlaceholderNamesAreOk() {\n+    extractMessagesSafely(\"var MSG_WITH_CAMELCASE = goog.getMsg(\"\n+        + \"'Slide {$slideNumber}:', {'slideNumber': opt_index + 1});\");\n+\n+    assertEquals(1, messages.size());\n+    JsMessage msg = messages.get(0);\n+    assertEquals(\"MSG_WITH_CAMELCASE\", msg.getKey());\n+    assertEquals(\"Slide {$slideNumber}:\", msg.toString());\n+    List<CharSequence> parts = msg.parts();\n+    assertEquals(3, parts.size());\n+    assertEquals(\"slideNumber\",\n+        ((JsMessage.PlaceholderReference)parts.get(1)).getName());\n+  }\n+\n+  public void testWithNonCamelcasePlaceholderNamesAreNotOk() {\n+    extractMessages(\"var MSG_WITH_CAMELCASE = goog.getMsg(\"\n+        + \"'Slide {$slide_number}:', {'slide_number': opt_index + 1});\");\n+\n+    assertEquals(0, messages.size());\n+    JSError[] errors = compiler.getErrors();\n+    assertEquals(1, errors.length);\n+    JSError error = errors[0];\n+    assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType());\n+    assertEquals(\"Message parse tree malformed. Placeholder name not in \"\n+        + \"lowerCamelCase: slide_number\", error.description);\n+  }\n+\n+  public void testUnquotedPlaceholdersAreOk() {\n+    extractMessagesSafely(\"/** @desc Hello */ \"\n+        + \"var MSG_FOO = goog.getMsg('foo {$unquoted}:', {unquoted: 12});\");\n+\n+    assertEquals(1, messages.size());\n+    assertEquals(0, compiler.getWarningCount());\n+  }\n+\n+  public void testIsLowerCamelCaseWithNumericSuffixes() {\n+    assertTrue(isLowerCamelCaseWithNumericSuffixes(\"name\"));\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"NAME\"));\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"Name\"));\n+\n+    assertTrue(isLowerCamelCaseWithNumericSuffixes(\"a4Letter\"));\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"A4_LETTER\"));\n+\n+    assertTrue(isLowerCamelCaseWithNumericSuffixes(\"startSpan_1_23\"));\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"startSpan_1_23b\"));\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"START_SPAN_1_23\"));\n+\n+    assertFalse(isLowerCamelCaseWithNumericSuffixes(\"\"));\n+  }\n+\n+  public void testToLowerCamelCaseWithNumericSuffixes() {\n+    assertEquals(\"name\", toLowerCamelCaseWithNumericSuffixes(\"NAME\"));\n+    assertEquals(\"a4Letter\", toLowerCamelCaseWithNumericSuffixes(\"A4_LETTER\"));\n+    assertEquals(\"startSpan_1_23\",\n+        toLowerCamelCaseWithNumericSuffixes(\"START_SPAN_1_23\"));\n+  }\n+\n+  private void extractMessagesSafely(String input) {\n+    extractMessages(input);\n+    JSError[] errors = compiler.getErrors();\n+    if (errors.length > 0) {\n+      fail(errors[0].description);\n+    }\n+  }\n+\n+  private void extractMessages(String input) {\n+    compiler = new Compiler();\n+    Node root = compiler.parseTestCode(input);\n+    JsMessageVisitor visitor = new CollectMessages(compiler);\n+    visitor.process(null, root);\n+  }\n+\n+  private class CollectMessages extends JsMessageVisitor {\n+\n+    private CollectMessages(Compiler compiler) {\n+      super(compiler, true, Style.getFromParams(true, allowLegacyMessages),\n+            null);\n+    }\n+\n+    @Override\n+    protected void processJsMessage(JsMessage message,\n+        JsMessageDefinition definition) {\n+      messages.add(message);\n+    }\n+  }\n+\n+  private class DummyJsVisitor extends JsMessageVisitor {\n+\n+    private DummyJsVisitor(Style style) {\n+      super(null, true, style, null);\n+    }\n+\n+    @Override\n+    protected void processJsMessage(JsMessage message,\n+        JsMessageDefinition definition) {\n+      // no-op\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Maps;\n+import static com.google.javascript.jscomp.JsMessage.Style.RELAX;\n+import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED;\n+import static com.google.javascript.jscomp.ReplaceMessages.BUNDLE_DOES_NOT_HAVE_THE_MESSAGE;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * Test which checks that replacer works correctly.\n+ *\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+public class ReplaceMessagesTest extends TestCase {\n+\n+  private Map<String, JsMessage> messages;\n+  private Compiler compiler;\n+  private boolean strictReplacement;\n+\n+  @Override\n+  protected void setUp()  {\n+    messages = Maps.newHashMap();\n+    strictReplacement = false;\n+  }\n+\n+  public void testReplaceSimpleMessage() {\n+    registerMessage(new JsMessage.Builder(\"MSG_A\")\n+        .appendStringPart(\"Hi\\nthere\")\n+        .build());\n+\n+    assertOutputEquals(\"var MSG_A = goog.getMsg('asdf');\",\n+        \"var MSG_A=\\\"Hi\\\\nthere\\\"\");\n+  }\n+\n+  public void testNameReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_B\")\n+        .appendStringPart(\"One \")\n+        .appendPlaceholderReference(\"measly\")\n+        .appendStringPart(\" ph\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_B = goog.getMsg('asdf {$measly}', {measly: x});\",\n+        \"var MSG_B=\\\"One \\\"+(x+\\\" ph\\\")\");\n+  }\n+\n+  public void testGetPropReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_C\")\n+        .appendPlaceholderReference(\"amount\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_C = goog.getMsg('${$amount}', {amount: a.b.amount});\",\n+        \"var MSG_C=a.b.amount\");\n+  }\n+\n+  public void testFunctionCallReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_D\")\n+        .appendPlaceholderReference(\"amount\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_D = goog.getMsg('${$amount}', {amount: getAmt()});\",\n+        \"var MSG_D=getAmt()\");\n+  }\n+\n+  public void testMethodCallReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_E\")\n+        .appendPlaceholderReference(\"amount\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_E = goog.getMsg('${$amount}', {amount: obj.getAmt()});\",\n+        \"var MSG_E=obj.getAmt()\");\n+  }\n+\n+  public void testHookReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_F\")\n+        .appendStringPart(\"#\")\n+        .appendPlaceholderReference(\"amount\")\n+        .appendStringPart(\".\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_F = goog.getMsg('${$amount}', {amount: (a ? b : c)});\",\n+        \"var MSG_F=\\\"#\\\"+((a?b:c)+\\\".\\\")\");\n+  }\n+\n+  public void testAddReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_G\")\n+        .appendPlaceholderReference(\"amount\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_G = goog.getMsg('${$amount}', {amount: x + ''});\",\n+        \"var MSG_G=x+\\\"\\\"\");\n+  }\n+\n+  public void testPlaceholderValueReferencedTwice()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_H\")\n+        .appendPlaceholderReference(\"dick\")\n+        .appendStringPart(\", \")\n+        .appendPlaceholderReference(\"dick\")\n+        .appendStringPart(\" and \")\n+        .appendPlaceholderReference(\"jane\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_H = goog.getMsg('{$dick}{$jane}', {jane: x, dick: y});\",\n+        \"var MSG_H=y+(\\\", \\\"+(y+(\\\" and \\\"+x)))\");\n+  }\n+\n+  public void testPlaceholderNameInLowerCamelCase()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_I\")\n+        .appendStringPart(\"Sum: $\")\n+        .appendPlaceholderReference(\"amtEarned\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"var MSG_I = goog.getMsg('${$amtEarned}', {amtEarned: x});\",\n+        \"var MSG_I=\\\"Sum: $\\\"+x\");\n+  }\n+\n+  public void testQualifiedMessageName()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_J\")\n+        .appendStringPart(\"One \")\n+        .appendPlaceholderReference(\"measly\")\n+        .appendStringPart(\" ph\")\n+        .build());\n+\n+    assertOutputEquals(\n+        \"a.b.c.MSG_J = goog.getMsg('asdf {$measly}', {measly: x});\",\n+        \"a.b.c.MSG_J=\\\"One \\\"+(x+\\\" ph\\\")\");\n+  }\n+\n+  public void testSimpleMessageReplacementMissing()  {\n+    assertOutputEquals(\"var MSG_E = 'd*6a0@z>t';\", \"var MSG_E=\\\"d*6a0@z>t\\\"\");\n+  }\n+\n+  public void testStrictModeAndMessageReplacementAbsentInBundle()  {\n+    strictReplacement = true;\n+    process(\"var MSG_E = 'Hello';\");\n+    assertEquals(1, compiler.getErrors().length);\n+    assertEquals(BUNDLE_DOES_NOT_HAVE_THE_MESSAGE,\n+        compiler.getErrors()[0].getType());\n+  }\n+\n+  public void testStrictModeAndMessageReplacementAbsentInNonEmptyBundle()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_J\")\n+        .appendStringPart(\"One \")\n+        .appendPlaceholderReference(\"measly\")\n+        .appendStringPart(\" ph\")\n+        .build());\n+\n+    strictReplacement = true;\n+    process(\"var MSG_E = 'Hello';\");\n+    assertEquals(1, compiler.getErrors().length);\n+    assertEquals(BUNDLE_DOES_NOT_HAVE_THE_MESSAGE,\n+        compiler.getErrors()[0].getType());\n+  }\n+\n+  public void testFunctionReplacementMissing()  {\n+    assertOutputEquals(\"var MSG_F = function() {return 'asdf'};\",\n+        \"var MSG_F=function(){return\\\"asdf\\\"}\");\n+  }\n+\n+  public void testFunctionWithParamReplacementMissing()  {\n+    assertOutputEquals(\n+        \"var MSG_G = function(measly) {return 'asdf' + measly};\",\n+        \"var MSG_G=function(measly){return\\\"asdf\\\"+measly}\");\n+  }\n+\n+  public void testPlaceholderNameInLowerUnderscoreCase()  {\n+    process(\"var MSG_J = goog.getMsg('${$amt_earned}', {amt_earned: x});\");\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(MESSAGE_TREE_MALFORMED, error.getType());\n+  }\n+\n+  public void testBadPlaceholderReferenceInReplacement()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_K\")\n+        .appendPlaceholderReference(\"amount\")\n+        .build());\n+\n+    process(\"var MSG_K = goog.getMsg('Hi {$jane}', {jane: x});\");\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(MESSAGE_TREE_MALFORMED, error.getType());\n+  }\n+\n+\n+  public void testLegacyStyleNoPlaceholdersVarSyntax()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_A\")\n+        .appendStringPart(\"Hi\\nthere\")\n+        .build());\n+    assertOutputEquals(\"var MSG_A = 'd*6a0@z>t';\",\n+        \"var MSG_A=\\\"Hi\\\\nthere\\\"\");\n+  }\n+\n+  public void testLegacyStyleNoPlaceholdersFunctionSyntax()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_B\")\n+        .appendStringPart(\"Hi\\nthere\")\n+        .build());\n+\n+    assertOutputEquals(\"var MSG_B = function() {return 'asdf'};\",\n+        \"var MSG_B=function(){return\\\"Hi\\\\nthere\\\"}\");\n+  }\n+\n+  public void testLegacyStyleOnePlaceholder()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_C\")\n+        .appendStringPart(\"One \")\n+        .appendPlaceholderReference(\"measly\")\n+        .appendStringPart(\" ph\")\n+        .build());\n+    assertOutputEquals(\n+        \"var MSG_C = function(measly) {return 'asdf' + measly};\",\n+        \"var MSG_C=function(measly){return\\\"One \\\"+(measly+\\\" ph\\\")}\");\n+  }\n+\n+  public void testLegacyStyleTwoPlaceholders()  {\n+    registerMessage(new JsMessage.Builder(\"MSG_D\")\n+        .appendPlaceholderReference(\"dick\")\n+        .appendStringPart(\" and \")\n+        .appendPlaceholderReference(\"jane\")\n+        .build());\n+    assertOutputEquals(\n+        \"var MSG_D = function(jane, dick) {return jane + dick};\",\n+        \"var MSG_D=function(jane,dick){return dick+(\\\" and \\\"+jane)}\");\n+  }\n+\n+  public void testLegacyStylePlaceholderNameInLowerCamelCase() {\n+    registerMessage(new JsMessage.Builder(\"MSG_E\")\n+        .appendStringPart(\"Sum: $\")\n+        .appendPlaceholderReference(\"amtEarned\")\n+        .build());\n+    assertOutputEquals(\n+        \"var MSG_E = function(amtEarned) {return amtEarned + 'x'};\",\n+        \"var MSG_E=function(amtEarned){return\\\"Sum: $\\\"+amtEarned}\");\n+  }\n+\n+  public void testLegacyStylePlaceholderNameInLowerUnderscoreCase() {\n+    registerMessage(new JsMessage.Builder(\"MSG_F\")\n+        .appendStringPart(\"Sum: $\")\n+        .appendPlaceholderReference(\"amt_earned\")\n+        .build());\n+\n+    // Placeholder named in lower-underscore case (discouraged nowadays)\n+    assertOutputEquals(\n+        \"var MSG_F = function(amt_earned) {return amt_earned + 'x'};\",\n+        \"var MSG_F=function(amt_earned){return\\\"Sum: $\\\"+amt_earned}\");\n+  }\n+\n+  public void testLegacyStyleBadPlaceholderReferenceInReplacemen() {\n+    registerMessage(new JsMessage.Builder(\"MSG_B\")\n+        .appendStringPart(\"Ola, \")\n+        .appendPlaceholderReference(\"chimp\")\n+        .build());\n+\n+    process(\"var MSG_B = function(chump) {return chump + 'x'};\");\n+    assertEquals(1, compiler.getErrors().length);\n+    JSError error = compiler.getErrors()[0];\n+    assertEquals(\"Message parse tree malformed. \"\n+        + \"Unrecognized message placeholder referenced: chimp\",\n+        error.description);\n+  }\n+\n+  private void assertOutputEquals(String input, String output) {\n+    String output1 = process(input);\n+    JSError[] errors = compiler.getErrors();\n+    if (errors.length > 0) {\n+      fail(errors[0].description);\n+    }\n+\n+    assertEquals(output, output1);\n+  }\n+\n+\n+  private String process(String input) {\n+    compiler = new Compiler();\n+    Node root = compiler.parseTestCode(input);\n+    JsMessageVisitor visitor = new ReplaceMessages(compiler,\n+        new SimpleMessageBundle(), false, RELAX, strictReplacement);\n+    visitor.process(null, root);\n+\n+    return compiler.toSource(root);\n+  }\n+\n+\n+  private void registerMessage(JsMessage message) {\n+    messages.put(message.getKey(), message);\n+  }\n+\n+  private class SimpleMessageBundle implements MessageBundle {\n+\n+    @Override\n+    public JsMessage getMessage(String id) {\n+      return messages.get(id);\n+    }\n+\n+    @Override\n+    public Iterable<JsMessage> getAllMessages() {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public JsMessage.IdGenerator idGenerator() {\n+      return null;\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+      return Locale.getDefault();\n+    }\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java\n \n import junit.framework.TestCase;\n \n+import java.io.StringReader;\n import java.util.Collections;\n \n /**\n   }\n \n   private void assertStrip(String expected, String input) {\n-    parser.doParse(\"file\", input);\n+    parser.doParse(\"file\", new StringReader(input));\n     assertEquals(expected, parser.toString());\n   }\n \n       super(errorManager);\n     }\n \n-    void parseLine(String line) {\n+    boolean parseLine(String line) {\n       sb.append(line);\n+      return true;\n     }\n \n     public String toString() {\n--- a/test/com/google/javascript/jscomp/deps/JsFileParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFileParserTest.java\n   public void setUp() {\n     errorManager = new PrintStreamErrorManager(System.err);\n     parser = new JsFileParser(errorManager);\n+    parser.setShortcutMode(true);\n   }\n \n   /**\n     assertEquals(0, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n   }\n+\n+  public void testShortcutMode1() {\n+    // For efficiency reasons, we stop reading after the ctor.\n+    final String CONTENTS = \" // hi ! \\n /* this is a comment */ \"\n+        + \"goog.provide('yes1');\\n /* and another comment */ \\n\"\n+        + \"goog.provide('yes2'); // include this\\n\"\n+        + \"function foo() {}\\n\"\n+        + \"goog.provide('no1');\";\n+\n+    DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n+        ImmutableList.of(\"yes1\", \"yes2\"), Collections.<String>emptyList());\n+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testShortcutMode2() {\n+    final String CONTENTS = \"/** goog.provide('no1'); \\n\" +\n+        \" * goog.provide('no2');\\n */\\n\"\n+        + \"goog.provide('yes1');\\n\";\n+\n+    DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n+        ImmutableList.of(\"yes1\"), Collections.<String>emptyList());\n+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testShortcutMode3() {\n+    final String CONTENTS = \"/**\\n\" +\n+        \" * goog.provide('no1');\\n */\\n\"\n+        + \"goog.provide('yes1');\\n\";\n+\n+    DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n+        ImmutableList.of(\"yes1\"), Collections.<String>emptyList());\n+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);\n+\n+    assertEquals(EXPECTED, result);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n }", "timestamp": 1274397781, "metainfo": ""}