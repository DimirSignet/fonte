{"sha": "5061aa1ed7924826ae3049b20f9dfd388c0155e7", "log": "Cloned from original change by dhans@dhans-jscomp on 2010/09/17 19:26:33.  Build changes to create open source secure_compiler library.  R=dhans,johnlenz DELTA=122  (105 added, 11 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=238964   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/ErrorLevel.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+/**\n+ * Represents possible error levels for JsonML errors.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public enum ErrorLevel {\n+  COMPILATION_ERROR,\n+  COMPILATION_WARNING,\n+  SYNTAX_ERROR,\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonML.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import java.io.IOException;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+/**\n+ * Class which represents JsonML element according to the specification at\n+ * \"http://code.google.com/p/es-lab/wiki/JsonMLASTFormat\"\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class JsonML {\n+  private final TagType type;\n+  private Map<TagAttr, Object> attributes =\n+      new EnumMap<TagAttr, Object>(TagAttr.class);\n+  private List<JsonML> children = new ArrayList<JsonML>();\n+\n+  /**\n+   * Creates a new element with a given type.\n+   * @param type\n+   */\n+  public JsonML(TagType type) {\n+    this.type = type;\n+  }\n+\n+  /**\n+   * Creates a new element.\n+   * @param type type of the element\n+   * @param children children to append to the element\n+   */\n+  public JsonML(TagType type, JsonML... children) {\n+    this(type, Arrays.asList(children));\n+  }\n+\n+  public JsonML(TagType type, List<? extends JsonML> children) {\n+    this(type, Collections.<TagAttr, Object>emptyMap(), children);\n+  }\n+\n+  public JsonML(TagType type, Map<? extends TagAttr, ?> attributes) {\n+    this(type, attributes, Collections.<JsonML>emptyList());\n+  }\n+\n+  public JsonML(TagType type, Map<? extends TagAttr, ?> attributes,\n+      List<? extends JsonML> children) {\n+    this.type = type;\n+    this.attributes.putAll(attributes);\n+    appendChildren(children);\n+  }\n+\n+  /**\n+   * Inserts the given JsonML element at the given position in the\n+   * list of children.\n+   * @param index index at which the given element is to be inserted\n+   * @param element JsonML element to be inserted\n+   */\n+  public void addChild(int index, JsonML element) {\n+    children.add(index, element);\n+  }\n+\n+  /**\n+   * Appends a given child element to the list of children.\n+   * @param element JsonML element to append\n+   */\n+  public void appendChild(JsonML element) {\n+    children.add(element);\n+  }\n+\n+  /**\n+   * Appends a collection of children to the back of the list of children.\n+   * @param elements collection of JsonML elements to append\n+   */\n+  public void appendChildren(Collection<? extends JsonML> elements) {\n+    children.addAll(elements);\n+  }\n+\n+  /**\n+   * Returns number of the children.\n+   */\n+  public int childrenSize() {\n+    return children.size();\n+  }\n+\n+  /**\n+   * Removes all elements from the list of children.\n+   */\n+  public void clearChildren() {\n+    setChildren();\n+  }\n+\n+  /**\n+   * Returns value associated with a given attribute.\n+   * @param name name of the attribute\n+   * @return associated value or null if the attribute is not present\n+   */\n+  public Object getAttribute(TagAttr name) {\n+    return attributes.get(name);\n+  }\n+\n+  /**\n+   * Returns a map with attributes and respective values.\n+   */\n+  public Map<TagAttr, Object> getAttributes() {\n+    return attributes;\n+  }\n+\n+  /**\n+   * Returns child at a given position.\n+   */\n+  public JsonML getChild(int index) {\n+    return children.get(index);\n+  }\n+\n+  /**\n+   * Returns a list of all children.\n+   */\n+  public List<JsonML> getChildren() {\n+    return children;\n+  }\n+\n+  /**\n+   * Returns the portion of children list between the specified\n+   * fromIndex, inclusive, and toIndex, exclusive.\n+   * @param fromIndex low endpoint (inclusive)\n+   * @param toIndex high endpoint (exclusive)\n+   */\n+  public List<JsonML> getChildren(int fromIndex, int toIndex) {\n+    return children.subList(fromIndex, toIndex);\n+  }\n+\n+  /**\n+   * Returns type of the JsonML element.\n+   */\n+  public TagType getType() {\n+    return type;\n+  }\n+\n+  /**\n+   * Returns true if the JsonML element has at least one child.\n+   */\n+  public boolean hasChildren() {\n+    return !children.isEmpty();\n+  }\n+\n+  /**\n+   * Sets value for a given attribute.\n+   * @param name name of the attribute\n+   * @param value value to associate with the attribute\n+   */\n+  public void setAttribute(TagAttr name, Object value) {\n+    attributes.put(name, value);\n+  }\n+\n+  /**\n+   * Sets attributes of the JsonML element.\n+   * @param attributes map with attributes and their values\n+   */\n+  public void setAttributes(Map<TagAttr, Object> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  /**\n+   * Replaces the element at the given position in the list of children wit\n+   * the given JsonML element.\n+   * @param index index of element to replace\n+   * @param element JsonML element to append\n+   */\n+  public void setChild(int index, JsonML element) {\n+    children.set(index, element);\n+  }\n+\n+  /**\n+   * Replaces all elements in the list of children with the given\n+   * JsonML elements.\n+   * @param children a comma separated list of JsonML elements\n+   */\n+  public void setChildren(JsonML... children) {\n+    this.children.clear();\n+    for (JsonML child : children) {\n+      this.children.add(child);\n+    }\n+  }\n+\n+  /**\n+   * Replaces all elements in the list of children with the given\n+   * list of JsonML elements..\n+   * @param children a list of JsonML elements.\n+   */\n+  public void setChildren(List<JsonML> children) {\n+    this.children = children;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    toString(sb, true, true);\n+    return sb.toString();\n+  }\n+\n+  private void toString(StringBuilder sb, boolean printAttributes,\n+      boolean printChildren) {\n+    sb.append(\"[\\\"\");\n+    escapeStringOnto(type.name(), sb);\n+    sb.append('\"');\n+\n+    if (printAttributes) {\n+      sb.append(\", {\");\n+      boolean first = true;\n+      for (Entry<TagAttr, Object> entry : attributes.entrySet()) {\n+        if (first) {\n+          first = false;\n+        } else {\n+          sb.append(\", \");\n+        }\n+        sb.append('\"');\n+        escapeStringOnto(entry.getKey().toString(), sb);\n+        sb.append(\"\\\": \");\n+        Object value = entry.getValue();\n+        if (value == null) {\n+          sb.append(\"null\");\n+        } else if (value instanceof String) {\n+          sb.append('\"');\n+          escapeStringOnto((String) value, sb);\n+          sb.append('\"');\n+        } else {\n+          sb.append(value);\n+        }\n+      }\n+      sb.append(\"}\");\n+    }\n+\n+    if (printChildren) {\n+      for (JsonML child : children) {\n+        sb.append(\", \");\n+        sb.append(child.toString());\n+      }\n+    }\n+    sb.append(']');\n+  }\n+\n+\n+  /**\n+   * Encodes the specified string and appends it to the given StringBuilder.\n+   */\n+  private static void escapeStringOnto(String s, StringBuilder sb) {\n+    int pos = 0, n = s.length();\n+    for (int i = 0; i < n; ++i) {\n+      char ch = s.charAt(i);\n+      switch (ch) {\n+        case '\\r': case '\\n': case '\"': case '\\\\':\n+        // these two characters are the exceptions to the general rule\n+        // that JSON is a syntactic subset of JavaScript\n+        // From JSON's perspective they are considered to be whitespaces,\n+        // while ES5 specifies them as line terminators.\n+        case '\\u2028': case '\\u2029':\n+          String hex = Integer.toString(ch, 16);\n+          sb.append(s, pos, i)\n+              .append(\"\\\\u\").append(\"0000\", hex.length(), 4).append(hex);\n+          pos = i + 1;\n+          break;\n+      }\n+    }\n+    sb.append(s, pos, n);\n+  }\n+\n+  /**\n+   * Prints a JsonML tree in a human readable format.\n+   */\n+  public String toStringTree() {\n+    try {\n+      StringBuilder s = new StringBuilder();\n+      toStringTreeHelper(this, 0, s);\n+      return s.toString();\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Should not happen\\n\" + e);\n+    }\n+  }\n+\n+  private static void toStringTreeHelper(JsonML element, int level,\n+      StringBuilder sb) throws IOException {\n+    for (int i = 0; i < level; ++i) {\n+      sb.append(\"    \");\n+    }\n+    element.toString(sb, true, false);\n+    sb.append(\"\\n\");\n+    for (JsonML child : element.getChildren()) {\n+      toStringTreeHelper(child, level + 1, sb);\n+    }\n+  }\n+}\n+\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.SourceAst;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+/**\n+ * Generates an AST from a JsonML source file.\n+ *\n+ * JsonML format for representation of JavaScript is specified\n+ * <a href=\"http://code.google.com/p/es-lab/wiki/JsonMLASTFormat\">here.</a>\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ *\n+ */\n+public class JsonMLAst implements SourceAst {\n+  private static final long serialVersionUID = 1L;\n+  private static final String DEFAULT_SOURCE_NAME = \"[[jsonmlsource]]\";\n+\n+  /*\n+   * Root element of JavaScript source which is represented by a JsonML tree.\n+   * See JsonML class for more details.\n+   */\n+  private JsonML jsonml;\n+\n+  /*\n+   * Root node of internal JS Compiler AST which represents the same source.\n+   * In order to get the tree, getAstRoot() has to be called.\n+   */\n+  private Node root;\n+\n+  public JsonMLAst(JsonML jsonml) {\n+    this.jsonml = jsonml;\n+  }\n+\n+  @Override\n+  public void clearAst() {\n+    root = null;\n+  }\n+\n+  /**\n+   * Generates AST based on AST representation\n+   * @see com.google.javascript.jscomp.SourceAst#getAstRoot(AbstractCompiler)\n+   */\n+  @Override\n+  public Node getAstRoot(AbstractCompiler compiler) {\n+    if (root == null) {\n+      createAst(compiler);\n+    }\n+    return root;\n+  }\n+\n+  @Override\n+  public SourceFile getSourceFile() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void setSourceFile(SourceFile file) {\n+    throw new UnsupportedOperationException(\n+        \"JsonMLAst cannot be associated with a SourceFile instance.\");\n+  }\n+\n+  public String getSourceName() {\n+    Object obj = jsonml.getAttribute(TagAttr.SOURCE);\n+    if (obj instanceof String) {\n+      return (String) obj;\n+    } else {\n+      return DEFAULT_SOURCE_NAME;\n+    }\n+  }\n+\n+  private void createAst(AbstractCompiler compiler) {\n+    Reader translator = new Reader();\n+    translator.setRootElement(jsonml);\n+    try {\n+      root = translator.parse(compiler);\n+    } catch (JsonMLException e) {\n+      // compiler should already have JSErrors\n+    }\n+  }\n+\n+  public JsonML convertToJsonML () {\n+    if (root != null) {\n+      Writer converter = new Writer();\n+      return converter.processAst(root);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns a JsonML element with the specified number from the tree in\n+   * pre-order walk.\n+   *\n+   * @return n-th node or null if the node does not exists\n+   */\n+  public JsonML getElementPreOrder(int n) {\n+    Preconditions.checkState(jsonml != null);\n+\n+    if (n == 0) {\n+      return jsonml;\n+    }\n+\n+    Deque<WalkHelper> stack =\n+        new ArrayDeque<WalkHelper>();\n+    stack.push(new WalkHelper(jsonml, 0));\n+    int i = 0;\n+    while (i <= n && !stack.isEmpty()) {\n+      WalkHelper current = stack.pop();\n+      JsonML element = current.element;\n+      Integer childno = current.childno;\n+\n+      // not all the children of this node have been visited\n+      if (childno < element.childrenSize()) {\n+        stack.push(new WalkHelper(element, childno + 1));\n+        // we visit the next child\n+        i++;\n+        element = element.getChild(childno);\n+\n+        if (i == n) {\n+          return element;\n+        }\n+\n+        // put the next child on the stack to preserve pre-order\n+        stack.push(new WalkHelper(element, 0));\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /*\n+   * Represents a walk step while the JsonML tree is traversed.\n+   */\n+  private static class WalkHelper {\n+    // JsonML element that corresponds to this step\n+    final JsonML element;\n+\n+    // number of children of the element which has already been visited\n+    final int childno;\n+\n+    WalkHelper(JsonML element, int childno) {\n+      this.element = element;\n+      this.childno = childno;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLError.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.JSError;\n+\n+/**\n+ * Class used to represent errors which correspond to JsonML elements.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class JsonMLError {\n+\n+  /**  */\n+  private final DiagnosticType type;\n+\n+  /** Description of the error */\n+  public final String description;\n+\n+  /** Name of the source */\n+  public final String sourceName;\n+\n+  /** Node where the warning occurred. */\n+  public final JsonML element;\n+\n+  /** Line number of the source */\n+  public final int lineNumber;\n+\n+  /** Level */\n+  public final ErrorLevel level;\n+\n+  private JsonMLError(DiagnosticType type, String sourceName, JsonML element,\n+      int lineNumber, ErrorLevel level, String... arguments) {\n+    this.type = type;\n+    this.description = type.format.format(arguments);\n+    this.sourceName = sourceName;\n+    this.element = element;\n+    this.lineNumber = lineNumber;\n+    this.level = level;\n+  }\n+\n+  private JsonMLError(String description, DiagnosticType type,\n+      String sourceName, JsonML element, int lineNumber, ErrorLevel level) {\n+    this.type = type;\n+    this.description = description;\n+    this.sourceName = sourceName;\n+    this.element = element;\n+    this.lineNumber = lineNumber;\n+    this.level = level;\n+  }\n+\n+  public static JsonMLError make(DiagnosticType type, String sourceName,\n+      JsonML element, int lineNumber, ErrorLevel level, String... arguments) {\n+    return new JsonMLError(type, sourceName, element, lineNumber, level,\n+        arguments);\n+  }\n+\n+  public static JsonMLError make(JSError error, JsonMLAst ast) {\n+    // try to find the corresponding JsonML element\n+    // it is stored as line number of the JSError\n+    int n = error.lineNumber;\n+    JsonML element = ast.getElementPreOrder(n);\n+\n+    ErrorLevel level = error.level == CheckLevel.ERROR\n+        ? ErrorLevel.COMPILATION_ERROR\n+        : ErrorLevel.COMPILATION_WARNING;\n+\n+    return new JsonMLError(error.getType(), error.sourceName, element, 0,\n+        level, error.description);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLException.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+/**\n+ * Class used to report internal exceptions which concern JsonML.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ *\n+ */\n+class JsonMLException extends Exception {\n+  private static final long serialVersionUID = 1L;\n+\n+  JsonMLException() {}\n+\n+  JsonMLException(String message) {\n+    super(message);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLUtil.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import org.json.JSONArray;\n+import org.json.JSONObject;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * JsonMLUtil contains utilities for the JsonML object.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class JsonMLUtil {\n+\n+  /**\n+   * Checks if the specified JsonML element represents an expression.\n+   */\n+  public static boolean isExpression(JsonML element) {\n+    switch (element.getType()) {\n+      case ArrayExpr:\n+      case AssignExpr:\n+      case BinaryExpr:\n+      case CallExpr:\n+      case ConditionalExpr:\n+      case CountExpr:\n+      case DeleteExpr:\n+      case EvalExpr:\n+      case FunctionExpr:\n+      case IdExpr:\n+      case InvokeExpr:\n+      case LiteralExpr:\n+      case LogicalAndExpr:\n+      case LogicalOrExpr:\n+      case MemberExpr:\n+      case NewExpr:\n+      case ObjectExpr:\n+      case RegExpExpr:\n+      case ThisExpr:\n+      case TypeofExpr:\n+      case UnaryExpr:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Parses JSON string which contains serialized JsonML content.\n+   * @param jsonml string representation of JsonML\n+   * @return root element of a JsonML tree\n+   */\n+  public static JsonML parseString(String jsonml) throws Exception {\n+    return parseElement(new JSONArray(jsonml));\n+  }\n+\n+  private static JsonML parseElement(JSONArray element)\n+      throws Exception {\n+    JsonML jsonMLElement = new JsonML(TagType.valueOf(element.getString(0)));\n+\n+    // set attributes for the JsonML element\n+    JSONObject attrs = element.getJSONObject(1);\n+    Iterator<?> it = attrs.keys();\n+    while (it.hasNext()) {\n+      String key = (String) it.next();\n+      Object value = attrs.get(key);\n+      TagAttr tag = TagAttr.get(key);\n+\n+      // an unsupported attribute\n+      if (tag == null) {\n+        continue;\n+      }\n+\n+      if (value instanceof Number) {\n+        value = ((Number) value).doubleValue();\n+      }\n+\n+      switch (tag) {\n+        case NAME:\n+        case BODY:\n+        case FLAGS:\n+        case OP:\n+        case TYPE:\n+        case IS_PREFIX:\n+        case LABEL:\n+          jsonMLElement.setAttribute(tag, value);\n+          break;\n+        case VALUE:\n+          // we do not want to deal with JSONObject.NULL\n+          if (value != null && value.equals(null)) {\n+            value = null;\n+          }\n+\n+          // we want all numbers to be stored as double values\n+          if (value instanceof Number) {\n+            jsonMLElement.setAttribute(tag, ((Number) value).doubleValue());\n+          } else {\n+            jsonMLElement.setAttribute(tag, value);\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+\n+    // recursively set children for the JsonML element\n+    for (int i = 2; i < element.length(); ++i) {\n+      jsonMLElement.appendChild(parseElement(element.getJSONArray(i)));\n+    }\n+\n+    return jsonMLElement;\n+  }\n+\n+  /**\n+   * Compares two specified JsonML trees.\n+   *\n+   * Two JsonML nodes are considered to be equal when the following conditions\n+   * are met:\n+   *\n+   * - have the same type\n+   * - have the same attributes from the list of attributes to compare\n+   * - have the same number of children\n+   * - nodes in each pair of corresponding children are equal\n+   *\n+   * Two JsonML trees are equal, if their roots are equal.\n+   *\n+   * When two nodes are compared, only the following attributes are taken\n+   * into account:\n+   * TagAttr.BODY, TagAttr.FLAGS, TagAttr.IS_PREFIX, TagAttr.LABEL,\n+   * TagAttr.NAME, TagAttr.OP, TagAttr.TYPE, TagAttr.VALUE\n+   * Generally, the comparator does not care about debugging attributes.\n+   *\n+   * @return\n+   * Returns string describing the inequality in the following format:\n+   *\n+   * The trees are not equal:\n+   *\n+   * Tree1:\n+   * -- string representation of Tree1\n+   *\n+   * Tree2:\n+   * -- string representation of Tree2\n+   *\n+   * Subtree1:\n+   * -- string representation of the subtree of the Tree1 which is not\n+   * -- equal to the corresponding subtree of the Tree2\n+   *\n+   * Subtree2:\n+   * -- see Subtree1\n+   *\n+   * If the trees are equal, null is returned.\n+   */\n+  public static String compare(JsonML tree1, JsonML tree2) {\n+    return (new JsonMLComparator(tree1, tree2)).compare();\n+  }\n+\n+  /**\n+   * Returns true if the trees are equal, false otherwise.\n+   */\n+  static boolean compareSilent(JsonML tree1, JsonML tree2) {\n+    return (new JsonMLComparator(tree1, tree2)).compareSilent();\n+  }\n+\n+  /**\n+   * Helper class which actually compares two given JsonML trees.\n+   *\n+   */\n+  private static class JsonMLComparator {\n+    private static final TagAttr[] ATTRS_TO_COMPARE = {\n+      TagAttr.BODY, TagAttr.FLAGS, TagAttr.IS_PREFIX, TagAttr.LABEL,\n+      TagAttr.NAME, TagAttr.OP, TagAttr.TYPE, TagAttr.VALUE\n+    };\n+    private JsonML treeA;\n+    private JsonML treeB;\n+    private JsonML mismatchA;\n+    private JsonML mismatchB;\n+\n+    JsonMLComparator(JsonML treeA, JsonML treeB) {\n+      this.treeA = treeA;\n+      this.treeB = treeB;\n+      if (compareElements(treeA, treeB)) {\n+        mismatchA = null;\n+        mismatchB = null;\n+      }\n+    }\n+\n+    private boolean setMismatch(JsonML a, JsonML b) {\n+      mismatchA = a;\n+      mismatchB = b;\n+      return false;\n+    }\n+\n+    /**\n+     * Check if two elements are equal (including comparing their children).\n+     */\n+    private boolean compareElements(JsonML a, JsonML b) {\n+      // the elements are considered to be equal if they are both null\n+      if (a == null || b == null) {\n+        if (a == null && b == null) {\n+          return true;\n+        } else {\n+          return setMismatch(a, b);\n+        }\n+      }\n+\n+      // the elements themselves have to be equivalent\n+      if (!areEquivalent(a, b)) {\n+        return setMismatch(a, b);\n+      }\n+\n+      // they both have to have the same number of children\n+      if (a.childrenSize() != b.childrenSize()) {\n+        return setMismatch(a, b);\n+      }\n+\n+      // all the children has to be the same\n+      Iterator<JsonML> itA = a.getChildren().listIterator();\n+      Iterator<JsonML> itB = b.getChildren().listIterator();\n+      while (itA.hasNext()) {\n+        if (!compareElements(itA.next(), itB.next())) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * Checks if two elements are semantically the same.\n+     */\n+    private boolean areEquivalent(JsonML a, JsonML b) {\n+      // both elements must have the same type\n+      if (a.getType() != b.getType()) {\n+        return false;\n+      }\n+\n+      for (TagAttr attr : ATTRS_TO_COMPARE) {\n+        if (!compareAttribute(attr, a, b)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n+    private boolean compareAttribute(TagAttr attr, JsonML a, JsonML b) {\n+      Object valueA = a.getAttributes().get(attr);\n+      Object valueB = b.getAttributes().get(attr);\n+\n+      // none of the elements have the attribute\n+      if (valueA == null && valueB == null) {\n+        return true;\n+      }\n+\n+      // only one of the elements has the attribute\n+      if (valueA == null || valueB == null) {\n+        return false;\n+      }\n+\n+      // check if corresponding values are equal\n+      if (!(valueA.equals(valueB))) {\n+        // there is still a chance that both attributes are numbers, but are\n+        // represented by different classes\n+\n+        Double doubleA = null, doubleB = null;\n+\n+        if (valueA instanceof Number) {\n+          doubleA = ((Number) valueA).doubleValue();\n+        } else if (valueA instanceof String) {\n+          doubleA = Double.valueOf((String) valueA);\n+        } else {\n+          return false;\n+        }\n+\n+        if (valueB instanceof Number) {\n+          doubleB = ((Number) valueB).doubleValue();\n+        } else if (valueB instanceof String) {\n+          doubleB = Double.valueOf((String) valueB);\n+        } else {\n+          return false;\n+        }\n+\n+        if (!doubleA.equals(doubleB)) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    private boolean compareSilent() {\n+      return mismatchA == null && mismatchB == null;\n+    }\n+\n+    private String compare() {\n+      if (compareSilent()) {\n+        return null;\n+      }\n+      return \"The trees are not equal: \" +\n+          \"\\n\\nTree1:\\n \" + treeA.toStringTree() +\n+          \"\\n\\nTree2:\\n \" + treeB.toStringTree() +\n+          \"\\n\\nSubtree1:\\n \" + mismatchA.toStringTree() +\n+          \"\\n\\nSubtree2:\\n \" + mismatchB.toStringTree();\n+\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/NodeUtil.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Non public methods copied from com.google.javascript.jscomp.NodeUtil class.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+class NodeUtil {\n+\n+  /**\n+   * @return Whether the node represents a FOR-IN loop.\n+   */\n+  static boolean isForIn(Node n) {\n+    return n.getType() == Token.FOR\n+        && n.getChildCount() == 3;\n+  }\n+\n+  /**\n+   * @return Whether the node is used as a statement.\n+   */\n+  static boolean isStatement(Node n) {\n+    Node parent = n.getParent();\n+    // It is not possible to determine definitely if a node is a statement\n+    // or not if it is not part of the AST.  A FUNCTION node can be\n+    // either part of an expression or a statement.\n+    Preconditions.checkState(parent != null);\n+    switch (parent.getType()) {\n+      case Token.SCRIPT:\n+      case Token.BLOCK:\n+      case Token.LABEL:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Is this node a function declaration? A function declaration is a function\n+   * that has a name that is added to the current scope (i.e. a function that\n+   * is not part of a expression; see {@link #isFunctionExpression}).\n+   */\n+  static boolean isFunctionDeclaration(Node n) {\n+    return n.getType() == Token.FUNCTION && isStatement(n);\n+  }\n+\n+  /**\n+   * Is this node a hoisted function declaration? A function declaration in the\n+   * scope root is hoisted to the top of the scope.\n+   * See {@link #isFunctionDeclaration}).\n+   */\n+  static boolean isHoistedFunctionDeclaration(Node n) {\n+    return isFunctionDeclaration(n)\n+        && (n.getParent().getType() == Token.SCRIPT\n+            || n.getParent().getParent().getType() == Token.FUNCTION);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Traverse JsonML source tree and generates AST.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class Reader {\n+\n+  static final DiagnosticType JSONML_SYNTAX = DiagnosticType.error(\n+      \"JSONML_SYNTAX\", \"Syntax error: {0}\");\n+\n+  /** Root element of JsonML tree which contains JavaScript source. */\n+  private JsonML rootElement;\n+\n+  /** Name of JavaScript source file */\n+  private String sourceName;\n+\n+  /** Error reporter */\n+  private ErrorReporter errorReporter;\n+\n+  /** List of ES5 directives supported by JsonML */\n+  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n+\n+  /** Number of node in JsonML order which is currently processed */\n+  private int nodeIndex;\n+\n+  /**\n+   * Inner class which is responsible for passing reader errors\n+   * to the JS compiler.\n+   */\n+  private class ErrorReporter {\n+    private AbstractCompiler compiler;\n+\n+    ErrorReporter(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    private void report(JsonML element, String...arguments)\n+        throws JsonMLException {\n+      report(JSONML_SYNTAX, element, arguments);\n+    }\n+\n+    private void report(DiagnosticType type, JsonML element,\n+        String... arguments) throws JsonMLException {\n+      // nodeIndex is the number of the node in which the error occurred\n+      // we will store it in line number\n+      int lineno = nodeIndex;\n+      int charno = -1;\n+\n+      report(JSError.make(sourceName, lineno, charno, type, arguments));\n+    }\n+\n+    private void report(DiagnosticType type, String... arguments)\n+        throws JsonMLException {\n+      report(JSError.make(type, arguments));\n+    }\n+\n+    /**\n+     * Reports a new parser error to the compiler and terminates the job.\n+     * @param error JSError instance to be passed to the compiler\n+     */\n+    private void report(JSError error) throws JsonMLException {\n+      report(error, true);\n+    }\n+\n+    /**\n+     * Reports a new parser error to the compiler and terminates the job\n+     * if the error is fatal.\n+     * @param error JSError instance to be passed to the compiler\n+     * @param terminal if true, parsing is terminated by throwing exception\n+     */\n+    private void report(JSError error, boolean terminal)\n+        throws JsonMLException {\n+      compiler.report(error);\n+      if (terminal) {\n+        throw new JsonMLException();\n+      }\n+    }\n+  }\n+\n+  // TODO(dhans): Maybe this state can be replaced with a simpler check\n+  /**\n+   * Stores state if EXPR_RESULT node should be inserted. The reason why\n+   * we have to keep track on that is JsonML representation does not have this\n+   * information.\n+   */\n+  private boolean insertExprResultState = true;\n+\n+  public void setRootElement(JsonML rootElement) {\n+    this.rootElement = rootElement;\n+  }\n+\n+  /**\n+   * Generates AST for a specified JsonML source file.\n+   * @return root node of the generated AST\n+   * @throws JsonMLException if an error occurs\n+   */\n+  public Node parse(AbstractCompiler compiler) throws JsonMLException {\n+    if (compiler == null) {\n+      // TODO(dhans): Review error handling\n+      // maybe throw an exception that compiler is required for errors.\n+      return null;\n+    }\n+\n+    errorReporter = this.new ErrorReporter(compiler);\n+    Node root = new Node(Token.BLOCK);\n+    nodeIndex = -1;\n+\n+    transformElement(rootElement, root);\n+    return root;\n+  }\n+\n+  /**\n+   * Retrieves value of an attribute, but does not throw an exception if\n+   * the attribute is not present for a specified JsonML element.\n+   * @param type desired type of the attribute\n+   * @return value of the attribute or null if it is not specified\n+   * @throws JsonMLException i.e. when the value has a wrong type\n+   */\n+  private <T> T getOptionalAttribute(JsonML element, TagAttr attr,\n+      Class<T> type) throws JsonMLException {\n+    return getAttribute(element, attr, type, true);\n+  }\n+\n+  /**\n+   * Retrieves value of an attribute and throws an exception if\n+   * the attribute is not present for a specified JsonML element.\n+   * @param type desired type of the attribute\n+   * @return value of the attribute\n+   * @throws JsonMLException i.e. when the attribute does not exist\n+   */\n+  private <T> T getAttribute(JsonML element, TagAttr attr, Class<T> type)\n+      throws JsonMLException {\n+    return getAttribute(element, attr, type, false);\n+  }\n+\n+  private <T> T getAttribute(JsonML element, TagAttr attr, Class<T> type,\n+      boolean optional) throws JsonMLException {\n+    Object value = element.getAttribute(attr);\n+\n+    if (value == null) {\n+      if (type == null || optional) {\n+        return null;\n+      }\n+\n+      throw new JsonMLException(\n+          \"Missing \" + attr.name() + \" attribute for \"\n+          + element.getType().name() + \" element.\");\n+    }\n+\n+    // Double type is a special case, as it might be represented by all\n+    // Number types or even by certain strings which contain only digit chars\n+    if (type.equals(Double.class)) {\n+      if (value instanceof Number) {\n+        return type.cast(((Number) value).doubleValue());\n+      }\n+      if (value instanceof String) {\n+        return type.cast(Double.valueOf((String) value));\n+      }\n+\n+      throw new JsonMLException(\n+          \"Wrong type of \" + attr.name() + \" attribute. \"\n+          + \"Received: \" + value.getClass() + \". Expected: \" + type.getName());\n+    }\n+\n+    if (type.isInstance(value)) {\n+      return type.cast(value);\n+    }\n+\n+    throw new JsonMLException(\n+        \"Wrong type of \" + attr.name() + \"attribute. \"\n+        + \"Received: \" + value.getClass() + \". Expected: \" + type.getName());\n+  }\n+\n+  /**\n+   * Retrieves an attribute whose type should be Object.\n+   */\n+  private Object getObjectAttribute(JsonML element, TagAttr attr)\n+      throws JsonMLException {\n+    return getAttribute(element, attr, Object.class);\n+  }\n+\n+  /**\n+   * Retrieves an attribute whose type should be String.\n+   */\n+  private String getStringAttribute(JsonML element, TagAttr attr)\n+      throws JsonMLException {\n+    return getAttribute(element, attr, String.class);\n+  }\n+\n+  private void validate(JsonML element) throws JsonMLException {\n+    String errorMessage = Validator.validate(element);\n+    if (errorMessage != null) {\n+      errorReporter.report(element, errorMessage);\n+    }\n+  }\n+\n+  /**\n+   * Recursively transforms JsonML tree into AST.\n+   *\n+   * @param element JsonML element to transform\n+   * @param parent current parent AST node, i.e. when the element is\n+   * transformed\n+   * to a new AST node, it should be added as a last child to the parent Node.\n+   */\n+  private void transformElement(JsonML element, Node parent)\n+      throws JsonMLException {\n+    // next element is transformed\n+    nodeIndex++;\n+\n+    // the element has to be validated\n+    validate(element);\n+\n+    // determine if EXPR_RESULT should be inserted\n+    if (insertExprResultState && JsonMLUtil.isExpression(element)) {\n+      transformExpr(element, parent);\n+      return;\n+    }\n+\n+    switch (element.getType()) {\n+      case ArrayExpr:\n+        transformArrayExpr(element, parent);\n+        break;\n+      case AssignExpr:\n+        transformAssignExpr(element, parent);\n+        break;\n+      case BinaryExpr:\n+        transformBinaryExpr(element, parent);\n+        break;\n+      case BlockStmt:\n+        transformBlock(element, parent);\n+        break;\n+      case BreakStmt:\n+        transformBreakStmt(element, parent);\n+        break;\n+      case CallExpr:\n+        transformCallExpr(element, parent);\n+        break;\n+      case Case:\n+        transformCase(element, parent);\n+        break;\n+      case CatchClause:\n+        transformCatchClause(element, parent);\n+        break;\n+      case ConditionalExpr:\n+        transformConditionalExpr(element, parent);\n+        break;\n+      case ContinueStmt:\n+        transformContinueStmt(element, parent);\n+        break;\n+      case CountExpr:\n+        transformCountExpr(element, parent);\n+        break;\n+      case DataProp:\n+        transformDataProp(element, parent);\n+        break;\n+      case DefaultCase:\n+        transformDefaultCase(element, parent);\n+        break;\n+      case DeleteExpr:\n+        transformDeleteExpr(element, parent);\n+        break;\n+      case DoWhileStmt:\n+        transformDoWhileStmt(element, parent);\n+        break;\n+      case Empty:\n+        transformEmpty(element, parent);\n+        break;\n+      case EmptyStmt:\n+        transformEmptyStmt(element, parent);\n+        break;\n+      case EvalExpr:\n+        transformEvalExpr(element, parent);\n+        break;\n+      case ForInStmt:\n+        transformForInStmt(element, parent);\n+        break;\n+      case ForStmt:\n+        transformForStmt(element, parent);\n+        break;\n+      case FunctionDecl:\n+        transformFunctionDecl(element, parent);\n+        break;\n+      case FunctionExpr:\n+        transformFunctionExpr(element, parent);\n+        break;\n+      case IdExpr:\n+        transformIdExpr(element, parent);\n+        break;\n+      case IdPatt:\n+        transformIdPatt(element, parent);\n+        break;\n+      case IfStmt:\n+        transformIfStmt(element, parent);\n+        break;\n+      case InitPatt:\n+        transformInitPatt(element, parent);\n+        break;\n+      case InvokeExpr:\n+        transformInvokeExpr(element, parent);\n+        break;\n+      case LabelledStmt:\n+        transformLabelledStmt(element, parent);\n+        break;\n+      case LiteralExpr:\n+        transformLiteralExpr(element, parent);\n+        break;\n+      case LogicalAndExpr:\n+        transformLogicalAndExpr(element, parent);\n+        break;\n+      case LogicalOrExpr:\n+        transformLogicalOrExpr(element, parent);\n+        break;\n+      case MemberExpr:\n+        transformMemberExpr(element, parent);\n+        break;\n+      case NewExpr:\n+        transformNewExpr(element, parent);\n+        break;\n+      case ObjectExpr:\n+        transformObjectExpr(element, parent);\n+        break;\n+      case ParamDecl:\n+        transformParamDecl(element, parent);\n+        break;\n+      case Program:\n+        transformProgram(element, parent);\n+        break;\n+      case PrologueDecl:\n+        transformPrologueDecl(element, parent);\n+        break;\n+      case RegExpExpr:\n+        transformRegExpExpr(element, parent);\n+        break;\n+      case ReturnStmt:\n+        transformReturnStmt(element, parent);\n+        break;\n+      case SwitchStmt:\n+        transformSwitchStmt(element, parent);\n+        break;\n+      case ThisExpr:\n+        transformThisExpr(element, parent);\n+        break;\n+      case ThrowStmt:\n+        transformThrowStmt(element, parent);\n+        break;\n+      case TryStmt:\n+        transformTryStmt(element, parent);\n+        break;\n+      case TypeofExpr:\n+        transformTypeofExpr(element, parent);\n+        break;\n+      case UnaryExpr:\n+        transformUnaryExpr(element, parent);\n+        break;\n+      case VarDecl:\n+        transformVarDecl(element, parent);\n+        break;\n+      case WhileStmt:\n+        transformWhileStmt(element, parent);\n+        break;\n+      case WithStmt:\n+        transformWithStmt(element, parent);\n+        break;\n+    }\n+  }\n+\n+  /*\n+   * Helper functions.\n+   * Usually called by functions which process particular JsonML elements.\n+   */\n+\n+  private void transformAllChildren(JsonML element, Node parent,\n+      boolean newState) throws JsonMLException {\n+    transformElements(element.getChildren(), parent, newState);\n+  }\n+\n+  private void transformAllChildren(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformElements(element.getChildren(), parent);\n+  }\n+\n+  private void transformAllChildrenFromIndex(JsonML element, Node parent,\n+      int fromIndex, boolean newState) throws JsonMLException {\n+    transformElements(element.getChildren().subList(\n+        fromIndex, element.childrenSize()), parent, newState);\n+  }\n+\n+  private void transformAllChildrenFromIndex(JsonML element, Node parent,\n+      int fromIndex) throws JsonMLException {\n+    transformElements(element.getChildren().subList(\n+        fromIndex, element.childrenSize()), parent);\n+  }\n+\n+  private void transformElements(List<JsonML> elements, Node parent,\n+      boolean newState) throws JsonMLException {\n+    boolean oldState = insertExprResultState;\n+    insertExprResultState = newState;\n+    transformElements(elements, parent);\n+    insertExprResultState = oldState;\n+  }\n+\n+  private void transformElements(List<JsonML> elements, Node parent)\n+      throws JsonMLException {\n+    for (JsonML element : elements) {\n+      transformElement(element, parent);\n+    }\n+  }\n+\n+  /**\n+   * Responsible for inserting EXPR_RESULT nodes.\n+   */\n+  private boolean transformExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    boolean result = false;\n+    if (insertExprResultState) {\n+      Node node = new Node(Token.EXPR_RESULT);\n+      parent.addChildToBack(node);\n+      insertExprResultState = false;\n+      nodeIndex--; // the same node will be transformed again\n+      transformElement(element, node);\n+      insertExprResultState = true;\n+      result = true;\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Generic function responsible for dealing with JsonML elements describing\n+   * for loop (ForStmt and ForInStmt).\n+   */\n+  private void transformForLoop(JsonML element, Node parent, int childno)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.FOR, element);\n+    parent.addChildToBack(node);\n+\n+    JsonML child;\n+    for (int i = 0; i < childno; ++i) {\n+      child = element.getChild(i);\n+      if (child.getType() == TagType.EmptyStmt ||\n+          child.getType() == TagType.Empty) {\n+        nodeIndex++;\n+        node.addChildToBack(new Node(Token.EMPTY));\n+      } else {\n+        transformElement(child, node);\n+      }\n+    }\n+\n+    transformPotentiallyUnwrappedBlock(element.getChild(childno), node);\n+    insertExprResultState = true;\n+  }\n+\n+  /**\n+   * Generic function responsible for dealing with the following JsonML\n+   * elements: BreakStmt and ContinueStmt.\n+   */\n+  private void transformJumpStmt(JsonML element, Node parent, int type)\n+      throws JsonMLException {\n+    Node node = createNode(type, element);\n+    parent.addChildToBack(node);\n+\n+    String label = getOptionalAttribute(element, TagAttr.LABEL, String.class);\n+    if (label != null) {\n+      node.addChildToBack(Node.newString(Token.LABEL_NAME, label));\n+    }\n+  }\n+\n+  /**\n+   * Generic function responsible for dealing with JsonML elements describing\n+   * logical two arguments expressions: LogicalAndExpr and LogicalOrExpr.\n+   */\n+  private void transformLogicalExpr(JsonML element, Node parent, int type)\n+      throws JsonMLException {\n+    transformTwoArgumentExpr(element, parent, type);\n+  }\n+\n+  /**\n+   * Generic function responsible for dealing with all kind of expressions\n+   * which are passed exactly two arguments.\n+   */\n+  private void transformTwoArgumentExpr(JsonML element, Node parent,\n+      int type) throws JsonMLException {\n+    Node node = createNode(type, element);\n+    parent.addChildToBack(node);\n+    transformAllChildren(element, node);\n+  }\n+\n+  /**\n+   * Transforms an element which should be transformed into a BLOCK node, but\n+   * may not be represented by BlockStmt. In this case, additional BLOCK node\n+   * is created.\n+   */\n+  private void transformPotentiallyUnwrappedBlock(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    // in theory it should be always EmptyStmt, but due to possible\n+    // compatibility issues Empty element is allowed as well\n+    if (element.getType() == TagType.EmptyStmt ||\n+        element.getType() == TagType.Empty) {\n+      nodeIndex++;\n+      // Empty elements are only replaced by BLOCK node\n+      Node block = new Node(Token.BLOCK);\n+      parent.addChildToBack(block);\n+      block.putBooleanProp(Node.EMPTY_BLOCK, true);\n+    } else if (element.getType() != TagType.BlockStmt) {\n+      Node block = new Node(Token.BLOCK);\n+      parent.addChildToBack(block);\n+      boolean state = insertExprResultState;\n+      insertExprResultState = true;\n+      transformElement(element, block);\n+      insertExprResultState = state;\n+    } else {\n+      nodeIndex++;\n+      transformBlock(element, parent);\n+    }\n+  }\n+\n+  /*\n+   * Main functions.\n+   * Functions responsible for handling particular JsonML elements. Depending\n+   * on type, transformElement function dispatches actual work to\n+   * the corresponding function below.\n+   */\n+\n+  private void transformArrayExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.ARRAYLIT, element);\n+    parent.addChildToBack(node);\n+\n+    // iterate through all the children and look for empty elements\n+    int skipCount = 0;\n+    for (JsonML child : element.getChildren()) {\n+      if (child.getType() == TagType.Empty) {\n+        skipCount++;\n+      }\n+      transformElement(child, node);\n+    }\n+\n+    // if at least one empty element occurs, set up SKIP_INDEXES_PROP\n+    if (skipCount > 0) {\n+      int [] skipIndexes = new int[skipCount];\n+      int i = 0;\n+      int j = 0;\n+      for (JsonML child : element.getChildren()) {\n+        if (child.getType() == TagType.Empty) {\n+          skipIndexes[i] = j;\n+          ++i;\n+        }\n+        ++j;\n+      }\n+      node.putProp(Node.SKIP_INDEXES_PROP, skipIndexes);\n+    }\n+  }\n+\n+  private void transformAssignExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String op = getStringAttribute(element, TagAttr.OP);\n+    int type = Operator.getNodeTypeForAssignOp(op);\n+    transformTwoArgumentExpr(element, parent, type);\n+  }\n+\n+  private void transformBinaryExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String op = getStringAttribute(element, TagAttr.OP);\n+    int type = Operator.getNodeTypeForBinaryOp(op);\n+    transformTwoArgumentExpr(element, parent, type);\n+  }\n+\n+  private void transformBlock(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformBlock(element, parent, 0, element.childrenSize());\n+  }\n+\n+  private void transformBlock(JsonML element, Node parent, int start)\n+      throws JsonMLException {\n+    transformBlock(element, parent, start, element.childrenSize());\n+  }\n+\n+  private void transformBlock(JsonML element, Node parent, int start, int end)\n+      throws JsonMLException {\n+    Node node = createNode(Token.BLOCK, element);\n+    parent.addChildToBack(node);\n+    transformElements(element.getChildren(start, end), node, true);\n+  }\n+\n+  private void transformBreakStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformJumpStmt(element, parent, Token.BREAK);\n+  }\n+\n+  private void transformCallExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.CALL, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformCase(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.CASE, element);\n+    parent.addChildToBack(node);\n+\n+    // the first element represents case id\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // always insert an extra BLOCK node\n+    Node block = new Node(Token.BLOCK);\n+    node.addChildToBack(block);\n+\n+    transformAllChildrenFromIndex(element, block, 1, true);\n+  }\n+\n+  private void transformCatchClause(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.CATCH, element);\n+    parent.addChildToBack(node);\n+\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the second child represents actual block\n+    child = element.getChild(1);\n+    transformElement(child, node);\n+  }\n+\n+  private void transformConditionalExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.HOOK, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformContinueStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformJumpStmt(element, parent, Token.CONTINUE);\n+  }\n+\n+  /*\n+   * CountExpr are both incrementing and decrementing expressions (++x, --x)\n+   */\n+  private void transformCountExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String op = getStringAttribute(element, TagAttr.OP);\n+\n+    int type = Operator.getNodeTypeForCountOp(op);\n+\n+    Boolean isPrefix = getAttribute(element, TagAttr.IS_PREFIX, Boolean.class);\n+    Node node = createNode(type, element);\n+    node.putIntProp(Node.INCRDECR_PROP, isPrefix ? 0 : 1);\n+    parent.addChildToBack(node);\n+\n+    transformElement(element.getChild(0), node);\n+  }\n+\n+  /*\n+   * DataProp is the name for an object property which is initialized\n+   * when the object is created by object literal.\n+   * For example, in {x: 1, y: 2} each property is represented by its own\n+   * DataProp.\n+   */\n+  private void transformDataProp(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Object name = getObjectAttribute(element, TagAttr.NAME);\n+\n+    Node node = null;\n+    if (name instanceof Number) {\n+      node = Node.newNumber(((Number) name).doubleValue());\n+    } else if (name instanceof String) {\n+      node = Node.newString(Token.STRING, (String) name);\n+    } else {\n+      throw new IllegalStateException(\n+          \"The name of the property has invalid type.\");\n+    }\n+\n+    setPosition(node);\n+    parent.addChildToBack(node);\n+\n+    transformElement(element.getChild(0), parent);\n+  }\n+\n+  private void transformDefaultCase(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.DEFAULT, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represent body\n+    Node block = new Node(Token.BLOCK);\n+    node.addChildToBack(block);\n+\n+    transformAllChildren(element, block, true);\n+  }\n+\n+  private void transformDeleteExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.DELPROP, element);\n+    parent.addChildToBack(node);\n+\n+    transformElement(element.getChild(0), node);\n+  }\n+\n+  private void transformDoWhileStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.DO, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represents body\n+    JsonML child = element.getChild(0);\n+    transformPotentiallyUnwrappedBlock(child, node);\n+\n+    // the second child represents condition\n+    child = element.getChild(1);\n+    transformElement(child, node);\n+\n+    insertExprResultState = true;\n+  }\n+\n+  private void transformEmpty(JsonML element, Node parent) {\n+    switch (parent.getType()) {\n+      case Token.ARRAYLIT:\n+        // nothing happens, but we make sure that the elements are\n+        // taken into account by nodeIndex\n+        break;\n+      case Token.FUNCTION:\n+        parent.addChildToBack(Node.newString(Token.NAME, \"\"));\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unexpected Empty element.\");\n+    }\n+  }\n+\n+  private void transformEmptyStmt(JsonML element, Node parent) {\n+    Preconditions.checkState(\n+        parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT);\n+    parent.addChildToBack(new Node(Token.EMPTY));\n+  }\n+\n+  private void transformEvalExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = createNode(Token.CALL, element);\n+    parent.addChildToBack(node);\n+\n+    Node child = Node.newString(Token.NAME, \"eval\");\n+    child.putBooleanProp(Node.DIRECT_EVAL, true);\n+    node.addChildToBack(child);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformForInStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformForLoop(element, parent, 2);\n+  }\n+\n+  private void transformForStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformForLoop(element, parent, 3);\n+  }\n+\n+  private void transformFunction(JsonML element, Node parent,\n+      boolean needsName) throws JsonMLException {\n+    Node node = createNode(Token.FUNCTION, element);\n+    parent.addChildToBack(node);\n+\n+    JsonML child = element.getChild(0);\n+    String name = \"\";\n+\n+    // it be already validated at this point that a non empty name exists\n+    // if it is a function declaration\n+    transformElement(element.getChild(0), node);\n+\n+    transformElement(element.getChild(1), node);\n+\n+    // other children represents function body which should be\n+    // wrapped inside a block node\n+    transformBlock(element, node, 2);\n+  }\n+\n+  private void transformFunctionDecl(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformFunction(element, parent, true);\n+  }\n+\n+  private void transformFunctionExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformFunction(element, parent, false);\n+  }\n+\n+  private void transformIdExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String name = getStringAttribute(element, TagAttr.NAME);\n+    Node node = Node.newString(Token.NAME, name);\n+    setPosition(node);\n+    parent.addChildToBack(node);\n+  }\n+\n+  /*\n+   * InitPatt represents all variable declarations value initialization.\n+   * It has two children: name of the variable and the initial value.\n+   */\n+  private void transformInitPatt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    JsonML child = element.getChild(0);\n+    nodeIndex++;\n+    Node node = Node.newString(Token.NAME,\n+        getAttribute(child, TagAttr.NAME, String.class));\n+    setPosition(node);\n+    parent.addChildToBack(node);\n+\n+    child = element.getChild(1);\n+    transformElement(child, node);\n+  }\n+\n+  private void transformIdPatt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = Node.newString(Token.NAME,\n+        getStringAttribute(element, TagAttr.NAME));\n+    setPosition(node);\n+    parent.addChildToBack(node);\n+  }\n+\n+  private void transformIfStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.IF, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represents condition\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the second child is required\n+    child = element.getChild(1);\n+    transformPotentiallyUnwrappedBlock(child, node);\n+\n+    // the third child represents else part and is not required by AST\n+    child = element.getChild(2);\n+    if (child.getType() != TagType.EmptyStmt &&\n+        child.getType() != TagType.Empty) {\n+      transformPotentiallyUnwrappedBlock(child, node);\n+    } else {\n+      nodeIndex++;\n+    }\n+    insertExprResultState = true;\n+  }\n+\n+  private void transformInvokeExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.CALL, element);\n+    parent.addChildToBack(node);\n+\n+    transformMemberExpr(element, node);\n+\n+    transformElements(element.getChildren(2, element.childrenSize()), node);\n+  }\n+\n+  private void transformLabelledStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String label = getStringAttribute(element, TagAttr.LABEL);\n+    Node node = createNode(Token.LABEL, element);\n+    node.addChildToBack(Node.newString(Token.LABEL_NAME, label));\n+    parent.addChildToBack(node);\n+\n+    JsonML child = element.getChild(0);\n+    if (child.getType() == TagType.EmptyStmt) {\n+      nodeIndex++;\n+      node.addChildToBack(new Node(Token.EMPTY));\n+    } else {\n+      transformElement(element.getChild(0), node);\n+    }\n+  }\n+\n+  private void transformLiteralExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    Node node = null;\n+    Type type = Type.get(getStringAttribute(element, TagAttr.TYPE));\n+    switch (type) {\n+      case BOOLEAN: {\n+        Boolean value = getAttribute(element, TagAttr.VALUE, Boolean.class);\n+        if (value) {\n+          node = new Node(Token.TRUE);\n+        } else {\n+          node = new Node(Token.FALSE);\n+        }\n+        break;\n+      }\n+\n+      case NULL: {\n+        // needed to throw an exception if value is not null\n+        getAttribute(element, TagAttr.VALUE, null);\n+        node = new Node(Token.NULL);\n+        break;\n+      }\n+\n+      case NUMBER: {\n+        Double value = getAttribute(element, TagAttr.VALUE, Double.class);\n+        node = Node.newNumber(value);\n+        break;\n+      }\n+\n+      case STRING: {\n+        String value = getStringAttribute(element, TagAttr.VALUE);\n+        node = Node.newString(value);\n+        break;\n+      }\n+\n+      default:\n+        throw new JsonMLException(\"Unrecognized type attribute.\");\n+    }\n+\n+    setPosition(node);\n+    parent.addChildToBack(node);\n+  }\n+\n+  private void transformLogicalAndExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformLogicalExpr(element, parent, Token.AND);\n+  }\n+\n+  private void transformLogicalOrExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    transformLogicalExpr(element, parent, Token.OR);\n+  }\n+\n+  private void transformMemberExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+\n+    String op = getAttribute(element, TagAttr.OP, String.class);\n+    int type;\n+    if (op.equals(\".\")) {\n+      type = Token.GETPROP;\n+    } else if (op.equals(\"[]\")) {\n+      type = Token.GETELEM;\n+    } else {\n+      throw new JsonMLException(\"Invalid OP argument: \" + op);\n+    }\n+\n+    Node node = createNode(type, element);\n+    parent.addChildToBack(node);\n+\n+    transformElement(element.getChild(0), node);\n+    transformElement(element.getChild(1), node);\n+  }\n+\n+  private void transformNewExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.NEW, element);\n+    parent.addChildToBack(node);\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformObjectExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.OBJECTLIT, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformParamDecl(JsonML element, Node parent)\n+      throws JsonMLException {\n+    // formal arguments should be wrapped by LP node\n+    Node node = createNode(Token.LP, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformProgram(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkNotNull(parent);\n+    insertExprResultState = true;\n+\n+    Node script = new Node(Token.SCRIPT);\n+    script.setIsSyntheticBlock(true);\n+    parent.addChildToBack(script);\n+\n+    for (JsonML child : element.getChildren()) {\n+      transformElement(child, script);\n+    }\n+  }\n+\n+  private void transformPrologueDecl(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String directive = getStringAttribute(element, TagAttr.DIRECTIVE);\n+\n+    if (ALLOWED_DIRECTIVES.contains(directive)) {\n+      Set<String> directives = parent.getDirectives();\n+      if (directives == null) {\n+        directives = Sets.newHashSet();\n+      }\n+      directives.add(directive);\n+      parent.setDirectives(directives);\n+    } else {\n+      // for a directive which is not supported, we create a regular node\n+      Node node = new Node(Token.EXPR_RESULT);\n+      parent.addChildToBack(node);\n+      node.addChildToBack(Node.newString(Token.STRING, directive));\n+    }\n+  }\n+\n+  private void transformRegExpExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.REGEXP, element);\n+    parent.addChildToBack(node);\n+\n+    String body = getStringAttribute(element, TagAttr.BODY);\n+    node.addChildToBack(Node.newString(Token.STRING, body));\n+\n+    String flags = getStringAttribute(element, TagAttr.FLAGS);\n+    if (!(flags.equals(\"\"))) {\n+      node.addChildToBack(Node.newString(Token.STRING, flags));\n+    }\n+  }\n+\n+  private void transformReturnStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    Node node = createNode(Token.RETURN, element);\n+    parent.addChildToBack(node);\n+\n+    if (element.hasChildren()) {\n+      insertExprResultState = false;\n+      transformElement(element.getChild(0), node);\n+      insertExprResultState = true;\n+    }\n+  }\n+\n+  private void transformSwitchStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.SWITCH, element);\n+    parent.addChildToBack(node);\n+\n+    // make sure it has at least one child\n+    // the first child represents switch param\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the rest of the children represent cases\n+    for (int i = 1; i < element.childrenSize(); ++i) {\n+      child = element.getChild(i);\n+      // make sure it is case or default\n+      transformElement(child, node);\n+    }\n+\n+    insertExprResultState = true;\n+  }\n+\n+  private void transformThisExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    parent.addChildToBack(createNode(Token.THIS, element));\n+  }\n+\n+  private void transformThrowStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    Node node = createNode(Token.THROW, element);\n+    parent.addChildToBack(node);\n+\n+    insertExprResultState = false;\n+    transformElement(element.getChild(0), node);\n+    insertExprResultState = true;\n+  }\n+\n+  private void transformTryStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    Node node = createNode(Token.TRY, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represents try body\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the second child represents catch\n+    Node block = new Node(Token.BLOCK);\n+    node.addChildToBack(block);\n+    child = element.getChild(1);\n+\n+    if (child.getType() == TagType.CatchClause) {\n+      transformElement(child, block);\n+    } else {\n+      // catch clause is not present, but the element has to be counted\n+      nodeIndex++;\n+    }\n+\n+    // if the third child is present, it represents finally\n+    if (element.childrenSize() == 3) {\n+      child = element.getChild(2);\n+      transformElement(child, node);\n+    }\n+  }\n+\n+  private void transformTypeofExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.TYPEOF, element);\n+    parent.addChildToBack(node);\n+    transformElement(element.getChild(0), node);\n+  }\n+\n+  private void transformUnaryExpr(JsonML element, Node parent)\n+      throws JsonMLException {\n+    String op = getStringAttribute(element, TagAttr.OP);\n+    int type = Operator.getNodeTypeForUnaryOp(op);\n+\n+    Node node = createNode(type, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node);\n+  }\n+\n+  private void transformVarDecl(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Node node = createNode(Token.VAR, element);\n+    parent.addChildToBack(node);\n+\n+    transformAllChildren(element, node, false);\n+  }\n+\n+  private void transformWhileStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.WHILE, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represents loop condition\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the second child represents loop body\n+    child = element.getChild(1);\n+    transformPotentiallyUnwrappedBlock(child, node);\n+\n+    insertExprResultState = true;\n+  }\n+\n+  private void transformWithStmt(JsonML element, Node parent)\n+      throws JsonMLException {\n+    Preconditions.checkState(insertExprResultState == true);\n+    insertExprResultState = false;\n+\n+    Node node = createNode(Token.WITH, element);\n+    parent.addChildToBack(node);\n+\n+    // the first child represents object\n+    JsonML child = element.getChild(0);\n+    transformElement(child, node);\n+\n+    // the second child represents body\n+    child = element.getChild(1);\n+    transformPotentiallyUnwrappedBlock(child, node);\n+\n+    insertExprResultState = true;\n+  }\n+\n+  /**\n+   * Creates a node which refers to a particular JsonML element.\n+   */\n+  private Node createNode(int type, JsonML element) {\n+    return new Node(type, nodeIndex, -1);\n+  }\n+\n+  /**\n+   * Sets position for a node which refers to a particular JsonML element.\n+   * The position says which number (in pre-order) has the corresponding\n+   * JsonML element in the tree.\n+   */\n+  private void setPosition(Node node) {\n+    node.setLineno(nodeIndex);\n+  }\n+\n+  /**\n+   * Internal representation for operators which are used by JsonML as\n+   * attributes for various elements.\n+   */\n+  private enum Operator {\n+    // Assign Operators\n+    ASSIGN(\"=\"),\n+    ASSIGN_BITOR(\"|=\"),\n+    ASSIGN_BITXOR(\"^=\"),\n+    ASSIGN_BITAND(\"&=\"),\n+    ASSIGN_LSH(\"<<=\"),\n+    ASSIGN_RSH(\">>=\"),\n+    ASSIGN_URSH(\">>>=\"),\n+    ASSIGN_ADD(\"+=\"),\n+    ASSIGN_SUB(\"-=\"),\n+    ASSIGN_MUL(\"*=\"),\n+    ASSIGN_DIV(\"/=\"),\n+    ASSIGN_MOD(\"%=\"),\n+\n+    // Binary Operators\n+    BITOR(\"|\"),\n+    BITXOR(\"^\"),\n+    BITAND(\"&\"),\n+    EQ(\"==\"),\n+    NE(\"!=\"),\n+    LT(\"<\"),\n+    LE(\"<=\"),\n+    GT(\">\"),\n+    GE(\">=\"),\n+    LSH(\"<<\"),\n+    RSH(\">>\"),\n+    URSH(\">>>\"),\n+    ADD(\"+\"),\n+    SUB(\"-\"),\n+    MUL(\"*\"),\n+    DIV(\"/\"),\n+    MOD(\"%\"),\n+    SHEQ(\"===\"),\n+    SHNE(\"!==\"),\n+    COMMA(\",\"),\n+    INSTANCEOF(\"instanceof\"),\n+    IN(\"in\"),\n+\n+    // Count Operators\n+    DEC(\"--\"),\n+    INC(\"++\"),\n+\n+    // Unary Operators\n+    NOT(\"!\"),\n+    BITNOT(\"~\"),\n+    POS(\"+_unary\"), // \"+\" would be a duplicate with ADD\n+    NEG(\"-_unary\"), // \"-\" would be a duplicate with SUB\n+    VOID(\"void\");\n+\n+    private final String name;\n+    private static Map<String, Operator> lookup = Maps.newHashMap();\n+\n+    // Maps string representation of operators with corresponding enums\n+    static {\n+      for (Operator op : Operator.values()) {\n+        lookup.put(op.getName(), op);\n+      }\n+    }\n+\n+    private String getName() {\n+      return this.name;\n+    }\n+\n+    private Operator(String name) {\n+      this.name = name;\n+    }\n+\n+    private static Operator get(String name) {\n+      return lookup.get(name);\n+    }\n+\n+    /**\n+     * Returns assign operator associated with a specified name.\n+     */\n+    private static int getNodeTypeForAssignOp(String name) {\n+      Operator op = get(name);\n+      if (op == null) {\n+        return Token.ERROR;\n+      }\n+\n+      int type;\n+      switch (op) {\n+        case ASSIGN:\n+          type = Token.ASSIGN;\n+          break;\n+        case ASSIGN_BITOR:\n+          type = Token.ASSIGN_BITOR;\n+          break;\n+        case ASSIGN_BITXOR:\n+          type = Token.ASSIGN_BITXOR;\n+          break;\n+        case ASSIGN_BITAND:\n+          type = Token.ASSIGN_BITAND;\n+          break;\n+        case ASSIGN_LSH:\n+          type = Token.ASSIGN_LSH;\n+          break;\n+        case ASSIGN_RSH:\n+          type = Token.ASSIGN_RSH;\n+          break;\n+        case ASSIGN_URSH:\n+          type = Token.ASSIGN_URSH;\n+          break;\n+        case ASSIGN_ADD:\n+          type = Token.ASSIGN_ADD;\n+          break;\n+        case ASSIGN_SUB:\n+          type = Token.ASSIGN_SUB;\n+          break;\n+        case ASSIGN_MUL:\n+          type = Token.ASSIGN_MUL;\n+          break;\n+        case ASSIGN_DIV:\n+          type = Token.ASSIGN_DIV;\n+          break;\n+        case ASSIGN_MOD:\n+          type = Token.ASSIGN_MOD;\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"\"\n+              + \"Invalid type of assign expression.\");\n+      }\n+      return type;\n+    }\n+\n+    /**\n+     * Returns binary operator associated with a specified name.\n+     */\n+    private static int getNodeTypeForBinaryOp(String name) {\n+      Operator op = get(name);\n+\n+      int type;\n+      switch (op) {\n+        case BITOR:\n+          type = Token.BITOR;\n+          break;\n+        case BITXOR:\n+          type = Token.BITXOR;\n+          break;\n+        case BITAND:\n+          type = Token.BITAND;\n+          break;\n+        case EQ:\n+          type = Token.EQ;\n+          break;\n+        case NE:\n+          type = Token.NE;\n+          break;\n+        case LT:\n+          type = Token.LT;\n+          break;\n+        case LE:\n+          type = Token.LE;\n+          break;\n+        case GT:\n+          type = Token.GT;\n+          break;\n+        case GE:\n+          type = Token.GE;\n+          break;\n+        case LSH:\n+          type = Token.LSH;\n+          break;\n+        case RSH:\n+          type = Token.RSH;\n+          break;\n+        case URSH:\n+          type = Token.URSH;\n+          break;\n+        case ADD:\n+          type = Token.ADD;\n+          break;\n+        case SUB:\n+          type = Token.SUB;\n+          break;\n+        case MUL:\n+          type = Token.MUL;\n+          break;\n+        case DIV:\n+          type = Token.DIV;\n+          break;\n+        case MOD:\n+          type = Token.MOD;\n+          break;\n+        case SHEQ:\n+          type = Token.SHEQ;\n+          break;\n+        case SHNE:\n+          type = Token.SHNE;\n+          break;\n+        case COMMA:\n+          type = Token.COMMA;\n+          break;\n+        case INSTANCEOF:\n+          type = Token.INSTANCEOF;\n+          break;\n+        case IN:\n+          type = Token.IN;\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"\"\n+              + \"Invalid type of binary expression.\");\n+      }\n+      return type;\n+    }\n+\n+    /**\n+     * Returns count operator(++, --)  associated with a specified name.\n+     */\n+    private static int getNodeTypeForCountOp(String name) {\n+      Operator op = get(name);\n+      if (op == null) {\n+        return Token.ERROR;\n+      }\n+\n+      int type;\n+      switch (op) {\n+        case DEC:\n+          type = Token.DEC;\n+          break;\n+        case INC:\n+          type = Token.INC;\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"\"\n+              + \"Invalid type of count expression.\");\n+      }\n+      return type;\n+    }\n+\n+    /**\n+     * Returns assign operator associated with a specified name.\n+     */\n+    private static int getNodeTypeForUnaryOp(String name) {\n+      String realName = new String(name);\n+      if (name.equals(\"+\") || name.equals(\"-\")) {\n+        realName += \"_unary\";\n+      }\n+      Operator op = get(realName);\n+\n+      int type;\n+      switch (op) {\n+        case NOT:\n+          type = Token.NOT;\n+          break;\n+        case BITNOT:\n+          type = Token.BITNOT;\n+          break;\n+        case POS:\n+          type = Token.POS;\n+          break;\n+        case NEG:\n+          type = Token.NEG;\n+          break;\n+        case VOID:\n+          type = Token.VOID;\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"\"\n+              + \"Invalid type of unary expression.\");\n+      }\n+      return type;\n+    }\n+  }\n+\n+  /**\n+   * Internal representation of possible types of arguments of JsonML.\n+   */\n+  private enum Type {\n+    BOOLEAN(\"boolean\"),\n+    NULL(\"null\"),\n+    NUMBER(\"number\"),\n+    STRING(\"string\");\n+\n+    private final String name;\n+    private static Map<String, Type> lookup = new HashMap<String, Type>();\n+\n+    static {\n+      for (Type type : Type.values()) {\n+        lookup.put(type.getName(), type);\n+      }\n+    }\n+\n+    private String getName() {\n+      return this.name;\n+    }\n+\n+    private Type(String name) {\n+      this.name = name;\n+    }\n+\n+    private static Type get(String name) {\n+      return lookup.get(name);\n+    }\n+  }\n+}\n+\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/SecureCompiler.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerInput;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.JSModule;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.VariableRenamingPolicy;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * Compilation of JavaScript code which guarantees that all security\n+ * capabilities are preserved after the process. In particular, it can be\n+ * safely applied to cajoled source.\n+ *\n+ * JS Compiler is used for code analysis and optimization. It runs a series\n+ * of passes which try to improve the code.\n+ *\n+ * For safety reasons, only a subset of local passes, which are provided by\n+ * JS Compiler, are processed. Currently it includes:\n+ * - elimination of temporary variables\n+ *\n+ * Using SecureCompiler is quite straightforward. A user just needs to create\n+ * a new instance and call compile() method. Currently the only input which\n+ * is supported is JsonML.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class SecureCompiler {\n+\n+  private static final String COMPILATION_UNCOMPLETED_MSG =\n+      \"No compilation has been completed yet.\";\n+\n+  private static final String COMPILATION_UNSUCCESSFUL_MSG =\n+      \"The last compilation was not successful.\";\n+\n+  private static final String COMPILATION_ALREADY_COMPLETED_MSG =\n+      \"This instance has already compiled one source.\";\n+\n+  private Compiler compiler;\n+  private CompilerOptions options;\n+  private JsonMLAst sourceAst;\n+\n+  /** Report from the last compilation */\n+  private Report report;\n+\n+  public SecureCompiler() {\n+    compiler = new Compiler();\n+    options = getSecureCompilerOptions();\n+  }\n+\n+  /**\n+   * Returns compiled source in JsonML format.\n+   */\n+  public JsonML getJsonML() {\n+    Preconditions.checkState(report != null, COMPILATION_UNCOMPLETED_MSG);\n+    Preconditions.checkState(report.success, COMPILATION_UNSUCCESSFUL_MSG);\n+    return sourceAst.convertToJsonML();\n+  }\n+\n+  /**\n+   * Returns compiled source as a JavaScript.\n+   */\n+  public String getString() {\n+    Preconditions.checkState(report != null, COMPILATION_UNCOMPLETED_MSG);\n+    Preconditions.checkState(report.success, COMPILATION_UNSUCCESSFUL_MSG);\n+    return compiler.toSource();\n+  }\n+\n+  /**\n+   * Returns report from the last compilation.\n+   */\n+  public Report getReport() {\n+    Preconditions.checkState(report != null, COMPILATION_UNCOMPLETED_MSG);\n+    return report;\n+  }\n+\n+  public void compile(JsonML source) {\n+    if (report != null) {\n+      throw new IllegalStateException(COMPILATION_ALREADY_COMPLETED_MSG);\n+    }\n+\n+    sourceAst = new JsonMLAst(source);\n+\n+    CompilerInput input = new CompilerInput(\n+        sourceAst, \"[[jsonmlsource]]\", false);\n+\n+    JSModule module = new JSModule(\"[[jsonmlmodule]]\");\n+    module.add(input);\n+\n+    Result result = compiler.compile(\n+        new JSSourceFile[] {},\n+        new JSModule[] { module },\n+        options);\n+\n+    report = generateReport(result);\n+  }\n+\n+  /**\n+   * Returns compiler options which are safe for compilation of a cajoled\n+   * module. The set of options is similar to the one which is used by\n+   * CompilationLevel in simple mode. The main difference is that variable\n+   * renaming and closurePass options are turned off.\n+   */\n+  private CompilerOptions getSecureCompilerOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+\n+    options.variableRenaming = VariableRenamingPolicy.OFF;\n+    options.inlineLocalVariables = true;\n+    options.inlineLocalFunctions = true;\n+    options.checkGlobalThisLevel = CheckLevel.OFF;\n+    options.coalesceVariableNames = true;\n+    options.deadAssignmentElimination = true;\n+    options.collapseVariableDeclarations = true;\n+    options.convertToDottedProperties = true;\n+    options.labelRenaming = true;\n+    options.removeDeadCode = true;\n+    options.optimizeArgumentsArray = true;\n+    options.removeUnusedVars = true;\n+    options.removeUnusedVarsInGlobalScope = false;\n+\n+    return options;\n+  }\n+\n+  public void enableFoldConstant() {\n+    options.foldConstants = true;\n+  }\n+\n+  Report generateReport(Result result) {\n+    // a report may be generated only after actual compilation is complete\n+    if (result == null) {\n+      return null;\n+    }\n+\n+    ArrayList<JsonMLError> errors = Lists.newArrayList();\n+    for (JSError error : result.errors) {\n+      errors.add(JsonMLError.make(error, sourceAst));\n+    }\n+\n+    ArrayList<JsonMLError> warnings = Lists.newArrayList();\n+    for (JSError warning : result.warnings) {\n+      warnings.add(JsonMLError.make(warning, sourceAst));\n+    }\n+\n+    return new Report(\n+        errors.toArray(new JsonMLError[0]),\n+        warnings.toArray(new JsonMLError[0]));\n+  }\n+\n+  public class Report {\n+    private final boolean success;\n+    private final JsonMLError[] errors;\n+    private final JsonMLError[] warnings;\n+\n+    private Report(JsonMLError[] errors, JsonMLError[] warnings) {\n+      this.success = errors.length == 0;\n+      this.errors = errors;\n+      this.warnings = warnings;\n+    }\n+\n+    public boolean isSuccessful() {\n+      return success;\n+    }\n+\n+    public JsonMLError[] getErrors() {\n+      return errors;\n+    }\n+\n+    public JsonMLError[] getWarnings() {\n+      return warnings;\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/TagAttr.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * List of attributes that a JsonML element may have.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public enum TagAttr {\n+  BODY(\"body\"),\n+  DIRECTIVE(\"directive\"),\n+  END_COLUMN(\"endColumn\"),\n+  END_LINE(\"endLine\"),\n+  FLAGS(\"flags\"),\n+  IS_PREFIX(\"isPrefix\"),\n+  LABEL(\"label\"),\n+  NAME(\"name\"),\n+  OP(\"op\"),\n+  OPAQUE_POSITION(\"opaque_position\"),\n+  SOURCE(\"source\"),\n+  START_COLUMN(\"startColumn\"),\n+  START_LINE(\"startLine\"),\n+  TYPE(\"type\"),\n+  VALUE(\"value\");\n+\n+  private final String name;\n+  private static final Map<String, TagAttr> lookup =\n+      new HashMap<String, TagAttr>();\n+\n+  static {\n+    for (TagAttr t : TagAttr.values()) {\n+      lookup.put(t.getName(), t);\n+    }\n+  }\n+\n+  private String getName() {\n+    return name;\n+  }\n+\n+  private TagAttr(String name) {\n+    this.name = name;\n+  }\n+\n+  public static TagAttr get(String name) {\n+    return lookup.get(name);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return name;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/TagType.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+/**\n+ * List of types allowed for JsonML elements.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public enum TagType {\n+\n+  // *Expr types\n+  ArrayExpr,\n+  AssignExpr,\n+  BinaryExpr,\n+  CallExpr,\n+  ConditionalExpr,\n+  CountExpr,\n+  DeleteExpr,\n+  EvalExpr,\n+  FunctionExpr,\n+  IdExpr,\n+  InvokeExpr,\n+  LiteralExpr,\n+  LogicalAndExpr,\n+  LogicalOrExpr,\n+  MemberExpr,\n+  NewExpr,\n+  ObjectExpr,\n+  RegExpExpr,\n+  ThisExpr,\n+  TypeofExpr,\n+  UnaryExpr,\n+\n+  // *Stmt types\n+  BlockStmt,\n+  BreakStmt,\n+  ContinueStmt,\n+  DebuggerStmt,\n+  DoWhileStmt,\n+  EmptyStmt,\n+  ForInStmt,\n+  ForStmt,\n+  IfStmt,\n+  LabelledStmt,\n+  ReturnStmt,\n+  SwitchStmt,\n+  ThrowStmt,\n+  TryStmt,\n+  WhileStmt,\n+  WithStmt,\n+\n+  // *Decl types\n+  FunctionDecl,\n+  ParamDecl,\n+  PrologueDecl,  // TODO\n+  VarDecl,\n+\n+  // *Prop types\n+  DataProp,\n+  GetterProp,         // not supported by Closure Compiler\n+  SetterProp,         // not supported by Closure Compiler\n+\n+  // *Patt types\n+  IdPatt,\n+  InitPatt,\n+\n+  // *Case types\n+  Case,\n+  DefaultCase,\n+\n+  // CatchClause type\n+  CatchClause,\n+\n+  // Empty type\n+  Empty,\n+\n+  // Program type (root)\n+  Program,\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/Validator.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Statically validates JsonML elements.\n+ *\n+ * It is done in constant time: no subtree is traversed, but the element\n+ * is validated based only on its properties. Sometimes, also its children\n+ * are taken into account.\n+ *\n+ * Usually it checks if the specified element has a correct number of children,\n+ * and if all require attributes exist. It does not enforce all restrictions\n+ * which are implied by ES3 or ES5 specification.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class Validator {\n+  public static final String MISSING_ARGUMENT = \"\" +\n+      \"No %s attribute specified for %s.\";\n+  public static final String NOT_ENOUGH_CHILDREN_FMT = \"\" +\n+      \"Not enough children for %s. Expected: %d. Found: %d.\";\n+  public static final String TOO_MANY_CHILDREN_FMT = \"\" +\n+      \"Too many children for %s. Expected: %d. Found: %d.\";\n+  public static final String WRONG_CHILD_TYPE_FMT = \"\" +\n+      \"Wrong type of child number %d for %s. Expected: %s. Found: %s.\";\n+\n+  // used to check if a JsonML element represents an expression\n+  public static TagType[] exprTypes = {\n+      TagType.ArrayExpr, TagType.AssignExpr, TagType.BinaryExpr,\n+      TagType.CallExpr, TagType.ConditionalExpr, TagType.CountExpr,\n+      TagType.DeleteExpr, TagType.EvalExpr, TagType.IdExpr, TagType.InvokeExpr,\n+      TagType.LiteralExpr, TagType.LogicalAndExpr, TagType.LogicalOrExpr,\n+      TagType.MemberExpr, TagType.NewExpr, TagType.ObjectExpr,\n+      TagType.RegExpExpr, TagType.ThisExpr, TagType.TypeofExpr,\n+      TagType.UnaryExpr, TagType.FunctionExpr\n+  };\n+\n+  private final StringBuilder b;\n+  private boolean error;\n+\n+  private Validator() {\n+    b = new StringBuilder();\n+    error = false;\n+  }\n+\n+  /**\n+   * Validates the specified JsonML element.\n+   * @param element JsonML element to validate\n+   * @return error message if the element could not be\n+   * validated, an empty string otherwise\n+   */\n+  public static String validate(JsonML element) {\n+    return (new Validator()).doValidate(element);\n+  }\n+\n+  /**\n+   * Validates the specified JsonML element.\n+   */\n+  private String doValidate(JsonML element) {\n+    String message;\n+    switch (element.getType()) {\n+      case AssignExpr:\n+        validateAssignExpr(element);\n+        break;\n+      case BinaryExpr:\n+        validateBinaryExpr(element);\n+        break;\n+      case BreakStmt:\n+      case ContinueStmt:\n+        validateJmpStmt(element);\n+        break;\n+      case Case:\n+        validateCase(element);\n+        break;\n+      case CatchClause:\n+        validateCatchClause(element);\n+        break;\n+      case ConditionalExpr:\n+        validateConditionalExpr(element);\n+        break;\n+      case CountExpr:\n+        validateCountExpr(element);\n+        break;\n+      case DataProp:\n+        validateDataProp(element);\n+        break;\n+      case DeleteExpr:\n+        validateDeleteExpr(element);\n+        break;\n+      case DoWhileStmt:\n+        validateDoWhileStmt(element);\n+        break;\n+      case EmptyStmt:\n+        validateEmptyStmt(element);\n+        break;\n+      case ForInStmt:\n+        validateForInStmt(element);\n+        break;\n+      case ForStmt:\n+        validateForStmt(element);\n+        break;\n+      case FunctionDecl:\n+        validateFunctionDecl(element);\n+        break;\n+      case FunctionExpr:\n+        validateFunctionExpr(element);\n+        break;\n+      case IdExpr:\n+        validateIdExpr(element);\n+        break;\n+      case IdPatt:\n+        validateIdPatt(element);\n+        break;\n+      case IfStmt:\n+        validateIfStmt(element);\n+        break;\n+      case InvokeExpr:\n+        validateInvokeExpr(element);\n+        break;\n+      case LabelledStmt:\n+        validateLabelledStmt(element);\n+        break;\n+      case LiteralExpr:\n+        validateLiteralExpr(element);\n+        break;\n+      case LogicalAndExpr:\n+      case LogicalOrExpr:\n+        validateLogicalExpr(element);\n+        break;\n+      case MemberExpr:\n+        validateMemberExpr(element);\n+        break;\n+      case NewExpr:\n+        validateNewExpr(element);\n+        break;\n+      case ObjectExpr:\n+        validateObjectExpr(element);\n+        break;\n+      case ParamDecl:\n+        validateParamDecl(element);\n+        break;\n+      case RegExpExpr:\n+        validateRegExpExpr(element);\n+        break;\n+      case ReturnStmt:\n+        validateReturnStmt(element);\n+        break;\n+      case SwitchStmt:\n+        validateSwitchStmt(element);\n+        break;\n+      case ThisExpr:\n+        validateThisExpr(element);\n+        break;\n+      case ThrowStmt:\n+        validateThrowStmt(element);\n+        break;\n+      case TryStmt:\n+        validateTryStmt(element);\n+        break;\n+      case TypeofExpr:\n+        validateTypeofExpr(element);\n+        break;\n+      case UnaryExpr:\n+        validateUnaryExpr(element);\n+        break;\n+      case VarDecl:\n+        validateVarDecl(element);\n+        break;\n+      case WhileStmt:\n+        validateWhileStmt(element);\n+        break;\n+      case WithStmt:\n+        validateWithStmt(element);\n+        break;\n+    }\n+    return b.length() != 0 ? b.toString() : null;\n+  }\n+\n+  private void validateAssignExpr(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    validateArgument(element, TagAttr.OP);\n+  }\n+\n+  private void validateBinaryExpr(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    validateArgument(element, TagAttr.OP);\n+  }\n+\n+  private void validateCase(JsonML element) {\n+    validateMinChildrenSize(element, 1);\n+    if (!error) {\n+      validateIsChildExpression(element, 0);\n+    }\n+  }\n+\n+  private void validateCatchClause(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    if (!error) {\n+      validateChildType(element, TagType.IdPatt , 0);\n+      validateChildType(element, TagType.BlockStmt, 1);\n+    }\n+  }\n+\n+  private void validateConditionalExpr(JsonML element) {\n+    validateChildrenSize(element, 3);\n+  }\n+\n+  private void validateCountExpr(JsonML element) {\n+    validateChildrenSize(element, 1);\n+    validateArgument(element, TagAttr.IS_PREFIX);\n+    validateArgument(element, TagAttr.OP);\n+  }\n+\n+  private void validateDataProp(JsonML element) {\n+    validateChildrenSize(element, 1);\n+    if (!error) {\n+      validateArgument(element, TagAttr.NAME);\n+    }\n+  }\n+\n+  private void validateDeleteExpr(JsonML element) {\n+    validateChildrenSize(element, 1);\n+    // TODO(dhans): maybe add that it has to be expression\n+  }\n+\n+  private void validateDoWhileStmt(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    // TODO(dhans): maybe add that the second child has to be an exception\n+  }\n+\n+  private void validateEmptyStmt(JsonML element) {\n+    validateChildrenSize(element, 0);\n+  }\n+\n+  private void validateForInStmt(JsonML element) {\n+    validateChildrenSize(element, 3);\n+  }\n+\n+  private void validateForStmt(JsonML element) {\n+    validateChildrenSize(element, 4);\n+  }\n+\n+  private void validateFunctionDecl(JsonML element) {\n+    validateFunction(element, true);\n+  }\n+\n+  private void validateFunctionExpr(JsonML element) {\n+    validateFunction(element, false);\n+  }\n+\n+  private void validateIdExpr(JsonML element) {\n+    validateChildrenSize(element, 0);\n+    if  (!error) {\n+      validateArgument(element, TagAttr.NAME);\n+    }\n+  }\n+\n+  private void validateIdPatt(JsonML element) {\n+    validateChildrenSize(element, 0);\n+    validateArgument(element, TagAttr.NAME);\n+  }\n+\n+  private void validateIfStmt(JsonML element) {\n+    validateChildrenSize(element, 3);\n+    if (!error) {\n+      // TODO(dhans): check the first child is condition\n+    }\n+  }\n+\n+  private void validateInvokeExpr(JsonML element) {\n+    validateMinChildrenSize(element, 2);\n+    validateArgument(element, TagAttr.OP);\n+  }\n+\n+  private void validateJmpStmt(JsonML element) {\n+    // for both BreakStmt and ContinueStmt\n+    validateChildrenSize(element, 0);\n+  }\n+\n+  private void validateLabelledStmt(JsonML element) {\n+    validateChildrenSize(element, 1);\n+    validateArgument(element, TagAttr.LABEL);\n+  }\n+\n+  private void validateLiteralExpr(JsonML element) {\n+    validateChildrenSize(element, 0);\n+    validateArgument(element, TagAttr.TYPE);\n+    validateArgument(element, TagAttr.VALUE);\n+  }\n+\n+  private void validateLogicalExpr(JsonML element) {\n+    validateChildrenSize(element, 2);\n+  }\n+\n+  private void validateMemberExpr(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    validateArgument(element, TagAttr.OP);\n+  }\n+\n+  private void validateNewExpr(JsonML element) {\n+    validateMinChildrenSize(element, 1);\n+  }\n+\n+  private void validateObjectExpr(JsonML element) {\n+    for (int i = 0; i < element.childrenSize(); ++i) {\n+      validateChildType(element, TagType.DataProp, i);\n+    }\n+  }\n+\n+  private void validateParamDecl(JsonML element) {\n+    for (int i = 0; i < element.childrenSize(); ++i) {\n+      validateChildType(element, TagType.IdPatt, i);\n+    }\n+  }\n+\n+  private void validateRegExpExpr(JsonML element) {\n+    validateChildrenSize(element, 0);\n+    validateArgument(element, TagAttr.BODY);\n+    validateArgument(element, TagAttr.FLAGS);\n+  }\n+\n+  private void validateReturnStmt(JsonML element) {\n+    validateMaxChildrenSize(element, 1);\n+  }\n+\n+  private void validateSwitchStmt(JsonML element) {\n+    validateMinChildrenSize(element, 1);\n+    boolean defaultStmt = false;\n+    for (int i = 1; i < element.childrenSize(); ++i) {\n+      if (!defaultStmt) {\n+        validateChildType(element,\n+            new TagType[] {TagType.Case, TagType.DefaultCase}, i);\n+      } else {\n+        validateChildType(element, TagType.Case, i);\n+      }\n+\n+      if (error) {\n+        break;\n+      }\n+\n+      if (element.getChild(i).getType() == TagType.DefaultCase) {\n+        defaultStmt = true;\n+      }\n+    }\n+  }\n+\n+  private void validateThisExpr(JsonML element) {\n+    validateChildrenSize(element, 0);\n+  }\n+\n+  private void validateThrowStmt(JsonML element) {\n+    validateChildrenSize(element, 1);\n+  }\n+\n+  private void validateTryStmt(JsonML element) {\n+    validateChildrenSize(element, 2, 3);\n+\n+    if (error) {\n+      return;\n+    }\n+\n+    validateChildType(element, TagType.BlockStmt, 0);\n+\n+    TagType[] types = new TagType[] { TagType.CatchClause, TagType.Empty };\n+    validateChildType(element, types, 1);\n+\n+    if (element.childrenSize() > 2) {\n+      validateChildType(element, TagType.BlockStmt, 2);\n+    }\n+  }\n+\n+  private void validateFunction(JsonML element, boolean needsName) {\n+    validateMinChildrenSize(element, 2);\n+\n+    if (error) {\n+      return;\n+    }\n+\n+    if (needsName) {\n+      validateChildType(\n+          element, new TagType[] { TagType.IdPatt }, 0);\n+    } else {\n+      validateChildType(\n+          element, new TagType[] { TagType.IdPatt, TagType.Empty }, 0);\n+    }\n+\n+    validateChildType(element, TagType.ParamDecl, 1);\n+  }\n+\n+  private void validateTypeofExpr(JsonML element) {\n+    validateChildrenSize(element, 1);\n+  }\n+\n+  private void validateUnaryExpr(JsonML element) {\n+    validateChildrenSize(element, 1);\n+    if (!error) {\n+      validateArgument(element, TagAttr.OP);\n+    }\n+  }\n+\n+  private void validateVarDecl(JsonML element) {\n+    validateMinChildrenSize(element, 1);\n+\n+    TagType[] types = new TagType[] { TagType.InitPatt, TagType.IdPatt };\n+    for (int i = 0; i < element.childrenSize(); ++i) {\n+      validateChildType(element, types, i);\n+    }\n+  }\n+\n+  private void validateWhileStmt(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    //TODO(dhans): check if the first child is expression\n+  }\n+\n+  private void validateWithStmt(JsonML element) {\n+    validateChildrenSize(element, 2);\n+    //TODO(dhans): check if the first child is expression\n+  }\n+\n+  private void validateArgument(JsonML element, TagAttr attr) {\n+    Object value = element.getAttribute(attr);\n+    if (value == null) {\n+\n+      // there is an exceptional situation when the value can be null\n+      // {'value': null, 'type': 'null'}\n+      String type;\n+      if ((type = (String) element.getAttribute(TagAttr.TYPE)) != null &&\n+          type.equals(\"null\")) {\n+        return;\n+      }\n+\n+      error = true;\n+      appendLine(String.format(\n+          MISSING_ARGUMENT,\n+          attr, element.getType()));\n+    }\n+  }\n+\n+  private void validateChildrenSize(JsonML element, int expected) {\n+    validateChildrenSize(element, expected, expected);\n+  }\n+\n+  private void validateChildrenSize(JsonML element, int min, int max) {\n+    validateMinChildrenSize(element, min);\n+    if (!error) {\n+      validateMaxChildrenSize(element, max);\n+    }\n+  }\n+\n+  private void validateMinChildrenSize(JsonML element, int min) {\n+    int size = element.childrenSize();\n+    if (size < min) {\n+      appendLine(String.format(\n+          NOT_ENOUGH_CHILDREN_FMT,\n+          element.getType(), min, size));\n+      error = true;\n+    }\n+  }\n+\n+  private void validateMaxChildrenSize(JsonML element, int max) {\n+    int size = element.childrenSize();\n+    if (size > max) {\n+      appendLine(String.format(\n+          TOO_MANY_CHILDREN_FMT,\n+          element.getType().toString(), max, size));\n+      error = true;\n+    }\n+  }\n+\n+  private void validateIsChildExpression(JsonML element, int index) {\n+    validateChildType(element, exprTypes, index);\n+  }\n+\n+  private void validateChildType(JsonML element, TagType expected,\n+      int index) {\n+    TagType[] types = { expected };\n+    validateChildType(element, types, index);\n+  }\n+\n+  private void validateChildType(JsonML element, TagType[] expected,\n+      int index) {\n+    TagType type = element.getChild(index).getType();\n+    if (!Arrays.asList(expected).contains(type)) {\n+      appendLine(String.format(\n+          WRONG_CHILD_TYPE_FMT,\n+          index, element.getType(), printList(expected), type));\n+      error = true;\n+    }\n+  }\n+\n+  private void appendLine(String line) {\n+    b.append(String.format(\"%s\", line));\n+  }\n+\n+  // public for test purposes only\n+  public static String printList(Object[] list) {\n+    StringBuilder builder = new StringBuilder(\"\");\n+    if (list.length == 1) {\n+      builder.append(list[0].toString());\n+    } else if (list.length > 1) {\n+      builder.append('[');\n+      for (int i = 0; i < list.length; ++i) {\n+        builder.append(list[i].toString());\n+        if (i < list.length - 1) {\n+          builder.append(\", \");\n+        }\n+      }\n+      builder.append(\"]\");\n+    }\n+    return builder.toString();\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/jsonml/Writer.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Converts internal AST into JsonML tree.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class Writer {\n+\n+  /**\n+   * Creates JsonML tree based on a specified AST.\n+   * @param root AST node\n+   * @return root of a created JsonML tree\n+   */\n+  public JsonML processAst(Node root) {\n+    Preconditions.checkNotNull(root);\n+    Preconditions.checkArgument(root.getType() == Token.BLOCK);\n+\n+    JsonML rootElement = new JsonML(TagType.BlockStmt);\n+    Node child = root.getFirstChild();\n+    while (child != null) {\n+      processNode(child, rootElement);\n+      child = child.getNext();\n+    }\n+\n+    return rootElement.getChild(0);\n+  }\n+\n+  /**\n+   * Dispatches an AST node to a function which converts it to JsonML.\n+   * @param node AST node to convert into JsonML element.\n+   * @param currentParent element to which newly created JsonML element will\n+   * be attached as a child\n+   */\n+  private void processNode(Node node, JsonML currentParent) {\n+    switch (node.getType()) {\n+      case Token.RETURN:\n+        processReturn(node, currentParent);\n+        break;\n+      case Token.BITOR:\n+        processBinaryExpr(node, currentParent, \"|\");\n+        break;\n+      case Token.BITXOR:\n+        processBinaryExpr(node, currentParent, \"^\");\n+        break;\n+      case Token.BITAND:\n+        processBinaryExpr(node, currentParent, \"&\");\n+        break;\n+      case Token.EQ:\n+        processBinaryExpr(node, currentParent, \"==\");\n+        break;\n+      case Token.NE:\n+        processBinaryExpr(node, currentParent, \"!=\");\n+        break;\n+      case Token.LT:\n+        processBinaryExpr(node, currentParent, \"<\");\n+        break;\n+      case Token.LE:\n+        processBinaryExpr(node, currentParent, \"<=\");\n+        break;\n+      case Token.GT:\n+        processBinaryExpr(node, currentParent, \">\");\n+        break;\n+      case Token.GE:\n+        processBinaryExpr(node, currentParent, \">=\");\n+        break;\n+      case Token.LSH:\n+        processBinaryExpr(node, currentParent, \"<<\");\n+        break;\n+      case Token.RSH:\n+        processBinaryExpr(node, currentParent, \">>\");\n+        break;\n+      case Token.URSH:\n+        processBinaryExpr(node, currentParent, \">>>\");\n+        break;\n+      case Token.ADD:\n+        processBinaryExpr(node, currentParent, \"+\");\n+        break;\n+      case Token.SUB:\n+        processBinaryExpr(node, currentParent, \"-\");\n+        break;\n+      case Token.MUL:\n+        processBinaryExpr(node, currentParent, \"*\");\n+        break;\n+      case Token.DIV:\n+        processBinaryExpr(node, currentParent, \"/\");\n+        break;\n+      case Token.MOD:\n+        processBinaryExpr(node, currentParent, \"%\");\n+        break;\n+      case Token.NOT:\n+        processUnaryExpr(node, currentParent, \"!\");\n+        break;\n+      case Token.BITNOT:\n+        processUnaryExpr(node, currentParent, \"~\");\n+        break;\n+      case Token.POS:\n+        processUnaryExpr(node, currentParent, \"+\");\n+        break;\n+      case Token.NEG:\n+        processUnaryExpr(node, currentParent, \"-\");\n+        break;\n+      case Token.NEW:\n+        processNew(node, currentParent, TagType.NewExpr);\n+        break;\n+      case Token.DELPROP:\n+        processOneArgExpr(node, currentParent, TagType.DeleteExpr);\n+        break;\n+      case Token.TYPEOF:\n+        processOneArgExpr(node, currentParent, TagType.TypeofExpr);\n+        break;\n+      case Token.GETPROP:\n+        processMemberExpr(node, currentParent, \".\");\n+        break;\n+      case Token.GETELEM:\n+        processMemberExpr(node, currentParent, \"[]\");\n+        break;\n+      case Token.CALL:\n+        processCall(node, currentParent);\n+        break;\n+      case Token.NAME:\n+        processName(node, currentParent);\n+        break;\n+      case Token.NUMBER:\n+      case Token.STRING:\n+      case Token.NULL:\n+      case Token.FALSE:\n+      case Token.TRUE:\n+        processLiteral(node, currentParent);\n+        break;\n+      case Token.THIS:\n+        processThis(node, currentParent);\n+        break;\n+      case Token.SHEQ:\n+        processBinaryExpr(node, currentParent, \"===\");\n+        break;\n+      case Token.SHNE:\n+        processBinaryExpr(node, currentParent, \"!==\");\n+        break;\n+      case Token.REGEXP:\n+        processRegExp(node, currentParent);\n+        break;\n+      case Token.THROW:\n+        processThrow(node, currentParent);\n+        break;\n+      case Token.IN:\n+        processBinaryExpr(node, currentParent, \"in\");\n+        break;\n+      case Token.INSTANCEOF:\n+        processBinaryExpr(node, currentParent, \"instanceof\");\n+        break;\n+      case Token.ARRAYLIT:\n+        processArrayLiteral(node, currentParent);\n+        break;\n+      case Token.OBJECTLIT:\n+        processObjectLiteral(node, currentParent);\n+        break;\n+      case Token.TRY:\n+        processTry(node, currentParent);\n+        break;\n+      case Token.COMMA:\n+        processBinaryExpr(node, currentParent, \",\");\n+        break;\n+      case Token.ASSIGN:\n+        processAssignExpr(node, currentParent, \"=\");\n+        break;\n+      case Token.ASSIGN_BITOR:\n+        processAssignExpr(node, currentParent, \"|=\");\n+        break;\n+      case Token.ASSIGN_BITXOR:\n+        processAssignExpr(node, currentParent, \"^=\");\n+        break;\n+      case Token.ASSIGN_BITAND:\n+        processAssignExpr(node, currentParent, \"&=\");\n+        break;\n+      case Token.ASSIGN_LSH:\n+        processAssignExpr(node, currentParent, \"<<=\");\n+        break;\n+      case Token.ASSIGN_RSH:\n+        processAssignExpr(node, currentParent, \">>=\");\n+        break;\n+      case Token.ASSIGN_URSH:\n+        processAssignExpr(node, currentParent, \">>>=\");\n+        break;\n+      case Token.ASSIGN_ADD:\n+        processAssignExpr(node, currentParent, \"+=\");\n+        break;\n+      case Token.ASSIGN_SUB:\n+        processAssignExpr(node, currentParent, \"-=\");\n+        break;\n+      case Token.ASSIGN_MUL:\n+        processAssignExpr(node, currentParent, \"*=\");\n+        break;\n+      case Token.ASSIGN_DIV:\n+        processAssignExpr(node, currentParent, \"/=\");\n+        break;\n+      case Token.ASSIGN_MOD:\n+        processAssignExpr(node, currentParent, \"%=\");\n+        break;\n+      case Token.HOOK:\n+        processHook(node, currentParent);\n+        break;\n+      case Token.OR:\n+        processLogicalExpr(node, currentParent, \"||\");\n+        break;\n+      case Token.AND:\n+        processLogicalExpr(node, currentParent, \"&&\");\n+        break;\n+      case Token.INC:\n+        processIncrDecrExpr(node, currentParent, \"++\");\n+        break;\n+      case Token.DEC:\n+        processIncrDecrExpr(node, currentParent, \"--\");\n+        break;\n+      case Token.FUNCTION:\n+        processFunction(node, currentParent);\n+        break;\n+      case Token.IF:\n+        processIf(node, currentParent);\n+        break;\n+      case Token.SWITCH:\n+        processSwitch(node, currentParent);\n+        break;\n+      case Token.CASE:\n+        processCase(node, currentParent, TagType.Case);\n+        break;\n+      case Token.DEFAULT:\n+        processCase(node, currentParent, TagType.DefaultCase);\n+        break;\n+      case Token.WHILE:\n+        processLoop(node, currentParent, TagType.WhileStmt);\n+        break;\n+      case Token.DO:\n+        processLoop(node, currentParent, TagType.DoWhileStmt);\n+        break;\n+      case Token.FOR:\n+        processForLoop(node, currentParent);\n+        break;\n+      case Token.BREAK:\n+        processJmp(node, currentParent, TagType.BreakStmt);\n+        break;\n+      case Token.CONTINUE:\n+        processJmp(node, currentParent, TagType.ContinueStmt);\n+        break;\n+      case Token.VAR:\n+        processVar(node, currentParent);\n+        break;\n+      case Token.WITH:\n+        processWith(node, currentParent);\n+        break;\n+      case Token.CATCH:\n+        processCatch(node, currentParent);\n+        break;\n+      case Token.VOID:\n+        processUnaryExpr(node, currentParent, \"void\");\n+        break;\n+      case Token.EMPTY:\n+        processEmpty(node, currentParent);\n+        break;\n+      case Token.BLOCK:\n+        processBlock(node, currentParent);\n+        break;\n+      case Token.LABEL:\n+        processLabel(node, currentParent);\n+        break;\n+      case Token.EXPR_RESULT:\n+        processExprResult(node, currentParent);\n+        break;\n+      case Token.SCRIPT:\n+        processScript(node, currentParent);\n+        break;\n+    }\n+  }\n+\n+  private void processAssignExpr(Node node, JsonML currentParent, String op) {\n+    processTwoArgExpr(node, currentParent, TagType.AssignExpr, op);\n+  }\n+\n+  private void processArrayLiteral(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.ArrayExpr);\n+    currentParent.appendChild(element);\n+    Iterator<Node> it = node.children().iterator();\n+    int[] skipIndexes = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n+    int i = 0;  // next index in new array to process\n+    int j = 0;  // next index in skip array\n+    int nextToSkip = 0;\n+    while (it.hasNext()) {\n+      while (skipIndexes != null && j < skipIndexes.length) {\n+        if (i == skipIndexes[j]) {\n+          element.appendChild(new JsonML(TagType.Empty));\n+          ++i;\n+          ++j;\n+        } else {\n+          break;\n+        }\n+      }\n+      processNode(it.next(), element);\n+      ++i;\n+    }\n+  }\n+\n+  private void processBinaryExpr(Node node, JsonML currentParent,\n+      String op) {\n+    processTwoArgExpr(node, currentParent, TagType.BinaryExpr, op);\n+  }\n+\n+  private void processBlock(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.BlockStmt);\n+    if (currentParent != null) {\n+      currentParent.appendChild(element);\n+    }\n+\n+    processDirectives(node, element);\n+\n+    for (Node child : node.children()) {\n+      processNode(child, element);\n+    }\n+  }\n+\n+  private void processCall(Node node, JsonML currentParent) {\n+    Iterator<Node> it = node.children().iterator();\n+    Node child = it.next();\n+    JsonML element;\n+    // the first child may indicate that it is invoke expression\n+    // or a standard function call\n+    switch (child.getType()) {\n+      case Token.GETPROP:         // a.x()\n+      case Token.GETELEM:         // a[x]()\n+        // we have to process this node here and cannot call processNode(child)\n+        // other children of CALL represent arguments, so we need to have\n+        // access to them while processing InvokeExpr\n+        element = new JsonML(TagType.InvokeExpr);\n+        element.setAttribute(\n+            TagAttr.OP,\n+            child.getType() == Token.GETPROP ? \".\" : \"[]\");\n+        currentParent.appendChild(element);\n+\n+        // there should be exactly two children\n+        Node grandchild = child.getFirstChild();\n+        processNode(grandchild, element);\n+        processNode(grandchild.getNext(), element);\n+\n+\n+        break;\n+      case Token.NAME:\n+        // caja treats calls to eval in a special way\n+        if (child.getString().equals(\"eval\")) {\n+          element = new JsonML(TagType.EvalExpr);\n+        } else {\n+          // element representing function name is created\n+          element = new JsonML(TagType.IdExpr);\n+          element.setAttribute(TagAttr.NAME, child.getString());\n+          // element representing function is created\n+          element = new JsonML(TagType.CallExpr, element);\n+        }\n+        currentParent.appendChild(element);\n+        break;\n+      default:\n+       // it addresses all cases where the first argument evaluates to\n+       // another expression\n+       element = new JsonML(TagType.CallExpr);\n+       currentParent.appendChild(element);\n+       processNode(child, element);\n+       break;\n+    }\n+\n+    // there may be arguments applied\n+    while (it.hasNext()) {\n+      processNode(it.next(), element);\n+    }\n+  }\n+\n+  private void processCase(Node node, JsonML currentParent,\n+      TagType type) {\n+    JsonML element = new JsonML(type);\n+    currentParent.appendChild(element);\n+\n+    Node child = node.getFirstChild();\n+    // for case, the first child represents its argument\n+    if (type == TagType.Case) {\n+      processNode(child, element);\n+      child = child.getNext();\n+    }\n+\n+    // it should be a BLOCK which is required by rhino for compatibility\n+    // the writer skips the node and move on to its children\n+    Preconditions.checkNotNull(child);\n+    Preconditions.checkState(child.getType() == Token.BLOCK);\n+    child = child.getFirstChild();\n+    while (child != null) {\n+      processNode(child, element);\n+      child = child.getNext();\n+    }\n+  }\n+\n+  private void processCatch(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.CatchClause);\n+    currentParent.appendChild(element);\n+\n+    // the first child represents exception's name\n+    Node child = node.getFirstChild();\n+    JsonML patt = new JsonML(TagType.IdPatt);\n+    patt.setAttribute(TagAttr.NAME, child.getString());\n+    element.appendChild(patt);\n+\n+    // the second child represents content\n+    child = child.getNext();\n+    processNode(child, element);\n+  }\n+\n+  private void processEmpty(Node node, JsonML currentParent) {\n+    currentParent.appendChild(new JsonML(TagType.EmptyStmt));\n+  }\n+\n+  private void processExprResult(Node node, JsonML currentParent) {\n+    // this not interesting to JsonML, so we just need to skip it\n+    processNode(node.getFirstChild(), currentParent);\n+  }\n+\n+  private void processForLoop(Node node, JsonML currentParent) {\n+    if (NodeUtil.isForIn(node)) {\n+      processLoop(node, currentParent, TagType.ForInStmt);\n+    } else {\n+      processLoop(node, currentParent, TagType.ForStmt);\n+    }\n+  }\n+\n+  private void processFunction(Node node, JsonML currentParent) {\n+    JsonML element;\n+    if (NodeUtil.isFunctionDeclaration(node)) {\n+      element = new JsonML(TagType.FunctionDecl);\n+    } else {  // isFunctionExpresion == true\n+      element = new JsonML(TagType.FunctionExpr);\n+    }\n+    currentParent.appendChild(element);\n+\n+    // the first child represents function's name\n+    Node child = node.getFirstChild();\n+    String name = child.getString();\n+    if (!name.equals(\"\")) {\n+      JsonML nameElement = new JsonML(TagType.IdPatt);\n+      nameElement.setAttribute(TagAttr.NAME, name);\n+      element.appendChild(nameElement);\n+    } else {\n+      element.appendChild(new JsonML(TagType.Empty));\n+    }\n+\n+    // the second child is a wrapper for formal parameters\n+    child = child.getNext();\n+    JsonML params = new JsonML(TagType.ParamDecl);\n+    element.appendChild(params);\n+    Iterator<Node> it = child.children().iterator();\n+    while (it.hasNext()) {\n+      JsonML param = new JsonML(TagType.IdPatt);\n+      Node nameNode = it.next();\n+      param.setAttribute(TagAttr.NAME, nameNode.getString());\n+      params.appendChild(param);\n+    }\n+\n+    // the third child represents function's body\n+    child = child.getNext();\n+\n+    // it can contain some directives\n+    processDirectives(child, element);\n+\n+    it = child.children().iterator();\n+    while (it.hasNext()) {\n+      processNode(it.next(), element);\n+    }\n+  }\n+\n+  private void processHook(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.ConditionalExpr);\n+    currentParent.appendChild(element);\n+    processChildren(node, element);\n+  }\n+\n+  private void processIf(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.IfStmt);\n+    currentParent.appendChild(element);\n+    Iterator<Node> it = node.children().iterator();\n+\n+    // there should be at least one child\n+    while (it.hasNext()) {\n+      processNode(it.next(), element);\n+    }\n+    // append EmptyStmt for each missing part\n+    int childCount = node.getChildCount();\n+    Preconditions.checkState(childCount >= 2);\n+    if (childCount < 3) { // no \"else\" part for sure\n+      element.appendChild(new JsonML(TagType.EmptyStmt));\n+    }\n+  }\n+\n+  private void processIncrDecrExpr(Node node, JsonML currentParent,\n+      String op) {\n+    JsonML element = new JsonML(TagType.CountExpr);\n+    currentParent.appendChild(element);\n+    if (op.equals(\"++\")) {\n+      element.setAttribute(TagAttr.OP, \"++\");\n+    } else { // op.euals(\"--\")\n+      element.setAttribute(TagAttr.OP, \"--\");\n+    }\n+\n+    if (node.getIntProp(Node.INCRDECR_PROP) == 1) {\n+      element.setAttribute(TagAttr.IS_PREFIX, false);\n+    } else { // INCRDECR_PROP == 0\n+      element.setAttribute(TagAttr.IS_PREFIX, true);\n+    }\n+\n+    // there is exactly one child\n+    processNode(node.getFirstChild(), element);\n+  }\n+\n+  private void processJmp(Node node, JsonML currentParent,\n+      TagType type) {\n+    JsonML element = new JsonML(type);\n+    currentParent.appendChild(element);\n+\n+    // optional child may point to a label\n+    Node child = node.getFirstChild();\n+    if (child != null) {\n+      element.setAttribute(TagAttr.LABEL, child.getString());\n+    }\n+  }\n+\n+  private void processLabel(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.LabelledStmt);\n+    currentParent.appendChild(element);\n+\n+    // the first child represents label's name\n+    Node child = node.getFirstChild();\n+    element.setAttribute(TagAttr.LABEL, child.getString());\n+\n+    // the second child represents labelled content\n+    child = child.getNext();\n+    processNode(child, element);\n+  }\n+\n+  private void processLiteral(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.LiteralExpr);\n+    switch (node.getType()) {\n+      case Token.NUMBER:\n+        element.setAttribute(TagAttr.TYPE, \"number\");\n+        element.setAttribute(TagAttr.VALUE, node.getDouble());\n+        break;\n+      case Token.STRING:\n+        element.setAttribute(TagAttr.TYPE, \"string\");\n+        element.setAttribute(TagAttr.VALUE, node.getString());\n+        break;\n+      case Token.NULL:\n+        element.setAttribute(TagAttr.TYPE, \"null\");\n+        element.setAttribute(TagAttr.VALUE, null);\n+        break;\n+      case Token.TRUE:\n+        element.setAttribute(TagAttr.TYPE, \"boolean\");\n+        element.setAttribute(TagAttr.VALUE, true);\n+        break;\n+      case Token.FALSE:\n+        element.setAttribute(TagAttr.TYPE, \"boolean\");\n+        element.setAttribute(TagAttr.VALUE, false);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Illegal type of node.\");\n+    }\n+    currentParent.appendChild(element);\n+  }\n+\n+  private void processLogicalExpr(Node node, JsonML currentParent,\n+      String op) {\n+    if (op.equals(\"||\")) {\n+      processTwoArgExpr(node, currentParent, TagType.LogicalOrExpr);\n+    } else if (op.endsWith(\"&&\")) {\n+      processTwoArgExpr(node, currentParent, TagType.LogicalAndExpr);\n+    } else {\n+      throw new IllegalArgumentException(\"Unsupported value of op argument.\");\n+    }\n+  }\n+\n+  private void processLoop(Node node, JsonML currentParent,\n+      TagType type) {\n+    JsonML element = new JsonML(type);\n+    currentParent.appendChild(element);\n+    processChildren(node, element);\n+  }\n+\n+  private void processMemberExpr(Node node, JsonML currentParent,\n+      String op) {\n+    JsonML element = new JsonML(TagType.MemberExpr);\n+    element.setAttribute(TagAttr.OP, op);\n+    currentParent.appendChild(element);\n+\n+    // there should be exactly two children\n+    Node child = node.getFirstChild();\n+    processNode(child, element);\n+    processNode(child.getNext(), element);\n+  }\n+\n+  private void processName(Node node, JsonML currentParent) {\n+    Preconditions.checkState(!node.hasChildren());\n+\n+    JsonML element = new JsonML(TagType.IdExpr);\n+    element.setAttribute(TagAttr.NAME, node.getString());\n+    currentParent.appendChild(element);\n+  }\n+\n+  private void processNew(Node node, JsonML currentParent, TagType type) {\n+    JsonML element = new JsonML(type);\n+    currentParent.appendChild(element);\n+\n+    processChildren(node, element);\n+  }\n+\n+  private void processObjectLiteral(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.ObjectExpr);\n+    currentParent.appendChild(element);\n+    Iterator<Node> it = node.children().iterator();\n+    while (it.hasNext()) {\n+      JsonML item = new JsonML(TagType.DataProp);\n+      Node child = it.next();\n+      Object name = null;\n+      switch (child.getType()) {\n+        case Token.STRING:\n+          name = child.getString();\n+          break;\n+        case Token.NUMBER:\n+          name = child.getDouble();\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"Illegal type of node.\");\n+      }\n+      item.setAttribute(TagAttr.NAME, name);\n+      processNode(it.next(), item);\n+      element.appendChild(item);\n+    }\n+  }\n+\n+  private void processRegExp(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.RegExpExpr);\n+    currentParent.appendChild(element);\n+\n+    // first child represents expression's body\n+    Node child = node.getFirstChild();\n+    element.setAttribute(TagAttr.BODY, child.getString());\n+\n+    // optional second child represents flags\n+    String flags = \"\";\n+    child = child.getNext();\n+    if (child != null) {\n+      flags = child.getString();\n+    }\n+    element.setAttribute(TagAttr.FLAGS, flags);\n+  }\n+\n+  private void processSwitch(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.SwitchStmt);\n+    currentParent.appendChild(element);\n+\n+    // the first child represents expression\n+    Node child = node.getFirstChild();\n+    processNode(child, element);\n+\n+    // next children represent particular cases\n+    for (Node c = child.getNext(); c != null; c = c.getNext()) {\n+      processNode(c, element);\n+    }\n+  }\n+\n+  private void processThis(Node node, JsonML currentParent) {\n+    currentParent.appendChild(new JsonML(TagType.ThisExpr));\n+  }\n+\n+  private void processThrow(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.ThrowStmt);\n+    currentParent.appendChild(element);\n+\n+    // there is exactly one child\n+    processNode(node.getFirstChild(), element);\n+  }\n+\n+  private void processTry(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.TryStmt);\n+    currentParent.appendChild(element);\n+\n+    // first child represents actual try block\n+    Node child = node.getFirstChild();\n+    processNode(child, element);\n+\n+    // second child (precisely: child of that child) represents catch block\n+    child = child.getNext();\n+    if (child.hasChildren()) {\n+      processNode(child.getFirstChild(), element);\n+    } else {  // catch block is not present\n+      element.appendChild(new JsonML(TagType.Empty));\n+    }\n+\n+    //optional third child represents finally block\n+    child = child.getNext();\n+    if (child != null) {\n+      processNode(child, element);\n+    }\n+  }\n+\n+  private void processTwoArgExpr(Node node, JsonML currentParent,\n+      TagType type) {\n+    processTwoArgExpr(node, currentParent, type, null);\n+  }\n+\n+  private void processTwoArgExpr(Node node, JsonML currentParent,\n+      TagType type, String op) {\n+    JsonML element = new JsonML(type);\n+    if (op != null) {\n+      element.setAttribute(TagAttr.OP, op);\n+    }\n+    currentParent.appendChild(element);\n+\n+    Preconditions.checkState(node.getChildCount() == 2);\n+    Node child = node.getFirstChild();\n+    processNode(child, element);\n+    processNode(child.getNext(), element);\n+  }\n+\n+  /**\n+   * Process nodes which JsonML represents by UnaryExpr.\n+   * @param node node to process\n+   * @param op operation for this unary expression - depends on node type\n+   */\n+  private void processUnaryExpr(Node node, JsonML currentParent,\n+      String op) {\n+    JsonML element = new JsonML(TagType.UnaryExpr);\n+    element.setAttribute(TagAttr.OP, op);\n+    currentParent.appendChild(element);\n+\n+    processNode(node.getFirstChild(), element);\n+  }\n+\n+  private void processVar(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.VarDecl);\n+    currentParent.appendChild(element);\n+\n+    //there may be many actual declarations\n+    Iterator<Node> it = node.children().iterator();\n+    while (it.hasNext()) {\n+      Node child = it.next();  // this node represents var's id\n+                               // its own child represents initial value\n+\n+      JsonML id = new JsonML(TagType.IdPatt);\n+      id.setAttribute(TagAttr.NAME, child.getString());\n+\n+      if (child.hasChildren()) {\n+        JsonML patt = new JsonML(TagType.InitPatt);\n+        element.appendChild(patt);\n+        patt.appendChild(id);\n+        processNode(child.getFirstChild(), patt);\n+      } else {\n+        element.appendChild(id);\n+      }\n+    }\n+  }\n+\n+  private void processReturn(Node currentNode, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.ReturnStmt);\n+    currentParent.appendChild(element);\n+\n+    // there is exactly one child if return statement is not empty\n+    if (currentNode.hasChildren()) {\n+      processNode(currentNode.getFirstChild(), element);\n+    }\n+  }\n+\n+  private void processScript(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.Program);\n+    currentParent.appendChild(element);\n+\n+    processDirectives(node, element);\n+\n+    processChildren(node, element);\n+  }\n+\n+  private void processWith(Node node, JsonML currentParent) {\n+    JsonML element = new JsonML(TagType.WithStmt);\n+    currentParent.appendChild(element);\n+\n+    // the first child represent object\n+    Node child = node.getFirstChild();\n+    processNode(child, element);\n+\n+    // the second one represents content\n+    child = child.getNext();\n+    processNode(child, element);\n+  }\n+\n+  private void processChildren(Node node, JsonML currentParent) {\n+    for (Node child : node.children()) {\n+      processNode(child, currentParent);\n+    }\n+  }\n+\n+  private void processDirectives(Node node, JsonML currectParent) {\n+    Set<String> directives = node.getDirectives();\n+\n+    if (directives == null) {\n+      return;\n+    }\n+\n+    for (String directive : directives) {\n+      JsonML element = new JsonML(TagType.PrologueDecl);\n+      element.setAttribute(TagAttr.DIRECTIVE, directive);\n+      element.setAttribute(TagAttr.VALUE, directive);\n+      currectParent.appendChild(element);\n+    }\n+  }\n+\n+  private void processOneArgExpr(Node node, JsonML currentParent,\n+      TagType type) {\n+    JsonML element = new JsonML(type);\n+    currentParent.appendChild(element);\n+\n+    // there is only one child node\n+    processNode(node.getFirstChild(), element);\n+  }\n+}", "timestamp": 1285195646, "metainfo": ""}