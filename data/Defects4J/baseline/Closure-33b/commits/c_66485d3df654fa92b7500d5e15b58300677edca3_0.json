{"sha": "66485d3df654fa92b7500d5e15b58300677edca3", "log": "Use non-generic data structures in a bunch of places. (More for readability reasons than anything else)    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n         r.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n \n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n-      addInvalidatingType(mis.first);\n-      addInvalidatingType(mis.second);\n+      addInvalidatingType(mis.typeA);\n+      addInvalidatingType(mis.typeB);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/BasicErrorManager.java\n+++ b/src/com/google/javascript/jscomp/BasicErrorManager.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n \n *\n  */\n public abstract class BasicErrorManager implements ErrorManager {\n-  private final SortedSet<Pair<JSError, CheckLevel>> messages =\n-    Sets.newTreeSet(new LeveledJSErrorComparator());\n+  private final SortedSet<ErrorWithLevel> messages =\n+      Sets.newTreeSet(new LeveledJSErrorComparator());\n   private int errorCount = 0;\n   private int warningCount = 0;\n   private double typedPercent = 0.0;\n \n   public void report(CheckLevel level, JSError error) {\n-    if (messages.add(Pair.of(error, level))) {\n+    if (messages.add(new ErrorWithLevel(error, level))) {\n       if (level == CheckLevel.ERROR) {\n         errorCount++;\n       } else if (level == CheckLevel.WARNING) {\n   }\n \n   public void generateReport() {\n-    for (Pair<JSError, CheckLevel> message : messages) {\n-      println(message.second, message.first);\n+    for (ErrorWithLevel message : messages) {\n+      println(message.level, message.error);\n     }\n     printSummary();\n   }\n \n   private JSError[] toArray(CheckLevel level) {\n     List<JSError> errors = new ArrayList<JSError>(messages.size());\n-    for (Pair<JSError, CheckLevel> p : messages) {\n-      if (p.second == level) {\n-        errors.add(p.first);\n+    for (ErrorWithLevel p : messages) {\n+      if (p.level == level) {\n+        errors.add(p.error);\n       }\n     }\n     return errors.toArray(new JSError[errors.size()]);\n    * {@link JSError#equals(Object)}.</p>\n    */\n   static final class LeveledJSErrorComparator\n-      implements Comparator<Pair<JSError, CheckLevel>> {\n+      implements Comparator<ErrorWithLevel> {\n     private static final int P1_LT_P2 = -1;\n     private static final int P1_GT_P2 = 1;\n \n-    public int compare(Pair<JSError, CheckLevel> p1,\n-        Pair<JSError, CheckLevel> p2) {\n+    public int compare(ErrorWithLevel p1, ErrorWithLevel p2) {\n       // null is the smallest value\n       if (p2 == null) {\n         if (p1 == null) {\n       }\n \n       // check level\n-      if (p1.second != p2.second) {\n-        return p2.second.compareTo(p1.second);\n+      if (p1.level != p2.level) {\n+        return p2.level.compareTo(p1.level);\n       }\n \n       // sourceName comparison\n-      String source1 = p1.first.sourceName;\n-      String source2 = p2.first.sourceName;\n+      String source1 = p1.error.sourceName;\n+      String source2 = p2.error.sourceName;\n       if (source1 != null && source2 != null) {\n         int sourceCompare = source1.compareTo(source2);\n         if (sourceCompare != 0) {\n         return P1_GT_P2;\n       }\n       // lineno comparison\n-      int lineno1 = p1.first.lineNumber;\n-      int lineno2 = p2.first.lineNumber;\n+      int lineno1 = p1.error.lineNumber;\n+      int lineno2 = p2.error.lineNumber;\n       if (lineno1 != lineno2) {\n         return lineno1 - lineno2;\n       } else if (lineno1 < 0 && 0 <= lineno2) {\n         return P1_GT_P2;\n       }\n       // charno comparison\n-      int charno1 = p1.first.getCharno();\n-      int charno2 = p2.first.getCharno();\n+      int charno1 = p1.error.getCharno();\n+      int charno2 = p2.error.getCharno();\n       if (charno1 != charno2) {\n         return charno1 - charno2;\n       } else if (charno1 < 0 && 0 <= charno2) {\n         return P1_GT_P2;\n       }\n       // description\n-      return p1.first.description.compareTo(p2.first.description);\n+      return p1.error.description.compareTo(p2.error.description);\n+    }\n+  }\n+\n+  static class ErrorWithLevel {\n+    final JSError error;\n+    final CheckLevel level;\n+\n+    ErrorWithLevel(JSError error, CheckLevel level) {\n+      this.error = error;\n+      this.level = level;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n \n import com.google.common.base.Function;\n-import com.google.common.base.Pair;\n import com.google.common.collect.ImmutableMapBuilder;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n         }\n       };\n \n-  /** Functions used to restrict types.\n-   */\n-  private Map<String, Function<Pair<JSType, Boolean>, JSType>> restricters;\n+  /** Functions used to restrict types. */\n+  private Map<String, Function<TypeRestriction, JSType>> restricters;\n \n   /**\n    * Creates a {@link ClosureReverseAbstractInterpreter}.\n       final JSTypeRegistry typeRegistry) {\n     super(convention, typeRegistry);\n     this.restricters =\n-      new ImmutableMapBuilder<String, Function<Pair<JSType, Boolean>, JSType>>()\n-      .put(\"isDef\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          if (p.second) {\n-            return getRestrictedWithoutUndefined(p.first);\n+      new ImmutableMapBuilder<String, Function<TypeRestriction, JSType>>()\n+      .put(\"isDef\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n+            return getRestrictedWithoutUndefined(p.type);\n           } else {\n             return null;\n           }\n          }\n       })\n-      .put(\"isNull\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          if (p.second) {\n+      .put(\"isNull\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n             return getNativeType(NULL_TYPE);\n           } else {\n-            return getRestrictedWithoutNull(p.first);\n-          }\n-        }\n-      })\n-      .put(\"isDefAndNotNull\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          if (p.second) {\n+            return getRestrictedWithoutNull(p.type);\n+          }\n+        }\n+      })\n+      .put(\"isDefAndNotNull\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n             return getRestrictedWithoutUndefined(\n-                getRestrictedWithoutNull(p.first));\n+                getRestrictedWithoutNull(p.type));\n           } else {\n             return null;\n           }\n         }\n       })\n-      .put(\"isString\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          return getRestrictedByTypeOfResult(p.first, \"string\", p.second);\n-        }\n-      })\n-      .put(\"isBoolean\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          return getRestrictedByTypeOfResult(p.first, \"boolean\", p.second);\n-        }\n-      })\n-      .put(\"isNumber\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          return getRestrictedByTypeOfResult(p.first, \"number\", p.second);\n-        }\n-      })\n-      .put(\"isFunction\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          return getRestrictedByTypeOfResult(p.first, \"function\", p.second);\n-        }\n-      })\n-      .put(\"isArray\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          Visitor<JSType> visitor = p.second ? restrictToArrayVisitor :\n+      .put(\"isString\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"string\", p.outcome);\n+        }\n+      })\n+      .put(\"isBoolean\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"boolean\", p.outcome);\n+        }\n+      })\n+      .put(\"isNumber\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"number\", p.outcome);\n+        }\n+      })\n+      .put(\"isFunction\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"function\", p.outcome);\n+        }\n+      })\n+      .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          Visitor<JSType> visitor = p.outcome ? restrictToArrayVisitor :\n               restrictToNotArrayVisitor;\n-          return p.first == null ? null : p.first.visit(visitor);\n-        }\n-      })\n-      .put(\"isObject\", new Function<Pair<JSType, Boolean>, JSType>() {\n-        public JSType apply(Pair<JSType, Boolean> p) {\n-          Visitor<JSType> visitor = p.second ? restrictToObjectVisitor :\n+          return p.type == null ? null : p.type.visit(visitor);\n+        }\n+      })\n+      .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n+        public JSType apply(TypeRestriction p) {\n+          Visitor<JSType> visitor = p.outcome ? restrictToObjectVisitor :\n               restrictToNotObjectVisitor;\n-          return p.first == null ? null : p.first.visit(visitor);\n+          return p.type == null ? null : p.type.visit(visitor);\n         }\n       })\n       .getMap();\n           Node right = callee.getLastChild();\n           if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n               right.getType() == STRING) {\n-            Function<Pair<JSType, Boolean>, JSType> restricter =\n+            Function<TypeRestriction, JSType> restricter =\n                 restricters.get(right.getString());\n             if (restricter != null) {\n               return restrictParameter(param, paramType, blindScope, restricter,\n   }\n \n   private FlowScope restrictParameter(Node parameter, JSType type,\n-      FlowScope blindScope, Function<Pair<JSType, Boolean>, JSType> restriction,\n+      FlowScope blindScope, Function<TypeRestriction, JSType> restriction,\n       boolean outcome) {\n     // restricting\n-    type = restriction.apply(Pair.of(type, outcome));\n+    type = restriction.apply(new TypeRestriction(type, outcome));\n \n     // changing the scope\n     if (type != null) {\n       return blindScope;\n     }\n   }\n+\n+  private static class TypeRestriction {\n+    private final JSType type;\n+    private final boolean outcome;\n+\n+    private TypeRestriction(JSType type, boolean outcome) {\n+      this.type = type;\n+      this.outcome = outcome;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n   public void process(Node externs, Node root) {\n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n-      addInvalidatingType(mis.first);\n-      addInvalidatingType(mis.second);\n+      addInvalidatingType(mis.typeA);\n+      addInvalidatingType(mis.typeB);\n     }\n \n     StaticScope<T> scope = typeSystem.getRootScope();\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Pair;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n   // the nodes that might have a name foo and connect that to the curFuncName.\n   // The accuracy of the analysis will depend heavily on eliminating the need\n   // to resort to this map.\n-  private final Multimap<String, Pair<Name, Reference>> unknownNameUse =\n+  private final Multimap<String, NameUse> unknownNameUse =\n       HashMultimap.create();\n \n   // Should we continue even if we found a type checker bug.\n         Reference ref = new Reference(n, parent);\n         ref.setUnknown(true);\n         unknownNameUse.put(n.getLastChild().getString(),\n-            new Pair<Name, Reference>(getNamedContainingFunction(), ref));\n+            new NameUse(getNamedContainingFunction(), ref));\n       }\n     }\n \n       if (propName == null) {\n         continue;\n       }\n-      Collection<Pair<Name, Reference>> uses = unknownNameUse.get(propName);\n+      Collection<NameUse> uses = unknownNameUse.get(propName);\n       if (uses != null) {\n-        for (Pair<Name, Reference> use : uses) {\n-          graph.connect(use.getFirst(), use.getSecond(), name);\n+        for (NameUse use : uses) {\n+          graph.connect(use.name, use.reference, name);\n         }\n       }\n     }\n     Preconditions.checkNotNull(containingFn);\n     return containingFn;\n   }\n+\n+  private static class NameUse {\n+    private final Name name;\n+    private final Reference reference;\n+\n+    private NameUse(Name name, Reference reference) {\n+      this.name = name;\n+      this.reference = reference;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n import com.google.common.base.Function;\n-import com.google.common.base.Pair;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSType.TypePair;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n   /**\n    * Merging function for equality between types.\n    */\n-  private static final Function<Pair<JSType, JSType>, Pair<JSType, JSType>> EQ =\n-    new Function<Pair<JSType, JSType>, Pair<JSType, JSType>>() {\n-      public Pair<JSType, JSType> apply(Pair<JSType, JSType> p) {\n-        if (p.first == null || p.second == null) {\n+  private static final Function<TypePair, TypePair> EQ =\n+    new Function<TypePair, TypePair>() {\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n           return null;\n         }\n-        return p.first.getTypesUnderEquality(p.second);\n+        return p.typeA.getTypesUnderEquality(p.typeB);\n       }\n     };\n \n   /**\n    * Merging function for non-equality between types.\n    */\n-  private static final Function<Pair<JSType, JSType>, Pair<JSType, JSType>> NE =\n-    new Function<Pair<JSType, JSType>, Pair<JSType, JSType>>() {\n-      public Pair<JSType, JSType> apply(Pair<JSType, JSType> p) {\n-        if (p.first == null || p.second == null) {\n+  private static final Function<TypePair, TypePair> NE =\n+    new Function<TypePair, TypePair>() {\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n           return null;\n         }\n-        return p.first.getTypesUnderInequality(p.second);\n+        return p.typeA.getTypesUnderInequality(p.typeB);\n       }\n     };\n \n    * Merging function for strict equality between types.\n    */\n   private static final\n-      Function<Pair<JSType, JSType>, Pair<JSType, JSType>> SHEQ =\n-    new Function<Pair<JSType, JSType>, Pair<JSType, JSType>>() {\n-      public Pair<JSType, JSType> apply(Pair<JSType, JSType> p) {\n-        if (p.first == null || p.second == null) {\n+      Function<TypePair, TypePair> SHEQ =\n+    new Function<TypePair, TypePair>() {\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n           return null;\n         }\n-        return p.first.getTypesUnderShallowEquality(p.second);\n+        return p.typeA.getTypesUnderShallowEquality(p.typeB);\n       }\n     };\n \n    * Merging function for strict non-equality between types.\n    */\n   private static final\n-      Function<Pair<JSType, JSType>, Pair<JSType, JSType>> SHNE =\n-    new Function<Pair<JSType, JSType>, Pair<JSType, JSType>>() {\n-      public Pair<JSType, JSType> apply(Pair<JSType, JSType> p) {\n-        if (p.first == null || p.second == null) {\n+      Function<TypePair, TypePair> SHNE =\n+    new Function<TypePair, TypePair>() {\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n           return null;\n         }\n-        return p.first.getTypesUnderShallowInequality(p.second);\n+        return p.typeA.getTypesUnderShallowInequality(p.typeB);\n       }\n     };\n \n    * Merging function for inequality comparisons between types.\n    */\n   private final\n-      Function<Pair<JSType, JSType>, Pair<JSType, JSType>> INEQ =\n-    new Function<Pair<JSType, JSType>, Pair<JSType, JSType>>() {\n-      public Pair<JSType, JSType> apply(Pair<JSType, JSType> p) {\n-        return new Pair<JSType, JSType>(\n-            getRestrictedWithoutUndefined(p.first),\n-            getRestrictedWithoutUndefined(p.second));\n+      Function<TypePair, TypePair> INEQ =\n+    new Function<TypePair, TypePair>() {\n+      public TypePair apply(TypePair p) {\n+        return new TypePair(\n+            getRestrictedWithoutUndefined(p.typeA),\n+            getRestrictedWithoutUndefined(p.typeB));\n       }\n     };\n \n   }\n \n   private FlowScope caseEquality(Node condition, FlowScope blindScope,\n-      Function<Pair<JSType, JSType>, Pair<JSType, JSType>> merging) {\n+      Function<TypePair, TypePair> merging) {\n     Node left = condition.getFirstChild();\n     Node right = condition.getLastChild();\n \n     }\n \n     // merged types\n-    Pair<JSType, JSType> merged = merging.apply(Pair.of(leftType, rightType));\n+    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n \n     // creating new scope\n     if (merged != null &&\n-        ((leftIsRefineable && merged.first != null) ||\n-         (rightIsRefineable && merged.second != null))) {\n+        ((leftIsRefineable && merged.typeA != null) ||\n+         (rightIsRefineable && merged.typeB != null))) {\n       FlowScope informed = blindScope.createChildFlowScope();\n-      if (leftIsRefineable && merged.first != null) {\n-        declareNameInScope(informed, left, merged.first);\n-      }\n-      if (rightIsRefineable && merged.second != null) {\n-        declareNameInScope(informed, right, merged.second);\n+      if (leftIsRefineable && merged.typeA != null) {\n+        declareNameInScope(informed, left, merged.typeA);\n+      }\n+      if (rightIsRefineable && merged.typeB != null) {\n+        declareNameInScope(informed, right, merged.typeB);\n       }\n       return informed;\n     }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n-import com.google.common.base.Pair;\n+import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.Scope.Var;\n import java.text.MessageFormat;\n import java.util.Iterator;\n import java.util.List;\n-\n \n /**\n  * A central reporter for all type violations: places where the programmer\n    * Type-based optimizations should take this into account\n    * so that they don't wreck code with type warnings.\n    */\n-  static class TypeMismatch extends Pair<JSType, JSType> {\n-    private static final long serialVersionUID = 1;\n+  static class TypeMismatch {\n+    final JSType typeA;\n+    final JSType typeB;\n \n     /**\n      * It's the responsibility of the class that creates the\n      * non-matching types.\n      */\n     TypeMismatch(JSType a, JSType b) {\n-      super(a, b);\n+      this.typeA = a;\n+      this.typeB = b;\n+    }\n+\n+    @Override public boolean equals(Object object) {\n+      if (object instanceof TypeMismatch) {\n+        TypeMismatch that = (TypeMismatch) object;\n+        return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB))\n+            || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB));\n+      }\n+      return false;\n+    }\n+\n+    @Override public int hashCode() {\n+      return Objects.hashCode(typeA, typeB);\n+    }\n+\n+    @Override public String toString() {\n+      return \"(\" + typeA + \", \" + typeB + \")\";\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/graph/Graph.java\n+++ b/src/com/google/javascript/jscomp/graph/Graph.java\n \n package com.google.javascript.jscomp.graph;\n \n-import com.google.common.base.Pair;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n \n  */\n public abstract class Graph<N, E> implements AdjacencyGraph<N, E> {\n   /**\n-   * Pseudo typedef for Pair<Annotatable, Annotation>. Record of an object's\n+   * Pseudo typedef for a pair of annotations. Record of an object's\n    * annotation at some state.\n    */\n-  private static final class AnnotationState extends\n-      Pair<Annotatable, Annotation> {\n-    private static final long serialVersionUID = 1L;\n-    \n+  private static final class AnnotationState {\n+    private final Annotatable first;\n+    private final Annotation second;\n+\n     public AnnotationState(Annotatable annotatable, Annotation annotation) {\n-      super(annotatable, annotation);\n+      this.first = annotatable;\n+      this.second = annotation;\n     }\n   }\n \n    */\n   private static class GraphAnnotationState extends ArrayList<AnnotationState> {\n     private static final long serialVersionUID = 1L;\n-    \n+\n     public GraphAnnotationState(int size) {\n       super(size);\n     }\n    * @return The newly created graph edge.\n    */\n   public abstract GraphEdge<N, E> connect(N n1, E edge, N n2);\n-  \n+\n   /**\n    * Disconnects two nodes in the graph by removing all edges between them.\n    *\n    * @return A list of neighboring nodes.\n    */\n   public abstract List<GraphNode<N, E>> getNeighborNodes(N value);\n-  \n+\n   public abstract Iterator<GraphNode<N, E>> getNeighborNodesIterator(N value);\n \n   /**\n \n   /**\n    * A generic edge.\n-   * \n+   *\n    * @param <N> Value type that the graph node stores.\n    * @param <E> Value type that the graph edge stores.\n    */\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n package com.google.javascript.rhino;\n \n-import com.google.common.base.Pair;\n+import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.jstype.JSType;\n \n      * Returns null if it's equal, or a message describing the differences.\n      */\n     public String checkTreeEquals(Node node2) {\n-        Pair<Node, Node> diff = checkTreeEqualsImpl(node2);\n+        NodeMismatch diff = checkTreeEqualsImpl(node2);\n         if (diff != null) {\n           return \"Node tree inequality:\" +\n               \"\\nTree1:\\n\" + toStringTree() +\n      * of nodes that differs doing a preorder depth-first traversal.\n      * Package private for testing. Returns null if the nodes are equivalent.\n      */\n-    Pair<Node, Node> checkTreeEqualsImpl(Node node2) {\n+    NodeMismatch checkTreeEqualsImpl(Node node2) {\n         boolean eq = false;\n \n         if (type == node2.getType() &&\n         }\n \n         if (!eq) {\n-            return Pair.of(this, node2);\n-        }\n-\n-        Pair<Node, Node> res = null;\n+            return new NodeMismatch(this, node2);\n+        }\n+\n+        NodeMismatch res = null;\n         Node n, n2;\n         for (n = first, n2 = node2.first;\n              res == null && n != null;\n     public void setQuotedString() {\n         Kit.codeBug();\n     }\n+\n+    static class NodeMismatch {\n+      final Node nodeA;\n+      final Node nodeB;\n+\n+      NodeMismatch(Node nodeA, Node nodeB) {\n+        this.nodeA = nodeA;\n+        this.nodeB = nodeB;\n+      }\n+\n+      @Override public boolean equals(Object object) {\n+        if (object instanceof NodeMismatch) {\n+          NodeMismatch that = (NodeMismatch) object;\n+          return that.nodeA.equals(this.nodeA) && that.nodeB.equals(this.nodeB);\n+        }\n+        return false;\n+      }\n+\n+      @Override public int hashCode() {\n+        return Objects.hashCode(nodeA, nodeB);\n+      }\n+    }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.JSDocInfo;\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}\n    */\n-  public Pair<JSType, JSType> getTypesUnderEquality(JSType that) {\n+  public TypePair getTypesUnderEquality(JSType that) {\n     // unions types\n     if (that instanceof UnionType) {\n-      Pair<JSType, JSType> p = that.getTypesUnderEquality(this);\n-      return Pair.of(p.second, p.first);\n+      TypePair p = that.getTypesUnderEquality(this);\n+      return new TypePair(p.typeB, p.typeA);\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case FALSE:\n-        return Pair.of(null, null);\n+        return new TypePair(null, null);\n \n       case TRUE:\n       case UNKNOWN:\n-        return Pair.of(this, that);\n+        return new TypePair(this, that);\n     }\n \n     // switch case is exhaustive\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}\n    */\n-  public Pair<JSType, JSType> getTypesUnderInequality(JSType that) {\n+  public TypePair getTypesUnderInequality(JSType that) {\n     // unions types\n     if (that instanceof UnionType) {\n-      Pair<JSType, JSType> p = that.getTypesUnderInequality(this);\n-      return Pair.of(p.second, p.first);\n+      TypePair p = that.getTypesUnderInequality(this);\n+      return new TypePair(p.typeB, p.typeA);\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return Pair.of(null, null);\n+        return new TypePair(null, null);\n \n       case FALSE:\n       case UNKNOWN:\n-        return Pair.of(this, that);\n+        return new TypePair(this, that);\n     }\n \n     // switch case is exhaustive\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}.\n    */\n-  public Pair<JSType, JSType> getTypesUnderShallowEquality(JSType that) {\n+  public TypePair getTypesUnderShallowEquality(JSType that) {\n     JSType commonType = getGreatestSubtype(that);\n-    return new Pair<JSType, JSType>(commonType, commonType);\n+    return new TypePair(commonType, commonType);\n   }\n \n   /**\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}\n    */\n-  public Pair<JSType, JSType> getTypesUnderShallowInequality(JSType that) {\n+  public TypePair getTypesUnderShallowInequality(JSType that) {\n     // union types\n     if (that instanceof UnionType) {\n-      Pair<JSType, JSType> p = that.getTypesUnderShallowInequality(this);\n-      return Pair.of(p.second, p.first);\n+      TypePair p = that.getTypesUnderShallowInequality(this);\n+      return new TypePair(p.typeB, p.typeA);\n     }\n \n     // Other types.\n     // true -- null and undefined. We can just enumerate them.\n     if (this.isNullType() && that.isNullType() ||\n         this.isVoidType() && that.isVoidType()) {\n-      return Pair.of(null, null);\n+      return new TypePair(null, null);\n     } else {\n-      return Pair.of(this, that);\n+      return new TypePair(this, that);\n     }\n   }\n \n    * @return the value returned by the visitor\n    */\n   public abstract <T> T visit(Visitor<T> visitor);\n+\n+  public static class TypePair {\n+    public final JSType typeA;\n+    public final JSType typeB;\n+\n+    public TypePair(JSType typeA, JSType typeB) {\n+      this.typeA = typeA;\n+      this.typeB = typeB;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.base.Pair;\n+import com.google.javascript.rhino.jstype.JSType.TypePair;\n \n import java.util.Set;\n import java.util.SortedSet;\n   }\n \n   @Override\n-  public Pair<JSType, JSType> getTypesUnderEquality(JSType that) {\n+  public TypePair getTypesUnderEquality(JSType that) {\n     UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);\n     UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);\n     for (JSType element : alternates) {\n-      Pair<JSType, JSType> p = element.getTypesUnderEquality(that);\n-      if (p.first != null) {\n-        thisRestricted.addAlternate(p.first);\n-      }\n-      if (p.second != null) {\n-        thatRestricted.addAlternate(p.second);\n-      }\n-    }\n-    return Pair.of(\n+      TypePair p = element.getTypesUnderEquality(that);\n+      if (p.typeA != null) {\n+        thisRestricted.addAlternate(p.typeA);\n+      }\n+      if (p.typeB != null) {\n+        thatRestricted.addAlternate(p.typeB);\n+      }\n+    }\n+    return new TypePair(\n         thisRestricted.build(),\n         thatRestricted.build());\n   }\n \n   @Override\n-  public Pair<JSType, JSType> getTypesUnderInequality(JSType that) {\n+  public TypePair getTypesUnderInequality(JSType that) {\n     UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);\n     UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);\n     for (JSType element : alternates) {\n-      Pair<JSType, JSType> p = element.getTypesUnderInequality(that);\n-      if (p.first != null) {\n-        thisRestricted.addAlternate(p.first);\n-      }\n-      if (p.second != null) {\n-        thatRestricted.addAlternate(p.second);\n-      }\n-    }\n-    return Pair.of(\n+      TypePair p = element.getTypesUnderInequality(that);\n+      if (p.typeA != null) {\n+        thisRestricted.addAlternate(p.typeA);\n+      }\n+      if (p.typeB != null) {\n+        thatRestricted.addAlternate(p.typeB);\n+      }\n+    }\n+    return new TypePair(\n         thisRestricted.build(),\n         thatRestricted.build());\n   }\n \n   @Override\n-  public Pair<JSType, JSType> getTypesUnderShallowInequality(JSType that) {\n+  public TypePair getTypesUnderShallowInequality(JSType that) {\n     UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);\n     UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);\n     for (JSType element : alternates) {\n-      Pair<JSType, JSType> p = element.getTypesUnderShallowInequality(that);\n-      if (p.first != null) {\n-        thisRestricted.addAlternate(p.first);\n-      }\n-      if (p.second != null) {\n-        thatRestricted.addAlternate(p.second);\n-      }\n-    }\n-    return Pair.of(\n+      TypePair p = element.getTypesUnderShallowInequality(that);\n+      if (p.typeA != null) {\n+        thisRestricted.addAlternate(p.typeA);\n+      }\n+      if (p.typeB != null) {\n+        thatRestricted.addAlternate(p.typeB);\n+      }\n+    }\n+    return new TypePair(\n         thisRestricted.build(),\n         thatRestricted.build());\n   }\n--- a/test/com/google/javascript/jscomp/BasicErrorManagerTest.java\n+++ b/test/com/google/javascript/jscomp/BasicErrorManagerTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Pair;\n+import com.google.javascript.jscomp.BasicErrorManager.ErrorWithLevel;\n import com.google.javascript.jscomp.BasicErrorManager.LeveledJSErrorComparator;\n import com.google.javascript.jscomp.CheckLevel;\n \n     assertSmaller(error(e1), error(e2));\n   }\n \n-  private Pair<JSError, CheckLevel> error(JSError e) {\n-    return Pair.of(e, CheckLevel.ERROR);\n+  private ErrorWithLevel error(JSError e) {\n+    return new ErrorWithLevel(e, CheckLevel.ERROR);\n   }\n \n-  private Pair<JSError, CheckLevel> warning(JSError e) {\n-    return Pair.of(e, CheckLevel.WARNING);\n+  private ErrorWithLevel warning(JSError e) {\n+    return new ErrorWithLevel(e, CheckLevel.WARNING);\n   }\n \n-  private void assertSmaller(Pair<JSError, CheckLevel> p1,\n-      Pair<JSError, CheckLevel> p2) {\n+  private void assertSmaller(ErrorWithLevel p1, ErrorWithLevel p2) {\n     int p1p2 = comparator.compare(p1, p2);\n     assertTrue(Integer.toString(p1p2), p1p2 < 0);\n     int p2p1 = comparator.compare(p2, p1);\n--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n         createVar(blind, \"a\", createNullableType(OBJECT_TYPE)),\n         createVar(blind, \"b\", createNullableType(OBJECT_TYPE)),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", OBJECT_TYPE),\n-            new Pair<String, JSType>(\"b\", OBJECT_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", NULL_TYPE),\n-            new Pair<String, JSType>(\"b\", NULL_TYPE)));\n+            new TypedName(\"a\", OBJECT_TYPE),\n+            new TypedName(\"b\", OBJECT_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"a\", NULL_TYPE),\n+            new TypedName(\"b\", NULL_TYPE)));\n   }\n \n   /**\n         Token.SHEQ,\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n         createNumber(56),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE))));\n   }\n \n         Token.SHEQ,\n         createNumber(56),\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE))));\n   }\n \n         Token.SHEQ,\n         createVar(blind, \"b\", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n-            new Pair<String, JSType>(\"b\", STRING_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\", STRING_TYPE),\n+            new TypedName(\"b\", STRING_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-            new Pair<String, JSType>(\"b\",\n+            new TypedName(\"b\",\n                 createUnionType(STRING_TYPE, BOOLEAN_TYPE))));\n   }\n \n         Token.SHEQ,\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", STRING_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         Token.SHEQ,\n         createVar(blind, \"a\", createUnionType(NULL_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NULL_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", NULL_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\",\n+            new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"a\",\n                 createUnionType(STRING_TYPE, VOID_TYPE)),\n-            new Pair<String, JSType>(\"b\",\n+            new TypedName(\"b\",\n                 createUnionType(NUMBER_TYPE, VOID_TYPE))));\n   }\n \n         Token.SHNE,\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n         createNumber(56),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE))),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)));\n   }\n \n   /**\n         Token.SHNE,\n         createNumber(56),\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE))),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)));\n   }\n \n   /**\n         Token.SHNE,\n         createVar(blind, \"b\", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+        Sets.newHashSet(new TypedName(\"a\",\n             createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-            new Pair<String, JSType>(\"b\",\n+            new TypedName(\"b\",\n                 createUnionType(STRING_TYPE, BOOLEAN_TYPE))),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n-            new Pair<String, JSType>(\"b\", STRING_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", STRING_TYPE),\n+            new TypedName(\"b\", STRING_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         Token.SHNE,\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", STRING_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         Token.SHNE,\n         createVar(blind, \"a\", createUnionType(NULL_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(NULL_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", NULL_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NULL_TYPE),\n-            new Pair<String, JSType>(\"b\", NULL_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", NULL_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", NULL_TYPE),\n+            new TypedName(\"b\", NULL_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n         createVar(blind, \"b\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\",\n+            new TypedName(\"a\",\n                 createUnionType(STRING_TYPE, VOID_TYPE)),\n-            new Pair<String, JSType>(\"b\",\n+            new TypedName(\"b\",\n                 createUnionType(NUMBER_TYPE, VOID_TYPE))),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", VOID_TYPE),\n-            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+            new TypedName(\"a\", VOID_TYPE),\n+            new TypedName(\"b\", VOID_TYPE)));\n   }\n \n   /**\n         Token.EQ,\n         createVar(blind, \"a\", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),\n         createNull(),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", BOOLEAN_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", BOOLEAN_TYPE)));\n   }\n \n   /**\n         Token.NE,\n         createNull(),\n         createVar(blind, \"a\", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", BOOLEAN_TYPE)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", BOOLEAN_TYPE)),\n+        Sets.newHashSet(new TypedName(\"a\", VOID_TYPE)));\n   }\n \n   /**\n         Token.EQ,\n         createVar(blind, \"a\", nullableOptionalNumber),\n         createNull(),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", nullUndefined)),\n-        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+        Sets.newHashSet(new TypedName(\"a\", nullUndefined)),\n+        Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE)));\n   }\n \n   /**\n           createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n           createNumber(8),\n           Sets.newHashSet(\n-              new Pair<String, JSType>(\"a\", STRING_TYPE)),\n-          Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+              new TypedName(\"a\", STRING_TYPE)),\n+          Sets.newHashSet(new TypedName(\"a\",\n               createUnionType(STRING_TYPE, VOID_TYPE))));\n     }\n   }\n           createVar(blind, \"b\",\n               createUnionType(NUMBER_TYPE, NULL_TYPE)),\n           Sets.newHashSet(\n-              new Pair<String, JSType>(\"a\",\n+              new TypedName(\"a\",\n               createUnionType(STRING_TYPE, NUMBER_TYPE)),\n-              new Pair<String, JSType>(\"b\",\n+              new TypedName(\"b\",\n               createUnionType(NUMBER_TYPE, NULL_TYPE))),\n           Sets.newHashSet(\n-              new Pair<String, JSType>(\"a\",\n+              new TypedName(\"a\",\n               createUnionType(STRING_TYPE, NUMBER_TYPE, VOID_TYPE)),\n-              new Pair<String, JSType>(\"b\",\n+              new TypedName(\"b\",\n               createUnionType(NUMBER_TYPE, NULL_TYPE))));\n     }\n   }\n           createUntypedNumber(8),\n           createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n           Sets.newHashSet(\n-              new Pair<String, JSType>(\"a\", STRING_TYPE)),\n-          Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+              new TypedName(\"a\", STRING_TYPE)),\n+          Sets.newHashSet(new TypedName(\"a\",\n               createUnionType(STRING_TYPE, VOID_TYPE))));\n     }\n   }\n       Token.AND,\n       createVar(blind, \"b\", createUnionType(STRING_TYPE, NULL_TYPE)),\n       createVar(blind, \"a\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n-      Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE),\n-          new Pair<String, JSType>(\"b\", STRING_TYPE)),\n-      Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+      Sets.newHashSet(new TypedName(\"a\", NUMBER_TYPE),\n+          new TypedName(\"b\", STRING_TYPE)),\n+      Sets.newHashSet(new TypedName(\"a\",\n           createUnionType(NUMBER_TYPE, VOID_TYPE)),\n-          new Pair<String, JSType>(\"b\",\n+          new TypedName(\"b\",\n           createUnionType(STRING_TYPE, NULL_TYPE))));\n   }\n \n         new Node(Token.TYPEOF, createVar(blind, \"a\", OBJECT_TYPE)),\n         Node.newString(\"function\"),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", U2U_CONSTRUCTOR_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", OBJECT_TYPE)));\n+            new TypedName(\"a\", U2U_CONSTRUCTOR_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"a\", OBJECT_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         new Node(Token.TYPEOF, createVar(blind, \"a\", ALL_TYPE)),\n         Node.newString(\"function\"),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", U2U_CONSTRUCTOR_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"a\", ALL_TYPE)));\n+            new TypedName(\"a\", U2U_CONSTRUCTOR_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"a\", ALL_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         createVar(blind, \"x\", UNKNOWN_TYPE),\n         createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+            new TypedName(\"x\", STRING_OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n             createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE)),\n         createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", NUMBER_OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+            new TypedName(\"x\", STRING_OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"x\", NUMBER_OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         createVar(blind, \"x\", OBJECT_TYPE),\n         createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+            new TypedName(\"x\", STRING_OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"x\", OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n         createVar(blind, \"x\", ALL_TYPE),\n         createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n         Sets.newHashSet(\n-            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n-        Sets.newHashSet(\n-            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+            new TypedName(\"x\", STRING_OBJECT_TYPE),\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new TypedName(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n   }\n \n   private void testBinop(FlowScope blind, int binop, Node left, Node right,\n-      Collection<Pair<String, JSType>> trueOutcome,\n-      Collection<Pair<String, JSType>> falseOutcome) {\n+      Collection<TypedName> trueOutcome,\n+      Collection<TypedName> falseOutcome) {\n     Node condition = new Node(binop);\n     condition.addChildToBack(left);\n     condition.addChildToBack(right);\n     // true outcome.\n     FlowScope informedTrue = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n-    for (Pair<String, JSType> p : trueOutcome) {\n-      assertEquals(p.first, p.second, getVarType(informedTrue, p.first));\n+    for (TypedName p : trueOutcome) {\n+      assertEquals(p.name, p.type, getVarType(informedTrue, p.name));\n     }\n \n     // false outcome.\n     FlowScope informedFalse = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n-    for (Pair<String, JSType> p : falseOutcome) {\n-      assertEquals(p.second, getVarType(informedFalse, p.first));\n+    for (TypedName p : falseOutcome) {\n+      assertEquals(p.type, getVarType(informedFalse, p.name));\n     }\n   }\n \n     n.setJSType(type);\n     return n;\n   }\n+\n+  private static class TypedName {\n+    private final String name;\n+    private final JSType type;\n+\n+    private TypedName(String name, JSType type) {\n+      this.name = name;\n+      this.type = type;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Joiner;\n-import com.google.common.base.Pair;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n   }\n \n   public void testScoping10() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n \n     // a declared, b is not\n-    assertTrue(p.second.isDeclared(\"a\", false));\n-    assertFalse(p.second.isDeclared(\"b\", false));\n+    assertTrue(p.scope.isDeclared(\"a\", false));\n+    assertFalse(p.scope.isDeclared(\"b\", false));\n \n     // checking that a has the correct assigned type\n-    assertEquals(\"function (): ?\", p.second.getVar(\"a\").getType().toString());\n+    assertEquals(\"function (): ?\", p.scope.getVar(\"a\").getType().toString());\n   }\n \n   public void testScoping11() throws Exception {\n   }\n \n   public void testVar1() throws Exception {\n-    Pair<Node, Scope> p =\n+    TypeCheckResult p =\n         parseAndTypeCheckWithScope(\"/** @type {(string,null)} */var a = null\");\n \n     assertEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n-        p.getSecond().getVar(\"a\").getType());\n+        p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar2() throws Exception {\n   }\n \n   public void testVar3() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = 3;\");\n-\n-    assertEquals(NUMBER_TYPE, p.second.getVar(\"a\").getType());\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = 3;\");\n+\n+    assertEquals(NUMBER_TYPE, p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar4() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var a = 3; a = 'string';\");\n \n     assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n-        p.second.getVar(\"a\").getType());\n+        p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar5() throws Exception {\n    */\n   public void testBug911118() throws Exception {\n     // verifying the type assigned to anonymous functions assigned variables\n-    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").second;\n+    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n     JSType type = s.getVar(\"a\").getType();\n     assertEquals(\"function (): ?\", type.toString());\n \n   }\n \n   public void testNew6() throws Exception {\n-    Pair<Node, Scope> p =\n+    TypeCheckResult p =\n       parseAndTypeCheckWithScope(\"/** @constructor */function A(){};\" +\n       \"var a = new A();\");\n \n-    JSType aType = p.getSecond().getVar(\"a\").getType();\n+    JSType aType = p.scope.getVar(\"a\").getType();\n     assertTrue(aType instanceof ObjectType);\n     ObjectType aObjectType = (ObjectType) aType;\n     assertEquals(\"A\", aObjectType.getConstructor().getReferenceName());\n   }\n \n   public void testNew12() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = new Array();\");\n-    Var a = p.second.getVar(\"a\");\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = new Array();\");\n+    Var a = p.scope.getVar(\"a\");\n \n     assertEquals(ARRAY_TYPE, a.getType());\n   }\n \n   public void testNew13() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"/** @constructor */function FooBar(){};\" +\n         \"var a = new FooBar();\");\n-    Var a = p.second.getVar(\"a\");\n+    Var a = p.scope.getVar(\"a\");\n \n     assertTrue(a.getType() instanceof ObjectType);\n     assertEquals(\"FooBar\", a.getType().toString());\n   }\n \n   public void testNew14() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"/** @constructor */var FooBar = function(){};\" +\n         \"var a = new FooBar();\");\n-    Var a = p.second.getVar(\"a\");\n+    Var a = p.scope.getVar(\"a\");\n \n     assertTrue(a.getType() instanceof ObjectType);\n     assertEquals(\"FooBar\", a.getType().toString());\n   }\n \n   public void testNew15() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var goog = {};\" +\n         \"/** @constructor */goog.A = function(){};\" +\n         \"var a = new goog.A();\");\n-    Var a = p.second.getVar(\"a\");\n+    Var a = p.scope.getVar(\"a\");\n \n     assertTrue(a.getType() instanceof ObjectType);\n     assertEquals(\"goog.A\", a.getType().toString());\n   }\n \n   public void testConstructorType7() throws Exception {\n-    Pair<Node, Scope> p =\n+    TypeCheckResult p =\n         parseAndTypeCheckWithScope(\"/** @constructor */function A(){};\");\n \n-    JSType type = p.getSecond().getVar(\"A\").getType();\n+    JSType type = p.scope.getVar(\"A\").getType();\n     assertTrue(type instanceof FunctionType);\n     FunctionType fType = (FunctionType) type;\n     assertEquals(\"A\", fType.getReferenceName());\n       \"goog.foo = {};\" +\n       \"goog.foo.bar = 5;\";\n \n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(js);\n+    TypeCheckResult p = parseAndTypeCheckWithScope(js);\n \n     // goog type in the scope\n-    JSType googScopeType = p.second.getVar(\"goog\").getType();\n+    JSType googScopeType = p.scope.getVar(\"goog\").getType();\n     assertTrue(googScopeType instanceof ObjectType);\n     assertTrue(\"foo property not present on goog type\",\n         ((ObjectType) googScopeType).hasProperty(\"foo\"));\n         ((ObjectType) googScopeType).hasProperty(\"bar\"));\n \n     // goog type on the VAR node\n-    Node varNode = p.first.getFirstChild();\n+    Node varNode = p.root.getFirstChild();\n     assertEquals(Token.VAR, varNode.getType());\n     JSType googNodeType = varNode.getFirstChild().getJSType();\n     assertTrue(googNodeType instanceof ObjectType);\n \n   public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1()\n       throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var goog = {};\" +\n         \"goog.A = /** @constructor */function() {};\" +\n         \"/** @type number */goog.A.prototype.m1 = 5\");\n \n   public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2()\n       throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var goog = {};\" +\n         \"/** @constructor */goog.A = function() {};\" +\n         \"/** @type number */goog.A.prototype.m1 = 5\");\n   }\n \n   private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n-      Pair<Node, Scope> p) {\n-    ObjectType goog = (ObjectType) p.second.getVar(\"goog\").getType();\n+      TypeCheckResult p) {\n+    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n     JSType googA = goog.getPropertyType(\"A\");\n     assertNotNull(googA);\n   }\n \n   public void testGatherProperyWithoutAnnotation2() throws Exception {\n-    Pair<Node, Scope> ns =\n+    TypeCheckResult ns =\n         parseAndTypeCheckWithScope(\"/** @type {!Object} */var t; t.x; t;\");\n-    Node n = ns.getFirst();\n-    Scope s = ns.getSecond();\n+    Node n = ns.root;\n+    Scope s = ns.scope;\n     JSType type = n.getLastChild().getLastChild().getJSType();\n     assertFalse(type.isUnknownType());\n     assertEquals(type, OBJECT_TYPE);\n   }\n \n   public void testPrototypePropertyReference() throws Exception {\n-    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"\"\n+    TypeCheckResult p = parseAndTypeCheckWithScope(\"\"\n         + \"/** @constructor */\\n\"\n         + \"function Foo() {}\\n\"\n         + \"/** @param {number} a */\\n\"\n     assertEquals(0, compiler.getErrorCount());\n     assertEquals(0, compiler.getWarningCount());\n \n-    assertTrue(p.second.getVar(\"Foo\").getType() instanceof FunctionType);\n-    FunctionType fooType = (FunctionType) p.second.getVar(\"Foo\").getType();\n+    assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n+    FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n     assertEquals(\"function (this:Foo, number): ?\",\n                  fooType.getPrototype().getPropertyType(\"bar\").toString());\n   }\n   }\n \n   private Node parseAndTypeCheck(String externs, String js) {\n-    return parseAndTypeCheckWithScope(externs, js).getFirst();\n+    return parseAndTypeCheckWithScope(externs, js).root;\n   }\n \n   /**\n    * Parses and type checks the JavaScript code and returns the Scope used\n    * whilst type checking.\n    */\n-  private Pair<Node, Scope> parseAndTypeCheckWithScope(String js) {\n+  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n     return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n   }\n \n-  private Pair<Node, Scope> parseAndTypeCheckWithScope(String externs,\n+  private TypeCheckResult parseAndTypeCheckWithScope(String externs,\n                                                        String js) {\n     Node externsNode = compiler.parseTestCode(externs);\n     Node n = compiler.parseTestCode(js);\n         0, compiler.getErrorCount());\n \n     Scope s = makeTypeCheck().processForTesting(externsNode, n);\n-    return new Pair<Node, Scope>(n, s);\n+    return new TypeCheckResult(n, s);\n   }\n \n   private Node typeCheck(Node n) {\n     }\n     return result + \"}\";\n   }\n+\n+  private static class TypeCheckResult {\n+    private final Node root;\n+    private final Scope scope;\n+\n+    private TypeCheckResult(Node root, Scope scope) {\n+      this.root = root;\n+      this.scope = scope;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n package com.google.javascript.jscomp.parsing;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.ImmutableList;\n import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n import com.google.javascript.jscomp.testing.TestErrorReporter;\n   public void testParse() {\n     Node a = Node.newString(Token.NAME, \"a\");\n     a.addChildToFront(Node.newString(Token.NAME, \"b\"));\n-    List<Pair<String, Node>> testCases = ImmutableList.of(\n-        Pair.of(\n+    List<ParserResult> testCases = ImmutableList.of(\n+        new ParserResult(\n             \"3;\",\n             createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),\n-        Pair.of(\n+        new ParserResult(\n             \"var a = b;\",\n              createScript(new Node(Token.VAR, a))),\n-        Pair.of(\n+        new ParserResult(\n             \"\\\"hell\\\\\\no\\\\ world\\\\\\n\\\\\\n!\\\"\",\n              createScript(new Node(Token.EXPR_RESULT,\n              Node.newString(Token.STRING, \"hello world!\")))));\n \n-    for (Pair<String, Node> testCase : testCases) {\n-      assertNodeEquality(testCase.second, parse(testCase.first));\n+    for (ParserResult testCase : testCases) {\n+      assertNodeEquality(testCase.node, parse(testCase.code));\n     }\n   }\n \n \n     return script;\n   }\n+\n+  private static class ParserResult {\n+    private final String code;\n+    private final Node node;\n+\n+    private ParserResult(String code, Node node) {\n+      this.code = code;\n+      this.node = node;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n \n package com.google.javascript.rhino;\n \n-import com.google.common.base.Pair;\n+import com.google.javascript.rhino.Node.NodeMismatch;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n \n import junit.framework.TestCase;\n   public void testCheckTreeEqualsImplDifferentType() {\n     Node node1 = new Node(1, new Node(2));\n     Node node2 = new Node(2, new Node(2));\n-    assertEquals(Pair.of(node1, node2), node1.checkTreeEqualsImpl(node2));\n+    assertEquals(new NodeMismatch(node1, node2),\n+        node1.checkTreeEqualsImpl(node2));\n   }\n \n   public void testCheckTreeEqualsImplDifferentChildCount() {\n     Node node1 = new Node(1, new Node(2));\n     Node node2 = new Node(1);\n-    assertEquals(Pair.of(node1, node2), node1.checkTreeEqualsImpl(node2));\n+    assertEquals(new NodeMismatch(node1, node2),\n+        node1.checkTreeEqualsImpl(node2));\n   }\n \n   public void testCheckTreeEqualsImplDifferentChild() {\n     Node child2 = new Node(2);\n     Node node1 = new Node(1, child1);\n     Node node2 = new Node(1, child2);\n-    assertEquals(Pair.of(child1, child2), node1.checkTreeEqualsImpl(node2));\n+    assertEquals(new NodeMismatch(child1, child2),\n+        node1.checkTreeEqualsImpl(node2));\n   }\n \n   public void testCheckTreeEqualsSame() {\n--- a/test/com/google/javascript/rhino/ParserTest.java\n+++ b/test/com/google/javascript/rhino/ParserTest.java\n \n package com.google.javascript.rhino;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n   public void testParse() {\n     Node a = Node.newString(Token.NAME, \"a\");\n     a.addChildToFront(Node.newString(Token.NAME, \"b\"));\n-    List<Pair<String, Node>> testCases = ImmutableList.of(\n-        Pair.of(\n+    List<ParserResult> testCases = ImmutableList.of(\n+        new ParserResult(\n             \"3;\",\n             createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),\n-        Pair.of(\n+        new ParserResult(\n             \"var a = b;\",\n              createScript(new Node(Token.VAR, a))),\n-        Pair.of(\n+        new ParserResult(\n             \"\\\"hell\\\\\\no\\\\ world\\\\\\n\\\\\\n!\\\"\",\n              createScript(new Node(Token.EXPR_RESULT,\n              Node.newString(Token.STRING, \"hello world!\")))));\n \n-    for (Pair<String, Node> testCase : testCases) {\n-      assertNodeEquality(testCase.second, parse(testCase.first));\n+    for (ParserResult testCase : testCases) {\n+      assertNodeEquality(testCase.node, parse(testCase.code));\n     }\n   }\n \n \n     return script;\n   }\n+\n+  private static class ParserResult {\n+    private final String code;\n+    private final Node node;\n+\n+    private ParserResult(String code, Node node) {\n+      this.code = code;\n+      this.node = node;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.base.Pair;\n import com.google.common.collect.Lists;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.jstype.JSType.TypePair;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n   private void testGetTypeUnderEquality(\n       JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n     // creating the pairs\n-    Pair<JSType, JSType> p12 = t1.getTypesUnderEquality(t2);\n-    Pair<JSType, JSType> p21 = t2.getTypesUnderEquality(t1);\n+    TypePair p12 = t1.getTypesUnderEquality(t2);\n+    TypePair p21 = t2.getTypesUnderEquality(t1);\n \n     // t1Eq\n-    assertEquals(t1Eq, p12.first);\n-    assertEquals(t1Eq, p21.second);\n+    assertEquals(t1Eq, p12.typeA);\n+    assertEquals(t1Eq, p21.typeB);\n \n     // t2Eq\n-    assertEquals(t2Eq, p12.second);\n-    assertEquals(t2Eq, p21.first);\n+    assertEquals(t2Eq, p12.typeB);\n+    assertEquals(t2Eq, p21.typeA);\n   }\n \n   @SuppressWarnings(\"checked\")\n   private void testGetTypesUnderInequality(\n       JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n     // creating the pairs\n-    Pair<JSType, JSType> p12 = t1.getTypesUnderInequality(t2);\n-    Pair<JSType, JSType> p21 = t2.getTypesUnderInequality(t1);\n+    TypePair p12 = t1.getTypesUnderInequality(t2);\n+    TypePair p21 = t2.getTypesUnderInequality(t1);\n \n     // t1Eq\n-    assertEquals(t1Eq, p12.first);\n-    assertEquals(t1Eq, p21.second);\n+    assertEquals(t1Eq, p12.typeA);\n+    assertEquals(t1Eq, p21.typeB);\n \n     // t2Eq\n-    assertEquals(t2Eq, p12.second);\n-    assertEquals(t2Eq, p21.first);\n+    assertEquals(t2Eq, p12.typeB);\n+    assertEquals(t2Eq, p21.typeA);\n   }\n \n ", "timestamp": 1263592560, "metainfo": ""}