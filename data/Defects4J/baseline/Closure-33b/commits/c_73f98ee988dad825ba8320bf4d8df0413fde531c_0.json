{"sha": "73f98ee988dad825ba8320bf4d8df0413fde531c", "log": "Lay the groundwork for the my next call optimization.  R=acleung DELTA=428  (267 added, 117 deleted, 44 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(optimizeArgumentsArray);\n     }\n \n-    // Remove all parameters that are constants or unused.\n-    if (options.optimizeParameters) {\n-      passes.add(removeUselessParameters);\n-    }\n-\n     // Abstract method removal works best on minimally modified code, and also\n     // only needs to run once.\n     if (options.closurePass &&\n     // optimizations based on global names (like cross module code motion\n     // and inline functions).  Smart Name Removal does better if run before\n     // this pass.\n-    if (options.devirtualizePrototypeMethods) {\n+    if (options.devirtualizePrototypeMethods\n+        || options.optimizeReturns\n+        || options.optimizeParameters) {\n       passes.add(optimizeCalls);\n     }\n \n     }\n   };\n \n-  /** Removes unused or constant formal parameters. */\n-  private final PassFactory removeUselessParameters =\n-      new PassFactory(\"optimizeParameters\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      return new CompilerPass() {\n-        @Override public void process(Node externs, Node root) {\n-          NameReferenceGraphConstruction c =\n-              new NameReferenceGraphConstruction(compiler);\n-          c.process(externs, root);\n-\n-          (new OptimizeParameters(compiler, c.getNameReferenceGraph())).process(\n-              externs, root);\n-        }\n-      };\n-    }\n-  };\n-\n   /** Remove variables set to goog.abstractMethod. */\n   private final PassFactory closureCodeRemoval =\n       new PassFactory(\"closureCodeRemoval\", true) {\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       OptimizeCalls passes = new OptimizeCalls(compiler);\n       if (options.optimizeReturns) {\n+        // Remove unused return values.\n         passes.addPass(new OptimizeReturns(compiler));\n       }\n-      // Devirtualize must be last as it modifies the the values\n-      // represented by the simple definition finder.\n-      passes.addPass(new DevirtualizePrototypeMethods(compiler));\n+\n+      if (options.optimizeParameters) {\n+        // Remove all parameters that are constants or unused.\n+        passes.addPass(new OptimizeParameters(compiler));\n+      }\n+\n+      if (options.devirtualizePrototypeMethods) {\n+        passes.addPass(new DevirtualizePrototypeMethods(compiler));\n+      }\n       return passes;\n     }\n   };\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n    */\n   static Definition getDefinition(Node n, boolean isExtern) {\n     // TODO(user): Since we have parent pointers handy. A lot of constructors\n-    // can be simplied.\n-\n+    // can be simplified.\n+\n+    // This logic must match #isDefinitionNode\n     Node parent = n.getParent();\n     if (parent == null) {\n       return null;\n     return null;\n   }\n \n+  /**\n+   * @return Whether a definition object can be created.\n+   */\n+  static boolean isDefinitionNode(Node n) {\n+    // This logic must match #getDefinition\n+    Node parent = n.getParent();\n+    if (parent == null) {\n+      return false;\n+    }\n+\n+    if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n+      return true;\n+    } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n+      if (!NodeUtil.isFunctionExpression(parent)) {\n+        return true;\n+      } else if (!n.getString().equals(\"\")) {\n+        return true;\n+      }\n+    } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n+      return true;\n+    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n+      return true;\n+    } else if (parent.getType() == Token.LP) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+\n   static abstract class Definition {\n \n     private final boolean isExtern;\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n   public void process(Node externs, Node root) {\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n-    process(defFinder);\n+    process(externs, root, defFinder);\n   }\n \n   @Override\n-  public void process(SimpleDefinitionFinder definitions) {\n+  public void process(\n+      Node externs, Node root, SimpleDefinitionFinder definitions) {\n     for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n       rewriteDefinitionIfEligible(defSite, definitions);\n     }\n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n \n     for (UseSite site : useSites) {\n-\n       // Accessing the property directly prevents rewrite.\n       if (!isCall(site)) {\n         return false;\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n  *\n  */\n public final class NodeUtil {\n+\n+  final static String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n \n   // TODO(user): Eliminate this class and make all of the static methods\n   // instance methods of com.google.javascript.rhino.Node.\n \n   static boolean constructorCallHasSideEffects(\n       Node callNode, AbstractCompiler compiler) {\n-    Preconditions.checkArgument(\n-        callNode.getType() == Token.NEW,\n-        \"Expected NEW node, got \" + Token.name(callNode.getType()));\n+    if (callNode.getType() != Token.NEW) {\n+      throw new IllegalStateException(\n+          \"Expected NEW node, got \" + Token.name(callNode.getType()));\n+    }\n \n     if (callNode.isNoSideEffectsCall()) {\n       return false;\n    */\n   static boolean functionCallHasSideEffects(\n       Node callNode, @Nullable AbstractCompiler compiler) {\n-    Preconditions.checkArgument(\n-        callNode.getType() == Token.CALL,\n-        \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    if (callNode.getType() != Token.CALL) {\n+      throw new IllegalStateException(\n+          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    }\n \n     if (callNode.isNoSideEffectsCall()) {\n       return false;\n   }\n \n   /**\n+   * @param node A node\n+   * @return Whether the call is a NEW or CALL node.\n+   */\n+  static boolean isCallOrNew(Node node) {\n+    return NodeUtil.isCall(node) || NodeUtil.isNew(node);\n+  }\n+\n+  /**\n    * Is this a FUNCTION node?\n    */\n   static boolean isFunction(Node n) {\n             \"\\n parent:\" + value.getParent());\n     }\n   }\n+\n+  /**\n+   * Given the first sibling, this returns the nth\n+   * sibling or null if no such sibling exists.\n+   * This is like \"getChildAtIndex\" but returns null for non-existent indexes.\n+   */\n+  private static Node getNthSibling(Node first, int index) {\n+    Node sibling = first;\n+    while (index != 0 && sibling != null) {\n+      sibling = sibling.getNext();\n+      index--;\n+    }\n+    return sibling;\n+  }\n+\n+  /**\n+   * Given the function, this returns the nth\n+   * argument or null if no such parameter exists.\n+   */\n+  static Node getArgumentForFunction(Node function, int index) {\n+    Preconditions.checkState(isFunction(function));\n+    return getNthSibling(\n+        function.getFirstChild().getNext().getFirstChild(), index);\n+  }\n+\n+  /**\n+   * Given the new or call, this returns the nth\n+   * argument of the call or null if no such argument exists.\n+   */\n+  static Node getArgumentForCallOrNew(Node call, int index) {\n+    Preconditions.checkState(isCallOrNew(call));\n+    return getNthSibling(\n+      call.getFirstChild().getNext(), index);\n+  }\n }\n--- a/src/com/google/javascript/jscomp/OptimizeCalls.java\n+++ b/src/com/google/javascript/jscomp/OptimizeCalls.java\n   }\n   \n   interface CallGraphCompilerPass {\n-    void process(SimpleDefinitionFinder definitions);\n+    void process(Node externs, Node root, SimpleDefinitionFinder definitions);\n   }\n \n   @Override\n       SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n       defFinder.process(externs, root);\n       for (CallGraphCompilerPass pass : passes) {\n-        pass.process(defFinder);\n+        pass.process(externs, root, defFinder);\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n   public void process(Node externs, Node root) {\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n-    process(defFinder);\n+    process(externs, root, defFinder);\n   }\n \n   @Override\n-  public void process(SimpleDefinitionFinder definitions) {\n+  public void process(\n+      Node externs, Node root, SimpleDefinitionFinder definitions) {\n     for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n       if (canChangeSignature(defSite, definitions)) {\n         tryEliminateConstantArgs(defSite, definitions);\n     // maps of functions use in for-in expressions, etc).\n     // Be conservative, don't try to optimize any declaration that isn't as\n     // simple function declaration or assignment.\n-    if (!OptimizeReturns.isSimpleFunctionDeclaration(rValue)) {\n+    if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(rValue)) {\n       return false;\n     }\n \n     // Assume an exported method result is used.\n-    if (OptimizeReturns.maybeExported(compiler, definition)) {\n+    if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n       return false;\n     }\n \n       // Any non-call reference maybe introducing an alias. Don't try to\n       // change the function signature, if all the aliases can't also be\n       // changed.\n-      if (!isCallSite(site.node)) {\n+      if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n         return false;\n       }\n+\n \n       // TODO(johnlenz): support specialization\n \n     Definition definition = defSite.definition;\n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n     for (UseSite site : useSites) {\n-      Preconditions.checkState(isCallSite(site.node));\n+      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));\n       Node call = site.node.getParent();\n \n       int numArgs = call.getChildCount() - 1;\n     Definition definition = defSite.definition;\n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n     for (UseSite site : useSites) {\n-      Preconditions.checkState(isCallSite(site.node));\n+      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));\n       Node call = site.node.getParent();\n \n       Node cur = call.getFirstChild();\n \n     // Remove the constant parameters in all the calls\n     for (UseSite site : useSites) {\n-      Preconditions.checkState(isCallSite(site.node));\n+      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));\n       Node call = site.node.getParent();\n \n       optimizeCallSite(parameters, call);\n   }\n \n   /**\n-   * @param fn A function to check.\n-   * @return true, if it's safe to optimize this function.\n-   */\n-  private boolean isCallSite(Node fn) {\n-    Node call = fn.getParent();\n-    // We need to make sure we're dealing with a call to the function we're\n-    // optimizing. If the the first child of the parent is not the site, this\n-    // is a nested call and it's a call to another function.\n-    return isCallOrNew(call) && call.getFirstChild() == fn;\n-  }\n-\n-  /**\n-   * Return true if the node can be considered a call. For the purpose of this\n-   * class, the new operator is considered a call since it can be optimized\n-   * in the same way.\n-   * @param node A node\n-   * @return True if the node is a call.\n-   */\n-  private boolean isCallOrNew(Node node) {\n-    return NodeUtil.isCall(node) || NodeUtil.isNew(node);\n-  }\n-\n-  /**\n    * Node equality as intended by the this pass.\n    * @param n1 A node\n    * @param n2 A node\n    * @return true if a parameter has been removed.\n    */\n   private boolean eliminateParamsAfter(Node function, int argIndex) {\n-\n     boolean paramRemoved = false;\n \n     Node formalArgPtr = function.getFirstChild().getNext().getFirstChild();\n   }\n \n   /**\n-   * Given the first argument of a function or call, this removes the nth\n-   * argument of the function or call.\n-   * @param firstArg The first arg of the call or function.\n-   * @param argIndex the index of the arg to remove.\n-   * @return the node of the removed argument.\n-   */\n-  private Node getArgumentAtIndex(Node firstArg, int argIndex) {\n-    Node formalArgPtr = firstArg;\n-    while (argIndex != 0 && formalArgPtr != null) {\n-      formalArgPtr = formalArgPtr.getNext();\n-      argIndex--;\n-    }\n-    return formalArgPtr;\n-  }\n-\n-  /**\n    * Eliminates the parameter from a function definition.\n    * @param function The function node\n    * @param argIndex The index of the the argument to remove.\n     Preconditions.checkArgument(NodeUtil.isFunction(function),\n         \"Node must be a function.\");\n \n-    Node formalArgPtr = getArgumentAtIndex(\n-        function.getFirstChild().getNext().getFirstChild(), argIndex);\n+    Node formalArgPtr = NodeUtil.getArgumentForFunction(\n+        function, argIndex);\n \n     if (formalArgPtr != null) {\n       function.getFirstChild().getNext().removeChild(formalArgPtr);\n    * @return The Node of the argument removed.\n    */\n   private Node eliminateCallParamAt(Node call, int argIndex) {\n-    Preconditions.checkArgument(isCallOrNew(call), \"Node must be a call.\");\n-\n-    Node formalArgPtr = getArgumentAtIndex(\n-        call.getFirstChild().getNext(), argIndex);\n+    Preconditions.checkArgument(\n+        NodeUtil.isCallOrNew(call), \"Node must be a call or new.\");\n+\n+    Node formalArgPtr = NodeUtil.getArgumentForCallOrNew(\n+        call, argIndex);\n \n     if (formalArgPtr != null) {\n       call.removeChild(formalArgPtr);\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n   public void process(Node externs, Node root) {\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n-    process(defFinder);\n+    process(externs, root, defFinder);\n   }\n \n   @Override\n-  public void process(SimpleDefinitionFinder definitions) {\n+  public void process(\n+      Node externs, Node root, SimpleDefinitionFinder definitions) {\n     for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n       optimizeResultsIfEligible(defSite, definitions);\n     }\n       return;\n     }\n \n-    rewriteReturns(defSite.definition.getRValue());\n+    rewriteReturns(defFinder, defSite.definition.getRValue());\n   }\n \n   /**\n \n     // Be conservative, don't try to optimize any declaration that isn't as\n     // simple function declaration or assignment.\n-    if (!isSimpleFunctionDeclaration(rValue)) {\n+    if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(rValue)) {\n       return true;\n     }\n \n     // Assume an exported method result is used.\n-    if (maybeExported(compiler, definition)) {\n+    if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n       return true;\n     }\n \n     }\n \n     // No possible use of the definition result\n-    return false;\n-  }\n-\n-  static boolean maybeExported(\n-      AbstractCompiler compiler, Definition definition) {\n-    // Assume an exported method result is used.\n-    Node lValue = definition.getLValue();\n-    if (lValue == null) {\n-      return true;\n-    }\n-\n-    String partialName;\n-    if (NodeUtil.isGetProp(lValue)) {\n-      partialName = lValue.getLastChild().getString();\n-    } else if (NodeUtil.isName(lValue)) {\n-      partialName = lValue.getString();\n-    } else {\n-      // GETELEM is assumed to be an export or other expression are unknown\n-      // uses.\n-      return true;\n-    }\n-\n-    CodingConvention codingConvention = compiler.getCodingConvention();\n-    if (codingConvention.isExported(partialName)) {\n-      return true;\n-    }\n-\n-    return false;\n-  }\n-\n-  static boolean isSimpleFunctionDeclaration(Node fn) {\n-    Node parent = fn.getParent();\n-    Node gramps = parent.getParent();\n-\n-    // Simple definition finder doesn't provide useful results in some\n-    // cases, specifically:\n-    //  - functions with recursive definitions\n-    //  - functions defined in object literals\n-    //  - functions defined in array litersals\n-    // Here we defined a set of known function declaration that are 'ok'.\n-\n-    // example: function a(){};\n-    if (NodeUtil.isFunctionDeclaration(fn)) {\n-      return true;\n-    }\n-\n-    // example: a = function(){};\n-    // example: var a = function(){};\n-    if (fn.getFirstChild().getString().isEmpty()\n-        && (NodeUtil.isExprAssign(gramps) || NodeUtil.isName(parent))) {\n-      return true;\n-    }\n-\n     return false;\n   }\n \n    *    foo(); return;\n    * Useless return will be removed later by the peephole optimization passes.\n    */\n-  private void rewriteReturns(Node fnNode) {\n+  private void rewriteReturns(\n+      final SimpleDefinitionFinder defFinder, Node fnNode) {\n     Preconditions.checkState(NodeUtil.isFunction(fnNode));\n     NodeUtil.visitPostOrder(\n       fnNode.getLastChild(),\n         @Override\n         public void visit(Node node) {\n           if (node.getType() == Token.RETURN && node.hasOneChild()) {\n+            boolean keepValue = NodeUtil.mayHaveSideEffects(\n+                node.getFirstChild(), compiler);\n+            if (!keepValue) {\n+              defFinder.removeReferences(node.getFirstChild());\n+            }\n             Node result = node.removeFirstChild();\n-            if (NodeUtil.mayHaveSideEffects(result, compiler)) {\n+            if (keepValue) {\n               node.getParent().addChildBefore(\n                 new Node(\n                   Token.EXPR_RESULT, result).copyInformationFrom(result), node);\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n     return definitionSiteMap.values();\n   }\n \n+  private DefinitionSite getDefinitionAt(Node node) {\n+    return definitionSiteMap.get(node);\n+  }\n+\n+  DefinitionSite getDefinitionForFunction(Node function) {\n+    Preconditions.checkState(NodeUtil.isFunction(function));\n+    return getDefinitionAt(getNameNodeFromFunctionNode(function));\n+  }\n+\n   @Override\n   public Collection<Definition> getDefinitionsReferencedAt(Node useSite) {\n     if (definitionSiteMap.containsKey(useSite)) {\n    * definition.  Returns an empty collection if the definition is not\n    * used anywhere.\n    *\n-   * @param definition Definition of insterest.\n+   * @param definition Definition of interest.\n    * @return use site collection.\n    */\n   Collection<UseSite> getUseSites(Definition definition) {\n           new UseSite(node, traversal.getModule()));\n     }\n   }\n+\n+  /**\n+   * @param use A use site to check.\n+   * @return Whether the use is a call or new.\n+   */\n+  static boolean isCallOrNewSite(UseSite use) {\n+    Node call = use.node.getParent();\n+    if (call == null) {\n+      // The node has been removed from the AST.\n+      return false;\n+    }\n+    // We need to make sure we're dealing with a call to the function we're\n+    // optimizing. If the the first child of the parent is not the site, this\n+    // is a nested call and it's a call to another function.\n+    return NodeUtil.isCallOrNew(call) && call.getFirstChild() == use.node;\n+  }\n+\n+  /**\n+   * @return Whether the definition is directly exported.\n+   */\n+  static boolean maybeExported(\n+      AbstractCompiler compiler, Definition definition) {\n+    // Assume an exported method result is used.\n+    Node lValue = definition.getLValue();\n+    if (lValue == null) {\n+      return true;\n+    }\n+\n+    String partialName;\n+    if (NodeUtil.isGetProp(lValue)) {\n+      partialName = lValue.getLastChild().getString();\n+    } else if (NodeUtil.isName(lValue)) {\n+      partialName = lValue.getString();\n+    } else {\n+      // GETELEM is assumed to be an export or other expression are unknown\n+      // uses.\n+      return true;\n+    }\n+\n+    CodingConvention codingConvention = compiler.getCodingConvention();\n+    if (codingConvention.isExported(partialName)) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return Whether the function is defined in a non-aliasing expression.\n+   */\n+  static boolean isSimpleFunctionDeclaration(Node fn) {\n+    Node parent = fn.getParent();\n+    Node gramps = parent.getParent();\n+\n+    // Simple definition finder doesn't provide useful results in some\n+    // cases, specifically:\n+    //  - functions with recursive definitions\n+    //  - functions defined in object literals\n+    //  - functions defined in array litersals\n+    // Here we defined a set of known function declaration that are 'ok'.\n+\n+    // Some projects seem to actually define \"JSCompiler_renameProperty\"\n+    // rather than simply having an extern definition.  Don't mess with it.\n+    Node nameNode = SimpleDefinitionFinder.getNameNodeFromFunctionNode(fn);\n+    if (nameNode != null\n+        && NodeUtil.isName(nameNode)\n+        && nameNode.getString().equals(NodeUtil.JSC_PROPERTY_NAME_FN)) {\n+      return false;\n+    }\n+\n+    // example: function a(){};\n+    if (NodeUtil.isFunctionDeclaration(fn)) {\n+      return true;\n+    }\n+\n+    // example: a = function(){};\n+    // example: var a = function(){};\n+    if (fn.getFirstChild().getString().isEmpty()\n+        && (NodeUtil.isExprAssign(gramps) || NodeUtil.isName(parent))) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return the node defining the name for this function (if any).\n+   */\n+  static Node getNameNodeFromFunctionNode(Node function) {\n+    Preconditions.checkState(NodeUtil.isFunction(function));\n+    if (NodeUtil.isFunctionDeclaration(function)) {\n+      return function.getFirstChild();\n+    } else {\n+      Node parent = function.getParent();\n+      if (NodeUtil.isVarDeclaration(parent)) {\n+        return parent;\n+      } else if (NodeUtil.isAssign(parent)) {\n+        return parent.getFirstChild();\n+      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n+        return parent;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Traverse a node and its children and remove any references to from\n+   * the structures.\n+   */\n+  void removeReferences(Node node) {\n+    if (DefinitionsRemover.isDefinitionNode(node)) {\n+      DefinitionSite defSite = definitionSiteMap.get(node);\n+      if (defSite != null) {\n+        Definition def = defSite.definition;\n+        String name = getSimplifiedName(def.getLValue());\n+        if (name != null) {\n+          this.definitionSiteMap.remove(node);\n+          this.nameDefinitionMultimap.remove(name, node);\n+        }\n+      }\n+    } else {\n+      Node useSite = node;\n+      if (NodeUtil.isGetProp(useSite)) {\n+        String propName = useSite.getLastChild().getString();\n+        if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n+          useSite = useSite.getFirstChild();\n+        }\n+      }\n+      String name = getSimplifiedName(useSite);\n+      if (name != null) {\n+        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null));\n+      }\n+    }\n+\n+    for (Node child : node.children()) {\n+      removeReferences(child);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/UseSite.java\n+++ b/src/com/google/javascript/jscomp/UseSite.java\n     this.node = node;\n     this.module = module;\n   }\n+\n+  // Use the node as the identifying feature to make the UseSite recreatable.\n+\n+  @Override\n+  public int hashCode() {\n+    return this.node.hashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    return (o instanceof UseSite && ((UseSite)(o)).node.equals(this.node));\n+  }\n }", "timestamp": 1291054156, "metainfo": ""}