{"sha": "26dfe37d9ace5bf791ff4ab8cec7bf1e2eb1b3f5", "log": "Automated g4 rollback.  *** Reason for rollback ***  Fix bind/call folding by taking care to maintain the FREE_CALL attribute.  *** Original change description ***  Automated g4 rollback.  *** Reason for rollback *** This breaks gmail   ... description truncated by g4 rollback ...  R=moedinger DELTA=151  (150 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2406   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.jscomp.CodingConvention.Bind;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n         // Fall through on purpose because tryFoldStandardConstructors() may\n         // convert a NEW node into a CALL node\n       case Token.CALL:\n-        return tryFoldLiteralConstructor(node);\n+        Node result =  tryFoldLiteralConstructor(node);\n+        if (result == node) {\n+          result = tryFoldImmediateCallToBoundFunction(node);\n+        }\n+        return result;\n \n       case Token.COMMA:\n         return tryFoldComma(node);\n \n       default:\n         return node; //Nothing changed\n+    }\n+  }\n+\n+  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n+    // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n+    Preconditions.checkState(n.getType() == Token.CALL);\n+    Node callTarget = n.getFirstChild();\n+    Bind bind = getCodingConvention().describeFunctionBind(callTarget);\n+    if (bind != null) {\n+      // replace the call target\n+      bind.target.detachFromParent();\n+      n.replaceChild(callTarget, bind.target);\n+      callTarget = bind.target;\n+\n+      // push the parameters\n+      addParameterAfter(bind.parameters, callTarget);\n+\n+      // add the this value before the parameters if necessary\n+      if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n+        // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n+        Node newCallTarget = new Node(Token.GETPROP,\n+            callTarget.cloneTree(),\n+            Node.newString(\"call\").copyInformationFrom(callTarget));\n+        n.replaceChild(callTarget, newCallTarget);\n+        n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n+        n.putBooleanProp(Node.FREE_CALL, false);\n+      } else {\n+        n.putBooleanProp(Node.FREE_CALL, true);\n+      }\n+      reportCodeChange();\n+    }\n+    return n;\n+  }\n+\n+  private void addParameterAfter(Node parameterList, Node after) {\n+    if (parameterList != null) {\n+      // push the last parameter to the head of the list first.\n+      addParameterAfter(parameterList.getNext(), after);\n+      after.getParent().addChildAfter(parameterList.cloneTree(), after);\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     test(\"var x=[',',' ',',',',',',',',']\",\n          \"var x=',; ;,;,;,;,'.split(';')\");\n   }\n+\n+  public void testBindToCall1() {\n+    test(\"(goog.bind(f))()\", \"f()\");\n+    test(\"(goog.bind(f,a))()\", \"f.call(a)\");\n+    test(\"(goog.bind(f,a,b))()\", \"f.call(a,b)\");\n+\n+    test(\"(goog.bind(f))(a)\", \"f(a)\");\n+    test(\"(goog.bind(f,a))(b)\", \"f.call(a,b)\");\n+    test(\"(goog.bind(f,a,b))(c)\", \"f.call(a,b,c)\");\n+\n+    test(\"(goog.partial(f))()\", \"f()\");\n+    test(\"(goog.partial(f,a))()\", \"f(a)\");\n+    test(\"(goog.partial(f,a,b))()\", \"f(a,b)\");\n+\n+    test(\"(goog.partial(f))(a)\", \"f(a)\");\n+    test(\"(goog.partial(f,a))(b)\", \"f(a,b)\");\n+    test(\"(goog.partial(f,a,b))(c)\", \"f(a,b,c)\");\n+\n+    test(\"((function(){}).bind())()\", \"((function(){}))()\");\n+    test(\"((function(){}).bind(a))()\", \"((function(){})).call(a)\");\n+    test(\"((function(){}).bind(a,b))()\", \"((function(){})).call(a,b)\");\n+\n+    test(\"((function(){}).bind())(a)\", \"((function(){}))(a)\");\n+    test(\"((function(){}).bind(a))(b)\", \"((function(){})).call(a,b)\");\n+    test(\"((function(){}).bind(a,b))(c)\", \"((function(){})).call(a,b,c)\");\n+\n+    // Without using type information we don't know \"f\" is a function.\n+    testSame(\"(f.bind())()\");\n+    testSame(\"(f.bind(a))()\");\n+    testSame(\"(f.bind())(a)\");\n+    testSame(\"(f.bind(a))(b)\");\n+\n+    // Don't rewrite if the bind isn't the immediate call target\n+    testSame(\"(goog.bind(f)).call(g)\");\n+  }\n+\n+  public void testBindToCall2() {\n+    test(\"(goog$bind(f))()\", \"f()\");\n+    test(\"(goog$bind(f,a))()\", \"f.call(a)\");\n+    test(\"(goog$bind(f,a,b))()\", \"f.call(a,b)\");\n+\n+    test(\"(goog$bind(f))(a)\", \"f(a)\");\n+    test(\"(goog$bind(f,a))(b)\", \"f.call(a,b)\");\n+    test(\"(goog$bind(f,a,b))(c)\", \"f.call(a,b,c)\");\n+\n+    test(\"(goog$partial(f))()\", \"f()\");\n+    test(\"(goog$partial(f,a))()\", \"f(a)\");\n+    test(\"(goog$partial(f,a,b))()\", \"f(a,b)\");\n+\n+    test(\"(goog$partial(f))(a)\", \"f(a)\");\n+    test(\"(goog$partial(f,a))(b)\", \"f(a,b)\");\n+    test(\"(goog$partial(f,a,b))(c)\", \"f(a,b,c)\");\n+\n+    // Don't rewrite if the bind isn't the immediate call target\n+    testSame(\"(goog$bind(f)).call(g)\");\n+  }\n+\n+  public void testBindToCall3() {\n+    // TODO(johnlenz): The code generator wraps free calls with (0,...) to\n+    // prevent leaking \"this\", but the parser doesn't unfold it, making a\n+    // AST comparison fail.  For now do a string comparison to validate the\n+    // correct code is in fact generated.\n+    // The FREE call wrapping should be moved out of the code generator\n+    // and into a denormalizing pass.\n+    new StringCompareTestCase().testBindToCall3();\n+  }\n+\n+  private static class StringCompareTestCase extends CompilerTestCase {\n+\n+    StringCompareTestCase() {\n+      super(\"\", false);\n+    }\n+\n+    @Override\n+    protected CompilerPass getProcessor(Compiler compiler) {\n+      CompilerPass peepholePass =\n+        new PeepholeOptimizationsPass(compiler,\n+            new PeepholeSubstituteAlternateSyntax(false));\n+      return peepholePass;\n+    }\n+\n+    public void testBindToCall3() {\n+      test(\"(goog.bind(f.m))()\", \"(0,f.m)()\");\n+      test(\"(goog.bind(f.m,a))()\", \"f.m.call(a)\");\n+\n+      test(\"(goog.bind(f.m))(a)\", \"(0,f.m)(a)\");\n+      test(\"(goog.bind(f.m,a))(b)\", \"f.m.call(a,b)\");\n+\n+      test(\"(goog.partial(f.m))()\", \"(0,f.m)()\");\n+      test(\"(goog.partial(f.m,a))()\", \"(0,f.m)(a)\");\n+\n+      test(\"(goog.partial(f.m))(a)\", \"(0,f.m)(a)\");\n+      test(\"(goog.partial(f.m,a))(b)\", \"(0,f.m)(a,b)\");\n+\n+      // Without using type information we don't know \"f\" is a function.\n+      testSame(\"f.m.bind()()\");\n+      testSame(\"f.m.bind(a)()\");\n+      testSame(\"f.m.bind()(a)\");\n+      testSame(\"f.m.bind(a)(b)\");\n+\n+      // Don't rewrite if the bind isn't the immediate call target\n+      testSame(\"goog.bind(f.m).call(g)\");\n+    }\n+\n+\n+  }\n }", "timestamp": 1308938330, "metainfo": ""}