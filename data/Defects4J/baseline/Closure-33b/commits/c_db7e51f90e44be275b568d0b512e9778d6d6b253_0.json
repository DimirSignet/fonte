{"sha": "db7e51f90e44be275b568d0b512e9778d6d6b253", "log": "Fix issue with improper join of strings containing null and undefined. Define a method for converting array literals to strings.  R=acleung DELTA=174  (122 added, 38 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=522   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * <code>String()</code> JavaScript cast function.\n    */\n   static String getStringValue(Node n) {\n-    // TODO(user): Convert constant array, object, and regex literals as well.\n+    // TODO(user): regex literals as well.\n     switch (n.getType()) {\n       case Token.STRING:\n         return n.getString();\n           return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n         }\n         break;\n+\n+      case Token.ARRAYLIT:\n+        return arrayToString(n);\n+\n+      case Token.OBJECTLIT:\n+        return \"[object Object]\";\n     }\n     return null;\n+  }\n+\n+  /**\n+   * When converting arrays to string using Array.prototype.toString or\n+   * Array.prototype.join, the rules for conversion to String are different\n+   * than converting each element individually.  Specifically, \"null\" and\n+   * \"undefined\" are converted to an empty string.\n+   * @param n A node that is a member of an Array.\n+   * @return The string representation.\n+   */\n+  static String getArrayElementStringValue(Node n) {\n+    return NodeUtil.isNullOrUndefined(n) ? \"\" : getStringValue(n);\n+  }\n+\n+  static String arrayToString(Node literal) {\n+    Node first = literal.getFirstChild();\n+    int[] skipIndexes = (int[]) literal.getProp(Node.SKIP_INDEXES_PROP);\n+    StringBuilder result = new StringBuilder();\n+    int nextSlot = 0;\n+    int nextSkipSlot = 0;\n+    for (Node n = first; n != null; n = n.getNext()) {\n+      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {\n+        if (nextSlot == skipIndexes[nextSkipSlot]) {\n+          result.append(',');\n+          nextSlot++;\n+          nextSkipSlot++;\n+        } else {\n+          break;\n+        }\n+      }\n+      String childValue = getArrayElementStringValue(n);\n+      if (childValue == null) {\n+        return null;\n+      }\n+      if (n != first) {\n+        result.append(',');\n+      }\n+      result.append(childValue);\n+\n+      nextSlot++;\n+    }\n+    return result.toString();\n   }\n \n   /**\n         break;\n \n       case Token.STRING:\n-        String s = trimJsWhiteSpace(n.getString());\n-        // return ScriptRuntime.toNumber(s);\n-        if (s.length() == 0) {\n-          return 0.0;\n-        }\n-\n-        if (s.length() > 2\n-            && s.charAt(0) == '0'\n-            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n-          // Attempt to convert hex numbers.\n-          try {\n-            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n-          } catch (NumberFormatException e) {\n-            return Double.NaN;\n-          }\n-        }\n-\n-        if (s.length() > 3\n-            && (s.charAt(0) == '-' || s.charAt(0) == '+')\n-            && s.charAt(1) == '0'\n-            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n-          // hex numbers with explicit signs vary between browsers.\n-          return null;\n-        }\n-\n-        // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n-        // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n-        if (s.equals(\"infinity\")\n-            || s.equals(\"-infinity\")\n-            || s.equals(\"+infinity\")) {\n-          return null;\n-        }\n-\n-        try {\n-          return Double.parseDouble(s);\n-        } catch (NumberFormatException e) {\n-          return Double.NaN;\n-        }\n+        return getStringNumberValue(n.getString());\n+\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        String value = getStringValue(n);\n+        return value != null ? getStringNumberValue(value) : null;\n     }\n \n     return null;\n+  }\n+\n+  static Double getStringNumberValue(String rawJsString) {\n+    String s = trimJsWhiteSpace(rawJsString);\n+    // return ScriptRuntime.toNumber(s);\n+    if (s.length() == 0) {\n+      return 0.0;\n+    }\n+\n+    if (s.length() > 2\n+        && s.charAt(0) == '0'\n+        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n+      // Attempt to convert hex numbers.\n+      try {\n+        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n+      } catch (NumberFormatException e) {\n+        return Double.NaN;\n+      }\n+    }\n+\n+    if (s.length() > 3\n+        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n+        && s.charAt(1) == '0'\n+        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n+      // hex numbers with explicit signs vary between browsers.\n+      return null;\n+    }\n+\n+    // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n+    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n+    if (s.equals(\"infinity\")\n+        || s.equals(\"-infinity\")\n+        || s.equals(\"+infinity\")) {\n+      return null;\n+    }\n+\n+    try {\n+      return Double.parseDouble(s);\n+    } catch (NumberFormatException e) {\n+      return Double.NaN;\n+    }\n   }\n \n   static String trimJsWhiteSpace(String s) {\n     return n.getType() == Token.NULL;\n   }\n \n+  static boolean isNullOrUndefined(Node n) {\n+    return isNull(n) || isUndefined(n);\n+  }\n+\n   static class MayBeStringResultPredicate implements Predicate<Node> {\n     public boolean apply(Node n) {\n       return mayBeStringHelper(n);\n    *   \"void 0\"\n    */\n   static Node newUndefinedNode(Node srcReferenceNode) {\n-    // TODO(johnlenz): Why this instead of the more common \"undefined\"?\n     Node node = new Node(Token.VOID, Node.newNumber(0));\n     if (srcReferenceNode != null) {\n         node.copyInformationFromForTree(srcReferenceNode);\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   private Node tryFoldArrayJoin(Node n) {\n     Node callTarget = n.getFirstChild();\n \n-    if (callTarget == null) {\n+    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n       return n;\n     }\n \n     Node right = callTarget.getNext();\n-\n-    if (right == null) {\n-      return n;\n-    }\n-\n-    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n+    if (right != null && !NodeUtil.isImmutableValue(right)) {\n       return n;\n     }\n \n       return n;\n     }\n \n-    String joinString = NodeUtil.getStringValue(right);\n+    // TODO(johnlenz): handle sparse arrays\n+\n+    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n     StringBuilder sb = null;\n     int foldedSize = 0;\n         } else {\n           sb.append(joinString);\n         }\n-        sb.append(NodeUtil.getStringValue(elem));\n+        sb.append(NodeUtil.getArrayElementStringValue(elem));\n       } else {\n         if (sb != null) {\n           Preconditions.checkNotNull(prev);\n     Preconditions.checkArgument(n.getType() == Token.GETELEM);\n \n     if (left.getType() == Token.ARRAYLIT) {\n+      // TODO(johnlenz): handle sparse arrays\n \n       if (right.getType() != Token.NUMBER) {\n         // Sometimes people like to use complex expressions to index into\n       int knownLength = -1;\n       switch (left.getType()) {\n         case Token.ARRAYLIT:\n+          // TODO(johnlenz): handle sparse arrays\n           if (mayHaveSideEffects(left)) {\n             // Nope, can't fold this, without handling the side-effects.\n             return n;\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertEquals(\"1\", NodeUtil.getStringValue(getNode(\"1.0\")));\n     assertEquals(\"0\", NodeUtil.getStringValue(getNode(\"'0'\")));\n     assertEquals(null, NodeUtil.getStringValue(getNode(\"/a/\")));\n-    assertEquals(null, NodeUtil.getStringValue(getNode(\"{}\")));\n-    assertEquals(null, NodeUtil.getStringValue(getNode(\"[]\")));\n+    assertEquals(\"[object Object]\", NodeUtil.getStringValue(getNode(\"{}\")));\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"[]\")));\n     assertEquals(\"false\", NodeUtil.getStringValue(getNode(\"false\")));\n     assertEquals(\"null\", NodeUtil.getStringValue(getNode(\"null\")));\n     assertEquals(\"0\", NodeUtil.getStringValue(getNode(\"0\")));\n     assertEquals(\"NaN\", NodeUtil.getStringValue(getNode(\"NaN\")));\n     assertEquals(\"Infinity\", NodeUtil.getStringValue(getNode(\"Infinity\")));\n     assertEquals(null, NodeUtil.getStringValue(getNode(\"x\")));\n+  }\n+\n+  public void testGetArrayStringValue() {\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"[]\")));\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"['']\")));\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"[null]\")));\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"[undefined]\")));\n+    assertEquals(\"\", NodeUtil.getStringValue(getNode(\"[void 0]\")));\n+    assertEquals(\"NaN\", NodeUtil.getStringValue(getNode(\"[NaN]\")));\n+    assertEquals(\",\", NodeUtil.getStringValue(getNode(\"[,'']\")));\n+    assertEquals(\",,\", NodeUtil.getStringValue(getNode(\"[[''],[''],['']]\")));\n+    assertEquals(\"1,2\", NodeUtil.getStringValue(getNode(\"[[1.0],[2.0]]\")));\n+    assertEquals(null, NodeUtil.getStringValue(getNode(\"[a]\")));\n+    assertEquals(null, NodeUtil.getStringValue(getNode(\"[1,a]\")));\n   }\n \n   public void testIsObjectLiteralKey1() throws Exception {\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = foo() + 'a' + 2\", \"x = foo()+\\\"a2\\\"\");\n     fold(\"x = '' + null\", \"x = \\\"null\\\"\");\n     fold(\"x = true + '' + false\", \"x = \\\"truefalse\\\"\");\n-    fold(\"x = '' + []\", \"x = \\\"\\\"+[]\");      // cannot fold (but nice if we can)\n+    fold(\"x = '' + []\", \"x = ''\");      // cannot fold (but nice if we can)\n   }\n \n   public void testFoldConstructor() {\n \n     fold(\"x = [1,2,3].join('abcdef')\",\n          \"x = '1abcdef2abcdef3'\");\n+\n+    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n+    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n+    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n+    // This can be folded but we don't currently.\n+    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n   }\n \n   public void testStringJoinAdd_b1992789() {\n     fold(\"1 + !1\", \"1\");\n     fold(\"'a ' + !1\", \"'a false'\");\n     fold(\"'a ' + !0\", \"'a true'\");\n+  }\n+\n+  public void testFoldMixed() {\n+    fold(\"''+[1]\", \"'1'\");\n+    foldSame(\"false+[]\"); // would like: \"\\\"false\\\"\"\n   }\n \n   private static final List<String> LITERAL_OPERANDS =", "timestamp": 1297795959, "metainfo": ""}