{"sha": "dc58965f18f524c67556aa4d750cd1d7f5cd1c83", "log": "Original change by tylerg@tylerg-jsdev on 2011/09/22 16:26:04. Cannibalizes a small piece of tyler's change, which surfaced an ambiguity in the function type lattice. We try to resolve this ambiguity by normalizing how structural functions are handled in union types.  R=tylerg DELTA=137  (132 added, 1 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3359   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.jstype.UnionType;\n   private boolean isNativeUnknownType = false;\n   private boolean areAllUnknownsChecked = true;\n   private final int maxUnionSize;\n+\n+  // Every UnionType may have at most one structural function in it.\n+  //\n+  // NOTE(nicksantos): I've read some literature that says that type-inferenced\n+  // languages are fundamentally incompatible with union types. I refuse\n+  // to believe this. But they do make the type lattice much more complicated.\n+  //\n+  // For this reason, when we deal with function types, we actually merge some\n+  // nodes on the lattice, and treat them as fundamentally equivalent.\n+  // For example, we treat\n+  // function(): string | function(): number\n+  // as equivalent to\n+  // function(): (string|number)\n+  // and normalize the first type into the second type.\n+  //\n+  // To perform this normalization, we've modified UnionTypeBuilder to disallow\n+  // multiple structural functions in a union. We always delegate to\n+  // FunctionType::getLeastSupertype, which either merges the functions into\n+  // one structural function, or just bails out and uses the top function type.\n+  private int functionTypePosition = -1;\n \n   // Memoize the result, in case build() is called multiple times.\n   private JSType result = null;\n         // Look through the alternates we've got so far,\n         // and check if any of them are duplicates of\n         // one another.\n+        int i = 0;\n         Iterator<JSType> it = alternates.iterator();\n         while (it.hasNext()) {\n           JSType current = it.next();\n             } else if (current.isSubtype(alternate)) {\n               // Alternate makes current obsolete\n               it.remove();\n+              if (i == functionTypePosition) {\n+                functionTypePosition = -1;\n+              }\n             }\n           }\n-        }\n-        alternates.add(alternate);\n+          i++;\n+        }\n+\n+        if (alternate.isFunctionType()) {\n+          // See the comments on functionTypePosition above.\n+          if (functionTypePosition == -1) {\n+            functionTypePosition = alternates.size();\n+            alternates.add(alternate);\n+          } else {\n+            JSType supremum = alternate.toMaybeFunctionType().getLeastSupertype(\n+                alternates.get(functionTypePosition).toMaybeFunctionType());\n+            Preconditions.checkState(supremum.isFunctionType());\n+            alternates.set(functionTypePosition, supremum);\n+          }\n+        } else {\n+          alternates.add(alternate);\n+        }\n+\n         result = null; // invalidate the memoized result\n       }\n     } else {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   public void testParseUnionType13() throws Exception {\n     testParseType(\n         \"(function(this:Date),function(this:String):number)\",\n-        \"(function (this:Date): ?|function (this:String): number)\");\n+        \"Function\");\n   }\n \n   public void testParseUnionType14() throws Exception {\n     testParseType(\n         \"(function(...[function(number):boolean]):number)|\" +\n         \"function(this:String, string):number\",\n-        \"(function (...[function (number): boolean]): number|\" +\n-        \"function (this:String, string): number)\");\n+        \"Function\");\n   }\n \n   public void testParseUnionType15() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n   }\n \n   /**\n+   * Tests that Proxied FunctionTypes behave the same over getLeastSupertype and\n+   * getGreatestSubtype as non proxied FunctionTypes\n+   */\n+  public void testSupertypeOfProxiedFunctionTypes() {\n+    ObjectType fn1 =\n+        new FunctionBuilder(registry)\n+        .withParamsNode(new Node(Token.LP))\n+        .withReturnType(NUMBER_TYPE)\n+        .build();\n+    ObjectType fn2 =\n+        new FunctionBuilder(registry)\n+        .withParamsNode(new Node(Token.LP))\n+        .withReturnType(STRING_TYPE)\n+        .build();\n+    ObjectType p1 = new ProxyObjectType(registry, fn1);\n+    ObjectType p2 = new ProxyObjectType(registry, fn2);\n+    ObjectType supremum =\n+        new FunctionBuilder(registry)\n+        .withParamsNode(new Node(Token.LP))\n+        .withReturnType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE))\n+        .build();\n+\n+    assertTypeEquals(fn1.getLeastSupertype(fn2), p1.getLeastSupertype(p2));\n+    assertTypeEquals(supremum, fn1.getLeastSupertype(fn2));\n+    assertTypeEquals(supremum, fn1.getLeastSupertype(p2));\n+    assertTypeEquals(supremum, p1.getLeastSupertype(fn2));\n+    assertTypeEquals(supremum, p1.getLeastSupertype(p2));\n+  }\n+\n+  /**\n    * Tests the {@link NamedType#equals} function, which had a bug in it.\n    */\n   public void testNamedTypeEquals() {\n     verifySubtypeChain(typeChain);\n   }\n \n+  public void testFunctionUnionSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        createUnionType(\n+            OBJECT_TYPE,\n+            STRING_TYPE),\n+        createUnionType(\n+            GREATEST_FUNCTION_TYPE,\n+            googBarInst,\n+            STRING_TYPE),\n+        createUnionType(\n+            STRING_TYPE,\n+            registry.createFunctionType(\n+                createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+            googBarInst),\n+        createUnionType(\n+            registry.createFunctionType(NUMBER_TYPE),\n+            googSubBarInst),\n+        LEAST_FUNCTION_TYPE,\n+        NO_OBJECT_TYPE,\n+        NO_TYPE);\n+    verifySubtypeChain(typeChain);\n+  }\n+\n   public void testConstructorSubtypeChain() throws Exception {\n     List<JSType> typeChain = Lists.newArrayList(\n         registry.getNativeType(JSTypeNative.ALL_TYPE),\n \n   public void verifySubtypeChain(List<JSType> typeChain,\n                                  boolean checkSubtyping) throws Exception {\n+    // Ugh. This wouldn't require so much copy-and-paste if we had a functional\n+    // programming language.\n     for (int i = 0; i < typeChain.size(); i++) {\n       for (int j = 0; j < typeChain.size(); j++) {\n         JSType typeI = typeChain.get(i);\n \n         JSType namedTypeI = getNamedWrapper(\"TypeI\", typeI);\n         JSType namedTypeJ = getNamedWrapper(\"TypeJ\", typeJ);\n+        JSType proxyTypeI = new ProxyObjectType(registry, typeI);\n+        JSType proxyTypeJ = new ProxyObjectType(registry, typeJ);\n \n         if (i == j) {\n           assertTrue(typeI + \" should equal itself\",\n               typeI.isEquivalentTo(typeI));\n           assertTrue(\"Named \" + typeI + \" should equal itself\",\n               namedTypeI.isEquivalentTo(namedTypeI));\n+          assertTrue(\"Proxy \" + typeI + \" should equal itself\",\n+              proxyTypeI.isEquivalentTo(proxyTypeI));\n         } else {\n           assertFalse(typeI + \" should not equal \" + typeJ,\n               typeI.isEquivalentTo(typeJ));\n           assertFalse(\"Named \" + typeI + \" should not equal \" + typeJ,\n               namedTypeI.isEquivalentTo(namedTypeJ));\n+          assertFalse(\"Proxy \" + typeI + \" should not equal \" + typeJ,\n+              proxyTypeI.isEquivalentTo(proxyTypeJ));\n         }\n \n         if (checkSubtyping) {\n             assertTrue(\n                 \"Named \" + typeJ + \" should be a subtype of Named \" + typeI,\n                 namedTypeJ.isSubtype(namedTypeI));\n+            // TODO(nicksantos): Should these tests pass?\n+            //assertTrue(\n+            //    \"Proxy \" + typeJ + \" should be a subtype of Proxy \" + typeI,\n+            //    proxyTypeJ.isSubtype(proxyTypeI));\n           } else {\n             assertFalse(typeJ + \" should not be a subtype of \" + typeI,\n                 typeJ.isSubtype(typeI));\n             assertFalse(\n                 \"Named \" + typeJ + \" should not be a subtype of Named \" + typeI,\n                 namedTypeJ.isSubtype(namedTypeI));\n+            // TODO(nicksantos): Should these tests pass?\n+            //assertFalse(\n+            //    \"Named \" + typeJ + \" should not be a subtype of Named \" + typeI,\n+            //    proxyTypeJ.isSubtype(proxyTypeI));\n           }\n \n           JSType expectedSupremum = i < j ? typeI : typeJ;\n           JSType expectedInfimum = i > j ? typeI : typeJ;\n+\n           assertTypeEquals(\n               expectedSupremum + \" should be the least supertype of \" + typeI +\n               \" and \" + typeJ,\n               expectedSupremum, typeI.getLeastSupertype(typeJ));\n+\n+          // TODO(nicksantos): Should these tests pass?\n+          //assertTypeEquals(\n+          //    expectedSupremum + \" should be the least supertype of Named \" +\n+          //    typeI + \" and Named \" + typeJ,\n+          //    expectedSupremum, namedTypeI.getLeastSupertype(namedTypeJ));\n+          //assertTypeEquals(\n+          //    expectedSupremum + \" should be the least supertype of Proxy \" +\n+          //    typeI + \" and Proxy \" + typeJ,\n+          //    expectedSupremum, proxyTypeI.getLeastSupertype(proxyTypeJ));\n+\n           assertTypeEquals(\n               expectedInfimum + \" should be the greatest subtype of \" + typeI +\n               \" and \" + typeJ,\n               expectedInfimum, typeI.getGreatestSubtype(typeJ));\n+\n+          // TODO(nicksantos): Should these tests pass?\n+          //assertTypeEquals(\n+          //    expectedInfimum + \" should be the greatest subtype of Named \" +\n+          //    typeI + \" and Named \" + typeJ,\n+          //    expectedInfimum, namedTypeI.getGreatestSubtype(namedTypeJ));\n+          //assertTypeEquals(\n+          //    expectedInfimum + \" should be the greatest subtype of Proxy \" +\n+          //    typeI + \" and Proxy \" + typeJ,\n+          //    expectedInfimum, proxyTypeI.getGreatestSubtype(proxyTypeJ));\n         }\n       }\n     }", "timestamp": 1317157059, "metainfo": ""}