{"sha": "76abdf11394c0e7515ae63335676ea3657badb45", "log": "Make our build warnings free.  R=acleung   Revision created by MOE tool push_codebase. MOE_MIGRATION=2830   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n   /**\n    * Parses the given contents containing a source map.\n    */\n+  @Override\n   public void parse(String contents) throws SourceMapParseException {\n     ParseState parser = new ParseState(contents);\n     try {\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV2.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV2.java\n   /**\n    * Parses the given contents containing a source map.\n    */\n+  @Override\n   public void parse(String contents) throws SourceMapParseException {\n     try {\n       JSONObject sourceMapRoot = new JSONObject(contents);\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n   /**\n    * Parses the given contents containing a source map.\n    */\n+  @Override\n   public void parse(String contents) throws SourceMapParseException {\n     parse(contents, null);\n   }\n       this.length = content.length();\n     }\n \n+    @Override\n     public char next() {\n       return content.charAt(current++);\n     }\n       return content.charAt(current);\n     }\n \n+    @Override\n     public boolean hasNext() {\n       return  current < length;\n     }\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV1.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV1.java\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n+  @Override\n   public void addMapping(\n       String sourceName, @Nullable String symbolName,\n       FilePosition sourceStartPosition,\n    *\n    * @param prefix The prefix that is added before the generated source code.\n    */\n+  @Override\n   public void setWrapperPrefix(String prefix) {\n     // Determine the current line and character position.\n     int prefixLine = 0;\n    * @param offsetLine The index of the current line being printed.\n    * @param offsetIndex The column index of the current character being printed.\n    */\n+  @Override\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     Preconditions.checkState(offsetLine >= 0);\n     Preconditions.checkState(offsetIndex >= 0);\n   /**\n    * Resets the source map for reuse for the generation of a new source file.\n    */\n+  @Override\n   public void reset() {\n     mappings = Lists.newArrayList();\n     lastMapping = null;\n    * @param name The name of the generated source file that this source map\n    *   represents.\n    */\n+  @Override\n   public void appendTo(Appendable out, String name) throws IOException {\n     // Write the mappings out to the file. The format of the generated\n     // source map is three sections, each deliminated by a magic comment.\n     /**\n      * As each segment is visited write out the appropriate line mapping.\n      */\n+    @Override\n     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n       throws IOException {\n \n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n   /**\n    * {@inheritDoc}\n    */\n+  @Override\n   public void reset() {\n     mappings.clear();\n     lastMapping = null;\n    * @param validate Whether to perform (potentially costly) validation on the\n    * generated source map.\n    */\n+  @Override\n   @VisibleForTesting\n   public void validate(boolean validate) {\n     this.validate = validate;\n    *\n    * @param prefix The prefix that is added before the generated source code.\n    */\n+  @Override\n   public void setWrapperPrefix(String prefix) {\n     // Determine the current line and character position.\n     int prefixLine = 0;\n    * @param offsetLine The index of the current line being printed.\n    * @param offsetIndex The column index of the current character being printed.\n    */\n+  @Override\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     Preconditions.checkState(offsetLine >= 0);\n     Preconditions.checkState(offsetIndex >= 0);\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n+  @Override\n   public void addMapping(\n       String sourceName, @Nullable String symbolName,\n       FilePosition sourceStartPosition,\n    *     An optional name (from the original source) that this entry represents.\n    *     This can either be an string or index into the \"names\" field.\n    */\n+  @Override\n   public void appendTo(Appendable out, String name) throws IOException {\n     int maxLine = prepMappings();\n \n     /**\n      * As each segment is visited write out the appropriate line mapping.\n      */\n+    @Override\n     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n       throws IOException {\n \n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n   /**\n    * {@inheritDoc}\n    */\n+  @Override\n   public void reset() {\n     mappings.clear();\n     lastMapping = null;\n    * @param validate Whether to perform (potentially costly) validation on the\n    * generated source map.\n    */\n+  @Override\n   public void validate(boolean validate) {\n     // Nothing currently.\n   }\n    *\n    * @param prefix The prefix that is added before the generated source code.\n    */\n+  @Override\n   public void setWrapperPrefix(String prefix) {\n     // Determine the current line and character position.\n     int prefixLine = 0;\n    * @param offsetLine The index of the current line being printed.\n    * @param offsetIndex The column index of the current character being printed.\n    */\n+  @Override\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     Preconditions.checkState(offsetLine >= 0);\n     Preconditions.checkState(offsetIndex >= 0);\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n+  @Override\n   public void addMapping(\n       String sourceName, @Nullable String symbolName,\n       FilePosition sourceStartPosition,\n    *     may be incomplete.\n    * Line 8: The mappings field.\n    */\n+  @Override\n   public void appendTo(Appendable out, String name) throws IOException {\n     int maxLine = prepMappings();\n \n     /**\n      * As each segment is visited write out the appropriate line mapping.\n      */\n+    @Override\n     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n       throws IOException {\n \n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n   /**\n    * Do all processing on the root node.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     defaultRoot = root.getFirstChild();\n     Preconditions.checkState(defaultRoot.getType() == Token.SCRIPT);\n       this.whitelist = whitelist;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n    */\n   private final class PropertyGatherer extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.GETPROP) {\n         Node propNameNode = n.getLastChild();\n       }\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.FUNCTION:\n    * usage for each global.\n    */\n   private final class GlobalGatherer extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.NAME) {\n         String name = n.getString();\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n   /**\n    * Do all processing on the root node.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     // Find candidates to alias.\n     NodeTraversal.traverse(compiler, root, new FindAliasableNodes());\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n    */\n   private static final Comparator<Property> FREQUENCY_COMPARATOR =\n       new Comparator<Property>() {\n+        @Override\n         public int compare(Property p1, Property p2) {\n           if (p1.numOccurrences != p2.numOccurrences) {\n             return p2.numOccurrences - p1.numOccurrences;\n     return newInt;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n     NodeTraversal.traverse(compiler, root, new ProcessProperties());\n       }\n     }\n \n+    @Override\n     public List<GraphNode<Property, Void>> getNodes() {\n       return Lists.<GraphNode<Property, Void>>newArrayList(nodes.values());\n     }\n \n+    @Override\n     public GraphNode<Property, Void> getNode(Property property) {\n       return nodes.get(property);\n     }\n \n+    @Override\n     public SubGraph<Property, Void> newSubGraph() {\n       return new PropertySubGraph();\n     }\n \n+    @Override\n     public void clearNodeAnnotations() {\n       for (PropertyGraphNode node : nodes.values()) {\n         node.setAnnotation(null);\n       }\n     }\n \n+    @Override\n     public int getWeight(Property value) {\n       return value.numOccurrences;\n     }\n      * sub graph.  That is, if none of its related types intersects with the\n      * related types for this sub graph.\n      */\n+    @Override\n     public boolean isIndependentOf(Property prop) {\n       return !relatedTypes.intersects(prop.relatedTypes);\n     }\n      * Adds the node to the sub graph, adding all its related types to the\n      * related types for the sub graph.\n      */\n+    @Override\n     public void addNode(Property prop) {\n       relatedTypes.or(prop.relatedTypes);\n     }\n       this.property = property;\n     }\n \n+    @Override\n     public Property getValue() {\n       return property;\n     }\n \n+    @Override\n     @SuppressWarnings(\"unchecked\")\n     public <A extends Annotation> A getAnnotation() {\n       return (A) annotation;\n     }\n \n+    @Override\n     public void setAnnotation(Annotation data) {\n       annotation = data;\n     }\n \n   /** Finds all property references, recording the types on which they occur. */\n   private class ProcessProperties extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP: {\n--- a/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n+++ b/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n   }\n \n   private class PropagateReferences implements EdgeCallback<Name, Reference> {\n+    @Override\n     public boolean traverseEdge(Name start, Reference edge, Name dest) {\n       NameInfo startInfo = getInfo(start);\n       NameInfo destInfo = getInfo(dest);\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n     }\n   }\n \n+  @Override\n   public void process(Node externRoot, Node root) {\n     if (!canModifyExterns) {\n       NodeTraversal.traverse(compiler, externRoot,\n \n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       if (isPrototypePropertyAssign(n)) {\n         symbolStack.push(new NameContext(getNameInfoForName(\n       return true;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.GETPROP) {\n         String propName = n.getFirstChild().getNext().getString();\n   }\n \n   private class ProcessExternProperties extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.GETPROP) {\n         symbolGraph.connect(externNode, firstModule,\n \n   private class PropagateReferences\n       implements EdgeCallback<NameInfo, JSModule> {\n+    @Override\n     public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n       if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n     this.namer = namer;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.FUNCTION:\n--- a/src/com/google/javascript/jscomp/BasicErrorManager.java\n+++ b/src/com/google/javascript/jscomp/BasicErrorManager.java\n   private int warningCount = 0;\n   private double typedPercent = 0.0;\n \n+  @Override\n   public void report(CheckLevel level, JSError error) {\n     if (messages.add(new ErrorWithLevel(error, level))) {\n       if (level == CheckLevel.ERROR) {\n     }\n   }\n \n+  @Override\n   public void generateReport() {\n     for (ErrorWithLevel message : messages) {\n       println(message.level, message.error);\n    */\n   protected abstract void printSummary();\n \n+  @Override\n   public int getErrorCount() {\n     return errorCount;\n   }\n \n+  @Override\n   public int getWarningCount() {\n     return warningCount;\n   }\n \n+  @Override\n   public JSError[] getErrors() {\n     return toArray(CheckLevel.ERROR);\n   }\n \n+  @Override\n   public JSError[] getWarnings() {\n     return toArray(CheckLevel.WARNING);\n   }\n \n+  @Override\n   public void setTypedPercent(double typedPercent) {\n     this.typedPercent = typedPercent;\n   }\n \n+  @Override\n   public double getTypedPercent() {\n     return typedPercent;\n   }\n     private static final int P1_LT_P2 = -1;\n     private static final int P1_GT_P2 = 1;\n \n+    @Override\n     public int compare(ErrorWithLevel p1, ErrorWithLevel p2) {\n       // null is the smallest value\n       if (p2 == null) {\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n     Collection<Function> functions =\n         Collections2.<Function>filter(getAllFunctions(),\n             new Predicate<Function>() {\n+        @Override\n         public boolean apply(Function function) {\n \n           String functionName = function.getName();\n--- a/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n    */\n   private final Visitor<JSType> restrictUndefinedVisitor =\n     new Visitor<JSType>() {\n+      @Override\n       public JSType caseEnumElementType(EnumElementType enumElementType) {\n         JSType type = enumElementType.getPrimitiveType().visit(this);\n         if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n         }\n       }\n \n+      @Override\n       public JSType caseAllType() {\n         return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n             STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE);\n       }\n \n+      @Override\n       public JSType caseNoObjectType() {\n         return getNativeType(NO_OBJECT_TYPE);\n       }\n \n+      @Override\n       public JSType caseNoType() {\n         return getNativeType(NO_TYPE);\n       }\n \n+      @Override\n       public JSType caseBooleanType() {\n         return getNativeType(BOOLEAN_TYPE);\n       }\n \n+      @Override\n       public JSType caseFunctionType(FunctionType type) {\n         return type;\n       }\n \n+      @Override\n       public JSType caseNullType() {\n         return getNativeType(NULL_TYPE);\n       }\n \n+      @Override\n       public JSType caseNumberType() {\n         return getNativeType(NUMBER_TYPE);\n       }\n \n+      @Override\n       public JSType caseObjectType(ObjectType type) {\n         return type;\n       }\n \n+      @Override\n       public JSType caseStringType() {\n         return getNativeType(STRING_TYPE);\n       }\n \n+      @Override\n       public JSType caseUnionType(UnionType type) {\n         return type.getRestrictedUnion(getNativeType(VOID_TYPE));\n       }\n \n+      @Override\n       public JSType caseUnknownType() {\n         return getNativeType(UNKNOWN_TYPE);\n       }\n \n+      @Override\n       public JSType caseVoidType() {\n         return null;\n       }\n    */\n   private final Visitor<JSType> restrictNullVisitor =\n     new Visitor<JSType>() {\n+      @Override\n       public JSType caseEnumElementType(EnumElementType enumElementType) {\n         JSType type = enumElementType.getPrimitiveType().visit(this);\n         if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n         }\n       }\n \n+      @Override\n       public JSType caseAllType() {\n         return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n             STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE);\n       }\n \n+      @Override\n       public JSType caseNoObjectType() {\n         return getNativeType(NO_OBJECT_TYPE);\n       }\n \n+      @Override\n       public JSType caseNoType() {\n         return getNativeType(NO_TYPE);\n       }\n \n+      @Override\n       public JSType caseBooleanType() {\n         return getNativeType(BOOLEAN_TYPE);\n       }\n \n+      @Override\n       public JSType caseFunctionType(FunctionType type) {\n         return type;\n       }\n \n+      @Override\n       public JSType caseNullType() {\n         return null;\n       }\n \n+      @Override\n       public JSType caseNumberType() {\n         return getNativeType(NUMBER_TYPE);\n       }\n \n+      @Override\n       public JSType caseObjectType(ObjectType type) {\n         return type;\n       }\n \n+      @Override\n       public JSType caseStringType() {\n         return getNativeType(STRING_TYPE);\n       }\n \n+      @Override\n       public JSType caseUnionType(UnionType type) {\n         return type.getRestrictedUnion(getNativeType(NULL_TYPE));\n       }\n \n+      @Override\n       public JSType caseUnknownType() {\n         return getNativeType(UNKNOWN_TYPE);\n       }\n \n+      @Override\n       public JSType caseVoidType() {\n         return getNativeType(VOID_TYPE);\n       }\n      */\n     protected abstract JSType caseTopType(JSType topType);\n \n+    @Override\n     public JSType caseAllType() {\n       return caseTopType(getNativeType(ALL_TYPE));\n     }\n \n+    @Override\n     public JSType caseUnknownType() {\n       return caseTopType(getNativeType(UNKNOWN_TYPE));\n     }\n \n+    @Override\n     public JSType caseUnionType(UnionType type) {\n       JSType restricted = null;\n       for (JSType alternate : type.getAlternates()) {\n       return restricted;\n     }\n \n+    @Override\n     public JSType caseNoType() {\n       return getNativeType(NO_TYPE);\n     }\n \n+    @Override\n     public JSType caseEnumElementType(EnumElementType enumElementType) {\n       // NOTE(nicksantos): This is a white lie. Suppose we have:\n       // /** @enum {string|number} */ var MyEnum = ...;\n    */\n   abstract class RestrictByTrueTypeOfResultVisitor\n       extends RestrictByTypeOfResultVisitor {\n+    @Override\n     public JSType caseNoObjectType() {\n       return null;\n     }\n \n+    @Override\n     public JSType caseBooleanType() {\n       return null;\n     }\n \n+    @Override\n     public JSType caseFunctionType(FunctionType type) {\n       return null;\n     }\n \n+    @Override\n     public JSType caseNullType() {\n       return null;\n     }\n \n+    @Override\n     public JSType caseNumberType() {\n       return null;\n     }\n \n+    @Override\n     public JSType caseObjectType(ObjectType type) {\n       return null;\n     }\n \n+    @Override\n     public JSType caseStringType() {\n       return null;\n     }\n \n+    @Override\n     public JSType caseVoidType() {\n       return null;\n     }\n       return topType;\n     }\n \n+    @Override\n     public JSType caseNoObjectType() {\n       return getNativeType(NO_OBJECT_TYPE);\n     }\n \n+    @Override\n     public JSType caseBooleanType() {\n       return getNativeType(BOOLEAN_TYPE);\n     }\n \n+    @Override\n     public JSType caseFunctionType(FunctionType type) {\n       return type;\n     }\n \n+    @Override\n     public JSType caseNullType() {\n       return getNativeType(NULL_TYPE);\n     }\n \n+    @Override\n     public JSType caseNumberType() {\n       return getNativeType(NUMBER_TYPE);\n     }\n \n+    @Override\n     public JSType caseObjectType(ObjectType type) {\n       return type;\n     }\n \n+    @Override\n     public JSType caseStringType() {\n       return getNativeType(STRING_TYPE);\n     }\n \n+    @Override\n     public JSType caseVoidType() {\n       return getNativeType(VOID_TYPE);\n     }\n       return result;\n     }\n \n+    @Override\n     public JSType caseNoObjectType() {\n       return (value.equals(\"object\") || value.equals(\"function\")) ==\n           resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n     }\n \n+    @Override\n     public JSType caseBooleanType() {\n       return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n     }\n \n+    @Override\n     public JSType caseFunctionType(FunctionType type) {\n       return matchesExpectation(\"function\") ? type : null;\n     }\n \n+    @Override\n     public JSType caseNullType() {\n       return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n     }\n \n+    @Override\n     public JSType caseNumberType() {\n       return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n     }\n \n+    @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n       return matchesExpectation(\"object\") ? type : null;\n     }\n \n+    @Override\n     public JSType caseStringType() {\n       return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;\n     }\n \n+    @Override\n     public JSType caseVoidType() {\n       return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null;\n     }\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n     NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n+  @Override\n   public void enterScope(NodeTraversal t) {\n     if (!t.inGlobalScope()) {\n       Node n = t.getScopeRoot();\n     }\n   }\n \n+  @Override\n   public void exitScope(NodeTraversal t) {\n     if (!t.inGlobalScope()) {\n       Node n = t.getScopeRoot();\n     return type;\n   }\n \n+  @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     return true;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.NAME:\n--- a/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n     this.level = level;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     Node child;\n     switch (n.getType()) {\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n     return this;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     // TODO(nicksantos): Let CollapseProperties and CheckGlobalNames\n     // share a namespace.\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n    * Since this pass reports errors only when a global {@code this} keyword\n    * is encountered, there is no reason to traverse non global contexts.\n    */\n+  @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n \n     if (n.getType() == Token.FUNCTION) {\n     return true;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n       compiler.report(t.makeError(n, GLOBAL_THIS));\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n   private final CheckLevel level;\n \n   private static final Predicate<Node> IS_RETURN = new Predicate<Node>() {\n+    @Override\n     public boolean apply(Node input) {\n       // Check for null because the control flow graph's implicit return node is\n       // represented by null, so this value might be input.\n   private static final Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>\n       GOES_THROUGH_TRUE_CONDITION_PREDICATE =\n         new Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>() {\n+    @Override\n     public boolean apply(DiGraphEdge<Node, ControlFlowGraph.Branch> input) {\n       // First skill all exceptions.\n       Branch branch = input.getValue();\n--- a/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n+++ b/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n     this.onlyOneError = onlyOneError;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     // Look for both top-level functions and assignments of functions to\n     // qualified names.\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n     this.level = level;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n     // I've been unable to think of any cases where this indicates a bug,\n--- a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n     this.restricters =\n       new ImmutableMap.Builder<String, Function<TypeRestriction, JSType>>()\n       .put(\"isDef\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           if (p.outcome) {\n             return getRestrictedWithoutUndefined(p.type);\n          }\n       })\n       .put(\"isNull\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           if (p.outcome) {\n             return getNativeType(NULL_TYPE);\n         }\n       })\n       .put(\"isDefAndNotNull\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           if (p.outcome) {\n             return getRestrictedWithoutUndefined(\n         }\n       })\n       .put(\"isString\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           return getRestrictedByTypeOfResult(p.type, \"string\", p.outcome);\n         }\n       })\n       .put(\"isBoolean\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           return getRestrictedByTypeOfResult(p.type, \"boolean\", p.outcome);\n         }\n       })\n       .put(\"isNumber\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           return getRestrictedByTypeOfResult(p.type, \"number\", p.outcome);\n         }\n       })\n       .put(\"isFunction\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           return getRestrictedByTypeOfResult(p.type, \"function\", p.outcome);\n         }\n       })\n       .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           if (p.type == null) {\n             return p.outcome ? getNativeType(ARRAY_TYPE) : null;\n         }\n       })\n       .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n+        @Override\n         public JSType apply(TypeRestriction p) {\n           if (p.type == null) {\n             return p.outcome ? getNativeType(OBJECT_TYPE) : null;\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n   private static final Comparator<Var> coloringTieBreaker =\n       new Comparator<Var>() {\n+    @Override\n     public int compare(Var v1, Var v2) {\n       return v1.index - v2.index;\n     }\n--- a/src/com/google/javascript/jscomp/CodeChangeHandler.java\n+++ b/src/com/google/javascript/jscomp/CodeChangeHandler.java\n   static final class RecentChange implements CodeChangeHandler {\n     private boolean hasChanged = false;\n \n+    @Override\n     public void reportChange() {\n       hasChanged = true;\n     }\n    * A change handler that throws an exception if any changes are made.\n    */\n   static final class ForbiddenChange implements CodeChangeHandler {\n+    @Override\n     public void reportChange() {\n       throw new IllegalStateException(\"Code changes forbidden\");\n     }\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n         (!docInfo.isConstructor() && !docInfo.hasThisType())) {\n       NodeTraversal.traverse(compiler, function.getLastChild(),\n           new NodeTraversal.AbstractShallowCallback() {\n+            @Override\n             public void visit(NodeTraversal t, Node n, Node parent) {\n               if (n.getType() == Token.THIS) {\n                 compiler.report(\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     collapses.clear();\n     nodesToCollapse.clear();\n     // This is a workaround for a bug in Firefox.\n     private final Set<Var> blacklistedVars = Sets.newHashSet();\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.VAR) {\n         blacklistStubVars(t, n);\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n       }\n     }\n \n-    private static class WarningGuardSetter implements Setter {\n-      private final Setter proxy;\n+    private static class WarningGuardSetter implements Setter<String> {\n+      private final Setter<? super String> proxy;\n       private final CheckLevel level;\n \n-      private WarningGuardSetter(Setter proxy, CheckLevel level) {\n+      private WarningGuardSetter(\n+          Setter<? super String> proxy, CheckLevel level) {\n         this.proxy = proxy;\n         this.level = level;\n       }\n \n-      @Override public boolean isMultiValued() { return proxy.isMultiValued(); }\n-\n-      @Override public Class getType() { return proxy.getType(); }\n-\n-      @Override public void addValue(Object value) throws CmdLineException {\n-        proxy.addValue((String) value);\n-        warningGuardSpec.add(level, (String) value);\n+      @Override public boolean isMultiValued() {\n+        return proxy.isMultiValued();\n+      }\n+\n+      @Override public Class<String> getType() {\n+        return (Class<String>) proxy.getType();\n+      }\n+\n+      @Override public void addValue(String value) throws CmdLineException {\n+        proxy.addValue(value);\n+        warningGuardSpec.add(level, value);\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n   private Result compile() {\n     return runInCompilerThread(new Callable<Result>() {\n+      @Override\n       public Result call() throws Exception {\n         compileInternal();\n         return getResult();\n     final Object[] result = new Object[1];\n     final Throwable[] exception = new Throwable[1];\n     Runnable runnable = new Runnable() {\n+      @Override\n       public void run() {\n         try {\n           if (dumpTraceReport) {\n   Supplier<String> getUniqueNameIdSupplier() {\n     final Compiler self = this;\n     return new Supplier<String>() {\n+      @Override\n       public String get() {\n         return String.valueOf(self.nextUniqueNameId());\n       }\n    */\n   public String toSource() {\n     return runInCompilerThread(new Callable<String>() {\n+      @Override\n       public String call() throws Exception {\n         Tracer tracer = newTracer(\"toSource\");\n         try {\n    */\n   public String[] toSourceArray() {\n     return runInCompilerThread(new Callable<String[]>() {\n+      @Override\n       public String[] call() throws Exception {\n         Tracer tracer = newTracer(\"toSourceArray\");\n         try {\n    */\n   public String toSource(final JSModule module) {\n     return runInCompilerThread(new Callable<String>() {\n+      @Override\n       public String call() throws Exception {\n         List<CompilerInput> inputs = module.getInputs();\n         int numInputs = inputs.size();\n    */\n   public String[] toSourceArray(final JSModule module) {\n     return runInCompilerThread(new Callable<String[]>() {\n+      @Override\n       public String[] call() throws Exception {\n         List<CompilerInput> inputs = module.getInputs();\n         int numInputs = inputs.size();\n                        final int inputSeqNum,\n                        final Node root) {\n     runInCompilerThread(new Callable<Void>() {\n+      @Override\n       public Void call() throws Exception {\n         if (options.printInputDelimiter) {\n           if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n     return null;\n   }\n \n+  @Override\n   public String getSourceLine(String sourceName, int lineNumber) {\n     if (lineNumber < 1) {\n       return null;\n     return null;\n   }\n \n+  @Override\n   public Region getSourceRegion(String sourceName, int lineNumber) {\n     if (lineNumber < 1) {\n       return null;\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n    */\n   public abstract static class AbstractCfgNodeTraversalCallback implements\n       Callback {\n+    @Override\n     public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       if (parent == null) {\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         canModifyExterns, false);\n   }\n \n+  @Override\n   public void process(Node externRoot, Node root) {\n     // If there are < 2 modules, then we will never move anything,\n     // so we're done.\n--- a/src/com/google/javascript/jscomp/CssRenamingMap.java\n+++ b/src/com/google/javascript/jscomp/CssRenamingMap.java\n   Style getStyle();\n \n   public static abstract class ByPart implements CssRenamingMap {\n+    @Override\n     abstract public String get(String value);\n \n+    @Override\n     public Style getStyle() {\n       return Style.BY_PART;\n     }\n   }\n \n   public static abstract class ByWhole implements CssRenamingMap {\n+    @Override\n     abstract public String get(String value);\n \n+    @Override\n     public Style getStyle() {\n       return Style.BY_WHOLE;\n     }\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void enableSpecialization(SpecializeModule.SpecializationState state) {\n     this.specializationState = state;\n   }\n--- a/src/com/google/javascript/jscomp/DiagnosticGroup.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroup.java\n     return types;\n   }\n \n+  @Override\n   public String toString() {\n     return name == null ? super.toString() : \"DiagnosticGroup<\" + name + \">\";\n   }\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n         JSError.make(\"\", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n       addInvalidatingType(mis.typeA);\n     protected final Stack<StaticScope<T>> scopes =\n         new Stack<StaticScope<T>>();\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       return true;\n     }\n \n+    @Override\n     public void enterScope(NodeTraversal t) {\n       if (t.inGlobalScope()) {\n         scopes.push(typeSystem.getRootScope());\n       }\n     }\n \n+    @Override\n     public void exitScope(NodeTraversal t) {\n       scopes.pop();\n     }\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n   private class ExportTestFunctionsNodes extends\n       NodeTraversal.AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (parent != null && parent.getType() == Token.SCRIPT) {\n         if (NodeUtil.isFunctionDeclaration(n)) {\n     }\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new ExportTestFunctionsNodes());\n   }\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n             && functionExpression.getFirstChild() != grandchild) {\n           // TODO(johnlenz): In Internet Explorer, non-javascript objects such\n           // as DOM objects can not be decomposed.\n-          if (true) {\n-            throw new IllegalStateException(\n-                \"Object method calls can not be decomposed.\");\n-          } else {\n-            // Either there were preexisting side-effects, or this node has\n-            // side-effects.\n-            state.sideEffects = true;\n-\n-            // Rewrite the call so \"this\" is preserved.\n-            Node replacement = rewriteCallExpression(parent, state);\n-            // Continue from here.\n-            parent = replacement;\n-          }\n+          Preconditions.checkState(allowObjectCallDecomposing(),\n+              \"Object method calls can not be decomposed.\");\n+          // Either there were preexisting side-effects, or this node has\n+          // side-effects.\n+          state.sideEffects = true;\n+\n+          // Rewrite the call so \"this\" is preserved.\n+          Node replacement = rewriteCallExpression(parent, state);\n+          // Continue from here.\n+          parent = replacement;\n         }\n       } else if (parentType == Token.OBJECTLIT) {\n         decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n       Node extractedConditional = extractConditional(\n           nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n+  }\n+\n+  private static boolean allowObjectCallDecomposing() {\n+    return false;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n       return loopsEntered != 0;\n     }\n \n+    @Override\n     public void visit(Node n) {\n       // If we are exiting a loop.\n       if (NodeUtil.isLoopStructure(n)) {\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     Preconditions.checkState(fnRecursionName != null);\n \n     Predicate<Node> p = new Predicate<Node>(){\n+      @Override\n       public boolean apply(Node n) {\n         if (n.getType() == Token.NAME) {\n           return n.getString().equals(\"arguments\")\n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n       this.functionMap = functionMap;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.FUNCTION) {\n         Node functionNameNode = n.getFirstChild();\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       this.newNodes = newNodes;\n     }\n \n+    @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n         return false;\n--- a/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @Override\n   public void enterScope(NodeTraversal t) {\n     Set<Node> varNodes = Sets.newLinkedHashSet();\n     Iterator<Var> scopeVarIter = t.getScope().getVars();\n     }\n   }\n \n+  @Override\n   public void exitScope(NodeTraversal t) {\n   }\n \n+  @Override\n   public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n                                 Node parent) {\n     return true;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n   }\n \n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n     implements HotSwapCompilerPass {\n \n   private final AbstractCompiler compiler;\n+  @SuppressWarnings(\"unused\")\n   private boolean inExterns;\n \n   InferJSDocInfo(AbstractCompiler compiler) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     JSDocInfo docInfo;\n \n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     return fs;\n   }\n \n+  @Override\n   public void enableSpecialization(SpecializeModule.SpecializationState\n       specializationState) {\n     this.specializationState = specializationState;\n       return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if ((t.inGlobalScope() && inlineGlobalFunctions)\n           || (!t.inGlobalScope() && inlineLocalFunctions)) {\n       this.callback = callback;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         // Function calls\n       }\n     }\n \n+    @Override\n     public void visitCallSite(\n         NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n       maybeAddReference(t, fs, callNode, t.getModule());\n       this.specializationState = specializationState;\n     }\n \n+    @Override\n     public void visitCallSite(\n         NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n       Preconditions.checkState(fs.hasExistingFunctionDefinition());\n       this.fn = fn;\n     }\n \n+    @Override\n     public String getName() {\n       return fn.getFirstChild().getString();\n     }\n \n+    @Override\n     public Node getFunctionNode() {\n       return fn;\n     }\n \n+    @Override\n     public void remove() {\n       NodeUtil.removeChild(fn.getParent(), fn);\n     }\n       this.var = var;\n     }\n \n+    @Override\n     public String getName() {\n       return var.getFirstChild().getString();\n     }\n \n+    @Override\n     public Node getFunctionNode() {\n       return var.getFirstChild().getFirstChild();\n     }\n \n+    @Override\n     public void remove() {\n       NodeUtil.removeChild(var.getParent(), var);\n     }\n       this.fakeName = String.valueOf(index);\n     }\n \n+    @Override\n     public String getName() {\n       return fakeName;\n     }\n \n+    @Override\n     public Node getFunctionNode() {\n       return fn;\n     }\n \n+    @Override\n     public void remove() {\n       // Nothing to do. The function is removed with the call.\n     }\n--- a/src/com/google/javascript/jscomp/InvocationsCallback.java\n+++ b/src/com/google/javascript/jscomp/InvocationsCallback.java\n  */\n abstract class InvocationsCallback extends AbstractPostOrderCallback {\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() != Token.CALL) {\n       return;\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n   }\n \n   /** Gets the module name. */\n+  @Override\n   public String getName() {\n     return name;\n   }\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n    * consistently break ties.\n    */\n   private class DepthComparator implements Comparator<JSModule> {\n+    @Override\n     public int compare(JSModule m1, JSModule m2) {\n       return depthCompare(m1, m2);\n     }\n    * a shallower module. Uses module names to consistently break ties.\n    */\n   private class InverseDepthComparator implements Comparator<JSModule> {\n+    @Override\n     public int compare(JSModule m1, JSModule m2) {\n       return depthCompare(m2, m1);\n     }\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n     return new LightweightMessageFormatter();\n   }\n \n+  @Override\n   public String formatError(JSError error) {\n     return format(error, false);\n   }\n \n+  @Override\n   public String formatWarning(JSError warning) {\n     return format(warning, true);\n   }\n    * and return line excerpt without any modification.\n    */\n   static class LineNumberingFormatter implements ExcerptFormatter {\n+    @Override\n     public String formatLine(String line, int lineNumber) {\n       return line;\n     }\n \n+    @Override\n     public String formatRegion(Region region) {\n       if (region == null) {\n         return null;\n--- a/src/com/google/javascript/jscomp/LineNumberCheck.java\n+++ b/src/com/google/javascript/jscomp/LineNumberCheck.java\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     requiresLineNumbers = false;\n \n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     // Each JavaScript file is rooted in a script node, so we'll only\n     // have line number information inside the script node.\n     return true;\n   }\n \n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.SCRIPT) {\n       requiresLineNumbers = false;\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n   /**\n    * Get the slot for the given symbol.\n    */\n+  @Override\n   public StaticSlot<JSType> getSlot(String name) {\n     if (cache.dirtySymbols.contains(name)) {\n       for (LinkedFlowSlot slot = lastSlot;\n    * have enough type information. Then fill in that type information\n    * with stuff that we've inferred in the local flow.\n    */\n+  @Override\n   public void completeScope(Scope scope) {\n     for (Iterator<Var> it = scope.getVars(); it.hasNext();) {\n       Var var = it.next();\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n       this.compiler = compiler;\n     }\n \n+    @Override\n     public void process(Node externs, Node js) {\n       NodeTraversal.traverse(compiler, js, this);\n     }\n     /**\n      * Prepare a set for the new scope.\n      */\n+    @Override\n     public void enterScope(NodeTraversal t) {\n       if (t.inGlobalScope()) {\n         return;\n      * Rename vars for the current scope, and merge any referenced\n      * names into the parent scope reference set.\n      */\n+    @Override\n     public void exitScope(NodeTraversal t) {\n       if (t.inGlobalScope()) {\n         return;\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     externMethods.clear();\n     externMethodsWithoutSignatures.clear();\n    */\n   private class GetExternMethods extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n    */\n   private class GatherSignatures extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n    */\n   private static class ReferencePropagationCallback\n       implements EdgeCallback<JsName, RefType> {\n+    @Override\n     public boolean traverseEdge(JsName from,\n                                 RefType callSite,\n                                 JsName to) {\n       return out.toString();\n     }\n \n+    @Override\n     public int compareTo(JsName rhs) {\n       return this.name.compareTo(rhs.name);\n     }\n      * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n      * this node\n      */\n+    @SuppressWarnings(\"unused\")\n     Node node;\n \n     /**\n       this.parent = node.getParent();\n     }\n \n+    @Override\n     public JsName name() {\n       return name;\n     }\n \n+    @Override\n     public void remove() {\n       // Setters have VAR, FUNCTION, or ASSIGN parent nodes. CALL parent\n       // nodes are global refs, and are handled later in this function.\n       this.gramps = gramps;\n     }\n \n+    @Override\n     public JsName name() {\n       return name;\n     }\n       Preconditions.checkState(node.getType() == Token.CALL);\n     }\n \n+    @Override\n     public void remove() {\n       Preconditions.checkState(node.getType() == Token.CALL);\n       if (NodeUtil.isExpressionNode(parent)) {\n       Preconditions.checkState(parent.getType() == Token.INSTANCEOF);\n     }\n \n+    @Override\n     public void remove() {\n       changeProxy.replaceWith(gramps, parent, new Node(Token.FALSE));\n     }\n    * Walk through externs and mark nodes as externally declared if declared\n    */\n   private class ProcessExternals extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       NameInformation ns = null;\n       if (NodeUtil.isVarDeclaration(n)) {\n    * </pre>\n    */\n   private class FindDependencyScopes extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (!t.inGlobalScope()) {\n         return;\n   private class HoistVariableAndFunctionDeclarations\n       extends NodeTraversal.AbstractShallowCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (NodeUtil.isVarDeclaration(n)) {\n         NameInformation ns = createNameInformation(t, n, parent);\n    */\n   private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n \n       // Record global variable and function declarations\n       }\n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       if (parent == null) {\n         return true;\n       return true;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (!(NodeUtil.isName(n) ||\n             NodeUtil.isGet(n) && !NodeUtil.isGetProp(parent))) {\n   }\n \n   private class RemoveListener implements AstChangeProxy.ChangeListener {\n+    @Override\n     public void nodeRemoved(Node n) {\n       compiler.reportCodeChange();\n     }\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctions.java\n       bytesUsed += uniqueName.length();\n     }\n \n+    @Override\n     public final String getCombinedName(String lhs, String rhs) {\n       return lhs + DELIMITER + rhs;\n     }\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n     return this.graph;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     // Use the MemoizedScopeCreator instance from TypeCheck if available\n     // as FunctionTypeBuilder warns about existing types if TypedScopeCreator is\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphReport.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphReport.java\n    */\n   class DiGraphNodeComparator implements\n       Comparator<DiGraphNode<Name, Reference>> {\n+    @Override\n     public int compare(DiGraphNode<Name, Reference> node1,\n         DiGraphNode<Name, Reference> node2) {\n       Preconditions.checkNotNull(node1.getValue());\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n    * Abstract callback to visit all nodes in post order.\n    */\n   public abstract static class AbstractPostOrderCallback implements Callback {\n+    @Override\n     public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       return true;\n    * bodies.\n    */\n   public abstract static class AbstractShallowCallback implements Callback {\n+    @Override\n     public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       // We do want to traverse the name of a named function, but we don't\n    */\n   public abstract static class AbstractShallowStatementCallback\n       implements Callback {\n+    @Override\n     public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       return parent == null || NodeUtil.isControlStructure(parent)\n       this.include = include;\n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       return include == nodeTypes.contains(n.getType());\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   static class NumbericResultPredicate implements Predicate<Node> {\n+    @Override\n     public boolean apply(Node n) {\n       return isNumericResultHelper(n);\n     }\n   }\n \n   static class BooleanResultPredicate implements Predicate<Node> {\n+    @Override\n     public boolean apply(Node n) {\n       return isBooleanResultHelper(n);\n     }\n   }\n \n   static class MayBeStringResultPredicate implements Predicate<Node> {\n+    @Override\n     public boolean apply(Node n) {\n       return mayBeStringHelper(n);\n     }\n   private static class VarCollector implements Visitor {\n     final Map<String, Node> vars = Maps.newLinkedHashMap();\n \n+    @Override\n     public void visit(Node n) {\n       if (n.getType() == Token.NAME) {\n         Node parent = n.getParent();\n       this.name = name;\n     }\n \n+    @Override\n     public boolean apply(Node n) {\n       return n.getType() == Token.NAME\n           && n.getString().equals(name);\n       this.type = type;\n     }\n \n+    @Override\n     public boolean apply(Node n) {\n       return n.getType() == type;\n     }\n    * A predicate for matching var or function declarations.\n    */\n   static class MatchDeclaration implements Predicate<Node> {\n+    @Override\n     public boolean apply(Node n) {\n       return isFunctionDeclaration(n) || n.getType() == Token.VAR;\n     }\n    * A predicate for matching anything except function nodes.\n    */\n   static class MatchNotFunction implements Predicate<Node>{\n+    @Override\n     public boolean apply(Node n) {\n       return !isFunction(n);\n     }\n    * A predicate for matching statements without exiting the current scope.\n    */\n   static class MatchShallowStatement implements Predicate<Node>{\n+    @Override\n     public boolean apply(Node n) {\n       Node parent = n.getParent();\n       return n.getType() == Token.BLOCK\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new Callback());\n   }\n \n   private class Callback extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() != Token.NEW) {\n         return;\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     addExternDeclaration(externs,\n         new Node(Token.VAR,\n   }\n \n   private class Callback extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (OBJECT_PROPERTY_STRING.equals(n.getQualifiedName())) {\n         Node newName =\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   /**\n    * Run all the passes in the optimizer.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     for (CompilerPass pass : passes) {\n       pass.process(externs, root);\n       this.name = name;\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       logger.info(name);\n       startPass(name);\n       return order;\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n       loopMutex = true;\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       }\n \n       CssRenamingMap cssRenamingMap = new CssRenamingMap() {\n+        @Override\n         public String get(String value) {\n           if (cssNames.containsKey(value)) {\n             return cssNames.get(value);\n           }\n         }\n \n+        @Override\n         public CssRenamingMap.Style getStyle() {\n           return style;\n         }\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n     return this;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     if (namespace == null) {\n       namespace = new GlobalNamespace(compiler, root);\n      * Keeps track of whether the traversal is in a conditional branch.\n      * We traverse all nodes of the parse tree.\n      */\n+    @Override\n     public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       updateAssignAllowedStack(n, true);\n       return true;\n     }\n \n+    @Override\n     public  void visit(NodeTraversal t, Node n, Node parent) {\n       RefInfo refInfo = allRefInfo.get(n);\n       if (refInfo != null) {\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n    * @return Whether the node is known to be a value that is not a reference\n    *     outside the local scope.\n    */\n+  @SuppressWarnings(\"unused\")\n   private static boolean isKnownLocalValue(final Node value) {\n     Predicate<Node> taintingPredicate = new Predicate<Node>() {\n       @Override\n    */\n   private static class SideEffectPropagationCallback\n       implements EdgeCallback<FunctionInformation, Node> {\n+    @Override\n     public boolean traverseEdge(FunctionInformation callee,\n                                 Node callSite,\n                                 FunctionInformation caller) {\n--- a/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n+++ b/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n     } else {\n       // The test expects a consistent module order.\n       TreeSet<JSModule> modules = Sets.newTreeSet(new Comparator<JSModule>() {\n+        @Override\n         public int compare(JSModule o1, JSModule o2) {\n           return o1.getName().compareTo(o2.getName());\n         }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n    * For each node, update the block stack and reference collection\n    * as appropriate.\n    */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.NAME) {\n       Var v;\n   /**\n    * Updates block stack and invokes any additional behavior.\n    */\n+  @Override\n   public void enterScope(NodeTraversal t) {\n     Node n = t.getScope().getRootNode();\n     BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n   /**\n    * Updates block statck and invokes any additional behavior.\n    */\n+  @Override\n   public void exitScope(NodeTraversal t) {\n     blockStack.pop();\n     if (t.getScope().isGlobal()) {\n   /**\n    * Updates block stack.\n    */\n+  @Override\n   public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n       Node parent) {\n     // If node is a new basic block, put on basic block stack\n--- a/src/com/google/javascript/jscomp/RemoveTryCatch.java\n+++ b/src/com/google/javascript/jscomp/RemoveTryCatch.java\n   /**\n    * Do all processing on the root node.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new RemoveTryCatchCode());\n   }\n \n   private class RemoveTryCatchCode extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.TRY:\n--- a/src/com/google/javascript/jscomp/RemoveUnusedNames.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedNames.java\n     this.canModifyExterns = canModifyExterns;\n   }\n \n+  @Override\n   public void process(Node externRoot, Node root) {\n     AnalyzeNameReferences analyzer =\n         new AnalyzeNameReferences(compiler);\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n     this.anchorUnusedVars = anchorUnusedVars;\n   }\n \n+  @Override\n   public void enableSpecialization(SpecializeModule.SpecializationState state) {\n     this.specializationState = state;\n   }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n    * Traverses the root, removing all unused variables. Multiple traversals\n    * may occur to ensure all unused variables are removed.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n     SimpleDefinitionFinder defFinder = null;\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n      *\n      * {@inheritDoc}\n      */\n+    @Override\n     public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node,\n         Node parent) {\n       if (node.getType() == Token.LABEL) {\n      *\n      * {@inheritDoc}\n      */\n+    @Override\n     public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n       switch (node.getType()) {\n         case Token.LABEL:\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n \n   private static final Comparator<Property> FREQUENCY_COMPARATOR =\n     new Comparator<Property>() {\n+      @Override\n       public int compare(Property p1, Property p2) {\n \n         /**\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n    */\n   private static final Comparator<Property> FREQUENCY_COMPARATOR =\n     new Comparator<Property>() {\n+      @Override\n       public int compare(Property a1, Property a2) {\n         int n1 = a1.count();\n         int n2 = a2.count();\n    * @param externs The root of the externs parse tree\n    * @param root The root of the main code parse tree\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n \n    */\n   private class ProcessExternedProperties extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n    */\n   private class ProcessProperties extends AbstractPostOrderCallback {\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n    */\n   private static final Comparator<Assignment> FREQUENCY_COMPARATOR =\n       new Comparator<Assignment>() {\n+    @Override\n     public int compare(Assignment a1, Assignment a2) {\n       if (a1.count != a2.count) {\n         return a2.count - a1.count;\n    */\n   private static final Comparator<Assignment> ORDER_OF_OCCURRENCE_COMPARATOR =\n       new Comparator<Assignment>() {\n+        @Override\n         public int compare(Assignment a1, Assignment a2) {\n           return a1.orderOfOccurrence - a2.orderOfOccurrence;\n         }\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n       super(compiler);\n     }\n \n+    @Override\n     public EvaluatorException runtimeError(String message, String sourceName,\n         int line, String lineSource, int lineOffset) {\n       return new EvaluatorException(message, sourceName, line, lineSource,\n       super(compiler);\n     }\n \n+    @Override\n     public com.google.javascript.jscomp.mozilla.rhino.EvaluatorException\n         runtimeError(String message, String sourceName, int line,\n             String lineSource, int lineOffset) {\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n class RuntimeTypeCheck implements CompilerPass {\n \n   private static final Comparator<JSType> ALPHA = new Comparator<JSType>() {\n+    @Override\n     public int compare(JSType t1, JSType t2) {\n       return getName(t1).compareTo(getName(t2));\n     }\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n     this.compiler = compiler;\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     sanityCheckAst(externs, root);\n     sanityCheckNormalization(externs, root);\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     /**\n      * Gets the name of the variable.\n      */\n+    @Override\n     public String getName() {\n       return name;\n     }\n      * Gets this variable's type. To know whether this type has been inferred,\n      * see {@code #isTypeInferred()}.\n      */\n+    @Override\n     public JSType getType() {\n       return type;\n     }\n      * Returns whether this variable's type is inferred. To get the variable's\n      * type, see {@link #getType()}.\n      */\n+    @Override\n     public boolean isTypeInferred() {\n       return typeInferred;\n     }\n   /**\n    * Gets the type of {@code this} in the current scope.\n    */\n+  @Override\n   public ObjectType getTypeOfThis() {\n     return thisType;\n   }\n     vars.remove(var.name);\n   }\n \n+  @Override\n   public StaticSlot<JSType> getSlot(String name) {\n     return getVar(name);\n   }\n \n+  @Override\n   public StaticSlot<JSType> getOwnSlot(String name) {\n     return vars.get(name);\n   }\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n       this.aliasDefinition = aliasDefinition;\n     }\n \n+    @Override\n     public void applyAlias() {\n       aliasReference.getParent().replaceChild(\n           aliasReference, aliasDefinition.cloneTree());\n       this.correctedType = correctedType;\n     }\n \n+    @Override\n     public void applyAlias() {\n       aliasReference.setString(correctedType);\n     }\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n    */\n   private static final Function<TypePair, TypePair> EQ =\n     new Function<TypePair, TypePair>() {\n+      @Override\n       public TypePair apply(TypePair p) {\n         if (p.typeA == null || p.typeB == null) {\n           return null;\n    */\n   private static final Function<TypePair, TypePair> NE =\n     new Function<TypePair, TypePair>() {\n+      @Override\n       public TypePair apply(TypePair p) {\n         if (p.typeA == null || p.typeB == null) {\n           return null;\n   private static final\n       Function<TypePair, TypePair> SHEQ =\n     new Function<TypePair, TypePair>() {\n+      @Override\n       public TypePair apply(TypePair p) {\n         if (p.typeA == null || p.typeB == null) {\n           return null;\n   private static final\n       Function<TypePair, TypePair> SHNE =\n     new Function<TypePair, TypePair>() {\n+      @Override\n       public TypePair apply(TypePair p) {\n         if (p.typeA == null || p.typeB == null) {\n           return null;\n   private final\n       Function<TypePair, TypePair> INEQ =\n     new Function<TypePair, TypePair>() {\n+      @Override\n       public TypePair apply(TypePair p) {\n         return new TypePair(\n             getRestrictedWithoutUndefined(p.typeA),\n     super(convention, typeRegistry);\n   }\n \n+  @Override\n   public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n       FlowScope blindScope, boolean outcome) {\n     // Check for the typeof operator.\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n     }\n \n     private static class DegenerateEffectLocation implements EffectLocation {\n-       public EffectLocation join(EffectLocation otherLocation) {\n+       @Override\n+      public EffectLocation join(EffectLocation otherLocation) {\n         if (otherLocation == EVERY_LOCATION) {\n           return otherLocation;\n         } else {\n         }\n       }\n \n+      @Override\n       public boolean intersectsLocation(EffectLocation otherLocation) {\n         return this == EVERY_LOCATION && otherLocation == EVERY_LOCATION;\n       }\n \n+      @Override\n       public boolean isEmpty() {\n         return this == NO_LOCATION;\n       }\n--- a/src/com/google/javascript/jscomp/SimpleRegion.java\n+++ b/src/com/google/javascript/jscomp/SimpleRegion.java\n     this.source = source;\n   }\n \n+  @Override\n   public int getBeginningLineNumber() {\n     return beginningLineNumber;\n   }\n \n+  @Override\n   public int getEndingLineNumber() {\n     return endingLineNumber;\n   }\n \n+  @Override\n   public String getSourceExcerpt() {\n     return source;\n   }\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n     this.redeclarationHandler = redeclarationHandler;\n   }\n \n+  @Override\n   public Scope createScope(Node n, Scope parent) {\n     sourceName = null;\n     if (parent == null) {\n    * The default handler for duplicate declarations.\n    */\n   private class DefaultRedeclarationHandler implements RedeclarationHandler {\n+    @Override\n     public void onRedeclaration(\n         Scope s, String name, Node n, CompilerInput input) {\n       Node parent = n.getParent();\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n   ConcreteScope getTopScope() { return topScope; }\n \n   /** Convenience method to get the type registry of the compiler. */\n+  @Override\n   public JSTypeRegistry getTypeRegistry() { return compiler.getTypeRegistry(); }\n \n   /** All concrete instance types encountered during flow analysis. */\n       Preconditions.checkNotNull(expr);\n     }\n \n+    @Override\n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n       return Lists.newArrayList(\n           new Assignment(slot, inferConcreteType(scope, expression)));\n      * {@code propName}, and if that property exists, it is assigned the type\n      * of {@code expression}.\n      */\n+    @Override\n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n       ConcreteType recvType = inferConcreteType(scope, receiver);\n       ConcreteType exprType = inferConcreteType(scope, expression);\n       this.argTypes = argTypes;\n     }\n \n+    @Override\n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n       return getFunctionCallAssignments(inferConcreteType(scope, receiver),\n                                         thisType, argTypes);\n       Preconditions.checkNotNull(receiver);\n     }\n \n+    @Override\n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n       ConcreteType thisType = ConcreteType.NONE;\n       ConcreteType recvType = inferConcreteType(scope, receiver);\n       Preconditions.checkNotNull(receiver);\n     }\n \n+    @Override\n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n       ConcreteType thisType = (firstArgument != null)\n           ? inferConcreteType(scope, firstArgument)\n     }\n \n     // TODO(user): handle object literals like { a: new Foo };\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.VAR:\n   }\n \n   /** Returns the function (if any) for the given node. */\n+  @Override\n   public ConcreteFunctionType getConcreteFunction(FunctionType functionType) {\n     return functionFromJSType.get(functionType);\n   }\n \n   /** Returns the function (if any) for the given node. */\n+  @Override\n   public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) {\n     return instanceFromJSType.get(instanceType);\n   }\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n  *    Tracer.addTracingStatistic(myTracingStatistic)\n  * </pre>\n  * where myTracingStatistic implements the {@link TracingStatistic} interface.\n- * The class {@link com.google.monitoring.tracing.TracingStatistics} contains\n+ * The class com.google.monitoring.tracing.TracingStatistics contains\n  * several useful statistics such as cpu time, wait time, and memory usage.\n  * If you add your own tracing statistics, the output is not quite as pretty,\n  * but includes additional useful information.\n    * in unit tests.\n    */\n   static InternalClock clock = new InternalClock() {\n+    @Override\n     public long currentTimeMillis() {\n       return System.currentTimeMillis();\n     }\n    * A TracingStatistic allows the program to add additional optional\n    * statistics to the trace output.\n    *\n-   * The class {@link com.google.monitoring.tracing.TracingStatistics}\n+   * The class com.google.monitoring.tracing.TracingStatistics\n    * contains several useful tracing statistics\n    *\n    */\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n    * @param externsRoot The root of the externs parse tree.\n    * @param jsRoot The root of the input parse tree to be checked.\n    */\n+  @Override\n   public void process(Node externsRoot, Node jsRoot) {\n     Preconditions.checkNotNull(scopeCreator);\n     Preconditions.checkNotNull(topScope);\n     }\n   }\n \n+  @Override\n   public boolean shouldTraverse(\n       NodeTraversal t, Node n, Node parent) {\n     checkNoTypeCheckSection(n, true);\n    * @param n The node being visited.\n    * @param parent The parent of the node n.\n    */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n    * @param externsRoot The root of the externs parse tree.\n    * @param jsRoot The root of the input parse tree to be checked.\n    */\n+  @Override\n   public void process(Node externsRoot, Node jsRoot) {\n     Node externsAndJs = jsRoot.getParent();\n     Preconditions.checkState(externsAndJs != null);\n   }\n \n   private class TypeInferringCallback implements ScopedCallback {\n+    @Override\n     public void enterScope(NodeTraversal t) {\n       Scope scope = t.getScope();\n       Node node = t.getCurrentNode();\n       }\n     }\n \n+    @Override\n     public void exitScope(NodeTraversal t) {\n       Scope scope = t.getScope();\n       Node node = t.getCurrentNode();\n       }\n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       return true;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       // Do nothing\n     }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     }\n   }\n \n-  /**\n-   * Given a node, determines whether that node names a prototype\n-   * property, and if so, returns the qualified name node representing\n-   * the owner of that property. Otherwise, returns null.\n-   */\n-  private static Node getPrototypePropertyOwner(Node n) {\n-    if (n.getType() == Token.GETPROP) {\n-      Node firstChild = n.getFirstChild();\n-      if (firstChild.getType() == Token.GETPROP &&\n-          firstChild.getLastChild().getString().equals(\"prototype\")) {\n-        Node maybeOwner = firstChild.getFirstChild();\n-        if (maybeOwner.isQualifiedName()) {\n-          return maybeOwner;\n-        }\n-      }\n-    }\n-    return null;\n-  }\n-\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n         this.thisType = thisType;\n       }\n \n+      @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n         if (n.getType() == Token.EXPR_RESULT) {\n           Node child = n.getFirstChild();\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n    * a variable from getting renamed, but no longer have any effect.\n    */\n   private class NameRefInExternsCheck extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.NAME) {\n         switch (parent.getType()) {\n--- a/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n     super(source);\n   }\n \n+  @Override\n   public String formatError(JSError error) {\n     return getLevelName(CheckLevel.ERROR) + \": \" + format(error);\n   }\n \n+  @Override\n   public String formatWarning(JSError warning) {\n     return getLevelName(CheckLevel.WARNING) + \": \" + format(warning);\n   }\n--- a/src/com/google/javascript/jscomp/graph/Graph.java\n+++ b/src/com/google/javascript/jscomp/graph/Graph.java\n   public abstract GraphNode<N, E> createNode(N value);\n \n   /** Gets an immutable list of all nodes. */\n+  @Override\n   public abstract Collection<GraphNode<N, E>> getNodes();\n \n   /** Gets an immutable list of all edges. */\n    */\n   public abstract int getNodeDegree(N value);\n \n+  @Override\n   public int getWeight(N value) {\n     return getNodeDegree(value);\n   }\n     return node;\n   }\n \n+  @Override\n   public final void clearNodeAnnotations() {\n     for (GraphNode<N, E> n : getNodes()) {\n       n.setAnnotation(null);\n       this.graph = graph;\n     }\n \n+    @Override\n     public boolean isIndependentOf(N value) {\n       GraphNode<N, E> node = graph.getNode(value);\n       for (GraphNode<N, E> n : nodes) {\n       return true;\n     }\n \n+    @Override\n     public void addNode(N value) {\n       nodes.add(graph.getNodeOrFail(value));\n     }\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n \n import java.util.Collection;\n import java.util.Collections;\n   protected final Map<N, LinkedDirectedGraphNode<N, E>> nodes =\n       Maps.newHashMap();\n \n+  @Override\n   public SubGraph<N, E> newSubGraph() {\n     return new SimpleSubGraph<N, E>(this);\n   }\n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n-import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphEdge;\n \n import java.util.Collection;\n import java.util.Collections;\n   protected final Map<N, LinkedUndirectedGraphNode<N, E>> nodes =\n       Maps.newHashMap();\n \n+  @Override\n   public SubGraph<N, E> newSubGraph() {\n     return new SimpleSubGraph<N, E>(this);\n   }\n       return neighborList;\n     }\n \n+    @Override\n     public Iterator<UndiGraphEdge<N, E>> getNeighborEdgesIterator() {\n       return neighborList.iterator();\n     }\n--- a/src/com/google/javascript/jscomp/graph/StandardUnionFind.java\n+++ b/src/com/google/javascript/jscomp/graph/StandardUnionFind.java\n     }\n   }\n \n+  @Override\n   public void add(E e) {\n     union(e, e);\n   }\n \n+  @Override\n   public E union(E a, E b) {\n     Node<E> nodeA = findRootOrCreateNode(a);\n     Node<E> nodeB = findRootOrCreateNode(b);\n     return nodeB.element;\n   }\n \n+  @Override\n   public E find(E e) {\n     checkArgument(elmap.containsKey(e), \"Element does not exist: %s\", e);\n     return findRoot(elmap.get(e)).element;\n   }\n \n+  @Override\n   public boolean areEquivalent(E a, E b) {\n     E aRep = find(a);\n     E bRep = find(b);\n     return aRep == bRep;\n   }\n \n+  @Override\n   public Set<E> elements() {\n     return Collections.unmodifiableSet(elmap.keySet());\n   }\n \n+  @Override\n   public Collection<Set<E>> allEquivalenceClasses() {\n     Map<Node<E>, ImmutableSet.Builder<E>> groupsTmp = Maps.newHashMap();\n     for (Node<E> elem : elmap.values()) {\n     return node.parent;\n   }\n \n+  @Override\n   public Set<E> findAll(final E value) {\n     checkArgument(elmap.containsKey(value), \"Element does not exist: \" + value);\n \n       /** some node that's close to the root, or null */\n       Node<E> nodeForValue = elmap.get(value);\n \n+      @Override\n       public boolean apply(@Nullable Object b) {\n         if (Objects.equal(value, b)) {\n           return true;\n--- a/src/com/google/javascript/jscomp/jsonml/JsonMLError.java\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLError.java\n  */\n public class JsonMLError {\n \n-  /**  */\n-  private final DiagnosticType type;\n-\n   /** Description of the error */\n   public final String description;\n \n \n   private JsonMLError(DiagnosticType type, String sourceName, JsonML element,\n       int lineNumber, ErrorLevel level, String... arguments) {\n-    this.type = type;\n     this.description = type.format.format(arguments);\n     this.sourceName = sourceName;\n     this.element = element;\n \n   private JsonMLError(String description, DiagnosticType type,\n       String sourceName, JsonML element, int lineNumber, ErrorLevel level) {\n-    this.type = type;\n     this.description = description;\n     this.sourceName = sourceName;\n     this.element = element;\n--- a/src/com/google/javascript/jscomp/jsonml/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/jsonml/NodeUtil.java\n   /**\n    * Is this node a function declaration? A function declaration is a function\n    * that has a name that is added to the current scope (i.e. a function that\n-   * is not part of a expression; see {@link #isFunctionExpression}).\n+   * is not part of a expression).\n    */\n   static boolean isFunctionDeclaration(Node n) {\n     return n.getType() == Token.FUNCTION && isStatement(n);\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n       report(JSError.make(sourceName, lineno, charno, type, arguments));\n     }\n \n-    private void report(DiagnosticType type, String... arguments)\n-        throws JsonMLException {\n-      report(JSError.make(type, arguments));\n-    }\n-\n     /**\n      * Reports a new parser error to the compiler and terminates the job.\n      * @param error JSError instance to be passed to the compiler\n       int fromIndex, boolean newState) throws JsonMLException {\n     transformElements(element.getChildren().subList(\n         fromIndex, element.childrenSize()), parent, newState);\n-  }\n-\n-  private void transformAllChildrenFromIndex(JsonML element, Node parent,\n-      int fromIndex) throws JsonMLException {\n-    transformElements(element.getChildren().subList(\n-        fromIndex, element.childrenSize()), parent);\n   }\n \n   private void transformElements(List<JsonML> elements, Node parent,\n     insertExprResultState = true;\n   }\n \n+  /**\n+   * @throws JsonMLException\n+   */\n   private void transformThisExpr(JsonML element, Node parent)\n       throws JsonMLException {\n     parent.addChildToBack(createNode(Token.THIS, element));\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     }\n   }\n \n-  private void maybeSetLengthFrom(Node node, Node source) {\n-    if (config.isIdeMode) {\n-      node.setLength(source.getLength());\n-    }\n-  }\n-\n   private int position2charno(int position) {\n     int lineIndex = sourceString.lastIndexOf('\\n', position);\n     if (lineIndex == -1) {\n               operand.getType() == Token.GETELEM ||\n               operand.getType() == Token.NAME)) {\n           String msg =\n-              \"Invalid delete operand. Only properties can be deleted.\";;\n+              \"Invalid delete operand. Only properties can be deleted.\";\n           errorReporter.error(\n               msg,\n               sourceName,\n--- a/src/com/google/javascript/jscomp/parsing/NullErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/parsing/NullErrorReporter.java\n \n   private static class NewRhinoNullReporter extends NullErrorReporter\n       implements com.google.javascript.jscomp.mozilla.rhino.ErrorReporter {\n+    @Override\n     public com.google.javascript.jscomp.mozilla.rhino.EvaluatorException\n       runtimeError(String message, String sourceName, int line,\n                    String lineSource, int lineOffset) {\n \n   private static class OldRhinoNullReporter extends NullErrorReporter\n       implements ErrorReporter {\n+    @Override\n     public EvaluatorException runtimeError(String message, String sourceName,\n                                            int line, String lineSource,\n                                            int lineOffset) {\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n   /**\n    * Parses the JavaScript text given by a reader.\n    *\n-   * @param sourceName The filename.\n    * @param sourceString Source code from the file.\n    * @param errorReporter An error.\n    * @param logger A logger.\n--- a/src/com/google/javascript/jscomp/testing/TestErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/testing/TestErrorReporter.java\n     this.warnings = warnings;\n   }\n \n+  @Override\n   public void error(String message, String sourceName, int line,\n       String lineSource, int lineOffset) {\n     if (errors != null && errorsIndex < errors.length) {\n     }\n   }\n \n+  @Override\n   public void warning(String message, String sourceName, int line,\n       String lineSource, int lineOffset) {\n     if (warnings != null && warningsIndex < warnings.length) {\n     }\n   }\n \n+  @Override\n   public EvaluatorException runtimeError(String message, String sourceName,\n       int line, String lineSource, int lineOffset) {\n     return new EvaluatorException(\"JSCompiler test code: \" + message);\n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {\n         lastPass = new AmbiguateProperties(compiler, new char[]{'$'});\n         lastPass.process(externs, root);\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n         compiler, CheckLevel.WARNING);\n     if (injectNamespace) {\n       return new CompilerPass() {\n+        @Override\n         public void process(Node externs, Node js) {\n           checkGlobalNames.injectNamespace(\n               new GlobalNamespace(compiler, js))\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js,\n             new CoalesceVariableNames(compiler, usePseudoName));\n--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n       return this;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       assertEquals(Token.STRING, n.getType());\n       visited.append(n.getString());\n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       assertEquals(Token.STRING, n.getType());\n       shouldTraversed.append(n.getString());\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n     private final JSTypeRegistry registry = new JSTypeRegistry(\n         new TestErrorReporter(null, null));\n \n+    @Override\n     public JSTypeRegistry getTypeRegistry() {\n       return registry;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ConcreteFunctionType createConcreteFunction(\n         Node decl, StaticScope<ConcreteType> parent) {\n       ConcreteFunctionType funcType = functionByDeclaration.get(decl);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ConcreteInstanceType createConcreteInstance(\n         ObjectType instanceType) {\n       ConcreteInstanceType instType = instanceByJSType.get(instanceType);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ConcreteFunctionType getConcreteFunction(FunctionType functionType) {\n       return functionByJSType.get(functionType);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) {\n       return instanceByJSType.get(instanceType);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StaticScope<ConcreteType> createFunctionScope(\n         Node decl, StaticScope<ConcreteType> parent) {\n       FakeScope scope = new FakeScope((FakeScope) parent);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StaticScope<ConcreteType> createInstanceScope(\n         ObjectType instanceType) {\n       FakeScope parentScope = null;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StaticScope<ConcreteType> getParentScope() { return parent; }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StaticSlot<ConcreteType> getOwnSlot(String name) {\n       return slots.get(name);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public StaticSlot<ConcreteType> getSlot(String name) {\n       if (slots.containsKey(name)) {\n         return slots.get(name);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ConcreteType getTypeOfThis() { return ConcreteType.ALL; }\n \n     void addSlot(String name) {\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node js) {\n         new CreateSyntheticBlocks(compiler, START_MARKER, END_MARKER).process(\n             externs, js);\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(\n             compiler, js, new DeadAssignmentsElimination(compiler));\n--- a/test/com/google/javascript/jscomp/DenormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/DenormalizeTest.java\n       normalizePass = new NormalizeStatements(compiler, false);\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       NodeTraversal.traverse(compiler, root, normalizePass);\n       NodeTraversal.traverse(compiler, root, denormalizePass);\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n         compiler.getTypeRegistry());\n \n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {\n         checker.processForTesting(externs, root);\n \n--- a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java\n+++ b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java\n   }\n \n   private class CounterIncrementer implements EdgeCallback<Counter, String> {\n+    @Override\n     public boolean traverseEdge(Counter source, String e, Counter dest) {\n       dest.value++;\n       return dest.value <= maxChange;\n     try {\n       traversal = new FixedPointGraphTraversal<Counter, String>(\n         new EdgeCallback<Counter, String>() {\n+          @Override\n           public boolean traverseEdge(Counter source, String e, Counter dest) {\n             return true;\n           }\n--- a/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n   private static Supplier<String> getNameSupplier() {\n     return new Supplier<String>() {\n       int i = 0;\n+      @Override\n       public String get() {\n         return String.valueOf(i++);\n       }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n \n     // can-inline tester\n     Method tester = new Method() {\n+      @Override\n       public boolean call(NodeTraversal t, Node n, Node parent) {\n         CanInlineResult result = injector.canInlineReferenceToFunction(\n             t, n, fnNode, unsafe, mode,\n \n     // inline tester\n     Method tester = new Method() {\n+      @Override\n       public boolean call(NodeTraversal t, Node n, Node parent) {\n \n         CanInlineResult canInline = injector.canInlineReferenceToFunction(\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n \n     // inline tester\n     Method tester = new Method() {\n+      @Override\n       public boolean call(NodeTraversal t, Node n, Node parent) {\n \n         Node result = mutator.mutate(\n--- a/test/com/google/javascript/jscomp/FunctionTypeBuilderTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionTypeBuilderTest.java\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     // By turning on type checking, the FunctionTypeBuilder will be invoked.\n-    return new CompilerPass() { public void process(Node externs, Node js) {} };\n+    return new CompilerPass() {\n+          @Override\n+          public void process(Node externs, Node js) {}\n+        };\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n   }\n \n   private final Callback callback = new AbstractPostOrderCallback() {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       Scope s = t.getScope();\n       if (s.isGlobal()) {\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {\n         ScopeCreator scopeCreator =\n             new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n--- a/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java\n+++ b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java\n \n   private SourceExcerptProvider source(final String source) {\n     return new SourceExcerptProvider() {\n+      @Override\n       public String getSourceLine(String sourceName, int lineNumber) {\n         return source;\n       }\n+      @Override\n       public Region getSourceRegion(String sourceName, int lineNumber) {\n         throw new UnsupportedOperationException();\n       }\n--- a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n       chainB.inferSlotType(\"local\" + i,\n           i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);\n \n-      if (LONG_CHAIN_LENGTH % 7 == 0) {\n+      if (i % 7 == 0) {\n         chainA = chainA.createChildFlowScope();\n         chainB = chainB.createChildFlowScope();\n       }\n--- a/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n+++ b/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n       NodeTraversal.traverse(compiler, root, this);\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.NEW) {\n         if (!NodeUtil.constructorCallHasSideEffects(n)) {\n--- a/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n+++ b/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler));\n       }\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n       this.analyzer = new NameAnalyzer(compiler, true);\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       markNoSideEffectCalls.process(externs, root);\n       analyzer.process(externs, root);\n--- a/test/com/google/javascript/jscomp/NodeTraversalTest.java\n+++ b/test/com/google/javascript/jscomp/NodeTraversalTest.java\n       super(nodeTypes, include);\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       throw new UnsupportedOperationException();\n     }\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n     final Set<Node> set = Sets.newHashSet();\n     NodeTraversal.traverse(\n         getLastCompiler(), root, new AbstractPostOrderCallback() {\n+        @Override\n         public void visit(NodeTraversal t, Node node, Node parent) {\n           if (node.getBooleanProp(prop)) {\n             set.add(node);\n     @Override\n     public CompilerPass getProcessor(final Compiler compiler) {\n       return new CompilerPass() {\n+        @Override\n         public void process(Node externs, Node root) {\n           new CollapseProperties(compiler, false, true).process(externs, root);\n         }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n       return new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true);\n     } else {\n       return new CompilerPass() {\n+        @Override\n         public void process(Node externs, Node root) {\n           // Process the original code.\n           new ProcessClosurePrimitives(compiler, CheckLevel.OFF, true)\n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n       this.compiler = compiler;\n     }\n \n+    @Override\n     public void process(Node externs, Node js) {\n       namespace = new GlobalNamespace(compiler, js);\n       new ProcessDefines(compiler, overrides)\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n       NodeTraversal.traverse(compiler, root, this);\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.NEW) {\n         if (!NodeUtil.constructorCallHasSideEffects(n)) {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n       this.compiler = compiler;\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       ProcessClosurePrimitives closurePass =\n           new ProcessClosurePrimitives(compiler, CheckLevel.WARNING, true);\n--- a/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n     pass = new ReplaceStrings(compiler, \"`\", names, reserved);\n \n     return new CompilerPass() {\n+        @Override\n         public void process(Node externs, Node js) {\n           new CollapseProperties(compiler, true, true).process(externs, js);\n           pass.process(externs, js);\n--- a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n \n   public CompilerPass getProcessor(Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {}\n     };\n   }\n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n  *\n  */\n public class RuntimeTypeCheckTest extends CompilerTestCase {\n-\n-  private Node runtimeTypeCheckCode = null;\n \n   public RuntimeTypeCheckTest() {\n     super(\"/** @const */ var undefined;\");\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n       this.compiler = compiler;\n     }\n \n+    @Override\n     public void process(Node externs, Node root) {\n       NodeTraversal.traverse(compiler, root, this);\n     }\n \n+    @Override\n     public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n         Node parent) {\n       return true;\n     }\n \n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info != null) {\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n \n     }\n \n+    @Override\n     public void visit(NodeTraversal traversal, Node node, Node parent) {\n       Collection<Definition> defs =\n           passUnderTest.getDefinitionsReferencedAt(node);\n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n \n   @Override protected CompilerPass getProcessor(Compiler compiler) {\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {}\n     };\n   }\n--- a/test/com/google/javascript/jscomp/TypeValidatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypeValidatorTest.java\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     this.compiler = compiler;\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node n) {\n         // Do nothing: we're in it for the type-checking.\n       }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n   }\n \n   private final Callback callback = new AbstractPostOrderCallback() {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       Scope s = t.getScope();\n       if (s.isGlobal()) {\n   public CompilerPass getProcessor(final Compiler compiler) {\n     registry = compiler.getTypeRegistry();\n     return new CompilerPass() {\n+      @Override\n       public void process(Node externs, Node root) {\n         ScopeCreator scopeCreator =\n             new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n--- a/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n     graph.connect(\"E\", \"-->\", \"A\");\n \n     Comparator<String> lexicographic = new Comparator<String>() {\n+      @Override\n       public int compare(String o1, String o2) {\n         return o1.toString().compareTo(o2.toString());\n       }\n     assertEquals(\"A\", coloring.getPartitionSuperNode(\"C\"));\n \n     Comparator<String> biasD = new Comparator<String>() {\n+      @Override\n       public int compare(String o1, String o2) {\n         return o1.replaceAll(\"D\", \"@\").compareTo(o2.replaceAll(\"D\", \"@\"));\n       }\n--- a/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n   @Override\n   public void setUp() {\n     enableEcmaScript5(true);\n-  }\n-\n-  private void testConversion(String js, String jsonml) throws Exception {\n-    JsonML jsonMLRoot = JsonMLUtil.parseString(jsonml);\n-    Node root = parseExpectedJs(js);\n-    Node astRoot = root.getFirstChild();\n-    Preconditions.checkState(astRoot.getType() == Token.SCRIPT);\n-\n-\n-    // test JsonML -> AST conversion\n-    JsonMLAst ast = new JsonMLAst(jsonMLRoot);\n-    Node resultAstRoot = ast.getAstRoot(null);\n-\n-    String explanation = resultAstRoot.checkTreeEquals(astRoot);\n-    assertNull(\"JsonML converter returned an incorrect AST for \" + js + \".\\n\" +\n-        explanation, explanation);\n-\n-    // test AST -> JsonML conversion\n-    jsonMLRoot = JsonMLUtil.parseString(jsonml);\n-    Writer parser = new Writer();\n-    JsonML resultJsonMLRoot = parser.processAst(astRoot);\n-\n-    explanation = JsonMLUtil.compare(resultJsonMLRoot, jsonMLRoot);\n-    assertNull(\"AST converter returned an incorrect JsonML for \" + js + \".\\n\" +\n-        explanation, explanation);\n   }\n \n   private void testJsonMLToAstConversion(String js) throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n         testErrorReporter.hasEncounteredAllWarnings());\n   }\n \n+  @SuppressWarnings(\"unused\")\n   private JSDocInfo parseFileOverviewWithoutDoc(String comment,\n                                                 String... warnings) {\n     return parse(comment, false, true, warnings);", "timestamp": 1311895196, "metainfo": ""}