{"sha": "a2d8936fae3eb0e3873c7f7c0233344c81436404", "log": "Add warnings for functions that are ambiguously defined on different browsers.  Add better support for Caja.  Rollback the change to CoalesceVariableNames, because it had problems.  Internal type system refactoring.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n     }\n \n     invalidatingTypes.add(type);\n-    if (type instanceof InstanceObjectType) {\n-      invalidatingTypes.add(((ObjectType) type).getImplicitPrototype());\n+    ObjectType objType = ObjectType.cast(type);\n+    if (objType instanceof InstanceObjectType) {\n+      invalidatingTypes.add(objType.getImplicitPrototype());\n     }\n   }\n \n       relatedBitsets.put(type, related);\n     }\n \n-    ObjectType parentType = (ObjectType) type;\n+    ObjectType parentType = type.toObjectType();\n     while (parentType != null) {\n       related.set(getIntForType(parentType));\n       parentType = parentType.getImplicitPrototype();\n     } else if (type instanceof FunctionPrototypeType) {\n       constructor = ((FunctionPrototypeType) type).getOwnerFunction();\n     } else {\n-      constructor = ((ObjectType) type).getConstructor();\n+      constructor = type.toObjectType().getConstructor();\n     }\n     if (constructor != null) {\n       Set<ObjectType> interfaces = constructor.getAllImplementedInterfaces();\n         return false;\n       }\n     }\n-    return type == null || !(type instanceof ObjectType)\n-        || invalidatingTypes.contains(type)\n-        || !((ObjectType) type).hasReferenceName()\n-        || (type.isNamedType() && type.isUnknownType())\n-        || type.isEnumType() || type.autoboxesTo() != null;\n+    ObjectType objType = ObjectType.cast(type);\n+    return objType == null\n+        || invalidatingTypes.contains(objType)\n+        || !objType.hasReferenceName()\n+        || (objType.isNamedType() && objType.isUnknownType())\n+        || objType.isEnumType() || objType.autoboxesTo() != null;\n   }\n \n   private Property getProperty(String name) {\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n       return;\n     }\n \n-    JSType maybeObjectType = dereference(n.getFirstChild().getJSType());\n+    ObjectType objectType =\n+        ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n     String propertyName = n.getLastChild().getString();\n \n-    if (maybeObjectType != null &&\n-        maybeObjectType instanceof ObjectType) {\n-\n-      ObjectType objectType = (ObjectType) maybeObjectType;\n-\n+    if (objectType != null) {\n       String deprecationInfo\n           = getPropertyDeprecationInfo(objectType, propertyName);\n \n    */\n   private void checkPropertyVisibility(NodeTraversal t,\n       Node getprop, Node parent) {\n-    JSType maybeObjectType = dereference(getprop.getFirstChild().getJSType());\n+    ObjectType objectType =\n+        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n     String propertyName = getprop.getLastChild().getString();\n \n-    if (maybeObjectType != null &&\n-        maybeObjectType instanceof ObjectType) {\n+    if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n       boolean isOverride = t.inGlobalScope() &&\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n-      ObjectType objectType = (ObjectType) maybeObjectType;\n       if (isOverride) {\n         objectType = objectType.getImplicitPrototype();\n       }\n       }\n       return \"\";\n     }\n-    if (type instanceof ObjectType) {\n-      ObjectType implicitProto = ((ObjectType) type).getImplicitPrototype();\n+    ObjectType objType = ObjectType.cast(type);\n+    if (objType != null) {\n+      ObjectType implicitProto = objType.getImplicitPrototype();\n       if (implicitProto != null) {\n         return getTypeDeprecationInfo(implicitProto);\n       }\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n import com.google.javascript.jscomp.graph.GraphNode;\n-import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n-import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     CompilerPass, ScopedCallback {\n \n   private final AbstractCompiler compiler;\n-  private final Deque<GraphColoring<Var, Void>> colorings;\n-  private final boolean usePseudoNames;\n+  private final Deque<GraphColoring<Var, ?>> colorings;\n+\n+  /** Logs all name assignments */\n+  private StringBuilder coalescedLog;\n \n   private static final Comparator<Var> coloringTieBreaker =\n       new Comparator<Var>() {\n     }\n   };\n \n-  /**\n-   * @param usePseudoNames For debug purposes, when merging variable foo and bar\n-   * to foo, rename both variable to foo_bar.\n-   */\n-  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n+  CoalesceVariableNames(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     colorings = Lists.newLinkedList();\n-    this.usePseudoNames = usePseudoNames;\n+    coalescedLog = new StringBuilder();\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+\n+    // Lastly, write the report to the debug log.\n+    compiler.addToDebugLog(\"JS vars coalesced:\\n\" + coalescedLog.toString());\n+    coalescedLog = new StringBuilder();\n   }\n \n   @Override\n         computeVariableNamesInterferenceGraph(\n             t, cfg, liveness.getEscapedLocals());\n \n-    GraphColoring<Var, Void> coloring =\n+    GraphColoring<Var, ?> coloring =\n         new GreedyGraphColoring<Var, Void>(interferenceGraph,\n             coloringTieBreaker);\n \n       return;\n     }\n     Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n-    \n-    if (!usePseudoNames) {\n-      if (vNode.getValue().equals(coalescedVar)) {\n-        // The coalesced name is itself, nothing to do.\n-        return;\n-      }\n-\n-      // Rename.\n-      n.setString(coalescedVar.name);\n-      compiler.reportCodeChange();\n-\n-      if (NodeUtil.isVar(parent)) {\n-        removeVarDeclaration(n);\n-      }\n-    } else {\n-      // This code block is slow but since usePseudoName is for debugging,\n-      // we should not sacrifice performance for non-debugging compilation to\n-      // make this fast.\n-      String pseudoName = null;\n-      Set<String> allMergedNames = Sets.newTreeSet();\n-      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n-        Var iVar = i.next();\n-        if (coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n-          allMergedNames.add(iVar.name);\n-        }\n-      }\n-      \n-      // Keep its original name.\n-      if (allMergedNames.size() == 1) {\n-        return;\n-      }\n-      \n-      pseudoName = Join.join(\"_\", allMergedNames);\n-      \n-      while (t.getScope().isDeclared(pseudoName, true)) {\n-        pseudoName += \"$\";\n-      }\n-      \n-      n.setString(pseudoName);\n-      compiler.reportCodeChange();\n-\n-      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n-        removeVarDeclaration(n);\n-      }\n+    if (vNode.getValue().equals(coalescedVar)) {\n+      // The coalesced name is itself, nothing to do.\n+      return;\n+    }\n+\n+    if (var.getNameNode() == n) {\n+      coalescedLog.append(n.getString()).append(\" => \")\n+          .append(coalescedVar.name).append(\" in \")\n+          .append(t.getSourceName()).append(':')\n+          .append(n.getLineno()).append('\\n');\n+    }\n+\n+    // Rename.\n+    n.setString(coalescedVar.name);\n+    compiler.reportCodeChange();\n+\n+    if (NodeUtil.isVar(parent)) {\n+      removeVarDeclaration(n);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * coverage pass only, and skip all other passes.\n    */\n   public boolean instrumentForCoverageOnly;\n+\n+  /** Add code to skip properties that Caja adds to Object.prototype */\n+  public boolean ignoreCajaProperties;\n \n   public String syntheticBlockStartMarker;\n \n     // Alterations\n     instrumentForCoverage = false;\n     instrumentForCoverageOnly = false;\n+    ignoreCajaProperties = false;\n     syntheticBlockStartMarker = null;\n     syntheticBlockEndMarker = null;\n     locale = null;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(checkConsts);\n     }\n \n+    // The Caja library adds properties to Object.prototype, which breaks\n+    // most for-in loops.  This adds a check to each loop that skips\n+    // any property matching /___$/.\n+    if (options.ignoreCajaProperties) {\n+      passes.add(ignoreCajaProperties);\n+    }\n+\n     assertAllOneTimePasses(passes);\n \n     if (options.smartNameRemoval || options.reportPath != null) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return ((functionNames = new FunctionNames(compiler)));\n+    }\n+  };\n+\n+  /** Skips Caja-private properties in for-in loops */\n+  private final PassFactory ignoreCajaProperties =\n+      new PassFactory(\"ignoreCajaProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new IgnoreCajaProperties(compiler);\n     }\n   };\n \n       new PassFactory(\"coalesceVariableNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n+      return new CoalesceVariableNames(compiler);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n     }\n \n     typeSystem.addInvalidatingType(type);\n-    if (type instanceof ObjectType &&\n-        ((ObjectType) type).getImplicitPrototype() != null) {\n-      typeSystem.addInvalidatingType(\n-          ((ObjectType) type).getImplicitPrototype());\n+    ObjectType objType = ObjectType.cast(type);\n+    if (objType != null && objType.getImplicitPrototype() != null) {\n+      typeSystem.addInvalidatingType(objType.getImplicitPrototype());\n     }\n   }\n \n     }\n \n     @Override public boolean isInvalidatingType(JSType type) {\n-      return (type == null) || invalidatingTypes.contains(type)\n-          || (type instanceof ObjectType &&\n-              !((ObjectType) type).hasReferenceName())\n-          || (type.isNamedType() && type.isUnknownType());\n+      if (type == null || invalidatingTypes.contains(type) ||\n+          (type.isNamedType() && type.isUnknownType())) {\n+        return true;\n+      }\n+\n+      ObjectType objType = ObjectType.cast(type);\n+      return objType != null && !objType.hasReferenceName();\n     }\n \n     @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n       JSType skipType = type;\n       while (skipType != null) {\n         types.add(skipType);\n-        if (skipType instanceof ObjectType) {\n-          skipType = ((ObjectType) skipType).getImplicitPrototype();\n+\n+        ObjectType objSkipType = skipType.toObjectType();\n+        if (objSkipType != null) {\n+          skipType = objSkipType.getImplicitPrototype();\n         } else {\n           break;\n         }\n     @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n       if (type.isUnionType()) {\n         return ((UnionType) type).getAlternates();\n-      } else if (type instanceof ObjectType\n-          && ((ObjectType) type).getConstructor() != null\n-          && ((ObjectType) type).getConstructor().isInterface()) {\n-        List<JSType> list = Lists.newArrayList();\n-        for (FunctionType impl\n-            : registry.getDirectImplementors((ObjectType) type)) {\n-          list.add(impl.getInstanceType());\n-        }\n-        return list;\n       } else {\n-        return null;\n+        ObjectType objType = type.toObjectType();\n+        if (objType != null &&\n+            objType.getConstructor() != null &&\n+            objType.getConstructor().isInterface()) {\n+          List<JSType> list = Lists.newArrayList();\n+          for (FunctionType impl\n+                   : registry.getDirectImplementors(objType)) {\n+            list.add(impl.getInstanceType());\n+          }\n+          return list;\n+        } else {\n+          return null;\n+        }\n       }\n     }\n \n       // this appears.  This will make references to overriden properties look\n       // like references to the initial property, so they are renamed alike.\n       ObjectType foundType = null;\n-      ObjectType objType = (ObjectType) type;\n+      ObjectType objType = ObjectType.cast(type);\n       while (objType != null && objType.getImplicitPrototype() != objType) {\n         if (objType.hasOwnProperty(field)) {\n           foundType = objType;\n     @Override\n     public void recordInterfaces(JSType type, JSType relatedType,\n                                  DisambiguateProperties<JSType>.Property p) {\n-      if (type instanceof ObjectType) {\n+      ObjectType objType = ObjectType.cast(type);\n+      if (objType != null) {\n         FunctionType constructor;\n-        if (type instanceof FunctionType) {\n-          constructor = (FunctionType) type;\n-        } else if (type instanceof FunctionPrototypeType) {\n-          constructor = ((FunctionPrototypeType) type).getOwnerFunction();\n+        if (objType instanceof FunctionType) {\n+          constructor = (FunctionType) objType;\n+        } else if (objType instanceof FunctionPrototypeType) {\n+          constructor = ((FunctionPrototypeType) objType).getOwnerFunction();\n         } else {\n-          constructor = ((ObjectType) type).getConstructor();\n+          constructor = objType.getConstructor();\n         }\n         while (constructor != null) {\n           List<ObjectType> interfaces = constructor.getImplementedInterfaces();\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       // base type\n       if (info.hasBaseType()) {\n         if (isConstructor || isInterface) {\n-          JSType maybeBaseType = info.getBaseType().evaluate(scope);\n-          if (maybeBaseType instanceof ObjectType) {\n-            baseType = (ObjectType) maybeBaseType;\n-          } else {\n-            reportWarning(EXTENDS_NON_OBJECT,\n-                fnName, maybeBaseType.toString());\n+          baseType = ObjectType.cast(info.getBaseType().evaluate(scope));\n+          if (baseType == null) {\n+            reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString());\n           }\n         } else {\n           reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n       if (isConstructor || isInterface) {\n         implementedInterfaces = Lists.newArrayList();\n         for (JSTypeExpression t : info.getImplementedInterfaces()) {\n-          JSType interType = t.evaluate(scope);\n-          if (interType instanceof ObjectType) {\n-            implementedInterfaces.add((ObjectType) interType);\n+          ObjectType interType = ObjectType.cast(t.evaluate(scope));\n+          if (interType != null) {\n+            implementedInterfaces.add(interType);\n           } else {\n             reportError(BAD_IMPLEMENTED_TYPE, fnName);\n           }\n    * @param type The type of this.\n    */\n   FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {\n-    if (type instanceof ObjectType &&\n-        (info == null || !info.hasType())) {\n-      thisType = (ObjectType) type;\n+    ObjectType objType = ObjectType.cast(type);\n+    if (objType != null && (info == null || !info.hasType())) {\n+      thisType = objType;\n     }\n     return this;\n   }\n    */\n   FunctionTypeBuilder inferThisType(JSDocInfo info,\n       @Nullable Node owner) {\n-    JSType maybeThisType = null;\n+    ObjectType maybeThisType = null;\n     if (info != null && info.hasThisType()) {\n-      maybeThisType = info.getThisType().evaluate(scope);\n-    }\n-    if (maybeThisType != null && maybeThisType instanceof ObjectType) {\n+      maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope));\n+    }\n+    if (maybeThisType != null) {\n       // TODO(user): Doing an instanceof check here is too\n       // restrictive as (Date,Error) is, for instance, an object type\n       // even though its implementation is a UnionType. Would need to\n       // create interfaces JSType, ObjectType, FunctionType etc and have\n       // separate implementation instead of the class hierarchy, so that\n       // union types can also be object types, etc.\n-      thisType = (ObjectType) maybeThisType;\n+      thisType = maybeThisType;\n     } else if (owner != null &&\n                (info == null || !info.hasType())) {\n       // If the function is of the form:\n       // /** @type {Function} */ x.prototype.y;\n       // then we should not give it a @this type.\n       String ownerTypeName = owner.getQualifiedName();\n-      JSType ownerType = typeRegistry.getType(\n-          scope, ownerTypeName, sourceName,\n-          owner.getLineno(), owner.getCharno());\n-      if (ownerType instanceof ObjectType) {\n-        thisType = (ObjectType) ownerType;\n+      ObjectType ownerType = ObjectType.cast(\n+          typeRegistry.getType(\n+              scope, ownerTypeName, sourceName,\n+              owner.getLineno(), owner.getCharno()));\n+      if (ownerType != null) {\n+        thisType = ownerType;\n       }\n     }\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Caja is a system that rewrites web content (JavaScript, CSS, HTML)\n+ * into web content that is safe to inline directly into a page.  \n+ * The rewritten (\"cajoled\") code runs in the presence of a JS library\n+ * that adds some properties to Object.prototype.  Because JS does not\n+ * yet (until ES5) allow programmers to mark properties as DontEnum,\n+ * for..in loops will see unexpected properties.\n+ *\n+ * This pass adds a conditional to for..in loops that filters out these\n+ * properties.\n+ *\n+*\n+ */\n+\n+class IgnoreCajaProperties implements CompilerPass {\n+\n+  final AbstractCompiler compiler;\n+  \n+  // Counts the number of temporary variables introduced.\n+  int counter;\n+ \n+  public IgnoreCajaProperties(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+    this.counter = 0;\n+  }\n+ \n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new Traversal());\n+  }\n+ \n+  private class Traversal extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Look for a for..in loop.\n+      if (n.getType() == Token.FOR && n.getChildCount() == 3) {\n+        Node body = n.getLastChild();\n+        n.removeChild(body);\n+        Node key = n.getFirstChild();\n+        n.removeChild(key);\n+        Node tmp = Node.newString(Token.NAME, \n+            \"JSCompiler_IgnoreCajaProperties_\" + counter++);\n+        n.addChildToFront(new Node(Token.VAR, tmp));\n+        Node assignment;\n+        Node ifBody;\n+\n+        // Construct the body of the if statement.\n+        if (key.getType() == Token.VAR) {\n+          // for (var key in x) { body; } \n+          // => \n+          // for (var tmp in x) {\n+          //   if (!tmp.match(/___$/)) {\n+          //     var key;\n+          //     key = tmp;\n+          //     body;\n+          //   }\n+          // }\n+          ifBody = new Node(\n+              Token.BLOCK,\n+              key,\n+              new Node(\n+                  Token.EXPR_RESULT,\n+                  new Node(\n+                    Token.ASSIGN, \n+                    key.getFirstChild().cloneNode(), \n+                    tmp.cloneTree())),\n+              body);\n+        } else {\n+          // for (key in x) { body; } \n+          // => \n+          // for (var tmp in x) {\n+          //   if (!tmp.match(/___$/)) {\n+          //     key = tmp;\n+          //     body;\n+          //   }\n+          // }\n+          ifBody = new Node(\n+              Token.BLOCK,\n+              new Node(\n+                  Token.EXPR_RESULT,\n+                  new Node(\n+                    Token.ASSIGN, \n+                    key, \n+                    tmp.cloneTree())),\n+              body);\n+        }          \n+\n+        // Construct the new body of the for loop.\n+        Node newBody = new Node(\n+            Token.BLOCK, \n+            new Node(\n+                Token.IF, \n+                new Node(\n+                    Token.NOT, \n+                    new Node(\n+                        Token.CALL, \n+                        new Node(\n+                            Token.GETPROP, \n+                            tmp.cloneTree(), \n+                            Node.newString(\"match\")), \n+                        new Node(\n+                            Token.REGEXP, \n+                            Node.newString(\"___$\")))), \n+                ifBody));\n+        n.addChildToBack(newBody);\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n    * Dereferences the given type to an object, or returns null.\n    */\n   private ObjectType dereferenceToObject(JSType type) {\n-    type = type == null ? null : type.dereference();\n-    return (type instanceof ObjectType) ? (ObjectType) type : null;\n+    return ObjectType.cast(type == null ? null : type.dereference());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n       instanceType = boxedType != null ? boxedType : instanceType;\n \n       // Retrieves the property.\n-      Preconditions.checkState(instanceType instanceof ObjectType);\n-      ObjectType objType = (ObjectType) instanceType;\n+      ObjectType objType = instanceType.toObjectType();\n+      Preconditions.checkState(objType != null);\n \n       if (!isExtern) {\n         // Don't count reference in extern as a use.\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Is this node a hoisted function declaration? A function declaration in the\n+   * scope root is hoisted to the top of the scope.\n+   * See {@link #isFunctionDeclaration}).\n+   */\n+  static boolean isHoistedFunctionDeclaration(Node n) {\n+    return NodeUtil.isFunctionDeclaration(n)\n+        && (n.getParent().getType() == Token.SCRIPT\n+            || n.getParent().getParent().getType() == Token.FUNCTION);\n+  }\n+\n+\n+  /**\n    * Is this node an anonymous function? An anonymous function is one that has\n    * either no name or a name that is not added to the current scope (see\n    * {@link #isFunctionAnonymous}).\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     }\n \n     boolean isHoistedFunction() {\n-      return NodeUtil.isFunctionDeclaration(parent) &&\n-          (grandparent.getType() == Token.SCRIPT ||\n-           grandparent.getParent().getType() == Token.FUNCTION);\n+      return NodeUtil.isHoistedFunctionDeclaration(parent);\n     }\n \n     /**\n      * Determines whether the block may not be part of the normal control flow,\n      * but instead \"hoisted\" to the top of the scope.\n      */\n-    private final boolean mayBeHoisted;\n+    private final boolean isHoisted;\n \n     /**\n      * Creates a new block.\n       this.parent = parent;\n \n       // only named functions may be hoisted.\n-      this.mayBeHoisted = (root.getType() == Token.FUNCTION) &&\n-          !NodeUtil.isFunctionAnonymous(root);\n+      this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n     }\n \n     BasicBlock getParent() {\n       for (currentBlock = thatBlock;\n            currentBlock != null && currentBlock != this;\n            currentBlock = currentBlock.getParent()) {\n-        if (currentBlock.mayBeHoisted) {\n+        if (currentBlock.isHoisted) {\n           return false;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n    * @param propertyName The string of the left-side of the in.\n    */\n   private FlowScope caseIn(Node object, String propertyName, FlowScope blindScope) {\n-    JSType objectType = object.getJSType();\n-    objectType = this.getRestrictedWithoutNull(objectType);\n-    objectType = this.getRestrictedWithoutUndefined(objectType);\n+    JSType jsType = object.getJSType();\n+    jsType = this.getRestrictedWithoutNull(jsType);\n+    jsType = this.getRestrictedWithoutUndefined(jsType);\n+\n     boolean hasProperty = false;\n-    if (objectType instanceof ObjectType) {\n-      hasProperty = ((ObjectType) objectType).hasProperty(propertyName);\n+    ObjectType objectType = ObjectType.cast(jsType);\n+    if (objectType != null) {\n+      hasProperty = objectType.hasProperty(propertyName);\n     }\n     if (!hasProperty) {\n       String qualifiedName = object.getQualifiedName();\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n         return Lists.<Action>newArrayList();\n       }\n \n-      JSType objType = getJSType(receiver.getFirstChild())\n-          .restrictByNotNullOrUndefined();\n+      ObjectType objType = ObjectType.cast(\n+          getJSType(receiver.getFirstChild())\n+          .restrictByNotNullOrUndefined());\n       String prop = receiver.getLastChild().getString();\n-      if (objType instanceof ObjectType &&\n-          (((ObjectType) objType).isPropertyInExterns(prop)) &&\n+      if (objType != null &&\n+          (objType.isPropertyInExterns(prop)) &&\n           ((FunctionType) recvType).getParameters() != null) {\n         List<Action> actions = Lists.newArrayList();\n \n       if (jsType instanceof UnionType) {\n         boolean found = false;\n         for (JSType alt : ((UnionType) jsType).getAlternates()) {\n-          if (alt instanceof ObjectType) {\n-            ObjectType altObj = (ObjectType) alt;\n+          ObjectType altObj = ObjectType.cast(alt);\n+          if (altObj != null) {\n             actions.addAll(getImplicitActionsFromPropNonUnion(\n                   altObj, prop, fnNode));\n             if (altObj.hasProperty(prop)) {\n         if (found) {\n           return actions;\n         }\n-      } else if (jsType instanceof ObjectType && !jsType.isUnknownType()) {\n-        ObjectType objType = (ObjectType) jsType;\n-        if (objType.hasProperty(prop)) {\n+      } else {\n+        ObjectType objType = ObjectType.cast(jsType);\n+        if (objType != null &&\n+            !objType.isUnknownType() && objType.hasProperty(prop)) {\n           return getImplicitActionsFromPropNonUnion(objType, prop, fnNode);\n         }\n       }\n     }\n \n     if (jsType.isObject()) {\n-      return createConcreteInstance((ObjectType) jsType);\n+      return createConcreteInstance(jsType.toObjectType());\n     }\n \n     return ConcreteType.NONE;  // Not a reference type.\n         ret = ret.unionWith(createTypeWithSubTypes(alt));\n       }\n     } else {\n-      if (jsType instanceof ObjectType\n-        && ((ObjectType) jsType).getConstructor() != null\n-            && ((ObjectType) jsType).getConstructor().isInterface()) {\n-        ObjectType instType = (ObjectType) jsType;\n-\n+      ObjectType instType = ObjectType.cast(jsType);\n+      if (instType != null &&\n+          instType.getConstructor() != null &&\n+          instType.getConstructor().isInterface()) {\n         Collection<FunctionType> implementors =\n             getTypeRegistry().getDirectImplementors(instType);\n \n       case Token.OBJECTLIT:\n         if ((expr.getJSType() != null) && !expr.getJSType().isUnknownType()) {\n           JSType exprType = expr.getJSType().restrictByNotNullOrUndefined();\n-          ConcreteType inst = createConcreteInstance((ObjectType) exprType);\n+          ConcreteType inst = createConcreteInstance(exprType.toObjectType());\n           allInstantiatedTypes.add(inst);\n           ret = inst;\n         } else {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       }\n \n       // object.property = ...;\n-      JSType type = objectJsType.restrictByNotNullOrUndefined();\n-      if (type instanceof ObjectType) {\n-        ObjectType objectType = (ObjectType) type;\n-        if (objectType.hasProperty(property)) {\n-          if (!objectType.isPropertyTypeInferred(property) &&\n-              !propertyIsImplicitCast(objectType, property)) {\n-            validator.expectCanAssignToPropertyOf(\n-                t, assign, getJSType(rvalue),\n-                objectType.getPropertyType(property), object, property);\n-          }\n+      ObjectType type = ObjectType.cast(\n+          objectJsType.restrictByNotNullOrUndefined());\n+      if (type != null) {\n+        if (type.hasProperty(property) &&\n+            !type.isPropertyTypeInferred(property) &&\n+            !propertyIsImplicitCast(type, property)) {\n+          validator.expectCanAssignToPropertyOf(\n+              t, assign, getJSType(rvalue),\n+              type.getPropertyType(property), object, property);\n         }\n         return;\n       }\n           continue;\n         }\n         FunctionType interfaceType =\n-            ((ObjectType) implementedInterface).getConstructor();\n+            implementedInterface.toObjectType().getConstructor();\n         boolean interfaceHasProperty =\n             interfaceType.getPrototype().hasProperty(propertyName);\n         foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n \n       for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n         boolean badImplementedType = false;\n-        if (baseInterface instanceof ObjectType) {\n+        ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n+        if (baseInterfaceObj != null) {\n           FunctionType interfaceConstructor =\n-              ((ObjectType) baseInterface).getConstructor();\n+              baseInterfaceObj.getConstructor();\n           if (interfaceConstructor != null &&\n               !interfaceConstructor.isInterface()) {\n             badImplementedType = true;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n    * Defines a property if the property has not been defined yet.\n    */\n   private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    JSType ownerType =\n-        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined();\n-    if (ownerType instanceof ObjectType) {\n-      ObjectType objectType = (ObjectType) ownerType;\n+    ObjectType objectType = ObjectType.cast(\n+        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n+    if (objectType != null) {\n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;\n       }\n    * be known in {@code TypedScopeCreator}.\n    */\n   private void ensurePropertyDeclared(Node getprop) {\n-    JSType ownerType =\n-        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined();\n-    if (ownerType instanceof ObjectType) {\n-      ensurePropertyDeclaredHelper(getprop, (ObjectType) ownerType);\n+    ObjectType ownerType = ObjectType.cast(\n+        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n+    if (ownerType != null) {\n+      ensurePropertyDeclaredHelper(getprop, ownerType);\n     }\n   }\n \n \n   private FlowScope traverseGetElem(Node n, FlowScope scope) {\n     scope = traverseChildren(n, scope);\n-    JSType objType =\n-        getJSType(n.getFirstChild()).restrictByNotNullOrUndefined();\n-    if (objType instanceof ObjectType) {\n-      JSType type = ((ObjectType) objType).getParameterType();\n+    ObjectType objType = ObjectType.cast(\n+        getJSType(n.getFirstChild()).restrictByNotNullOrUndefined());\n+    if (objType != null) {\n+      JSType type = objType.getParameterType();\n       if (type != null) {\n         n.setJSType(type);\n       }\n     if ((propertyType == null || propertyType.isUnknownType()) &&\n         qualifiedName != null) {\n       // If we find this node in the registry, then we can infer its type.\n-      JSType regType = registry.getType(qualifiedName);\n-      if (regType instanceof ObjectType) {\n-        propertyType = ((ObjectType) regType).getConstructor();\n+      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n+      if (regType != null) {\n+        propertyType = regType.getConstructor();\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       JSType indexType) {\n     if (objType.isUnknownType()) {\n       expectStringOrNumber(t, n, indexType, \"property access\");\n-    } else if (objType instanceof ObjectType &&\n-        ((ObjectType) objType).getIndexType() != null) {\n-      expectCanAssignTo(t, n, indexType, ((ObjectType) objType).getIndexType(),\n+    } else if (objType.toObjectType() != null &&\n+        objType.toObjectType().getIndexType() != null) {\n+      expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(),\n           \"restricted index type\");\n     } else if (objType.isArrayType()) {\n       expectNumber(t, n, indexType, \"array access\");\n \n     String qualifiedName = n.getQualifiedName();\n     if (type.isFunctionPrototypeType() ||\n-        (type instanceof ObjectType &&\n-         ((ObjectType) type).getConstructor() != null)) {\n+        (type.toObjectType() != null &&\n+         type.toObjectType().getConstructor() != null)) {\n       return type.toString();\n     } else if (qualifiedName != null) {\n       return qualifiedName;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n             Var var = scope.getVar(\n                 lvalueNode.getFirstChild().getQualifiedName());\n             if (var != null) {\n-              JSType ownerType = var.getType();\n-              if (ownerType instanceof ObjectType) {\n+              ObjectType ownerType = ObjectType.cast(var.getType());\n+              if (ownerType != null) {\n                 String propName = lvalueNode.getLastChild().getString();\n-                JSType propType =\n-                    ((ObjectType) ownerType).getPropertyType(propName);\n+                JSType propType = ownerType.getPropertyType(propName);\n                 if (propType instanceof FunctionType) {\n                   functionType =\n                       new FunctionTypeBuilder(\n           SubclassRelationship relationship =\n               codingConvention.getClassesDefinedByCall(n);\n           if (relationship != null) {\n-            JSType superClass =\n-                typeRegistry.getType(relationship.superclassName);\n-            JSType subClass = typeRegistry.getType(relationship.subclassName);\n-            if (superClass instanceof ObjectType &&\n-                subClass instanceof ObjectType) {\n-              ObjectType superObject = (ObjectType) superClass;\n-              ObjectType subObject = (ObjectType) subClass;\n-\n-              FunctionType superCtor = superObject.getConstructor();\n-              FunctionType subCtor = subObject.getConstructor();\n+            ObjectType superClass = ObjectType.cast(\n+                typeRegistry.getType(relationship.superclassName));\n+            ObjectType subClass = ObjectType.cast(\n+                typeRegistry.getType(relationship.subclassName));\n+            if (superClass != null && subClass != null) {\n+              FunctionType superCtor = superClass.getConstructor();\n+              FunctionType subCtor = subClass.getConstructor();\n \n               if (relationship.type == SubclassType.INHERITS) {\n-                validator.expectSuperType(t, n, superObject, subObject);\n+                validator.expectSuperType(t, n, superClass, subClass);\n               }\n \n               if (superCtor != null && subCtor != null) {\n           String singletonGetterClassName =\n               codingConvention.getSingletonGetterClassName(n);\n           if (singletonGetterClassName != null) {\n-            JSType classType = typeRegistry.getType(singletonGetterClassName);\n-            if (classType instanceof ObjectType) {\n-              ObjectType objectType = (ObjectType) classType;\n+            ObjectType objectType = ObjectType.cast(\n+                typeRegistry.getType(singletonGetterClassName));\n+            if (objectType != null) {\n               FunctionType functionType = objectType.getConstructor();\n \n               if (functionType != null) {\n           DelegateRelationship delegateRelationship =\n               codingConvention.getDelegateRelationship(n);\n           if (delegateRelationship != null) {\n-            JSType delegatorClass =\n-                typeRegistry.getType(delegateRelationship.delegator);\n-            JSType delegateBaseClass =\n-                typeRegistry.getType(delegateRelationship.delegateBase);\n-            JSType delegateSuperClass = typeRegistry.getType(\n-                codingConvention.getDelegateSuperclassName());\n-            if (delegatorClass instanceof ObjectType &&\n-                delegateBaseClass instanceof ObjectType &&\n-                delegateSuperClass instanceof ObjectType) {\n-              ObjectType delegatorObject = (ObjectType) delegatorClass;\n-              ObjectType delegateBaseObject = (ObjectType) delegateBaseClass;\n-              ObjectType delegateSuperObject = (ObjectType) delegateSuperClass;\n-\n+            ObjectType delegatorObject = ObjectType.cast(\n+                typeRegistry.getType(delegateRelationship.delegator));\n+            ObjectType delegateBaseObject = ObjectType.cast(\n+                typeRegistry.getType(delegateRelationship.delegateBase));\n+            ObjectType delegateSuperObject = ObjectType.cast(\n+                typeRegistry.getType(\n+                    codingConvention.getDelegateSuperclassName()));\n+            if (delegatorObject != null &&\n+                delegateBaseObject != null &&\n+                delegateSuperObject != null) {\n               FunctionType delegatorCtor = delegatorObject.getConstructor();\n               FunctionType delegateBaseCtor =\n                   delegateBaseObject.getConstructor();\n                     typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n                 FunctionType findDelegate = new FunctionType(\n                     typeRegistry, null, null, functionParamBuilder.build(),\n-                    typeRegistry.createNullableType(delegateBaseClass), null);\n+                    typeRegistry.createNullableType(delegateBaseObject), null);\n \n                 FunctionType delegateProxy =\n                     typeRegistry.createConstructorType(\n           ObjectLiteralCast objectLiteralCast =\n               codingConvention.getObjectLiteralCast(t, n);\n           if (objectLiteralCast != null) {\n-            JSType type = typeRegistry.getType(objectLiteralCast.typeName);\n-            if (type instanceof ObjectType &&\n-                ((ObjectType) type).getConstructor() != null) {\n+            ObjectType type = ObjectType.cast(\n+                typeRegistry.getType(objectLiteralCast.typeName));\n+            if (type != null && type.getConstructor() != null) {\n               objectLiteralCast.objectNode.setJSType(type);\n             } else {\n               compiler.report(JSError.make(t.getSourceName(), n,\n       Var ownerVar = scope.getVar(slotName);\n       if (ownerVar != null) {\n         JSType ownerVarType = ownerVar.getType();\n-        ownerVarType = ownerVarType == null ?\n-            null : ownerVarType.restrictByNotNullOrUndefined();\n-\n-        if (ownerVarType instanceof ObjectType) {\n-          return (ObjectType) ownerVarType;\n-        }\n+        return ObjectType.cast(ownerVarType == null ?\n+            null : ownerVarType.restrictByNotNullOrUndefined());\n       }\n       return null;\n     }\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n       \"JSC_REDECLARED_VARIABLE\",\n       \"Redeclared variable: {0}\");\n \n+  static final DiagnosticType AMBIGUOUS_FUNCTION_DECL =\n+    DiagnosticType.warning(\"AMBIGUIOUS_FUNCTION_DECL\",\n+        \"Ambiguious use of a named function: {0}.\");\n+\n   private AbstractCompiler compiler;\n   private CheckLevel checkLevel;\n \n     private void checkVar(NodeTraversal t, Var v, List<Reference> references) {\n       blocksWithDeclarations.clear();\n       boolean isDeclaredInScope = false;\n+      boolean isUnhoistedNamedFunction = false;\n       Reference hoistedFn = null;\n \n       // Look for hoisted functions.\n           isDeclaredInScope = true;\n           hoistedFn = reference;\n           break;\n+        } else if (NodeUtil.isFunctionDeclaration(\n+            reference.getNameNode().getParent())) {\n+          isUnhoistedNamedFunction = true;\n         }\n       }\n \n                       reference.getNameNode(),\n                       checkLevel,\n                       REDECLARED_VARIABLE, v.name));\n+              break;\n+            }\n+          }\n+        }\n+\n+        if (!isDeclaration && isDeclaredInScope && isUnhoistedNamedFunction) {\n+          // Only allow an unhoisted named function to be used within the\n+          // block it is declared.\n+          for (BasicBlock declaredBlock : blocksWithDeclarations) {\n+            if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n+              compiler.report(\n+                  JSError.make(reference.getSourceName(),\n+                      reference.getNameNode(),\n+                      checkLevel,\n+                      AMBIGUOUS_FUNCTION_DECL, v.name));\n               break;\n             }\n           }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     /**\n      * Returns the set of ES5 directives for this node.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public Set<String> getDirectives() {\n         return (Set<String>) getProp(DIRECTIVES);\n     }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n       String name) {\n     super(registry);\n     this.primitiveType = elementType;\n-    this.primitiveObjectType = elementType instanceof ObjectType ?\n-        (ObjectType) elementType : null;\n+    this.primitiveObjectType = elementType.toObjectType();\n     this.name = name;\n   }\n \n   public boolean equals(Object that) {\n     if (this == that) {\n       return true;\n-    } else if (this.isNominalType() && that instanceof JSType &&\n-        ((JSType) that).isNominalType()) {\n-      return getReferenceName().equals(((ObjectType) that).getReferenceName());\n+    } else if (that instanceof JSType && this.isNominalType()) {\n+      ObjectType thatObj = ObjectType.cast((JSType) that);\n+      if (thatObj != null && thatObj.isNominalType()) {\n+        return getReferenceName().equals(thatObj.getReferenceName());\n+      }\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   boolean defineProperty(String name, JSType type,\n       boolean inferred, boolean inExterns) {\n     if (\"prototype\".equals(name)) {\n-      if (type instanceof ObjectType) {\n-        ObjectType objType = (ObjectType) type;\n+      ObjectType objType = type.toObjectType();\n+      if (objType != null) {\n         return setPrototype(\n             new FunctionPrototypeType(\n                 registry, this, objType, isNativeObjectType()));\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   public boolean equals(Object that) {\n     if (this == that) {\n       return true;\n-    } else if (this.isNominalType() && that instanceof JSType &&\n-        ((JSType) that).isNominalType()) {\n-      return getReferenceName().equals(((ObjectType) that).getReferenceName());\n+    } else if (that instanceof JSType && this.isNominalType()) {\n+      ObjectType thatObj = ObjectType.cast((JSType) that);\n+      if (thatObj != null && thatObj.isNominalType()) {\n+        return getReferenceName().equals(thatObj.getReferenceName());\n+      }\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    *     have properties, or if the type is not found.\n    */\n   public JSType findPropertyType(String propertyName) {\n-    JSType autoboxObjType = autoboxesTo();\n-    if (autoboxObjType != null &&\n-        autoboxObjType instanceof ObjectType) {\n-      return ((ObjectType) autoboxObjType).findPropertyType(propertyName);\n+    ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());\n+    if (autoboxObjType != null) {\n+      return autoboxObjType.findPropertyType(propertyName);\n     }\n \n     return null;\n   }\n \n   /**\n+   * Casts this to an ObjectType, or returns null if this is not an ObjectType.\n+   *\n+   * Does not change the underlying JS type. If you want to simulate JS\n+   * autoboxing or dereferencing, you should use autoboxesTo() or dereference().\n+   * Those methods may change the underlying JS type.\n+   */\n+  public ObjectType toObjectType() {\n+    return this instanceof ObjectType ? (ObjectType) this : null;\n+  }\n+\n+  /**\n    * Dereference a type for property access.\n    *\n    * Autoboxes the type, filters null/undefined, and returns the result\n   public final ObjectType dereference() {\n     JSType restricted = restrictByNotNullOrUndefined();\n     JSType autobox = restricted.autoboxesTo();\n-    JSType result =  autobox == null ? restricted : autobox;\n-    return result instanceof ObjectType ?\n-        (ObjectType) result : null;\n+    return ObjectType.cast(autobox == null ? restricted : autobox);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n           JSTypeNative.GLOBAL_THIS);\n       JSType windowType = getType(\"Window\");\n       if (globalThis.isUnknownType()) {\n-        if (windowType instanceof ObjectType) {\n-          globalThis.setImplicitPrototype((ObjectType) windowType);\n+        ObjectType windowObjType = ObjectType.cast(windowType);\n+        if (windowObjType != null) {\n+          globalThis.setImplicitPrototype(windowObjType);\n         } else {\n           globalThis.setImplicitPrototype(\n               getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n         Node current = n.getFirstChild();\n         if (current.getType() == Token.THIS) {\n           Node thisNode = current.getFirstChild();\n-          JSType maybeThisType =\n-              createFromTypeNodes(thisNode, sourceName, scope)\n-              .restrictByNotNullOrUndefined();\n-          if (maybeThisType instanceof ObjectType) {\n-            thisType = (ObjectType) maybeThisType;\n-          } else {\n+          thisType =\n+              ObjectType.cast(\n+                  createFromTypeNodes(thisNode, sourceName, scope)\n+                  .restrictByNotNullOrUndefined());\n+          if (thisType == null) {\n             reporter.warning(\n                 ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"),\n                 sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   public boolean equals(Object that) {\n     if (this == that) {\n       return true;\n-    } else if (that instanceof ObjectType) {\n-      ObjectType objType = (ObjectType) that;\n-      return objType.isNominalType() &&\n-          reference.equals(objType.getReferenceName());\n+    } else if (that instanceof JSType) {\n+      ObjectType objType = ObjectType.cast((JSType) that);\n+      if (objType != null) {\n+        return objType.isNominalType() &&\n+            reference.equals(objType.getReferenceName());\n+      }\n     }\n     return false;\n   }\n    */\n   private void resolveViaRegistry(\n       ErrorReporter t, StaticScope<JSType> enclosing) {\n-    JSType type = registry.getType(reference);\n-    if (type != null && type instanceof ObjectType) {\n-      setReferencedType((ObjectType) type, t, enclosing);\n+    ObjectType type = ObjectType.cast(registry.getType(reference));\n+    if (type != null) {\n+      setReferencedType(type, t, enclosing);\n     }\n   }\n \n \n     // resolving component by component\n     for (int i = 1; i < componentNames.length; i++) {\n-      if (!(value instanceof ObjectType)) {\n+      ObjectType parentClass = ObjectType.cast(value);\n+      if (parentClass == null) {\n         handleUnresolvedType(t);\n         return;\n       }\n-      ObjectType parentClass = (ObjectType)value;\n       if (componentNames[i].length() == 0) {\n         handleUnresolvedType(t);\n         return;\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   public boolean isNativeObjectType() {\n     return false;\n   }\n+\n+  /**\n+   * A null-safe version of JSType#toObjectType.\n+   */\n+  public static ObjectType cast(JSType type) {\n+    return type == null ? null : type.toObjectType();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     JSType propertyType = getPropertyType(propertyName);\n     ObjectType nativeType =\n         this.isFunctionType() ?\n-        ((ObjectType) getNativeType(JSTypeNative.FUNCTION_PROTOTYPE)) :\n-        ((ObjectType) getNativeType(JSTypeNative.OBJECT_PROTOTYPE));\n+        registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) :\n+        registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);\n     JSType nativePropertyType = nativeType.getPropertyType(propertyName);\n     return propertyType != nativePropertyType;\n   }\n       return RecordType.isSubtype(this, (RecordType) that);\n     }\n     // prototype based objects\n-    if (that instanceof ObjectType) {\n+    ObjectType thatObj = ObjectType.cast(that);\n+    if (that != null) {\n       if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n         // If unsure, say 'yes', to avoid spurious warnings.\n         // TODO(user): resolve the prototype chain completely in all cases,\n         // to avoid guessing.\n         return true;\n       }\n-      return this.isImplicitPrototype((ObjectType) that);\n+      return this.isImplicitPrototype(thatObj);\n     }\n     return false;\n   }\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   // The spacing in this file is not exactly standard but it greatly helps\n   // picking out which variable names are merged.\n \n-  private boolean usePseudoName = false;\n-  \n-  @Override\n-  protected int getNumRepetitions() {\n-   return 1;\n-  }  \n-  \n-  @Override\n-  public void setUp() {\n-    usePseudoName = false;\n-  }\n-  \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js,\n-            new CoalesceVariableNames(compiler, usePseudoName));\n+            new CoalesceVariableNames(compiler));\n       }\n     };\n   }\n         \"   this.load();\");\n   }\n \n-  public void testUsePseduoNames() {\n-    usePseudoName = true;\n-    inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y)\",\n-               \"var x_y = 0; print(x_y);     x_y = 1; print(x_y)\");\n-    \n-    inFunction(\"var x_y = 1; var x   = 0; print(x  ); var     y = 1;\" + \n-               \"print(  y); print(x_y);\",\n-\n-               \"var x_y = 1; var x_y$ = 0; print(x_y$);     x_y$ = 1;\" + \"\" +\n-               \"print(x_y$); print(x_y);\");\n-    \n-    inFunction(\"var x_y = 1; function f() {\" +\n-               \"var x    = 0; print(x  ); var y = 1; print( y);\" +\n-               \"print(x_y);}\",\n-\n-               \"var x_y = 1; function f() {\" +\n-               \"var x_y$ = 0; print(x_y$); x_y$ = 1; print(x_y$);\" +\n-               \"print(x_y);}\");\n-  }\n-  \n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/IgnoreCajaPropertiesTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+\n+/**\n+ * {@link IgnoreCajaProperties} tests.\n+ *\n+*\n+ */\n+public class IgnoreCajaPropertiesTest extends CompilerTestCase {\n+\n+  private static final String EXTERNS = \n+      \"var z = {}, \" +\n+      \"f = function(y) { z[y] = z[y] ? (z[y]+1) : 1; }, \" +\n+      \"x, i;\";\n+\n+  public IgnoreCajaPropertiesTest() {\n+    super(EXTERNS);\n+  }\n+\n+  @Override\n+  public int getNumRepetitions() {\n+    return 1;\n+  }\n+  \n+  public void testSimpleKey() {\n+    // Test a one-statement body.\n+    test(\"for (i in x) f(i);\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x)\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    i = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(i); }\" +\n+         \"  }\");\n+    // Test a two-statement body.\n+    test(\"for (i in x) { f(i); f(i); }\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x)\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    i = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(i); f(i); }\" +\n+         \"  }\");\n+    // Check that the counter's incrementing properly and \n+    //   that nested loops work.\n+    test(\"for (i in x) for (j in y) f(i,j);\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_1 in x)\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_1.match(/___$/)) {\" +\n+         \"    i = JSCompiler_IgnoreCajaProperties_1;\" +\n+         \"    {\" +\n+         \"      for (var JSCompiler_IgnoreCajaProperties_0 in y)\" +\n+         \"        if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"          j = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"          { f(i,j); }\" +\n+         \"        }\" +\n+         \"    }\" +\n+         \"  }\");\n+  }\n+\n+  public void testPropertyKey() {\n+    test(\"for (z.i in x) { f(z.i); f(z.i); }\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x) {\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    z.i = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(z.i); f(z.i); }\" +\n+         \"  }\" +\n+         \"}\");\n+  }\n+\n+  public void testFunctionPropertyKey() {\n+    // Note that both in the original code and the\n+    // rewritten code, z.j() is invoked on every\n+    // iteration of the loop.\n+    test(\"for (z.j().i in x) { f(z.j().i); f(z.j().i); }\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x) {\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    z.j().i = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(z.j().i); f(z.j().i); }\" +\n+         \"  }\" +\n+         \"}\");\n+  }\n+  \n+  public void testVarKey() {\n+    // Test a one-statement body.\n+    test(\"for (var j in x) { f(j); }\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x) {\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    var j;\" +\n+         \"    j = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(j); }\" +\n+         \"  }\" +\n+         \"}\");\n+    // Test a two-statement body.\n+    test(\"for (var j in x) { f(j); f(j); }\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_0 in x) {\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"    var j;\" +\n+         \"    j = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"    { f(j); f(j); }\" +\n+         \"  }\" +\n+         \"}\");\n+    // Test two loops.\n+    test(\"for (var i in x) for (var j in y) f(i,j);\",\n+         \"for (var JSCompiler_IgnoreCajaProperties_1 in x)\" +\n+         \"  if (!JSCompiler_IgnoreCajaProperties_1.match(/___$/)) {\" +\n+         \"    var i;\" +\n+         \"    i = JSCompiler_IgnoreCajaProperties_1;\" +\n+         \"    {\" +\n+         \"      for (var JSCompiler_IgnoreCajaProperties_0 in y)\" +\n+         \"        if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {\" +\n+         \"          var j;\" +\n+         \"          j = JSCompiler_IgnoreCajaProperties_0;\" +\n+         \"          { f(i,j); }\" +\n+         \"        }\" +\n+         \"    }\" +\n+         \"  }\");\n+  }\n+  \n+  public void testFourChildFor() {\n+    test(\"for (i = 0; i < 10; ++i) { f(i); }\",\n+         \"for (i = 0; i < 10; ++i) { f(i); }\");\n+  }\n+  \n+  /** {@inheritDoc} */\n+  @Override\n+  public CompilerPass getProcessor(Compiler compiler) {\n+    return new IgnoreCajaProperties(compiler);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new InlineVariables(\n-        compiler, \n-        (inlineLocalsOnly) \n+        compiler,\n+        (inlineLocalsOnly)\n             ? InlineVariables.Mode.LOCALS_ONLY\n             : InlineVariables.Mode.ALL,\n         inlineAllStrings);\n     testSame(\"f(); var x = false; function f() { alert(x); };\");\n   }\n \n+  public void testInlineIntoNestedNonHoistedNamedFunctions() {\n+    test(\"f(); var x = false; if (false) function f() { alert(x); };\",\n+         \"f(); if (false) function f() { alert(false); };\");\n+  }\n+\n   public void testNoInlineIntoNestedNamedFunctions() {\n-    testSame(\"f(); var x = false; if (false) function f() { alert(x); };\");\n     testSame(\"f(); var x = false; function f() { if (false) { alert(x); } };\");\n   }\n \n   }\n \n   public void testInlineFunctionDeclaration() {\n-    test(\"var f = function () {}; var a = f;\", \n+    test(\"var f = function () {}; var a = f;\",\n          \"var a = function () {};\");\n-    test(\"var f = function () {}; foo(); var a = f;\", \n+    test(\"var f = function () {}; foo(); var a = f;\",\n          \"foo(); var a = function () {};\");\n-    test(\"var f = function () {}; foo(f);\", \n+    test(\"var f = function () {}; foo(f);\",\n          \"foo(function () {});\");\n-    \n-    testSame(\"var f = function () {}; function g() {var a = f;}\"); \n-    testSame(\"var f = function () {}; function g() {h(f);}\"); \n-  }\n-  \n+\n+    testSame(\"var f = function () {}; function g() {var a = f;}\");\n+    testSame(\"var f = function () {}; function g() {h(f);}\");\n+  }\n+\n   public void testRecursiveFunction1() {\n     testSame(\"var x = 0; (function x() { return x ? x() : 3; })();\");\n   }\n         \"var x=1; x; function f() {var x = 1; x;}\",\n         \"var x=1; x; function f() {1;}\");\n   }\n-  \n+\n   public void testLocalsOnly2() {\n     inlineLocalsOnly = true;\n     test(\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n   }\n \n   public void testCorrectRedeclare() {\n-    assertNoWarning(\"function f() { if (1) { var a = 2; } else { var a = 3; } }\");\n+    assertNoWarning(\n+        \"function f() { if (1) { var a = 2; } else { var a = 3; } }\");\n   }\n \n   public void testCorrectRecursion() {\n     assertUndeclared(\"if (true) { f(); function f() {} }\");\n   }\n \n+  public void testNonHoistedFunction2() {\n+    assertNoWarning(\"if (false) { function f() {} f(); }\");\n+  }\n+\n+  public void testNonHoistedFunction3() {\n+    assertNoWarning(\"function g() { if (false) { function f() {} f(); }}\");\n+  }\n+\n+  public void testNonHoistedFunction4() {\n+    assertAmbiguous(\"if (false) { function f() {} }  f();\");\n+  }\n+\n+  public void testNonHoistedFunction5() {\n+    assertAmbiguous(\"function g() { if (false) { function f() {} }  f(); }\");\n+  }\n+\n+  public void testNonHoistedFunction6() {\n+    assertUndeclared(\"if (false) { f(); function f() {} }\");\n+  }\n+\n+  public void testNonHoistedFunction7() {\n+    assertUndeclared(\"function g() { if (false) { f(); function f() {} }}\");\n+  }\n+  \n+  \n+  public void testNonHoistedRecursiveFunction1() {\n+    assertNoWarning(\"if (false) { function f() { f(); }}\");\n+  }\n+\n+  public void testNonHoistedRecursiveFunction2() {\n+    assertNoWarning(\"function g() { if (false) { function f() { f(); }}}\");\n+  }\n+\n+  public void testNonHoistedRecursiveFunction3() {\n+    assertNoWarning(\"function g() { if (false) { function f() { f(); g(); }}}\");\n+  }\n+\n   /**\n    * Expects the JS to generate one bad-read error.\n    */\n   }\n \n   /**\n+   * Expects the JS to generate one bad-write warning.\n+   */\n+  private void assertAmbiguous(String js) {\n+    testSame(js, VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL);\n+  }\n+\n+\n+  /**\n    * Expects the JS to generate no errors or warnings.\n    */\n   private void assertNoWarning(String js) {", "timestamp": 1260913970, "metainfo": ""}