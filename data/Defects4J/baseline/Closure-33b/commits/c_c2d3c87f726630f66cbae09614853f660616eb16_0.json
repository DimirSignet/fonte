{"sha": "c2d3c87f726630f66cbae09614853f660616eb16", "log": "Change on 2010/05/18 by nick          handle circular dependencies properly.          R=alan         DELTA=216  (182 added, 0 deleted, 34 changed)  Change on 2010/05/18 by nick          open-source i18n plugin for translating goog.getMsg.         Slaps an apache license on everything and removes dependencies         on non-open-source code.          R=robert         DELTA=96  (78 added, 7 deleted, 11 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=7001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n+import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n           }\n         }\n \n-        inputs =\n-            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-            .manageDependencies(inputs);\n+        try {\n+          inputs =\n+              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n+              .manageDependencies(inputs);\n+        } catch (CircularDependencyException e) {\n+          report(JSError.make(\n+              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+          return null;\n+        }\n       }\n \n       // Check if externs files need to be lifted.\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.deps.DependencyInfo;\n import com.google.javascript.jscomp.deps.SortedDependencies;\n+import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n  */\n public class JSModule implements DependencyInfo, Serializable {\n   private static final long serialVersionUID = 1;\n+\n+  static final DiagnosticType CIRCULAR_DEPENDENCY_ERROR =\n+      DiagnosticType.error(\"JSC_CIRCULAR_DEP\",\n+          \"Circular dependency detected: {0}\");\n \n   /** Module name */\n   private final String name;\n     }\n \n     // Sort the JSModule in this order.\n-    List<CompilerInput> sortedList =\n-        (new SortedDependencies<CompilerInput>(\n-            Collections.<CompilerInput>unmodifiableList(inputs)))\n-        .getSortedList();\n-    inputs.clear();\n-    inputs.addAll(sortedList);\n+    try {\n+      List<CompilerInput> sortedList =\n+          (new SortedDependencies<CompilerInput>(\n+              Collections.<CompilerInput>unmodifiableList(inputs)))\n+          .getSortedList();\n+      inputs.clear();\n+      inputs.addAll(sortedList);\n+    } catch (CircularDependencyException e) {\n+      compiler.report(\n+          JSError.make(CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+    }\n   }\n \n   /**\n    * satisfy the ordering dependencies.  This can be important for cases where\n    * the modules do not properly specify all dependencies.\n    */\n-  public static JSModule[] sortJsModules(Collection<JSModule> modules) {\n+  public static JSModule[] sortJsModules(Collection<JSModule> modules)\n+      throws CircularDependencyException {\n     // Sort the JSModule in this order.\n     List<JSModule> sortedList = (new SortedDependencies<JSModule>(\n             Lists.newArrayList(modules))).getSortedList();\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.deps.SortedDependencies;\n+import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n \n import java.util.ArrayList;\n import java.util.Collection;\n    *     is stable.\n    * @return The sorted list of sources.\n    */\n-  List<CompilerInput> manageDependencies(List<CompilerInput> inputs) {\n+  List<CompilerInput> manageDependencies(List<CompilerInput> inputs)\n+      throws CircularDependencyException {\n     SortedDependencies<CompilerInput> sorter =\n         new SortedDependencies<CompilerInput>(inputs);\n     List<CompilerInput> inputsWithoutProvides =\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JsMessage.java\n+/*\n+ * Copyright 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.base.Hash;\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A representation of a translatable message in JavaScript source code.\n+ *\n+ * <p>Instances are created using a {@link JsMessage.Builder},\n+ * like this:\n+ * <pre>\n+ * JsMessage m = new JsMessage.Builder(key)\n+ *     .appendPart(\"Hi \")\n+ *     .appendPlaceholderReference(\"firstName\")\n+ *     .appendPart(\"!\")\n+ *     .setDesc(\"A welcome message\")\n+ *     .build();\n+ * </pre>\n+ *\n+*\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+public class JsMessage {\n+\n+  /**\n+   * Message style that could be used for JS code parsing.\n+   * The enum order is from most relaxed to most restricted.\n+   */\n+  public enum Style {\n+    LEGACY, // All legacy code is completely OK\n+    RELAX,  // You allowed to use legacy code but it would be reported as warn\n+    CLOSURE; // Any legacy code is prohibited\n+\n+    /**\n+     * Calculates current messages {@link Style} based on the given arguments.\n+     *\n+     * @param useClosure if true then use closure style, otherwise not\n+     * @param allowLegacyMessages if true then allow legacy messages otherwise\n+     *        not\n+     * @return the message style based on the given arguments\n+     */\n+    static Style getFromParams(boolean useClosure,\n+        boolean allowLegacyMessages) {\n+      if (useClosure) {\n+        return allowLegacyMessages ? RELAX : CLOSURE;\n+      } else {\n+        return LEGACY;\n+      }\n+    }\n+  }\n+\n+  private static final String MESSAGE_REPRESENTATION_FORMAT = \"{$%s}\";\n+\n+  private final String key;\n+  private final String id;\n+  private final List<CharSequence> parts;\n+  private final Set<String> placeholders;\n+  private final String desc;\n+  private final boolean hidden;\n+\n+  private final String sourceName;\n+  private final boolean isAnonymous;\n+  private final boolean isExternal;\n+\n+  /**\n+   * Creates an instance. Client code should use a {@link JsMessage.Builder}.\n+   *\n+   * @param key a key that should identify this message in sources; typically\n+   *     it is the message's name (e.g. {@code \"MSG_HELLO\"}).\n+   * @param id an id that *uniquely* identifies the message in the bundle.\n+   *     It could be either the message name or id generated from the message\n+   *     content.\n+   */\n+  private JsMessage(String sourceName, String key,\n+      boolean isAnonymous, boolean isExternal,\n+      String id, List<CharSequence> parts, Set<String> placeholders,\n+      String desc, boolean hidden) {\n+\n+    Preconditions.checkState(key != null);\n+    Preconditions.checkState(id != null);\n+\n+    this.key = key;\n+    this.id = id;\n+    this.parts = Collections.unmodifiableList(parts);\n+    this.placeholders = Collections.unmodifiableSet(placeholders);\n+    this.desc = desc;\n+    this.hidden = hidden;\n+\n+    this.sourceName = sourceName;\n+    this.isAnonymous = isAnonymous;\n+    this.isExternal = isExternal;\n+  }\n+\n+  /**\n+   * Gets the message's sourceName.\n+   */\n+  public String getSourceName() {\n+    return sourceName;\n+  }\n+\n+  /**\n+   * Gets the message's key, or name (e.g. {@code \"MSG_HELLO\"}).\n+   */\n+  public String getKey() {\n+    return key;\n+  }\n+\n+  public boolean isAnonymous() {\n+    return isAnonymous;\n+  }\n+\n+  public boolean isExternal() {\n+    return isExternal;\n+  }\n+\n+  /**\n+   * Gets the message's id, or name (e.g. {@code \"92430284230902938293\"}).\n+   */\n+  public String getId() {\n+    return id;\n+  }\n+\n+  /**\n+   * Gets the description associated with this message, intended to help\n+   * translators, or null if this message has no description.\n+   */\n+  public String getDesc() {\n+    return desc;\n+  }\n+\n+  /**\n+   * Gets whether this message should be hidden from volunteer translators (to\n+   * reduce the chances of a new feature leak).\n+   */\n+  public boolean isHidden() {\n+    return hidden;\n+  }\n+\n+  /**\n+   * Gets a read-only list of the parts of this message. Each part is either a\n+   * {@link String} or a {@link PlaceholderReference}.\n+   */\n+  public List<CharSequence> parts() {\n+    return parts;\n+  }\n+\n+  /** Gets a read-only set of the registered placeholders in this message. */\n+  public Set<String> placeholders() {\n+    return placeholders;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    for (CharSequence p : parts) {\n+      sb.append(p.toString());\n+    }\n+    return sb.toString();\n+  }\n+\n+  /** @return false iff the message is represented by empty string. */\n+  public boolean isEmpty() {\n+    for (CharSequence part : parts) {\n+      if (part.length() > 0) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof JsMessage)) return false;\n+\n+    JsMessage m = (JsMessage) o;\n+    return id.equals(m.id) &&\n+           key.equals(m.key) &&\n+           isAnonymous == m.isAnonymous &&\n+           parts.equals(m.parts) &&\n+           placeholders.equals(m.placeholders) &&\n+           (desc == null ? m.desc == null : desc.equals(m.desc)) &&\n+           (sourceName == null\n+               ? m.sourceName == null\n+               : sourceName.equals(m.sourceName)) &&\n+           hidden == m.hidden;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int hash = key.hashCode();\n+    hash = 31 * hash + (isAnonymous ? 1 : 0);\n+    hash = 31 * hash + id.hashCode();\n+    hash = 31 * hash + parts.hashCode();\n+    hash = 31 * hash + (desc != null ? desc.hashCode() : 0);\n+    hash = 31 * hash + (hidden ? 1 : 0);\n+    hash = 31 * hash + (sourceName != null ? sourceName.hashCode() : 0);\n+    return hash;\n+  }\n+\n+  /** A reference to a placeholder in a translatable message. */\n+  public static class PlaceholderReference implements CharSequence {\n+\n+    private final String name;\n+\n+    PlaceholderReference(String name) {\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public int length() {\n+      return name.length();\n+    }\n+\n+    @Override\n+    public char charAt(int index) {\n+      return name.charAt(index);\n+    }\n+\n+    @Override\n+    public CharSequence subSequence(int start, int end) {\n+      return name.subSequence(start, end);\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return String.format(MESSAGE_REPRESENTATION_FORMAT, name);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o == this ||\n+             o instanceof PlaceholderReference &&\n+             name.equals(((PlaceholderReference) o).name);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 31 * name.hashCode();\n+    }\n+  }\n+\n+  /**\n+   * Contains functionality for creating js messages. Generates authoritative\n+   * keys and fingerprints for a message that must stay constant over time.\n+   *\n+   * This implementation correctly processes unnamed messages and creates a key\n+   * for them that looks like MSG_<fingerprint value>.\n+   */\n+  public static class Builder {\n+\n+    private static final Pattern MSG_EXTERNAL_PATTERN =\n+        Pattern.compile(\"MSG_EXTERNAL_(\\\\d+)\");\n+\n+    /**\n+     * @return an external message id or null if this is not an\n+     * external message identifier\n+     */\n+    private static String getExternalMessageId(String identifier) {\n+      Matcher m = MSG_EXTERNAL_PATTERN.matcher(identifier);\n+      return m.matches() ? m.group(1) : null;\n+    }\n+\n+    private String key;\n+    private String desc;\n+    private boolean hidden;\n+\n+    private List<CharSequence> parts = Lists.newLinkedList();\n+    private Set<String> placeholders = Sets.newHashSet();\n+\n+    private String sourceName;\n+\n+    public Builder() {\n+      this(null);\n+    }\n+\n+    /** Creates an instance. */\n+    public Builder(String key) {\n+      this.key = key;\n+    }\n+\n+    /** Gets the message's key (e.g. {@code \"MSG_HELLO\"}). */\n+    public String getKey() {\n+      return key;\n+    }\n+\n+    /**\n+     * @param key a key that should uniquely identify this message; typically\n+     *     it is the message's name (e.g. {@code \"MSG_HELLO\"}).\n+     */\n+    public Builder setKey(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * @param sourceName The message's sourceName.\n+     */\n+    public Builder setSourceName(String sourceName) {\n+      this.sourceName = sourceName;\n+      return this;\n+    }\n+\n+    /**\n+     * Appends a placeholder reference to the message\n+     */\n+    public Builder appendPlaceholderReference(String name) {\n+      Preconditions.checkNotNull(name, \"Placeholder name could not be null\");\n+      parts.add(new PlaceholderReference(name));\n+      placeholders.add(name);\n+      return this;\n+    }\n+\n+    /** Appends a translatable string literal to the message. */\n+    public Builder appendStringPart(String part) {\n+      Preconditions.checkNotNull(part,\n+          \"String part of the message could not be null\");\n+      parts.add(part);\n+      return this;\n+    }\n+\n+    /** Returns the message registred placeholders */\n+    public Set<String> getPlaceholders() {\n+      return placeholders;\n+    }\n+\n+    /** Sets the description of the message, which helps translators. */\n+    public Builder setDesc(String desc) {\n+      this.desc = desc;\n+      return this;\n+    }\n+\n+    /** Sets whether the message should be hidden from volunteer translators. */\n+    public Builder setIsHidden(boolean hidden) {\n+      this.hidden = hidden;\n+      return this;\n+    }\n+\n+    /** Gets whether at least one part has been appended. */\n+    public boolean hasParts() {\n+      return !parts.isEmpty();\n+    }\n+\n+    public List<CharSequence> getParts() {\n+      return parts;\n+    }\n+\n+    public JsMessage build() {\n+      return build(null);\n+    }\n+\n+    public JsMessage build(IdGenerator idGenerator) {\n+      boolean isAnonymous = false;\n+      boolean isExternal = false;\n+      String id = null;\n+\n+      if (getKey() == null) {\n+        // Before constructing a message we need to change unnamed messages name\n+        // to the unique one.\n+        key = JsMessageVisitor.MSG_PREFIX + fingerprint(getParts());\n+        isAnonymous = true;\n+      }\n+\n+      if (!isAnonymous) {\n+        String externalId = getExternalMessageId(key);\n+        if (externalId != null) {\n+          isExternal = true;\n+          id = externalId;\n+        }\n+      }\n+\n+      if (!isExternal) {\n+        id = idGenerator == null ? key : idGenerator.generateId(key, parts);\n+      }\n+\n+      return new JsMessage(sourceName, key, isAnonymous, isExternal, id, parts,\n+          placeholders, desc, hidden);\n+    }\n+\n+    /**\n+     * Generates a compact uppercase alphanumeric text representation of a\n+     * 63-bit fingerprint of the content parts of a message.\n+     */\n+    private static String fingerprint(List<CharSequence> messageParts) {\n+      StringBuilder sb = new StringBuilder();\n+      for (CharSequence part : messageParts) {\n+        if (part instanceof JsMessage.PlaceholderReference) {\n+          sb.append(part.toString());\n+        } else {\n+          sb.append(part);\n+        }\n+      }\n+      long nonnegativeHash = Long.MAX_VALUE & Hash.hash64(sb.toString());\n+      return Long.toString(nonnegativeHash, 36).toUpperCase();\n+    }\n+  }\n+  public interface IdGenerator {\n+\n+    String generateId(String key, List<CharSequence> messageParts);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JsMessageDefinition.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Container class that holds information about jsmessage source.\n+ *\n+ * This class is specific to our JsMessage syntax. Allows you to use the\n+ * new-style or the old-style messages.\n+ *\n+ * Old-style:\n+ * <code>\n+ * var MSG_LEOPARD = 'Leopard';\n+ * var MSG_LEOPARD_HELP = 'The Leopard operating system';\n+ * </code>\n+ *\n+ * New-style:\n+ * <code>\n+ * /** @desc The leopard operating system * /\n+ * var MSG_LEOPARD = goog.getMsg('Leopard');\n+ * </code>\n+ *\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+class JsMessageDefinition {\n+\n+  private final Node messageNode;\n+  private final Node messageParentNode;\n+  private final Node visitingNode;\n+\n+  /**\n+   * Constructs js message definition.\n+   *\n+   * @param visitingNode Node that is visited by\n+   *     {@link JsMessageVisitor}. Take into\n+   *     account that visiting node could differ from the node the message\n+   *     was found.\n+   * @param messageNode A node that contains the message. It could be node with\n+   *     goog.getMsg() call or string/function for old-style messages.\n+   * @param messageParentNode The parent of the message node.\n+   */\n+  JsMessageDefinition(Node visitingNode, Node messageNode,\n+      Node messageParentNode) {\n+\n+    this.messageNode = messageNode;\n+    this.visitingNode = visitingNode;\n+    this.messageParentNode = messageParentNode;\n+  }\n+\n+  Node getMessageNode() {\n+    return messageNode;\n+  }\n+\n+  Node getVisitingNode() {\n+    return visitingNode;\n+  }\n+\n+ Node getMessageParentNode() {\n+    return messageParentNode;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.CaseFormat;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.JsMessage.Builder;\n+import static com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.*;\n+import java.util.regex.*;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Traverses across parsed tree and finds I18N messages. Then it passes it to\n+ * {@link JsMessageVisitor#processJsMessage(JsMessage, JsMessageDefinition)}.\n+ *\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+abstract class JsMessageVisitor extends AbstractPostOrderCallback\n+    implements CompilerPass {\n+\n+  private static final String MSG_FUNCTION_NAME = \"goog.getMsg\";\n+\n+  static final DiagnosticType MESSAGE_HAS_NO_DESCRIPTION =\n+      DiagnosticType.warning(\"JSC_MSG_HAS_NO_DESCRIPTION\",\n+          \"Message {0} has no description. Add @desc JsDoc tag.\");\n+\n+  static final DiagnosticType MESSAGE_HAS_NO_TEXT =\n+      DiagnosticType.warning(\"JSC_MSG_HAS_NO_TEXT\",\n+          \"Message value of {0} is just an empty string. \"\n+              + \"Empty messages are forbidden.\" );\n+\n+  static final DiagnosticType MESSAGE_TREE_MALFORMED =\n+      DiagnosticType.error(\"JSC_MSG_TREE_MALFORMED\",\n+          \"Message parse tree malformed. {0}\");\n+\n+  static final DiagnosticType MESSAGE_HAS_NO_VALUE =\n+      DiagnosticType.error(\"JSC_MSG_HAS_NO_VALUE\",\n+          \"message node {0} has no value\");\n+\n+  static final DiagnosticType MESSAGE_DUPLICATE_KEY =\n+      DiagnosticType.error(\"JSC_MSG_KEY_DUPLICATED\",\n+          \"duplicate message variable name found for {0}, \" +\n+              \"initial definition {1}:{2}\");\n+\n+  static final DiagnosticType MESSAGE_NODE_IS_ORPHANED =\n+      DiagnosticType.warning(\"JSC_MSG_ORPHANED_NODE\", MSG_FUNCTION_NAME +\n+          \"() function could be used only with MSG_* property or variable\");\n+\n+  static final DiagnosticType MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX =\n+      DiagnosticType.error(\"JSC_MSG_NOT_INITIALIZED_USING_NEW_SYNTAX\",\n+          \"message not initialized using \" + MSG_FUNCTION_NAME);\n+\n+  private static final String PH_JS_PREFIX = \"{$\";\n+  private static final String PH_JS_SUFFIX = \"}\";\n+\n+  static final String MSG_PREFIX = \"MSG_\";\n+\n+\n+  private static final Pattern MSG_UNNAMED_PATTERN =\n+      Pattern.compile(\"MSG_UNNAMED_\\\\d+\");\n+\n+  private static final Pattern CAMELCASE_PATTERN =\n+      Pattern.compile(\"[a-z][a-zA-Z\\\\d]*[_\\\\d]*\");\n+\n+  static final String HIDDEN_DESC_PREFIX = \"@hidden\";\n+\n+  // For old-style js messages\n+  private static final String DESC_SUFFIX = \"_HELP\";\n+\n+  private final boolean needToCheckDuplications;\n+  private final JsMessage.Style style;\n+  private final JsMessage.IdGenerator idGenerator;\n+  final AbstractCompiler compiler;\n+\n+  /**\n+   * The names encountered associated with their defining node and source. We\n+   * use it for tracking duplicated message ids in the source code.\n+   */\n+  private final Map<String, MessageLocation> messageNames =\n+      Maps.newHashMap();\n+\n+  /**\n+   * List of found goog.getMsg call nodes.\n+   *\n+   * When we visit goog.getMsg() node we add a pair node:sourcename and later\n+   * when we visit its parent we remove this pair. All nodes that are left at\n+   * the end of traversing are orphaned nodes. It means have no corresponding\n+   * var or property node.\n+   */\n+  private final Map<Node, String> googMsgNodes = Maps.newHashMap();\n+\n+  private final CheckLevel checkLevel;\n+\n+  /**\n+   * Creates js message visitor.\n+   *\n+   * @param compiler the compiler instance\n+   * @param needToCheckDuplications whether to check duplicated messages in\n+   *        traversed\n+   * @param style style that should be used during parsing\n+   * @param idGenerator generator that used for creating unique ID for the\n+   *        message\n+   */\n+  JsMessageVisitor(AbstractCompiler compiler,\n+      boolean needToCheckDuplications,\n+      JsMessage.Style style, JsMessage.IdGenerator idGenerator) {\n+\n+    this.compiler = compiler;\n+    this.needToCheckDuplications = needToCheckDuplications;\n+    this.style = style;\n+    this.idGenerator = idGenerator;\n+\n+    checkLevel = (style == JsMessage.Style.CLOSURE)\n+        ? CheckLevel.ERROR : CheckLevel.WARNING;\n+\n+    // TODO(anatol): add flag that decides whether to process UNNAMED messages.\n+    // Some projects would not want such functionality (unnamed) as they dont\n+\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+\n+    for (Map.Entry<Node, String> msgNode : googMsgNodes.entrySet()) {\n+      compiler.report(JSError.make(msgNode.getValue(), msgNode.getKey(),\n+          checkLevel, MESSAGE_NODE_IS_ORPHANED));\n+    }\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal traversal, Node node, Node parent) {\n+    String messageKey;\n+    boolean isVar;\n+    Node msgNode, msgNodeParent;\n+\n+    switch (node.getType()) {\n+      case Token.NAME:\n+        // var MSG_HELLO = 'Message'\n+        if ((parent != null) && (parent.getType() == Token.VAR)) {\n+          messageKey = node.getString();\n+          isVar = true;\n+        } else {\n+          return;\n+        }\n+\n+        msgNode = node.getFirstChild();\n+        msgNodeParent = node;\n+        break;\n+      case Token.ASSIGN:\n+        // somenamespace.someclass.MSG_HELLO = 'Message'\n+        isVar = false;\n+\n+        Node getProp = node.getFirstChild();\n+        if (getProp.getType() != Token.GETPROP) {\n+          return;\n+        }\n+\n+        Node propNode = getProp.getLastChild();\n+\n+        messageKey = propNode.getString();\n+        msgNode = node.getLastChild();\n+        msgNodeParent = node;\n+        break;\n+      case Token.CALL:\n+        // goog.getMsg()\n+        if (MSG_FUNCTION_NAME.equals(node.getFirstChild().getQualifiedName())) {\n+          googMsgNodes.put(node, traversal.getSourceName());\n+        }\n+        return;\n+      default:\n+        return;\n+    }\n+\n+    // Is this a message name?\n+    boolean isNewStyleMessage =\n+        msgNode != null && msgNode.getType() == Token.CALL;\n+    if (!isMessageName(messageKey, isNewStyleMessage)) {\n+      return;\n+    }\n+\n+    if (msgNode == null) {\n+      compiler.report(\n+          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n+      return;\n+    }\n+\n+    // Just report a warning if a qualified messageKey that looks like a message\n+    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n+    if (isNewStyleMessage) {\n+      googMsgNodes.remove(msgNode);\n+    } else if (style != JsMessage.Style.LEGACY) {\n+      compiler.report(traversal.makeError(node, checkLevel,\n+          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n+    }\n+\n+    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n+\n+    if (!isUnnamedMsg && needToCheckDuplications) {\n+      checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode);\n+    }\n+\n+    Builder builder = new Builder(\n+        isUnnamedMsg ? null : messageKey);\n+    builder.setSourceName(traversal.getSourceName());\n+\n+    try {\n+      if (isVar) {\n+        extractMessageFromVariable(builder, node, parent, parent.getParent());\n+      } else {\n+        extractMessageFromProperty(builder, node.getFirstChild(), node);\n+      }\n+    } catch (MalformedException ex) {\n+      compiler.report(traversal.makeError(ex.getNode(),\n+          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n+      return;\n+    }\n+\n+    JsMessage extractedMessage = builder.build(idGenerator);\n+\n+    if (extractedMessage.isEmpty()) {\n+      // value of the message is an empty string. Translators do not like it.\n+      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n+          messageKey));\n+    }\n+\n+    // New-style messages must have descriptions. We don't emit a warning\n+    // for legacy-style messages, because there are thousands of\n+    // them in legacy code that are not worth the effort to fix, since they've\n+    // already been translated anyway.\n+    String desc = extractedMessage.getDesc();\n+    if (isNewStyleMessage\n+        && (desc == null || desc.trim().isEmpty())\n+        && !extractedMessage.isExternal()) {\n+      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n+          messageKey));\n+    }\n+\n+    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n+        node, msgNode, msgNodeParent);\n+    processJsMessage(extractedMessage, msgDefinition);\n+  }\n+\n+  /**\n+   * Checks if message already processed. If so - it generates 'message\n+   * duplicated' compiler error.\n+   *\n+   * @param sourceName the source file name\n+   * @param msgName the name of the message\n+   * @param msgNode the node that represents js message\n+   */\n+  private void checkIfMessageDuplicated(String sourceName, String msgName,\n+      Node msgNode) {\n+    if (messageNames.containsKey(msgName)) {\n+      MessageLocation location = messageNames.get(msgName);\n+      compiler.report(JSError.make(sourceName, msgNode, MESSAGE_DUPLICATE_KEY,\n+          msgName, location.sourceName, Integer.toString(location.lineNo)));\n+    } else {\n+      MessageLocation location =\n+          new MessageLocation(sourceName, msgNode.getLineno());\n+      messageNames.put(msgName, location);\n+    }\n+  }\n+\n+  /**\n+   * Creates a {@link JsMessage} for a js message defined using a js variable\n+   * declaration (e.g <code>var MSG_X = ...;</code>).\n+   *\n+   * @param builder the message builder\n+   * @param nameNode a NAME node for a js message variable\n+   * @param parentNode a VAR node, parent of {@code nameNode}\n+   * @param grandParentNode the grandparent of {@code nameNode}. This node is\n+   *        only used to get meta data about the message that might be\n+   *        surrounding it (e.g. a message description). This argument may be\n+   *        null if the meta data is not needed.\n+   * @throws MalformedException if {@code varNode} does not\n+   *         correspond to a valid js message VAR node\n+   */\n+  private void extractMessageFromVariable(\n+      Builder builder, Node nameNode, Node parentNode,\n+      @Nullable Node grandParentNode) throws MalformedException {\n+\n+    // Determine the message's value\n+    Node valueNode = nameNode.getFirstChild();\n+    switch (valueNode.getType()) {\n+      case Token.STRING:\n+      case Token.ADD:\n+        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n+            grandParentNode);\n+        builder.appendStringPart(extractStringFromStringExprNode(valueNode));\n+        break;\n+      case Token.FUNCTION:\n+        maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode,\n+            grandParentNode);\n+        extractFromFunctionNode(builder, valueNode);\n+        break;\n+      case Token.CALL:\n+        maybeInitMetaDataFromJsDoc(builder, parentNode);\n+        extractFromCallNode(builder, valueNode);\n+        break;\n+      default:\n+        throw new MalformedException(\"Cannot parse value of message \"\n+            + builder.getKey(), valueNode);\n+    }\n+  }\n+\n+  /**\n+   * Creates a {@link JsMessage} for a js message defined using an assignment to\n+   * a qualified name (e.g <code>a.b.MSG_X = goog.getMsg(...);</code>).\n+   *\n+   * @param builder the message builder\n+   * @param getPropNode a GETPROP node in a js message assignment\n+   * @param assignNode an ASSIGN node, parent of {@code getPropNode}.\n+   * @throws MalformedException if {@code getPropNode} does not\n+   *         correspond to a valid js message node\n+   */\n+  private void extractMessageFromProperty(\n+      Builder builder, Node getPropNode, Node assignNode)\n+      throws MalformedException {\n+    Node callNode = getPropNode.getNext();\n+    maybeInitMetaDataFromJsDoc(builder, assignNode);\n+    extractFromCallNode(builder, callNode);\n+  }\n+\n+  /**\n+   * Initializes the meta data in a JsMessage by examining the nodes just before\n+   * and after a message VAR node.\n+   *\n+   * @param builder the message builder whose meta data will be initialized\n+   * @param varNode the message VAR node\n+   * @param parentOfVarNode {@code varNode}'s parent node\n+   */\n+  private void maybeInitMetaDataFromJsDocOrHelpVar(\n+      Builder builder, Node varNode, @Nullable Node parentOfVarNode)\n+      throws MalformedException {\n+\n+    // First check description in @desc\n+    if (maybeInitMetaDataFromJsDoc(builder, varNode)) {\n+      return;\n+    }\n+\n+    // Check the preceding node for meta data\n+    if ((parentOfVarNode != null) &&\n+        maybeInitMetaDataFromHelpVar(builder,\n+            parentOfVarNode.getChildBefore(varNode))) {\n+      return;\n+    }\n+\n+    // Check the subsequent node for meta data\n+    maybeInitMetaDataFromHelpVar(builder, varNode.getNext());\n+  }\n+\n+  /**\n+   * Initializes the meta data in a JsMessage by examining a node just before or\n+   * after a message VAR node.\n+   *\n+   * @param builder the message builder whose meta data will be initialized\n+   * @param sibling a node adjacent to the message VAR node\n+   * @return true iff message has corresponding description variable\n+   */\n+  private boolean maybeInitMetaDataFromHelpVar(Builder builder,\n+      @Nullable Node sibling) throws MalformedException {\n+    if ((sibling != null) && (sibling.getType() == Token.VAR)) {\n+      Node nameNode = sibling.getFirstChild();\n+      String name = nameNode.getString();\n+      if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n+        Node valueNode = nameNode.getFirstChild();\n+        String desc = extractStringFromStringExprNode(valueNode);\n+        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n+          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n+          builder.setIsHidden(true);\n+        } else {\n+          builder.setDesc(desc);\n+        }\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Initializes the meta data in a message builder given a node that may\n+   * contain JsDoc properties.\n+   *\n+   * @param builder the message builder whose meta data will be initialized\n+   * @param node the node with the message's JSDoc properties\n+   * @return true if message has JsDoc with valid description in @desc\n+   *         annotation\n+   */\n+  private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node) {\n+    boolean messageHasDesc = false;\n+    JSDocInfo info = node.getJSDocInfo();\n+    if (info != null) {\n+      String desc = info.getDescription();\n+      if (desc != null) {\n+        builder.setDesc(desc);\n+        messageHasDesc = true;\n+      }\n+      if (info.isHidden()) {\n+        builder.setIsHidden(true);\n+      }\n+    }\n+\n+    return messageHasDesc;\n+  }\n+\n+  /**\n+   * Returns the string value associated with a node representing a js string or\n+   * several js strings added together (e.g. {@code 'str'} or {@code 's' + 't' +\n+   * 'r'}).\n+   *\n+   * @param node the node from where we extract the string\n+   * @return String representation of the node\n+   * @throws MalformedException if the parsed message is invalid\n+   */\n+  private static String extractStringFromStringExprNode(Node node)\n+      throws MalformedException {\n+    switch (node.getType()) {\n+      case Token.STRING:\n+        return node.getString();\n+      case Token.ADD:\n+        StringBuilder sb = new StringBuilder();\n+        for (Node child : node.children()) {\n+          sb.append(extractStringFromStringExprNode(child));\n+        }\n+        return sb.toString();\n+      default:\n+        throw new MalformedException(\"STRING or ADD node expected; found: \" +\n+                getReadableTokenName(node), node);\n+    }\n+  }\n+\n+  /**\n+   * Initializes a message builder from a FUNCTION node.\n+   * <p>\n+   * <pre>\n+   * The tree should look something like:\n+   *\n+   * function\n+   *  |-- name\n+   *  |-- lp\n+   *  |   |-- name <arg1>\n+   *  |    -- name <arg2>\n+   *   -- block\n+   *      |\n+   *       --return\n+   *           |\n+   *            --add\n+   *               |-- string foo\n+   *                -- name <arg1>\n+   * </pre>\n+   *\n+   * @param builder the message builder\n+   * @param node the function node that contains a message\n+   * @throws MalformedException if the parsed message is invalid\n+   */\n+  private void extractFromFunctionNode(Builder builder, Node node)\n+      throws MalformedException {\n+    Set<String> phNames = Sets.newHashSet();\n+\n+    for (Node fnChild : node.children()) {\n+      switch (fnChild.getType()) {\n+        case Token.NAME:\n+          // This is okay. The function has a name, but it is empty.\n+          break;\n+        case Token.LP:\n+          // Parse the placeholder names from the function argument list.\n+          for (Node argumentNode : fnChild.children()) {\n+            if (argumentNode.getType() == Token.NAME) {\n+              String phName = argumentNode.getString();\n+              if (phNames.contains(phName)) {\n+                throw new MalformedException(\"Duplicate placeholder name: \"\n+                    + phName, argumentNode);\n+              } else {\n+                phNames.add(phName);\n+              }\n+            }\n+          }\n+          break;\n+        case Token.BLOCK:\n+          // Build the message's value by examining the return statement\n+          Node returnNode = fnChild.getFirstChild();\n+          if (returnNode.getType() != Token.RETURN) {\n+            throw new MalformedException(\"RETURN node expected; found: \"\n+                + getReadableTokenName(returnNode), returnNode);\n+          }\n+          for (Node child : returnNode.children()) {\n+            extractFromReturnDescendant(builder, child);\n+          }\n+\n+          // Check that all placeholders from the message text have appropriate\n+          // object literal keys\n+          for (String phName : builder.getPlaceholders()) {\n+            if(!phNames.contains(phName)) {\n+              throw new MalformedException(\n+                  \"Unrecognized message placeholder referenced: \" + phName,\n+                  returnNode);\n+            }\n+          }\n+          break;\n+        default:\n+          throw new MalformedException(\n+              \"NAME, LP, or BLOCK node expected; found: \"\n+                  + getReadableTokenName(node), fnChild);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Appends value parts to the message builder by traversing the descendants\n+   * of the given RETURN node.\n+   *\n+   * @param builder the message builder\n+   * @param node the node from where we extract a message\n+   * @throws MalformedException if the parsed message is invalid\n+   */\n+  private void extractFromReturnDescendant(Builder builder, Node node)\n+      throws MalformedException {\n+\n+    switch (node.getType()) {\n+      case Token.STRING:\n+        builder.appendStringPart(node.getString());\n+        break;\n+      case Token.NAME:\n+        builder.appendPlaceholderReference(node.getString());\n+        break;\n+      case Token.ADD:\n+        for (Node child : node.children()) {\n+          extractFromReturnDescendant(builder, child);\n+        }\n+        break;\n+      default:\n+        throw new MalformedException(\n+            \"STRING, NAME, or ADD node expected; found: \"\n+                + getReadableTokenName(node), node);\n+    }\n+  }\n+\n+  /**\n+   * Initializes a message builder from a CALL node.\n+   * <p>\n+   * The tree should look something like:\n+   *\n+   * <pre>\n+   * call\n+   *  |-- getprop\n+   *  |   |-- name 'goog'\n+   *  |   +-- string 'getMsg'\n+   *  |\n+   *  |-- string 'Hi {$userName}! Welcome to {$product}.'\n+   *  +-- objlit\n+   *      |-- string 'userName'\n+   *      |-- name 'someUserName'\n+   *      |-- string 'product'\n+   *      +-- call\n+   *          +-- name 'getProductName'\n+   * </pre>\n+   *\n+   * @param builder the message builder\n+   * @param node the call node from where we extract the message\n+   * @throws MalformedException if the parsed message is invalid\n+   */\n+  private void extractFromCallNode(Builder builder,\n+      Node node) throws MalformedException {\n+    // Check the function being called\n+    if (node.getType() != Token.CALL) {\n+      throw new MalformedException(\n+          \"Message must be initialized using \" + MSG_FUNCTION_NAME +\n+          \" function.\", node);\n+    }\n+\n+    Node fnNameNode = node.getFirstChild();\n+    if (!MSG_FUNCTION_NAME.equals(fnNameNode.getQualifiedName())) {\n+      throw new MalformedException(\n+          \"Message initialized using unrecognized function. \" +\n+          \"Please use \" + MSG_FUNCTION_NAME + \"() instead.\", fnNameNode);\n+    }\n+\n+    // Get the message string\n+    Node stringLiteralNode = fnNameNode.getNext();\n+    if (stringLiteralNode == null) {\n+      throw new MalformedException(\"Message string literal expected\",\n+          stringLiteralNode);\n+    }\n+    // Parse the message string and append parts to the builder\n+    parseMessageTextNode(builder, stringLiteralNode);\n+\n+    Node objLitNode = stringLiteralNode.getNext();\n+    Set<String> phNames = Sets.newHashSet();\n+    if (objLitNode != null) {\n+      // Register the placeholder names\n+      if (objLitNode.getType() != Token.OBJECTLIT) {\n+        throw new MalformedException(\"OBJLIT node expected\", objLitNode);\n+      }\n+      for (Node aNode = objLitNode.getFirstChild(); aNode != null;\n+          aNode = aNode.getNext().getNext()) {\n+        if (aNode.getType() != Token.STRING) {\n+          throw new MalformedException(\"STRING node expected as OBJLIT key\",\n+              aNode);\n+        }\n+        String phName = aNode.getString();\n+        if (!isLowerCamelCaseWithNumericSuffixes(phName)) {\n+          throw new MalformedException(\n+              \"Placeholder name not in lowerCamelCase: \" + phName, aNode);\n+        }\n+\n+        if (phNames.contains(phName)) {\n+          throw new MalformedException(\"Duplicate placeholder name: \"\n+              + phName, aNode);\n+        }\n+\n+        phNames.add(phName);\n+      }\n+    }\n+\n+    // Check that all placeholders from the message text have appropriate objlit\n+    // values\n+    Set<String> usedPlaceholders = builder.getPlaceholders();\n+    for (String phName : usedPlaceholders) {\n+      if(!phNames.contains(phName)) {\n+        throw new MalformedException(\n+            \"Unrecognized message placeholder referenced: \" + phName,\n+            objLitNode);\n+      }\n+    }\n+\n+    // Check that objLiteral have only names that are present in the\n+    // message text\n+    for (String phName : phNames) {\n+      if(!usedPlaceholders.contains(phName)) {\n+        throw new MalformedException(\n+            \"Unused message placeholder: \" + phName,\n+            objLitNode);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Appends the message parts in a JS message value extracted from the given\n+   * text node.\n+   *\n+   * @param builder the js message builder to append parts to\n+   * @param node the node with string literal that contains the message text\n+   * @throws MalformedException if {@code value} contains a reference to\n+   *         an unregistered placeholder\n+   */\n+  private void parseMessageTextNode(Builder builder, Node node)\n+      throws MalformedException {\n+    String value = extractStringFromStringExprNode(node);\n+\n+    while(true) {\n+      int phBegin = value.indexOf(PH_JS_PREFIX);\n+      if (phBegin < 0) {\n+        // Just a string literal\n+        builder.appendStringPart(value);\n+        return;\n+      } else {\n+        if (phBegin > 0) {\n+          // A string literal followed by a placeholder\n+          builder.appendStringPart(value.substring(0, phBegin));\n+        }\n+\n+        // A placeholder. Find where it ends\n+        int phEnd = value.indexOf(PH_JS_SUFFIX, phBegin);\n+        if (phEnd < 0) {\n+          throw new MalformedException(\n+              \"Placeholder incorrectly formatted in: \" + builder.getKey(),\n+              node);\n+        }\n+\n+        String phName = value.substring(phBegin + PH_JS_PREFIX.length(),\n+            phEnd);\n+        builder.appendPlaceholderReference(phName);\n+        int nextPos = phEnd + PH_JS_SUFFIX.length();\n+        if (nextPos < value.length()) {\n+          // Iterate on the rest of the message value\n+          value = value.substring(nextPos);\n+        } else {\n+          // The message is parsed\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Processes found js message. Several examples of \"standard\" processing\n+   * routines are:\n+   * <ol>\n+   * <li>extract all js messages\n+   * <li>replace js messages with localized versions for some specific language\n+   * <li>check that messages have correct syntax and present in localization\n+   *     bundle\n+   * </ol>\n+   *\n+   * @param message the found message\n+   * @param definition the definition of the object and usually contains all\n+   *        additional message information like message node/parent's node\n+   */\n+  abstract void processJsMessage(JsMessage message,\n+      JsMessageDefinition definition);\n+\n+  /**\n+   * Returns whether the given js identifier is a valid js message name.\n+   */\n+  boolean isMessageName(String identifier, boolean isNewStyleMessage) {\n+    return identifier.startsWith(MSG_PREFIX) &&\n+        (style == JsMessage.Style.CLOSURE || isNewStyleMessage ||\n+         !identifier.endsWith(DESC_SUFFIX));\n+  }\n+\n+  /**\n+   * Returns whether the given message name is in the unnamed namespace.\n+   */\n+  private static boolean isUnnamedMessageName(String identifier) {\n+    return MSG_UNNAMED_PATTERN.matcher(identifier).matches();\n+  }\n+\n+  /**\n+   * Returns whether a string is nonempty, begins with a lowercase letter, and\n+   * contains only digits and underscores after the first underscore.\n+   */\n+  static boolean isLowerCamelCaseWithNumericSuffixes(String input) {\n+    return CAMELCASE_PATTERN.matcher(input).matches();\n+  }\n+\n+  /**\n+   * Returns human-readable name of the given node's type.\n+   */\n+  private static String getReadableTokenName(Node node) {\n+    return Node.tokenToName(node.getType()).toUpperCase();\n+  }\n+\n+  /**\n+   * Converts the given string from upper-underscore case to lower-camel case,\n+   * preserving numeric suffixes. For example: \"NAME\" -> \"name\" \"A4_LETTER\" ->\n+   * \"a4Letter\" \"START_SPAN_1_23\" -> \"startSpan_1_23\".\n+   */\n+  static String toLowerCamelCaseWithNumericSuffixes(String input) {\n+    // Determine where the numeric suffixes begin\n+    int suffixStart = input.length();\n+    while (suffixStart > 0) {\n+      char ch = '\\0';\n+      int numberStart = suffixStart;\n+      while (numberStart > 0) {\n+        ch = input.charAt(numberStart - 1);\n+        if (Character.isDigit(ch)) {\n+          numberStart--;\n+        } else {\n+          break;\n+        }\n+      }\n+      if ((numberStart > 0) && (numberStart < suffixStart) && (ch == '_')) {\n+        suffixStart = numberStart - 1;\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    if (suffixStart == input.length()) {\n+      return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, input);\n+    } else {\n+      return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,\n+          input.substring(0, suffixStart)) +\n+          input.substring(suffixStart);\n+    }\n+  }\n+\n+  static class MalformedException extends Exception {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final Node node;\n+\n+    MalformedException(String message, Node node) {\n+      super(message);\n+      this.node = node;\n+    }\n+\n+    Node getNode() {\n+      return node;\n+    }\n+  }\n+\n+  private static class MessageLocation {\n+    private final String sourceName;\n+    private final int lineNo;\n+\n+    private MessageLocation(String sourceName, int lineNo) {\n+      this.sourceName = sourceName;\n+      this.lineNo = lineNo;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/MessageBundle.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import java.util.Locale;\n+\n+/**\n+ * An interface for providing alterative values for user-visible messages in\n+ * javascript code.\n+ *\n+*\n+*\n+ */\n+public interface MessageBundle {\n+\n+  /**\n+   * Gets the message ID generator to use to compute message IDs for this\n+   * type of bundle.\n+   * @return idGenerator instance or null if we do not want to use any custom\n+   *     id generation. In case if idGenerator is null caller should decide how\n+   *     to create id by itself. In the most cases using the message key is\n+   *     enough.\n+   */\n+  public JsMessage.IdGenerator idGenerator();\n+\n+  /**\n+   * Gets a message replacement.\n+   *\n+   * @param id the id of the message being replaced; the key is message ID\n+   *     generated by {@link JsMessage.IdGenerator}\n+   * @return the message replacement, which may be null.\n+   */\n+  public JsMessage getMessage(String id);\n+\n+  /**\n+   * Returns an iterable over the keys that this object has replacements for.\n+   * @return all messages from this bundle.\n+   */\n+  public Iterable<JsMessage> getAllMessages();\n+\n+  /**\n+   * Returns bundle locale.\n+   * @return locale for bundle's messages.\n+   */\n+  public Locale getLocale();\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import javax.annotation.Nullable;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * ReplaceMessages replaces user-visible messages with alternatives.\n+ * It uses Google specific JsMessageVisitor implementation.\n+ *\n+*\n+*\n+ * @author anatol@google.com (Anatol Pomazau)\n+ */\n+class ReplaceMessages extends JsMessageVisitor {\n+  private final MessageBundle bundle;\n+  private final boolean strictReplacement;\n+\n+  static final DiagnosticType BUNDLE_DOES_NOT_HAVE_THE_MESSAGE =\n+      DiagnosticType.error(\"JSC_BUNDLE_DOES_NOT_HAVE_THE_MESSAGE\",\n+          \"Message with id = {0} cound not be found in replacement bundle\");\n+\n+  ReplaceMessages(AbstractCompiler compiler, MessageBundle bundle,\n+      boolean checkDuplicatedMessages, JsMessage.Style style,\n+      boolean strictReplacement) {\n+\n+    super(compiler, checkDuplicatedMessages, style, bundle.idGenerator());\n+\n+    this.bundle = bundle;\n+    this.strictReplacement = strictReplacement;\n+  }\n+\n+  @Override\n+  protected void processJsMessage(JsMessage message,\n+      JsMessageDefinition definition) {\n+\n+    // Get the replacement.\n+    JsMessage replacement = bundle.getMessage(message.getId());\n+    if (replacement == null) {\n+      if (strictReplacement) {\n+        compiler.report(JSError.make(message.getSourceName(),\n+            definition.getMessageNode(), BUNDLE_DOES_NOT_HAVE_THE_MESSAGE,\n+            message.getId()));\n+        // Fallback to the default message\n+        return;\n+      } else {\n+        // In case if it is not a strict replacement we could leave original\n+        // message.\n+        replacement = message;\n+      }\n+    }\n+\n+    // Replace the message.\n+    Node newValue;\n+    Node msgNode = definition.getMessageNode();\n+    try {\n+      newValue = getNewValueNode(replacement, msgNode);\n+    } catch (MalformedException e) {\n+      compiler.report(JSError.make(message.getSourceName(),\n+          e.getNode(), MESSAGE_TREE_MALFORMED, e.getMessage()));\n+      newValue = msgNode;\n+    }\n+\n+    if (newValue != msgNode) {\n+      definition.getMessageParentNode().replaceChild(msgNode, newValue);\n+    }\n+  }\n+\n+  /**\n+   * Constructs a node representing a message's value, or, if possible, just\n+   * modifies {@code origValueNode} so that it accurately represents the\n+   * message's value.\n+   *\n+   * @param message  a message\n+   * @param origValueNode  the message's original value node\n+   * @return a Node that can replace {@code origValueNode}\n+   *\n+   * @throws MalformedException if the passed node's subtree structure is\n+   *   not as expected\n+   */\n+  private Node getNewValueNode(JsMessage message, Node origValueNode)\n+      throws MalformedException {\n+    switch (origValueNode.getType()) {\n+      case Token.FUNCTION:\n+        // The message is a function. Modify the function node.\n+        updateFunctionNode(message, origValueNode);\n+        return origValueNode;\n+      case Token.STRING:\n+        // The message is a simple string. Modify the string node.\n+        origValueNode.setString(message.toString());\n+        return origValueNode;\n+      case Token.ADD:\n+        // The message is a simple string. Create a string node.\n+        return Node.newString(message.toString());\n+      case Token.CALL:\n+        // The message is a function call. Replace it with a string expression.\n+        return replaceCallNode(message, origValueNode);\n+      default:\n+        throw new MalformedException(\n+            \"Expected FUNCTION, STRING, or ADD node; found: \" +\n+                origValueNode.getType(), origValueNode);\n+    }\n+  }\n+\n+  /**\n+   * Updates the descendants of a FUNCTION node to represent a message's value.\n+   * <p>\n+   * The tree looks something like:\n+   * <pre>\n+   * function\n+   *  |-- name\n+   *  |-- lp\n+   *  |   |-- name <arg1>\n+   *  |    -- name <arg2>\n+   *   -- block\n+   *      |\n+   *       --return\n+   *           |\n+   *            --add\n+   *               |-- string foo\n+   *                -- name <arg1>\n+   * </pre>\n+   *\n+   * @param message  a message\n+   * @param functionNode  the message's original FUNCTION value node\n+   *\n+   * @throws MalformedException if the passed node's subtree structure is\n+   *         not as expected\n+   */\n+  private void updateFunctionNode(JsMessage message, Node functionNode)\n+      throws MalformedException {\n+    checkNode(functionNode, Token.FUNCTION);\n+    Node nameNode = functionNode.getFirstChild();\n+    checkNode(nameNode, Token.NAME);\n+    Node argListNode = nameNode.getNext();\n+    checkNode(argListNode, Token.LP);\n+    Node oldBlockNode = argListNode.getNext();\n+    checkNode(oldBlockNode, Token.BLOCK);\n+\n+    Iterator<CharSequence> iterator = message.parts().iterator();\n+    Node valueNode = iterator.hasNext()\n+        ? constructAddOrStringNode(iterator, argListNode)\n+        : Node.newString(\"\");\n+    Node newBlockNode = new Node(Token.BLOCK,\n+        new Node(Token.RETURN, valueNode));\n+\n+    functionNode.replaceChild(oldBlockNode, newBlockNode);\n+  }\n+\n+  /**\n+   * Creates a parse tree corresponding to the remaining message parts in\n+   * an iteration. The result will contain only STRING nodes, NAME nodes\n+   * (corresponding to placeholder references), and/or ADD nodes used to\n+   * combine the other two types.\n+   *\n+   * @param partsIterator  an iterator over message parts\n+   * @param argListNode  an LP node whose children are valid placeholder names\n+   * @return the root of the constructed parse tree\n+   *\n+   * @throws MalformedException if {@code partsIterator} contains a\n+   *   placeholder reference that does not correspond to a valid argument in\n+   *   the arg list\n+   */\n+  private Node constructAddOrStringNode(Iterator<CharSequence> partsIterator,\n+                                        Node argListNode)\n+      throws MalformedException {\n+    CharSequence part = partsIterator.next();\n+    Node partNode = null;\n+    if (part instanceof JsMessage.PlaceholderReference) {\n+      JsMessage.PlaceholderReference phRef =\n+          (JsMessage.PlaceholderReference) part;\n+\n+      for (Node node : argListNode.children()) {\n+        if (node.getType() == Token.NAME) {\n+          String arg = node.getString();\n+\n+          // We ignore the case here because the transconsole only supports\n+          // uppercase placeholder names, but function arguments in javascript\n+          // code can have mixed case.\n+          if (arg.equalsIgnoreCase(phRef.getName())) {\n+            partNode = Node.newString(Token.NAME, arg);\n+          }\n+        }\n+      }\n+\n+      if (partNode == null) {\n+        throw new MalformedException(\n+            \"Unrecognized message placeholder referenced: \" + phRef.getName(),\n+            argListNode);\n+      }\n+    } else {\n+      // The part is just a string literal.\n+      partNode = Node.newString(part.toString());\n+    }\n+\n+    if (partsIterator.hasNext()) {\n+      return new Node(Token.ADD, partNode,\n+                      constructAddOrStringNode(partsIterator, argListNode));\n+    } else {\n+      return partNode;\n+    }\n+  }\n+\n+  /**\n+   * Replaces a CALL node with an inlined message value.\n+   *  <p>\n+   * The call tree looks something like:\n+   * <pre>\n+   * call\n+   *  |-- getprop\n+   *  |   |-- name 'goog'\n+   *  |   +-- string 'getMsg'\n+   *  |\n+   *  |-- string 'Hi {$userName}! Welcome to {$product}.'\n+   *  +-- objlit\n+   *      |-- string 'userName'\n+   *      |-- name 'someUserName'\n+   *      |-- string 'product'\n+   *      +-- call\n+   *          +-- name 'getProductName'\n+   * <pre>\n+   * <p>\n+   * For that example, we'd return:\n+   * <pre>\n+   * add\n+   *  |-- string 'Hi '\n+   *  +-- add\n+   *      |-- name someUserName\n+   *      +-- add\n+   *          |-- string '! Welcome to '\n+   *          +-- add\n+   *              |-- call\n+   *              |   +-- name 'getProductName'\n+   *              +-- string '.'\n+   * </pre>\n+   * @param message  a message\n+   * @param callNode  the message's original CALL value node\n+   * @return a STRING node, or an ADD node that does string concatenation, if\n+   *   the message has one or more placeholders\n+   *\n+   * @throws MalformedException if the passed node's subtree structure is\n+   *   not as expected\n+   */\n+  private Node replaceCallNode(JsMessage message, Node callNode)\n+      throws MalformedException {\n+    checkNode(callNode, Token.CALL);\n+    Node getPropNode = callNode.getFirstChild();\n+    checkNode(getPropNode, Token.GETPROP);\n+    Node stringExprNode = getPropNode.getNext();\n+    checkStringExprNode(stringExprNode);\n+    Node objLitNode = stringExprNode.getNext();\n+\n+    // Build the replacement tree.\n+    return constructStringExprNode(message.parts().iterator(), objLitNode);\n+  }\n+\n+  /**\n+   * Creates a parse tree corresponding to the remaining message parts in an\n+   * iteration. The result consists of one or more STRING nodes, placeholder\n+   * replacement value nodes (which can be arbitrary expressions), and ADD\n+   * nodes.\n+   *\n+   * @param parts  an iterator over message parts\n+   * @param objLitNode  an OBJLIT node mapping placeholder names to values\n+   * @return the root of the constructed parse tree\n+   *\n+   * @throws MalformedException if {@code parts} contains a placeholder\n+   *   reference that does not correspond to a valid placeholder name\n+   */\n+  private Node constructStringExprNode(Iterator<CharSequence> parts,\n+      Node objLitNode) throws MalformedException {\n+\n+    CharSequence part = parts.next();\n+    Node partNode = null;\n+    if (part instanceof JsMessage.PlaceholderReference) {\n+      JsMessage.PlaceholderReference phRef =\n+          (JsMessage.PlaceholderReference) part;\n+\n+      for (Node n = objLitNode.getFirstChild(); n != null;\n+          n = n.getNext().getNext()) {\n+        if (n.getString().equals(phRef.getName())) {\n+          Node valueNode = n.getNext();\n+          partNode = valueNode.cloneTree();\n+        }\n+      }\n+\n+      if (partNode == null) {\n+        throw new MalformedException(\n+            \"Unrecognized message placeholder referenced: \" + phRef.getName(),\n+            objLitNode);\n+      }\n+    } else {\n+      // The part is just a string literal.\n+      partNode = Node.newString(part.toString());\n+    }\n+\n+    if (parts.hasNext()) {\n+      return new Node(Token.ADD, partNode,\n+          constructStringExprNode(parts, objLitNode));\n+    } else {\n+      return partNode;\n+    }\n+  }\n+\n+  /**\n+   * Checks a node's type.\n+   *\n+   * @throws MalformedException if the node is null or the wrong type\n+   */\n+  private void checkNode(@Nullable Node node, int type) throws MalformedException {\n+    if (node == null) {\n+      throw new MalformedException(\n+          \"Expected node type \" + type + \"; found: null\", node);\n+    }\n+    if (node.getType() != type) {\n+      throw new MalformedException(\n+          \"Expected node type \" + type + \"; found: \" + node.getType(), node);\n+    }\n+  }\n+\n+  /**\n+   * Checks that a node is a valid string expression (either a string literal\n+   * or a concatenation of string literals).\n+   *\n+   * @throws IllegalArgumentException if the node is null or the wrong type\n+   */\n+  private void checkStringExprNode(@Nullable Node node) {\n+    if (node == null) {\n+      throw new IllegalArgumentException(\"Expected a string; found: null\");\n+    }\n+    switch (node.getType()) {\n+      case Token.STRING:\n+        break;\n+      case Token.ADD:\n+        Node c = node.getFirstChild();\n+        checkStringExprNode(c);\n+        checkStringExprNode(c.getNext());\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\n+            \"Expected a string; found: \" + node.getType());\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n \n package com.google.javascript.jscomp.deps;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.HashMultimap;\n import java.util.Map;\n import java.util.PriorityQueue;\n import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n \n /**\n  * A sorted list of inputs with dependency information. Uses a stable\n \n   private final Map<String, INPUT> provideMap = Maps.newHashMap();\n \n-  public SortedDependencies(List<INPUT> inputs) {\n+  public SortedDependencies(List<INPUT> inputs)\n+      throws CircularDependencyException {\n     this.inputs = Lists.newArrayList(inputs);\n     noProvides = Lists.newArrayList();\n \n \n     // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n     sortedList = topologicalStableSort(inputs, deps);\n+\n+    // The dependency graph of inputs has a cycle iff sortedList is a proper\n+    // subset of inputs. Also, it has a cycle iff the subgraph\n+    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n+    // by the lemma that a graph has a cycle iff it has a subgraph where\n+    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n+    // to the reader.\n+    if (sortedList.size() < inputs.size()) {\n+      List<INPUT> subGraph = Lists.newArrayList(inputs);\n+      subGraph.removeAll(sortedList);\n+\n+      throw new CircularDependencyException(\n+          cycleToString(findCycle(subGraph, deps)));\n+    }\n+  }\n+\n+  /**\n+   * Returns the first circular dependency found. Expressed as a list of\n+   * items in reverse dependency order (the second element depends on the\n+   * first, etc.).\n+   */\n+  private List<INPUT> findCycle(\n+      List<INPUT> subGraph, Multimap<INPUT, INPUT> deps) {\n+    return findCycle(subGraph.get(0), Sets.<INPUT>newHashSet(subGraph),\n+        deps, Sets.<INPUT>newHashSet());\n+  }\n+\n+  private List<INPUT> findCycle(\n+      INPUT current, Set<INPUT> subGraph, Multimap<INPUT, INPUT> deps,\n+      Set<INPUT> covered) {\n+    if (covered.add(current)) {\n+      List<INPUT> cycle = findCycle(\n+          findRequireInSubGraphOrFail(current, subGraph),\n+          subGraph, deps, covered);\n+\n+      // Don't add the input to the list if the cycle has closed already.\n+      if (cycle.get(0) != cycle.get(cycle.size() - 1)) {\n+        cycle.add(current);\n+      }\n+\n+      return cycle;\n+    } else {\n+      // Explicitly use the add() method, to prevent a generics constructor\n+      // warning that is dumb. The condition it's protecting is\n+      // obscure, and I think people have proposed that it be removed.\n+      List<INPUT> cycle = Lists.<INPUT>newArrayList();\n+      cycle.add(current);\n+      return cycle;\n+    }\n+  }\n+\n+  private INPUT findRequireInSubGraphOrFail(INPUT input, Set<INPUT> subGraph) {\n+    for (String symbol : input.getRequires()) {\n+      INPUT candidate = provideMap.get(symbol);\n+      if (subGraph.contains(candidate)) {\n+        return candidate;\n+      }\n+    }\n+    throw new IllegalStateException(\"no require found in subgraph\");\n+  }\n+\n+  /**\n+   * @param cycle A cycle in reverse-dependency order.\n+   */\n+  private String cycleToString(List<INPUT> cycle) {\n+    List<String> symbols = Lists.newArrayList();\n+    for (int i = cycle.size() - 1; i >= 0; i--) {\n+      symbols.add(cycle.get(i).getProvides().iterator().next());\n+    }\n+    symbols.add(symbols.get(0));\n+    return Joiner.on(\" -> \").join(symbols);\n   }\n \n   public List<INPUT> getSortedList() {\n       }\n     }\n \n-    ImmutableList.Builder builder = ImmutableList.builder();\n+    ImmutableList.Builder<INPUT> builder = ImmutableList.builder();\n     for (INPUT current : sortedList) {\n       if (included.contains(current)) {\n         builder.add(current);\n \n     return result;\n   }\n+\n+  public static class CircularDependencyException extends Exception {\n+    CircularDependencyException(String message) {\n+      super(message);\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          });\n   }\n \n+  public void testSourceSortingCircularDeps1() {\n+    args.add(\"--manage_closure_dependencies=true\");\n+    test(new String[] {\n+          \"goog.provide('gin'); goog.require('tonic'); var gin = {};\",\n+          \"goog.provide('tonic'); goog.require('gin'); var tonic = {};\",\n+          \"goog.require('gin'); goog.require('tonic');\"\n+         },\n+         JSModule.CIRCULAR_DEPENDENCY_ERROR);\n+  }\n+\n+  public void testSourceSortingCircularDeps2() {\n+    args.add(\"--manage_closure_dependencies=true\");\n+    test(new String[] {\n+          \"goog.provide('roses.lime.juice');\",\n+          \"goog.provide('gin'); goog.require('tonic'); var gin = {};\",\n+          \"goog.provide('tonic'); goog.require('gin'); var tonic = {};\",\n+          \"goog.require('gin'); goog.require('tonic');\",\n+          \"goog.provide('gimlet');\" +\n+          \"     goog.require('gin'); goog.require('roses.lime.juice');\"\n+         },\n+         JSModule.CIRCULAR_DEPENDENCY_ERROR);\n+  }\n+\n   public void testSourcePruningOn() {\n     args.add(\"--manage_closure_dependencies=true\");\n     test(new String[] {\n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n     assertEquals(\"d.js\", E.getInputs().get(0).getName());\n   }\n \n-  public void testManageDependencies() {\n+  public void testManageDependencies() throws Exception {\n     List<CompilerInput> inputs = Lists.newArrayList();\n \n     A.add(code(\"a1\", provides(\"a1\"), requires()));\n--- a/test/com/google/javascript/jscomp/JSModuleTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleTest.java\n                  mod4.getThisAndAllDependencies());\n   }\n \n-  public void testSortInputs() {\n+  public void testSortInputs() throws Exception {\n     CompilerInput a = new CompilerInput(\n         JSSourceFile.fromCode(\"a.js\",\n             \"goog.require('b');goog.require('c')\"));\n   }\n \n   private void assertSortedInputs(\n-      List<CompilerInput> expected, List<CompilerInput> shuffled) {\n+      List<CompilerInput> expected, List<CompilerInput> shuffled)\n+      throws Exception {\n     JSModule mod = new JSModule(\"mod\");\n     for (CompilerInput input : shuffled) {\n       input.setModule(null);\n     assertEquals(expected, mod.getInputs());\n   }\n \n-  public void testSortJsModules() {\n+  public void testSortJsModules() throws Exception {\n     // already in order:\n     assertEquals(ImmutableList.of(mod1, mod2, mod3, mod4),\n         Arrays.asList(JSModule.sortJsModules(\n--- a/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java\n+++ b/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n \n import junit.framework.TestCase;\n \n  */\n public class SortedDependenciesTest extends TestCase {\n \n-  public void testSort() {\n+  public void testSort() throws Exception {\n     SimpleDependencyInfo a = new SimpleDependencyInfo(\n-        \"a\", \"a\", symbols(), symbols(\"b\", \"c\"));\n+        \"a\", \"a\", provides(), requires(\"b\", \"c\"));\n     SimpleDependencyInfo b = new SimpleDependencyInfo(\n-        \"b\", \"b\", symbols(\"b\"), symbols(\"d\"));\n+        \"b\", \"b\", provides(\"b\"), requires(\"d\"));\n     SimpleDependencyInfo c = new SimpleDependencyInfo(\n-        \"c\", \"c\", symbols(\"c\"), symbols(\"d\"));\n+        \"c\", \"c\", provides(\"c\"), requires(\"d\"));\n     SimpleDependencyInfo d = new SimpleDependencyInfo(\n-        \"d\", \"d\", symbols(\"d\"), symbols());\n+        \"d\", \"d\", provides(\"d\"), requires());\n     SimpleDependencyInfo e = new SimpleDependencyInfo(\n-        \"e\", \"e\", symbols(\"e\"), symbols());\n+        \"e\", \"e\", provides(\"e\"), requires());\n     SimpleDependencyInfo f = new SimpleDependencyInfo(\n-        \"f\", \"f\", symbols(\"f\"), symbols());\n+        \"f\", \"f\", provides(\"f\"), requires());\n \n     assertSortedInputs(\n         ImmutableList.of(d, b, c, a),\n     } catch (IllegalArgumentException expected) {}\n   }\n \n-  public void testSort2() {\n+  public void testSort2() throws Exception {\n     SimpleDependencyInfo ab = new SimpleDependencyInfo(\n-        \"ab\", \"ab\", symbols(\"a\", \"b\"), symbols(\"d\", \"f\"));\n+        \"ab\", \"ab\", provides(\"a\", \"b\"), requires(\"d\", \"f\"));\n     SimpleDependencyInfo c = new SimpleDependencyInfo(\n-        \"c\", \"c\", symbols(\"c\"), symbols(\"h\"));\n+        \"c\", \"c\", provides(\"c\"), requires(\"h\"));\n     SimpleDependencyInfo d = new SimpleDependencyInfo(\n-        \"d\", \"d\", symbols(\"d\"), symbols(\"e\", \"f\"));\n+        \"d\", \"d\", provides(\"d\"), requires(\"e\", \"f\"));\n     SimpleDependencyInfo ef = new SimpleDependencyInfo(\n-        \"ef\", \"ef\", symbols(\"e\", \"f\"), symbols(\"g\", \"c\"));\n+        \"ef\", \"ef\", provides(\"e\", \"f\"), requires(\"g\", \"c\"));\n     SimpleDependencyInfo g = new SimpleDependencyInfo(\n-        \"g\", \"g\", symbols(\"g\"), symbols());\n+        \"g\", \"g\", provides(\"g\"), requires());\n     SimpleDependencyInfo hi = new SimpleDependencyInfo(\n-        \"hi\", \"hi\", symbols(\"h\", \"i\"), symbols());\n+        \"hi\", \"hi\", provides(\"h\", \"i\"), requires());\n \n     assertSortedInputs(\n         ImmutableList.of(g, hi, c, ef, d, ab),\n         ImmutableList.of(d, hi));\n   }\n \n+  public void testSort3() {\n+    SimpleDependencyInfo a = new SimpleDependencyInfo(\n+        \"a\", \"a\", provides(\"a\"), requires(\"c\"));\n+    SimpleDependencyInfo b = new SimpleDependencyInfo(\n+        \"b\", \"b\", provides(\"b\"), requires(\"a\"));\n+    SimpleDependencyInfo c = new SimpleDependencyInfo(\n+        \"c\", \"c\", provides(\"c\"), requires(\"b\"));\n+\n+    try {\n+      new SortedDependencies<SimpleDependencyInfo>(\n+          Lists.newArrayList(a, b, c));\n+      fail(\"expected exception\");\n+    } catch (CircularDependencyException e) {}\n+  }\n+\n+  public void testSort4() {\n+    SimpleDependencyInfo a = new SimpleDependencyInfo(\n+        \"a\", \"a\", provides(\"a\"), requires(\"a\"));\n+\n+    try {\n+      new SortedDependencies<SimpleDependencyInfo>(\n+          Lists.newArrayList(a));\n+      fail(\"expected exception\");\n+    } catch (CircularDependencyException e){\n+      assertEquals(\"a -> a\", e.getMessage());\n+    }\n+  }\n+\n+  public void testSort5() throws Exception {\n+    SimpleDependencyInfo a = new SimpleDependencyInfo(\n+        \"a\", \"a\", provides(\"a\"), requires());\n+    SimpleDependencyInfo b = new SimpleDependencyInfo(\n+        \"b\", \"b\", provides(\"b\"), requires());\n+    SimpleDependencyInfo c = new SimpleDependencyInfo(\n+        \"c\", \"c\", provides(\"c\"), requires());\n+\n+    assertSortedInputs(\n+        ImmutableList.of(a, b, c),\n+        ImmutableList.of(a, b, c));\n+    assertSortedInputs(\n+        ImmutableList.of(c, b, a),\n+        ImmutableList.of(c, b, a));\n+  }\n+\n   private void assertSortedInputs(\n       List<SimpleDependencyInfo> expected,\n-      List<SimpleDependencyInfo> shuffled) {\n+      List<SimpleDependencyInfo> shuffled) throws Exception {\n     SortedDependencies<SimpleDependencyInfo> sorted =\n         new SortedDependencies<SimpleDependencyInfo>(shuffled);\n     assertEquals(expected, sorted.getSortedList());\n   private void assertSortedDeps(\n       List<SimpleDependencyInfo> expected,\n       List<SimpleDependencyInfo> shuffled,\n-      List<SimpleDependencyInfo> roots) {\n+      List<SimpleDependencyInfo> roots) throws Exception {\n     SortedDependencies<SimpleDependencyInfo> sorted =\n         new SortedDependencies<SimpleDependencyInfo>(shuffled);\n     assertEquals(expected, sorted.getSortedDependenciesOf(roots));\n   }\n \n-  private List<String> symbols(String ... strings) {\n+  private List<String> requires(String ... strings) {\n+    return Lists.newArrayList(strings);\n+  }\n+\n+  private List<String> provides(String ... strings) {\n     return Lists.newArrayList(strings);\n   }\n }", "timestamp": 1274229479, "metainfo": ""}