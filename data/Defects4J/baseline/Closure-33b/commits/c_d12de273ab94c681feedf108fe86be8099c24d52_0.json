{"sha": "d12de273ab94c681feedf108fe86be8099c24d52", "log": "added unit-tests for GlobalVarReferenceMap  R=nicksantos DELTA=163  (163 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2098   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n           basicBlock, t.getScope(), t.getSourceName());\n     }\n \n+    /**\n+     * Creates a variable reference in a given script file name, used in tests.\n+     *\n+     * @param sourceName The name of the script file.\n+     * @return The created reference.\n+     */\n+    @VisibleForTesting\n+    static Reference createRefForTest(String sourceName) {\n+      return new Reference(new Node(Token.NAME), null, null, null, null,\n+          sourceName);\n+    }\n+\n     private Reference(Node nameNode, Node parent, Node grandparent,\n         BasicBlock basicBlock, Scope scope, String sourceName) {\n       this.nameNode = nameNode;\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import static com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.createRefForTest;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Map;\n+\n+/**\n+ * Unit-tests for the GlobalVarReferenceMap class.\n+ *\n+ * @author bashir@google.com (Bashir Sadjad)\n+ */\n+public class GlobalVarReferenceMapTest extends TestCase {\n+\n+  private static final CompilerInput INPUT1 =\n+      new CompilerInput(null, \"input1\", false);\n+  private static final CompilerInput INPUT2 =\n+      new CompilerInput(null, \"input2\", false);\n+  private static final CompilerInput INPUT3 =\n+      new CompilerInput(null, \"input3\", false);\n+\n+  private final GlobalVarReferenceMap map = new GlobalVarReferenceMap(\n+      Lists.newArrayList(INPUT1, INPUT2, INPUT3));\n+  private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap();\n+  private final Node root = new Node(Token.BLOCK);\n+  private final Scope globalScope = new Scope(root, (ObjectType) null);\n+  Node scriptRoot = new Node(Token.SCRIPT);\n+\n+  // In the initial setUp we have 3 references to var1 (one in each input) and\n+  // 2 references to var2 (in first and third inputs).\n+  private static final String VAR1 = \"var1\";\n+  private static final String VAR2 = \"var2\";\n+  private final ReferenceCollection var1Refs = new ReferenceCollection();\n+  private final ReferenceCollection var2Refs = new ReferenceCollection();\n+  private final Reference var1In1Ref =  createRefForTest(INPUT1.getName());\n+  private final Reference var1In2Ref =  createRefForTest(INPUT2.getName());\n+  private final Reference var1In3Ref =  createRefForTest(INPUT3.getName());\n+  private final Reference var2In1Ref =  createRefForTest(INPUT1.getName());\n+  private final Reference var2In3Ref =  createRefForTest(INPUT3.getName());\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    globalScope.declare(VAR1, new Node(Token.NAME), null, INPUT1);\n+    var1Refs.references = Lists.newArrayList(var1In1Ref,\n+        var1In2Ref, var1In3Ref);\n+    globalScope.declare(VAR2, new Node(Token.NAME), null, INPUT1);\n+    var2Refs.references = Lists.newArrayList(var2In1Ref, var2In3Ref);\n+    // We recreate these two ReferenceCollection to keep var1Refs and\n+    // var2Refs intact in update operations for comparison in the tests.\n+    ReferenceCollection var1TempRefs = new ReferenceCollection();\n+    var1TempRefs.references = Lists.newArrayList(var1Refs.references);\n+    ReferenceCollection var2TempRefs = new ReferenceCollection();\n+    var2TempRefs.references = Lists.newArrayList(var2Refs.references);\n+    globalMap.put(globalScope.getVar(VAR1), var1TempRefs);\n+    globalMap.put(globalScope.getVar(VAR2), var2TempRefs);\n+    map.updateGlobalVarReferences(globalMap, root);\n+    scriptRoot.putProp(Node.SOURCENAME_PROP, INPUT2.getName());\n+  }\n+\n+  /** Tests whether the global variable references are set/reset properly. */\n+  public void testUpdateGlobalVarReferences_ResetReferences() {\n+    // First we check the original setup then reset again.\n+    for (int i = 0; i < 2; i++) {\n+      assertEquals(var1Refs.references,\n+          map.getReferences(globalScope.getVar(VAR1)).references);\n+      assertEquals(var2Refs.references,\n+          map.getReferences(globalScope.getVar(VAR2)).references);\n+      map.updateGlobalVarReferences(globalMap, root);\n+    }\n+  }\n+\n+  /** Removes all variable references in second script. */\n+  public void testUpdateGlobalVarReferences_UpdateScriptNoRef() {\n+    Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n+    map.updateGlobalVarReferences(scriptMap, scriptRoot);\n+    ReferenceCollection refs = map.getReferences(globalScope.getVar(VAR2));\n+    assertEquals(var2Refs.references, refs.references);\n+    refs = map.getReferences(globalScope.getVar(VAR1));\n+    assertEquals(2, refs.references.size());\n+    assertEquals(var1Refs.references.get(0), refs.references.get(0));\n+    assertEquals(var1Refs.references.get(2), refs.references.get(1));\n+  }\n+\n+  /** Changes variable references in second script. */\n+  public void testUpdateGlobalVarReferences_UpdateScriptNewRefs() {\n+    Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n+    ReferenceCollection newVar1Refs = new ReferenceCollection();\n+    Reference newVar1In2Ref = createRefForTest(INPUT2.getName());\n+    newVar1Refs.references = Lists.newArrayList(newVar1In2Ref);\n+    ReferenceCollection newVar2Refs = new ReferenceCollection();\n+    Reference newVar2In2Ref = createRefForTest(INPUT2.getName());\n+    newVar2Refs.references = Lists.newArrayList(newVar2In2Ref);\n+    scriptMap.put(globalScope.getVar(VAR1), newVar1Refs);\n+    scriptMap.put(globalScope.getVar(VAR2), newVar2Refs);\n+    map.updateGlobalVarReferences(scriptMap, scriptRoot);\n+    ReferenceCollection refs = map.getReferences(globalScope.getVar(VAR1));\n+    assertEquals(3, refs.references.size());\n+    assertEquals(var1Refs.references.get(0), refs.references.get(0));\n+    assertEquals(newVar1In2Ref, refs.references.get(1));\n+    assertEquals(var1Refs.references.get(2), refs.references.get(2));\n+    refs = map.getReferences(globalScope.getVar(VAR2));\n+    assertEquals(3, refs.references.size());\n+    assertEquals(var2Refs.references.get(0), refs.references.get(0));\n+    assertEquals(newVar2In2Ref, refs.references.get(1));\n+    assertEquals(var2Refs.references.get(1), refs.references.get(2));\n+  }\n+\n+  /** Changes variable references in second script. */\n+  public void testUpdateGlobalVarReferences_UpdateScriptNewVar() {\n+    Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n+    final String var3 = \"var3\";\n+    globalScope.declare(var3, new Node(Token.NAME), null, INPUT2);\n+    ReferenceCollection newVar3Refs = new ReferenceCollection();\n+    Reference newVar3In2Ref = createRefForTest(INPUT2.getName());\n+    newVar3Refs.references = Lists.newArrayList(newVar3In2Ref);\n+    scriptMap.put(globalScope.getVar(var3), newVar3Refs);\n+    map.updateGlobalVarReferences(scriptMap, scriptRoot);\n+    ReferenceCollection refs = map.getReferences(globalScope.getVar(var3));\n+    assertEquals(1, refs.references.size());\n+    assertEquals(newVar3In2Ref, refs.references.get(0));\n+  }\n+\n+}", "timestamp": 1306858793, "metainfo": ""}