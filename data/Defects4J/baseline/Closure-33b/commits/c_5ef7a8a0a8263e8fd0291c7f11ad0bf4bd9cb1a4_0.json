{"sha": "5ef7a8a0a8263e8fd0291c7f11ad0bf4bd9cb1a4", "log": "First class support for AMD[1] and Common JS[2] modules in closure compiler.  The AMD specific pass, compiles AMD modules to CJS modules. The CJS pass turns the modules into a form that can be concatenated without the need to enclose the code in an immediate function to protect the scope. This makes applying our optimizations significantly more effective.  Attempts to set up correct requires and provides for each module and to order modules correctly. This part of my CL needs some help. I'm having trouble understanding the original design and feel that what I wrote looks sub-optimal.  I did integration testing by compiling the dojo library which uses AMD. Size reduction looks good and cross module code motion as well as dead code elimination works. [1] https://github.com/amdjs/amdjs-api/wiki/AMD [2] http://wiki.commonjs.org/wiki/Modules/1.1.1  R=johnlenz,nicksantos DELTA=1113  (1109 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3981   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     }\n \n     options.acceptConstKeyword = config.acceptConstKeyword;\n+    options.transformAMDToCJSModules = config.transformAMDToCJSModules;\n+    options.processCommonJSModules = config.processCommonJSModules;\n+    options.commonJSModulePathPrefix = config.commonJSModulePathPrefix;\n   }\n \n   final protected A getCompiler() {\n       return this;\n     }\n \n+\n+    private boolean transformAMDToCJSModules = false;\n+\n+    /**\n+     * Set whether to transform AMD to Common JS modules.\n+     */\n+    CommandLineConfig setTransformAMDToCJSModules(boolean transformAMDToCJSModules) {\n+      this.transformAMDToCJSModules = transformAMDToCJSModules;\n+      return this;\n+    }\n+\n+    private boolean processCommonJSModules = false;\n+\n+    /**\n+     * Sets whether to process Common JS modules.\n+     */\n+    CommandLineConfig setProcessCommonJSModules(boolean processCommonJSModules) {\n+      this.processCommonJSModules = processCommonJSModules;\n+      return this;\n+    }\n+\n+\n+    private String commonJSModulePathPrefix =\n+        ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n+\n+    /**\n+     * Sets the Common JS module path prefix.\n+     */\n+    CommandLineConfig setCommonJSModulePathPrefix(String commonJSModulePathPrefix) {\n+      this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n+      return this;\n+    }\n+\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n     private List<FormattingOption> formatting = Lists.newArrayList();\n \n+    @Option(name = \"--process_common_js_modules\",\n+        usage = \"Process Common JS modules to a concatenable form.\")\n+    private boolean process_common_js_modules = false;\n+\n+    @Option(name = \"--common_js_module_path_prefix\",\n+        usage = \"Path prefix to be removed from Common JS module names.\")\n+    private String common_js_path_prefix =\n+        ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n+\n+    @Option(name = \"--common_js_entry_module\",\n+        usage = \"Root of your common JS dependency hierarchy. \"+\n+            \"Your main script.\")\n+    private String common_js_entry_module;\n+\n+    @Option(name = \"--transform_amd_modules\",\n+        usage = \"Transform AMD to Common JS modules.\")\n+    private boolean transform_amd_modules = false;\n+\n     @Option(name = \"--process_closure_primitives\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Processes built-ins from the Closure library, such as \"\n           \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n           \"Built on: \" + config.getString(\"compiler.date\"));\n       err.flush();\n+    }\n+\n+    if (flags.process_common_js_modules) {\n+      flags.process_closure_primitives = true;\n+      flags.manage_closure_dependencies = true;\n+      if (flags.common_js_entry_module == null) {\n+        err.println(\"Please specify --common_js_entry_module.\");\n+        err.flush();\n+        isConfigValid = false;\n+      }\n+      flags.closure_entry_point = Lists.newArrayList(\n+          ProcessCommonJSModules.toModuleName(flags.common_js_entry_module));\n     }\n \n     if (!isConfigValid || flags.display_help) {\n           .setClosureEntryPoints(flags.closure_entry_point)\n           .setOutputManifest(ImmutableList.of(flags.output_manifest))\n           .setAcceptConstKeyword(flags.accept_const_keyword)\n-          .setLanguageIn(flags.language_in);\n+          .setLanguageIn(flags.language_in)\n+          .setProcessCommonJSModules(flags.process_common_js_modules)\n+          .setCommonJSModulePathPrefix(flags.common_js_path_prefix)\n+          .setTransformAMDToCJSModules(flags.transform_amd_modules);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n+import com.google.common.base.Throwables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n         externsRoot.addChildToBack(n);\n       }\n \n+      // Modules inferred in ProcessCommonJS pass.\n+      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n+        processAMDAndCommonJSModules();\n+      }\n+\n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n       return externAndJsRoot;\n     } finally {\n       stopTracer(tracer, \"parseInputs\");\n+    }\n+  }\n+\n+  /**\n+   * Transforms AMD and CJS modules to something closure compiler can\n+   * process and creates JSModules and the corresponding dependency tree\n+   * on the way.\n+   */\n+  private void processAMDAndCommonJSModules() {\n+    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n+    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n+    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n+    // with multiple ways to express dependencies. Directly support JSModules\n+    // that are equivalent to a signal file and which express their deps\n+    // directly in the source.\n+    for (CompilerInput input : inputs) {\n+      input.setCompiler(this);\n+      Node root = input.getAstRoot(this);\n+      if (root == null) {\n+        continue;\n+      }\n+      if (options.transformAMDToCJSModules) {\n+        new TransformAMDToCJSModule(this).process(null, root);\n+      }\n+      if (options.processCommonJSModules) {\n+        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n+            options.commonJSModulePathPrefix);\n+        cjs.process(null, root);\n+        JSModule m = cjs.getModule();\n+        if (m != null) {\n+          modulesByName.put(m.getName(), m);\n+          modulesByInput.put(input, m);\n+        }\n+      }\n+    }\n+    if (options.processCommonJSModules) {\n+      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n+      if (!modules.isEmpty()) {\n+        this.modules = modules;\n+        this.moduleGraph = new JSModuleGraph(this.modules);\n+      }\n+      for (JSModule module : modules) {\n+        for (CompilerInput input : module.getInputs()) {\n+          for (String require : input.getRequires()) {\n+            module.addDependency(modulesByName.get(require));\n+          }\n+        }\n+      }\n+      try {\n+        modules = Lists.newArrayList();\n+        for (CompilerInput input : this.moduleGraph.manageDependencies(\n+            options.dependencyOptions, inputs)) {\n+          modules.add(modulesByInput.get(input));\n+        }\n+        this.modules = modules;\n+        this.moduleGraph = new JSModuleGraph(modules);\n+      } catch (Exception e) {\n+        Throwables.propagate(e);\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n     }\n   }\n \n+  // TODO(nicksantos): Remove addProvide/addRequire/removeRequire once\n+  // there is better support for discovering non-closure dependencies.\n+  void addProvide(String provide) {\n+    getProvides();\n+    provides.add(provide);\n+  }\n+\n+  void addRequire(String require) {\n+    getRequires();\n+    requires.add(require);\n+  }\n+\n+  public void removeRequire(String require) {\n+    getRequires();\n+    requires.remove(require);\n+  }\n+\n   /**\n    * Regenerates the provides/requires if we need to do so.\n    */\n     this.module = module;\n   }\n \n+  /** Overrides the module to which the input belongs. */\n+  void overrideModule(JSModule module) {\n+    this.module = module;\n+  }\n+\n   public boolean isExtern() {\n     if (ast == null || ast.getSourceFile() == null) {\n       return false;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** List of properties that we report invalidation errors for. */\n   Map<String, CheckLevel> propertyInvalidationErrors;\n+\n+  /** Transform AMD to Common JS modules. */\n+  boolean transformAMDToCJSModules = false;\n+\n+  /** Transform AMD to Common JS modules. */\n+  boolean processCommonJSModules = false;\n+\n+  /** Common JS module prefix. */\n+  String commonJSModulePathPrefix =\n+      ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n \n \n   //--------------------------------\n     this.sourceMapLocationMappings = sourceMapLocationMappings;\n   }\n \n+  /**\n+   * Activates transformation of AMD to CJS modules.\n+   */\n+  public void setTransformAMDToCJSModules(boolean transformAMDToCJSModules) {\n+    this.transformAMDToCJSModules = transformAMDToCJSModules;\n+  }\n+\n+  /**\n+   * Activates Common JS module processing.\n+   */\n+  public void setProcessCommonJSModules(boolean processCommonJSModules) {\n+    this.processCommonJSModules = processCommonJSModules;\n+  }\n+\n+  /**\n+   * Sets a path prefix for Common JS modules.\n+   */\n+  public void setCommonJSModulePathPrefix(String commonJSModulePathPrefix) {\n+    this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n+  }\n+\n+\n   //////////////////////////////////////////////////////////////////////////////\n   // Enums\n \n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n     input.setModule(this);\n   }\n \n+  /**\n+   * Adds a source code input to this module. Call only if the input might\n+   * already be associated with a module. Otherwise use\n+   * add(CompilerInput input).\n+   */\n+  void addAndOverrideModule(CompilerInput input) {\n+    inputs.add(input);\n+    input.overrideModule(this);\n+  }\n+\n   /** Adds a source code input to this module. */\n   public void addFirst(CompilerInput input) {\n     inputs.add(0, input);\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Rewrites a Common JS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n+ * into a form that can be safely concatenated.\n+ * Does not add a function around the module body but instead adds suffixes\n+ * to global variables to avoid conflicts.\n+ * Calls to require are changed to reference the required module directly.\n+ * goog.provide and goog.require are emitted for closure compiler automatic\n+ * ordering.\n+ */\n+class ProcessCommonJSModules implements CompilerPass {\n+\n+  public static final String  DEFAULT_FILENAME_PREFIX = \"./\";\n+\n+  private static final String MODULE_NAME_PREFIX = \"module$\";\n+\n+  private final AbstractCompiler compiler;\n+  private final String filenamePrefix;\n+  private final boolean reportDependencies;\n+  private JSModule module;\n+\n+  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix) {\n+    this.compiler = compiler;\n+    this.filenamePrefix = filenamePrefix;\n+    this.reportDependencies = true;\n+  }\n+\n+  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix,\n+      boolean reportDependencies) {\n+    this.compiler = compiler;\n+    this.filenamePrefix = filenamePrefix;\n+    this.reportDependencies = reportDependencies;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal\n+        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n+  }\n+\n+  private String guessCJSModuleName(String filename) {\n+    return toModuleName(normalizeSourceName(filename));\n+  }\n+\n+  /**\n+   * For every file that is being processed this returns the module that\n+   * created for it.\n+   */\n+  JSModule getModule() {\n+    return module;\n+  }\n+\n+  /**\n+   * Turns a filename into a JS identifier that is used for moduleNames in\n+   * rewritten code. Removes leading ./, replaces / with $, removes trailing .js\n+   * and replaces - with _. All moduleNames get a \"module$\" prefix.\n+   */\n+  public static String toModuleName(String filename) {\n+    return MODULE_NAME_PREFIX +\n+        filename.replaceAll(\"^\\\\./\", \"\").replaceAll(\"/\", \"\\\\$\")\n+            .replaceAll(\"\\\\.js$\", \"\").replaceAll(\"-\", \"_\");\n+  }\n+\n+  /**\n+   * Turn a filename into a moduleName with support for relative addressing\n+   * with ./ and ../ based on currentFilename;\n+   */\n+  public static String toModuleName(String requiredFilename,\n+      String currentFilename) {\n+    requiredFilename = requiredFilename.replaceAll(\"\\\\.js$\", \"\");\n+    currentFilename = currentFilename.replaceAll(\"\\\\.js$\", \"\");\n+\n+    if (requiredFilename.startsWith(\"./\") ||\n+        requiredFilename.startsWith(\"../\")) {\n+      try {\n+        requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename))\n+            .toString();\n+      } catch (URISyntaxException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return toModuleName(requiredFilename);\n+  }\n+\n+  private String normalizeSourceName(String filename) {\n+    if (filename.indexOf(filenamePrefix) == 0) {\n+      filename = filename.substring(filenamePrefix.length());\n+    }\n+    return filename;\n+  }\n+\n+  /**\n+   * Visits require, every \"script\" and special module.exports assignments.\n+   */\n+  private class ProcessCommonJsModulesCallback extends\n+      AbstractPostOrderCallback {\n+\n+    private int scriptNodeCount = 0;\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isCall() && n.getChildCount() == 2 &&\n+          \"require\".equals(n.getFirstChild().getQualifiedName()) &&\n+          n.getChildAtIndex(1).isString()) {\n+        visitRequireCall(t, n, parent);\n+      }\n+\n+      if (n.isScript()) {\n+        scriptNodeCount++;\n+        visitScript(t, n);\n+      }\n+\n+      if (n.isGetProp() &&\n+          \"module.exports\".equals(n.getQualifiedName())) {\n+        visitModuleExports(n);\n+      }\n+    }\n+\n+    /**\n+     * Visit require calls. Emit corresponding goog.require and rewrite require\n+     * to be a direct reference to name of require module.\n+     */\n+    private void visitRequireCall(NodeTraversal t, Node require, Node parent) {\n+      String moduleName = toModuleName(require.getChildAtIndex(1).getString(),\n+          normalizeSourceName(t.getSourceName()));\n+      Node moduleRef = IR.name(moduleName).srcref(require);\n+      parent.replaceChild(require, moduleRef);\n+      Node script = getCurrentScriptNode(parent);\n+      if (reportDependencies) {\n+        t.getInput().addRequire(moduleName);\n+      }\n+      // Rewrite require(\"name\").\n+      script.addChildToFront(IR.exprResult(\n+          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"require\")),\n+              IR.string(moduleName))).copyInformationFromForTree(require));\n+      compiler.reportCodeChange();\n+    }\n+\n+    /**\n+     * Emit goog.provide and add suffix to all global vars to avoid conflicts\n+     * with other modules.\n+     */\n+    private void visitScript(NodeTraversal t, Node script) {\n+      Preconditions.checkArgument(scriptNodeCount == 1,\n+          \"ProcessCommonJSModules supports only one invocation per \" +\n+          \"CompilerInput / script node\");\n+      String moduleName = guessCJSModuleName(normalizeSourceName(script\n+          .getSourceFileName()));\n+      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n+          .copyInformationFromForTree(script));\n+      if (reportDependencies) {\n+        CompilerInput ci = t.getInput();\n+        ci.addProvide(moduleName);\n+        JSModule m = new JSModule(moduleName);\n+        m.addAndOverrideModule(ci);\n+        module = m;\n+      }\n+      script.addChildToFront(IR.exprResult(\n+          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n+              IR.string(moduleName))).copyInformationFromForTree(script));\n+\n+      emitOptionalModuleExportsOverride(script, moduleName);\n+\n+      // Rename vars to not conflict in global scope.\n+      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n+          moduleName));\n+\n+      compiler.reportCodeChange();\n+    }\n+\n+    /**\n+     * Emit <code>if (moduleName.module$exports) {\n+     *    moduleName = moduleName.module$export;\n+     * }</code> at end of file.\n+     */\n+    private void emitOptionalModuleExportsOverride(Node script,\n+        String moduleName) {\n+      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n+          IR.string(\"module$exports\"));\n+      script.addChildToBack(IR.ifNode(\n+          moduleExportsProp,\n+          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n+              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n+          script));\n+    }\n+\n+    /**\n+     * Rewrite module.exports to moduleName.module$exports.\n+     */\n+    private void visitModuleExports(Node prop) {\n+      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n+      Node module = prop.getChildAtIndex(0);\n+      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n+      module.setString(moduleName);\n+      Node exports = prop.getChildAtIndex(1);\n+      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n+      exports.setString(\"module$exports\");\n+    }\n+\n+    /**\n+     * Returns next script node in parents.\n+     */\n+    private Node getCurrentScriptNode(Node n) {\n+      while (true) {\n+        if (n.isScript()) {\n+          return n;\n+        }\n+        n = n.getParent();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Traverses a node tree and appends a suffix to all global variable names.\n+   */\n+  private class SuffixVarsCallback extends AbstractPostOrderCallback {\n+\n+    private static final String EXPORTS = \"exports\";\n+\n+    private final String suffix;\n+\n+    public SuffixVarsCallback(String suffix) {\n+      this.suffix = suffix;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isName()) {\n+        String name = n.getString();\n+        if (suffix.equals(name)) {\n+          return;\n+        }\n+        if (EXPORTS.equals(name)) {\n+          n.setString(suffix);\n+          n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);\n+        } else {\n+          Scope.Var var = t.getScope().getVar(name);\n+          if (var != null && var.isGlobal()) {\n+            n.setString(name + \"$$\" + suffix);\n+            n.putProp(Node.ORIGINALNAME_PROP, name);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import java.util.Iterator;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Iterators;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Rewrites an AMD module https://github.com/amdjs/amdjs-api/wiki/AMD to a\n+ * Common JS module. See {@link ProcessCommonJSModule} for follow up processing\n+ * step.\n+ */\n+class TransformAMDToCJSModule implements CompilerPass {\n+\n+  @VisibleForTesting\n+  final static DiagnosticType UNSUPPORTED_DEFINE_SIGNATURE_ERROR =\n+      DiagnosticType.error(\n+          \"UNSUPPORTED_DEFINE_SIGNATURE\",\n+          \"Only define(function() ...), define(OBJECT_LITERAL) and define(\"\n+              + \"['dep', 'dep1'], function(d0, d2, [exports, module]) ...) forms \"\n+              + \"are currently supported.\");\n+  final static DiagnosticType NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR =\n+      DiagnosticType.error(\n+            \"NON_TOP_LEVEL_STATEMENT_DEFINE\",\n+            \"The define function must be called as a top level statement.\");\n+  final static DiagnosticType REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING =\n+    DiagnosticType.warning(\n+          \"REQUIREJS_PLUGINS_NOT_SUPPORTED\",\n+          \"Plugins in define requirements are not supported: {0}\");\n+\n+  final static String VAR_RENAME_SUFFIX = \"__alias\";\n+\n+\n+  private final AbstractCompiler compiler;\n+  private int renameIndex = 0;\n+\n+  TransformAMDToCJSModule(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new TransformAMDModulesCallback());\n+  }\n+\n+  private void unsupportedDefineError(NodeTraversal t, Node n) {\n+    t.report(n, UNSUPPORTED_DEFINE_SIGNATURE_ERROR);\n+  }\n+\n+  /**\n+   * The modules \"exports\", \"require\" and \"module\" are virtual in terms of\n+   * existing implicitly in CJS.\n+   */\n+  private boolean isVirtualModuleName(String moduleName) {\n+    return \"exports\".equals(moduleName) || \"require\".equals(moduleName) ||\n+        \"module\".equals(moduleName);\n+  }\n+\n+  /**\n+   * Rewrites calls to define which has to be in void context just below the\n+   * current script node.\n+   */\n+  private class TransformAMDModulesCallback extends AbstractPostOrderCallback {\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isCall() && n.getFirstChild() != null &&\n+          n.getFirstChild().isName() &&\n+          \"define\".equals(n.getFirstChild().getString())) {\n+        Scope.Var define = t.getScope().getVar(n.getFirstChild().\n+            getString());\n+        if (define != null && !define.isGlobal()) {\n+          // Ignore non-global define.\n+          return;\n+        }\n+        if (!(parent.isExprResult() && parent.getParent().isScript())) {\n+          t.report(n, NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR);\n+          return;\n+        }\n+        Node script = parent.getParent();\n+        Node requiresNode = null;\n+        Node callback = null;\n+        int defineArity = n.getChildCount() - 1;\n+        if (defineArity == 0) {\n+          unsupportedDefineError(t, n);\n+          return;\n+        } else if (defineArity == 1) {\n+          callback = n.getChildAtIndex(1);\n+          if (callback.isObjectLit()) {\n+            handleDefineObjectLiteral(parent, callback, script);\n+            return;\n+          }\n+        } else if (defineArity == 2) {\n+          requiresNode = n.getChildAtIndex(1);\n+          callback = n.getChildAtIndex(2);\n+        } else if (defineArity >= 3) {\n+          unsupportedDefineError(t, n);\n+          return;\n+        }\n+\n+        if (!callback.isFunction() ||\n+            (requiresNode != null && !requiresNode.isArrayLit())) {\n+          unsupportedDefineError(t, n);\n+          return;\n+        }\n+\n+        handleRequiresAndParamList(t, n, script, requiresNode, callback);\n+\n+        Node callbackBlock = callback.getChildAtIndex(2);\n+        NodeTraversal.traverse(compiler, callbackBlock,\n+            new DefineCallbackReturnCallback());\n+\n+        moveCallbackContentToTopLevel(parent, script, callbackBlock);\n+        compiler.reportCodeChange();\n+      }\n+    }\n+\n+    /**\n+     * When define is called with an object literal, assign it to exports and\n+     * we're done.\n+     */\n+    private void handleDefineObjectLiteral(Node parent, Node onlyExport,\n+        Node script) {\n+      onlyExport.getParent().removeChild(onlyExport);\n+      script.replaceChild(parent,\n+          IR.exprResult(IR.assign(IR.name(\"exports\"), onlyExport))\n+              .copyInformationFromForTree(onlyExport));\n+      compiler.reportCodeChange();\n+    }\n+\n+    /**\n+     * Rewrites the required modules to\n+     * <code>var nameInParamList = require(\"nameFromRequireList\");</code>\n+     */\n+    private void handleRequiresAndParamList(NodeTraversal t, Node defineNode,\n+        Node script, Node requiresNode, Node callback) {\n+      Iterator<Node> paramList = callback.getChildAtIndex(1).children().\n+          iterator();\n+      Iterator<Node> requires = requiresNode != null ?\n+          requiresNode.children().iterator() : Iterators.<Node>emptyIterator();\n+      while (paramList.hasNext() || requires.hasNext()) {\n+        Node aliasNode = paramList.hasNext() ? paramList.next() : null;\n+        Node modNode = requires.hasNext() ? requires.next() : null;\n+        handleRequire(t, defineNode, script, callback, aliasNode, modNode);\n+      }\n+    }\n+\n+    /**\n+     * Rewrite a single require call.\n+     */\n+    private void handleRequire(NodeTraversal t, Node defineNode, Node script,\n+        Node callback, Node aliasNode, Node modNode) {\n+      String moduleName = null;\n+      if (modNode != null) {\n+        moduleName = handlePlugins(t, script, modNode.getString(), modNode);\n+      }\n+\n+      if (isVirtualModuleName(moduleName)) {\n+        return;\n+      }\n+\n+      String aliasName = aliasNode != null ? aliasNode.getString() : null;\n+      Scope globalScope = t.getScope();\n+      if (aliasName != null &&\n+          globalScope.isDeclared(aliasName, true)) {\n+        while (true) {\n+          String renamed = aliasName + VAR_RENAME_SUFFIX + renameIndex;\n+          if (!globalScope.isDeclared(renamed, true)) {\n+            NodeTraversal.traverse(compiler, callback,\n+                new RenameCallback(aliasName, renamed));\n+            aliasName = renamed;\n+            break;\n+          }\n+          renameIndex++;\n+        }\n+      }\n+\n+      Node requireNode;\n+      if (moduleName != null) {\n+        Node call = IR.call(IR.name(\"require\"), IR.string(moduleName));\n+        call.putBooleanProp(Node.FREE_CALL, true);\n+        if (aliasName != null) {\n+          requireNode = IR.var(IR.name(aliasName), call)\n+              .copyInformationFromForTree(aliasNode);\n+        } else {\n+          requireNode = IR.exprResult(call).\n+              copyInformationFromForTree(modNode);\n+        }\n+      } else {\n+        // ignore exports, require and module (because they are implicit\n+        // in CJS);\n+        if (isVirtualModuleName(aliasName)) {\n+          return;\n+        }\n+        requireNode = IR.var(IR.name(aliasName), IR.nullNode())\n+            .copyInformationFromForTree(aliasNode);\n+      }\n+\n+      script.addChildBefore(requireNode,\n+          defineNode.getParent());\n+    }\n+\n+    /**\n+     * Require.js supports a range of plugins that are hard to support\n+     * statically. Generally none are supported right now with the\n+     * exception of a simple hack to support condition loading. This\n+     * was added to make compilation of Dojo work better but will\n+     * probably break, so just don't use them :)\n+     */\n+    private String handlePlugins(NodeTraversal t, Node script,\n+        String moduleName, Node modNode) {\n+      if (moduleName.contains(\"!\")) {\n+        t.report(modNode, REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING, moduleName);\n+        int condition = moduleName.indexOf('?');\n+        if (condition > 0) {\n+          if (moduleName.contains(\":\")) {\n+            return null;\n+          }\n+          return handlePlugins(t, script, moduleName.substring(condition + 1),\n+              modNode);\n+        }\n+        moduleName = null;\n+      }\n+      return moduleName;\n+    }\n+\n+    /**\n+     * Moves the statements in the callback to be direct children of the\n+     * current script.\n+     */\n+    private void moveCallbackContentToTopLevel(Node defineParent, Node script,\n+        Node callbackBlock) {\n+      int curIndex = script.getIndexOfChild(defineParent);\n+      script.removeChild(defineParent);\n+      callbackBlock.getParent().removeChild(callbackBlock);\n+      Node before = script.getChildAtIndex(curIndex);\n+      if (before != null) {\n+        script.addChildBefore(callbackBlock, before);\n+      }\n+      script.addChildToBack(callbackBlock);\n+      NodeUtil.tryMergeBlock(callbackBlock);\n+    }\n+  }\n+\n+  /**\n+   * Rewrites the return statement of the callback to be an assingment to\n+   * module.exports.\n+   */\n+  private class DefineCallbackReturnCallback extends\n+      NodeTraversal.AbstractShallowStatementCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isReturn() && n.hasChildren()) {\n+        Node retVal = n.getFirstChild();\n+        n.removeChild(retVal);\n+        parent.replaceChild(n, IR.exprResult(\n+            IR.assign(\n+                IR.getprop(IR.name(\"module\"), IR.string(\"exports\")), retVal))\n+                    .useSourceInfoFromForTree(n));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Renames names;\n+   */\n+  private class RenameCallback extends AbstractPostOrderCallback {\n+\n+    private final String from;\n+    private final String to;\n+\n+    public RenameCallback(String from, String to) {\n+      this.from = from;\n+      this.to = to;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isName() && from.equals(n.getString())) {\n+        n.setString(to);\n+        n.putProp(Node.ORIGINALNAME_PROP, from);\n+      }\n+    }\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n import com.google.common.base.Suppliers;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.AbstractCommandLineRunner.FlagUsageException;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import java.io.IOException;\n import java.io.PrintStream;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Tests for {@link CommandLineRunner}.\n   private List<Integer> exitCodes = null;\n   private ByteArrayOutputStream outReader = null;\n   private ByteArrayOutputStream errReader = null;\n+  private Map<Integer,String> filenames;\n \n   // If set, this will be appended to the end of the args list.\n   // For testing args parsing.\n   public void setUp() throws Exception {\n     super.setUp();\n     externs = DEFAULT_EXTERNS;\n+    filenames = Maps.newHashMap();\n     lastCompiler = null;\n     lastArg = null;\n     outReader = new ByteArrayOutputStream();\n       \"Manifest files cannot be generated when the input is from stdin.\");\n   }\n \n+  public void testTransformAMD() {\n+    args.add(\"--transform_amd_modules\");\n+    test(\"define({test: 1})\", \"exports = {test: 1}\");\n+  }\n+\n+  public void testProcessCJS() {\n+    args.add(\"--process_common_js_modules\");\n+    args.add(\"--common_js_entry_module=foo/bar\");\n+    setFilename(0, \"foo/bar.js\");\n+    test(\"exports.test = 1\",\n+        \"var module$foo$bar={test:1}; \" +\n+        \"module$foo$bar.module$exports && \" +\n+        \"(module$foo$bar=module$foo$bar.module$exports)\");\n+  }\n+\n+  public void testTransformAMDAndProcessCJS() {\n+    args.add(\"--transform_amd_modules\");\n+    args.add(\"--process_common_js_modules\");\n+    args.add(\"--common_js_entry_module=foo/bar\");\n+    setFilename(0, \"foo/bar.js\");\n+    test(\"define({foo: 1})\",\n+        \"var module$foo$bar={}, module$foo$bar={foo:1}; \" +\n+        \"module$foo$bar.module$exports && \" +\n+        \"(module$foo$bar=module$foo$bar.module$exports)\");\n+  }\n+\n   /* Helper functions */\n \n   private void testSame(String original) {\n     if (useModules == ModulePattern.NONE) {\n       List<JSSourceFile> inputs = Lists.newArrayList();\n       for (int i = 0; i < original.length; i++) {\n-        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n+        inputs.add(JSSourceFile.fromCode(getFilename(i), original[i]));\n       }\n       inputsSupplier = Suppliers.ofInstance(inputs);\n     } else if (useModules == ModulePattern.STAR) {\n     Compiler compiler = runner.createCompiler();\n     List<JSSourceFile> inputs = Lists.newArrayList();\n     for (int i = 0; i < original.length; i++) {\n-      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n+      inputs.add(JSSourceFile.fromCode(getFilename(i), original[i]));\n     }\n     CompilerOptions options = new CompilerOptions();\n     // ECMASCRIPT5 is the most forgiving.\n     Node n = all.getLastChild();\n     return n;\n   }\n+\n+  private void setFilename(int i, String filename) {\n+    this.filenames.put(i, filename);\n+  }\n+\n+  private String getFilename(int i) {\n+    if (filenames.isEmpty()) {\n+      return \"input\" + i;\n+    }\n+    return filenames.get(i);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n \n package com.google.javascript.jscomp;\n \n+import java.util.List;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n+import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n         \"(function (undefined) { alert(undefined); })();\");\n     compiler.compile(externs, input, options);\n   }\n+\n+  public void testCommonJSProvidesAndRequire() throws\n+      CircularDependencyException, MissingProvideException {\n+    JSSourceFile[] inputs = {\n+        JSSourceFile.fromCode(\"gin.js\", \"require('tonic')\"),\n+        JSSourceFile.fromCode(\"tonic.js\", \"\"),\n+        JSSourceFile.fromCode(\"mix.js\", \"require('gin'); require('tonic');\")};\n+    CompilerOptions options = new CompilerOptions();\n+    options.ideMode = true;\n+    List<String> entryPoints = Lists.newArrayList(\"module$mix\");\n+    options.setManageClosureDependencies(entryPoints);\n+    options.closurePass = true;\n+    options.processCommonJSModules = true;\n+    Compiler compiler = new Compiler();\n+    compiler.init(new JSSourceFile[0], inputs, options);\n+    compiler.parseInputs();\n+    JSModuleGraph graph = compiler.getModuleGraph();\n+    assertEquals(graph.getModuleCount(), 3);\n+    List<CompilerInput> result = graph.manageDependencies(entryPoints,\n+        compiler.getInputsForTesting());\n+    assertEquals(\"tonic.js\", result.get(0).getName());\n+    assertEquals(\"gin.js\", result.get(1).getName());\n+    assertEquals(\"mix.js\", result.get(2).getName());\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n    */\n   private boolean astValidationEnabled = true;\n \n+  private String filename = \"testcode\";\n+\n   /**\n    * Constructs a test.\n    *\n     return new GoogleCodingConvention();\n   }\n \n+  public void setFilename(String filename) {\n+    this.filename = filename;\n+  }\n+\n   /**\n    * Returns the number of times the pass should be run before results are\n    * verified.\n     // actually cause the type check to run.\n     options.checkTypes = parseTypeInfo;\n     compiler.init(externs, new JSSourceFile[] {\n-        JSSourceFile.fromCode(\"testcode\", js) }, options);\n+        JSSourceFile.fromCode(filename, js) }, options);\n \n     BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry());\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link ProcessCommonJSModules}\n+ */\n+public class ProcessCommonJSModulesTest extends CompilerTestCase {\n+\n+  public ProcessCommonJSModulesTest() {\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new ProcessCommonJSModules(compiler, \"foo/bar/\", false);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void testWithoutExports() {\n+    setFilename(\"test\");\n+    test(\n+        \"var name = require('name');\" +\n+        \"name()\",\n+        \"goog.provide('module$test');\" +\n+        \"var module$test = {};\" +\n+        \"goog.require('module$name');\" +\n+        \"var name$$module$test = module$name;\" +\n+        \"name$$module$test();\" +\n+        \"if(module$test.module$exports)\" +\n+        \"module$test=module$test.module$exports\");\n+    setFilename(\"test/sub\");\n+    test(\n+        \"var name = require('mod/name');\" +\n+        \"(function() { name(); })();\",\n+        \"goog.provide('module$test$sub');\" +\n+        \"var module$test$sub = {};\" +\n+        \"goog.require('module$mod$name');\" +\n+        \"var name$$module$test$sub = module$mod$name;\" +\n+        \"(function() { name$$module$test$sub(); })();\" +\n+        \"if(module$test$sub.module$exports)\" +\n+        \"module$test$sub=module$test$sub.module$exports\");\n+  }\n+\n+  public void testExports() {\n+    setFilename(\"test\");\n+    test(\n+        \"var name = require('name');\" +\n+        \"exports.foo = 1;\",\n+        \"goog.provide('module$test');\" +\n+        \"var module$test = {};\" +\n+        \"goog.require('module$name');\" +\n+        \"var name$$module$test = module$name;\" +\n+        \"module$test.foo = 1;\" +\n+        \"if(module$test.module$exports)\" +\n+        \"module$test=module$test.module$exports\");\n+    test(\n+        \"var name = require('name');\" +\n+        \"module.exports = function() {};\",\n+        \"goog.provide('module$test');\" +\n+        \"var module$test = {};\" +\n+        \"goog.require('module$name');\" +\n+        \"var name$$module$test = module$name;\" +\n+        \"module$test.module$exports = function() {};\" +\n+        \"if(module$test.module$exports)\" +\n+        \"module$test=module$test.module$exports\");\n+  }\n+\n+  public void testVarRenaming() {\n+    setFilename(\"test\");\n+    test(\n+        \"var a = 1, b = 2;\" +\n+        \"(function() { var a; b = 4})()\",\n+        \"goog.provide('module$test');\" +\n+        \"var module$test = {};\" +\n+        \"var a$$module$test = 1, b$$module$test = 2;\" +\n+        \"(function() { var a; b$$module$test = 4})();\" +\n+        \"if(module$test.module$exports)\" +\n+        \"module$test=module$test.module$exports\");\n+  }\n+\n+  public void testDash() {\n+    setFilename(\"test-test\");\n+    test(\n+        \"var name = require('name'); exports.foo = 1;\",\n+        \"goog.provide('module$test_test');\" +\n+        \"var module$test_test = {};\" +\n+        \"goog.require('module$name');\" +\n+        \"var name$$module$test_test = module$name;\" +\n+        \"module$test_test.foo = 1;\" +\n+        \"if(module$test_test.module$exports)\" +\n+        \"module$test_test=module$test_test.module$exports\");\n+  }\n+\n+  public void testModuleName() {\n+    assertEquals(\"module$foo$baz\",\n+        ProcessCommonJSModules.toModuleName(\"./baz.js\", \"foo/bar.js\"));\n+    assertEquals(\"module$foo$baz_bar\",\n+        ProcessCommonJSModules.toModuleName(\"./baz-bar.js\", \"foo/bar.js\"));\n+    assertEquals(\"module$baz\",\n+        ProcessCommonJSModules.toModuleName(\"../baz.js\", \"foo/bar.js\"));\n+    assertEquals(\"module$baz\",\n+        ProcessCommonJSModules.toModuleName(\"../../baz.js\", \"foo/bar/abc.js\"));\n+    assertEquals(\"module$baz\", ProcessCommonJSModules.toModuleName(\n+        \"../../../baz.js\", \"foo/bar/abc/xyz.js\"));\n+    setFilename(\"foo/bar\");\n+    test(\n+        \"var name = require('name');\",\n+        \"goog.provide('module$foo$bar'); var module$foo$bar = {};\" +\n+        \"goog.require('module$name');\" +\n+        \"var name$$module$foo$bar = module$name;\" +\n+        \"if(module$foo$bar.module$exports)\" +\n+        \"module$foo$bar=module$foo$bar.module$exports\");\n+    test(\n+        \"var name = require('./name');\",\n+        \"goog.provide('module$foo$bar');\" +\n+        \"var module$foo$bar = {};\" +\n+        \"goog.require('module$foo$name');\" +\n+        \"var name$$module$foo$bar = module$foo$name;\" +\n+        \"if(module$foo$bar.module$exports)\" +\n+        \"module$foo$bar=module$foo$bar.module$exports\");\n+\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/TransformAMDToCJSModuleTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link TransformAMDToCJSModules}\n+ */\n+public class TransformAMDToCJSModuleTest extends CompilerTestCase {\n+\n+  @Override protected CompilerPass getProcessor(Compiler compiler) {\n+    return new TransformAMDToCJSModule(compiler);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void testDefine() {\n+    test(\"define(['foo', 'bar'], function(foo, bar) { foo(bar); bar+1; })\",\n+        \"var foo=require('foo'); var bar=require('bar');foo(bar);bar+1\");\n+    test(\"define(['foo', 'bar'], function(foo, bar, baz) { foo(bar); bar+1; })\",\n+        \"var foo=require('foo'); var bar=require('bar');\" +\n+        \"var baz = null;foo(bar);bar+1\");\n+    test(\"define(['foo', 'bar'], function(foo, bar) { return { test: 1 } })\",\n+        \"var foo=require('foo'); var bar=require('bar');\" +\n+        \"module.exports={test:1}\");\n+    test(\"define(['foo', 'bar'], function(foo, bar, exports) { \" +\n+        \"return { test: 1 } })\",\n+        \"var foo=require('foo'); var bar=require('bar');\" +\n+        \"module.exports={test:1}\");\n+    test(\"define(['foo', 'bar'], function(foo, bar, exports, module) { \" +\n+        \"return { test: 1 } })\",\n+        \"var foo=require('foo'); var bar=require('bar');\" +\n+        \"module.exports={test:1}\");\n+    test(\"define(['foo', 'bar'], function(foo, bar, exports, module, baz) { \" +\n+        \"return { test: 1 } })\",\n+        \"var foo=require('foo'); var bar=require('bar');var baz = null;\" +\n+        \"module.exports={test:1}\");\n+    test(\"define(['foo', 'bar'], function(foo) { return { test: 1 } })\",\n+        \"var foo=require('foo'); require('bar'); module.exports={test:1}\");\n+    test(\"define(['foo', 'bar'], function(test) { return { test: 1 } })\",\n+        \"var test=require('foo'); require('bar'); module.exports={test:1}\");\n+  }\n+\n+  public void testVarRenaming() {\n+    final String suffix = TransformAMDToCJSModule.VAR_RENAME_SUFFIX;\n+    test(\"var foo; define(['foo', 'bar'], function(foo, bar) { \" +\n+        \"foo(bar); bar+1; })\",\n+        \"var foo; var foo\" + suffix +\"0=require('foo');\" +\n+        \"var bar=require('bar');foo\" + suffix +\"0(bar);bar+1\");\n+    test(\"function foo() {}; define(['foo', 'bar'], \" +\n+        \"function(foo, bar) { foo(bar); bar+1; })\",\n+        \"function foo() {}; var foo\" + suffix +\"0=require('foo'); \" +\n+        \"var bar=require('bar');foo\" + suffix +\"0(bar);bar+1\");\n+  }\n+\n+  public void testDefineOnlyFunction() {\n+    test(\"define(function() { return { test: 1 } })\",\n+        \"module.exports={test:1}\");\n+    test(\"define(function(exports, module) { return { test: 1 } })\",\n+        \"module.exports={test:1}\");\n+  }\n+\n+  public void testObjectLit() {\n+    test(\"define({foo: 'bar'})\", \"exports={foo: 'bar'}\");\n+  }\n+\n+  public void testPlugins() {\n+    test(\"define(['foo', 'text!foo'], function(foo, text) {})\",\n+        \"var foo = require('foo'); var text = null;\",\n+        null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING);\n+    test(\"define(['foo', 'text!foo?bar'], function(foo, bar) {})\",\n+        \"var foo = require('foo'); var bar = require('bar'); \",\n+        null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING);\n+    test(\"define(['foo', 'text!foo?:bar'], function(foo, bar) {})\",\n+        \"var foo = require('foo'); var bar = null;\",\n+        null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING);\n+  }\n+\n+  public void testUnsupportedForms() {\n+    testUnsupported(\"define()\");\n+    testUnsupported(\"define([], function() {}, 1)\");\n+    testUnsupported(\"define({}, function() {})\");\n+    testUnsupported(\"define('test', function() {})\");\n+    testUnsupported(\"define([])\");\n+    testUnsupported(\"define(true)\");\n+    testUnsupported(\"define(1)\");\n+    testNonTopLevelDefine(\"var x = define(function() {});\");\n+    testNonTopLevelDefine(\"if(define(function() {})) {}\");\n+  }\n+\n+  public void testLocalDefine() {\n+    testSame(\"(function() { function define() {}; define({}); })()\");\n+  }\n+\n+  private void testUnsupported(String js) {\n+    test(js, null, TransformAMDToCJSModule.UNSUPPORTED_DEFINE_SIGNATURE_ERROR);\n+  }\n+\n+  private void testNonTopLevelDefine(String js) {\n+    test(js, null,\n+        TransformAMDToCJSModule.NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR);\n+  }\n+\n+}", "timestamp": 1323895939, "metainfo": ""}