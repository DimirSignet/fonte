{"sha": "365110ae2a8c87b2ee2e20fb5fa60e207b40af5c", "log": "As it turns out, symbols cannot be uniquely identified by their declaration node, because sometimes we have two symbols at the same node  R=acleung DELTA=21  (11 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3043   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashBasedTable;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Table;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n \n   /**\n    * All symbols in the program, uniquely identified by the node where\n-   * they're declared.\n-   */\n-  private final Map<Node, Symbol> symbols = Maps.newHashMap();\n+   * they're declared and their name.\n+   */\n+  private final Table<Node, String, Symbol> symbols = HashBasedTable.create();\n \n   /**\n    * All scopes in the program, uniquely identified by the node where\n   <S extends StaticSlot<JSType>, R extends StaticReference<JSType>>\n   void addSymbolsFrom(StaticSymbolTable<S, R> otherSymbolTable) {\n     for (S otherSymbol : otherSymbolTable.getAllSymbols()) {\n+      String name = otherSymbol.getName();\n       SymbolScope myScope = createScopeFrom(\n           otherSymbolTable.getScope(otherSymbol));\n \n       Symbol mySymbol = null;\n       if (declNode != null && declNode.getStaticSourceFile() != null) {\n         // If we have a declaration node, we can ensure the symbol is declared.\n-        mySymbol = symbols.get(declNode);\n+        mySymbol = symbols.get(declNode, name);\n         if (mySymbol == null) {\n           mySymbol = new Symbol(\n-              otherSymbol.getName(),\n+              name,\n               otherSymbol.getType(),\n               otherSymbol.isTypeInferred(),\n               myScope);\n-          symbols.put(declNode, mySymbol);\n-          myScope.ownSymbols.put(mySymbol.getName(), mySymbol);\n+          symbols.put(declNode, name, mySymbol);\n+          myScope.ownSymbols.put(name, mySymbol);\n \n           mySymbol.setDeclaration(new Reference(mySymbol, declNode));\n         }\n         // If we don't have a declaration node, we won't be able to declare\n         // a symbol in this symbol table. But we may be able to salvage the\n         // references if we already have a symbol.\n-        mySymbol = myScope.getOwnSlot(otherSymbol.getName());\n+        mySymbol = myScope.getOwnSlot(name);\n       }\n \n       if (mySymbol != null) {\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(fn, table.getSymbolForScope(scope));\n   }\n \n+  public void testPrototypeSymbol() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function Foo() {}\");\n+    Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n+    assertNotNull(fooPrototype);\n+    assertEquals(1, Iterables.size(table.getReferences(fooPrototype)));\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     for (Symbol symbol : table.getAllSymbols()) {\n       if (symbol.getName().equals(name) &&", "timestamp": 1313555950, "metainfo": ""}