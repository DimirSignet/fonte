{"sha": "2e158bdc1a74af6453d3087a7377ace75e2bcd45", "log": "Fixup local value evaluation.  R=nicksantos DELTA=163  (122 added, 29 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=178   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    *\n    * @param callNode - function call node\n    */\n-  static boolean functionCallHasSideEffects(\n-      Node callNode) {\n+  static boolean functionCallHasSideEffects(Node callNode) {\n     return functionCallHasSideEffects(callNode, null);\n   }\n \n   static boolean callHasLocalResult(Node n) {\n     Preconditions.checkState(n.getType() == Token.CALL);\n     return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n+  }\n+\n+  /**\n+   * @return Whether the new has a local result.\n+   */\n+  static boolean newHasLocalResult(Node n) {\n+    Preconditions.checkState(n.getType() == Token.NEW);\n+    return n.isOnlyModifiesThisCall();\n   }\n \n   /**\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        // TODO(nicksantos): This needs to be changed so that it\n-        // returns true iff we're sure the value was never aliased from inside\n-        // the constructor (similar to callHasLocalResult)\n-        return false;\n+        return newHasLocalResult(value)\n+               || locals.apply(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"undefined\")));\n     assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"void 0\")));\n     assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"void foo()\")));\n-    \n+\n     assertEquals(\"NaN\", NodeUtil.getStringValue(getNode(\"NaN\")));\n     assertEquals(\"Infinity\", NodeUtil.getStringValue(getNode(\"Infinity\")));\n     assertEquals(null, NodeUtil.getStringValue(getNode(\"x\")));\n     assertFalse(testLocalValue(\"o.valueOf()\"));\n   }\n \n+  public void testLocalValue2() {\n+    Node newExpr = getNode(\"new x()\");\n+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    Preconditions.checkState(newExpr.getType() == Token.NEW);\n+    Node.SideEffectFlags flags = new Node.SideEffectFlags();\n+\n+    flags.clearAllFlags();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    flags.clearAllFlags();\n+    flags.setMutatesThis();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    flags.clearAllFlags();\n+    flags.setReturnsTainted();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    flags.clearAllFlags();\n+    flags.setThrows();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    flags.clearAllFlags();\n+    flags.setMutatesArguments();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));\n+\n+    flags.clearAllFlags();\n+    flags.setMutatesGlobalState();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));\n+  }\n+\n+  public void testCallSideEffects() {\n+    Node callExpr = getNode(\"new x().method()\");\n+    assertTrue(NodeUtil.functionCallHasSideEffects(callExpr));\n+\n+    Node newExpr = callExpr.getFirstChild().getFirstChild();\n+    Preconditions.checkState(newExpr.getType() == Token.NEW);\n+    Node.SideEffectFlags flags = new Node.SideEffectFlags();\n+\n+    // No side effects, local result\n+    flags.clearAllFlags();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+    flags.clearAllFlags();\n+    callExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));\n+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));\n+\n+    // Modifies this, local result\n+    flags.clearAllFlags();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+    flags.clearAllFlags();\n+    flags.setMutatesThis();\n+    callExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));\n+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));\n+\n+    // Modifies this, non-local result\n+    flags.clearAllFlags();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+    flags.clearAllFlags();\n+    flags.setMutatesThis();\n+    flags.setReturnsTainted();\n+    callExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertFalse(NodeUtil.evaluatesToLocalValue(callExpr));\n+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));\n+    \n+    // No modifications, non-local result\n+    flags.clearAllFlags();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+    flags.clearAllFlags();\n+    flags.setReturnsTainted();\n+    callExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertFalse(NodeUtil.evaluatesToLocalValue(callExpr));\n+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n+    assertFalse(NodeUtil.mayHaveSideEffects(callExpr));\n+\n+    // The new modifies global state, no side-effect call, non-local result\n+    // This call could be removed, but not the new.\n+    flags.clearAllFlags();\n+    flags.setMutatesGlobalState();\n+    newExpr.setSideEffectFlags(flags.valueOf());\n+    flags.clearAllFlags();\n+    callExpr.setSideEffectFlags(flags.valueOf());\n+\n+    assertTrue(NodeUtil.evaluatesToLocalValue(callExpr));\n+    assertFalse(NodeUtil.functionCallHasSideEffects(callExpr));\n+    assertTrue(NodeUtil.mayHaveSideEffects(callExpr));\n+  }\n+\n   private boolean testLocalValue(String js) {\n-    Node script = parse(\"var test = \" + js +\";\");\n-    Preconditions.checkState(script.getType() == Token.SCRIPT);\n-    Node var = script.getFirstChild();\n-    Preconditions.checkState(var.getType() == Token.VAR);\n-    Node name = var.getFirstChild();\n-    Preconditions.checkState(name.getType() == Token.NAME);\n-    Node value = name.getFirstChild();\n-\n-    return NodeUtil.evaluatesToLocalValue(value);\n+    return NodeUtil.evaluatesToLocalValue(getNode(js));\n   }\n \n   public void testValidDefine() {\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n \n   boolean regExpHaveSideEffects = true;\n \n-  private static final boolean BROKEN_NEW = true;\n-\n   private static String kExterns =\n       CompilerTypeTestCase.DEFAULT_EXTERNS +\n       \"var window; window.setTimeout;\" +\n       \"/**@nosideeffects*/ function externSENone(){}\\n\" +\n \n       \"/**@modifies{this}*/ function externSEThis(){}\\n\" +\n+\n       \"/**@constructor\\n\" +\n       \" * @modifies{this}*/\\n\" +\n       \"function externObjSEThis(){}\\n\" +\n     // side-effect free in this context.\n \n     checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n-        BROKEN_NEW ?\n-            ImmutableList.<String>of(\n-               \"externObjSEThis\") :\n-            ImmutableList.<String>of(\n-               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n+        ImmutableList.<String>of(\n+           \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n   }\n \n   public void testAnnotationInExterns_new5() throws Exception {\n     // While \"externObjSEThisMethod\" has modifies \"this\"\n     // it does not have global side-effects with \"this\" is\n     // a known local value.\n+    // TODO(johnlenz): \"f\" is side-effect free but we need\n+    // to propagate that \"externObjSEThisMethod\" is modifing\n+    // a local object.\n     checkMarkedCalls(\n         \"function f() {\" +\n         \"  new externObjSEThis().externObjSEThisMethod('') \" +\n         \"};\" +\n         \"f();\",\n-        BROKEN_NEW ?\n-            ImmutableList.<String>of(\n-                \"externObjSEThis\") :\n-           ImmutableList.<String>of(\n-               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n+         ImmutableList.<String>of(\n+             \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n   }\n \n   public void testAnnotationInExterns_new7() throws Exception {\n         \"f(g);\",\n         ImmutableList.<String>of(\"externObjSEThis\"));\n   }\n-\n \n   public void testAnnotationInExterns_new10() throws Exception {\n     // While \"externObjSEThisMethod2\" only modifies it arguments\n     checkLocalityOfMarkedCalls(\n         prefix + \"return 1; return g\" + suffix, notExpected);\n \n-\n     // local var, not yet.\n     checkLocalityOfMarkedCalls(\n         prefix + \"var a = 1; return a\" + suffix, notExpected);\n   public void testLocalizedSideEffects8() throws Exception {\n     // Returning a local object that has been modified\n     // is not a global side-effect.\n+    // TODO(johnlenz): Not yet. Propagate local object information.\n     checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n                      \"function f() {\" +\n                      \"  var a = new A; a.foo = 1; return a;\" +\n                      \"}\" +\n                      \"f()\",\n-                     BROKEN_NEW ?\n-                         ImmutableList.<String>of(\"A\") :\n-                         ImmutableList.<String>of(\"A\", \"f\"));\n+                     ImmutableList.<String>of(\"A\"));\n   }\n \n   public void testLocalizedSideEffects9() throws Exception {\n     // Returning a local object that has been modified\n     // is not a global side-effect.\n+    // TODO(johnlenz): Not yet. Propagate local object information.\n     checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +\n                      \"function f() {\" +\n                      \"  var a = new A; a.foo = 1; return a;\" +\n                      \"}\" +\n                      \"f()\",\n-                     BROKEN_NEW ?\n-                         ImmutableList.<String>of(\"A\") :\n-                         ImmutableList.<String>of(\"A\", \"f\"));\n+                     ImmutableList.<String>of(\"A\"));\n   }\n \n   public void testLocalizedSideEffects10() throws Exception {", "timestamp": 1292959363, "metainfo": ""}