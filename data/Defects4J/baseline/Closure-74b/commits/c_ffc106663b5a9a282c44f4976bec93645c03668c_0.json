{"sha": "ffc106663b5a9a282c44f4976bec93645c03668c", "log": "Split and fold constant comma expressions. (John) R=Alan DELTA=51  (51 added, 0 deleted, 0 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n         condition = NodeUtil.getConditionExpression(n);\n         this.tryFoldForCondition(condition, n);\n       }\n-        \n+\n       tryFoldFor(t, n, parent);\n       return;\n     }\n     if (type == Token.CALL) {\n       tryFoldStringJoin(t, n, left, right, parent);\n       tryFoldStringIndexOf(t, n, left, right, parent);\n+      return;\n+    }\n+\n+    if (type == Token.COMMA) {\n+      tryFoldComma(t, n, left, right, parent);\n       return;\n     }\n \n     }\n \n     // other types aren't handled\n+  }\n+\n+  private void tryFoldComma(\n+      NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+    // If the left side does nothing replace the comma with the result.\n+    if (!NodeUtil.mayHaveSideEffects(left)) {\n+      // Fold it!\n+      n.removeChild(right);\n+      parent.replaceChild(n, right);\n+      t.getCompiler().reportCodeChange();\n+    } else {\n+      if (parent.getType() == Token.EXPR_RESULT) {\n+        // split comma\n+        n.detachChildren();\n+        // Replace the original expression with the left operand.\n+        parent.replaceChild(n, left);\n+        // Add the right expression afterward.\n+        Node newStatement = new Node(Token.EXPR_RESULT, right);\n+        newStatement.copyInformationFrom(n);\n+        parent.getParent().addChildAfter(newStatement, parent);\n+        t.getCompiler().reportCodeChange();\n+      }\n+    }\n   }\n \n   private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n             result = left.getType() == right.getType();\n             break;\n \n-          case Token.SHNE:            \n+          case Token.SHNE:\n           case Token.NE:\n             result = left.getType() != right.getType();\n             break;\n       }\n     }\n   }\n-  \n+\n   /**\n    * Replaces a node with a number node if the new number node is not equivalent\n    * to the current node.\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n              \"  if (a) { var b = 1; } else { a.b = 1; }\" +\n              \"}\");\n   }\n+\n+  public void testFoldConstantCommaExpressions() {\n+    fold(\"if (true, false) {foo()}\", \"\");\n+    fold(\"if (false, true) {foo()}\", \"foo()\");\n+    fold(\"true, foo()\", \"foo()\");\n+    fold(\"(1 + 2 + ''), foo()\", \"foo()\");\n+  }\n+\n+  public void testSplitCommaExpressions() {\n+    // Don't try to split in expressions.\n+    foldSame(\"if (foo(), true) boo()\");\n+    foldSame(\"var a = (foo(), true);\");\n+    foldSame(\"a = (foo(), true);\");\n+\n+    fold(\"(x=2), foo()\", \"x=2; foo()\");\n+    fold(\"foo(), boo();\", \"foo(); boo()\");    \n+    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");    \n+    // TODO(johnlenz): interestingly we don't remove side-effect free expression\n+    // in a script block (as it is currently part of block folding), so \"1;\" \n+    // is left. \n+    fold(\"foo(), true\", \"foo();1\");\n+    fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n+  }\n }", "timestamp": 1269034471, "metainfo": ""}