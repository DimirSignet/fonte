{"sha": "0a39688562637465944df3c29ae0c1259cc0a4dc", "log": "Removes useless unconditional jumps  R=johnlenz DELTA=179  (96 added, 33 deleted, 50 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=88010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n \n     if (elseBlock == null) {\n       createEdge(node, Branch.ON_FALSE,\n-          computeFollowNode(node)); // not taken branch\n+          computeFollowNode(node, this)); // not taken branch\n     } else {\n       createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n     }\n \n     // Control goes to the follow() if the condition evaluates to false.\n     createEdge(node, Branch.ON_FALSE,\n-        computeFollowNode(node));\n+        computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(\n         node, NodeUtil.getConditionExpression(node));\n   }\n     createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n     // The edge that leaves the do loop if the condition fails.\n     createEdge(node, Branch.ON_FALSE,\n-        computeFollowNode(node));\n+        computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(\n         node, NodeUtil.getConditionExpression(node));\n   }\n       createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n       // The edge to end of the loop.\n       createEdge(forNode, Branch.ON_FALSE,\n-          computeFollowNode(forNode));\n+          computeFollowNode(forNode, this));\n       // The end of the body will have a unconditional branch to our iter\n       // (handled by calling computeFollowNode of the last instruction of the\n       // body. Our iter will jump to the forNode again to another condition\n       createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n       // The edge to end of the loop.\n       createEdge(forNode, Branch.ON_FALSE,\n-          computeFollowNode(forNode));\n+          computeFollowNode(forNode, this));\n       connectToPossibleExceptionHandler(forNode, collection);\n     }\n   }\n       if (node.getFirstChild().getNext() != null) {\n         createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n       } else { // No CASE, no DEFAULT\n-        createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n       }\n     }\n     connectToPossibleExceptionHandler(node, node.getFirstChild());\n       if (deflt != null) { // Has a DEFAULT\n         createEdge(node, Branch.ON_FALSE, deflt);\n       } else { // No DEFAULT found, go to the follow of the SWITCH.\n-        createEdge(node, Branch.ON_FALSE, computeFollowNode(node));\n+        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n       }\n     }\n     connectToPossibleExceptionHandler(node, node.getFirstChild());\n     if (child != null) {\n       createEdge(node, Branch.UNCOND, computeFallThrough(child));\n     } else {\n-      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     }\n \n     // Synthetic blocks\n   }\n \n   private void handleExpr(Node node) {\n-    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(node, node);\n   }\n \n       Preconditions.checkState(parent != null, \"Cannot find break target.\");\n     }\n     if (lastJump == node) {\n-      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));\n+      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n     } else {\n-      finallyMap.put(lastJump, computeFollowNode(cur));\n+      finallyMap.put(lastJump, computeFollowNode(cur, this));\n     }\n   }\n \n \n   private void handleStmt(Node node) {\n     // Simply transfer to the next line.\n-    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n+    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n     connectToPossibleExceptionHandler(node, node);\n   }\n \n-  private Node computeFollowNode(Node node) {\n-    return computeFollowNode(node, node);\n+  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n+    return computeFollowNode(node, node, cfa);\n+  }\n+\n+  static Node computeFollowNode(Node node) {\n+    return computeFollowNode(node, node, null);\n   }\n \n   /**\n    *        during recursion.\n    * @param node The node that follow() should compute.\n    */\n-  private Node computeFollowNode(Node fromNode, Node node) {\n+  private static Node computeFollowNode(\n+      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n     /*\n      * This is the case where:\n      *\n      * This will make life easier for DFAs.\n      */\n     Node parent = node.getParent();\n-    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n+    if (parent == null || parent.getType() == Token.FUNCTION ||\n+        (cfa != null && node == cfa.root)) {\n       return null;\n     }\n \n     switch (parent.getType()) {\n       // The follow() of any of the path from IF would be what follows IF.\n       case Token.IF:\n-        return computeFollowNode(fromNode, parent);\n+        return computeFollowNode(fromNode, parent, cfa);\n       case Token.CASE:\n       case Token.DEFAULT:\n         // After the body of a CASE, the control goes to the body of the next\n             Preconditions.checkState(false, \"Not reachable\");\n           }\n         } else {\n-          return computeFollowNode(fromNode, parent);\n+          return computeFollowNode(fromNode, parent, cfa);\n         }\n         break;\n       case Token.FOR:\n           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n             return computeFallThrough(parent.getLastChild());\n           } else { // and have no FINALLY.\n-            return computeFollowNode(fromNode, parent);\n+            return computeFollowNode(fromNode, parent, cfa);\n           }\n         // CATCH block.\n         } else if (NodeUtil.getCatchBlock(parent) == node){\n           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n             return computeFallThrough(node.getNext());\n           } else {\n-            return computeFollowNode(fromNode, parent);\n+            return computeFollowNode(fromNode, parent, cfa);\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n-          for (Node finallyNode : finallyMap.get(parent)) {\n-            createEdge(fromNode, Branch.UNCOND, finallyNode);\n+          if (cfa != null) {\n+            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+            }\n           }\n-          return computeFollowNode(fromNode, parent);\n+          return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n \n       return computeFallThrough(nextSibling);\n     } else {\n       // If there are no more siblings, control is transfered up the AST.\n-      return computeFollowNode(fromNode, parent);\n+      return computeFollowNode(fromNode, parent, cfa);\n     }\n   }\n \n    * subtree of n. We don't always create a CFG edge into n itself because of\n    * DOs and FORs.\n    */\n-  private static Node computeFallThrough(Node n) {\n+  static Node computeFallThrough(Node n) {\n     switch (n.getType()) {\n       case Token.DO:\n         return computeFallThrough(n.getFirstChild());\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Predicate;\n+import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.graph.GraphReachability;\n-import com.google.javascript.jscomp.graph.GraphNode;\n-import com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.Deque;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n \n     cfgStack.push(curCfg);\n     curCfg = cfa.getCfg();\n \n-    new GraphReachability<Node, ControlFlowGraph.Branch>(\n-        curCfg, new ReachablePredicate()).compute(curCfg.getEntry().getValue());\n+    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n+        .compute(curCfg.getEntry().getValue());\n   }\n \n   @Override\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  @SuppressWarnings(\"fallthrough\")\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (parent == null) {\n         n = body;\n       }\n     }\n-    GraphNode<Node, Branch> gNode = curCfg.getNode(n);\n+    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n     if (gNode == null) { // Not in CFG.\n       return;\n     }\n     if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n         (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n       removeDeadExprStatementSafely(n, parent);\n+      return;\n+    }\n+\n+    /*\n+     * For each of the unconditional branching control flow node, check to see\n+     * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n+     * the branching target. If it is, the branch node is safe to be removed.\n+     *\n+     * This is not as clever as MinimizeExitPoints because it doesn't do any\n+     * if-else conversion but it handles more complicated switch statements\n+     * much nicer.\n+     */\n+    switch (n.getType()) {\n+      case Token.RETURN:\n+        if (n.hasChildren()) {\n+          break;\n+        }\n+      case Token.BREAK:\n+      case Token.CONTINUE:\n+\n+        // We are looking for a control flow changing statement that always\n+        // branches to the same node. If removing it the control flow still\n+        // branches to that same node. It is safe to remove it.\n+        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+        if (outEdges.size() == 1 &&\n+\n+            // If there is a next node, there is no chance this jump is useless.\n+            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n+          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n+          Node fallThrough = ControlFlowAnalysis.computeFollowNode(n);\n+          if (outEdges.get(0).getDestination().getValue() == fallThrough) {\n+            removeDeadExprStatementSafely(n, parent);\n+          }\n+        }\n     }\n   }\n \n     }\n     NodeUtil.removeChild(parent, n);\n   }\n-  \n-  private final class ReachablePredicate implements\n-      Predicate<EdgeTuple<Node, ControlFlowGraph.Branch>> {\n-\n-    @Override\n-    public boolean apply(EdgeTuple<Node, Branch> input) {\n-      Branch branch = input.edge;\n-      if (!branch.isConditional()) {\n-        return true;\n-      }\n-      Node predecessor = input.sourceNode;\n-      Node condition = NodeUtil.getConditionExpression(predecessor);\n-  \n-      // TODO(user): Handle more complicated expression like true == true,\n-      // etc....\n-      if (condition != null && NodeUtil.isImmutableValue(condition)) {\n-        return NodeUtil.getBooleanValue(condition).toBoolean(true) ==\n-            (branch == Branch.ON_TRUE);\n-      }\n-      return true;\n-    }\n-  }\n-}\n+}\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n \n     // if/else statements with returns\n     test(\"function bar(){if(foo)x=1;else if(bar){return;x=2}\" +\n-         \"else{x=3;return;x=4}return;x=5}\",\n+         \"else{x=3;return;x=4}return 5;x=5}\",\n          \"function bar(){if(foo)x=1;else if(bar){return}\" +\n-         \"else{x=3;return}return}\");\n+         \"else{x=3;return}return 5}\");\n \n     // if statements without blocks\n     test(\"function foo(){if(x==3)return;x=4;y++;while(y==4){return;x=3}}\",\n          \"while(i<4){x=3;return}}\");\n \n     // return statements on the same level as conditionals\n-    test(\"function foo(){if(x==3){return}return;while(y==4){x++;return;x=4}}\",\n-         \"function foo(){if(x==3){return}return}\");\n+    test(\"function foo(){if(x==3){return}return 5;while(y==4){x++;return;x=4}}\",\n+         \"function foo(){if(x==3){return}return 5}\");\n \n     // return statements on the same level as conditionals\n     test(\"function foo(){return 3;for(;y==4;){x++;return;x=4}}\",\n          \"function foo(){return 3}\");\n \n     // try/catch statements\n-    test(\"function foo(){try{x=3;return x+1;x=5}catch(e){x=4;return;x=5}}\",\n-         \"function foo(){try{x=3;return x+1}catch(e){x=4;return}}\");\n+    test(\"function foo(){try{x=3;return x+1;x=5}catch(e){x=4;return 5;x=5}}\",\n+         \"function foo(){try{x=3;return x+1}catch(e){x=4;return 5}}\");\n \n     // try/finally statements\n-    test(\"function foo(){try{x=3;return x+1;x=5}finally{x=4;return;x=5}}\",\n-         \"function foo(){try{x=3;return x+1}finally{x=4;return}}\");\n+    test(\"function foo(){try{x=3;return x+1;x=5}finally{x=4;return 5;x=5}}\",\n+         \"function foo(){try{x=3;return x+1}finally{x=4;return 5}}\");\n \n     // try/catch/finally statements\n     test(\"function foo(){try{x=3;return x+1;x=5}catch(e){x=3;return;x=2}\" +\n-         \"finally{x=4;return;x=5}}\",\n+         \"finally{x=4;return 5;x=5}}\",\n \n          \"function foo(){try{x=3;return x+1}catch(e){x=3;return}\" +\n-         \"finally{x=4;return}}\");\n+         \"finally{x=4;return 5}}\");\n \n     // test a combination of blocks\n-    test(\"function foo(){x=3;if(x==4){x=5;return;x=6}else{x=7}return;x=3}\",\n-         \"function foo(){x=3;if(x==4){x=5;return}else{x=7}return}\");\n+    test(\"function foo(){x=3;if(x==4){x=5;return;x=6}else{x=7}return 5;x=3}\",\n+         \"function foo(){x=3;if(x==4){x=5;return}else{x=7}return 5}\");\n \n     // test removing multiple statements\n     test(\"function foo() { return 1; var x = 2; var y = 10; return 2;}\",\n   }\n \n   public void testConditionalDeadCode() {\n-    test(\"function f() { if (x) return; else return; x = 1}\",\n-        \"function f() { if (x) return; else return; }\");\n-  }\n-\n-  public void testKnownIf() {\n-    test(\"if(0) {alert(1)}\", \"\");\n-    test(\"if(0) if(0) {{alert(1)}}\", \"\");\n-  }\n-\n-  public void testKnownWhile() {\n-    // TODO(user): Improve elimination method to clean these up.\n-    test(\"while(0) {alert(1)}\", \"while(0);\");\n-    test(\"while(0) while(0) {{alert(1)}}\", \"while(0);\");\n+    test(\"function f() { if (1) return 5; else return 5; x = 1}\",\n+        \"function f() { if (1) return 5; else return 5; }\");\n   }\n \n   public void testSwitchCase() {\n-    test(\"function f() { switch(x) { default: return; foo()}}\",\n-         \"function f() { switch(x) { default: return;}}\");\n+    test(\"function f() { switch(x) { default: return 5; foo()}}\",\n+         \"function f() { switch(x) { default: return 5;}}\");\n     test(\"function f() { switch(x) { default: return; case 1: foo(); bar()}}\",\n          \"function f() { switch(x) { default: return; case 1: foo(); bar()}}\");\n-    test(\"function f() { switch(x) { default: return; case 1: return; bar()}}\",\n-         \"function f() { switch(x) { default: return; case 1: return;}}\");\n+    test(\"function f() { switch(x) { default: return; case 1: return 5;bar()}}\",\n+         \"function f() { switch(x) { default: return; case 1: return 5;}}\");\n   }\n \n   public void testTryCatchFinally() {\n     test(\"(function() {}).prototype['toString'] = function(){};\", \"\");\n     test(\"(function() {}).prototype[f] = function(){};\", \"\");\n   }\n+\n+  public void testUnlessUnconditionalReturn() {\n+    test(\"function foo() { return }\", \" function foo() { }\");\n+    test(\"function foo() { return; return; x=1 }\", \"function foo() { }\");\n+    test(\"function foo() { return; return; var x=1}\", \"function foo() {var x}\");\n+    test(\"function foo() { return; function bar() {} }\",\n+         \"function foo() {         function bar() {} }\" );\n+    testSame(\"function foo() { return 5 }\");\n+\n+\n+    test(\"function() {switch (a) { case 'a': return}}\",\n+         \"function() {switch (a) { case 'a': }}\");\n+    testSame(\"function() {switch (a) { case 'a': return; case foo(): }}\");\n+    testSame(\"function() {switch (a) { default: return; case 'a': alert(1)}}\");\n+    testSame(\"function() {switch (a) { case 'a': return; default: alert(1)}}\");\n+  }\n+\n+  public void testUnlessUnconditionalContinue() {\n+    test(\"for(;1;) {continue}\", \" for(;1;) {}\");\n+    test(\"for(;0;) {continue}\", \" for(;0;) {}\");\n+\n+    testSame(\"X: for(;1;) { for(;1;) { if (x()) {continue X} x = 1}}\");\n+    test(\"for(;1;) { X: for(;1;) { if (x()) {continue X} }}\",\n+         \"for(;1;) { X: for(;1;) { if (x()) {}}}\");\n+\n+    test(\"do { continue } while(1);\", \"do {  } while(1);\");\n+  }\n+\n+  public void testUnlessUnconditonalBreak() {\n+    test(\"switch (a) { case 'a': break }\", \"switch (a) { case 'a': }\");\n+    testSame(\"switch (a) { case 'a': break; case foo(): }\");\n+    testSame(\"switch (a) { default: break; case 'a': }\");\n+    testSame(\"switch (a) { case 'a': break; default: }\");\n+\n+\n+    test(\"X: {switch (a) { case 'a': break X}}\",\n+         \"X: {switch (a) { case 'a': }}\");\n+\n+    testSame(\"X: {switch (a) { case 'a': if (a()) {break X}  a = 1}}\");\n+    test(\"X: {switch (a) { case 'a': if (a()) {break X}}}\",\n+         \"X: {switch (a) { case 'a': if (a()) {}}}\");\n+\n+    test(\"X: {switch (a) { case 'a': if (a()) {break X}}}\",\n+         \"X: {switch (a) { case 'a': if (a()) {}}}\");\n+\n+    // TODO(user): Optimize these better.\n+    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n+         \"switch (a) { case 'a': break; case 'b': break; case 'c': }\");\n+\n+    testSame(\"do { break } while(1);\");\n+    testSame(\"for(;1;) { break }\");\n+  }\n }", "timestamp": 1280969611, "metainfo": ""}