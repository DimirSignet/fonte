{"sha": "0895c28861ee4a1969acc858f1a703ab11ddc64c", "log": "Change on 2010/06/16 by johnlenz          Remove unused member variable.          R=acleung         DELTA=17  (0 added, 12 deleted, 5 changed)  Change on 2010/06/16 by acleung          Make @notypecheck behaves like it is doing typechecking except for reporting errors.          R=johnlenz         DELTA=144  (89 added, 17 deleted, 38 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=28012   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   private int unknownCount = 0;\n   private boolean inExterns;\n \n+  // A state boolean to see we are currently in @notypecheck section of the\n+  // code.\n+  private int noTypeCheckSection = 0;\n+\n   public TypeCheck(AbstractCompiler compiler,\n       ReverseAbstractInterpreter reverseInterpreter,\n       JSTypeRegistry typeRegistry,\n   }\n \n \n+  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n+    switch (n.getType()) {\n+      case Token.SCRIPT:\n+      case Token.BLOCK:\n+      case Token.VAR:\n+      case Token.FUNCTION:\n+      case Token.ASSIGN:\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null && info.isNoTypeCheck()) {\n+          if (enterSection) {\n+            noTypeCheckSection++;\n+          } else {\n+            noTypeCheckSection--;\n+          }\n+        }\n+        validator.setShouldReport(noTypeCheckSection == 0);\n+        break;\n+    }\n+  }\n+\n+  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n+      String... arguments) {\n+    if (noTypeCheckSection == 0) {\n+      t.report(n, diagnosticType, arguments);\n+    }\n+  }\n+\n   public boolean shouldTraverse(\n       NodeTraversal t, Node n, Node parent) {\n-    JSDocInfo info;\n+    checkNoTypeCheckSection(n, true);\n     switch (n.getType()) {\n-      case Token.SCRIPT:\n-      case Token.VAR:\n-        // @notypecheck\n-        info = n.getJSDocInfo();\n-        if (info != null && info.isNoTypeCheck()) {\n-          return false;\n-        }\n-        break;\n-\n       case Token.FUNCTION:\n-        // @notypecheck\n-        info = n.getJSDocInfo();\n-        info = (info == null) ? parent.getJSDocInfo() : info;\n-        if (info != null && info.isNoTypeCheck()) {\n-          return false;\n-        }\n-\n         // normal type checking\n         final TypeCheck outerThis = this;\n         final Scope outerScope = t.getScope();\n             // redeclarations of built-in types generates spurious warnings.\n             !(outerScope.getVar(\n                 functionPrivateName).getType() instanceof FunctionType)) {\n-          t.report(n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n+          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n         }\n \n         // TODO(user): Only traverse the function's body. The function's\n       case Token.BITNOT:\n         childType = getJSType(n.getFirstChild());\n         if (!childType.matchesInt32Context()) {\n-          t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n+          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n               childType.toString());\n         }\n         ensureTyped(t, n, NUMBER_TYPE);\n           if (n.getType() == Token.NE) {\n             result = result.not();\n           }\n-          t.report(n, DETERMINISTIC_TEST, leftType.toString(),\n+          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n               rightType.toString(), result.toString());\n         }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n         if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                 rightTypeRestricted)) {\n-          t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n+          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n               rightType.toString());\n         }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n \n       case Token.DELPROP:\n         if (!isReference(n.getFirstChild())) {\n-          t.report(n, BAD_DELETE);\n+          report(t, n, BAD_DELETE);\n         }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n         break;\n         break;\n \n       default:\n-        t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n         ensureTyped(t, n);\n         break;\n     }\n     if (typeable) {\n       doPercentTypedAccounting(t, n);\n     }\n+\n+    checkNoTypeCheckSection(n, false);\n   }\n \n   /**\n            objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\n           propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n         if (objectType instanceof EnumType) {\n-          t.report(n, INEXISTENT_ENUM_ELEMENT, propName);\n+          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n         } else if (!objectType.isEmptyType() &&\n             reportMissingProperties && !isPropertyTest(n)) {\n           if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n-            t.report(n, INEXISTENT_PROPERTY, propName,\n+            report(t, n, INEXISTENT_PROPERTY, propName,\n                 validator.getReadableJSTypeName(n.getFirstChild(), true));\n           }\n         }\n         } else {\n           line = constructor;\n         }\n-        t.report(line, NOT_A_CONSTRUCTOR);\n+        report(t, line, NOT_A_CONSTRUCTOR);\n       }\n       ensureTyped(t, n);\n     }\n           badImplementedType = true;\n         }\n         if (badImplementedType) {\n-          t.report(n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n+          report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n         }\n       }\n       if (functionType.isConstructor()) {\n     JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n \n     if (!childType.canBeCalled()) {\n-      t.report(n, NOT_CALLABLE, childType.toString());\n+      report(t, n, NOT_CALLABLE, childType.toString());\n       ensureTyped(t, n);\n       return;\n     }\n       // Non-native constructors should never be called directly.\n       if (functionType.isConstructor() &&\n           !functionType.isNativeObjectType()) {\n-        t.report(n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n+        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n       }\n \n       visitParameterList(t, n, functionType);\n       case Token.ASSIGN_URSH:\n       case Token.URSH:\n         if (!leftType.matchesInt32Context()) {\n-          t.report(left, BIT_OPERATION,\n+          report(t, left, BIT_OPERATION,\n                    NodeUtil.opToStr(n.getType()), leftType.toString());\n         }\n         if (!rightType.matchesUint32Context()) {\n-          t.report(right, BIT_OPERATION,\n+          report(t, right, BIT_OPERATION,\n                    NodeUtil.opToStr(n.getType()), rightType.toString());\n         }\n         break;\n         break;\n \n       default:\n-        t.report(n, UNEXPECTED_TOKEN, Node.tokenToName(op));\n+        report(t, n, UNEXPECTED_TOKEN, Node.tokenToName(op));\n     }\n     ensureTyped(t, n);\n   }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n   private final AbstractCompiler compiler;\n   private final JSTypeRegistry typeRegistry;\n   private final JSType allValueTypes;\n+  private boolean shouldReport = true;\n \n   // TODO(nicksantos): Provide accessors to better filter the list of type\n   // mismatches. For example, if we pass (Cake|null) where only Cake is\n    */\n   Iterable<TypeMismatch> getMismatches() {\n     return mismatches;\n+  }\n+\n+  void setShouldReport(boolean report) {\n+    this.shouldReport = report;\n   }\n \n   // All non-private methods should have the form:\n       JSType hiddenType, String propertyName, JSType ownerType) {\n     if (!overridingType.canAssignTo(hiddenType)) {\n       registerMismatch(overridingType, hiddenType);\n-      compiler.report(\n-          t.makeError(n, HIDDEN_PROPERTY_MISMATCH,\n-              propertyName, ownerType.toString(),\n-              hiddenType.toString(), overridingType.toString()));\n+      if (shouldReport) {\n+        compiler.report(\n+            t.makeError(n, HIDDEN_PROPERTY_MISMATCH,\n+                propertyName, ownerType.toString(),\n+                hiddenType.toString(), overridingType.toString()));\n+      }\n     }\n   }\n \n         subObject.getImplicitPrototype().getImplicitPrototype();\n     if (!declaredSuper.equals(superObject)) {\n       if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {\n-        compiler.report(\n-            t.makeError(n, MISSING_EXTENDS_TAG_WARNING,\n-                subObject.toString()));\n+        if (shouldReport) {\n+          compiler.report(\n+              t.makeError(n, MISSING_EXTENDS_TAG_WARNING,\n+                  subObject.toString()));\n+        }\n         registerMismatch(superObject, declaredSuper);\n       } else {\n         mismatch(t.getSourceName(), n,\n     type = type.restrictByNotNullOrUndefined();\n \n     if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n-      compiler.report(\n-          t.makeError(n, INVALID_CAST,\n-              castType.toString(), type.toString()));\n+      if (shouldReport) {\n+        compiler.report(\n+            t.makeError(n, INVALID_CAST,\n+                castType.toString(), type.toString()));\n+      }\n       registerMismatch(type, castType);\n     }\n   }\n         if (!(allowDupe ||\n               var.getParentNode().getType() == Token.EXPR_RESULT) ||\n             !newType.equals(varType)) {\n-          compiler.report(\n-              JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n-                  variableName, newType.toString(), var.getInputName(),\n-                  String.valueOf(var.nameNode.getLineno()),\n-                  varType.toString()));\n+          if (shouldReport) {\n+            compiler.report(\n+                JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n+                    variableName, newType.toString(), var.getInputName(),\n+                    String.valueOf(var.nameNode.getLineno()),\n+                    varType.toString()));\n+          }\n         }\n       }\n     }\n             Preconditions.checkNotNull(source);\n             String sourceName = (String) source.getProp(Node.SOURCENAME_PROP);\n             sourceName = sourceName == null ? \"\" : sourceName;\n-\n-            compiler.report(JSError.make(sourceName, source,\n-                INTERFACE_METHOD_NOT_IMPLEMENTED,\n-                prop, implemented.toString(), instance.toString()));\n+            if (shouldReport) {\n+              compiler.report(JSError.make(sourceName, source,\n+                  INTERFACE_METHOD_NOT_IMPLEMENTED,\n+                  prop, implemented.toString(), instance.toString()));\n+            }\n             registerMismatch(instance, implemented);\n           }\n         }\n   private void mismatch(String sourceName, Node n,\n                         String msg, JSType found, JSType required) {\n     registerMismatch(found, required);\n-    compiler.report(\n-        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n-                     formatFoundRequired(msg, found, required)));\n+    if (shouldReport) {\n+      compiler.report(\n+          JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n+                       formatFoundRequired(msg, found, required)));\n+    }\n   }\n \n   private void registerMismatch(JSType found, JSType required) {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   public void testNoTypeCheck8() throws Exception {\n     testTypes(\"/** @fileoverview \\n * @notypecheck */ var foo;\" +\n         \"var bar = 3; /** @param {string} x */ function f(x) {} f(bar);\");\n+  }\n+\n+  public void testNoTypeCheck9() throws Exception {\n+    testTypes(\"/** @notypecheck */ function g() { }\" +\n+        \" /** @type {string} */ var a = 1\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\"\n+        );\n+  }\n+\n+  public void testNoTypeCheck10() throws Exception {\n+    testTypes(\"/** @notypecheck */ function g() { }\" +\n+        \" function h() {/** @type {string} */ var a = 1}\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\"\n+        );\n+  }\n+\n+  public void testNoTypeCheck11() throws Exception {\n+    testTypes(\"/** @notypecheck */ function g() { }\" +\n+        \"/** @notypecheck */ function h() {/** @type {string} */ var a = 1}\"\n+        );\n+  }\n+\n+  public void testNoTypeCheck12() throws Exception {\n+    testTypes(\"/** @notypecheck */ function g() { }\" +\n+        \"function h() {/** @type {string}\\n * @notypecheck\\n*/ var a = 1}\"\n+        );\n+  }\n+\n+  public void testNoTypeCheck13() throws Exception {\n+    testTypes(\"/** @notypecheck */ function g() { }\" +\n+        \"function h() {/** @type {string}\\n * @notypecheck\\n*/ var a = 1;\" +\n+        \"/** @type {string}*/ var b = 1}\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\"\n+        );\n   }\n \n   public void testImplicitCast() throws Exception {", "timestamp": 1276795011, "metainfo": ""}