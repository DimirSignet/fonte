{"sha": "f6336648d893f0ad455d53ab85f82128937fa41c", "log": "Adding Chris Black's patch from CODEC-40 adding BigInteger support to Base64. Still needs edge case testing  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n+import java.math.BigInteger;\n+\n /**\n  * Provides Base64 encoding and decoding as defined by RFC 2045.\n  * \n         return encodeBase64(pArray, false);\n     }\n \n+    // Implementation of integer encoding used for crypto\n+    /**\n+     * Decode a byte64-encoded integer according to crypto\n+     * standards such as W3C's XML-Signature\n+     * \n+     * @param pArray a byte array containing base64 character data\n+     * @return A BigInteger\n+     */\n+    public static BigInteger decodeInteger(byte[] pArray) {\n+        return new BigInteger(1, decodeBase64(pArray));\n+    }\n+\n+    /**\n+     * Encode to a byte64-encoded integer according to crypto\n+     * standards such as W3C's XML-Signature\n+     * \n+     * @param bigInt a BigInteger\n+     * @return A byte array containing base64 character data\n+     * @throws NullPointerException if null is passed in\n+     */\n+    public static byte[] encodeInteger(BigInteger bigInt) {\n+        if(bigInt == null)  {\n+            throw new NullPointerException(\"encodeInteger called with null parameter\");\n+        }\n+\n+        return encodeBase64(toIntegerBytes(bigInt), false);\n+    }\n+\n+    /**\n+     * Returns a byte-array representation of a <code>BigInteger</code>\n+     * without sign bit.\n+     *\n+     * @param bigInt <code>BigInteger</code> to be converted\n+     * @return a byte array representation of the BigInteger parameter\n+     */\n+     static byte[] toIntegerBytes(BigInteger bigInt) {\n+        int bitlen = bigInt.bitLength();\n+        // round bitlen\n+        bitlen = ((bitlen + 7) >> 3) << 3;\n+        byte[] bigBytes = bigInt.toByteArray();\n+\n+        if(((bigInt.bitLength() % 8) != 0)\n+            && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n+            return bigBytes;\n+        }\n+\n+        // set up params for copying everything but sign bit\n+        int startSrc = 0;\n+        int len = bigBytes.length;\n+\n+        // if bigInt is exactly byte-aligned, just skip signbit in copy\n+        if((bigInt.bitLength() % 8) == 0) {\n+            startSrc = 1;\n+            len--;\n+        }\n+\n+        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n+        byte[] resizedBytes = new byte[bitlen / 8];\n+\n+        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n+\n+        return resizedBytes;\n+    }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n \n import java.util.Arrays;\n import java.util.Random;\n-\n+import java.math.BigInteger;\n import junit.framework.TestCase;\n \n /**\n                 destFromNoWS.equals( orig ) );\n     }\n \n+    public void testCodeInteger1() {\n+        String encodedInt1 = \"li7dzDacuo67Jg7mtqEm2TRuOMU=\";\n+        BigInteger bigInt1 = new BigInteger(\"85739377120809420210425962799\" +\n+            \"0318636601332086981\");\n+\n+    \tassertEquals(encodedInt1, new String(Base64.encodeInteger(bigInt1)));\n+        assertEquals(bigInt1, Base64.decodeInteger(encodedInt1.getBytes()));\n+    }\n+\n+    public void testCodeInteger2() {\n+        String encodedInt2 = \"9B5ypLY9pMOmtxCeTDHgwdNFeGs=\";\n+        BigInteger bigInt2 = new BigInteger(\"13936727572861167254666467268\" +\n+            \"91466679477132949611\");\n+\n+        assertEquals(encodedInt2, new String(Base64.encodeInteger(bigInt2)));\n+        assertEquals(bigInt2, Base64.decodeInteger(encodedInt2.getBytes()));\n+    }\n+\n+    public void testCodeInteger3() {\n+        String encodedInt3 = \"FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2\" +\n+            \"rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==\";\n+        BigInteger bigInt3 = new BigInteger(\"10806548154093873461951748545\" +\n+            \"1196989136416448805819079363524309897749044958112417136240557\" +\n+            \"4495062430572478766856090958495998158114332651671116876320938126\");\n+\n+        assertEquals(encodedInt3, new String(Base64.encodeInteger(bigInt3)));\n+        assertEquals(bigInt3, Base64.decodeInteger(encodedInt3.getBytes()));\n+    }\n+\n+    public void testCodeInteger4() {\n+        String encodedInt4 = \"ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI\" +\n+            \"4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o\" +\n+            \"DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv\" +\n+            \"Q0=\";\n+        BigInteger bigInt4 = new BigInteger(\"80624726256040348115552042320\" +\n+            \"6968135001872753709424419772586693950232350200555646471175944\" +\n+             \"519297087885987040810778908507262272892702303774422853675597\" +\n+             \"748008534040890923814202286633163248086055216976551456088015\" +\n+             \"338880713818192088877057717530169381044092839402438015097654\" +\n+             \"53542091716518238707344493641683483917\");\n+\n+        assertEquals(encodedInt4, new String(Base64.encodeInteger(bigInt4)));\n+        assertEquals(bigInt4, Base64.decodeInteger(encodedInt4.getBytes()));\n+    }\n+\n+    public void testCodeIntegerEdgeCases() {\n+        // TODO\n+    }\n+\n     // -------------------------------------------------------- Private Methods\n \n     private String toString(byte[] data) {", "timestamp": 1204962701, "metainfo": ""}