{"sha": "2f7454a01e4c2992bffc3d86137e632e80c5027f", "log": "[#CODEC-75] Make Base64 URL-safe. Applied patch (https://issues.apache.org/jira/secure/attachment/12408898/codec75.patch) and make other clean ups.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n      * Thanks to \"commons\" project in ws.apache.org for this code. \n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      */\n-    private static final byte[] intToBase64 = {\n+    private static final byte[] STANDARD_ENCODE_TABLE = {\n             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n             'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n             'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n     };\n \n     /**\n+     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n+     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n+     * This table is only used when the Base64's mode is set to URL-SAFE.\n+     */    \n+    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n+    /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = '=';\n \n     /**\n-     * This array is a lookup table that translates unicode characters\n+     * This array is a lookup table that translates Unicode characters\n      * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n      * into their 6-bit positive integer equivalents.  Characters that\n      * are not in the Base64 alphabet but fall within the bounds of the\n      * array are translated to -1.\n      *\n+     * Note:  '+' and '-' both decode to 62.  '/' and '_' both decode to 63.\n+     * This means decoder seamlessly handles both URL_SAFE and STANDARD base64.\n+     * (The encoder, on the other hand, needs to know ahead of time what to emit).\n+     *\n      * Thanks to \"commons\" project in ws.apache.org for this code.\n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n      */\n-    private static final byte[] base64ToInt = {\n+    private static final byte[] DECODE_TABLE = {\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n             55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n             5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n             35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n     };\n \n     // The private member fields below are used with the new streaming approach, which requires\n     // some state be preserved between calls of encode() and decode().\n \n+    /**\n+     * Encode table to use:  either STANDARD or URL_SAFE.  Note:  the DECODE_TABLE above remains static\n+     * because it is able to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member\n+     * variable so we can switch between the two modes.\n+     */\n+    private final byte[] encodeTable;\n \n     /**\n      * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n     private int x;\n \n     /**\n-     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF\n-     * when encoding, and all forms can be decoded.\n+     * Sets state for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants can be decoded.\n+     * </p>\n      */\n     public Base64() {\n-        this(CHUNK_SIZE, CHUNK_SEPARATOR);\n-    }\n-\n-    /**\n-     * <p>\n-     * Consumer can use this constructor to choose a different lineLength\n-     * when encoding (lineSeparator is still CRLF).  All forms of data can\n-     * be decoded.\n-     * </p><p>\n-     * Note:  lineLengths that aren't multiples of 4 will still essentially\n-     * end up being multiples of 4 in the encoded data.\n-     * </p>\n-     *\n-     * @param lineLength each line of encoded data will be at most this long\n-     * (rounded up to nearest multiple of 4). \n-     * If lineLength <= 0, then the output will not be divided into lines (chunks).  \n-     * Ignored when decoding.\n+        this(false);\n+    }\n+\n+    /**\n+     * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is\n+     * supplied.\n+     * \n+     * When decoding: all variants can be decoded.\n+     * \n+     * @param urlSafe\n+     *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.\n+     */\n+    public Base64(boolean urlSafe) {\n+        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.\n+     * </p>\n+     * <p>\n+     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n+     * data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If\n+     *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      */\n     public Base64(int lineLength) {\n         this(lineLength, CHUNK_SEPARATOR);\n \n     /**\n      * <p>\n-     * Consumer can use this constructor to choose a different lineLength\n-     * and lineSeparator when encoding.  All forms of data can\n-     * be decoded.\n+     * Sets the line length and line separator when encoding. All forms of data can be decoded.\n+     * </p>\n+     * <p>\n+     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n+     * data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored\n+     *            when decoding. If <= 0, then output will not be divided into lines (chunks).\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some base64 characters. That's not going to work!\n+     */\n+    public Base64(int lineLength, byte[] lineSeparator) {\n+        this(lineLength, lineSeparator, false);\n+    }\n+\n+    /**\n+     * <p>\n+     * Consumer can use this constructor to choose a different lineLength,\n+     * lineSeparator, and whether to use URL-SAFE mode when encoding.\n+     * All forms of data can be decoded.\n      * </p><p>\n      * Note:  lineLengths that aren't multiples of 4 will still essentially\n      * end up being multiples of 4 in the encoded data.\n      * @param lineSeparator Each line of encoded data will end with this\n      *                      sequence of bytes.\n      *                      If lineLength <= 0, then the lineSeparator is not used.\n+     * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.\n+     *                      urlSafe is only applied to \"encode\" operations.  Decoding seamlessly\n+     *                      handles both modes.\n+     *\n      * @throws IllegalArgumentException The provided lineSeparator included\n      *                                  some base64 characters.  That's not going to work!\n      */\n-    public Base64(int lineLength, byte[] lineSeparator) {\n+    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n         this.lineLength = lineLength;\n         this.lineSeparator = new byte[lineSeparator.length];\n         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n         } else {\n             this.encodeSize = 4;\n         }\n-        this.decodeSize = encodeSize - 1;\n+        this.decodeSize = this.encodeSize - 1;\n         if (containsBase64Byte(lineSeparator)) {\n             String sep;\n             try {\n             }\n             throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n+        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n+    }\n+\n+    /**\n+     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n+     * \n+     * @return true if we're in URL-SAFE mode, false otherwise.\n+     */\n+    public boolean isUrlSafe() {\n+        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n     }\n \n     /**\n      * Returns true if this Base64 object has buffered data for reading.\n-     *\n+     * \n      * @return true if there is Base64 object still available for reading.\n      */\n-    boolean hasData() { return buf != null; }\n+    boolean hasData() {\n+        return this.buf != null;\n+    }\n \n     /**\n      * Returns the amount of buffered data available for reading.\n-     *\n+     * \n      * @return The amount of buffered data available for reading.\n      */\n-    int avail() { return buf != null ? pos - readPos : 0; }\n+    int avail() {\n+        return buf != null ? pos - readPos : 0;\n+    }\n \n     /** Doubles our buffer. */\n     private void resizeBuf() {\n                 buf = null;\n             }\n             return len;\n-        } else {\n-            return eof ? -1 : 0;\n-        }\n+        }\n+        return eof ? -1 : 0;\n     }\n \n     /**\n         if (eof) {\n             return;\n         }\n-\n         // inAvail < 0 is how we're informed of EOF in the underlying data we're\n         // encoding.\n         if (inAvail < 0) {\n             }\n             switch (modulus) {\n                 case 1:\n-                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];\n-                    buf[pos++] = PAD;\n-                    buf[pos++] = PAD;\n+                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buf[pos++] = PAD;\n+                        buf[pos++] = PAD;\n+                    }\n                     break;\n \n                 case 2:\n-                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];\n-                    buf[pos++] = PAD;\n+                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buf[pos++] = PAD;\n+                    }\n                     break;\n             }\n             if (lineLength > 0) {\n                 if (b < 0) { b += 256; }\n                 x = (x << 8) + b;\n                 if (0 == modulus) {\n-                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];\n-                    buf[pos++] = intToBase64[x & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n+                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                     currentLinePos += 4;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n                         System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n             }\n             byte b = in[inPos++];\n             if (b == PAD) {\n-                x = x << 6;\n-                switch (modulus) {\n-                    case 2:\n-                        x = x << 6;\n-                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                        break;\n-                    case 3:\n-                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                        buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                        break;\n-                }\n                 // WE'RE DONE!!!!\n                 eof = true;\n-                return;\n+                break;\n             } else {\n-                if (b >= 0 && b < base64ToInt.length) {\n-                    int result = base64ToInt[b];\n+                if (b >= 0 && b < DECODE_TABLE.length) {\n+                    int result = DECODE_TABLE[b];\n                     if (result >= 0) {\n                         modulus = (++modulus) % 4;\n                         x = (x << 6) + result;\n                 }\n             }\n         }\n+\n+        // Two forms of EOF as far as base64 decoder is concerned:  actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus != 0) {\n+            x = x << 6;\n+            switch (modulus) {\n+                case 2:\n+                    x = x << 6;\n+                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    break;\n+                case 3:\n+                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n     }\n \n     /**\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     public static boolean isBase64(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);\n+        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n     }\n \n     /**\n         return true;\n     }\n \n-    /*\n+    /**\n      * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n      * \n      * @param arrayOctet\n     public static byte[] encodeBase64(byte[] binaryData) {\n         return encodeBase64(binaryData, false);\n     }\n+\n+    /**\n+     * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.\n+     * The url-safe variation emits - and _ instead of + and / characters.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return Base64 characters\n+     */\n+    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n+        return encodeBase64(binaryData, false, true);\n+    }\n+    \n \n     /**\n      * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n+        return encodeBase64(binaryData, isChunked, false);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     *\n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n+     * @param urlSafe\n+     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n+     * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n-        Base64 b64 = isChunked ? new Base64() : new Base64(0);\n-\n+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n         long len = (binaryData.length * 4) / 3;\n         long mod = len % 4;\n         if (mod != 0) {\n         if (isChunked) {\n             len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n         }\n-\n         if (len > Integer.MAX_VALUE) {\n             throw new IllegalArgumentException(\n                     \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n         b64.setInitialBuffer(buf, 0, buf.length);\n         b64.encode(binaryData, 0, binaryData.length);\n         b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n-\n         // Encoder might have resized, even though it was unnecessary.\n         if (b64.buf != buf) {\n             b64.readResults(buf, 0, buf.length);\n         }\n+        // In URL-SAFE mode we skip the padding characters, so sometimes our\n+        // final length is a bit smaller.\n+        if (urlSafe && b64.pos < buf.length) {\n+            byte[] smallerBuf = new byte[b64.pos];\n+            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n+            buf = smallerBuf;\n+        }\n         return buf;\n     }\n \n             return base64Data;\n         }\n         Base64 b64 = new Base64();\n-\n         long len = (base64Data.length * 3) / 4;\n         byte[] buf = new byte[(int) len];\n         b64.setInitialBuffer(buf, 0, buf.length);\n         b64.decode(base64Data, 0, base64Data.length);\n         b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n-\n         // We have no idea what the line-length was, so we\n         // cannot know how much of our array wasn't used.\n         byte[] result = new byte[b64.pos];\n     static byte[] discardWhitespace(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-\n         for (int i = 0; i < data.length; i++) {\n             switch (data[i]) {\n                 case ' ' :\n                     groomedData[bytesCopied++] = data[i];\n             }\n         }\n-\n         byte packedData[] = new byte[bytesCopied];\n-\n         System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n         return packedData;\n     }\n \n \n     /**\n-     * Check if a byte value is whitespace or not.\n-     * \n-     * @param byteToCheck the byte to check\n+     * Checks if a byte value is whitespace or not.\n+     * \n+     * @param byteToCheck\n+     *            the byte to check\n      * @return true if byte is whitespace, false otherwise\n      */\n-    private static boolean isWhiteSpace(byte byteToCheck){\n+    private static boolean isWhiteSpace(byte byteToCheck) {\n         switch (byteToCheck) {\n-        case ' ' :\n-        case '\\n' :\n-        case '\\r' :\n-        case '\\t' :\n-            return true;\n-        default :\n-            return false;\n+            case ' ' :\n+            case '\\n' :\n+            case '\\r' :\n+            case '\\t' :\n+                return true;\n+            default :\n+                return false;\n         }\n     }\n \n     static byte[] discardNonBase64(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-\n         for (int i = 0; i < data.length; i++) {\n             if (isBase64(data[i])) {\n                 groomedData[bytesCopied++] = data[i];\n             }\n         }\n-\n         byte packedData[] = new byte[bytesCopied];\n-\n         System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n         return packedData;\n     }\n \n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        return encodeBase64(pArray, false);\n+        return encodeBase64(pArray, false, isUrlSafe());\n     }\n \n     // Implementation of integer encoding used for crypto\n     /**\n-     * Decode a byte64-encoded integer according to crypto\n+     * Decodes a byte64-encoded integer according to crypto\n      * standards such as W3C's XML-Signature\n      * \n      * @param pArray a byte array containing base64 character data\n     }\n \n     /**\n-     * Encode to a byte64-encoded integer according to crypto\n+     * Encodes to a byte64-encoded integer according to crypto\n      * standards such as W3C's XML-Signature\n      * \n      * @param bigInt a BigInteger\n         if(bigInt == null)  {\n             throw new NullPointerException(\"encodeInteger called with null parameter\");\n         }\n-\n         return encodeBase64(toIntegerBytes(bigInt), false);\n     }\n \n             (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n             return bigBytes;\n         }\n-\n         // set up params for copying everything but sign bit\n         int startSrc = 0;\n         int len = bigBytes.length;\n             startSrc = 1;\n             len--;\n         }\n-\n         int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n         byte[] resizedBytes = new byte[bitlen / 8];\n-\n         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n-\n         return resizedBytes;\n     }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n package org.apache.commons.codec.binary;\n \n \n+import java.io.UnsupportedEncodingException;\n import java.util.Arrays;\n import java.util.Random;\n import java.math.BigInteger;\n         }\n         base64 = new Base64(64,new byte[]{' ','$','\\n','\\r','\\t'}); // OK\n     }\n+\n+    /**\n+     * Base64 encoding of UUID's is a common use-case, especially in URL-SAFE\n+     * mode.  This test case ends up being the \"URL-SAFE\" JUnit's.\n+     *\n+     * @throws DecoderException if Hex.decode() fails - a serious problem since\n+     * Hex comes from our own commons-codec!\n+     *\n+     * @throws UnsupportedEncodingException if \"UTF-8\" character set is not\n+     * available.  Unlikely.\n+     */\n+    public void testUUID() throws DecoderException, UnsupportedEncodingException {\n+        // The 4 UUID's below contains mixtures of + and / to help us test the\n+        // URL-SAFE encoding mode.\n+        byte[][] ids = new byte[4][];\n+\n+        // ids[0] was chosen so that it encodes with at least one +.\n+        ids[0] = Hex.decodeHex(\"94ed8d0319e4493399560fb67404d370\".toCharArray());\n+\n+        // ids[1] was chosen so that it encodes with both / and +.\n+        ids[1] = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());\n+\n+        // ids[2] was chosen so that it encodes with at least one /.\n+        ids[2] = Hex.decodeHex(\"64be154b6ffa40258d1a01288e7c31ca\".toCharArray());\n+\n+        // ids[3] was chosen so that it encodes with both / and +, with /\n+        // right at the beginning.\n+        ids[3] = Hex.decodeHex(\"ff7f8fc01cdb471a8c8b5a9306183fe8\".toCharArray());\n+\n+        byte[][] standard = new byte[4][];\n+        standard[0] = \"lO2NAxnkSTOZVg+2dATTcA==\".getBytes(\"UTF-8\");\n+        standard[1] = \"K/fMJwH+Q5e0nr7tWsxwkA==\".getBytes(\"UTF-8\");\n+        standard[2] = \"ZL4VS2/6QCWNGgEojnwxyg==\".getBytes(\"UTF-8\");\n+        standard[3] = \"/3+PwBzbRxqMi1qTBhg/6A==\".getBytes(\"UTF-8\");\n+\n+        byte[][] urlSafe1 = new byte[4][];\n+        // regular padding (two '==' signs).\n+        urlSafe1[0] = \"lO2NAxnkSTOZVg-2dATTcA==\".getBytes(\"UTF-8\");\n+        urlSafe1[1] = \"K_fMJwH-Q5e0nr7tWsxwkA==\".getBytes(\"UTF-8\");\n+        urlSafe1[2] = \"ZL4VS2_6QCWNGgEojnwxyg==\".getBytes(\"UTF-8\");\n+        urlSafe1[3] = \"_3-PwBzbRxqMi1qTBhg_6A==\".getBytes(\"UTF-8\");\n+\n+        byte[][] urlSafe2 = new byte[4][];\n+        // single padding (only one '=' sign).\n+        urlSafe2[0] = \"lO2NAxnkSTOZVg-2dATTcA=\".getBytes(\"UTF-8\");\n+        urlSafe2[1] = \"K_fMJwH-Q5e0nr7tWsxwkA=\".getBytes(\"UTF-8\");\n+        urlSafe2[2] = \"ZL4VS2_6QCWNGgEojnwxyg=\".getBytes(\"UTF-8\");\n+        urlSafe2[3] = \"_3-PwBzbRxqMi1qTBhg_6A=\".getBytes(\"UTF-8\");\n+\n+        byte[][] urlSafe3 = new byte[4][];\n+        // no padding (no '=' signs).        \n+        urlSafe3[0] = \"lO2NAxnkSTOZVg-2dATTcA\".getBytes(\"UTF-8\");\n+        urlSafe3[1] = \"K_fMJwH-Q5e0nr7tWsxwkA\".getBytes(\"UTF-8\");\n+        urlSafe3[2] = \"ZL4VS2_6QCWNGgEojnwxyg\".getBytes(\"UTF-8\");\n+        urlSafe3[3] = \"_3-PwBzbRxqMi1qTBhg_6A\".getBytes(\"UTF-8\");\n+\n+        for (int i = 0; i < 4; i++) {\n+            byte[] encodedStandard = Base64.encodeBase64(ids[i]);\n+            byte[] encodedUrlSafe = Base64.encodeBase64URLSafe(ids[i]);\n+            byte[] decodedStandard = Base64.decodeBase64(standard[i]);\n+            byte[] decodedUrlSafe1 = Base64.decodeBase64(urlSafe1[i]);\n+            byte[] decodedUrlSafe2 =Base64.decodeBase64(urlSafe2[i]);\n+            byte[] decodedUrlSafe3 =Base64.decodeBase64(urlSafe3[i]);             \n+\n+            // Very important debugging output should anyone\n+            // ever need to delve closely into this stuff.\n+            if (false) {\n+                System.out.println(\"reference: [\" + new String(Hex.encodeHex(ids[i])) + \"]\");\n+                System.out.println(\"standard:  [\" + new String(Hex.encodeHex(decodedStandard)) + \"] From: [\" + new String(standard[i], \"UTF-8\") + \"]\");\n+                System.out.println(\"safe1:     [\" + new String(Hex.encodeHex(decodedUrlSafe1)) + \"] From: [\" + new String(urlSafe1[i], \"UTF-8\") + \"]\");\n+                System.out.println(\"safe2:     [\" + new String(Hex.encodeHex(decodedUrlSafe2)) + \"] From: [\" + new String(urlSafe2[i], \"UTF-8\") + \"]\");\n+                System.out.println(\"safe3:     [\" + new String(Hex.encodeHex(decodedUrlSafe3)) + \"] From: [\" + new String(urlSafe3[i], \"UTF-8\") + \"]\");\n+            }\n+\n+            assertTrue(\"standard encode uuid\", Arrays.equals(encodedStandard, standard[i]));\n+            assertTrue(\"url-safe encode uuid\", Arrays.equals(encodedUrlSafe, urlSafe3[i]));\n+            assertTrue(\"standard decode uuid\", Arrays.equals(decodedStandard, ids[i]));\n+            assertTrue(\"url-safe1 decode uuid\", Arrays.equals(decodedUrlSafe1, ids[i]));\n+            assertTrue(\"url-safe2 decode uuid\", Arrays.equals(decodedUrlSafe2, ids[i]));\n+            assertTrue(\"url-safe3 decode uuid\", Arrays.equals(decodedUrlSafe3, ids[i]));\n+        }\n+    }\n+\n     // -------------------------------------------------------- Private Methods\n \n     private String toString(byte[] data) {", "timestamp": 1247517452, "metainfo": ""}