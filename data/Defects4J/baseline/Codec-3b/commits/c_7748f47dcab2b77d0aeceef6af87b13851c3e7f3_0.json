{"sha": "7748f47dcab2b77d0aeceef6af87b13851c3e7f3", "log": "Fixed a number of checkstyle problems - from around 270 checkstyle issues to 16   ", "commit": "\n--- a/src/java/org/apache/commons/codec/base64/Base64.java\n+++ b/src/java/org/apache/commons/codec/base64/Base64.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/base64/Attic/Base64.java,v 1.1 2003/04/25 17:50:56 tobrien Exp $\n- * $Revision: 1.1 $\n- * $Date: 2003/04/25 17:50:56 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/base64/Attic/Base64.java,v 1.2 2003/05/29 23:03:28 tobrien Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/05/29 23:03:28 $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * 1996. Available at: http://www.ietf.org/rfc/rfc2045.txt\n  * </p>\n  * @author Jeffrey Rodriguez\n- * @version $Revision: 1.1 $ $Date: 2003/04/25 17:50:56 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/29 23:03:28 $\n  *\n  * @deprecated This class has been replaced by \n  *             {@link org.apache.commons.codec.binary.Base64}\n public final class Base64 {\n \n     protected static final String DEFAULT_CHAR_ENCODING = \"ISO-8859-1\";\n-    private static final int BASELENGTH = 255;\n-    private static final int LOOKUPLENGTH = 64;\n-    private static final int TWENTYFOURBITGROUP = 24;\n-    private static final int EIGHTBIT = 8;\n-    private static final int SIXTEENBIT = 16;\n-    private static final int SIXBIT = 6;\n-    private static final int FOURBYTE = 4;\n-    private static final int SIGN = -128;\n-    private static final byte PAD = (byte) '=';\n+\n+    /**\n+     * The bsae length\n+     */\n+    static final int BASELENGTH = 255;\n+\n+    /**\n+     * Lookup length\n+     */\n+    static final int LOOKUPLENGTH = 64;\n+\n+    /**\n+     * Used to calculate the number of bits in a byte.\n+     */\n+    static final int EIGHTBIT = 8;\n+\n+    /**\n+     * Used when encoding something which has fewer than 24 bits\n+     */\n+    static final int SIXTEENBIT = 16;\n+\n+    /**\n+     * Constant used to determine how many bits data contains\n+     */\n+    static final int TWENTYFOURBITGROUP = 24;\n+\n+    /**\n+     * Used to get the number of Quadruples\n+     */\n+    static final int FOURBYTE = 4;\n+\n+    /**\n+     * Used to test the sign of a byte\n+     */\n+    static final int SIGN = -128;\n+    \n+    /**\n+     * Byte used to pad output\n+     */\n+    static final byte PAD = (byte) '=';\n+\n+    // Create arrays to hold the base64 characters and a \n+    // lookup for base64 chars\n+    private static byte[] base64Alphabet = new byte[BASELENGTH];\n+\n     private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n-    private static byte[] base64Alphabet = new byte[BASELENGTH];\n+    \n+    /**\n+     * Lookup table\n+     */\n     private static byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n \n     static {\n \n     }\n \n+    /**\n+     * Tests to see whether the bytes of this string are\n+     * Base64\n+     *\n+     * @param isValidString String to test\n+     * @return trus if String is base64\n+     */\n     public static boolean isBase64(String isValidString) {\n         return (isBase64(isValidString.getBytes()));\n     }\n \n-\n+    /**\n+     * Tests a byte to see whether it falls within the Base64\n+     * alphabet (or if it is a padding character).\n+     *\n+     * @param octect byte to test\n+     * @return true if byte is in alphabet or padding\n+     */\n     public static boolean isBase64(byte octect) {\n         // Should we ignore white space?\n         return (octect == PAD || base64Alphabet[octect] != -1);\n     }\n \n-\n+    /**\n+     * Tests byte array to see if all characters are within the\n+     * Base64 alphabet\n+     *\n+     * @param arrayOctect A byte[] to test\n+     * @return true if all data falls within the Base64 alphabet OR if the\n+     *         array is empty.\n+     */\n     public static boolean isBase64(byte[] arrayOctect) {\n         int length = arrayOctect.length;\n         if (length == 0) {\n         if (fewerThan24bits != 0) {\n             //data not divisible by 24 bit\n             encodedData = new byte[(numberTriplets + 1) * 4];\n-        }\n-        else {\n+        } else {\n             // 16 or 8 bit \n             encodedData = new byte[numberTriplets * 4];\n         }\n                 : (byte) ((b3) >> 6 ^ 0xfc);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n+                                                                 | (k << 4)];\n+            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) \n+                                                                 | val3];\n             encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n         }\n \n             encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n             encodedData[encodedIndex + 2] = PAD;\n             encodedData[encodedIndex + 3] = PAD;\n-        } \n-        else if (fewerThan24bits == SIXTEENBIT) {\n+        } else if (fewerThan24bits == SIXTEENBIT) {\n             b1 = binaryData[dataIndex];\n             b2 = binaryData[dataIndex + 1];\n             l = (byte) (b2 & 0x0f);\n                 : (byte) ((b2) >> 4 ^ 0xf0);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n+                                                                 | (k << 4)];\n             encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n             encodedData[encodedIndex + 3] = PAD;\n         }\n     public static String encode(String data) {\n          try {\n              return encode(data, DEFAULT_CHAR_ENCODING);\n-         }\n-         catch (UnsupportedEncodingException uee) {\n+         } catch (UnsupportedEncodingException uee) {\n              throw new IllegalStateException(uee.toString());\n          }\n      }\n      *\n      * @param data String of data to convert\n      * @param charEncoding the character encoding to use when converting\n-     * a String to a byte[]\n+     *                     a String to a byte[]\n      * @return Base64-encoded String\n      */\n     public static String encode(String data, String charEncoding)\n-        throws UnsupportedEncodingException \n-    {\n+        throws UnsupportedEncodingException {\n \n         // Check arguments\n         if (data == null) {\n         OutputStreamWriter osw = new OutputStreamWriter(bos, charEncoding);\n         try {\n             osw.write(data);\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new RuntimeException(ioe.toString());\n         }\n \n         bos = new ByteArrayOutputStream(encodedData.length);\n         try {\n             bos.write(encodedData);\n-        }\n-        catch (IOException ioe) {\n+        } catch (IOException ioe) {\n             throw new RuntimeException(ioe.toString());\n         }\n \n     /**\n      * Decodes Base64 data into octects\n      *\n-     * @param binaryData Byte array containing Base64 data\n+     * @param base64Data Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decode(byte[] base64Data) {\n                 b4 = base64Alphabet[marker1];\n \n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n+                                                        | ((b3 >> 2) & 0xf));\n                 decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } \n-            else if (marker0 == PAD) {\n+            } else if (marker0 == PAD) {\n                 //Two PAD e.g. 3c[Pad][Pad]\n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } \n-            else if (marker1 == PAD) {\n+            } else if (marker1 == PAD) {\n                 //One PAD e.g. 3cQ[Pad]\n                 b3 = base64Alphabet[marker0];\n \n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n+                                                        | ((b3 >> 2) & 0xf));\n             }\n             encodedIndex += 3;\n         }\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/binary/Base64.java,v 1.3 2003/05/14 02:40:18 tobrien Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/05/14 02:40:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/binary/Base64.java,v 1.4 2003/05/29 23:03:28 tobrien Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/05/29 23:03:28 $\n   *\n   * ====================================================================\n   *\n   * @author <a href=\"dlr@apache.org\">Daniel Rall</a>\n   * @author <a href=\"m.redington@ucl.ac.uk\">Martin Redington</a>\n   * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n   * @since 1.0-dev\n-  *\n-  * @todo Add more documentation\n   */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n \n-    // Create constants pertaining to the chunk requirement\n+    /**\n+     * Chunk size according to RFC 2045\n+     */\n     static final int CHUNK_SIZE = 76;\n+\n+    /**\n+     * Chunk separator, we use a newline to separate chunks\n+     * of encoded data (if you ask for it to be chunked)\n+     */\n     static final byte[] CHUNK_SEPARATOR = \"\\n\".getBytes();\n \n-    // Create numerical and byte constants \n+    /**\n+     * The bsae length\n+     */\n     static final int BASELENGTH = 255;\n+\n+    /**\n+     * Lookup length\n+     */\n     static final int LOOKUPLENGTH = 64;\n+\n+    /**\n+     * Used to calculate the number of bits in a byte.\n+     */\n+    static final int EIGHTBIT = 8;\n+\n+    /**\n+     * Used when encoding something which has fewer than 24 bits\n+     */\n+    static final int SIXTEENBIT = 16;\n+\n+    /**\n+     * Constant used to determine how many bits data contains\n+     */\n     static final int TWENTYFOURBITGROUP = 24;\n-    static final int EIGHTBIT = 8;\n-    static final int SIXTEENBIT = 16;\n-    static final int SIXBIT = 6;\n+\n+    /**\n+     * Used to get the number of Quadruples\n+     */\n     static final int FOURBYTE = 4;\n+\n+    /**\n+     * Used to test the sign of a byte\n+     */\n     static final int SIGN = -128;\n+    \n+    /**\n+     * Byte used to pad output\n+     */\n     static final byte PAD = (byte) '=';\n \n     // Create arrays to hold the base64 characters and a \n     private static boolean isBase64(byte octect) {\n         if (octect == PAD) {\n             return true;\n-        } \n-        else if (base64Alphabet[octect] == -1) {\n+        } else if (base64Alphabet[octect] == -1) {\n             return false;\n-        } \n-        else {\n+        } else {\n             return true;\n         }\n     }\n \n+    /**\n+     * This array tests a given byte array to see if it contains\n+     * only valid characters within the Base64 alphabet.\n+     *\n+     * @param arrayOctect byte array to test\n+     * @return true if all bytes are valid characters in the Base64\n+     *         alphabet or if the byte array is empty; false, otherwise\n+     */\n     public static boolean isArrayByteBase64(byte[] arrayOctect) {\n \n         arrayOctect = discardWhitespace(arrayOctect);\n         return true;\n     }\n \n-\n+    /**\n+     * Encodes binary data using the base64 algorithm (this\n+     * does not \"chunk\" the output).\n+     *\n+     * @param binaryData binary data to encode\n+     * @return Base64 characters\n+     */\n     public static byte[] encodeBase64(byte[] binaryData) {\n         return (encodeBase64(binaryData, false));\n     }\n \n+    /**\n+     * Encodes binary data using the base64 algorithm and chunks\n+     * the encoded output into 76 character blocks\n+     *\n+     * @param binaryData binary data to encode\n+     * @return Base64 characters chunked in 76 character blocks\n+     */\n     public static byte[] encodeBase64Chunked(byte[] binaryData) {\n         return (encodeBase64(binaryData, true));\n     }\n \n+\n+    /**\n+     * Decodes an Object using the base64 algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Decoder interface, and will throw a DecoderException if the\n+     * supplied object is not of type byte[].\n+     *\n+     * @param pObject Object to decode\n+     * @return An object (of type byte[]) containing the \n+     *         binary data which corresponds to the byte[] supplied.\n+     * @throws DecoderException if the parameter supplied is not\n+     *                          of type byte[]\n+     */\n     public Object decode(Object pObject) throws DecoderException {\n \n         Object result;\n                 \"Parameter supplied to \"\n                     + \"Base64 \"\n                     + \"decode is not a byte[]\");\n-        } \n-        else {\n+        } else {\n             result = decode((byte[]) pObject);\n         }\n \n \n     }\n \n+    /**\n+     * Decodes a byte[] containing containing\n+     * characters in the Base64 alphabet.\n+     *\n+     * @param pArray A byte array containing Base64 character data\n+     * @return a byte array containing binary data\n+     * @throws DecoderException if there is an Decoder specific exception\n+     *                          during the decoding process\n+     */\n     public byte[] decode(byte[] pArray) throws DecoderException {\n         byte[] result;\n         result = decodeBase64((byte[]) pArray);\n      * Encodes hex octects into Base64.\n      *\n      * @param binaryData Array containing binary data to encode.\n+     * @param isChunked if isChunked is true this encoder will chunk\n+     *                  the base64 output into 76 character blocks\n      * @return Base64-encoded data.\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n         if (fewerThan24bits != 0) {\n             //data not divisible by 24 bit\n             encodedDataLength = (numberTriplets + 1) * 4;\n-        } \n-        else {\n+        } else {\n             // 16 or 8 bit\n             encodedDataLength = numberTriplets * 4;\n         }\n             encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n             encodedData[encodedIndex + 2] = PAD;\n             encodedData[encodedIndex + 3] = PAD;\n-        } \n-        else if (fewerThan24bits == SIXTEENBIT) {\n+        } else if (fewerThan24bits == SIXTEENBIT) {\n \n             b1 = binaryData[dataIndex];\n             b2 = binaryData[dataIndex + 1];\n     /**\n      * Decodes Base64 data into octects\n      *\n-     * @param binaryData Byte array containing Base64 data\n+     * @param base64Data Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n             }\n             decodedData = new byte[lastData - numberQuadruple];\n         }\n-\n+        \n         for (int i = 0; i < numberQuadruple; i++) {\n             dataIndex = i * 4;\n             marker0 = base64Data[dataIndex + 2];\n             marker1 = base64Data[dataIndex + 3];\n-\n+            \n             b1 = base64Alphabet[base64Data[dataIndex]];\n             b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n+            \n             if (marker0 != PAD && marker1 != PAD) {\n                 //No PAD e.g 3cQl\n                 b3 = base64Alphabet[marker0];\n                 b4 = base64Alphabet[marker1];\n-\n+                \n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                 decodedData[encodedIndex + 1] =\n                     (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                 decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } \n-            else if (marker0 == PAD) {\n+            } else if (marker0 == PAD) {\n                 //Two PAD e.g. 3c[Pad][Pad]\n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } \n-            else if (marker1 == PAD) {\n+            } else if (marker1 == PAD) {\n                 //One PAD e.g. 3cQ[Pad]\n                 b3 = base64Alphabet[marker0];\n-\n+                \n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                 decodedData[encodedIndex + 1] =\n                     (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n         }\n         return decodedData;\n     }\n-\n+    \n     /**\n      * Discards any whitespace from a base-64 encoded block.\n      *\n     static byte[] discardWhitespace(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-\n+        \n         for (int i = 0; i < data.length; i++) {\n             switch (data[i]) {\n-                case (byte) ' ' :\n-                case (byte) '\\n' :\n-                case (byte) '\\r' :\n-                case (byte) '\\t' :\n+            case (byte) ' ' :\n+            case (byte) '\\n' :\n+            case (byte) '\\r' :\n+            case (byte) '\\t' :\n                     break;\n-                default:\n+            default:\n                     groomedData[bytesCopied++] = data[i];\n             }\n         }\n \n         return packedData;\n     }\n-    \n-\t/**\n-\t * Discards any characters outside of the base64 alphabet, per\n-\t * the requirements on page 25 of RFC 2045 - \"Any characters\n-\t * outside of the base64 alphabet are to be ignored in base64\n-\t * encoded data.\"\n-\t *\n-\t * @param data The base-64 encoded data to groom\n-\t * @return The data, less non-base64 characters (see RFC 2045).\n-\t */\n-\tstatic byte[] discardNonBase64(byte[] data) {\n-\t\tbyte groomedData[] = new byte[data.length];\n-\t\tint bytesCopied = 0;\n-\n-\t\tfor (int i = 0; i < data.length; i++) {\n-\t\t\tif( isBase64(data[i]) ) {\n-\t\t\t  groomedData[bytesCopied++] = data[i];\n-\t\t\t}\n-\t\t}\n-\n-\t\tbyte packedData[] = new byte[bytesCopied];\n-\n-\t\tSystem.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n-\t\treturn packedData;\n-\t}\n+\n+    /**\n+     * Discards any characters outside of the base64 alphabet, per\n+     * the requirements on page 25 of RFC 2045 - \"Any characters\n+     * outside of the base64 alphabet are to be ignored in base64\n+     * encoded data.\"\n+     *\n+     * @param data The base-64 encoded data to groom\n+     * @return The data, less non-base64 characters (see RFC 2045).\n+     */\n+    static byte[] discardNonBase64(byte[] data) {\n+        byte groomedData[] = new byte[data.length];\n+        int bytesCopied = 0;\n+\n+        for (int i = 0; i < data.length; i++) {\n+            if (isBase64(data[i])) {\n+                groomedData[bytesCopied++] = data[i];\n+            }\n+        }\n+\n+        byte packedData[] = new byte[bytesCopied];\n+\n+        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n+\n+        return packedData;\n+    }\n \n \n     // Implementation of the Encoder Interface\n \n     /**\n-     * encode an Object\n+     * Encodes an Object using the base64 algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the\n+     * supplied object is not of type byte[].\n+     *\n+     * @param pObject Object to encode\n+     * @return An object (of type byte[]) containing the \n+     *         base64 encoded data which corresponds to the byte[] supplied.\n+     * @throws EncoderException if the parameter supplied is not\n+     *                          of type byte[]\n      */\n     public Object encode(Object pObject) throws EncoderException {\n \n                 \"Parameter supplied to \"\n                     + \"Base64 \"\n                     + \"encode is not a byte[]\");\n-        } \n-        else {\n+        } else {\n             result = encode((byte[]) pObject);\n         }\n \n \n     }\n \n+    /**\n+     * Encodes a byte[] containing binary data, into a byte[] containing\n+     * characters in the Base64 alphabet.\n+     *\n+     * @param pArray a byte array containing binary data\n+     * @return A byte array containing only Base64 character data\n+     * @throws EncoderException if there is an Encoder specific exception\n+     *                          during the encoding process\n+     */\n     public byte[] encode(byte[] pArray) throws EncoderException {\n         return (encodeBase64(pArray, false));\n     }\n--- a/src/java/org/apache/commons/codec/binary/Hex.java\n+++ b/src/java/org/apache/commons/codec/binary/Hex.java\n \n \n     /**\n-       Converts an array of bytes into an array of characters representing the\n-       hexidecimal values of each byte in order. The returned array will be\n-       double the length of the passed array, as it takes two characters to\n-       represent any given byte.\n-    */\n+     * Converts an array of bytes into an array of characters representing the\n+     * hexidecimal values of each byte in order. The returned array will be\n+     * double the length of the passed array, as it takes two characters to\n+     * represent any given byte.\n+     *\n+     * @param data array of byte to convert to Hex characters\n+     * @return A char[] containing hexidecimal characters\n+     */\n     public static char[] encodeHex(byte[] data) {\n \n         int l = data.length;\n \n \n     /**\n-       Converts an array of characters representing hexidecimal values into an\n-       array of bytes of those same values. The returned array will be half the\n-       length of the passed array, as it takes two characters to represent any\n-       given byte. An exception is thrown if the passed char array has an odd\n-       number of elements.\n-    */\n+     * Converts an array of characters representing hexidecimal values into an\n+     * array of bytes of those same values. The returned array will be half the\n+     * length of the passed array, as it takes two characters to represent any\n+     * given byte. An exception is thrown if the passed char array has an odd\n+     * number of elements.\n+     * \n+     * @param data An array of characters containing hexidecimal digits\n+     * @return A byte array array containing binary data decoded from\n+     *         the supplied char array.\n+     * @throws Exception Thrown if an odd number of characters is supplied\n+     *                   to this function\n+     */\n     public static byte[] decodeHex(char[] data) throws Exception {\n \n         int l = data.length;\n--- a/src/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/java/org/apache/commons/codec/language/Metaphone.java\n  *  \"Hanging on the Metaphone\" by Lawrence Philips\n  *      <i>Computer Language</i> of Dec. 1990, p 39   \n  * \n- * @version $Revision: 1.1 $ $Date: 2003/04/25 17:50:56 $\n+ * @version $Revision: 1.2 $ $Date: 2003/05/29 23:03:29 $\n  * @author wbrogden@bga.com\n  * @author bayard@generationjava.com\n  * @author tobrien@transolutions.net\n  */\n public class Metaphone implements StringEncoder {\n \n+    /**\n+     * Five values in the English language \n+     */\n     private String vowels = \"AEIOU\" ;\n+\n+    /**\n+     * Variable used in Metaphone algorithm\n+     */\n     private String frontv = \"EIY\"   ;\n+\n+    /**\n+     * Variable used in Metaphone algorithm\n+     */\n     private String varson = \"CSPTG\" ;\n \n+    /**\n+     * The max code length for metaphone is 4\n+     */\n     private int maxCodeLen = 4 ;\n \n+    /**\n+     * Creates an instance of the Metaphone encoder\n+     */\n     public Metaphone() {\n         super();\n     }\n      * All input is converted to upper case.\n      * Limitations: Input format is expected to be a single ASCII word\n      * with only characters in the A - Z range, no punctuation or numbers.\n-     */\n-    public String metaphone(String txt){\n+     *\n+     * @param txt String to find the metaphone code for\n+     * @return A metaphone code corresponding to the String supplied\n+     */\n+    public String metaphone(String txt) {\n         int mtsz = 0  ;\n         boolean hard = false ;\n-        if ((txt == null) ||\n-            (txt.length() == 0)) return \"\" ;\n+        if ((txt == null) \n+            || (txt.length() == 0)) {\n+            return \"\" ;\n+        }\n         // single character is itself\n-        if (txt.length() == 1) return txt.toUpperCase() ;\n+        if (txt.length() == 1) {\n+            return txt.toUpperCase() ;\n+        }\n       \n         char[] inwd = txt.toUpperCase().toCharArray() ;\n       \n         StringBuffer local = new StringBuffer(40); // manipulate\n         StringBuffer code = new StringBuffer(10) ; //   output\n         // handle initial 2 characters exceptions\n-        switch(inwd[0]){\n-        case 'K': case 'G' : case 'P' : /* looking for KN, etc*/\n-            if (inwd[1] == 'N')local.append(inwd, 1, inwd.length - 1);\n-            else local.append(inwd);\n+        switch(inwd[0]) {\n+        case 'K' : \n+        case 'G' : \n+        case 'P' : /* looking for KN, etc*/\n+            if (inwd[1] == 'N') {\n+                local.append(inwd, 1, inwd.length - 1);\n+            } else {\n+                local.append(inwd);\n+            }\n             break;\n         case 'A': /* looking for AE */\n-            if (inwd[1] == 'E')local.append(inwd, 1, inwd.length - 1);\n-            else local.append(inwd);\n+            if (inwd[1] == 'E') {\n+                local.append(inwd, 1, inwd.length - 1);\n+            } else {\n+                local.append(inwd);\n+            }\n             break;\n         case 'W' : /* looking for WR or WH */\n-            if (inwd[1] == 'R'){   // WR -> R\n-                local.append(inwd, 1, inwd.length - 1); break ;\n+            if (inwd[1] == 'R') {   // WR -> R\n+                local.append(inwd, 1, inwd.length - 1); \n+                break ;\n             }\n-            if (inwd[1] == 'H'){\n+            if (inwd[1] == 'H') {\n                 local.append(inwd, 1, inwd.length - 1);\n-                local.setCharAt(0,'W'); // WH -> W\n+                local.setCharAt(0, 'W'); // WH -> W\n+            } else {\n+                local.append(inwd);\n             }\n-            else local.append(inwd);\n             break;\n         case 'X' : /* initial X becomes S */\n-            inwd[0] = 'S' ;local.append(inwd);\n+            inwd[0] = 'S';\n+            local.append(inwd);\n             break ;\n         default :\n             local.append(inwd);\n         } // now local has working string with initials fixed\n+\n         int wdsz = local.length();\n         int n = 0 ;\n-        while((mtsz < maxCodeLen) && // max code size of 4 works well\n-              (n < wdsz)){\n+\n+        while ((mtsz < maxCodeLen) // max code size of 4 works well\n+               && (n < wdsz)) {\n             char symb = local.charAt(n) ;\n             // remove duplicate letters except C\n-            if ((symb != 'C') &&\n-                (n > 0) && (local.charAt(n - 1) == symb)) n++ ;\n-            else{ // not dup\n-                switch(symb){\n+            if ((symb != 'C') \n+                && (n > 0) && (local.charAt(n - 1) == symb)) {\n+                n++ ;\n+            } else { // not dup\n+                switch(symb) {\n                 case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n-                    if (n == 0) { code.append(symb);mtsz++;\n+                    if (n == 0) { \n+                        code.append(symb);\n+                        mtsz++;\n                     }\n                     break ; // only use vowel if leading char\n                 case 'B' :\n-                    if ((n > 0) &&\n-                        !(n + 1 == wdsz) && // not MB at end of word\n-                        (local.charAt(n - 1) == 'M')) {\n+                    if ((n > 0) \n+                        && !(n + 1 == wdsz) // not MB at end of word\n+                        && (local.charAt(n - 1) == 'M')) {\n                         code.append(symb);\n-                    }\n-                    else code.append(symb);\n-                    mtsz++ ;\n-                    break ;\n+                    } else {\n+                        code.append(symb);\n+                    }\n+                    mtsz++;\n+                    break;\n                 case 'C' : // lots of C special cases\n                     /* discard if SCI, SCE or SCY */\n-                    if ((n > 0) &&\n-                        (local.charAt(n-1) == 'S') &&\n-                        (n + 1 < wdsz) &&\n-                        (frontv.indexOf(local.charAt(n + 1)) >= 0)){ break ;}\n+                    if ((n > 0) \n+                        && (local.charAt(n - 1) == 'S') \n+                        && (n + 1 < wdsz) \n+                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)) { \n+                        break ;\n+                    }\n                     tmpS = local.toString();\n                     if (tmpS.indexOf(\"CIA\", n) == n) { // \"CIA\" -> X\n                         code.append('X'); mtsz++; break ;\n                     }\n-                    if ((n + 1 < wdsz) &&\n-                        (frontv.indexOf(local.charAt(n+1))>= 0)){\n-                        code.append('S');mtsz++; break ; // CI,CE,CY -> S\n-                    }\n-                    if ((n > 0) &&\n-                        (tmpS.indexOf(\"SCH\",n-1)== n-1)){ // SCH->sk\n-                        code.append('K') ; mtsz++;break ;\n-                    }\n-                    if (tmpS.indexOf(\"CH\", n) == n){ // detect CH\n-                        if ((n == 0) &&\n-                            (wdsz >= 3) &&    // CH consonant -> K consonant\n-                            (vowels.indexOf(local.charAt(2)) < 0)){\n+                    if ((n + 1 < wdsz) \n+                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)) {\n+                        code.append('S');\n+                        mtsz++; \n+                        break ; // CI,CE,CY -> S\n+                    }\n+                    if ((n > 0) \n+                        && (tmpS.indexOf(\"SCH\", n - 1) == n - 1)) { // SCH->sk\n+                        code.append('K') ; \n+                        mtsz++;\n+                        break ;\n+                    }\n+                    if (tmpS.indexOf(\"CH\", n) == n) { // detect CH\n+                        if ((n == 0) \n+                            && (wdsz >= 3)     // CH consonant -> K consonant\n+                            && (vowels.indexOf(local.charAt(2)) < 0)) {\n                             code.append('K');\n-                        }\n-                        else { code.append('X'); // CHvowel -> X\n+                        } else { \n+                            code.append('X'); // CHvowel -> X\n                         }\n                         mtsz++;\n-                    }\n-                    else { code.append('K');mtsz++;\n+                    } else { \n+                        code.append('K');\n+                        mtsz++;\n                     }\n                     break ;\n                 case 'D' :\n-                    if ((n + 2 < wdsz)&&  // DGE DGI DGY -> J\n-                        (local.charAt(n+1) == 'G')&&\n-                        (frontv.indexOf(local.charAt(n+2))>= 0)){\n+                    if ((n + 2 < wdsz)   // DGE DGI DGY -> J\n+                        && (local.charAt(n + 1) == 'G')\n+                        && (frontv.indexOf(local.charAt(n + 2)) >= 0)) {\n                         code.append('J'); n += 2 ;\n-                    }\n-                    else { code.append('T');\n+                    } else { \n+                        code.append('T');\n                     }\n                     mtsz++;\n                     break ;\n                 case 'G' : // GH silent at end or before consonant\n-                    if ((n + 2 == wdsz)&&\n-                        (local.charAt(n+1) == 'H')) break ;\n-                    if ((n + 2 < wdsz) &&\n-                        (local.charAt(n+1) == 'H')&&\n-                        (vowels.indexOf(local.charAt(n+2)) < 0)) break ;\n+                    if ((n + 2 == wdsz)\n+                        && (local.charAt(n + 1) == 'H')) {\n+                        break;\n+                    }\n+                    if ((n + 2 < wdsz) \n+                        && (local.charAt(n + 1) == 'H')\n+                        && (vowels.indexOf(local.charAt(n + 2)) < 0)) {\n+                        break;\n+                    }\n                     tmpS = local.toString();\n-                    if ((n > 0) &&\n-                        (tmpS.indexOf(\"GN\", n) == n)||\n-                        (tmpS.indexOf(\"GNED\",n) == n)) break ; // silent G\n-                    if ((n > 0) &&\n-                        (local.charAt(n-1) == 'G')) hard = true ;\n-                    else hard = false ;\n-                    if ((n+1 < wdsz) &&\n-                        (frontv.indexOf(local.charAt(n+1)) >= 0)&&\n-                        (!hard)) code.append('J');\n-                    else code.append('K');\n+                    if ((n > 0) \n+                        && (tmpS.indexOf(\"GN\", n) == n)\n+                        || (tmpS.indexOf(\"GNED\", n) == n)) {\n+                        break; // silent G\n+                    }\n+                    if ((n > 0) \n+                        && (local.charAt(n - 1) == 'G')) {\n+                        hard = true ;\n+                    } else {\n+                        hard = false ;\n+                    }\n+                    if ((n + 1 < wdsz) \n+                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)\n+                        && (!hard)) {\n+                        code.append('J');\n+                    } else {\n+                        code.append('K');\n+                    }\n                     mtsz++;\n                     break ;\n                 case 'H':\n-                    if (n + 1 == wdsz) break ; // terminal H\n-                    if ((n > 0) &&\n-                        (varson.indexOf(local.charAt(n-1)) >= 0)) break ;\n-                    if (vowels.indexOf(local.charAt(n+1)) >=0){\n-                        code.append('H') ; mtsz++;// Hvowel\n+                    if (n + 1 == wdsz) {\n+                        break ; // terminal H\n+                    }\n+                    if ((n > 0) \n+                        && (varson.indexOf(local.charAt(n - 1)) >= 0)) {\n+                        break;\n+                    }\n+                    if (vowels.indexOf(local.charAt(n + 1)) >= 0) {\n+                        code.append('H'); \n+                        mtsz++;// Hvowel\n                     }\n                     break;\n-                case 'F': case 'J' : case 'L' :\n-                case 'M': case 'N' : case 'R' :\n-                    code.append(symb); mtsz++; break ;\n+                case 'F': \n+                case 'J' : \n+                case 'L' :\n+                case 'M': \n+                case 'N' : \n+                case 'R' :\n+                    code.append(symb); \n+                    mtsz++; \n+                    break;\n                 case 'K' :\n-                    if (n > 0){ // not initial\n-                        if (local.charAt(n -1) != 'C') {\n+                    if (n > 0) { // not initial\n+                        if (local.charAt(n - 1) != 'C') {\n                             code.append(symb);\n                         }\n-                    }\n-                    else   code.append(symb); // initial K\n+                    } else {\n+                        code.append(symb); // initial K\n+                    }\n                     mtsz++ ;\n                     break ;\n                 case 'P' :\n-                    if ((n + 1 < wdsz) &&  // PH -> F\n-                        (local.charAt(n+1) == 'H'))code.append('F');\n-                    else code.append(symb);\n+                    if ((n + 1 < wdsz) \n+                        && (local.charAt(n + 1) == 'H')) {\n+                        // PH -> F\n+                        code.append('F');\n+                    } else {\n+                        code.append(symb);\n+                    }\n                     mtsz++;\n                     break ;\n                 case 'Q' :\n-                    code.append('K');mtsz++; break ;\n+                    code.append('K');\n+                    mtsz++; \n+                    break;\n                 case 'S' :\n                     tmpS = local.toString();\n-                    if ((tmpS.indexOf(\"SH\", n)== n) ||\n-                        (tmpS.indexOf(\"SIO\",n)== n) ||\n-                        (tmpS.indexOf(\"SIA\",n)== n)) code.append('X');\n-                    else code.append('S');\n-                    mtsz++ ;\n-                    break ;\n+                    if ((tmpS.indexOf(\"SH\", n) == n) \n+                        || (tmpS.indexOf(\"SIO\", n) == n) \n+                        || (tmpS.indexOf(\"SIA\", n) == n)) {\n+                        code.append('X');\n+                    } else {\n+                        code.append('S');\n+                    }\n+                    mtsz++;\n+                    break;\n                 case 'T' :\n                     tmpS = local.toString(); // TIA TIO -> X\n-                    if ((tmpS.indexOf(\"TIA\",n)== n)||\n-                        (tmpS.indexOf(\"TIO\",n)== n)){\n-                        code.append('X'); mtsz++; break;\n-                    }\n-                    if (tmpS.indexOf(\"TCH\",n)==n) break;\n+                    if ((tmpS.indexOf(\"TIA\", n) == n) \n+                        || (tmpS.indexOf(\"TIO\", n) == n)) {\n+                        code.append('X'); \n+                        mtsz++; \n+                        break;\n+                    }\n+                    if (tmpS.indexOf(\"TCH\", n) == n) {\n+                        break;\n+                    }\n                     // substitute numeral 0 for TH (resembles theta after all)\n-                    if (tmpS.indexOf(\"TH\", n)==n) code.append('0');\n-                    else code.append('T');\n+                    if (tmpS.indexOf(\"TH\", n) == n) {\n+                        code.append('0');\n+                    } else {\n+                        code.append('T');\n+                    }\n                     mtsz++ ;\n                     break ;\n                 case 'V' :\n                     code.append('F'); mtsz++;break ;\n                 case 'W' : case 'Y' : // silent if not followed by vowel\n-                    if ((n+1 < wdsz) &&\n-                        (vowels.indexOf(local.charAt(n + 1)) >= 0)) {\n+                    if ((n + 1 < wdsz) \n+                     && (vowels.indexOf(local.charAt(n + 1)) >= 0)) {\n                         code.append(symb);\n                         mtsz++;\n                     }\n             if (mtsz > 4) { code.setLength(4); }\n         }\n         return code.toString();\n-    } // end static method metaPhone()\n+    } \n     \n+    \n+    /**\n+     * Encodes an Object using the metaphone algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the\n+     * supplied object is not of type java.lang.String.\n+     *\n+     * @param pObject Object to encode\n+     * @return An object (or type java.lang.String) containing the \n+     *         metaphone code which corresponds to the String supplied.\n+     * @throws EncoderException if the parameter supplied is not\n+     *                          of type java.lang.String\n+     */\n     public Object encode(Object pObject) throws EncoderException {\n         Object result;\n-\n         if (!(pObject instanceof java.lang.String)) {\n             throw new EncoderException(\"Parameter supplied to Metaphone \" \n                                        + \"encode is not of type \" \n                                        + \"java.lang.String\"); \n-\t} \n-        else {\n+        } else {\n             result = metaphone((String) pObject);\n         }\n-\n         return result;\n     }\n \n+    /**\n+     * Encodes a String using the Metaphone algorithm. \n+     *\n+     * @param pString String object to encode\n+     * @return The metaphone code corresponding to the String supplied\n+     * @throws EncoderException thrown if a Metaphone specific exception\n+     *                          is encountered.\n+     */\n     public String encode(String pString) throws EncoderException {\n         return (metaphone(pString));   \n     }\n \n     /**\n-     * Are the metaphones of two strings the same.\n+     * Tests is the metaphones of two strings are identical.\n+     *\n+     * @param str1 First of two strings to compare\n+     * @param str2 Second of two strings to compare\n+     * @return true if the metaphones of these strings are identical, \n+     *         false otherwise.\n      */\n     public boolean isMetaphoneEqual(String str1, String str2) {\n         return metaphone(str1).equals(metaphone(str2));\n      * Returns the maxCodeLen.\n      * @return int\n      */\n-    public int getMaxCodeLen() {\n-        return maxCodeLen;\n-    }\n+    public int getMaxCodeLen() { return maxCodeLen; }\n \n     /**\n      * Sets the maxCodeLen.\n      * @param maxCodeLen The maxCodeLen to set\n      */\n-    public void setMaxCodeLen(int maxCodeLen) {\n-        this.maxCodeLen = maxCodeLen;\n-    }\n+    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n \n }\n--- a/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n+++ b/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n  * \n  * @author tobrien@transolutions.net\n  * @author ggregory@seagullsw.com\n- * @version $Revision: 1.4 $ $Date: 2003/05/29 21:14:59 $\n+ * @version $Revision: 1.5 $ $Date: 2003/05/29 23:03:29 $\n  */\n public class RefinedSoundex implements StringEncoder {\n \n+    /**\n+     * RefinedSoundex is *refined* for a number of\n+     * reasons one being that the mappings have been\n+     * altered.  This implementation contains default\n+     * mappings for US English.\n+     */\n     public static final char[] US_ENGLISH_MAPPING =\n         \"01360240043788015936020505\".toCharArray();\n \n+    /**\n+     * This static variable contains an instance of the\n+     * RefinedSoundex using the US_ENGLISH mapping.\n+     */\n     public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\n     \n+    /**\n+     * Every letter of the alphabet is \"mapped\" to a numerical \n+     * value.  This char array holds the values to which each\n+     * letter is mapped.  This implementation contains a default\n+     * map for US_ENGLISH\n+     */\n     private char[] soundexMapping;\n \n+    /**\n+     * Creates an instance of the RefinedSoundex object using the\n+     * default US English mapping.\n+     */\n     public RefinedSoundex() {\n         this(US_ENGLISH_MAPPING);\n     }\n \n+    /**\n+     * Creates a refined soundex instance using a custom mapping.  This\n+     * constructor can be used to customize the mapping, and/or possibly\n+     * provide an internationalized mapping for a non-Western character\n+     * set.\n+     *\n+     * @param mapping Mapping array to use when finding the corresponding\n+     *                code for a given character\n+     */\n     public RefinedSoundex(char[] mapping) {\n         this.soundexMapping = mapping;\n     }\n \n     /**\n-     * Get the SoundEx value of a string.\n-     * This implementation is taken from the code-snippers on \n-     * http://www.sourceforge.net/\n+     * Retreives the Refined Soundex code for a given String object.\n+     *\n+     * @param str String to encode using the Refined Soundex algorithm\n+     * @return A soundex code for the String supplied\n      */\n     public String soundex(String str) {\n         if (null == str || str.length() == 0) { return str; }\n             current = getMappingCode(str.charAt(i));\n             if (current == last) {\n                 continue;\n-            } \n-            else if (current != 0) {\n+            } else if (current != 0) {\n                 sBuf.append(current);   \n             }\n             \n         return sBuf.toString();\n     }\n \n+    /**\n+     * Encodes a String using the refined soundex algorithm. \n+     *\n+     * @param pString A String object to encode\n+     * @return A Soundex code corresponding to the String supplied\n+     * @throws EncoderException throws exception if there is an\n+     *                          encoding-specific problem\n+     */\n     public String encode(String pString) throws EncoderException {\n         return (soundex(pString));   \n     }\n \n+    /**\n+     * Encodes an Object using the refined soundex algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the\n+     * supplied object is not of type java.lang.String.\n+     *\n+     * @param pObject Object to encode\n+     * @return An object (or type java.lang.String) containing the \n+     *         refined soundex code which corresponds to the String supplied.\n+     * @throws EncoderException if the parameter supplied is not\n+     *                          of type java.lang.String\n+     */\n     public Object encode(Object pObject) throws EncoderException {\n-\n         Object result;\n-\n         if (!(pObject instanceof java.lang.String)) {\n             throw new EncoderException(\"Parameter supplied to \" \n                                        + \"RefinedSoundex \" \n                                        + \"encode is not of type \" \n                                        + \"java.lang.String\"); \n-        } \n-        else {\n+        } else {\n             result = soundex((String) pObject);\n         }\n-\n         return result;\n-\n-    }\n-\n-\n-    /**\n-     * Used internally by the SoundEx algorithm.\n+    }\n+\n+    /**\n+     * Returns the mapping code for a given character.  The mapping\n+     * codes are maintained in an internal char array named soundexMapping,\n+     * and the default values of these mappings are US English.\n+     *\n+     * @param c char to get mapping for\n+     * @return A character (really a numeral) to return for the given char\n      */\n     private char getMappingCode(char c) {\n         if (!Character.isLetter(c)) {\n             return 0;\n-        } \n-        else {\n+        } else {\n             return soundexMapping[Character.toUpperCase(c) - 'A'];\n         }\n     }\n--- a/src/java/org/apache/commons/codec/language/Soundex.java\n+++ b/src/java/org/apache/commons/codec/language/Soundex.java\n  * relate similar names, but can also be used as a general purpose\n  * scheme to find word with similar phonemes. \n  * \n- * <!-- This link is broken: -->\n- * <!-- @see <a href=\"http://www.bluepoof.com/Soundex/info2.html\">http://www.bluepoof.com/Soundex/info2.html</a> -->\n- * \n  * @author bayard@generationjava.com\n  * @author tobrien@transolutions.net\n  * @author ggregory@seagullsw.com\n- * @version $Revision: 1.3 $ $Date: 2003/05/12 17:17:24 $\n- *\n- * @todo Internationalize Exception Messages\n+ * @version $Revision: 1.4 $ $Date: 2003/05/29 23:03:29 $\n  */\n public class Soundex implements StringEncoder {\n \n+    /**\n+     * This is a default mapping of the 26 letters used\n+     * in US english.\n+     */\n     public static final char[] US_ENGLISH_MAPPING =\n         \"01230120022455012623010202\".toCharArray();\n \n+    /**\n+     * This static variable contains an instance of the\n+     * Soundex using the US_ENGLISH mapping.\n+     */\n     public static final Soundex US_ENGLISH = new Soundex();\n     \n+    /**\n+     * Every letter of the alphabet is \"mapped\" to a numerical \n+     * value.  This char array holds the values to which each\n+     * letter is mapped.  This implementation contains a default\n+     * map for US_ENGLISH\n+     */\n     private char[] soundexMapping;\n+\n+    /**\n+     * The maximum length of a Soundex code - Soundex codes are\n+     * only four characters by definition.\n+     */\n     private int maxLength = 4;\n \n-\n+    /**\n+     * Creates an instance of the Soundex object using the default\n+     * US_ENGLISH mapping.\n+     */\n     public Soundex() {\n         this(US_ENGLISH_MAPPING);\n     }\n \n+    /**\n+     * Creates a soundex instance using a custom mapping.  This\n+     * constructor can be used to customize the mapping, and/or possibly\n+     * provide an internationalized mapping for a non-Western character\n+     * set.\n+     *\n+     * @param mapping Mapping array to use when finding the corresponding\n+     *                code for a given character\n+     */\n     public Soundex(char[] mapping) {\n         this.soundexMapping = mapping;\n     }\n \n     /**\n-     * Get the SoundEx value of a string.\n-     * This implementation is taken from the code-snippers on \n-     * http://www.sourceforge.net/\n+     * Retreives the Soundex code for a given String object.\n+     *\n+     * @param str String to encode using the Soundex algorithm\n+     * @return A soundex code for the String supplied\n      */\n     public String soundex(String str) {\n         if (null == str || str.length() == 0) { return str; }\n         return new String(out);\n     }\n \n+    /**\n+     * Encodes an Object using the soundex algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the\n+     * supplied object is not of type java.lang.String.\n+     *\n+     * @param pObject Object to encode\n+     * @return An object (or type java.lang.String) containing the \n+     *         soundex code which corresponds to the String supplied.\n+     * @throws EncoderException if the parameter supplied is not\n+     *                          of type java.lang.String\n+     */\n     public Object encode(Object pObject) throws EncoderException {\n \n         Object result;\n                                        + \"Soundex \" \n                                        + \"encode is not of type \" \n                                        + \"java.lang.String\"); \n-        } \n-        else {\n+        } else {\n             result = soundex((String) pObject);\n         }\n \n \n     }\n \n-\n+    /**\n+     * Encodes a String using the soundex algorithm. \n+     *\n+     * @param pString A String object to encode\n+     * @return A Soundex code corresponding to the String supplied\n+     * @throws EncoderException throws exception if there is an\n+     *                          encoding-specific problem\n+     */\n     public String encode(String pString) throws EncoderException {\n         return (soundex(pString));   \n     }\n \n     /**\n      * Used internally by the SoundEx algorithm.\n+     *\n+     * @param c character to use to retrieve mapping code\n+     * @return Mapping code for a particular character\n      */\n     private char getMappingCode(char c) {\n         if (!Character.isLetter(c)) {\n             return 0;\n-        } \n-        else {\n+        } else {\n             return soundexMapping[Character.toUpperCase(c) - 'A'];\n         }\n     }", "timestamp": 1054249409, "metainfo": ""}