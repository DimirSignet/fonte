{"sha": "f5185b0229f93097be2433386c2d4022e70545d1", "log": "[CODEC-61] Base64.EncodeBase64() throws NegativeArraySizeException on large files. Throws IllegalArgumentException when the input array needs an output array bigger than Integer.MAX_VALUE.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- */ \n+ */\n \n package org.apache.commons.codec.binary;\n \n /**\n  * Provides Base64 encoding and decoding as defined by RFC 2045.\n  * \n- * <p>This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> \n- * from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: \n- * Format of Internet Message Bodies</cite> by Freed and Borenstein.</p> \n- *\n+ * <p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ * \n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @author Apache Software Foundation\n  * @since 1.0-dev\n     /**\n      * Chunk size per RFC 2045 section 6.8.\n      * \n-     * <p>The {@value} character limit does not count the trailing CRLF, but counts \n-     * all other characters, including any equal signs.</p>\n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n      * \n      * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n      */\n      * Used to test the sign of a byte.\n      */\n     private static final int SIGN = -128;\n-    \n+\n     /**\n      * Byte used to pad output.\n      */\n      * </p>\n      */\n     private static final byte[] base64Alphabet = new byte[BASELENGTH];\n-    \n+\n     /**\n      * <p>\n      * Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n     /**\n      * Returns whether or not the <code>octect</code> is in the base 64 alphabet.\n      * \n-     * @param octect The value to test\n+     * @param octect\n+     *            The value to test\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     private static boolean isBase64(byte octect) {\n     }\n \n     /**\n-     * Tests a given byte array to see if it contains\n-     * only valid characters within the Base64 alphabet.\n-     *\n-     * @param arrayOctect byte array to test\n-     * @return <code>true</code> if all bytes are valid characters in the Base64\n-     *         alphabet or if the byte array is empty; false, otherwise\n+     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n+     * \n+     * @param arrayOctect\n+     *            byte array to test\n+     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n+     *         empty; false, otherwise\n      */\n     public static boolean isArrayByteBase64(byte[] arrayOctect) {\n \n     }\n \n     /**\n-     * Encodes binary data using the base64 algorithm but\n-     * does not chunk the output.\n-     *\n-     * @param binaryData binary data to encode\n+     * Encodes binary data using the base64 algorithm but does not chunk the output.\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n      * @return Base64 characters\n      */\n     public static byte[] encodeBase64(byte[] binaryData) {\n     }\n \n     /**\n-     * Encodes binary data using the base64 algorithm and chunks\n-     * the encoded output into 76 character blocks\n-     *\n-     * @param binaryData binary data to encode\n+     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n      * @return Base64 characters chunked in 76 character blocks\n      */\n     public static byte[] encodeBase64Chunked(byte[] binaryData) {\n         return encodeBase64(binaryData, true);\n     }\n \n-\n-    /**\n-     * Decodes an Object using the base64 algorithm.  This method\n-     * is provided in order to satisfy the requirements of the\n-     * Decoder interface, and will throw a DecoderException if the\n-     * supplied object is not of type byte[].\n-     *\n-     * @param pObject Object to decode\n-     * @return An object (of type byte[]) containing the \n-     *         binary data which corresponds to the byte[] supplied.\n-     * @throws DecoderException if the parameter supplied is not\n-     *                          of type byte[]\n+    /**\n+     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].\n+     * \n+     * @param pObject\n+     *            Object to decode\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.\n+     * @throws DecoderException\n+     *             if the parameter supplied is not of type byte[]\n      */\n     public Object decode(Object pObject) throws DecoderException {\n         if (!(pObject instanceof byte[])) {\n     }\n \n     /**\n-     * Decodes a byte[] containing containing\n-     * characters in the Base64 alphabet.\n-     *\n-     * @param pArray A byte array containing Base64 character data\n+     * Decodes a byte[] containing containing characters in the Base64 alphabet.\n+     * \n+     * @param pArray\n+     *            A byte array containing Base64 character data\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n     }\n \n     /**\n-     * Encodes binary data using the base64 algorithm, optionally\n-     * chunking the output into 76 character blocks.\n-     *\n-     * @param binaryData Array containing binary data to encode.\n-     * @param isChunked if <code>true</code> this encoder will chunk\n-     *                  the base64 output into 76 character blocks\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n      * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n-        int lengthDataBits = binaryData.length * EIGHTBIT;\n-        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n-        byte encodedData[] = null;\n-        int encodedDataLength = 0;\n-        int nbrChunks = 0;\n+        long binaryDataLength = binaryData.length;\n+        long lengthDataBits = binaryDataLength * EIGHTBIT;\n+        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n+        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n+        long encodedDataLengthLong = 0;\n+        int chunckCount = 0;\n \n         if (fewerThan24bits != 0) {\n-            //data not divisible by 24 bit\n-            encodedDataLength = (numberTriplets + 1) * 4;\n+            // data not divisible by 24 bit\n+            encodedDataLengthLong = (tripletCount + 1) * 4;\n         } else {\n             // 16 or 8 bit\n-            encodedDataLength = numberTriplets * 4;\n-        }\n-\n-        // If the output is to be \"chunked\" into 76 character sections, \n-        // for compliance with RFC 2045 MIME, then it is important to \n+            encodedDataLengthLong = tripletCount * 4;\n+        }\n+\n+        // If the output is to be \"chunked\" into 76 character sections,\n+        // for compliance with RFC 2045 MIME, then it is important to\n         // allow for extra length to account for the separator(s)\n         if (isChunked) {\n \n-            nbrChunks =\n-                (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE));\n-            encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;\n-        }\n-\n-        encodedData = new byte[encodedDataLength];\n+            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n+                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n+            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n+        }\n+\n+        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\n+                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n+        }\n+        int encodedDataLength = (int) encodedDataLengthLong;\n+        byte encodedData[] = new byte[encodedDataLength];\n \n         byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n \n         int nextSeparatorIndex = CHUNK_SIZE;\n         int chunksSoFar = 0;\n \n-        //log.debug(\"number of triplets = \" + numberTriplets);\n-        for (i = 0; i < numberTriplets; i++) {\n+        // log.debug(\"number of triplets = \" + numberTriplets);\n+        for (i = 0; i < tripletCount; i++) {\n             dataIndex = i * 3;\n             b1 = binaryData[dataIndex];\n             b2 = binaryData[dataIndex + 1];\n             b3 = binaryData[dataIndex + 2];\n \n-            //log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n+            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n \n             l = (byte) (b2 & 0x0f);\n             k = (byte) (b1 & 0x03);\n \n-            byte val1 =\n-                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 =\n-                ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-            byte val3 =\n-                ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n+            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n+            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n+            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            //log.debug( \"val2 = \" + val2 );\n-            //log.debug( \"k4   = \" + (k<<4) );\n-            //log.debug(  \"vak  = \" + (val2 | (k<<4)) );\n-            encodedData[encodedIndex + 1] =\n-                lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] =\n-                lookUpBase64Alphabet[(l << 2) | val3];\n+            // log.debug( \"val2 = \" + val2 );\n+            // log.debug( \"k4 = \" + (k<<4) );\n+            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n+            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n             encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n \n             encodedIndex += 4;\n             if (isChunked) {\n                 // this assumes that CHUNK_SIZE % 4 == 0\n                 if (encodedIndex == nextSeparatorIndex) {\n-                    System.arraycopy(\n-                        CHUNK_SEPARATOR,\n-                        0,\n-                        encodedData,\n-                        encodedIndex,\n-                        CHUNK_SEPARATOR.length);\n+                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                     chunksSoFar++;\n-                    nextSeparatorIndex =\n-                        (CHUNK_SIZE * (chunksSoFar + 1)) + \n-                        (chunksSoFar * CHUNK_SEPARATOR.length);\n+                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                     encodedIndex += CHUNK_SEPARATOR.length;\n                 }\n             }\n         if (fewerThan24bits == EIGHTBIT) {\n             b1 = binaryData[dataIndex];\n             k = (byte) (b1 & 0x03);\n-            //log.debug(\"b1=\" + b1);\n-            //log.debug(\"b1<<2 = \" + (b1>>2) );\n-            byte val1 =\n-                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n+            // log.debug(\"b1=\" + b1);\n+            // log.debug(\"b1<<2 = \" + (b1>>2) );\n+            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n             encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n             encodedData[encodedIndex + 2] = PAD;\n             l = (byte) (b2 & 0x0f);\n             k = (byte) (b1 & 0x03);\n \n-            byte val1 =\n-                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 =\n-                ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n+            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n+            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] =\n-                lookUpBase64Alphabet[val2 | (k << 4)];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n             encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n             encodedData[encodedIndex + 3] = PAD;\n         }\n \n         if (isChunked) {\n             // we also add a separator to the end of the final chunk.\n-            if (chunksSoFar < nbrChunks) {\n-                System.arraycopy(\n-                    CHUNK_SEPARATOR,\n-                    0,\n-                    encodedData,\n-                    encodedDataLength - CHUNK_SEPARATOR.length,\n-                    CHUNK_SEPARATOR.length);\n+            if (chunksSoFar < chunckCount) {\n+                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n+                        CHUNK_SEPARATOR.length);\n             }\n         }\n \n \n     /**\n      * Decodes Base64 data into octects\n-     *\n-     * @param base64Data Byte array containing Base64 data\n+     * \n+     * @param base64Data\n+     *            Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n             }\n             decodedData = new byte[lastData - numberQuadruple];\n         }\n-        \n+\n         for (int i = 0; i < numberQuadruple; i++) {\n             dataIndex = i * 4;\n             marker0 = base64Data[dataIndex + 2];\n             marker1 = base64Data[dataIndex + 3];\n-            \n+\n             b1 = base64Alphabet[base64Data[dataIndex]];\n             b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-            \n+\n             if (marker0 != PAD && marker1 != PAD) {\n-                //No PAD e.g 3cQl\n+                // No PAD e.g 3cQl\n                 b3 = base64Alphabet[marker0];\n                 b4 = base64Alphabet[marker1];\n-                \n+\n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] =\n-                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                 decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n             } else if (marker0 == PAD) {\n-                //Two PAD e.g. 3c[Pad][Pad]\n+                // Two PAD e.g. 3c[Pad][Pad]\n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n             } else if (marker1 == PAD) {\n-                //One PAD e.g. 3cQ[Pad]\n+                // One PAD e.g. 3cQ[Pad]\n                 b3 = base64Alphabet[marker0];\n-                \n+\n                 decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] =\n-                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n             }\n             encodedIndex += 3;\n         }\n         return decodedData;\n     }\n-    \n+\n     /**\n      * Discards any whitespace from a base-64 encoded block.\n-     *\n-     * @param data The base-64 encoded data to discard the whitespace\n-     * from.\n+     * \n+     * @param data\n+     *            The base-64 encoded data to discard the whitespace from.\n      * @return The data, less whitespace (see RFC 2045).\n      */\n     static byte[] discardWhitespace(byte[] data) {\n         byte groomedData[] = new byte[data.length];\n         int bytesCopied = 0;\n-        \n+\n         for (int i = 0; i < data.length; i++) {\n             switch (data[i]) {\n-            case (byte) ' ' :\n-            case (byte) '\\n' :\n-            case (byte) '\\r' :\n-            case (byte) '\\t' :\n+                case (byte) ' ' :\n+                case (byte) '\\n' :\n+                case (byte) '\\r' :\n+                case (byte) '\\t' :\n                     break;\n-            default:\n+                default :\n                     groomedData[bytesCopied++] = data[i];\n             }\n         }\n     }\n \n     /**\n-     * Discards any characters outside of the base64 alphabet, per\n-     * the requirements on page 25 of RFC 2045 - \"Any characters\n-     * outside of the base64 alphabet are to be ignored in base64\n-     * encoded data.\"\n-     *\n-     * @param data The base-64 encoded data to groom\n+     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - \"Any\n+     * characters outside of the base64 alphabet are to be ignored in base64 encoded data.\"\n+     * \n+     * @param data\n+     *            The base-64 encoded data to groom\n      * @return The data, less non-base64 characters (see RFC 2045).\n      */\n     static byte[] discardNonBase64(byte[] data) {\n         return packedData;\n     }\n \n-\n     // Implementation of the Encoder Interface\n \n     /**\n-     * Encodes an Object using the base64 algorithm.  This method\n-     * is provided in order to satisfy the requirements of the\n-     * Encoder interface, and will throw an EncoderException if the\n-     * supplied object is not of type byte[].\n-     *\n-     * @param pObject Object to encode\n-     * @return An object (of type byte[]) containing the \n-     *         base64 encoded data which corresponds to the byte[] supplied.\n-     * @throws EncoderException if the parameter supplied is not\n-     *                          of type byte[]\n+     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n+     * \n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type byte[]\n      */\n     public Object encode(Object pObject) throws EncoderException {\n         if (!(pObject instanceof byte[])) {\n-            throw new EncoderException(\n-                \"Parameter supplied to Base64 encode is not a byte[]\");\n+            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n         }\n         return encode((byte[]) pObject);\n     }\n \n     /**\n-     * Encodes a byte[] containing binary data, into a byte[] containing\n-     * characters in the Base64 alphabet.\n-     *\n-     * @param pArray a byte array containing binary data\n+     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n+     * \n+     * @param pArray\n+     *            a byte array containing binary data\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {", "timestamp": 1202156441, "metainfo": ""}