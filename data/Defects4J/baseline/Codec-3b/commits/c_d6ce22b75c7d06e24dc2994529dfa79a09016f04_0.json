{"sha": "d6ce22b75c7d06e24dc2994529dfa79a09016f04", "log": "set svn:eol-style to native  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.FilterInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-/**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n- * constructor.\n- * <p>\n- * The default behaviour of the Base64InputStream is to DECODE, whereas the\n- * default behaviour of the Base64OutputStream is to ENCODE, but this\n- * behaviour can be overridden by using a different constructor.\n- * </p><p>\n- * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n- * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n- * </p><p>\n- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). \n- * </p>\n- * @author Apache Software Foundation\n- * @version $Id $\n- * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n- * @since 1.4\n- */\n-public class Base64InputStream extends FilterInputStream {\n-\n-    private final boolean doEncode;\n-    private final Base64 base64;\n-    private final byte[] singleByte = new byte[1];\n-\n-    /**\n-     * Creates a Base64InputStream such that all data read is Base64-decoded\n-     * from the original provided InputStream.\n-     *\n-     * @param in InputStream to wrap.\n-     */\n-    public Base64InputStream(InputStream in) {\n-        this(in, false);\n-    }\n-\n-    /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in       InputStream to wrap.\n-     * @param doEncode true if we should encode all data read from us,\n-     *                 false if we should decode.\n-     */\n-    public Base64InputStream(InputStream in, boolean doEncode) {\n-        super(in);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64();\n-    }\n-\n-    /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in            InputStream to wrap.\n-     * @param doEncode      true if we should encode all data read from us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.\n-     *                      If lineLength <=0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *                      If lineLength <= 0, the lineSeparator is not used.  \n-     *                      If doEncode is false lineSeparator is ignored.\n-     */\n-    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n-        super(in);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(lineLength, lineSeparator);\n-    }\n-\n-    /**\n-     * Reads one <code>byte</code> from this input stream.\n-     * \n-     * @return the byte as an integer in the range 0 to 255\n-     * Returns -1 if EOF has been reached.\n-     */\n-    public int read() throws IOException {\n-        int r = read(singleByte, 0, 1);\n-        while (r == 0) {\n-            r = read(singleByte, 0, 1);\n-        }\n-        if (r > 0) {\n-            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Attempts to read <code>len</code> bytes into the specified\n-     * <code>b</code> array starting at <code>offset</code> from\n-     * this InputStream.\n-     * \n-     * @param b destination byte array\n-     * @param offset where to start writing the bytes\n-     * @param len maximum number of bytes to read\n-     * \n-     * @return number of bytes read\n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n-     */\n-    public int read(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return 0;\n-        } else {\n-            if (!base64.hasData()) {\n-                byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                int c = in.read(buf);\n-\n-                // A little optimization to avoid System.arraycopy()\n-                // when possible.\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n-                }\n-\n-                if (doEncode) {\n-                    base64.encode(buf, 0, c);\n-                } else {\n-                    base64.decode(buf, 0, c);\n-                }\n-            }\n-            return base64.readResults(b, offset, len);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     * @return false\n-     */\n-    public boolean markSupported() {\n-        return false; // not an easy job to support marks\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n+ * When encoding the default lineLength is 76 characters and the default\n+ * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64InputStream is to DECODE, whereas the\n+ * default behaviour of the Base64OutputStream is to ENCODE, but this\n+ * behaviour can be overridden by using a different constructor.\n+ * </p><p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p><p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). \n+ * </p>\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.4\n+ */\n+public class Base64InputStream extends FilterInputStream {\n+\n+    private final boolean doEncode;\n+    private final Base64 base64;\n+    private final byte[] singleByte = new byte[1];\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is Base64-decoded\n+     * from the original provided InputStream.\n+     *\n+     * @param in InputStream to wrap.\n+     */\n+    public Base64InputStream(InputStream in) {\n+        this(in, false);\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either\n+     * Base64-encoded or Base64-decoded from the original provided InputStream.\n+     *\n+     * @param in       InputStream to wrap.\n+     * @param doEncode true if we should encode all data read from us,\n+     *                 false if we should decode.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64();\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either\n+     * Base64-encoded or Base64-decoded from the original provided InputStream.\n+     *\n+     * @param in            InputStream to wrap.\n+     * @param doEncode      true if we should encode all data read from us,\n+     *                      false if we should decode.\n+     * @param lineLength    If doEncode is true, each line of encoded\n+     *                      data will contain lineLength characters.\n+     *                      If lineLength <=0, the encoded data is not divided into lines.\n+     *                      If doEncode is false, lineLength is ignored.\n+     * @param lineSeparator If doEncode is true, each line of encoded\n+     *                      data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *                      If lineLength <= 0, the lineSeparator is not used.  \n+     *                      If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64(lineLength, lineSeparator);\n+    }\n+\n+    /**\n+     * Reads one <code>byte</code> from this input stream.\n+     * \n+     * @return the byte as an integer in the range 0 to 255\n+     * Returns -1 if EOF has been reached.\n+     */\n+    public int read() throws IOException {\n+        int r = read(singleByte, 0, 1);\n+        while (r == 0) {\n+            r = read(singleByte, 0, 1);\n+        }\n+        if (r > 0) {\n+            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Attempts to read <code>len</code> bytes into the specified\n+     * <code>b</code> array starting at <code>offset</code> from\n+     * this InputStream.\n+     * \n+     * @param b destination byte array\n+     * @param offset where to start writing the bytes\n+     * @param len maximum number of bytes to read\n+     * \n+     * @return number of bytes read\n+     * @throws IOException if an I/O error occurs.\n+     * @throws NullPointerException if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     */\n+    public int read(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            if (!base64.hasData()) {\n+                byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                int c = in.read(buf);\n+\n+                // A little optimization to avoid System.arraycopy()\n+                // when possible.\n+                if (c > 0 && b.length == len) {\n+                    base64.setInitialBuffer(b, offset, len);\n+                }\n+\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n+                }\n+            }\n+            return base64.readResults(b, offset, len);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return false\n+     */\n+    public boolean markSupported() {\n+        return false; // not an easy job to support marks\n+    }\n+}\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.FilterOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-\n-/**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n- * constructor.\n- * <p>\n- * The default behaviour of the Base64OutputStream is to ENCODE, whereas the\n- * default behaviour of the Base64InputStream is to DECODE.  But this behaviour\n- * can be overridden by using a different constructor.\n- * </p><p>\n- * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n- * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n- * </p><p>\n- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n- * </p> \n- * @author Apache Software Foundation\n- * @version $Id $\n- * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n- * @since 1.4\n- */\n-public class Base64OutputStream extends FilterOutputStream {\n-    private final boolean doEncode;\n-    private final Base64 base64;\n-    private final byte[] singleByte = new byte[1];\n-\n-    /**\n-     * Creates a Base64OutputStream such that all data written is Base64-encoded\n-     * to the original provided OutputStream.\n-     *\n-     * @param out OutputStream to wrap.\n-     */\n-    public Base64OutputStream(OutputStream out) {\n-        this(out, true);\n-    }\n-\n-    /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out      OutputStream to wrap.\n-     * @param doEncode true if we should encode all data written to us,\n-     *                 false if we should decode.\n-     */\n-    public Base64OutputStream(OutputStream out, boolean doEncode) {\n-        super(out);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64();\n-    }\n-\n-    /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out           OutputStream to wrap.\n-     * @param doEncode      true if we should encode all data written to us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.  \n-     *                      If lineLength <=0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).  \n-     *                      If lineLength <= 0, the lineSeparator is not used.\n-     *                      If doEncode is false lineSeparator is ignored.\n-     */\n-    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n-        super(out);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(lineLength, lineSeparator);\n-    }\n-\n-    /**\n-     * Writes the specified <code>byte</code> to this output stream.\n-     */\n-    public void write(int i) throws IOException {\n-        singleByte[0] = (byte) i;\n-        write(singleByte, 0, 1);\n-    }\n-\n-    /**\n-     * Writes <code>len</code> bytes from the specified\n-     * <code>b</code> array starting at <code>offset</code> to\n-     * this output stream.\n-     *\n-     * @param b source byte array\n-     * @param offset where to start reading the bytes\n-     * @param len maximum number of bytes to write\n-     * \n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n-     */\n-    public void write(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len > 0) {\n-            if (doEncode) {\n-                base64.encode(b, offset, len);\n-            } else {\n-                base64.decode(b, offset, len);\n-            }\n-            flush(false);\n-        }\n-    }\n-\n-    /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.  If propogate is true, the wrapped\n-     * stream will also be flushed.\n-     *\n-     * @param propogate boolean flag to indicate whether the wrapped\n-     *                  OutputStream should also be flushed.\n-     * @throws IOException if an I/O error occurs.\n-     */\n-    private void flush(boolean propogate) throws IOException {\n-        int avail = base64.avail();\n-        if (avail > 0) {\n-            byte[] buf = new byte[avail];\n-            int c = base64.readResults(buf, 0, avail);\n-            if (c > 0) {\n-                out.write(buf, 0, c);\n-            }\n-        }\n-        if (propogate) {\n-            out.flush();\n-        }\n-    }\n-\n-    /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.\n-     *\n-     * @throws IOException if an I/O error occurs.\n-     */\n-    public void flush() throws IOException {\n-        flush(true); \n-    }\n-\n-    /**\n-     * Closes this output stream and releases any system resources\n-     * associated with the stream.\n-     */\n-    public void close() throws IOException {\n-        // Notify encoder of EOF (-1).\n-        if (doEncode) {\n-            base64.encode(singleByte, 0, -1);\n-        } else {\n-            base64.decode(singleByte, 0, -1);\n-        }\n-        flush();\n-        out.close();\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n+ * When encoding the default lineLength is 76 characters and the default\n+ * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the\n+ * default behaviour of the Base64InputStream is to DECODE.  But this behaviour\n+ * can be overridden by using a different constructor.\n+ * </p><p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p><p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p> \n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.4\n+ */\n+public class Base64OutputStream extends FilterOutputStream {\n+    private final boolean doEncode;\n+    private final Base64 base64;\n+    private final byte[] singleByte = new byte[1];\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded\n+     * to the original provided OutputStream.\n+     *\n+     * @param out OutputStream to wrap.\n+     */\n+    public Base64OutputStream(OutputStream out) {\n+        this(out, true);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either\n+     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n+     *\n+     * @param out      OutputStream to wrap.\n+     * @param doEncode true if we should encode all data written to us,\n+     *                 false if we should decode.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode) {\n+        super(out);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64();\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either\n+     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n+     *\n+     * @param out           OutputStream to wrap.\n+     * @param doEncode      true if we should encode all data written to us,\n+     *                      false if we should decode.\n+     * @param lineLength    If doEncode is true, each line of encoded\n+     *                      data will contain lineLength characters.  \n+     *                      If lineLength <=0, the encoded data is not divided into lines.\n+     *                      If doEncode is false, lineLength is ignored.\n+     * @param lineSeparator If doEncode is true, each line of encoded\n+     *                      data will be terminated with this byte sequence (e.g. \\r\\n).  \n+     *                      If lineLength <= 0, the lineSeparator is not used.\n+     *                      If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(out);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64(lineLength, lineSeparator);\n+    }\n+\n+    /**\n+     * Writes the specified <code>byte</code> to this output stream.\n+     */\n+    public void write(int i) throws IOException {\n+        singleByte[0] = (byte) i;\n+        write(singleByte, 0, 1);\n+    }\n+\n+    /**\n+     * Writes <code>len</code> bytes from the specified\n+     * <code>b</code> array starting at <code>offset</code> to\n+     * this output stream.\n+     *\n+     * @param b source byte array\n+     * @param offset where to start reading the bytes\n+     * @param len maximum number of bytes to write\n+     * \n+     * @throws IOException if an I/O error occurs.\n+     * @throws NullPointerException if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     */\n+    public void write(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len > 0) {\n+            if (doEncode) {\n+                base64.encode(b, offset, len);\n+            } else {\n+                base64.decode(b, offset, len);\n+            }\n+            flush(false);\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.  If propogate is true, the wrapped\n+     * stream will also be flushed.\n+     *\n+     * @param propogate boolean flag to indicate whether the wrapped\n+     *                  OutputStream should also be flushed.\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    private void flush(boolean propogate) throws IOException {\n+        int avail = base64.avail();\n+        if (avail > 0) {\n+            byte[] buf = new byte[avail];\n+            int c = base64.readResults(buf, 0, avail);\n+            if (c > 0) {\n+                out.write(buf, 0, c);\n+            }\n+        }\n+        if (propogate) {\n+            out.flush();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.\n+     *\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    public void flush() throws IOException {\n+        flush(true); \n+    }\n+\n+    /**\n+     * Closes this output stream and releases any system resources\n+     * associated with the stream.\n+     */\n+    public void close() throws IOException {\n+        // Notify encoder of EOF (-1).\n+        if (doEncode) {\n+            base64.encode(singleByte, 0, -1);\n+        } else {\n+            base64.decode(singleByte, 0, -1);\n+        }\n+        flush();\n+        out.close();\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/codec/binary/StringBytesUtils.java\n+++ b/src/java/org/apache/commons/codec/binary/StringBytesUtils.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.UnsupportedEncodingException;\n-\n-import org.apache.commons.codec.RequiredCharsetNames;\n-\n-/**\n- * Converts String to bytes using the encodings required by the Java specification.\n- * \n- * @see RequiredCharsetNames\n- * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n- * @version $Id: $\n- */\n-public class StringBytesUtils {\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n-     * byte array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesIso8859_1(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.ISO_8859_1);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n-     * array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesUsAscii(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.US_ASCII);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n-     * array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesUtf16(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n-     * array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesUtf16Be(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16BE);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n-     * array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesUtf16Le(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16LE);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n-     * array.\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when the charset is missing, which should be never according the the Java specification.\n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n-     *      encoding names </a>\n-     * @see #getSupportedBytes(String, String)\n-     */\n-    public static byte[] getBytesUtf8(String string) {\n-        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_8);\n-    }\n-\n-    /**\n-     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n-     * array.\n-     * <p>\n-     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n-     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n-     * </p>\n-     * \n-     * @param string\n-     *            the String to encode\n-     * @param charsetName\n-     *            The name of a required {@link java.nio.charset.Charset}\n-     * @return encoded bytes\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n-     *             required charset name.\n-     * @see RequiredCharsetNames\n-     * @see String#getBytes(String)\n-     */\n-    public static byte[] getSupportedBytes(String string, String charsetName) {\n-        try {\n-            return string.getBytes(charsetName);\n-        } catch (UnsupportedEncodingException e) {\n-            throw StringBytesUtils.newIllegalStateException(charsetName, e);\n-        }\n-    }\n-\n-    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n-        return new IllegalStateException(charsetName + \": \" + e);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n-     * <p>\n-     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n-     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n-     * </p>\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @param charsetName\n-     *            The name of a required {@link java.nio.charset.Charset}\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n-     *             required charset name.\n-     * @see RequiredCharsetNames\n-     * @see String#String(byte[], String)\n-     */\n-    public static String newString(byte[] bytes, String charsetName) {\n-        try {\n-            return new String(bytes, charsetName);\n-        } catch (UnsupportedEncodingException e) {\n-            throw StringBytesUtils.newIllegalStateException(charsetName, e);\n-        }\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringIso8859_1(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.ISO_8859_1);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringUsAscii(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.US_ASCII);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringUtf16(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringUtf16Be(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16BE);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringUtf16Le(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16LE);\n-    }\n-\n-    /**\n-     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n-     * \n-     * @param bytes\n-     *            The bytes to be decoded into characters\n-     * @throws IllegalStateException\n-     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n-     *             charset is required.\n-     */\n-    public static String newStringUtf8(byte[] bytes) {\n-        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_8);\n-    }\n-\n-    private StringBytesUtils() {\n-        // noop, cannot instantiate.\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.RequiredCharsetNames;\n+\n+/**\n+ * Converts String to bytes using the encodings required by the Java specification.\n+ * \n+ * @see RequiredCharsetNames\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id: $\n+ */\n+public class StringBytesUtils {\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n+     * byte array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesIso8859_1(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUsAscii(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.US_ASCII);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Be(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16BE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Le(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_16LE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names </a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf8(String string) {\n+        return StringBytesUtils.getSupportedBytes(string, RequiredCharsetNames.UTF_8);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n+     * array.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see RequiredCharsetNames\n+     * @see String#getBytes(String)\n+     */\n+    public static byte[] getSupportedBytes(String string, String charsetName) {\n+        try {\n+            return string.getBytes(charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringBytesUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n+        return new IllegalStateException(charsetName + \": \" + e);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see RequiredCharsetNames\n+     * @see String#String(byte[], String)\n+     */\n+    public static String newString(byte[] bytes, String charsetName) {\n+        try {\n+            return new String(bytes, charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringBytesUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringIso8859_1(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUsAscii(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.US_ASCII);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Be(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16BE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Le(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_16LE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf8(byte[] bytes) {\n+        return StringBytesUtils.newString(bytes, RequiredCharsetNames.UTF_8);\n+    }\n+\n+    private StringBytesUtils() {\n+        // noop, cannot instantiate.\n+    }\n+}\n--- a/src/test/org/apache/commons/codec/RequiredCharsetNamesTest.java\n+++ b/src/test/org/apache/commons/codec/RequiredCharsetNamesTest.java\n-/*\n- * Copyright (C) 1993-2003 SEAGULL\n- * \n- * RequiredCharsetNamesTest.java\n- * Created on Jul 20, 2009, 6:08:58 PM\n- * \n- */\n-\n-package org.apache.commons.codec;\n-\n-import junit.framework.Assert;\n-import junit.framework.TestCase;\n-\n-/**\n- * Sanity checks.\n- * \n- * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n- * @version $Id: $\n- */\n-public class RequiredCharsetNamesTest extends TestCase {\n-\n-    public void testIso8859_1() {\n-        Assert.assertEquals(\"ISO-8859-1\", RequiredCharsetNames.ISO_8859_1);\n-    }\n-\n-    public void testUsAscii() {\n-        Assert.assertEquals(\"US-ASCII\", RequiredCharsetNames.US_ASCII);\n-    }\n-\n-    public void testUtf16() {\n-        Assert.assertEquals(\"UTF-16\", RequiredCharsetNames.UTF_16);\n-    }\n-\n-    public void testUtf16Be() {\n-        Assert.assertEquals(\"UTF-16BE\", RequiredCharsetNames.UTF_16BE);\n-    }\n-\n-    public void testUtf16Le() {\n-        Assert.assertEquals(\"UTF-16LE\", RequiredCharsetNames.UTF_16LE);\n-    }\n-\n-    public void testUtf8() {\n-        Assert.assertEquals(\"UTF-8\", RequiredCharsetNames.UTF_8);\n-    }\n-\n-}\n+/*\n+ * Copyright (C) 1993-2003 SEAGULL\n+ * \n+ * RequiredCharsetNamesTest.java\n+ * Created on Jul 20, 2009, 6:08:58 PM\n+ * \n+ */\n+\n+package org.apache.commons.codec;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Sanity checks.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id: $\n+ */\n+public class RequiredCharsetNamesTest extends TestCase {\n+\n+    public void testIso8859_1() {\n+        Assert.assertEquals(\"ISO-8859-1\", RequiredCharsetNames.ISO_8859_1);\n+    }\n+\n+    public void testUsAscii() {\n+        Assert.assertEquals(\"US-ASCII\", RequiredCharsetNames.US_ASCII);\n+    }\n+\n+    public void testUtf16() {\n+        Assert.assertEquals(\"UTF-16\", RequiredCharsetNames.UTF_16);\n+    }\n+\n+    public void testUtf16Be() {\n+        Assert.assertEquals(\"UTF-16BE\", RequiredCharsetNames.UTF_16BE);\n+    }\n+\n+    public void testUtf16Le() {\n+        Assert.assertEquals(\"UTF-16LE\", RequiredCharsetNames.UTF_16LE);\n+    }\n+\n+    public void testUtf8() {\n+        Assert.assertEquals(\"UTF-8\", RequiredCharsetNames.UTF_8);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n-import java.util.Arrays;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * @author Apache Software Foundation\n- * @version $Id $\n- * @since 1.4\n- */\n-public class Base64InputStreamTest extends TestCase {\n-\n-    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n-\n-    private final static byte[] LF = {(byte) '\\n'};\n-\n-    private static final String STRING_FIXTURE = \"Hello World\";\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     * \n-     * @param name\n-     *            Name of the test case\n-     */\n-    public Base64InputStreamTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * Tests the Base64InputStream implementation against empty input.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64EmptyInputStream() throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n-    }\n-\n-    /**\n-     * Tests the Base64InputStream implementation.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64InputStreamByChunk() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 0, LF);\n-\n-        // test random data of sizes 0 thru 150\n-        for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n-            encoded = randomData[1];\n-            decoded = randomData[0];\n-            testByChunk(encoded, decoded, 0, LF);\n-        }\n-    }\n-\n-    /**\n-     * Tests the Base64InputStream implementation.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64InputStreamByteByByte() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByteByByte(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n-        testByteByByte(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n-        decoded = Base64TestData.DECODED;\n-        testByteByByte(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n-        decoded = Base64TestData.DECODED;\n-        testByteByByte(encoded, decoded, 0, LF);\n-\n-        // test random data of sizes 0 thru 150\n-        for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n-            encoded = randomData[1];\n-            decoded = randomData[0];\n-            testByteByByte(encoded, decoded, 0, LF);\n-        }\n-    }\n-\n-    /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n-     * over and over again.\n-     * \n-     * @param encoded\n-     *            base64 encoded data\n-     * @param decoded\n-     *            the data from above, but decoded\n-     * @param chunkSize\n-     *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n-     *            Line separator in the base64 encoded data.\n-     * @throws Exception\n-     *             Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n-\n-        // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base64InputStream(in, true, chunkSize, seperator);\n-        byte[] output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base64InputStream(in);\n-        output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this! (wrap encoder with decoder etc etc).\n-        in = new ByteArrayInputStream(decoded);\n-        for (int i = 0; i < 10; i++) {\n-            in = new Base64InputStream(in, true, chunkSize, seperator);\n-            in = new Base64InputStream(in, false);\n-        }\n-        output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n-    }\n-\n-    /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n-     * over and over again.\n-     * \n-     * @param encoded\n-     *            base64 encoded data\n-     * @param decoded\n-     *            the data from above, but decoded\n-     * @param chunkSize\n-     *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n-     *            Line separator in the base64 encoded data.\n-     * @throws Exception\n-     *             Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n-\n-        // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base64InputStream(in, true, chunkSize, seperator);\n-        byte[] output = new byte[encoded.length];\n-        for (int i = 0; i < output.length; i++) {\n-            output[i] = (byte) in.read();\n-        }\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base64InputStream(in);\n-        output = new byte[decoded.length];\n-        for (int i = 0; i < output.length; i++) {\n-            output[i] = (byte) in.read();\n-        }\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this! (wrap encoder with decoder etc etc).\n-        in = new ByteArrayInputStream(decoded);\n-        for (int i = 0; i < 10; i++) {\n-            in = new Base64InputStream(in, true, chunkSize, seperator);\n-            in = new Base64InputStream(in, false);\n-        }\n-        output = new byte[decoded.length];\n-        for (int i = 0; i < output.length; i++) {\n-            output[i] = (byte) in.read();\n-        }\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n-    }\n-\n-    /**\n-     * Tests markSupported.\n-     * \n-     * @throws Exception\n-     */\n-    public void testMarkSupported() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n-        // Always returns false for now.\n-        assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n-    }\n-\n-    /**\n-     * Tests read returning 0\n-     * \n-     * @throws Exception\n-     */\n-    public void testRead0() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n-        int bytesRead = 0;\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n-        bytesRead = in.read(buf, 0, 0);\n-        assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n-    }\n-\n-    /**\n-     * Tests read with null.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testReadNull() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n-        try {\n-            in.read(null, 0, 0);\n-            fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n-            // Expected\n-        }\n-    }\n-\n-    /**\n-     * Tests read throwing IndexOutOfBoundsException\n-     * \n-     * @throws Exception\n-     */\n-    public void testReadOutOfBounds() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n-\n-        try {\n-            in.read(buf, -1, 0);\n-            fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-\n-        try {\n-            in.read(buf, 0, -1);\n-            fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-\n-        try {\n-            in.read(buf, buf.length + 1, 0);\n-            fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-\n-        try {\n-            in.read(buf, buf.length - 1, 2);\n-            fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n-            // Expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64InputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     * \n+     * @param name\n+     *            Name of the test case\n+     */\n+    public Base64InputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64EmptyInputStream() throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = new byte[encoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests markSupported.\n+     * \n+     * @throws Exception\n+     */\n+    public void testMarkSupported() throws Exception {\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        // Always returns false for now.\n+        assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n+    }\n+\n+    /**\n+     * Tests read returning 0\n+     * \n+     * @throws Exception\n+     */\n+    public void testRead0() throws Exception {\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        int bytesRead = 0;\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        bytesRead = in.read(buf, 0, 0);\n+        assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+    }\n+\n+    /**\n+     * Tests read with null.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testReadNull() throws Exception {\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        try {\n+            in.read(null, 0, 0);\n+            fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests read throwing IndexOutOfBoundsException\n+     * \n+     * @throws Exception\n+     */\n+    public void testReadOutOfBounds() throws Exception {\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+\n+        try {\n+            in.read(buf, -1, 0);\n+            fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, 0, -1);\n+            fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length + 1, 0);\n+            fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length - 1, 2);\n+            fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.OutputStream;\n-import java.util.Arrays;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * @author Apache Software Foundation\n- * @version $Id $\n- * @since 1.4\n- */\n-public class Base64OutputStreamTest extends TestCase {\n-\n-    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n-\n-    private final static byte[] LF = {(byte) '\\n'};\n-\n-    private static final String STRING_FIXTURE = \"Hello World\";\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     * \n-     * @param name\n-     *            Name of the test case\n-     */\n-    public Base64OutputStreamTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * Test the Base64OutputStream implementation against empty input.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64EmptyOutputStream() throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n-    }\n-\n-    /**\n-     * Test the Base64OutputStream implementation\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64OutputStreamByChunk() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 0, LF);\n-\n-        // test random data of sizes 0 thru 150\n-        for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n-            encoded = randomData[1];\n-            decoded = randomData[0];\n-            testByChunk(encoded, decoded, 0, LF);\n-        }\n-    }\n-\n-    /**\n-     * Test the Base64OutputStream implementation\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testBase64OutputStreamByteByByte() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByteByByte(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n-        testByteByByte(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n-        decoded = Base64TestData.DECODED;\n-        testByteByByte(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n-        decoded = Base64TestData.DECODED;\n-        testByteByByte(encoded, decoded, 0, LF);\n-\n-        // test random data of sizes 0 thru 150\n-        for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n-            encoded = randomData[1];\n-            decoded = randomData[0];\n-            testByteByByte(encoded, decoded, 0, LF);\n-        }\n-    }\n-\n-    /**\n-     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n-     * mode over and over again.\n-     * \n-     * @param encoded\n-     *            base64 encoded data\n-     * @param decoded\n-     *            the data from above, but decoded\n-     * @param chunkSize\n-     *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n-     *            Line separator in the base64 encoded data.\n-     * @throws Exception\n-     *             Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n-\n-        // Start with encode.\n-        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n-        out.write(decoded);\n-        out.close();\n-        byte[] output = byteOut.toByteArray();\n-        assertTrue(\"Streaming chunked base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        byteOut = new ByteArrayOutputStream();\n-        out = new Base64OutputStream(byteOut, false);\n-        out.write(encoded);\n-        out.close();\n-        output = byteOut.toByteArray();\n-        assertTrue(\"Streaming chunked base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this! (wrap encoder with decoder etc etc).\n-        byteOut = new ByteArrayOutputStream();\n-        out = byteOut;\n-        for (int i = 0; i < 10; i++) {\n-            out = new Base64OutputStream(out, false);\n-            out = new Base64OutputStream(out, true, chunkSize, seperator);\n-        }\n-        out.write(decoded);\n-        out.close();\n-        output = byteOut.toByteArray();\n-\n-        assertTrue(\"Streaming chunked base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n-    }\n-\n-    /**\n-     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n-     * mode over and over again.\n-     * \n-     * @param encoded\n-     *            base64 encoded data\n-     * @param decoded\n-     *            the data from above, but decoded\n-     * @param chunkSize\n-     *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n-     *            Line separator in the base64 encoded data.\n-     * @throws Exception\n-     *             Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n-\n-        // Start with encode.\n-        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n-        }\n-        out.close();\n-        byte[] output = byteOut.toByteArray();\n-        assertTrue(\"Streaming byte-by-byte base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        byteOut = new ByteArrayOutputStream();\n-        out = new Base64OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n-        }\n-        out.close();\n-        output = byteOut.toByteArray();\n-        assertTrue(\"Streaming byte-by-byte base64 decode\", Arrays.equals(output, decoded));\n-\n-        // Now let's try decode with tonnes of flushes.\n-        byteOut = new ByteArrayOutputStream();\n-        out = new Base64OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n-            out.flush();\n-        }\n-        out.close();\n-        output = byteOut.toByteArray();\n-        assertTrue(\"Streaming byte-by-byte flush() base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this! (wrap encoder with decoder etc etc).\n-        byteOut = new ByteArrayOutputStream();\n-        out = byteOut;\n-        for (int i = 0; i < 10; i++) {\n-            out = new Base64OutputStream(out, false);\n-            out = new Base64OutputStream(out, true, chunkSize, seperator);\n-        }\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n-        }\n-        out.close();\n-        output = byteOut.toByteArray();\n-\n-        assertTrue(\"Streaming byte-by-byte base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n-    }\n-\n-    /**\n-     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testWriteOutOfBounds() throws Exception {\n-        byte[] buf = new byte[1024];\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base64OutputStream out = new Base64OutputStream(bout);\n-\n-        try {\n-            out.write(buf, -1, 1);\n-            fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            // Expected\n-        }\n-\n-        try {\n-            out.write(buf, 1, -1);\n-            fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            // Expected\n-        }\n-\n-        try {\n-            out.write(buf, buf.length + 1, 0);\n-            fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            // Expected\n-        }\n-\n-        try {\n-            out.write(buf, buf.length - 1, 2);\n-            fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n-            // Expected\n-        }\n-    }\n-\n-    /**\n-     * Tests Base64OutputStream.write(null).\n-     * \n-     * @throws Exception\n-     *             for some failure scenarios.\n-     */\n-    public void testWriteToNullCoverage() throws Exception {\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base64OutputStream out = new Base64OutputStream(bout);\n-        try {\n-            out.write(null, 0, 0);\n-            fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n-            // Expected\n-        }\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64OutputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     * \n+     * @param name\n+     *            Name of the test case\n+     */\n+    public Base64OutputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64EmptyOutputStream() throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64OutputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64OutputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming chunked base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte base64 decode\", Arrays.equals(output, decoded));\n+\n+        // Now let's try decode with tonnes of flushes.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+            out.flush();\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte flush() base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming byte-by-byte base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteOutOfBounds() throws Exception {\n+        byte[] buf = new byte[1024];\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+\n+        try {\n+            out.write(buf, -1, 1);\n+            fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, 1, -1);\n+            fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length + 1, 0);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length - 1, 2);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests Base64OutputStream.write(null).\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteToNullCoverage() throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+        try {\n+            out.write(null, 0, 0);\n+            fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Random;\n-\n-/**\n- * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n- * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n- * \n- * @author Apache Software Foundation\n- * @version $Id $\n- * @since 1.4\n- */\n-public class Base64TestData {\n-\n-    // OpenSSL doesn't include the final \\n, but it would be annoying beyond belief\n-    // to further parameterize commons-codec to support this pointless variation.\n-    final static String ENCODED\n-            = \"9IPNKwUvdLiIAp6ctz12SiQmOGstWyYvSPeevufDhrzaws65voykKjbIj33YWTa9\\n\"\n-            + \"xA7c/FHypWclrZhQ7onfc3JE93BJ5fT4R9zAEdjbjy1hv4ZYNnET4WJeXMLJ/5p+\\n\"\n-            + \"qBpTsPpepW8DNVYy1c02/1wyC+kgA6CvRUd9cSr/lt88AEdsTV4GMCn1+EwuAiYd\\n\"\n-            + \"ivxuzn+cLM8q2jewqlI52tP9J7Cs8vqG71s6+WAELKvm/UovvyaOi+OdMUfjQ0JL\\n\"\n-            + \"iLkHu6p9OwUgvQqiDKzEv/Augo0dTPZzYGEyCP5GVrle3QQdgciIHnpdd4VUTPGR\\n\"\n-            + \"UbXeKbh++U3fbJIng/sQXM3IYByMZ7xt9HWS1LUcRdQ7Prwn/IlQWxOMeq+KZJSo\\n\"\n-            + \"AviWtdserXyHbIEa//hmr4p/j80k0g9q35hq1ayGM9984ALTSaZ8WeyFbZx1CxC/\\n\"\n-            + \"Qoqf92UH/ylBRnSJNn4sS0oa3uUbNvOnpkB4D9V7Ut9atinCJrw+wiJcMl+9kp25\\n\"\n-            + \"1IUxBGA4cUxh0eaxk3ODWnwI95EktmWOKwCSP0xjWwIMxDjygwAG5R8fk9H9bVi1\\n\"\n-            + \"thMavm4nDc4vaNoSE1RnZNYwbiUVlVPM9EclvJWTWd6igWeA0MxHAA8iOM5Vnmqp\\n\"\n-            + \"/WGM7UDq59rBIdNQCoeTJaAkEtAuLL5zogOa5e+MzVjvB5MYQlOlaaTtQrRApXa5\\n\"\n-            + \"Z4VfEanu9UK2fi1T8jJPFC2PmXebxp0bnO+VW+bgyEdIIkIQCaZq1MKWC3KuiOS9\\n\"\n-            + \"BJ1t7O0A2JKJKvoE4UNulzV2TGCC+KAnmjRqQBqXlJmgjHQAoHNZKOma/uIQOsvf\\n\"\n-            + \"DnqicYdDmfyCYuV89HjA1H8tiDJ85VfsrFHdcbPAoNCpi65awJSHfdPO1NDONOK+\\n\"\n-            + \"+S7Y0VXUgoYYrBV4Y7YbC8wg/nqcimr3lm3tRyp+QsgKzdREbfNRk0F5PLyLfsUE\\n\"\n-            + \"lepjs1QdV3fEV1LJtiywA3ubVNQJRxhbYxa/C/Xy2qxpm6vvdL92l3q1ccev35Ic\\n\"\n-            + \"aOiSx7Im+/GxV2lVKdaOvYVGDD1zBRe6Y2CwQb9p088l3/93qGR5593NCiuPPWcs\\n\"\n-            + \"DWwUShM1EyW0FNX1F8bnzHnYijoyE/jf4s/l9bBd7yJdRWRCyih2WcypAiOIEkBs\\n\"\n-            + \"H+dCTgalu8sRDoMh4ZIBBdgHfoZUycLqReQFLZZ4Sl4zSmzt5vQxQFhEKb9+ff/4\\n\"\n-            + \"rb1KAo6wifengxVfIsa2b5ljXzAqXs7JkPvmC6fa7X4ZZndRokaxYlu3cg8OV+uG\\n\"\n-            + \"/6YAHZilo8at0OpkkNdNFuhwuGlkBqrZKNUj/gSiYYc06gF/r/z6iWAjpXJRW1qq\\n\"\n-            + \"3CLZXdZFZ/VrqXeVjtOAu2A=\\n\";\n-\n-    final static byte[] DECODED\n-            = {-12, -125, -51, 43, 5, 47, 116, -72, -120, 2, -98, -100, -73, 61, 118, 74, 36, 38, 56, 107, 45, 91, 38,\n-            47, 72, -9, -98, -66, -25, -61, -122, -68, -38, -62, -50, -71, -66, -116, -92, 42, 54, -56, -113, 125,\n-            -40, 89, 54, -67, -60, 14, -36, -4, 81, -14, -91, 103, 37, -83, -104, 80, -18, -119, -33, 115, 114, 68,\n-            -9, 112, 73, -27, -12, -8, 71, -36, -64, 17, -40, -37, -113, 45, 97, -65, -122, 88, 54, 113, 19, -31, 98,\n-            94, 92, -62, -55, -1, -102, 126, -88, 26, 83, -80, -6, 94, -91, 111, 3, 53, 86, 50, -43, -51, 54, -1, 92,\n-            50, 11, -23, 32, 3, -96, -81, 69, 71, 125, 113, 42, -1, -106, -33, 60, 0, 71, 108, 77, 94, 6, 48, 41, -11,\n-            -8, 76, 46, 2, 38, 29, -118, -4, 110, -50, 127, -100, 44, -49, 42, -38, 55, -80, -86, 82, 57, -38, -45,\n-            -3, 39, -80, -84, -14, -6, -122, -17, 91, 58, -7, 96, 4, 44, -85, -26, -3, 74, 47, -65, 38, -114, -117,\n-            -29, -99, 49, 71, -29, 67, 66, 75, -120, -71, 7, -69, -86, 125, 59, 5, 32, -67, 10, -94, 12, -84, -60, -65,\n-            -16, 46, -126, -115, 29, 76, -10, 115, 96, 97, 50, 8, -2, 70, 86, -71, 94, -35, 4, 29, -127, -56, -120,\n-            30, 122, 93, 119, -123, 84, 76, -15, -111, 81, -75, -34, 41, -72, 126, -7, 77, -33, 108, -110, 39, -125,\n-            -5, 16, 92, -51, -56, 96, 28, -116, 103, -68, 109, -12, 117, -110, -44, -75, 28, 69, -44, 59, 62, -68,\n-            39, -4, -119, 80, 91, 19, -116, 122, -81, -118, 100, -108, -88, 2, -8, -106, -75, -37, 30, -83, 124, -121,\n-            108, -127, 26, -1, -8, 102, -81, -118, 127, -113, -51, 36, -46, 15, 106, -33, -104, 106, -43, -84, -122,\n-            51, -33, 124, -32, 2, -45, 73, -90, 124, 89, -20, -123, 109, -100, 117, 11, 16, -65, 66, -118, -97, -9,\n-            101, 7, -1, 41, 65, 70, 116, -119, 54, 126, 44, 75, 74, 26, -34, -27, 27, 54, -13, -89, -90, 64, 120, 15,\n-            -43, 123, 82, -33, 90, -74, 41, -62, 38, -68, 62, -62, 34, 92, 50, 95, -67, -110, -99, -71, -44, -123,\n-            49, 4, 96, 56, 113, 76, 97, -47, -26, -79, -109, 115, -125, 90, 124, 8, -9, -111, 36, -74, 101, -114, 43,\n-            0, -110, 63, 76, 99, 91, 2, 12, -60, 56, -14, -125, 0, 6, -27, 31, 31, -109, -47, -3, 109, 88, -75, -74,\n-            19, 26, -66, 110, 39, 13, -50, 47, 104, -38, 18, 19, 84, 103, 100, -42, 48, 110, 37, 21, -107, 83, -52,\n-            -12, 71, 37, -68, -107, -109, 89, -34, -94, -127, 103, -128, -48, -52, 71, 0, 15, 34, 56, -50, 85, -98,\n-            106, -87, -3, 97, -116, -19, 64, -22, -25, -38, -63, 33, -45, 80, 10, -121, -109, 37, -96, 36, 18, -48,\n-            46, 44, -66, 115, -94, 3, -102, -27, -17, -116, -51, 88, -17, 7, -109, 24, 66, 83, -91, 105, -92, -19,\n-            66, -76, 64, -91, 118, -71, 103, -123, 95, 17, -87, -18, -11, 66, -74, 126, 45, 83, -14, 50, 79, 20, 45,\n-            -113, -103, 119, -101, -58, -99, 27, -100, -17, -107, 91, -26, -32, -56, 71, 72, 34, 66, 16, 9, -90, 106,\n-            -44, -62, -106, 11, 114, -82, -120, -28, -67, 4, -99, 109, -20, -19, 0, -40, -110, -119, 42, -6, 4, -31,\n-            67, 110, -105, 53, 118, 76, 96, -126, -8, -96, 39, -102, 52, 106, 64, 26, -105, -108, -103, -96, -116,\n-            116, 0, -96, 115, 89, 40, -23, -102, -2, -30, 16, 58, -53, -33, 14, 122, -94, 113, -121, 67, -103, -4,\n-            -126, 98, -27, 124, -12, 120, -64, -44, 127, 45, -120, 50, 124, -27, 87, -20, -84, 81, -35, 113, -77,\n-            -64, -96, -48, -87, -117, -82, 90, -64, -108, -121, 125, -45, -50, -44, -48, -50, 52, -30, -66, -7, 46,\n-            -40, -47, 85, -44, -126, -122, 24, -84, 21, 120, 99, -74, 27, 11, -52, 32, -2, 122, -100, -118, 106, -9,\n-            -106, 109, -19, 71, 42, 126, 66, -56, 10, -51, -44, 68, 109, -13, 81, -109, 65, 121, 60, -68, -117, 126,\n-            -59, 4, -107, -22, 99, -77, 84, 29, 87, 119, -60, 87, 82, -55, -74, 44, -80, 3, 123, -101, 84, -44, 9, 71,\n-            24, 91, 99, 22, -65, 11, -11, -14, -38, -84, 105, -101, -85, -17, 116, -65, 118, -105, 122, -75, 113,\n-            -57, -81, -33, -110, 28, 104, -24, -110, -57, -78, 38, -5, -15, -79, 87, 105, 85, 41, -42, -114, -67,\n-            -123, 70, 12, 61, 115, 5, 23, -70, 99, 96, -80, 65, -65, 105, -45, -49, 37, -33, -1, 119, -88, 100, 121,\n-            -25, -35, -51, 10, 43, -113, 61, 103, 44, 13, 108, 20, 74, 19, 53, 19, 37, -76, 20, -43, -11, 23, -58, -25,\n-            -52, 121, -40, -118, 58, 50, 19, -8, -33, -30, -49, -27, -11, -80, 93, -17, 34, 93, 69, 100, 66, -54, 40,\n-            118, 89, -52, -87, 2, 35, -120, 18, 64, 108, 31, -25, 66, 78, 6, -91, -69, -53, 17, 14, -125, 33, -31, -110,\n-            1, 5, -40, 7, 126, -122, 84, -55, -62, -22, 69, -28, 5, 45, -106, 120, 74, 94, 51, 74, 108, -19, -26, -12,\n-            49, 64, 88, 68, 41, -65, 126, 125, -1, -8, -83, -67, 74, 2, -114, -80, -119, -9, -89, -125, 21, 95, 34,\n-            -58, -74, 111, -103, 99, 95, 48, 42, 94, -50, -55, -112, -5, -26, 11, -89, -38, -19, 126, 25, 102, 119,\n-            81, -94, 70, -79, 98, 91, -73, 114, 15, 14, 87, -21, -122, -1, -90, 0, 29, -104, -91, -93, -58, -83, -48,\n-            -22, 100, -112, -41, 77, 22, -24, 112, -72, 105, 100, 6, -86, -39, 40, -43, 35, -2, 4, -94, 97, -121, 52,\n-            -22, 1, 127, -81, -4, -6, -119, 96, 35, -91, 114, 81, 91, 90, -86, -36, 34, -39, 93, -42, 69, 103, -11,\n-            107, -87, 119, -107, -114, -45, -128, -69, 96};\n-\n-    // Some utility code to help test chunked reads of the InputStream.\n-\n-    private final static int SIZE_KEY = 0;\n-    private final static int LAST_READ_KEY = 1;\n-\n-    static byte[] streamToBytes(final InputStream in) throws IOException {\n-        // new byte[7] is obviously quite slow, but helps exercise the code.\n-        byte[] buf = new byte[7];\n-        try {\n-            int[] status = fill(buf, 0, in);\n-            int size = status[SIZE_KEY];\n-            int lastRead = status[LAST_READ_KEY];\n-            while (lastRead != -1) {\n-                buf = resizeArray(buf);\n-                status = fill(buf, size, in);\n-                size = status[SIZE_KEY];\n-                lastRead = status[LAST_READ_KEY];\n-            }\n-            if (buf.length != size) {\n-                byte[] smallerBuf = new byte[size];\n-                System.arraycopy(buf, 0, smallerBuf, 0, size);\n-                buf = smallerBuf;\n-            }\n-        }\n-        finally {\n-            in.close();\n-        }\n-        return buf;\n-    }\n-\n-    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n-            throws IOException {\n-        int read = in.read(buf, offset, buf.length - offset);\n-        int lastRead = read;\n-        if (read == -1) {\n-            read = 0;\n-        }\n-        while (lastRead != -1 && read + offset < buf.length) {\n-            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n-            if (lastRead != -1) {\n-                read += lastRead;\n-            }\n-        }\n-        return new int[]{offset + read, lastRead};\n-    }\n-\n-    private static byte[] resizeArray(final byte[] bytes) {\n-        byte[] biggerBytes = new byte[bytes.length * 2];\n-        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n-        return biggerBytes;\n-    }\n-\n-\n-    /**\n-     * Returns an encoded and decoded copy of the same random data.\n-     * \n-     * @param size amount of random data to generate and encode\n-     * @param urlSafe true if encoding be urlSafe\n-     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n-     */\n-    static byte[][] randomData(int size, boolean urlSafe) {\n-        Random r = new Random();\n-        byte[] decoded = new byte[size];\n-        r.nextBytes(decoded);\n-        byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n-        return new byte[][] {decoded, encoded};\n-    }\n-\n-    /**\n-     * Tests the supplied byte[] array to see if it contains the specified byte c.\n-     *\n-     * @param bytes byte[] array to test\n-     * @param c byte to look for\n-     * @return true if bytes contains c, false otherwise\n-     */\n-    static boolean bytesContain(byte[] bytes, byte c) {\n-        for (int i = 0; i < bytes.length; i++) {\n-            if (bytes[i] == c) { return true; }\n-        }\n-        return false;\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Random;\n+\n+/**\n+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n+ * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64TestData {\n+\n+    // OpenSSL doesn't include the final \\n, but it would be annoying beyond belief\n+    // to further parameterize commons-codec to support this pointless variation.\n+    final static String ENCODED\n+            = \"9IPNKwUvdLiIAp6ctz12SiQmOGstWyYvSPeevufDhrzaws65voykKjbIj33YWTa9\\n\"\n+            + \"xA7c/FHypWclrZhQ7onfc3JE93BJ5fT4R9zAEdjbjy1hv4ZYNnET4WJeXMLJ/5p+\\n\"\n+            + \"qBpTsPpepW8DNVYy1c02/1wyC+kgA6CvRUd9cSr/lt88AEdsTV4GMCn1+EwuAiYd\\n\"\n+            + \"ivxuzn+cLM8q2jewqlI52tP9J7Cs8vqG71s6+WAELKvm/UovvyaOi+OdMUfjQ0JL\\n\"\n+            + \"iLkHu6p9OwUgvQqiDKzEv/Augo0dTPZzYGEyCP5GVrle3QQdgciIHnpdd4VUTPGR\\n\"\n+            + \"UbXeKbh++U3fbJIng/sQXM3IYByMZ7xt9HWS1LUcRdQ7Prwn/IlQWxOMeq+KZJSo\\n\"\n+            + \"AviWtdserXyHbIEa//hmr4p/j80k0g9q35hq1ayGM9984ALTSaZ8WeyFbZx1CxC/\\n\"\n+            + \"Qoqf92UH/ylBRnSJNn4sS0oa3uUbNvOnpkB4D9V7Ut9atinCJrw+wiJcMl+9kp25\\n\"\n+            + \"1IUxBGA4cUxh0eaxk3ODWnwI95EktmWOKwCSP0xjWwIMxDjygwAG5R8fk9H9bVi1\\n\"\n+            + \"thMavm4nDc4vaNoSE1RnZNYwbiUVlVPM9EclvJWTWd6igWeA0MxHAA8iOM5Vnmqp\\n\"\n+            + \"/WGM7UDq59rBIdNQCoeTJaAkEtAuLL5zogOa5e+MzVjvB5MYQlOlaaTtQrRApXa5\\n\"\n+            + \"Z4VfEanu9UK2fi1T8jJPFC2PmXebxp0bnO+VW+bgyEdIIkIQCaZq1MKWC3KuiOS9\\n\"\n+            + \"BJ1t7O0A2JKJKvoE4UNulzV2TGCC+KAnmjRqQBqXlJmgjHQAoHNZKOma/uIQOsvf\\n\"\n+            + \"DnqicYdDmfyCYuV89HjA1H8tiDJ85VfsrFHdcbPAoNCpi65awJSHfdPO1NDONOK+\\n\"\n+            + \"+S7Y0VXUgoYYrBV4Y7YbC8wg/nqcimr3lm3tRyp+QsgKzdREbfNRk0F5PLyLfsUE\\n\"\n+            + \"lepjs1QdV3fEV1LJtiywA3ubVNQJRxhbYxa/C/Xy2qxpm6vvdL92l3q1ccev35Ic\\n\"\n+            + \"aOiSx7Im+/GxV2lVKdaOvYVGDD1zBRe6Y2CwQb9p088l3/93qGR5593NCiuPPWcs\\n\"\n+            + \"DWwUShM1EyW0FNX1F8bnzHnYijoyE/jf4s/l9bBd7yJdRWRCyih2WcypAiOIEkBs\\n\"\n+            + \"H+dCTgalu8sRDoMh4ZIBBdgHfoZUycLqReQFLZZ4Sl4zSmzt5vQxQFhEKb9+ff/4\\n\"\n+            + \"rb1KAo6wifengxVfIsa2b5ljXzAqXs7JkPvmC6fa7X4ZZndRokaxYlu3cg8OV+uG\\n\"\n+            + \"/6YAHZilo8at0OpkkNdNFuhwuGlkBqrZKNUj/gSiYYc06gF/r/z6iWAjpXJRW1qq\\n\"\n+            + \"3CLZXdZFZ/VrqXeVjtOAu2A=\\n\";\n+\n+    final static byte[] DECODED\n+            = {-12, -125, -51, 43, 5, 47, 116, -72, -120, 2, -98, -100, -73, 61, 118, 74, 36, 38, 56, 107, 45, 91, 38,\n+            47, 72, -9, -98, -66, -25, -61, -122, -68, -38, -62, -50, -71, -66, -116, -92, 42, 54, -56, -113, 125,\n+            -40, 89, 54, -67, -60, 14, -36, -4, 81, -14, -91, 103, 37, -83, -104, 80, -18, -119, -33, 115, 114, 68,\n+            -9, 112, 73, -27, -12, -8, 71, -36, -64, 17, -40, -37, -113, 45, 97, -65, -122, 88, 54, 113, 19, -31, 98,\n+            94, 92, -62, -55, -1, -102, 126, -88, 26, 83, -80, -6, 94, -91, 111, 3, 53, 86, 50, -43, -51, 54, -1, 92,\n+            50, 11, -23, 32, 3, -96, -81, 69, 71, 125, 113, 42, -1, -106, -33, 60, 0, 71, 108, 77, 94, 6, 48, 41, -11,\n+            -8, 76, 46, 2, 38, 29, -118, -4, 110, -50, 127, -100, 44, -49, 42, -38, 55, -80, -86, 82, 57, -38, -45,\n+            -3, 39, -80, -84, -14, -6, -122, -17, 91, 58, -7, 96, 4, 44, -85, -26, -3, 74, 47, -65, 38, -114, -117,\n+            -29, -99, 49, 71, -29, 67, 66, 75, -120, -71, 7, -69, -86, 125, 59, 5, 32, -67, 10, -94, 12, -84, -60, -65,\n+            -16, 46, -126, -115, 29, 76, -10, 115, 96, 97, 50, 8, -2, 70, 86, -71, 94, -35, 4, 29, -127, -56, -120,\n+            30, 122, 93, 119, -123, 84, 76, -15, -111, 81, -75, -34, 41, -72, 126, -7, 77, -33, 108, -110, 39, -125,\n+            -5, 16, 92, -51, -56, 96, 28, -116, 103, -68, 109, -12, 117, -110, -44, -75, 28, 69, -44, 59, 62, -68,\n+            39, -4, -119, 80, 91, 19, -116, 122, -81, -118, 100, -108, -88, 2, -8, -106, -75, -37, 30, -83, 124, -121,\n+            108, -127, 26, -1, -8, 102, -81, -118, 127, -113, -51, 36, -46, 15, 106, -33, -104, 106, -43, -84, -122,\n+            51, -33, 124, -32, 2, -45, 73, -90, 124, 89, -20, -123, 109, -100, 117, 11, 16, -65, 66, -118, -97, -9,\n+            101, 7, -1, 41, 65, 70, 116, -119, 54, 126, 44, 75, 74, 26, -34, -27, 27, 54, -13, -89, -90, 64, 120, 15,\n+            -43, 123, 82, -33, 90, -74, 41, -62, 38, -68, 62, -62, 34, 92, 50, 95, -67, -110, -99, -71, -44, -123,\n+            49, 4, 96, 56, 113, 76, 97, -47, -26, -79, -109, 115, -125, 90, 124, 8, -9, -111, 36, -74, 101, -114, 43,\n+            0, -110, 63, 76, 99, 91, 2, 12, -60, 56, -14, -125, 0, 6, -27, 31, 31, -109, -47, -3, 109, 88, -75, -74,\n+            19, 26, -66, 110, 39, 13, -50, 47, 104, -38, 18, 19, 84, 103, 100, -42, 48, 110, 37, 21, -107, 83, -52,\n+            -12, 71, 37, -68, -107, -109, 89, -34, -94, -127, 103, -128, -48, -52, 71, 0, 15, 34, 56, -50, 85, -98,\n+            106, -87, -3, 97, -116, -19, 64, -22, -25, -38, -63, 33, -45, 80, 10, -121, -109, 37, -96, 36, 18, -48,\n+            46, 44, -66, 115, -94, 3, -102, -27, -17, -116, -51, 88, -17, 7, -109, 24, 66, 83, -91, 105, -92, -19,\n+            66, -76, 64, -91, 118, -71, 103, -123, 95, 17, -87, -18, -11, 66, -74, 126, 45, 83, -14, 50, 79, 20, 45,\n+            -113, -103, 119, -101, -58, -99, 27, -100, -17, -107, 91, -26, -32, -56, 71, 72, 34, 66, 16, 9, -90, 106,\n+            -44, -62, -106, 11, 114, -82, -120, -28, -67, 4, -99, 109, -20, -19, 0, -40, -110, -119, 42, -6, 4, -31,\n+            67, 110, -105, 53, 118, 76, 96, -126, -8, -96, 39, -102, 52, 106, 64, 26, -105, -108, -103, -96, -116,\n+            116, 0, -96, 115, 89, 40, -23, -102, -2, -30, 16, 58, -53, -33, 14, 122, -94, 113, -121, 67, -103, -4,\n+            -126, 98, -27, 124, -12, 120, -64, -44, 127, 45, -120, 50, 124, -27, 87, -20, -84, 81, -35, 113, -77,\n+            -64, -96, -48, -87, -117, -82, 90, -64, -108, -121, 125, -45, -50, -44, -48, -50, 52, -30, -66, -7, 46,\n+            -40, -47, 85, -44, -126, -122, 24, -84, 21, 120, 99, -74, 27, 11, -52, 32, -2, 122, -100, -118, 106, -9,\n+            -106, 109, -19, 71, 42, 126, 66, -56, 10, -51, -44, 68, 109, -13, 81, -109, 65, 121, 60, -68, -117, 126,\n+            -59, 4, -107, -22, 99, -77, 84, 29, 87, 119, -60, 87, 82, -55, -74, 44, -80, 3, 123, -101, 84, -44, 9, 71,\n+            24, 91, 99, 22, -65, 11, -11, -14, -38, -84, 105, -101, -85, -17, 116, -65, 118, -105, 122, -75, 113,\n+            -57, -81, -33, -110, 28, 104, -24, -110, -57, -78, 38, -5, -15, -79, 87, 105, 85, 41, -42, -114, -67,\n+            -123, 70, 12, 61, 115, 5, 23, -70, 99, 96, -80, 65, -65, 105, -45, -49, 37, -33, -1, 119, -88, 100, 121,\n+            -25, -35, -51, 10, 43, -113, 61, 103, 44, 13, 108, 20, 74, 19, 53, 19, 37, -76, 20, -43, -11, 23, -58, -25,\n+            -52, 121, -40, -118, 58, 50, 19, -8, -33, -30, -49, -27, -11, -80, 93, -17, 34, 93, 69, 100, 66, -54, 40,\n+            118, 89, -52, -87, 2, 35, -120, 18, 64, 108, 31, -25, 66, 78, 6, -91, -69, -53, 17, 14, -125, 33, -31, -110,\n+            1, 5, -40, 7, 126, -122, 84, -55, -62, -22, 69, -28, 5, 45, -106, 120, 74, 94, 51, 74, 108, -19, -26, -12,\n+            49, 64, 88, 68, 41, -65, 126, 125, -1, -8, -83, -67, 74, 2, -114, -80, -119, -9, -89, -125, 21, 95, 34,\n+            -58, -74, 111, -103, 99, 95, 48, 42, 94, -50, -55, -112, -5, -26, 11, -89, -38, -19, 126, 25, 102, 119,\n+            81, -94, 70, -79, 98, 91, -73, 114, 15, 14, 87, -21, -122, -1, -90, 0, 29, -104, -91, -93, -58, -83, -48,\n+            -22, 100, -112, -41, 77, 22, -24, 112, -72, 105, 100, 6, -86, -39, 40, -43, 35, -2, 4, -94, 97, -121, 52,\n+            -22, 1, 127, -81, -4, -6, -119, 96, 35, -91, 114, 81, 91, 90, -86, -36, 34, -39, 93, -42, 69, 103, -11,\n+            107, -87, 119, -107, -114, -45, -128, -69, 96};\n+\n+    // Some utility code to help test chunked reads of the InputStream.\n+\n+    private final static int SIZE_KEY = 0;\n+    private final static int LAST_READ_KEY = 1;\n+\n+    static byte[] streamToBytes(final InputStream in) throws IOException {\n+        // new byte[7] is obviously quite slow, but helps exercise the code.\n+        byte[] buf = new byte[7];\n+        try {\n+            int[] status = fill(buf, 0, in);\n+            int size = status[SIZE_KEY];\n+            int lastRead = status[LAST_READ_KEY];\n+            while (lastRead != -1) {\n+                buf = resizeArray(buf);\n+                status = fill(buf, size, in);\n+                size = status[SIZE_KEY];\n+                lastRead = status[LAST_READ_KEY];\n+            }\n+            if (buf.length != size) {\n+                byte[] smallerBuf = new byte[size];\n+                System.arraycopy(buf, 0, smallerBuf, 0, size);\n+                buf = smallerBuf;\n+            }\n+        }\n+        finally {\n+            in.close();\n+        }\n+        return buf;\n+    }\n+\n+    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n+            throws IOException {\n+        int read = in.read(buf, offset, buf.length - offset);\n+        int lastRead = read;\n+        if (read == -1) {\n+            read = 0;\n+        }\n+        while (lastRead != -1 && read + offset < buf.length) {\n+            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n+            if (lastRead != -1) {\n+                read += lastRead;\n+            }\n+        }\n+        return new int[]{offset + read, lastRead};\n+    }\n+\n+    private static byte[] resizeArray(final byte[] bytes) {\n+        byte[] biggerBytes = new byte[bytes.length * 2];\n+        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n+        return biggerBytes;\n+    }\n+\n+\n+    /**\n+     * Returns an encoded and decoded copy of the same random data.\n+     * \n+     * @param size amount of random data to generate and encode\n+     * @param urlSafe true if encoding be urlSafe\n+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n+     */\n+    static byte[][] randomData(int size, boolean urlSafe) {\n+        Random r = new Random();\n+        byte[] decoded = new byte[size];\n+        r.nextBytes(decoded);\n+        byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n+        return new byte[][] {decoded, encoded};\n+    }\n+\n+    /**\n+     * Tests the supplied byte[] array to see if it contains the specified byte c.\n+     *\n+     * @param bytes byte[] array to test\n+     * @param c byte to look for\n+     * @return true if bytes contains c, false otherwise\n+     */\n+    static boolean bytesContain(byte[] bytes, byte c) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (bytes[i] == c) { return true; }\n+        }\n+        return false;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java\n+++ b/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.codec.binary;\n-\n-import java.io.UnsupportedEncodingException;\n-import java.util.Arrays;\n-\n-import junit.framework.Assert;\n-import junit.framework.TestCase;\n-\n-/**\n- * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n- * @version $Id: $\n- */\n-public class StringBytesUtilsTest extends TestCase {\n-\n-    private static byte[] BYTES_FIXTURE;\n-\n-    private static final String STRING_FIXTURE = \"ABC\";\n-    {\n-        try {\n-            BYTES_FIXTURE = \"abc\".getBytes(\"US-ASCII\");\n-        } catch (UnsupportedEncodingException e) {\n-            throw new IllegalArgumentException(e.toString());\n-        }\n-    }\n-\n-    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n-        String charsetName = \"ISO-8859-1\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesIso8859_1(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n-        String charsetName = \"US-ASCII\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesUsAscii(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetBytesUtf16() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesUtf16(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16BE\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesUtf16Be(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16LE\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesUtf16Le(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetBytesUtf8() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-8\";\n-        testGetSupportedBytes(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringBytesUtils.getSupportedBytes(STRING_FIXTURE, charsetName);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetSupportedBytesBadEnc() {\n-        try {\n-            StringBytesUtils.getSupportedBytes(STRING_FIXTURE, \"UNKNOWN\");\n-            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n-        } catch (IllegalStateException e) {\n-            // Expected\n-        }\n-    }\n-\n-    private void testNewString(String charsetName) throws UnsupportedEncodingException {\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newString(BYTES_FIXTURE, charsetName);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringBadEnc() {\n-        try {\n-            StringBytesUtils.newString(BYTES_FIXTURE, \"UNKNOWN\");\n-            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n-        } catch (IllegalStateException e) {\n-            // Expected\n-        }\n-    }\n-\n-    public void testNewStringIso8859_1() throws UnsupportedEncodingException {\n-        String charsetName = \"ISO-8859-1\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringIso8859_1(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringUsAscii() throws UnsupportedEncodingException {\n-        String charsetName = \"US-ASCII\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringUsAscii(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringUtf16() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringUtf16(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringUtf16Be() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16BE\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringUtf16Be(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringUtf16Le() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16LE\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringUtf16Le(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-    public void testNewStringUtf8() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-8\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringBytesUtils.newStringUtf8(BYTES_FIXTURE);\n-        Assert.assertEquals(expected, actual);\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id: $\n+ */\n+public class StringBytesUtilsTest extends TestCase {\n+\n+    private static byte[] BYTES_FIXTURE;\n+\n+    private static final String STRING_FIXTURE = \"ABC\";\n+    {\n+        try {\n+            BYTES_FIXTURE = \"abc\".getBytes(\"US-ASCII\");\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalArgumentException(e.toString());\n+        }\n+    }\n+\n+    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesIso8859_1(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesUsAscii(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesUtf16(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesUtf16Be(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesUtf16Le(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringBytesUtils.getSupportedBytes(STRING_FIXTURE, charsetName);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetSupportedBytesBadEnc() {\n+        try {\n+            StringBytesUtils.getSupportedBytes(STRING_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    private void testNewString(String charsetName) throws UnsupportedEncodingException {\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newString(BYTES_FIXTURE, charsetName);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringBadEnc() {\n+        try {\n+            StringBytesUtils.newString(BYTES_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    public void testNewStringIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringIso8859_1(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringUsAscii(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringUtf16(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringUtf16Be(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringUtf16Le(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringBytesUtils.newStringUtf8(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+}", "timestamp": 1248313610, "metainfo": ""}