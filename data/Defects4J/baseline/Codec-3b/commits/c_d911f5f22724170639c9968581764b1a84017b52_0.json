{"sha": "d911f5f22724170639c9968581764b1a84017b52", "log": "Remove tabs  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Hex.java\n+++ b/src/java/org/apache/commons/codec/binary/Hex.java\n \n            return out;\n     }\n-\t\n+\n     /**\n      * Converts an array of character bytes representing hexidecimal values into an\n      * array of bytes of those same values. The returned array will be half the\n      *                   to this function\n      * @see #decodeHex(char[])\n      */\n-\tpublic byte[] decode(byte[] array) throws DecoderException {\n-\t\treturn decodeHex(new String(array).toCharArray());\n-\t}\n-\t\n+    public byte[] decode(byte[] array) throws DecoderException {\n+        return decodeHex(new String(array).toCharArray());\n+    }\n+    \n     /**\n      * Converts a String or an array of character bytes representing hexidecimal values into an\n      * array of bytes of those same values. The returned array will be half the\n      *                   to this function or the object is not a String or char[]\n      * @see #decodeHex(char[])\n      */\n-\tpublic Object decode(Object object) throws DecoderException {\n-\t\ttry {\n+    public Object decode(Object object) throws DecoderException {\n+        try {\n             char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n-\t\t    return decodeHex(charArray);\n-\t\t} catch (ClassCastException e) {\n-\t\t    throw new DecoderException(e.getMessage());\n-\t\t}\n-\t}\n-\t\n+            return decodeHex(charArray);\n+        } catch (ClassCastException e) {\n+            throw new DecoderException(e.getMessage());\n+        }\n+    }\n+\n     /**\n      * Converts an array of bytes into an array of bytes for the characters representing the\n      * hexidecimal values of each byte in order. The returned array will be\n      * @return A byte[] containing the bytes of the hexidecimal characters\n      * @see #encodeHex(byte[])\n      */\n-\tpublic byte[] encode(byte[] array) {\n-\t\treturn new String(encodeHex(array)).getBytes();\n-\t}\n+    public byte[] encode(byte[] array) {\n+        return new String(encodeHex(array)).getBytes();\n+    }\n \n     /**\n      * Converts a String or an array of bytes into an array of characters representing the\n      * @throws EncoderException Thrown if the given object is not a String or byte[]\n      * @see #encodeHex(byte[])\n      */\n-\tpublic Object encode(Object object) throws EncoderException {\t\n-\t\ttry {\n+    public Object encode(Object object) throws EncoderException {    \n+        try {\n             byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;\n-\t\t\treturn encodeHex(byteArray);\n-\t\t} catch (ClassCastException e) {\n-\t\t\tthrow new EncoderException(e.getMessage());\n-\t\t}\n-\t}\n+            return encodeHex(byteArray);\n+        } catch (ClassCastException e) {\n+            throw new EncoderException(e.getMessage());\n+        }\n+    }\n \n }\n \n--- a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n      * Complex condition 0 for 'C'\n      */\n     private boolean conditionC0(String value, int index) {\n-\t\tif (contains(value, index, 4, \"CHIA\")) {\n-\t\t\treturn true;\n-\t\t} else if (index <= 1) {\n-\t\t\treturn false;\n-\t\t} else if (isVowel(charAt(value, index - 2))) {\n-\t\t\treturn false;\n-\t\t} else if (!contains(value, index - 1, 3, \"ACH\")) {\n-\t\t\treturn false;\n-\t\t} else {\n-\t\t\tchar c = charAt(value, index + 2);\n-\t\t\treturn (c != 'I' && c != 'E') ||\n-\t\t\t\t\tcontains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n-\t\t}\n-\t}\n-    \n-    /**\n-\t * Complex condition 0 for 'CH'\n-\t */\n+        if (contains(value, index, 4, \"CHIA\")) {\n+            return true;\n+        } else if (index <= 1) {\n+            return false;\n+        } else if (isVowel(charAt(value, index - 2))) {\n+            return false;\n+        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n+            return false;\n+        } else {\n+            char c = charAt(value, index + 2);\n+            return (c != 'I' && c != 'E') ||\n+                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'CH'\n+     */\n     private boolean conditionCH0(String value, int index) {\n         if (index != 0) {\n             return false;\n      * Complex condition 0 for 'M'\n      */\n     private boolean conditionM0(String value, int index) {\n-\t\tif (charAt(value, index + 1) == 'M') {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn contains(value, index - 1, 3, \"UMB\") &&\n-\t\t\t\t((index + 1) == value.length() - 1 || contains(value,\n-\t\t\t\t\t\tindex + 2, 2, \"ER\"));\n-\t}\n+        if (charAt(value, index + 1) == 'M') {\n+            return true;\n+        }\n+        return contains(value, index - 1, 3, \"UMB\") &&\n+                ((index + 1) == value.length() - 1 || contains(value,\n+                        index + 2, 2, \"ER\"));\n+    }\n     \n     //-- BEGIN HELPER FUNCTIONS --//\n \n     /**\n-\t * Determines whether or not a value is of slavo-germanic orgin. A value is\n-\t * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n-\t */\n+     * Determines whether or not a value is of slavo-germanic orgin. A value is\n+     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n+     */\n     private boolean isSlavoGermanic(String value) {\n         return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n             value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n      * Cleans the input\n      */    \n     private String cleanInput(String input) {\n-\t\tif (input == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tinput = input.trim();\n-\t\tif (input.length() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn input.toUpperCase(java.util.Locale.ENGLISH);\n-\t}\n-\n-    /**\n-\t * Gets the character at index <code>index</code> if available, otherwise\n-\t * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n-\t * of a default\n-\t */    \n+        if (input == null) {\n+            return null;\n+        }\n+        input = input.trim();\n+        if (input.length() == 0) {\n+            return null;\n+        }\n+        return input.toUpperCase(java.util.Locale.ENGLISH);\n+    }\n+\n+    /**\n+     * Gets the character at index <code>index</code> if available, otherwise\n+     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n+     * of a default\n+     */    \n     protected char charAt(String value, int index) {\n         if (index < 0 || index >= value.length()) {\n             return Character.MIN_VALUE;\n--- a/src/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/java/org/apache/commons/codec/language/Metaphone.java\n         int n = 0 ;\n \n         while ((code.length() < this.getMaxCodeLen()) && \n-        \t   (n < wdsz) ) { // max code size of 4 works well\n+               (n < wdsz) ) { // max code size of 4 works well\n             char symb = local.charAt(n) ;\n             // remove duplicate letters except C\n             if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                 case 'B' :\n                     if ( isPreviousChar(local, n, 'M') && \n                          isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n-\t\t\t\t\t\tbreak;\n+                        break;\n                     }\n                     code.append(symb);\n                     break;\n                         break; // CI,CE,CY -> S\n                     }\n                     if (isPreviousChar(local, n, 'S') &&\n-\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n+                        isNextChar(local, n, 'H') ) { // SCH->sk\n                         code.append('K') ; \n                         break ;\n                     }\n                     if (isNextChar(local, n, 'H')) { // detect CH\n                         if ((n == 0) && \n-                        \t(wdsz >= 3) && \n+                            (wdsz >= 3) && \n                             isVowel(local,2) ) { // CH consonant -> K consonant\n                             code.append('K');\n                         } else { \n                         break;\n                     }\n                     if ((n > 0) && \n-                    \t( regionMatch(local, n, \"GN\") ||\n-\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n+                        ( regionMatch(local, n, \"GN\") ||\n+                          regionMatch(local, n, \"GNED\") ) ) {\n                         break; // silent G\n                     }\n                     if (isPreviousChar(local, n, 'G')) {\n                     break;\n                 case 'S' :\n                     if (regionMatch(local,n,\"SH\") || \n-\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n-\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n+                        regionMatch(local,n,\"SIO\") || \n+                        regionMatch(local,n,\"SIA\")) {\n                         code.append('X');\n                     } else {\n                         code.append('S');\n                     break;\n                 case 'T' :\n                     if (regionMatch(local,n,\"TIA\") || \n-\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n+                        regionMatch(local,n,\"TIO\")) {\n                         code.append('X'); \n                         break;\n                     }\n                     if (regionMatch(local,n,\"TCH\")) {\n-\t\t\t\t\t\t// Silent if in \"TCH\"\n+                        // Silent if in \"TCH\"\n                         break;\n                     }\n                     // substitute numeral 0 for TH (resembles theta after all)\n                     code.append('F'); break ;\n                 case 'W' : case 'Y' : // silent if not followed by vowel\n                     if (!isLastChar(wdsz,n) && \n-                    \tisVowel(local,n+1)) {\n+                        isVowel(local,n+1)) {\n                         code.append(symb);\n                     }\n                     break ;\n                 n++ ;\n             } // end else from symb != 'C'\n             if (code.length() > this.getMaxCodeLen()) { \n-            \tcode.setLength(this.getMaxCodeLen()); \n+                code.setLength(this.getMaxCodeLen()); \n             }\n         }\n         return code.toString();\n     }\n \n-\tprivate boolean isVowel(StringBuffer string, int index) {\n-\t\treturn VOWELS.indexOf(string.charAt(index)) >= 0;\n-\t}\n-\n-\tprivate boolean isPreviousChar(StringBuffer string, int index, char c) {\n-\t\tboolean matches = false;\n-\t\tif( index > 0 &&\n-\t\t    index < string.length() ) {\n-\t\t\tmatches = string.charAt(index - 1) == c;\n-\t\t}\n-\t\treturn matches;\n-\t}\n-\n-\tprivate boolean isNextChar(StringBuffer string, int index, char c) {\n-\t\tboolean matches = false;\n-\t\tif( index >= 0 &&\n-\t\t    index < string.length() - 1 ) {\n-\t\t\tmatches = string.charAt(index + 1) == c;\n-\t\t}\n-\t\treturn matches;\n-\t}\n-\n-\tprivate boolean regionMatch(StringBuffer string, int index, String test) {\n-\t\tboolean matches = false;\n-\t\tif( index >= 0 &&\n-\t\t    (index + test.length() - 1) < string.length() ) {\n-\t\t\tString substring = string.substring( index, index + test.length());\n-\t\t\tmatches = substring.equals( test );\n-\t\t}\n-\t\treturn matches;\n-\t}\n-\n-\tprivate boolean isLastChar(int wdsz, int n) {\n-\t\treturn n + 1 == wdsz;\n-\t} \n+    private boolean isVowel(StringBuffer string, int index) {\n+        return VOWELS.indexOf(string.charAt(index)) >= 0;\n+    }\n+\n+    private boolean isPreviousChar(StringBuffer string, int index, char c) {\n+        boolean matches = false;\n+        if( index > 0 &&\n+            index < string.length() ) {\n+            matches = string.charAt(index - 1) == c;\n+        }\n+        return matches;\n+    }\n+\n+    private boolean isNextChar(StringBuffer string, int index, char c) {\n+        boolean matches = false;\n+        if( index >= 0 &&\n+            index < string.length() - 1 ) {\n+            matches = string.charAt(index + 1) == c;\n+        }\n+        return matches;\n+    }\n+\n+    private boolean regionMatch(StringBuffer string, int index, String test) {\n+        boolean matches = false;\n+        if( index >= 0 &&\n+            (index + test.length() - 1) < string.length() ) {\n+            String substring = string.substring( index, index + test.length());\n+            matches = substring.equals( test );\n+        }\n+        return matches;\n+    }\n+\n+    private boolean isLastChar(int wdsz, int n) {\n+        return n + 1 == wdsz;\n+    } \n     \n     \n     /**\n--- a/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n+++ b/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n public class RefinedSoundex implements StringEncoder {\n \n    /**\n-\t * RefinedSoundex is *refined* for a number of reasons one being that the\n-\t * mappings have been altered. This implementation contains default\n-\t * mappings for US English.\n-\t */\n+     * RefinedSoundex is *refined* for a number of reasons one being that the\n+     * mappings have been altered. This implementation contains default\n+     * mappings for US English.\n+     */\n     public static final char[] US_ENGLISH_MAPPING = \"01360240043788015936020505\".toCharArray();\n \n     /**\n-\t * Every letter of the alphabet is \"mapped\" to a numerical value. This char\n-\t * array holds the values to which each letter is mapped. This\n-\t * implementation contains a default map for US_ENGLISH\n-\t */\n+     * Every letter of the alphabet is \"mapped\" to a numerical value. This char\n+     * array holds the values to which each letter is mapped. This\n+     * implementation contains a default map for US_ENGLISH\n+     */\n     private final char[] soundexMapping;\n \n     /**\n-\t * This static variable contains an instance of the RefinedSoundex using\n-\t * the US_ENGLISH mapping.\n-\t */\n+     * This static variable contains an instance of the RefinedSoundex using\n+     * the US_ENGLISH mapping.\n+     */\n     public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\n \n      /**\n-\t * Creates an instance of the RefinedSoundex object using the default US\n-\t * English mapping.\n-\t */\n+     * Creates an instance of the RefinedSoundex object using the default US\n+     * English mapping.\n+     */\n     public RefinedSoundex() {\n         this(US_ENGLISH_MAPPING);\n     }\n \n     /**\n-\t * Creates a refined soundex instance using a custom mapping. This\n-\t * constructor can be used to customize the mapping, and/or possibly\n-\t * provide an internationalized mapping for a non-Western character set.\n-\t * \n-\t * @param mapping\n-\t *                  Mapping array to use when finding the corresponding code for\n-\t *                  a given character\n-\t */\n+     * Creates a refined soundex instance using a custom mapping. This\n+     * constructor can be used to customize the mapping, and/or possibly\n+     * provide an internationalized mapping for a non-Western character set.\n+     * \n+     * @param mapping\n+     *                  Mapping array to use when finding the corresponding code for\n+     *                  a given character\n+     */\n     public RefinedSoundex(char[] mapping) {\n         this.soundexMapping = mapping;\n     }\n \n     /**\n-\t * Returns the number of characters in the two encoded Strings that are the\n-\t * same. This return value ranges from 0 to the length of the shortest\n-\t * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n-\t * example) indicates strong similarity or identical values. For refined\n-\t * Soundex, the return value can be greater than 4.\n-\t * \n-\t * @param s1\n-\t *                  A String that will be encoded and compared.\n-\t * @param s2\n-\t *                  A String that will be encoded and compared.\n-\t * @return The number of characters in the two encoded Strings that are the\n-\t *             same from 0 to to the length of the shortest encoded String.\n-\t * \n-\t * @see SoundexUtils#difference(StringEncoder,String,String)\n-\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n-\t *          MS T-SQL DIFFERENCE</a>\n-\t * \n-\t * @throws EncoderException\n-\t *                  if an error occurs encoding one of the strings\n+     * Returns the number of characters in the two encoded Strings that are the\n+     * same. This return value ranges from 0 to the length of the shortest\n+     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n+     * example) indicates strong similarity or identical values. For refined\n+     * Soundex, the return value can be greater than 4.\n+     * \n+     * @param s1\n+     *                  A String that will be encoded and compared.\n+     * @param s2\n+     *                  A String that will be encoded and compared.\n+     * @return The number of characters in the two encoded Strings that are the\n+     *             same from 0 to to the length of the shortest encoded String.\n+     * \n+     * @see SoundexUtils#difference(StringEncoder,String,String)\n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     * \n+     * @throws EncoderException\n+     *                  if an error occurs encoding one of the strings\n      * @since 1.3\n-\t */\n+     */\n     public int difference(String s1, String s2) throws EncoderException {\n         return SoundexUtils.difference(this, s1, s2);\n     }\n \n     /**\n-\t * Encodes an Object using the refined soundex algorithm. This method is\n-\t * provided in order to satisfy the requirements of the Encoder interface,\n-\t * and will throw an EncoderException if the supplied object is not of type\n-\t * java.lang.String.\n-\t * \n-\t * @param pObject\n-\t *                  Object to encode\n-\t * @return An object (or type java.lang.String) containing the refined\n-\t *             soundex code which corresponds to the String supplied.\n-\t * @throws EncoderException\n-\t *                  if the parameter supplied is not of type java.lang.String\n-\t */\n+     * Encodes an Object using the refined soundex algorithm. This method is\n+     * provided in order to satisfy the requirements of the Encoder interface,\n+     * and will throw an EncoderException if the supplied object is not of type\n+     * java.lang.String.\n+     * \n+     * @param pObject\n+     *                  Object to encode\n+     * @return An object (or type java.lang.String) containing the refined\n+     *             soundex code which corresponds to the String supplied.\n+     * @throws EncoderException\n+     *                  if the parameter supplied is not of type java.lang.String\n+     */\n     public Object encode(Object pObject) throws EncoderException {\n         if (!(pObject instanceof java.lang.String)) {\n             throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\");\n     }\n \n     /**\n-\t * Encodes a String using the refined soundex algorithm.\n-\t * \n-\t * @param pString\n-\t *                  A String object to encode\n-\t * @return A Soundex code corresponding to the String supplied\n-\t */\n+     * Encodes a String using the refined soundex algorithm.\n+     * \n+     * @param pString\n+     *                  A String object to encode\n+     * @return A Soundex code corresponding to the String supplied\n+     */\n     public String encode(String pString) {\n         return soundex(pString);\n     }\n \n     /**\n-\t * Returns the mapping code for a given character. The mapping codes are\n-\t * maintained in an internal char array named soundexMapping, and the\n-\t * default values of these mappings are US English.\n-\t * \n-\t * @param c\n-\t *                  char to get mapping for\n-\t * @return A character (really a numeral) to return for the given char\n-\t */\n+     * Returns the mapping code for a given character. The mapping codes are\n+     * maintained in an internal char array named soundexMapping, and the\n+     * default values of these mappings are US English.\n+     * \n+     * @param c\n+     *                  char to get mapping for\n+     * @return A character (really a numeral) to return for the given char\n+     */\n     char getMappingCode(char c) {\n         if (!Character.isLetter(c)) {\n             return 0;\n     }\n \n     /**\n-\t * Retreives the Refined Soundex code for a given String object.\n-\t * \n-\t * @param str\n-\t *                  String to encode using the Refined Soundex algorithm\n-\t * @return A soundex code for the String supplied\n-\t */\n+     * Retreives the Refined Soundex code for a given String object.\n+     * \n+     * @param str\n+     *                  String to encode using the Refined Soundex algorithm\n+     * @return A soundex code for the String supplied\n+     */\n     public String soundex(String str) {\n         if (str == null) {\n             return null;\n--- a/src/java/org/apache/commons/codec/language/SoundexUtils.java\n+++ b/src/java/org/apache/commons/codec/language/SoundexUtils.java\n final class SoundexUtils {\n \n     /**\n-\t * Cleans up the input string before Soundex processing by only returning\n-\t * upper case letters.\n-\t * \n-\t * @param str\n-\t *                  The String to clean.\n-\t * @return A clean String.\n-\t */\n+     * Cleans up the input string before Soundex processing by only returning\n+     * upper case letters.\n+     * \n+     * @param str\n+     *                  The String to clean.\n+     * @return A clean String.\n+     */\n     static String clean(String str) {\n         if (str == null || str.length() == 0) {\n             return str;\n     }\n \n     /**\n-\t * Encodes the Strings and returns the number of characters in the two\n-\t * encoded Strings that are the same.\n-\t * <ul>\n-\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n-\t * little or no similarity, and 4 indicates strong similarity or identical\n-\t * values.</li>\n-\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n-\t * </ul>\n-\t * \n-\t * @param encoder\n-\t *                  The encoder to use to encode the Strings.\n-\t * @param s1\n-\t *                  A String that will be encoded and compared.\n-\t * @param s2\n-\t *                  A String that will be encoded and compared.\n-\t * @return The number of characters in the two Soundex encoded Strings that\n-\t *             are the same.\n-\t * \n-\t * @see #differenceEncoded(String,String)\n-\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n-\t *          MS T-SQL DIFFERENCE</a>\n-\t * \n-\t * @throws EncoderException\n-\t *                  if an error occurs encoding one of the strings\n-\t */\n+     * Encodes the Strings and returns the number of characters in the two\n+     * encoded Strings that are the same.\n+     * <ul>\n+     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n+     * little or no similarity, and 4 indicates strong similarity or identical\n+     * values.</li>\n+     * <li>For refined Soundex, the return value can be greater than 4.</li>\n+     * </ul>\n+     * \n+     * @param encoder\n+     *                  The encoder to use to encode the Strings.\n+     * @param s1\n+     *                  A String that will be encoded and compared.\n+     * @param s2\n+     *                  A String that will be encoded and compared.\n+     * @return The number of characters in the two Soundex encoded Strings that\n+     *             are the same.\n+     * \n+     * @see #differenceEncoded(String,String)\n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     * \n+     * @throws EncoderException\n+     *                  if an error occurs encoding one of the strings\n+     */\n     static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n         return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n     }\n \n     /**\n-\t * Returns the number of characters in the two Soundex encoded Strings that\n-\t * are the same.\n-\t * <ul>\n-\t * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n-\t * little or no similarity, and 4 indicates strong similarity or identical\n-\t * values.</li>\n-\t * <li>For refined Soundex, the return value can be greater than 4.</li>\n-\t * </ul>\n-\t * \n-\t * @param es1\n-\t *                  An encoded String.\n-\t * @param es2\n-\t *                  An encoded String.\n-\t * @return The number of characters in the two Soundex encoded Strings that\n-\t *             are the same.\n-\t * \n-\t * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n-\t *          MS T-SQL DIFFERENCE</a>\n-\t */\n+     * Returns the number of characters in the two Soundex encoded Strings that\n+     * are the same.\n+     * <ul>\n+     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n+     * little or no similarity, and 4 indicates strong similarity or identical\n+     * values.</li>\n+     * <li>For refined Soundex, the return value can be greater than 4.</li>\n+     * </ul>\n+     * \n+     * @param es1\n+     *                  An encoded String.\n+     * @param es2\n+     *                  An encoded String.\n+     * @return The number of characters in the two Soundex encoded Strings that\n+     *             are the same.\n+     * \n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     */\n     static int differenceEncoded(String es1, String es2) {\n \n         if (es1 == null || es2 == null) {\n--- a/src/test/org/apache/commons/codec/BinaryEncoderAbstractTest.java\n+++ b/src/test/org/apache/commons/codec/BinaryEncoderAbstractTest.java\n \n     public void testEncodeNull() throws Exception {\n         BinaryEncoder encoder = makeEncoder();\n-\ttry {\n-\t    encoder.encode(null);\n-\t} catch( EncoderException ee ) {\n-\t    // An exception should be thrown\n-\t}\n+        try {\n+            encoder.encode(null);\n+        } catch( EncoderException ee ) {\n+            // An exception should be thrown\n+        }\n     }        \n }\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n \n     public void testKnownEncodings() {\n         assertEquals(\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\",new String(Base64.encodeBase64(\"The quick brown fox jumped over the lazy dogs.\".getBytes())));\n-\tassertEquals(\"YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs\\r\\nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo\\r\\nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi\\r\\nbGFoIGJsYWg=\\r\\n\",new String(Base64.encodeBase64Chunked(\"blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah\".getBytes())));\n+        assertEquals(\"YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs\\r\\nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo\\r\\nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi\\r\\nbGFoIGJsYWg=\\r\\n\",new String(Base64.encodeBase64Chunked(\"blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah\".getBytes())));\n         assertEquals(\"SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg==\",new String(Base64.encodeBase64(\"It was the best of times, it was the worst of times.\".getBytes())));\n         assertEquals(\"aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw==\",new String(Base64.encodeBase64(\"http://jakarta.apache.org/commmons\".getBytes())));\n         assertEquals(\"QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg==\",new String(Base64.encodeBase64(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\".getBytes())));\n         assertEquals(\"xyzzy!\",new String(Base64.decodeBase64(\"eHl6enkh\".getBytes())));\n         } \n \n-\tpublic void testNonBase64Test() throws Exception {\n-\n-\t\tbyte[] bArray = { '%' };\n-\n-\t\tassertFalse( \"Invalid Base64 array was incorrectly validated as \" +\n-\t\t\t\t\t \"an array of Base64 encoded data\", \n-\t\t\t\t\t Base64.isArrayByteBase64( bArray ) );\n+    public void testNonBase64Test() throws Exception {\n+\n+        byte[] bArray = { '%' };\n+\n+        assertFalse( \"Invalid Base64 array was incorrectly validated as \" +\n+                     \"an array of Base64 encoded data\", \n+                     Base64.isArrayByteBase64( bArray ) );\n         \n-\t\tboolean exceptionThrown = false;\n-\n-\t\ttry {\n-\t\t\tBase64 b64 = new Base64();\n-\t\t\tbyte[] result = b64.decode( bArray );\n+        boolean exceptionThrown = false;\n+\n+        try {\n+            Base64 b64 = new Base64();\n+            byte[] result = b64.decode( bArray );\n             \n-\t\t\tassertTrue( \"The result should be empty as the test encoded content did \" +\n-\t\t\t\t\"not contain any valid base 64 characters\", result.length == 0);\n-\t\t} \n-\t\tcatch( Exception e ) {\n-\t\t\texceptionThrown = true;\n-\t\t}\n-\n-\t\tassertFalse( \"Exception was thrown when trying to decode \" +\n-\t\t\t\t\t\"invalid base64 encoded data - RFC 2045 requires that all \" +\n-\t\t\t\t\t\"non base64 character be discarded, an exception should not\" +\n-\t\t\t\t\t\" have been thrown\", exceptionThrown );\n+            assertTrue( \"The result should be empty as the test encoded content did \" +\n+                \"not contain any valid base 64 characters\", result.length == 0);\n+        } \n+        catch( Exception e ) {\n+            exceptionThrown = true;\n+        }\n+\n+        assertFalse( \"Exception was thrown when trying to decode \" +\n+                    \"invalid base64 encoded data - RFC 2045 requires that all \" +\n+                    \"non base64 character be discarded, an exception should not\" +\n+                    \" have been thrown\", exceptionThrown );\n           \n \n-\t}\n+    }\n     \n-\tpublic void testIgnoringNonBase64InDecode() throws Exception {\n-\t\tassertEquals(\"The quick brown fox jumped over the lazy dogs.\",new String(Base64.decodeBase64(\"VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve\\n\\r\\t%#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes())));\n-\t}\n+    public void testIgnoringNonBase64InDecode() throws Exception {\n+        assertEquals(\"The quick brown fox jumped over the lazy dogs.\",new String(Base64.decodeBase64(\"VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve\\n\\r\\t%#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes())));\n+    }\n \n     public void testIsArrayByteBase64() {        \n         assertFalse(Base64.isArrayByteBase64(new byte[] {Byte.MIN_VALUE}));\n         BigInteger bigInt1 = new BigInteger(\"85739377120809420210425962799\" +\n             \"0318636601332086981\");\n \n-    \tassertEquals(encodedInt1, new String(Base64.encodeInteger(bigInt1)));\n+        assertEquals(encodedInt1, new String(Base64.encodeInteger(bigInt1)));\n         assertEquals(bigInt1, Base64.decodeInteger(encodedInt1.getBytes()));\n     }\n \n--- a/src/test/org/apache/commons/codec/digest/DigestUtilsTest.java\n+++ b/src/test/org/apache/commons/codec/digest/DigestUtilsTest.java\n     }\n     \n     /**\n-\t * An MD5 hash converted to hex should always be 32 characters.\n-\t */\n+     * An MD5 hash converted to hex should always be 32 characters.\n+     */\n     public void testMD5HexLength() {\n         String hashMe = \"this is some string that is longer than 32 characters\";\n         String hash = DigestUtils.md5Hex(hashMe.getBytes());\n     }\n \n     /**\n-\t * An MD5 hash should always be a 16 element byte[].\n-\t */\n+     * An MD5 hash should always be a 16 element byte[].\n+     */\n     public void testMD5Length() {\n         String hashMe = \"this is some string that is longer than 16 characters\";\n         byte[] hash = DigestUtils.md5(hashMe.getBytes());\n     }\n \n     public void testSha256() throws IOException {\n-\t// Examples from FIPS 180-2\n-\tassertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n-\t\t     DigestUtils.sha256Hex(\"abc\"));\n-\tassertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n-\t\t     DigestUtils.sha256Hex(\"abc\".getBytes()));\n-\tassertEquals(\"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\",\n-\t\t     DigestUtils.sha256Hex(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"));\n+    // Examples from FIPS 180-2\n+    assertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n+             DigestUtils.sha256Hex(\"abc\"));\n+    assertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n+             DigestUtils.sha256Hex(\"abc\".getBytes()));\n+    assertEquals(\"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\",\n+             DigestUtils.sha256Hex(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"));\n     \n     assertEquals(DigestUtils.sha256Hex(testData),\n             DigestUtils.sha256Hex(new ByteArrayInputStream(testData)));\n     }\n \n     public void testSha384() throws IOException {\n-\t// Examples from FIPS 180-2\n-\tassertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n-\t\t     \"8086072ba1e7cc2358baeca134c825a7\",\n-\t\t     DigestUtils.sha384Hex(\"abc\"));\n-\tassertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n-\t\t     \"8086072ba1e7cc2358baeca134c825a7\",\n-\t\t     DigestUtils.sha384Hex(\"abc\".getBytes()));\n-\tassertEquals(\"09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712\" +\n-\t        \"fcc7c71a557e2db966c3e9fa91746039\",\n-\t\t     DigestUtils.sha384Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" +\n-\t\t\t\t\t   \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n+    // Examples from FIPS 180-2\n+    assertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n+             \"8086072ba1e7cc2358baeca134c825a7\",\n+             DigestUtils.sha384Hex(\"abc\"));\n+    assertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n+             \"8086072ba1e7cc2358baeca134c825a7\",\n+             DigestUtils.sha384Hex(\"abc\".getBytes()));\n+    assertEquals(\"09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712\" +\n+            \"fcc7c71a557e2db966c3e9fa91746039\",\n+             DigestUtils.sha384Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" +\n+                       \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n     assertEquals(DigestUtils.sha384Hex(testData),\n             DigestUtils.sha384Hex(new ByteArrayInputStream(testData)));\n     }    \n \n     public void testSha512() throws IOException {\n-\t// Examples from FIPS 180-2\n-\tassertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n-\t        \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n-\t\t     DigestUtils.sha512Hex(\"abc\"));\n-\tassertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n-\t\t     \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n-\t\t     DigestUtils.sha512Hex(\"abc\".getBytes()));\n-\tassertEquals(\"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018\" + \n-\t\t     \"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909\",\n-\t\t     DigestUtils.sha512Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" + \n-\t\t\t\t\t   \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n+    // Examples from FIPS 180-2\n+    assertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n+            \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n+             DigestUtils.sha512Hex(\"abc\"));\n+    assertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n+             \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n+             DigestUtils.sha512Hex(\"abc\".getBytes()));\n+    assertEquals(\"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018\" + \n+             \"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909\",\n+             DigestUtils.sha512Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" + \n+                       \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n     assertEquals(DigestUtils.sha512Hex(testData),\n             DigestUtils.sha512Hex(new ByteArrayInputStream(testData)));\n }\n--- a/src/test/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n+++ b/src/test/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n public class DoubleMetaphoneTest extends StringEncoderAbstractTest {\n \n     /**\n-\t * Test data from http://aspell.sourceforge.net/test/batch0.tab.\n-\t * \n-\t * \"Copyright (C) 2002 Kevin Atkinson (kevina@gnu.org). Verbatim copying\n-\t * and distribution of this entire article is permitted in any medium,\n-\t * provided this notice is preserved.\"\n+     * Test data from http://aspell.sourceforge.net/test/batch0.tab.\n+     * \n+     * \"Copyright (C) 2002 Kevin Atkinson (kevina@gnu.org). Verbatim copying\n+     * and distribution of this entire article is permitted in any medium,\n+     * provided this notice is preserved.\"\n      * \n      * Massaged the test data in the array below.\n-\t */\n+     */\n     private static final String[][] FIXTURE = { { \"Accosinly\", \"Occasionally\" }, {\n             \"Ciculer\", \"Circler\" }, {\n             \"Circue\", \"Circle\" }, {\n     };\n \n     /**\n-\t * A subset of FIXTURE generated by this test.\n-\t */\n+     * A subset of FIXTURE generated by this test.\n+     */\n     private static final String[][] MATCHES = { { \"Accosinly\", \"Occasionally\" }, {\n             \"Maddness\", \"Madness\" }, {\n             \"Occusionaly\", \"Occasionally\" }, {\n     }\n \n     /**\n-\t * Tests encoding APIs in one place.\n-\t */\n+     * Tests encoding APIs in one place.\n+     */\n     private void assertDoubleMetaphone(String expected, String source) {\n         assertEquals(expected, this.getDoubleMetaphone().encode(source));\n         try {\n     }\n \n     /**\n-\t * Tests encoding APIs in one place.\n-\t */\n+     * Tests encoding APIs in one place.\n+     */\n     public void assertDoubleMetaphoneAlt(String expected, String source) {\n         assertEquals(expected, this.getDoubleMetaphone().doubleMetaphone(source, true));\n     }\n     }\n \n     /**\n-\t * Example in the original article but failures in this Java impl:\n-\t */\n+     * Example in the original article but failures in this Java impl:\n+     */\n     public void testIsDoubleMetaphoneEqualExtended1() {\n         //        String[][] testFixture = new String[][] { { \"Smith\", \"Schmidt\" }\n         //        };\n     }\n \n     /**\n-\t * Used to generate the MATCHES array and test possible matches from the\n-\t * FIXTURE arrary.\n-\t */\n+     * Used to generate the MATCHES array and test possible matches from the\n+     * FIXTURE arrary.\n+     */\n     public void testIsDoubleMetaphoneEqualExtended3() {\n         this.validateFixture(FIXTURE);\n         StringBuffer failures = new StringBuffer();\n--- a/src/test/org/apache/commons/codec/language/MetaphoneTest.java\n+++ b/src/test/org/apache/commons/codec/language/MetaphoneTest.java\n         }\n     }\n     /**\n-\t * @return Returns the metaphone.\n-\t */\n+     * @return Returns the metaphone.\n+     */\n     private Metaphone getMetaphone() {\n         return this.metaphone;\n     }\n     }\n \n     /**\n-\t * @param metaphone\n-\t *                  The metaphone to set.\n-\t */\n+     * @param metaphone\n+     *                  The metaphone to set.\n+     */\n     private void setMetaphone(Metaphone metaphone) {\n         this.metaphone = metaphone;\n     }\n     }\n \n     /**\n-\t * Matches computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Matches computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqual2() {\n         this.assertMetaphoneEqual(new String[][] { { \"Lawrence\", \"Lorenza\" }, {\n                 \"Gary\", \"Cahra\" }, });\n     }\n \n     /**\n-\t * Initial AE case.\n-\t * \n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Initial AE case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualAero() {\n         this.assertIsMetaphoneEqual(\"Aero\", new String[] { \"Eure\" });\n     }\n \n     /**\n-\t * Initial WH case.\n-\t * \n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Initial WH case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualWhite() {\n         this.assertIsMetaphoneEqual(\n             \"White\",\n     }\n \n     /**\n-\t * Initial A, not followed by an E case.\n-\t * \n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Initial A, not followed by an E case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualAlbert() {\n         this.assertIsMetaphoneEqual(\"Albert\", new String[] { \"Ailbert\", \"Alberik\", \"Albert\", \"Alberto\", \"Albrecht\" });\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualGary() {\n         this.assertIsMetaphoneEqual(\n             \"Gary\",\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualJohn() {\n         this.assertIsMetaphoneEqual(\n             \"John\",\n     }\n \n     /**\n-\t * Initial KN case.\n-\t * \n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Initial KN case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualKnight() {\n         this.assertIsMetaphoneEqual(\n             \"Knight\",\n                 \"Nydia\" });\n     }\n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualMary() {\n         this.assertIsMetaphoneEqual(\n             \"Mary\",\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualParis() {\n         this.assertIsMetaphoneEqual(\"Paris\", new String[] { \"Pearcy\", \"Perris\", \"Piercy\", \"Pierz\", \"Pryse\" });\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualPeter() {\n         this.assertIsMetaphoneEqual(\n             \"Peter\",\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualRay() {\n         this.assertIsMetaphoneEqual(\"Ray\", new String[] { \"Ray\", \"Rey\", \"Roi\", \"Roy\", \"Ruy\" });\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualSusan() {\n         this.assertIsMetaphoneEqual(\n             \"Susan\",\n     }\n \n     /**\n-\t * Initial WR case.\n-\t * \n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Initial WR case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualWright() {\n         this.assertIsMetaphoneEqual(\"Wright\", new String[] { \"Rota\", \"Rudd\", \"Ryde\" });\n     }\n \n     /**\n-\t * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n-\t */\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n     public void testIsMetaphoneEqualXalan() {\n         this.assertIsMetaphoneEqual(\n             \"Xalan\",\n     }\n \n     public void testMetaphone() {\n-\t\tassertEquals(\"HL\", this.getMetaphone().metaphone(\"howl\"));\n+        assertEquals(\"HL\", this.getMetaphone().metaphone(\"howl\"));\n         assertEquals(\"TSTN\", this.getMetaphone().metaphone(\"testing\"));\n         assertEquals(\"0\", this.getMetaphone().metaphone(\"The\"));\n         assertEquals(\"KK\", this.getMetaphone().metaphone(\"quick\"));\n         assertEquals(\"LS\", this.getMetaphone().metaphone(\"lazy\"));\n         assertEquals(\"TKS\", this.getMetaphone().metaphone(\"dogs\"));\n     }\n-\t\n-\tpublic void testWordEndingInMB() {\n-\t\tassertEquals( \"KM\", this.getMetaphone().metaphone(\"COMB\") );\n-\t\tassertEquals( \"TM\", this.getMetaphone().metaphone(\"TOMB\") );\n-\t\tassertEquals( \"WM\", this.getMetaphone().metaphone(\"WOMB\") );\n-\t}\n-\n-\tpublic void testDiscardOfSCEOrSCIOrSCY() {\n-\t\tassertEquals( \"SNS\", this.getMetaphone().metaphone(\"SCIENCE\") );\n-\t\tassertEquals( \"SN\", this.getMetaphone().metaphone(\"SCENE\") );\n-\t\tassertEquals( \"S\", this.getMetaphone().metaphone(\"SCY\") );\n-\t}\n+    \n+    public void testWordEndingInMB() {\n+        assertEquals( \"KM\", this.getMetaphone().metaphone(\"COMB\") );\n+        assertEquals( \"TM\", this.getMetaphone().metaphone(\"TOMB\") );\n+        assertEquals( \"WM\", this.getMetaphone().metaphone(\"WOMB\") );\n+    }\n+\n+    public void testDiscardOfSCEOrSCIOrSCY() {\n+        assertEquals( \"SNS\", this.getMetaphone().metaphone(\"SCIENCE\") );\n+        assertEquals( \"SN\", this.getMetaphone().metaphone(\"SCENE\") );\n+        assertEquals( \"S\", this.getMetaphone().metaphone(\"SCY\") );\n+    }\n \n     /**\n      * Tests (CODEC-57) Metaphone.metaphone(String) returns an empty string when passed the word \"why\"\n         assertEquals( \"XP\", this.getMetaphone().metaphone(\"CIAPO\") );\n     }\n \n-\tpublic void testTranslateOfSCHAndCH() {\n-\t\tassertEquals( \"SKTL\", this.getMetaphone().metaphone(\"SCHEDULE\") );\n-\t\tassertEquals( \"SKMT\", this.getMetaphone().metaphone(\"SCHEMATIC\") );\n-\n-\t\tassertEquals( \"KRKT\", this.getMetaphone().metaphone(\"CHARACTER\") );\n-\t\tassertEquals( \"TX\", this.getMetaphone().metaphone(\"TEACH\") );\n-\t}\n-\n-\tpublic void testTranslateToJOfDGEOrDGIOrDGY() {\n-\t\tassertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGY\") );\n-\t\tassertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGE\") );\n-\t\tassertEquals( \"AJMT\", this.getMetaphone().metaphone(\"ADGIEMTI\") );\n-\t}\n-\n-\tpublic void testDiscardOfSilentHAfterG() {\n-\t\tassertEquals( \"KNT\", this.getMetaphone().metaphone(\"GHENT\") );\n-\t\tassertEquals( \"B\", this.getMetaphone().metaphone(\"BAUGH\") );\n-\t}\n-\n-\tpublic void testDiscardOfSilentGN() {\n-\t\tassertEquals( \"N\", this.getMetaphone().metaphone(\"GNU\") );\n-\t\tassertEquals( \"SNT\", this.getMetaphone().metaphone(\"SIGNED\") );\n-\t}\n-\n-\tpublic void testPHTOF() {\n-\t\tassertEquals( \"FX\", this.getMetaphone().metaphone(\"PHISH\") );\n-\t}\n-\n-\tpublic void testSHAndSIOAndSIAToX() {\n-\t\tassertEquals( \"XT\", this.getMetaphone().metaphone(\"SHOT\") );\n-\t\tassertEquals( \"OTXN\", this.getMetaphone().metaphone(\"ODSIAN\") );\n-\t\tassertEquals( \"PLXN\", this.getMetaphone().metaphone(\"PULSION\") );\n-\t}\n-\n-\tpublic void testTIOAndTIAToX() {\n-\t\tassertEquals( \"OX\", this.getMetaphone().metaphone(\"OTIA\") );\n-\t\tassertEquals( \"PRXN\", this.getMetaphone().metaphone(\"PORTION\") );\n-\t}\n-\n-\tpublic void testTCH() {\n-\t\tassertEquals( \"RX\", this.getMetaphone().metaphone(\"RETCH\") );\n-\t\tassertEquals( \"WX\", this.getMetaphone().metaphone(\"WATCH\") );\n-\t}\n-\n-\tpublic void testExceedLength() {\n-\t\t// should be AKSKS, but istruncated by Max Code Length\n-\t\tassertEquals( \"AKSK\", this.getMetaphone().metaphone(\"AXEAXE\") );\n-\t}\n-\n-\tpublic void testSetMaxLengthWithTruncation() {\n-\t\t// should be AKSKS, but istruncated by Max Code Length\n-\t\tthis.getMetaphone().setMaxCodeLen( 6 );\n-\t\tassertEquals( \"AKSKSK\", this.getMetaphone().metaphone(\"AXEAXEAXE\") );\n-\t}\n+    public void testTranslateOfSCHAndCH() {\n+        assertEquals( \"SKTL\", this.getMetaphone().metaphone(\"SCHEDULE\") );\n+        assertEquals( \"SKMT\", this.getMetaphone().metaphone(\"SCHEMATIC\") );\n+\n+        assertEquals( \"KRKT\", this.getMetaphone().metaphone(\"CHARACTER\") );\n+        assertEquals( \"TX\", this.getMetaphone().metaphone(\"TEACH\") );\n+    }\n+\n+    public void testTranslateToJOfDGEOrDGIOrDGY() {\n+        assertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGY\") );\n+        assertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGE\") );\n+        assertEquals( \"AJMT\", this.getMetaphone().metaphone(\"ADGIEMTI\") );\n+    }\n+\n+    public void testDiscardOfSilentHAfterG() {\n+        assertEquals( \"KNT\", this.getMetaphone().metaphone(\"GHENT\") );\n+        assertEquals( \"B\", this.getMetaphone().metaphone(\"BAUGH\") );\n+    }\n+\n+    public void testDiscardOfSilentGN() {\n+        assertEquals( \"N\", this.getMetaphone().metaphone(\"GNU\") );\n+        assertEquals( \"SNT\", this.getMetaphone().metaphone(\"SIGNED\") );\n+    }\n+\n+    public void testPHTOF() {\n+        assertEquals( \"FX\", this.getMetaphone().metaphone(\"PHISH\") );\n+    }\n+\n+    public void testSHAndSIOAndSIAToX() {\n+        assertEquals( \"XT\", this.getMetaphone().metaphone(\"SHOT\") );\n+        assertEquals( \"OTXN\", this.getMetaphone().metaphone(\"ODSIAN\") );\n+        assertEquals( \"PLXN\", this.getMetaphone().metaphone(\"PULSION\") );\n+    }\n+\n+    public void testTIOAndTIAToX() {\n+        assertEquals( \"OX\", this.getMetaphone().metaphone(\"OTIA\") );\n+        assertEquals( \"PRXN\", this.getMetaphone().metaphone(\"PORTION\") );\n+    }\n+\n+    public void testTCH() {\n+        assertEquals( \"RX\", this.getMetaphone().metaphone(\"RETCH\") );\n+        assertEquals( \"WX\", this.getMetaphone().metaphone(\"WATCH\") );\n+    }\n+\n+    public void testExceedLength() {\n+        // should be AKSKS, but istruncated by Max Code Length\n+        assertEquals( \"AKSK\", this.getMetaphone().metaphone(\"AXEAXE\") );\n+    }\n+\n+    public void testSetMaxLengthWithTruncation() {\n+        // should be AKSKS, but istruncated by Max Code Length\n+        this.getMetaphone().setMaxCodeLen( 6 );\n+        assertEquals( \"AKSKSK\", this.getMetaphone().metaphone(\"AXEAXEAXE\") );\n+    }\n \n     public void validateFixture(String[][] pairs) {\n         if (pairs.length == 0) {\n--- a/src/test/org/apache/commons/codec/language/RefinedSoundexTest.java\n+++ b/src/test/org/apache/commons/codec/language/RefinedSoundexTest.java\n     }\n \n     /**\n-\t * @return Returns the encoder.\n-\t */\n+     * @return Returns the encoder.\n+     */\n     private RefinedSoundex getEncoder() {\n         return this.encoder;\n     }\n     }\n \n     /**\n-\t * @param encoder\n-\t *                  The encoder to set.\n-\t */\n+     * @param encoder\n+     *                  The encoder to set.\n+     */\n     private void setEncoder(RefinedSoundex encoder) {\n         this.encoder = encoder;\n     }\n         assertEquals(1, this.getEncoder().difference(\"Margaret\", \"Andrew\"));\n         assertEquals(1, this.getEncoder().difference(\"Janet\", \"Margaret\"));\n         // Examples from\n-\t\t// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\n+        // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\n         assertEquals(5, this.getEncoder().difference(\"Green\", \"Greene\"));\n         assertEquals(1, this.getEncoder().difference(\"Blotchet-Halls\", \"Greene\"));\n         // Examples from\n-\t\t// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n+        // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n         assertEquals(6, this.getEncoder().difference(\"Smith\", \"Smythe\"));\n         assertEquals(8, this.getEncoder().difference(\"Smithers\", \"Smythers\"));\n         assertEquals(5, this.getEncoder().difference(\"Anothers\", \"Brothers\"));\n         assertEquals(\"D6043\", RefinedSoundex.US_ENGLISH.encode(\"dogs\"));\n     }\n \n-\tpublic void testGetMappingCodeNonLetter() {\n-\t\tchar code = this.getEncoder().getMappingCode('#');\n-\t\tassertEquals(\"Code does not equals zero\", 0, code);\n-\t}\n+    public void testGetMappingCodeNonLetter() {\n+        char code = this.getEncoder().getMappingCode('#');\n+        assertEquals(\"Code does not equals zero\", 0, code);\n+    }\n }\n--- a/src/test/org/apache/commons/codec/language/SoundexTest.java\n+++ b/src/test/org/apache/commons/codec/language/SoundexTest.java\n     }\n \n     /**\n-\t * @return Returns the _encoder.\n-\t */\n+     * @return Returns the _encoder.\n+     */\n     public Soundex getEncoder() {\n         return this.encoder;\n     }\n     }\n \n     /**\n-\t * @param encoder\n-\t *                  The encoder to set.\n-\t */\n+     * @param encoder\n+     *                  The encoder to set.\n+     */\n     public void setEncoder(Soundex encoder) {\n         this.encoder = encoder;\n     }\n     }\n \n     /**\n-\t * Examples from\n-\t * http://www.bradandkathy.com/genealogy/overviewofsoundex.html\n-\t */\n+     * Examples from\n+     * http://www.bradandkathy.com/genealogy/overviewofsoundex.html\n+     */\n     public void testEncodeBatch2() {\n         assertEquals(\"A462\", this.getEncoder().encode(\"Allricht\"));\n         assertEquals(\"E166\", this.getEncoder().encode(\"Eberhard\"));\n     }\n \n     /**\n-\t * Examples from\n-\t * http://www.archives.gov/research_room/genealogy/census/soundex.html\n-\t */\n+     * Examples from\n+     * http://www.archives.gov/research_room/genealogy/census/soundex.html\n+     */\n     public void testEncodeBatch3() {\n         assertEquals(\"W252\", this.getEncoder().encode(\"Washington\"));\n         assertEquals(\"L000\", this.getEncoder().encode(\"Lee\"));\n     }\n \n     /**\n-\t * Examples from: http://www.myatt.demon.co.uk/sxalg.htm\n-\t */\n+     * Examples from: http://www.myatt.demon.co.uk/sxalg.htm\n+     */\n     public void testEncodeBatch4() {\n         assertEquals(\"H452\", this.getEncoder().encode(\"HOLMES\"));\n         assertEquals(\"A355\", this.getEncoder().encode(\"ADOMOMI\"));\n \n     }\n \n-\tpublic void testBadCharacters() {\n-\t\tassertEquals(\"H452\", this.getEncoder().encode(\"HOL>MES\"));\n-\n-\t}\n+    public void testBadCharacters() {\n+        assertEquals(\"H452\", this.getEncoder().encode(\"HOL>MES\"));\n+\n+    }\n \n     public void testEncodeIgnoreApostrophes() {\n         this.encodeAll(new String[] { \"OBrien\", \"'OBrien\", \"O'Brien\", \"OB'rien\", \"OBr'ien\", \"OBri'en\", \"OBrie'n\", \"OBrien'\" }, \"O165\");\n     }\n \n     /**\n-\t * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n-\t */\n+     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n+     */\n     public void testEncodeIgnoreHyphens() {\n         this.encodeAll(\n             new String[] {\n     }\n \n     /**\n-\t * Consonants from the same code group separated by W or H are treated as\n-\t * one.\n-\t */\n+     * Consonants from the same code group separated by W or H are treated as\n+     * one.\n+     */\n     public void testHWRuleEx1() {\n         // From\n         // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n     }\n \n     /**\n-\t * Consonants from the same code group separated by W or H are treated as\n-\t * one.\n-\t *\n-\t * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n-\t */\n+     * Consonants from the same code group separated by W or H are treated as\n+     * one.\n+     *\n+     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n+     */\n     public void testHWRuleEx2() {\n         assertEquals(\"B312\", this.getEncoder().encode(\"BOOTHDAVIS\"));\n         assertEquals(\"B312\", this.getEncoder().encode(\"BOOTH-DAVIS\"));\n     }\n \n     /**\n-\t * Consonants from the same code group separated by W or H are treated as\n-\t * one.\n-\t */\n+     * Consonants from the same code group separated by W or H are treated as\n+     * one.\n+     */\n     public void testHWRuleEx3() {\n         assertEquals(\"S460\", this.getEncoder().encode(\"Sgler\"));\n         assertEquals(\"S460\", this.getEncoder().encode(\"Swhgler\"));", "timestamp": 1211399871, "metainfo": ""}