{"sha": "e2df85024e2ab99645a788b4b2836ba1cfdb87f5", "log": "PR: CODED-69 Submitted-By: Julius Davies <juliusdavies@gmail.com> Added the Base64InputStream and the Base64OutputStream.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n+import java.io.UnsupportedEncodingException;\n import java.math.BigInteger;\n \n /**\n  * @version $Id$\n  */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n-\n     /**\n      * Chunk size per RFC 2045 section 6.8.\n      * \n     static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n \n     /**\n-     * The base length.\n-     */\n-    private static final int BASELENGTH = 255;\n-\n-    /**\n-     * Lookup length.\n-     */\n-    private static final int LOOKUPLENGTH = 64;\n-\n-    /**\n-     * Used to calculate the number of bits in a byte.\n-     */\n-    private static final int EIGHTBIT = 8;\n-\n-    /**\n-     * Used when encoding something which has fewer than 24 bits.\n-     */\n-    private static final int SIXTEENBIT = 16;\n-\n-    /**\n-     * Used to determine how many bits data contains.\n-     */\n-    private static final int TWENTYFOURBITGROUP = 24;\n-\n-    /**\n-     * Used to get the number of Quadruples.\n-     */\n-    private static final int FOURBYTE = 4;\n-\n-    /**\n-     * Used to test the sign of a byte.\n-     */\n-    private static final int SIGN = -128;\n-\n-    /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = (byte) '=';\n \n-    /**\n-     * Contains the Base64 values <code>0</code> through <code>63</code> accessed by using character encodings as\n-     * indices.\n+\n+    // The static final fields above are used for the original static byte[] methods on Base64.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n+\n+    /**\n+     * Line length for encoding.  Not used when decoding.  Any value of zero or less implies\n+     * so chunking of the base64 encoded data.\n+     */\n+    private final int lineLength;\n+\n+    /**\n+     * Line separator for encoding.  Not used when decoding.  Only used if lineLength >= 1.\n+     */\n+    private final byte[] lineSeparator;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n+     */\n+    private final int decodeSize;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of\n+     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n+     */\n+    private final int encodeSize;\n+\n+    /**\n+     * Buffer for streaming. \n+     */\n+    private byte[] buf;\n+\n+    /**\n+     * Position where next character should be written in the buffer.\n+     */\n+    private int pos;\n+\n+    /**\n+     * Position where next character should be read from the buffer.\n+     */\n+    private int readPos;\n+\n+    /**\n+     * Variable tracks how many characters have been written to the current line.\n+     * Only used when encoding.  We use it to make sure each encoded line never\n+     * goes beyond lineLength (if lineLength >= 0).\n+     */\n+    private int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 3 reads when encoding, an\n+     * every 4 reads when decoding.  This variable helps track that.\n+     */\n+    private int modulus;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n+     * reached, this Base64 object becomes useless, and must be thrown away.\n+     */\n+    private boolean eof;\n+\n+    /**\n+     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n+     * Bitwise operations store and extract the base64 encoding or decoding from\n+     * this variable.\n+     */\n+    private int x;\n+\n+    /**\n+     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF\n+     * when encoding, and all forms can be decoded.\n+     */\n+    Base64() {\n+        this(CHUNK_SIZE, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n      * <p>\n-     * For example, <code>base64Alphabet['+']</code> returns <code>62</code>.\n+     * Consumer can use this constructor to choose a different lineLength\n+     * when encoding (lineSeparator is still CRLF).  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n      * </p>\n+     *\n+     * @param lineLength each line of encoded data will be at most this long\n+     * (rounded up to nearest multiple of 4).  Ignored when decoding.\n+     */\n+    Base64(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n      * <p>\n-     * The value of undefined encodings is <code>-1</code>.\n+     * Consumer can use this constructor to choose a different lineLength\n+     * and lineSeparator when encoding.  All forms of data can\n+     * be decoded.\n+     * </p><p>\n+     * Note:  lineLengths that aren't multiples of 4 will still essentially\n+     * end up being multiples of 4 in the encoded data.\n      * </p>\n-     */\n-    private static final byte[] base64Alphabet = new byte[BASELENGTH];\n+     * @param lineLength    Each line of encoded data will be at most this long\n+     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n+     * @param lineSeparator Each line of encoded data will end with this\n+     *                      sequence of bytes.\n+     * @throws IllegalArgumentException The provided lineSeparator included\n+     *                                  some base64 characters.  That's not going to work!\n+     */\n+    Base64(int lineLength, byte[] lineSeparator) {\n+        this.lineLength = lineLength;\n+        this.lineSeparator = lineSeparator;\n+        if (lineLength > 0) {\n+            this.encodeSize = (byte) (4 + lineSeparator.length);\n+        } else {\n+            this.encodeSize = 4;\n+        }\n+        this.decodeSize = encodeSize - 1;\n+        byte[] separator = discardWhitespace(lineSeparator);\n+        if (separator.length > 0 && isArrayByteBase64(separator)) {\n+            String sep;\n+            try {\n+                sep = new String(lineSeparator, \"UTF-8\");\n+            } catch (UnsupportedEncodingException uee) {\n+                sep = new String(lineSeparator);\n+            }\n+            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n+        }\n+    }\n+\n+    /**\n+     * This array is a lookup table that translates 6-bit positive integer\n+     * index values into their \"Base64 Alphabet\" equivalents as specified\n+     * in Table 1 of RFC 2045.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code. \n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] intToBase64 = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates unicode characters\n+     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n+     * into their 6-bit positive integer equivalents.  Characters that\n+     * are not in the Base64 alphabet but fall within the bounds of the\n+     * array are translated to -1.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n+     */\n+    private static final byte[] base64ToInt = {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n+            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n+    };\n+\n+    /**\n+     * Returns true if this Base64 object has buffered data for reading.\n+     *\n+     * @return true if there is Base64 object still available for reading.\n+     */\n+    boolean hasData() { return buf != null; }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     *\n+     * @return The amount of buffered data available for reading.\n+     */\n+    int avail() { return buf != null ? pos - readPos : 0; }\n+\n+    /** Doubles our buffer. */\n+    private void resizeBuf() {\n+        if (buf == null) {\n+            buf = new byte[8192];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buf.length * 2];\n+            System.arraycopy(buf, 0, b, 0, buf.length);\n+            buf = b;\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting\n+     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n+     * many bytes were actually extracted.\n+     *\n+     * @param b      byte[] array to extract the buffered data into.\n+     * @param bPos   position in byte[] array to start extraction at.\n+     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n+     *               fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided\n+     *         byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {\n+        if (buf != null) {\n+            int len = Math.min(avail(), bAvail);\n+            if (buf != b) {\n+                System.arraycopy(buf, readPos, b, bPos, len);\n+                readPos += len;\n+                if (readPos >= pos) {\n+                    buf = null;\n+                }\n+            } else {\n+                // Re-using the original consumer's output array is only\n+                // allowed for one round.\n+                buf = null;\n+            }\n+            return len;\n+        } else {\n+            return eof ? -1 : 0;\n+        }\n+    }\n+\n+    /**\n+     * Small optimization where we try to buffer directly to the consumer's\n+     * output array for one round (if consumer calls this method first!) instead\n+     * of starting our own buffer.\n+     *\n+     * @param out byte[] array to buffer directly to.\n+     * @param outPos Position to start buffering into.\n+     * @param outAvail Amount of bytes available for direct buffering.\n+     */\n+    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n+        // We can re-use consumer's original output array under\n+        // special circumstances, saving on some System.arraycopy().\n+        if (out != null && out.length == outAvail) {\n+            buf = out;\n+            pos = outPos;\n+            readPos = outPos;\n+        }\n+    }\n \n     /**\n      * <p>\n-     * Contains the Base64 encodings <code>A</code> through <code>Z</code>, followed by <code>a</code> through\n-     * <code>z</code>, followed by <code>0</code> through <code>9</code>, followed by <code>+</code>, and\n-     * <code>/</code>.\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Must be called at least twice:  once with the data to encode, and once\n+     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n+     * so flush last remaining bytes (if not multiple of 3).\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      * </p>\n+     *\n+     * @param in byte[] array of binary data to base64 encode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */\n+    void encode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (buf == null || buf.length - pos < encodeSize) {\n+                resizeBuf();\n+            }\n+            switch (modulus) {\n+                case 1:\n+                    buf[pos++] = intToBase64[(x >> 2) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 4) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    buf[pos++] = PAD;\n+                    break;\n+\n+                case 2:\n+                    buf[pos++] = intToBase64[(x >> 10) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 4) & 0x3f];\n+                    buf[pos++] = intToBase64[(x << 2) & 0x3f];\n+                    buf[pos++] = PAD;\n+                    break;\n+            }\n+            if (lineLength > 0) {\n+                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }\n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                if (buf == null || buf.length - pos < encodeSize) {\n+                    resizeBuf();\n+                }\n+                modulus = (++modulus) % 3;\n+                int b = in[inPos++];\n+                if (b < 0) { b += 256; }\n+                x = (x << 8) + b;\n+                if (0 == modulus) {\n+                    buf[pos++] = intToBase64[(x >> 18) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 12) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 6) & 0x3f];\n+                    buf[pos++] = intToBase64[x & 0x3f];\n+                    currentLinePos += 4;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n      * <p>\n-     * This array is accessed by using character values as indices.\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n+     * Should be called at least twice:  once with the data to decode, and once\n+     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n+     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p><p>\n+     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n+     * data is handled, since CR and LF are silently ignored, but has implications\n+     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n+     * philosophy:  it will not check the provided data for validity.\n+     * </p><p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n+     * and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      * </p>\n-     * <p>\n-     * For example, <code>lookUpBase64Alphabet[62] </code> returns <code>'+'</code>.\n-     * </p>\n-     */\n-    private static final byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n-\n-    // Populating the lookup and character arrays\n-    static {\n-        for (int i = 0; i < BASELENGTH; i++) {\n-            base64Alphabet[i] = (byte) -1;\n-        }\n-        for (int i = 'Z'; i >= 'A'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'A');\n-        }\n-        for (int i = 'z'; i >= 'a'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'a' + 26);\n-        }\n-        for (int i = '9'; i >= '0'; i--) {\n-            base64Alphabet[i] = (byte) (i - '0' + 52);\n-        }\n-\n-        base64Alphabet['+'] = 62;\n-        base64Alphabet['/'] = 63;\n-\n-        for (int i = 0; i <= 25; i++) {\n-            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n-        }\n-\n-        for (int i = 26, j = 0; i <= 51; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n-        }\n-\n-        for (int i = 52, j = 0; i <= 61; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n-        }\n-\n-        lookUpBase64Alphabet[62] = (byte) '+';\n-        lookUpBase64Alphabet[63] = (byte) '/';\n+\n+     * @param in byte[] array of ascii data to base64 decode.\n+     * @param inPos Position to start reading data from.\n+     * @param inAvail Amount of bytes available from input for encoding.\n+     */    \n+    void decode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            if (buf == null || buf.length - pos < decodeSize) {\n+                resizeBuf();\n+            }\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                modulus = (++modulus) % 4;\n+                x = x << 6;\n+                switch (modulus) {\n+                    case 3:\n+                        x = x << 6;\n+                    case 0:\n+                        buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                        }\n+                    default:\n+                        // WE'RE DONE!!!!\n+                        eof = true;\n+                        return;\n+                }\n+            } else {\n+                if (b >= 0 && b < base64ToInt.length) {\n+                    int result = base64ToInt[b];\n+                    if (result >= 0) {\n+                        modulus = (byte) ((++modulus) % 4);\n+                        x = (x << 6) + result;\n+                        if (modulus == 0) {\n+                            buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                            buf[pos++] = (byte) (x & 0xff);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     /**\n      * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n      */\n     private static boolean isBase64(byte octect) {\n-        if (octect == PAD) {\n-            return true;\n-        } else if (octect < 0 || base64Alphabet[octect] == -1) {\n-            return false;\n-        } else {\n-            return true;\n-        }\n+        return octect == PAD || (octect >= 0 && octect < base64ToInt.length && base64ToInt[octect] != -1);\n     }\n \n     /**\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n-        long binaryDataLength = binaryData.length;\n-        long lengthDataBits = binaryDataLength * EIGHTBIT;\n-        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n-        long encodedDataLengthLong = 0;\n-        int chunckCount = 0;\n-\n-        if (fewerThan24bits != 0) {\n-            // data not divisible by 24 bit\n-            encodedDataLengthLong = (tripletCount + 1) * 4;\n-        } else {\n-            // 16 or 8 bit\n-            encodedDataLengthLong = tripletCount * 4;\n-        }\n-\n-        // If the output is to be \"chunked\" into 76 character sections,\n-        // for compliance with RFC 2045 MIME, then it is important to\n-        // allow for extra length to account for the separator(s)\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n+        }\n+        Base64 b64 = isChunked ? new Base64() : new Base64(0);\n+\n+        long len = (binaryData.length * 4) / 3;\n+        long mod = len % 4;\n+        if (mod != 0) {\n+            len += 4 - mod;\n+        }\n         if (isChunked) {\n-\n-            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n-                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n-            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n-        }\n-\n-        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n+            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n+        }\n+\n+        if (len > Integer.MAX_VALUE) {\n             throw new IllegalArgumentException(\n                     \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n         }\n-        int encodedDataLength = (int) encodedDataLengthLong;\n-        byte encodedData[] = new byte[encodedDataLength];\n-\n-        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        int i = 0;\n-        int nextSeparatorIndex = CHUNK_SIZE;\n-        int chunksSoFar = 0;\n-\n-        // log.debug(\"number of triplets = \" + numberTriplets);\n-        for (i = 0; i < tripletCount; i++) {\n-            dataIndex = i * 3;\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            b3 = binaryData[dataIndex + 2];\n-\n-            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n-\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            // log.debug( \"val2 = \" + val2 );\n-            // log.debug( \"k4 = \" + (k<<4) );\n-            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n-            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n-\n-            encodedIndex += 4;\n-\n-            // If we are chunking, let's put a chunk separator down.\n-            if (isChunked) {\n-                // this assumes that CHUNK_SIZE % 4 == 0\n-                if (encodedIndex == nextSeparatorIndex) {\n-                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n-                    chunksSoFar++;\n-                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n-                    encodedIndex += CHUNK_SEPARATOR.length;\n-                }\n-            }\n-        }\n-\n-        // form integral number of 6-bit groups\n-        dataIndex = i * 3;\n-\n-        if (fewerThan24bits == EIGHTBIT) {\n-            b1 = binaryData[dataIndex];\n-            k = (byte) (b1 & 0x03);\n-            // log.debug(\"b1=\" + b1);\n-            // log.debug(\"b1<<2 = \" + (b1>>2) );\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n-            encodedData[encodedIndex + 2] = PAD;\n-            encodedData[encodedIndex + 3] = PAD;\n-        } else if (fewerThan24bits == SIXTEENBIT) {\n-\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n-            encodedData[encodedIndex + 3] = PAD;\n-        }\n-\n-        if (isChunked) {\n-            // we also add a separator to the end of the final chunk.\n-            if (chunksSoFar < chunckCount) {\n-                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n-                        CHUNK_SEPARATOR.length);\n-            }\n-        }\n-\n-        return encodedData;\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.encode(binaryData, 0, binaryData.length);\n+        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n+\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (b64.buf != buf) {\n+            b64.readResults(buf, 0, buf.length);\n+        }\n+        return buf;\n     }\n \n     /**\n      * Decodes Base64 data into octects\n-     * \n-     * @param base64Data\n-     *            Byte array containing Base64 data\n+     *\n+     * @param base64Data Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        // RFC 2045 requires that we discard ALL non-Base64 characters\n-        base64Data = discardNonBase64(base64Data);\n-\n-        // handle the edge case, so we don't have to worry about it later\n-        if (base64Data.length == 0) {\n-            return new byte[0];\n-        }\n-\n-        int numberQuadruple = base64Data.length / FOURBYTE;\n-        byte decodedData[] = null;\n-        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n-\n-        // Throw away anything not in base64Data\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        {\n-            // this sizes the output array properly - rlw\n-            int lastData = base64Data.length;\n-            // ignore the '=' padding\n-            while (base64Data[lastData - 1] == PAD) {\n-                if (--lastData == 0) {\n-                    return new byte[0];\n-                }\n-            }\n-            decodedData = new byte[lastData - numberQuadruple];\n-        }\n-\n-        for (int i = 0; i < numberQuadruple; i++) {\n-            dataIndex = i * 4;\n-            marker0 = base64Data[dataIndex + 2];\n-            marker1 = base64Data[dataIndex + 3];\n-\n-            b1 = base64Alphabet[base64Data[dataIndex]];\n-            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n-            if (marker0 != PAD && marker1 != PAD) {\n-                // No PAD e.g 3cQl\n-                b3 = base64Alphabet[marker0];\n-                b4 = base64Alphabet[marker1];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } else if (marker0 == PAD) {\n-                // Two PAD e.g. 3c[Pad][Pad]\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } else if (marker1 == PAD) {\n-                // One PAD e.g. 3cQ[Pad]\n-                b3 = base64Alphabet[marker0];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-            }\n-            encodedIndex += 3;\n-        }\n-        return decodedData;\n+        if (base64Data == null || base64Data.length == 0) {\n+            return base64Data;\n+        }\n+        Base64 b64 = new Base64();\n+\n+        long len = (base64Data.length * 3) / 4;\n+        byte[] buf = new byte[(int) len];\n+        b64.setInitialBuffer(buf, 0, buf.length);\n+        b64.decode(base64Data, 0, base64Data.length);\n+        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n+\n+        // We have no idea what the line-length was, so we\n+        // cannot know how much of our array wasn't used.\n+        byte[] result = new byte[b64.pos];\n+        b64.readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n+ * When encoding the default lineLength is 76 characters and the default\n+ * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64InputStream is to DECODE, whereas the\n+ * default behaviour of the Base64OutputStream is to ENCODE, but this\n+ * behaviour can be overridden by using a different constructor.\n+ * </p><p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.0-dev\n+ */\n+public class Base64InputStream extends FilterInputStream {\n+\n+    private final boolean doEncode;\n+    private final Base64 base64;\n+    private final byte[] singleByte = new byte[1];\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is Base64-decoded\n+     * from the original provided InputStream.\n+     *\n+     * @param in InputStream to wrap.\n+     */\n+    public Base64InputStream(InputStream in) {\n+        this(in, false);\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either\n+     * Base64-encoded or Base64-decoded from the original provided InputStream.\n+     *\n+     * @param in       InputStream to wrap.\n+     * @param doEncode true if we should encode all data read from us,\n+     *                 false if we should decode.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64();\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either\n+     * Base64-encoded or Base64-decoded from the original provided InputStream.\n+     *\n+     * @param in            InputStream to wrap.\n+     * @param doEncode      true if we should encode all data read from us,\n+     *                      false if we should decode.\n+     * @param lineLength    If doEncode is true, each line of encoded\n+     *                      data will contain lineLength characters.  If\n+     *                      doEncode is false, lineLength is ignored.\n+     * @param lineSeparator If doEncode is true, each line of encoded\n+     *                      data will be terminated with this byte sequence\n+     *                      (e.g. \\r\\n).  If doEncode is false lineSeparator\n+     *                      is ignored.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64(lineLength, lineSeparator);\n+    }\n+\n+    /**\n+     * Reads one <code>byte</code> from this input stream.\n+     * Returns -1 if EOF has been reached.\n+     */\n+    public int read() throws IOException {\n+        int r = read(singleByte, 0, 1);\n+        while (r == 0) {\n+            r = read(singleByte, 0, 1);\n+        }\n+        if (r > 0) {\n+            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Attempts to read <code>len</code> bytes into the specified\n+     * <code>b</code> array starting at <code>offset</code> from\n+     * this InputStream.\n+     *\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    public int read(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0 || offset + len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            if (!base64.hasData()) {\n+                byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                int c = in.read(buf);\n+\n+                // A little optimization to avoid System.arraycopy()\n+                // when possible.\n+                if (c > 0 && b.length == len) {\n+                    base64.setInitialBuffer(b, offset, len);\n+                }\n+\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n+                }\n+            }\n+            return base64.readResults(b, offset, len);\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n+ * When encoding the default lineLength is 76 characters and the default\n+ * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the\n+ * default behaviour of the Base64InputStream is to DECODE.  But this behaviour\n+ * can be overridden by using a different constructor.\n+ * </p><p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.0-dev\n+ */\n+public class Base64OutputStream extends FilterOutputStream {\n+    private final boolean doEncode;\n+    private final Base64 base64;\n+    private final byte[] singleByte = new byte[1];\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded\n+     * to the original provided OutputStream.\n+     *\n+     * @param out OutputStream to wrap.\n+     */\n+    public Base64OutputStream(OutputStream out) {\n+        this(out, true);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either\n+     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n+     *\n+     * @param out      OutputStream to wrap.\n+     * @param doEncode true if we should encode all data written to us,\n+     *                 false if we should decode.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode) {\n+        super(out);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64();\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either\n+     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n+     *\n+     * @param out           OutputStream to wrap.\n+     * @param doEncode      true if we should encode all data written to us,\n+     *                      false if we should decode.\n+     * @param lineLength    If doEncode is true, each line of encoded\n+     *                      data will contain lineLength characters.  If\n+     *                      doEncode is false, lineLength is ignored.\n+     * @param lineSeparator If doEncode is true, each line of encoded\n+     *                      data will be terminated with this byte sequence\n+     *                      (e.g. \\r\\n).  If doEncode is false lineSeparator\n+     *                      is ignored.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(out);\n+        this.doEncode = doEncode;\n+        this.base64 = new Base64(lineLength, lineSeparator);\n+    }\n+\n+    /**\n+     * Writes the specified <code>byte</code> to this output stream.\n+     */\n+    public void write(int i) throws IOException {\n+        singleByte[0] = (byte) i;\n+        write(singleByte, 0, 1);\n+    }\n+\n+    /**\n+     * Writes <code>len</code> bytes from the specified\n+     * <code>b</code> array starting at <code>offset</code> to\n+     * this output stream.\n+     *\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    public void write(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0 || offset + len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len > 0) {\n+            if (doEncode) {\n+                base64.encode(b, offset, len);\n+            } else {\n+                base64.decode(b, offset, len);\n+            }\n+            flush(false);\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.  If propogate is true, the wrapped\n+     * stream will also be flushed.\n+     *\n+     * @param propogate boolean flag to indicate whether the wrapped\n+     *                  OutputStream should also be flushed.\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    private void flush(boolean propogate) throws IOException {\n+        int avail = base64.avail();\n+        if (avail > 0) {\n+            byte[] buf = new byte[avail];\n+            int c = base64.readResults(buf, 0, avail);\n+            if (c > 0) {\n+                out.write(buf, 0, c);\n+            }\n+        }\n+        if (propogate) {\n+            out.flush();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.\n+     *\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    public void flush() throws IOException { flush(true); }\n+\n+    /**\n+     * Closes this output stream and releases any system resources\n+     * associated with the stream.\n+     */\n+    public void close() throws IOException {\n+        // Notify encoder of EOF (-1).\n+        if (doEncode) {\n+            base64.encode(singleByte, 0, -1);\n+        } else {\n+            base64.decode(singleByte, 0, -1);\n+        }\n+        flush();\n+        out.close();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+\n+import junit.framework.TestCase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ */\n+public class Base64InputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public Base64InputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Test the Base64InputStream implementation.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n+        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+    }\n+\n+    /**\n+     * Test the Base64InputStream implementation.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n+        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+    }\n+\n+\n+    /**\n+     * Test method does three tests on the supplied data:\n+     * 1. encoded ---[DECODE]--> decoded\n+     * 2. decoded ---[ENCODE]--> encoded\n+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n+     * Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     *\n+     * @param encoded   base64 encoded data\n+     * @param decoded   the data from above, but decoded\n+     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n+     * @param seperator Line separator in the base64 encoded data.\n+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(\n+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n+    ) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = new byte[encoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data:\n+     * 1. encoded ---[DECODE]--> decoded\n+     * 2. decoded ---[ENCODE]--> encoded\n+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n+     * Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     *\n+     * @param encoded   base64 encoded data\n+     * @param decoded   the data from above, but decoded\n+     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n+     * @param seperator Line separator in the base64 encoded data.\n+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(\n+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n+    ) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+\n+import junit.framework.TestCase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ */\n+public class Base64OutputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public Base64OutputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n+        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n+        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+    }\n+\n+\n+    /**\n+     * Test method does three tests on the supplied data:\n+     * 1. encoded ---[DECODE]--> decoded\n+     * 2. decoded ---[ENCODE]--> encoded\n+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n+     * Base64OutputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     *\n+     * @param encoded   base64 encoded data\n+     * @param decoded   the data from above, but decoded\n+     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n+     * @param seperator Line separator in the base64 encoded data.\n+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(\n+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n+    ) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data:\n+     * 1. encoded ---[DECODE]--> decoded\n+     * 2. decoded ---[ENCODE]--> encoded\n+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n+     * Base64OutputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     *\n+     * @param encoded   base64 encoded data\n+     * @param decoded   the data from above, but decoded\n+     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n+     * @param seperator Line separator in the base64 encoded data.\n+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(\n+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n+    ) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * This random data was encoded by OpenSSL.  Java had nothing to do with it.\n+ * This data helps us test interop between Commons-Codec and OpenSSL.  Notice\n+ * that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ */\n+public class Base64TestData {\n+\n+    // OpenSSL doesn't include the final \\n, but it would be annoying beyond belief\n+    // to further parameterize commons-codec to support this pointless variation.\n+    public final static String ENCODED\n+            = \"9IPNKwUvdLiIAp6ctz12SiQmOGstWyYvSPeevufDhrzaws65voykKjbIj33YWTa9\\n\"\n+            + \"xA7c/FHypWclrZhQ7onfc3JE93BJ5fT4R9zAEdjbjy1hv4ZYNnET4WJeXMLJ/5p+\\n\"\n+            + \"qBpTsPpepW8DNVYy1c02/1wyC+kgA6CvRUd9cSr/lt88AEdsTV4GMCn1+EwuAiYd\\n\"\n+            + \"ivxuzn+cLM8q2jewqlI52tP9J7Cs8vqG71s6+WAELKvm/UovvyaOi+OdMUfjQ0JL\\n\"\n+            + \"iLkHu6p9OwUgvQqiDKzEv/Augo0dTPZzYGEyCP5GVrle3QQdgciIHnpdd4VUTPGR\\n\"\n+            + \"UbXeKbh++U3fbJIng/sQXM3IYByMZ7xt9HWS1LUcRdQ7Prwn/IlQWxOMeq+KZJSo\\n\"\n+            + \"AviWtdserXyHbIEa//hmr4p/j80k0g9q35hq1ayGM9984ALTSaZ8WeyFbZx1CxC/\\n\"\n+            + \"Qoqf92UH/ylBRnSJNn4sS0oa3uUbNvOnpkB4D9V7Ut9atinCJrw+wiJcMl+9kp25\\n\"\n+            + \"1IUxBGA4cUxh0eaxk3ODWnwI95EktmWOKwCSP0xjWwIMxDjygwAG5R8fk9H9bVi1\\n\"\n+            + \"thMavm4nDc4vaNoSE1RnZNYwbiUVlVPM9EclvJWTWd6igWeA0MxHAA8iOM5Vnmqp\\n\"\n+            + \"/WGM7UDq59rBIdNQCoeTJaAkEtAuLL5zogOa5e+MzVjvB5MYQlOlaaTtQrRApXa5\\n\"\n+            + \"Z4VfEanu9UK2fi1T8jJPFC2PmXebxp0bnO+VW+bgyEdIIkIQCaZq1MKWC3KuiOS9\\n\"\n+            + \"BJ1t7O0A2JKJKvoE4UNulzV2TGCC+KAnmjRqQBqXlJmgjHQAoHNZKOma/uIQOsvf\\n\"\n+            + \"DnqicYdDmfyCYuV89HjA1H8tiDJ85VfsrFHdcbPAoNCpi65awJSHfdPO1NDONOK+\\n\"\n+            + \"+S7Y0VXUgoYYrBV4Y7YbC8wg/nqcimr3lm3tRyp+QsgKzdREbfNRk0F5PLyLfsUE\\n\"\n+            + \"lepjs1QdV3fEV1LJtiywA3ubVNQJRxhbYxa/C/Xy2qxpm6vvdL92l3q1ccev35Ic\\n\"\n+            + \"aOiSx7Im+/GxV2lVKdaOvYVGDD1zBRe6Y2CwQb9p088l3/93qGR5593NCiuPPWcs\\n\"\n+            + \"DWwUShM1EyW0FNX1F8bnzHnYijoyE/jf4s/l9bBd7yJdRWRCyih2WcypAiOIEkBs\\n\"\n+            + \"H+dCTgalu8sRDoMh4ZIBBdgHfoZUycLqReQFLZZ4Sl4zSmzt5vQxQFhEKb9+ff/4\\n\"\n+            + \"rb1KAo6wifengxVfIsa2b5ljXzAqXs7JkPvmC6fa7X4ZZndRokaxYlu3cg8OV+uG\\n\"\n+            + \"/6YAHZilo8at0OpkkNdNFuhwuGlkBqrZKNUj/gSiYYc06gF/r/z6iWAjpXJRW1qq\\n\"\n+            + \"3CLZXdZFZ/VrqXeVjtOAu2A=\\n\";\n+\n+    public final static byte[] DECODED\n+            = {-12, -125, -51, 43, 5, 47, 116, -72, -120, 2, -98, -100, -73, 61, 118, 74, 36, 38, 56, 107, 45, 91, 38,\n+            47, 72, -9, -98, -66, -25, -61, -122, -68, -38, -62, -50, -71, -66, -116, -92, 42, 54, -56, -113, 125,\n+            -40, 89, 54, -67, -60, 14, -36, -4, 81, -14, -91, 103, 37, -83, -104, 80, -18, -119, -33, 115, 114, 68,\n+            -9, 112, 73, -27, -12, -8, 71, -36, -64, 17, -40, -37, -113, 45, 97, -65, -122, 88, 54, 113, 19, -31, 98,\n+            94, 92, -62, -55, -1, -102, 126, -88, 26, 83, -80, -6, 94, -91, 111, 3, 53, 86, 50, -43, -51, 54, -1, 92,\n+            50, 11, -23, 32, 3, -96, -81, 69, 71, 125, 113, 42, -1, -106, -33, 60, 0, 71, 108, 77, 94, 6, 48, 41, -11,\n+            -8, 76, 46, 2, 38, 29, -118, -4, 110, -50, 127, -100, 44, -49, 42, -38, 55, -80, -86, 82, 57, -38, -45,\n+            -3, 39, -80, -84, -14, -6, -122, -17, 91, 58, -7, 96, 4, 44, -85, -26, -3, 74, 47, -65, 38, -114, -117,\n+            -29, -99, 49, 71, -29, 67, 66, 75, -120, -71, 7, -69, -86, 125, 59, 5, 32, -67, 10, -94, 12, -84, -60, -65,\n+            -16, 46, -126, -115, 29, 76, -10, 115, 96, 97, 50, 8, -2, 70, 86, -71, 94, -35, 4, 29, -127, -56, -120,\n+            30, 122, 93, 119, -123, 84, 76, -15, -111, 81, -75, -34, 41, -72, 126, -7, 77, -33, 108, -110, 39, -125,\n+            -5, 16, 92, -51, -56, 96, 28, -116, 103, -68, 109, -12, 117, -110, -44, -75, 28, 69, -44, 59, 62, -68,\n+            39, -4, -119, 80, 91, 19, -116, 122, -81, -118, 100, -108, -88, 2, -8, -106, -75, -37, 30, -83, 124, -121,\n+            108, -127, 26, -1, -8, 102, -81, -118, 127, -113, -51, 36, -46, 15, 106, -33, -104, 106, -43, -84, -122,\n+            51, -33, 124, -32, 2, -45, 73, -90, 124, 89, -20, -123, 109, -100, 117, 11, 16, -65, 66, -118, -97, -9,\n+            101, 7, -1, 41, 65, 70, 116, -119, 54, 126, 44, 75, 74, 26, -34, -27, 27, 54, -13, -89, -90, 64, 120, 15,\n+            -43, 123, 82, -33, 90, -74, 41, -62, 38, -68, 62, -62, 34, 92, 50, 95, -67, -110, -99, -71, -44, -123,\n+            49, 4, 96, 56, 113, 76, 97, -47, -26, -79, -109, 115, -125, 90, 124, 8, -9, -111, 36, -74, 101, -114, 43,\n+            0, -110, 63, 76, 99, 91, 2, 12, -60, 56, -14, -125, 0, 6, -27, 31, 31, -109, -47, -3, 109, 88, -75, -74,\n+            19, 26, -66, 110, 39, 13, -50, 47, 104, -38, 18, 19, 84, 103, 100, -42, 48, 110, 37, 21, -107, 83, -52,\n+            -12, 71, 37, -68, -107, -109, 89, -34, -94, -127, 103, -128, -48, -52, 71, 0, 15, 34, 56, -50, 85, -98,\n+            106, -87, -3, 97, -116, -19, 64, -22, -25, -38, -63, 33, -45, 80, 10, -121, -109, 37, -96, 36, 18, -48,\n+            46, 44, -66, 115, -94, 3, -102, -27, -17, -116, -51, 88, -17, 7, -109, 24, 66, 83, -91, 105, -92, -19,\n+            66, -76, 64, -91, 118, -71, 103, -123, 95, 17, -87, -18, -11, 66, -74, 126, 45, 83, -14, 50, 79, 20, 45,\n+            -113, -103, 119, -101, -58, -99, 27, -100, -17, -107, 91, -26, -32, -56, 71, 72, 34, 66, 16, 9, -90, 106,\n+            -44, -62, -106, 11, 114, -82, -120, -28, -67, 4, -99, 109, -20, -19, 0, -40, -110, -119, 42, -6, 4, -31,\n+            67, 110, -105, 53, 118, 76, 96, -126, -8, -96, 39, -102, 52, 106, 64, 26, -105, -108, -103, -96, -116,\n+            116, 0, -96, 115, 89, 40, -23, -102, -2, -30, 16, 58, -53, -33, 14, 122, -94, 113, -121, 67, -103, -4,\n+            -126, 98, -27, 124, -12, 120, -64, -44, 127, 45, -120, 50, 124, -27, 87, -20, -84, 81, -35, 113, -77,\n+            -64, -96, -48, -87, -117, -82, 90, -64, -108, -121, 125, -45, -50, -44, -48, -50, 52, -30, -66, -7, 46,\n+            -40, -47, 85, -44, -126, -122, 24, -84, 21, 120, 99, -74, 27, 11, -52, 32, -2, 122, -100, -118, 106, -9,\n+            -106, 109, -19, 71, 42, 126, 66, -56, 10, -51, -44, 68, 109, -13, 81, -109, 65, 121, 60, -68, -117, 126,\n+            -59, 4, -107, -22, 99, -77, 84, 29, 87, 119, -60, 87, 82, -55, -74, 44, -80, 3, 123, -101, 84, -44, 9, 71,\n+            24, 91, 99, 22, -65, 11, -11, -14, -38, -84, 105, -101, -85, -17, 116, -65, 118, -105, 122, -75, 113,\n+            -57, -81, -33, -110, 28, 104, -24, -110, -57, -78, 38, -5, -15, -79, 87, 105, 85, 41, -42, -114, -67,\n+            -123, 70, 12, 61, 115, 5, 23, -70, 99, 96, -80, 65, -65, 105, -45, -49, 37, -33, -1, 119, -88, 100, 121,\n+            -25, -35, -51, 10, 43, -113, 61, 103, 44, 13, 108, 20, 74, 19, 53, 19, 37, -76, 20, -43, -11, 23, -58, -25,\n+            -52, 121, -40, -118, 58, 50, 19, -8, -33, -30, -49, -27, -11, -80, 93, -17, 34, 93, 69, 100, 66, -54, 40,\n+            118, 89, -52, -87, 2, 35, -120, 18, 64, 108, 31, -25, 66, 78, 6, -91, -69, -53, 17, 14, -125, 33, -31, -110,\n+            1, 5, -40, 7, 126, -122, 84, -55, -62, -22, 69, -28, 5, 45, -106, 120, 74, 94, 51, 74, 108, -19, -26, -12,\n+            49, 64, 88, 68, 41, -65, 126, 125, -1, -8, -83, -67, 74, 2, -114, -80, -119, -9, -89, -125, 21, 95, 34,\n+            -58, -74, 111, -103, 99, 95, 48, 42, 94, -50, -55, -112, -5, -26, 11, -89, -38, -19, 126, 25, 102, 119,\n+            81, -94, 70, -79, 98, 91, -73, 114, 15, 14, 87, -21, -122, -1, -90, 0, 29, -104, -91, -93, -58, -83, -48,\n+            -22, 100, -112, -41, 77, 22, -24, 112, -72, 105, 100, 6, -86, -39, 40, -43, 35, -2, 4, -94, 97, -121, 52,\n+            -22, 1, 127, -81, -4, -6, -119, 96, 35, -91, 114, 81, 91, 90, -86, -36, 34, -39, 93, -42, 69, 103, -11,\n+            107, -87, 119, -107, -114, -45, -128, -69, 96};\n+\n+    // Some utility code to help test chunked reads of the InputStream.\n+\n+    private final static int SIZE_KEY = 0;\n+    private final static int LAST_READ_KEY = 1;\n+\n+    static byte[] streamToBytes(final InputStream in) throws IOException {\n+        // new byte[7] is obviously quite slow, but helps exercise the code.\n+        byte[] buf = new byte[7];\n+        try {\n+            int[] status = fill(buf, 0, in);\n+            int size = status[SIZE_KEY];\n+            int lastRead = status[LAST_READ_KEY];\n+            while (lastRead != -1) {\n+                buf = resizeArray(buf);\n+                status = fill(buf, size, in);\n+                size = status[SIZE_KEY];\n+                lastRead = status[LAST_READ_KEY];\n+            }\n+            if (buf.length != size) {\n+                byte[] smallerBuf = new byte[size];\n+                System.arraycopy(buf, 0, smallerBuf, 0, size);\n+                buf = smallerBuf;\n+            }\n+        }\n+        finally {\n+            in.close();\n+        }\n+        return buf;\n+    }\n+\n+    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n+            throws IOException {\n+        int read = in.read(buf, offset, buf.length - offset);\n+        int lastRead = read;\n+        if (read == -1) {\n+            read = 0;\n+        }\n+        while (lastRead != -1 && read + offset < buf.length) {\n+            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n+            if (lastRead != -1) {\n+                read += lastRead;\n+            }\n+        }\n+        return new int[]{offset + read, lastRead};\n+    }\n+\n+    private static byte[] resizeArray(final byte[] bytes) {\n+        byte[] biggerBytes = new byte[bytes.length * 2];\n+        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n+        return biggerBytes;\n+    }\n+\n+}", "timestamp": 1213816563, "metainfo": ""}