{"sha": "6a43ce7aa8fb6be26fd0559b189dce704a0a32f5", "log": "[CODEC-78] Base64 classes: Improve Code Coverage.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n     public int read(byte b[], int offset, int len) throws IOException {\n         if (b == null) {\n             throw new NullPointerException();\n-        } else if (offset < 0 || len < 0 || offset + len < 0) {\n+        } else if (offset < 0 || len < 0) {\n             throw new IndexOutOfBoundsException();\n         } else if (offset > b.length || offset + len > b.length) {\n             throw new IndexOutOfBoundsException();\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n     public void write(byte b[], int offset, int len) throws IOException {\n         if (b == null) {\n             throw new NullPointerException();\n-        } else if (offset < 0 || len < 0 || offset + len < 0) {\n+        } else if (offset < 0 || len < 0) {\n             throw new IndexOutOfBoundsException();\n         } else if (offset > b.length || offset + len > b.length) {\n             throw new IndexOutOfBoundsException();\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n         }\n \n         try {\n+            in.read(buf, 0, -1);\n+            fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n             in.read(buf, buf.length + 1, 0);\n             fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n         } catch (IndexOutOfBoundsException e) {\n             // Expected\n         }\n+\n+        try {\n+            in.read(buf, buf.length - 1, 2);\n+            fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }        \n     }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n \n     private final static byte[] LF = {(byte) '\\n'};\n \n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    private static final String UTF_8_NAME = \"UTF-8\";\n+\n     /**\n      * Construct a new instance of this test case.\n      * \n      */\n     public void testBase64OutputStreamByChunk() throws Exception {\n         // Hello World test.\n-        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n-        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(UTF_8_NAME);\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        encoded = \"AA==\\r\\n\".getBytes(UTF_8_NAME);\n         decoded = new byte[]{(byte) 0};\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = singleLine.getBytes(\"UTF-8\");\n+        encoded = singleLine.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 0, LF);\n \n      */\n     public void testBase64OutputStreamByteByByte() throws Exception {\n         // Hello World test.\n-        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n-        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(UTF_8_NAME);\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = singleLine.getBytes(\"UTF-8\");\n+        encoded = singleLine.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n \n         out.write(decoded);\n         out.close();\n         byte[] output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+        assertTrue(\"Streaming chunked base64 encode\", Arrays.equals(output, encoded));\n \n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         out.write(encoded);\n         out.close();\n         output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+        assertTrue(\"Streaming chunked base64 decode\", Arrays.equals(output, decoded));\n \n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         byteOut = new ByteArrayOutputStream();\n         out.close();\n         output = byteOut.toByteArray();\n \n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+        assertTrue(\"Streaming chunked base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n     }\n \n     /**\n         }\n         out.close();\n         byte[] output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+        assertTrue(\"Streaming byte-by-byte base64 encode\", Arrays.equals(output, encoded));\n \n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         }\n         out.close();\n         output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+        assertTrue(\"Streaming byte-by-byte base64 decode\", Arrays.equals(output, decoded));\n+\n+        // Now let's try decode with tonnes of flushes.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+            out.flush();\n+        }                      \n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte flush() base64 decode\", Arrays.equals(output, decoded));        \n \n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         byteOut = new ByteArrayOutputStream();\n         out.close();\n         output = byteOut.toByteArray();\n \n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+        assertTrue(\"Streaming byte-by-byte base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n     }\n \n     /**\n         Base64OutputStream out = new Base64OutputStream(bout);\n \n         try {\n-            out.write(buf, -1, 0);\n-            fail(\"Expected Base64OutputStream.write(buf, -1, 0) to throw a IndexOutOfBoundsException\");\n+            out.write(buf, -1, 1);\n+            fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, 1, -1);\n+            fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n         } catch (IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n         } catch (IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n+\n+        try {\n+            out.write(buf, buf.length - 1, 2);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }        \n     }\n \n     /**\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n             byte[] decoded = randomData[0];\n             byte[] result = Base64.decodeBase64(encoded);\n             assertTrue(\"url-safe i=\" + i, Arrays.equals(decoded, result));\n+            assertFalse(\"url-safe i=\" + i + \" no '='\", Base64TestData.bytesContain(encoded, (byte) '='));\n+            assertFalse(\"url-safe i=\" + i + \" no '\\\\'\", Base64TestData.bytesContain(encoded, (byte) '\\\\'));\n+            assertFalse(\"url-safe i=\" + i + \" no '+'\", Base64TestData.bytesContain(encoded, (byte) '+'));            \n         }\n \n     }\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n      * @param urlSafe true if encoding be urlSafe\n      * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n      */\n-    public static byte[][] randomData(int size, boolean urlSafe) {\n+    static byte[][] randomData(int size, boolean urlSafe) {\n         Random r = new Random();\n         byte[] decoded = new byte[size];\n         r.nextBytes(decoded);\n         return new byte[][] {decoded, encoded};\n     }\n \n+    /**\n+     * Tests the supplied byte[] array to see if it contains the specified byte c.\n+     *\n+     * @param bytes byte[] array to test\n+     * @param c byte to look for\n+     * @return true if bytes contains c, false otherwise\n+     */\n+    static boolean bytesContain(byte[] bytes, byte c) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (bytes[i] == c) { return true; }\n+        }\n+        return false;\n+    }\n+\n }", "timestamp": 1247865036, "metainfo": ""}