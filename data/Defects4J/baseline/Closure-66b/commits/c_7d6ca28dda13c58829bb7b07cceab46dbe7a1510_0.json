{"sha": "7d6ca28dda13c58829bb7b07cceab46dbe7a1510", "log": "Tweak the shared source mapping library, and update JSC to use it. This paves the way for sharing the source with other compilers as well and makes it easy to experiment with new source formats.  R=jschorr DELTA=1466  (215 added, 1059 deleted, 192 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=640   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.javascript.jscomp.sourcemap.Position;\n+import com.google.javascript.jscomp.sourcemap.FilePosition;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n      */\n     private static class Mapping {\n       Node node;\n-      Position start;\n-      Position end;\n+      FilePosition start;\n+      FilePosition end;\n     }\n \n     /**\n         Preconditions.checkState(line >= 0);\n         Mapping mapping = new Mapping();\n         mapping.node = node;\n-        mapping.start = new Position(line, index);\n+        mapping.start = new FilePosition(line, index);\n         mappings.push(mapping);\n         allMappings.add(mapping);\n       }\n         int line = getCurrentLineIndex();\n         int index = getCurrentCharIndex();\n         Preconditions.checkState(line >= 0);\n-        mapping.end = new Position(line, index);\n+        mapping.end = new FilePosition(line, index);\n       }\n     }\n \n      *\n      * @return The normalized position.\n      */\n-    private Position convertPosition(Position position, int lineIndex,\n+    private FilePosition convertPosition(FilePosition position, int lineIndex,\n                                      int characterPosition) {\n-      int originalLine = position.getLineNumber();\n-      int originalChar = position.getCharacterIndex();\n+      int originalLine = position.getLine();\n+      int originalChar = position.getColumn();\n       if (originalLine == lineIndex && originalChar >= characterPosition) {\n         // If the position falls on the line itself, then normalize it\n         // if it falls at or after the place the newline was inserted.\n-        return new Position(originalLine + 1, originalChar - characterPosition);\n+        return new FilePosition(\n+            originalLine + 1, originalChar - characterPosition);\n       } else {\n         return position;\n       }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n import com.google.javascript.jscomp.sourcemap.SourceMapGenerator;\n import com.google.javascript.jscomp.sourcemap.SourceMapGeneratorV1;\n import com.google.javascript.jscomp.sourcemap.SourceMapGeneratorV2;\n-import com.google.javascript.jscomp.sourcemap.Position;\n+import com.google.javascript.jscomp.sourcemap.FilePosition;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n  * @see CodePrinter\n  *\n  */\n-public class SourceMap implements SourceMapGenerator {\n+public class SourceMap {\n \n   public static enum Format {\n      LEGACY {\n     this.generator = generator;\n   }\n \n-  @Override\n   public void addMapping(\n-      Node node, Position startPosition, Position endPosition) {\n-    generator.addMapping(node, startPosition, endPosition);\n+      Node node,\n+      FilePosition outputStartPosition,\n+      FilePosition outputEndPosition) {\n+    String sourceFile = (String) node.getProp(Node.SOURCENAME_PROP);\n+    // If the node does not have an associated source file or\n+    // its line number is -1, then the node does not have sufficient\n+    // information for a mapping to be useful.\n+    if (sourceFile == null || node.getLineno() < 0) {\n+      return;\n+    }\n+\n+    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n+\n+    generator.addMapping(\n+        sourceFile, originalName,\n+        new FilePosition(node.getLineno(), node.getCharno()),\n+        outputStartPosition, outputEndPosition);\n   }\n \n-  @Override\n   public void appendTo(Appendable out, String name) throws IOException {\n     generator.appendTo(out, name);\n   }\n \n-  @Override\n   public void reset() {\n     generator.reset();\n   }\n \n-  @Override\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     generator.setStartingPosition(offsetLine, offsetIndex);\n   }\n \n-  @Override\n   public void setWrapperPrefix(String prefix) {\n     generator.setWrapperPrefix(prefix);\n   }\n-\n \n   public void validate(boolean validate) {\n     generator.validate(validate);\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/sourcemap/FilePosition.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.sourcemap;\n+\n+/**\n+ * Represents a position in a source file.\n+ *\n+ */\n+/**\n+ * Represents a position in a source file.\n+ */\n+public class FilePosition {\n+  private final int line;\n+  private final int column;\n+\n+  public FilePosition(int line, int column) {\n+    this.line = line;\n+    this.column = column;\n+  }\n+\n+  /**\n+   * Returns the line number of this postion.\n+   */\n+  public int getLine() {\n+    return line;\n+  }\n+\n+  /**\n+   * Returns the character index on the line\n+   * of this position.\n+   */\n+  public int getColumn() {\n+    return column;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/sourcemap/SourceMapGenerator.java\n+++ b/src/com/google/javascript/jscomp/sourcemap/SourceMapGenerator.java\n \n package com.google.javascript.jscomp.sourcemap;\n \n-import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Collects information mapping the generated (compiled) source back to\n  */\n public interface SourceMapGenerator {\n \n-  enum Format {\n+  public enum Format {\n      LEGACY {\n-       @Override SourceMapGenerator getInstance() {\n+       @Override\n+       public SourceMapGenerator getInstance() {\n          return new SourceMapGeneratorV1();\n        }\n      },\n      EXPERIMENTIAL {\n-       @Override SourceMapGenerator getInstance() {\n+       @Override\n+       public SourceMapGenerator getInstance() {\n          return new SourceMapGeneratorV2();\n        }\n      };\n-     abstract SourceMapGenerator getInstance();\n+     public abstract SourceMapGenerator getInstance();\n   }\n \n   /**\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n-   *\n-   * @param node The node that the new mapping represents.\n-   * @param startPosition The position on the starting line\n-   * @param endPosition The position on the ending line.\n+   * @param sourceName The file name to use in the generate source map\n+   *     to represent this source.\n+   * @param symbolName The symbol name associated with this position in the\n+   *     source map.\n+   * @param sourceStartPosition The starting position in the original source for\n+   *     represented range outputStartPosition to outputEndPosition in the\n+   *     generated file.\n+   * @param outputStartPosition The position on the starting line\n+   * @param outputEndPosition The position on the ending line.\n    */\n-  void addMapping(Node node, Position startPosition, Position endPosition);\n+  void addMapping(String sourceName, @Nullable String symbolName,\n+           FilePosition sourceStartPosition,\n+           FilePosition outputStartPosition, FilePosition outputEndPosition);\n \n   /**\n    * Sets the prefix used for wrapping the generated source file before\n    */\n   void validate(boolean validate);\n \n+  /**\n+   * @param out\n+   * @param name\n+   * @param appSections\n+   * @throws IOException\n+   */\n+  void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections)\n+      throws IOException;\n }\n--- a/src/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV1.java\n+++ b/src/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV1.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.List;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Collects information mapping the generated (compiled) source back to\n      * the line number and the character index are indexed by\n      * 1 for legacy reasons via the Rhino Node class.\n      */\n-    Position originalPosition;\n+    FilePosition originalPosition;\n \n     /**\n      * The starting position of the code in the generated source\n      * file which this mapping represents. Indexed by 0.\n      */\n-    Position startPosition;\n+    FilePosition startPosition;\n \n     /**\n      * The ending position of the code in the generated source\n      * file which this mapping represents. Indexed by 0.\n      */\n-    Position endPosition;\n+    FilePosition endPosition;\n \n     /**\n      * The original name of the token found at the position\n       out.append(escapedSourceFile);\n       out.append(\",\");\n \n-      int line = m.originalPosition.getLineNumber();\n+      int line = m.originalPosition.getLine();\n       if (line != lastLine) {\n         lastLineString = String.valueOf(line);\n       }\n \n       out.append(\",\");\n       out.append(String.valueOf(\n-          m.originalPosition.getCharacterIndex()));\n+          m.originalPosition.getColumn()));\n \n       if (m.originalName != null) {\n         out.append(\",\");\n    * The position that the current source map is offset in the\n    * buffer being used to generated the compiled source file.\n    */\n-  private Position offsetPosition = new Position(0, 0);\n+  private FilePosition offsetPosition = new FilePosition(0, 0);\n \n   /**\n    * The position that the current source map is offset in the\n    * generated the compiled source file by the addition of a\n    * an output wrapper prefix.\n    */\n-  private Position prefixPosition = new Position(0, 0);\n+  private FilePosition prefixPosition = new FilePosition(0, 0);\n \n   /**\n    * Escapes the given string for JSON.\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n-   *\n-   * @param node The node that the new mapping represents.\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n   public void addMapping(\n-      Node node, Position startPosition, Position endPosition) {\n-    String sourceFile = (String)node.getProp(Node.SOURCENAME_PROP);\n-\n-    // If the node does not have an associated source file or\n-    // its line number is -1, then the node does not have sufficient\n-    // information for a mapping to be useful.\n-    if (sourceFile == null || node.getLineno() < 0) {\n+      String sourceName, @Nullable String symbolName,\n+      FilePosition sourceStartPosition,\n+      FilePosition startPosition, FilePosition endPosition) {\n+\n+    // Don't bother if there is not sufficient information to be useful.\n+    if (sourceName == null || sourceStartPosition.getLine() < 0) {\n       return;\n     }\n \n     // Create the new mapping.\n     Mapping mapping = new Mapping();\n-    mapping.sourceFile = sourceFile;\n-    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n-\n-    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n-    if (originalName != null) {\n-      mapping.originalName = originalName;\n-    }\n-\n-    if (offsetPosition.getLineNumber() == 0\n-        && offsetPosition.getCharacterIndex() == 0) {\n+    mapping.sourceFile = sourceName;\n+    mapping.originalPosition = sourceStartPosition;\n+    mapping.originalName = symbolName; // may be null\n+\n+    // NOTE: When multiple outputs are concatenated together, the positions in\n+    // the mapping are relative to offsetPosition.\n+    if (offsetPosition.getLine() == 0\n+        && offsetPosition.getColumn() == 0) {\n       mapping.startPosition = startPosition;\n       mapping.endPosition = endPosition;\n     } else {\n       // its character position by the number of characters found on\n       // the *last* line of the source file to which the code is\n       // being generated.\n-      int offsetLine = offsetPosition.getLineNumber();\n-      int startOffsetPosition = offsetPosition.getCharacterIndex();\n-      int endOffsetPosition = offsetPosition.getCharacterIndex();\n-\n-      if (startPosition.getLineNumber() > 0) {\n+      int offsetLine = offsetPosition.getLine();\n+      int startOffsetPosition = offsetPosition.getColumn();\n+      int endOffsetPosition = offsetPosition.getColumn();\n+\n+      if (startPosition.getLine() > 0) {\n         startOffsetPosition = 0;\n       }\n \n-      if (endPosition.getLineNumber() > 0) {\n+      if (endPosition.getLine() > 0) {\n         endOffsetPosition = 0;\n       }\n \n       mapping.startPosition =\n-          new Position(startPosition.getLineNumber() + offsetLine,\n-                       startPosition.getCharacterIndex() + startOffsetPosition);\n+          new FilePosition(startPosition.getLine() + offsetLine,\n+                       startPosition.getColumn() + startOffsetPosition);\n \n       mapping.endPosition =\n-          new Position(endPosition.getLineNumber() + offsetLine,\n-                       endPosition.getCharacterIndex() + endOffsetPosition);\n+          new FilePosition(endPosition.getLine() + offsetLine,\n+                       endPosition.getColumn() + endOffsetPosition);\n     }\n \n     // Validate the mappings are in a proper order.\n     if (lastMapping != null) {\n-      int lastLine = lastMapping.startPosition.getLineNumber();\n-      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n-      int nextLine = mapping.startPosition.getLineNumber();\n-      int nextColumn = mapping.startPosition.getCharacterIndex();\n+      int lastLine = lastMapping.startPosition.getLine();\n+      int lastColumn = lastMapping.startPosition.getColumn();\n+      int nextLine = mapping.startPosition.getLine();\n+      int nextColumn = mapping.startPosition.getColumn();\n       Preconditions.checkState(nextLine > lastLine\n           || (nextLine == lastLine && nextColumn >= lastColumn),\n           \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n           + \"new : (%s,%s)\\nnode : %s\",\n-          lastLine, lastColumn, nextLine, nextColumn, node);\n+          lastLine, lastColumn, nextLine, nextColumn);\n     }\n \n     lastMapping = mapping;\n       }\n     }\n \n-    prefixPosition = new Position(prefixLine, prefixIndex);\n+    prefixPosition = new FilePosition(prefixLine, prefixIndex);\n   }\n \n   /**\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     Preconditions.checkState(offsetLine >= 0);\n     Preconditions.checkState(offsetIndex >= 0);\n-    offsetPosition = new Position(offsetLine, offsetIndex);\n+    offsetPosition = new FilePosition(offsetLine, offsetIndex);\n   }\n \n   /**\n   public void reset() {\n     mappings = Lists.newArrayList();\n     lastMapping = null;\n-    offsetPosition = new Position(0, 0);\n-    prefixPosition = new Position(0, 0);\n+    offsetPosition = new FilePosition(0, 0);\n+    prefixPosition = new FilePosition(0, 0);\n   }\n \n   /**\n     for (Mapping m : mappings) {\n       if (m.used) {\n         m.id = id++;\n-        int endPositionLine = m.endPosition.getLineNumber();\n+        int endPositionLine = m.endPosition.getLine();\n         maxLine = Math.max(maxLine, endPositionLine);\n       }\n     }\n \n     // Adjust for the prefix.\n-    return maxLine + prefixPosition.getLineNumber();\n+    return maxLine + prefixPosition.getLine();\n   }\n \n   private class LineMapper implements MappingVisitor {\n     /**\n      * @return The line adjusted for the prefix position.\n      */\n-    private int getAdjustedLine(Position p) {\n-      return p.getLineNumber() + prefixPosition.getLineNumber();\n+    private int getAdjustedLine(FilePosition p) {\n+      return p.getLine() + prefixPosition.getLine();\n     }\n \n     /**\n      * @return The column adjusted for the prefix position.\n      */\n-    private int getAdjustedCol(Position p) {\n-      int rawLine = p.getLineNumber();\n-      int rawCol = p.getCharacterIndex();\n+    private int getAdjustedCol(FilePosition p) {\n+      int rawLine = p.getLine();\n+      int rawCol = p.getColumn();\n       // Only the first line needs the character position adjusted.\n       return (rawLine != 0)\n-          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n+          ? rawCol : rawCol + prefixPosition.getColumn();\n     }\n \n     /**\n      */\n     private boolean isOverlapped(Mapping m1, Mapping m2) {\n       // No need to use adjusted values here, relative positions are sufficient.\n-      int l1 = m1.endPosition.getLineNumber();\n-      int l2 = m2.startPosition.getLineNumber();\n-      int c1 = m1.endPosition.getCharacterIndex();\n-      int c2 = m2.startPosition.getCharacterIndex();\n+      int l1 = m1.endPosition.getLine();\n+      int l2 = m2.startPosition.getLine();\n+      int c1 = m1.endPosition.getColumn();\n+      int c2 = m2.startPosition.getColumn();\n \n       return (l1 == l2 && c1 >= c2) || l1 > l2;\n     }\n   public void validate(boolean validate) {\n     // No additional validation to do.\n   }\n+\n+  @Override\n+  public void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections) {\n+    throw new UnsupportedOperationException();\n+  }\n }\n--- a/src/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV2.java\n+++ b/src/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV2.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.javascript.rhino.Node;\n-\n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.List;\n import java.util.Map.Entry;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Collects information mapping the generated (compiled) source back to\n  * its original source for debugging purposes.\n   /**\n    * A map of source names to source name index\n    */\n-  private LinkedHashMap<String, Integer> source_file_map =\n+  private LinkedHashMap<String, Integer> sourceFileMap =\n       Maps.newLinkedHashMap();\n \n   /**\n    * The position that the current source map is offset in the\n    * buffer being used to generated the compiled source file.\n    */\n-  private Position offsetPosition = new Position(0, 0);\n+  private FilePosition offsetPosition = new FilePosition(0, 0);\n \n   /**\n    * The position that the current source map is offset in the\n    * generated the compiled source file by the addition of a\n    * an output wrapper prefix.\n    */\n-  private Position prefixPosition = new Position(0, 0);\n+  private FilePosition prefixPosition = new FilePosition(0, 0);\n \n   /**\n    * {@inheritDoc}\n   public void reset() {\n     mappings.clear();\n     lastMapping = null;\n-    source_file_map.clear();\n+    sourceFileMap.clear();\n     lastSourceFile = null;\n     lastSourceFileIndex = -1;\n-    offsetPosition = new Position(0, 0);\n-    prefixPosition = new Position(0, 0);\n+    offsetPosition = new FilePosition(0, 0);\n+    prefixPosition = new FilePosition(0, 0);\n   }\n \n   /**\n       }\n     }\n \n-    prefixPosition = new Position(prefixLine, prefixIndex);\n+    prefixPosition = new FilePosition(prefixLine, prefixIndex);\n   }\n \n   /**\n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n     Preconditions.checkState(offsetLine >= 0);\n     Preconditions.checkState(offsetIndex >= 0);\n-    offsetPosition = new Position(offsetLine, offsetIndex);\n+    offsetPosition = new FilePosition(offsetLine, offsetIndex);\n   }\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n-   *\n-   * @param node The node that the new mapping represents.\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n   public void addMapping(\n-      Node node, Position startPosition, Position endPosition) {\n-    String sourceFile = (String)node.getProp(Node.SOURCENAME_PROP);\n-\n-    // If the node does not have an associated source file or\n-    // its line number is -1, then the node does not have sufficient\n-    // information for a mapping to be useful.\n-    if (sourceFile == null || node.getLineno() < 0) {\n+      String sourceName, @Nullable String symbolName,\n+      FilePosition sourceStartPosition,\n+      FilePosition startPosition, FilePosition endPosition) {\n+\n+    // Don't bother if there is not sufficient information to be useful.\n+    if (sourceName == null || sourceStartPosition.getLine() < 0) {\n       return;\n     }\n \n-    if (sourceFile != lastSourceFile) {\n-      lastSourceFile = sourceFile;\n-      Integer index = source_file_map.get(sourceFile);\n+    if (sourceName != lastSourceFile) {\n+      lastSourceFile = sourceName;\n+      Integer index = sourceFileMap.get(sourceName);\n       if (index != null) {\n         lastSourceFileIndex = index;\n       } else {\n-        lastSourceFileIndex = source_file_map.size();\n-        source_file_map.put(sourceFile, lastSourceFileIndex);\n-      }\n-    }\n-\n-    // Create the new mapping.\n-    Mapping mapping = new Mapping();\n-    mapping.sourceFile = lastSourceFileIndex;\n-    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n-\n-    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n-    if (originalName != null) {\n-      mapping.originalName = originalName;\n-    }\n-\n-    if (offsetPosition.getLineNumber() == 0\n-        && offsetPosition.getCharacterIndex() == 0) {\n-      mapping.startPosition = startPosition;\n-      mapping.endPosition = endPosition;\n-    } else {\n+        lastSourceFileIndex = sourceFileMap.size();\n+        sourceFileMap.put(sourceName, lastSourceFileIndex);\n+      }\n+    }\n+\n+    FilePosition adjustedStart = startPosition;\n+    FilePosition adjustedEnd = endPosition;\n+\n+    if (offsetPosition.getLine() != 0\n+        || offsetPosition.getColumn() != 0) {\n       // If the mapping is found on the first line, we need to offset\n       // its character position by the number of characters found on\n       // the *last* line of the source file to which the code is\n       // being generated.\n-      int offsetLine = offsetPosition.getLineNumber();\n-      int startOffsetPosition = offsetPosition.getCharacterIndex();\n-      int endOffsetPosition = offsetPosition.getCharacterIndex();\n-\n-      if (startPosition.getLineNumber() > 0) {\n+      int offsetLine = offsetPosition.getLine();\n+      int startOffsetPosition = offsetPosition.getColumn();\n+      int endOffsetPosition = offsetPosition.getColumn();\n+\n+      if (startPosition.getLine() > 0) {\n         startOffsetPosition = 0;\n       }\n \n-      if (endPosition.getLineNumber() > 0) {\n+      if (endPosition.getLine() > 0) {\n         endOffsetPosition = 0;\n       }\n \n-      mapping.startPosition =\n-          new Position(startPosition.getLineNumber() + offsetLine,\n-                       startPosition.getCharacterIndex() + startOffsetPosition);\n-\n-      mapping.endPosition =\n-          new Position(endPosition.getLineNumber() + offsetLine,\n-                       endPosition.getCharacterIndex() + endOffsetPosition);\n-    }\n+      adjustedStart = new FilePosition(\n+          startPosition.getLine() + offsetLine,\n+          startPosition.getColumn() + startOffsetPosition);\n+\n+      adjustedEnd = new FilePosition(\n+          endPosition.getLine() + offsetLine,\n+          endPosition.getColumn() + endOffsetPosition);\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = lastSourceFileIndex;\n+    mapping.originalPosition = sourceStartPosition;\n+    mapping.originalName = symbolName;\n+    mapping.startPosition = adjustedStart;\n+    mapping.endPosition = adjustedEnd;\n \n     // Validate the mappings are in a proper order.\n     if (lastMapping != null) {\n-      int lastLine = lastMapping.startPosition.getLineNumber();\n-      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n-      int nextLine = mapping.startPosition.getLineNumber();\n-      int nextColumn = mapping.startPosition.getCharacterIndex();\n+      int lastLine = lastMapping.startPosition.getLine();\n+      int lastColumn = lastMapping.startPosition.getColumn();\n+      int nextLine = mapping.startPosition.getLine();\n+      int nextColumn = mapping.startPosition.getColumn();\n       Preconditions.checkState(nextLine > lastLine\n           || (nextLine == lastLine && nextColumn >= lastColumn),\n           \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n           + \"new : (%s,%s)\\nnode : %s\",\n-          lastLine, lastColumn, nextLine, nextColumn, node);\n+          lastLine, lastColumn, nextLine, nextColumn);\n     }\n \n     lastMapping = mapping;\n    */\n   private void addSourceNameMap(Appendable out) throws IOException {\n     int i = 0;\n-    for (Entry<String, Integer> entry : source_file_map.entrySet()) {\n+    for (Entry<String, Integer> entry : sourceFileMap.entrySet()) {\n       String key = entry.getKey();\n       if (i != 0) {\n         out.append(\",\");\n \n   // Source map field helpers.\n \n-  private void appendFirstField(Appendable out, String name, String value)\n+  private static void appendFirstField(\n+      Appendable out, String name, String value)\n       throws IOException {\n     out.append(\"\\\"\");\n     out.append(name);\n     out.append(value);\n   }\n \n-  private void appendField(Appendable out, String name, String value)\n+  private static void appendField(Appendable out, String name, String value)\n       throws IOException {\n     out.append(\",\\n\");\n     out.append(\"\\\"\");\n     out.append(value);\n   }\n \n-  private void appendFieldStart(Appendable out, String name)\n+  private static void appendFieldStart(Appendable out, String name)\n       throws IOException {\n     appendField(out, name, \"\");\n   }\n \n   @SuppressWarnings(\"unused\")\n-  private void appendFieldEnd(Appendable out)\n+  private static void appendFieldEnd(Appendable out)\n      throws IOException {\n   }\n \n     for (Mapping m : mappings) {\n       if (m.used) {\n         m.id = id++;\n-        int endPositionLine = m.endPosition.getLineNumber();\n+        int endPositionLine = m.endPosition.getLine();\n         maxLine = Math.max(maxLine, endPositionLine);\n       }\n     }\n \n     // Adjust for the prefix.\n-    return maxLine + prefixPosition.getLineNumber();\n+    return maxLine + prefixPosition.getLine();\n   }\n \n   /**\n      * the line number and the character index are indexed by\n      * 1 for legacy reasons via the Rhino Node class.\n      */\n-    Position originalPosition;\n+    FilePosition originalPosition;\n \n     /**\n      * The starting position of the code in the generated source\n      * file which this mapping represents. Indexed by 0.\n      */\n-    Position startPosition;\n+    FilePosition startPosition;\n \n     /**\n      * The ending position of the code in the generated source\n      * file which this mapping represents. Indexed by 0.\n      */\n-    Position endPosition;\n+    FilePosition endPosition;\n \n     /**\n      * The original name of the token found at the position\n       out.append(String.valueOf(m.sourceFile));\n       out.append(\",\");\n \n-      int line = m.originalPosition.getLineNumber();\n+      int line = m.originalPosition.getLine();\n       if (line != lastLine) {\n         lastLineString = String.valueOf(line);\n       }\n \n       out.append(\",\");\n       out.append(String.valueOf(\n-          m.originalPosition.getCharacterIndex()));\n+          m.originalPosition.getColumn()));\n \n       if (m.originalName != null) {\n         out.append(\",\");\n   }\n \n   @VisibleForTesting\n-  static class LineMapEncoder {\n+  public static class LineMapEncoder {\n     /**\n      * The source map line map is consists of a series of entries each\n      * representing a map entry and a repetition count of that entry.\n      * @param reps The number of times the id is repeated in the map.\n      * @throws IOException\n      */\n-    static void encodeEntry(Appendable out, int id, int lastId, int reps)\n+    public static void encodeEntry(Appendable out, int id, int lastId, int reps)\n         throws IOException {\n       Preconditions.checkState(reps > 0);\n       int relativeIdLength = getRelativeMappingIdLength(id, lastId);\n      * @return A value relative to the the lastId.  Negative value are\n      * represented as a two-complement value.\n      */\n-    static int getRelativeMappingId(int id, int idLength, int lastId) {\n+    public static int getRelativeMappingId(int id, int idLength, int lastId) {\n       int base = 1 << (idLength *6);\n       int relativeId = id - lastId;\n       return (relativeId < 0) ? relativeId + base : relativeId;\n     /**\n      * @return The length of the base64 number needed to include the id.\n      */\n-    static int getRelativeMappingIdLength(int rawId, int lastId) {\n+    public static int getRelativeMappingIdLength(int rawId, int lastId) {\n       Preconditions.checkState(rawId >= 0 || rawId == UNMAPPED);\n       int relativeId = rawId - lastId;\n       int id = (relativeId < 0 ? Math.abs(relativeId) -1 : relativeId) << 1;\n    * A line mapping decoder class used for testing and validation.\n    */\n   @VisibleForTesting\n-  static class LineMapDecoder {\n+  public static class LineMapDecoder {\n     private static LineEntry decodeLineEntry(String in, int lastId) {\n       return decodeLineEntry(new StringParser(in), lastId);\n     }\n       return new LineEntry(mappingId, reps);\n     }\n \n-    static List<Integer> decodeLine(String lineSource) {\n+    public static List<Integer> decodeLine(String lineSource) {\n       return decodeLine(new StringParser(lineSource));\n     }\n \n     static private List<Integer> decodeLine(StringParser reader) {\n       List<Integer> result = Lists.newArrayListWithCapacity(512);\n       int lastId = 0;\n-      do {\n+      while (reader.hasNext()) {\n         LineEntry entry = decodeLineEntry(reader, lastId);\n         lastId = entry.id;\n \n         for (int i=0; i < entry.reps; i++) {\n           result.add(entry.id);\n         }\n-      } while(reader.hasNext());\n+      }\n \n       return result;\n     }\n     /**\n      * @return the id from the relative id.\n      */\n-    static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n+    public static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n       // The value range depends on the number of digits\n       int base = 1 << (digits * 6);\n       return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n     /**\n      * @return The line adjusted for the prefix position.\n      */\n-    private int getAdjustedLine(Position p) {\n-      return p.getLineNumber() + prefixPosition.getLineNumber();\n+    private int getAdjustedLine(FilePosition p) {\n+      return p.getLine() + prefixPosition.getLine();\n     }\n \n     /**\n      * @return The column adjusted for the prefix position.\n      */\n-    private int getAdjustedCol(Position p) {\n-      int rawLine = p.getLineNumber();\n-      int rawCol = p.getCharacterIndex();\n+    private int getAdjustedCol(FilePosition p) {\n+      int rawLine = p.getLine();\n+      int rawCol = p.getColumn();\n       // Only the first line needs the character position adjusted.\n       return (rawLine != 0)\n-          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n+          ? rawCol : rawCol + prefixPosition.getColumn();\n     }\n \n     /**\n      */\n     private boolean isOverlapped(Mapping m1, Mapping m2) {\n       // No need to use adjusted values here, relative positions are sufficient.\n-      int l1 = m1.endPosition.getLineNumber();\n-      int l2 = m2.startPosition.getLineNumber();\n-      int c1 = m1.endPosition.getCharacterIndex();\n-      int c2 = m2.startPosition.getCharacterIndex();\n+      int l1 = m1.endPosition.getLine();\n+      int l2 = m2.startPosition.getLine();\n+      int c1 = m1.endPosition.getColumn();\n+      int c2 = m2.startPosition.getColumn();\n \n       return (l1 == l2 && c1 >= c2) || l1 > l2;\n     }\n       col = nextCol;\n     }\n   }\n+\n+  /**\n+   * To facilitate incremental compiles, create a source map that is built\n+   * piecemeal from other source maps.\n+   * @throws IOException\n+   */\n+  @Override\n+  public void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections)\n+      throws IOException {\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"2\");\n+    appendField(out, \"file\", escapeString(name));\n+\n+    // Add the line character maps.\n+    appendFieldStart(out, \"sections\");\n+    out.append(\"[\\n\");\n+    boolean first = true;\n+    Long offset = new Long(0);\n+    for (SourceMapSection section : appSections) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        out.append(\",\\n\");\n+      }\n+      out.append(\"{\\n\");\n+      appendFirstField(out, \"offset\", offset.toString());\n+      appendField(out, \"file\", escapeString(section.getSectionUrl()));\n+      out.append(\"\\n}\");\n+\n+      offset += section.getLength();\n+    }\n+\n+    out.append(\"\\n]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/sourcemap/SourceMapSection.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.sourcemap;\n+\n+/**\n+ * A class representing a partial source map.\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapSection {\n+\n+  /**\n+   * A url for a valid source map file that represents a section of a generate\n+   * source file such as when multiple files are concatenated together.\n+   */\n+  private final String sectionUrl;\n+  private final long representedLength;\n+\n+  /**\n+   * @param sectionUrl The url for the partial sourcemap\n+   * @param length The number of character represented by the source\n+   * map section.\n+   */\n+  public SourceMapSection(String sectionUrl, long length) {\n+    this.sectionUrl = sectionUrl;\n+    this.representedLength = length;\n+  }\n+\n+  /**\n+   * @return the name\n+   */\n+  public String getSectionUrl() {\n+    return sectionUrl;\n+  }\n+\n+  /**\n+   * @return the length\n+   */\n+  public long getLength() {\n+    return representedLength;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV1Test.java\n+++ b/test/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV1Test.java\n \n   private static class RunResult {\n     String generatedSource;\n-    SourceMapGenerator sourceMap;\n+    SourceMap sourceMap;\n     public String sourceMapFileContent;\n   }\n \n   private static class Token {\n     String tokenName;\n-    Position position;\n+    FilePosition position;\n   }\n \n   /**\n           Token token = new Token();\n           token.tokenName = tokenName;\n           int currentPosition = i - positionOffset;\n-          token.position = new Position(currentLine, currentPosition);\n+          token.position = new FilePosition(currentLine, currentPosition);\n           tokens.put(tokenName, token);\n         }\n \n     // input source and ensure that the map is correct.\n     for (Token token : resultTokens.values()) {\n       OriginalMapping mapping = reader.getMappingForLine(\n-          token.position.getLineNumber() + 1,\n-          token.position.getCharacterIndex() + 1);\n+          token.position.getLine() + 1,\n+          token.position.getColumn() + 1);\n \n       assertNotNull(mapping);\n \n \n       // Ensure that the map correctly points to the token (we add 1\n       // to normalize versus the Rhino line number indexing scheme).\n-      assertEquals(mapping.position.getLineNumber(),\n-                   inputToken.position.getLineNumber() + 1);\n+      assertEquals(mapping.position.getLine(),\n+                   inputToken.position.getLine() + 1);\n \n       // Ensure that if the token name does not being with an 'STR' (meaning a\n       // string) it has an original name.\n \n   public static class OriginalMapping {\n     public final String srcfile;\n-    public final Position position;\n+    public final FilePosition position;\n     public final String originalName;\n \n     OriginalMapping(String srcfile, int line, int column, String name) {\n       this.srcfile = srcfile;\n-      this.position = new Position(line, column);\n+      this.position = new FilePosition(line, column);\n       this.originalName = name;\n     }\n   }\n--- a/test/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV2Test.java\n+++ b/test/com/google/javascript/jscomp/sourcemap/SourceMapGeneratorV2Test.java\n \n   private static class Token {\n     String tokenName;\n-    Position position;\n+    FilePosition position;\n   }\n \n   /**\n           Token token = new Token();\n           token.tokenName = tokenName;\n           int currentPosition = i - positionOffset;\n-          token.position = new Position(currentLine, currentPosition);\n+          token.position = new FilePosition(currentLine, currentPosition);\n           tokens.put(tokenName, token);\n         }\n \n     // input source and ensure that the map is correct.\n     for (Token token : resultTokens.values()) {\n       OriginalMapping mapping = reader.getMappingForLine(\n-          token.position.getLineNumber() + 1,\n-          token.position.getCharacterIndex() + 1);\n+          token.position.getLine() + 1,\n+          token.position.getColumn() + 1);\n \n       assertNotNull(mapping);\n \n \n       // Ensure that the map correctly points to the token (we add 1\n       // to normalize versus the Rhino line number indexing scheme).\n-      assertEquals(mapping.position.getLineNumber(),\n-                   inputToken.position.getLineNumber() + 1);\n+      assertEquals(mapping.position.getLine(),\n+                   inputToken.position.getLine() + 1);\n \n       // Ensure that if the token name does not being with an 'STR' (meaning a\n       // string) it has an original name.\n \n   public static class OriginalMapping {\n     public final String srcfile;\n-    public final Position position;\n+    public final FilePosition position;\n     public final String originalName;\n \n     OriginalMapping(String srcfile, int line, int column, String name) {\n       this.srcfile = srcfile;\n-      this.position = new Position(line, column);\n+      this.position = new FilePosition(line, column);\n       this.originalName = name;\n     }\n   }", "timestamp": 1298424287, "metainfo": ""}