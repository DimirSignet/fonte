{"sha": "43f6b639e7129e2d69135e065ac481298d4e34f7", "log": "Add support for \"get\" and \"set\" property definitions. Also, fix code motion when prototype properties are set using an object literal.  R=nicksantos DELTA=131  (102 added, 13 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=145   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n         // should count as a use of property a and b.\n         for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n              propNameNode = propNameNode.getNext()) {\n-          if (propNameNode.getType() == Token.STRING &&\n+          // May be NUMBER, STRING, GET, or SET, but NUMBER isn't interesting.\n+          if (propNameNode.getType() != Token.NUMBER &&\n               !propNameNode.isQuotedString()) {\n             addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n           }\n               NodeUtil.isExprAssign(grandParent) &&\n               NodeUtil.isLhs(n, parent)) {\n             String name = dest.getString();\n-            Property prop = new AssignmentProperty(grandParent,\n-                grandParent.getParent(), t.getModule());\n+            Property prop = new AssignmentProperty(grandParent, t.getModule());\n             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n           }\n           break;\n         case Token.ASSIGN:\n           Node map = n.getFirstChild().getNext();\n           if (map.getType() == Token.OBJECTLIT) {\n-            // assumes the object literal is well formed\n-            // (has an even number of children)\n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n-              if (key.getType() == Token.STRING) {\n+              // May be NUMBER, STRING, GET, or SET,\n+              // but NUMBER isn't interesting.\n+              if (key.getType() != Token.NUMBER) {\n                 String name = key.getString();\n                 Property prop = new LiteralProperty(\n                     key, key.getFirstChild(), map, n, t.getModule());\n \n     /** Returns the value of this property. */\n     Node getValue();\n-\n-    /** Returns the parent of the value of this property. */\n-    Node getValueParent();\n   }\n \n   /**\n    * Foo.prototype.bar = function() { ... };</pre>\n    */\n   static class AssignmentProperty implements Property {\n-    private final Node node;\n+    private final Node exprNode;\n     private final JSModule module;\n \n     /**\n      * @param node An EXPR node.\n-     * @param parent parent of {@code node}\n-     */\n-    AssignmentProperty(Node node, Node parent, JSModule module) {\n-      this.node = node;\n+     */\n+    AssignmentProperty(Node node, JSModule module) {\n+      this.exprNode = node;\n       this.module = module;\n     }\n \n     @Override\n     public void remove() {\n-      NodeUtil.removeChild(node.getParent(), node);\n+      NodeUtil.removeChild(exprNode.getParent(), exprNode);\n     }\n \n     @Override\n     public Node getPrototype() {\n-      return getValueParent().getFirstChild().getFirstChild();\n+      return getAssignNode().getFirstChild().getFirstChild();\n     }\n \n     @Override\n     public Node getValue() {\n-      return getValueParent().getLastChild();\n-    }\n-\n-    @Override\n-    public Node getValueParent() {\n-      return node.getFirstChild();\n+      return getAssignNode().getLastChild();\n+    }\n+\n+    private Node getAssignNode() {\n+      return exprNode.getFirstChild();\n     }\n \n     @Override\n     }\n \n     @Override\n-    public Node getValueParent() {\n-      return map;\n-    }\n-\n-    @Override\n     public JSModule getModule() {\n       return module;\n     }\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         // We should only move a property across modules if:\n         // 1) We can move it deeper in the module graph, and\n         // 2) it's a function.\n+        // 3) it is not a get or a set.\n         //\n         // #1 should be obvious. #2 is more subtle. It's possible\n         // to copy off of a prototype, as in the code:\n         Node value = prop.getValue();\n         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n             value.getType() == Token.FUNCTION) {\n-          Node valueParent = prop.getValueParent();\n+          Node valueParent = value.getParent();\n+          if (valueParent.getType() == Token.GET\n+              || valueParent.getType() == Token.SET) {\n+            // TODO(johnlenz): a GET or SET can't be deferred like a normal\n+            // FUNCTION property definition as a mix-in would get the result\n+            // of a GET instead of the function itself.\n+            continue;\n+          }\n           Node proto = prop.getPrototype();\n           int stubId = idGenerator.newId();\n \n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n     canMoveExterns = false;\n   }\n \n-  public void testMovePrototypeMethod() {\n+  public void testMovePrototypeMethod1() {\n     testSame(createModuleChain(\n                  \"function Foo() {}\" +\n                  \"Foo.prototype.bar = function() {};\",\n              \"Foo.prototype.bar = JSCompiler_unstubMethod(0, function() {});\" +\n              \"(new Foo).bar()\"\n          });\n+  }\n+\n+  public void testMovePrototypeMethod2() {\n+    test(createModuleChain(\n+             \"function Foo() {}\" +\n+             \"Foo.prototype = { method: function() {} };\",\n+             // Module 2\n+             \"(new Foo).method()\"),\n+         new String[] {\n+             STUB_DECLARATIONS +\n+             \"function Foo() {}\" +\n+             \"Foo.prototype = { method: JSCompiler_stubMethod(0) };\",\n+             // Module 2\n+             \"Foo.prototype.method = \" +\n+             \"    JSCompiler_unstubMethod(0, function() {});\" +\n+             \"(new Foo).method()\"\n+         });\n+  }\n+\n+  public void testMovePrototypeMethod3() {\n+    testSame(createModuleChain(\n+             \"function Foo() {}\" +\n+             \"Foo.prototype = { get method() {} };\",\n+             // Module 2\n+             \"(new Foo).method()\"));\n   }\n \n   public void testMovePrototypeRecursiveMethod() {\n            \"var y = new Foo(); y.baz();\"\n         });\n   }\n-  \n+\n   // An anonymous inner function reading a closure variable is fine.\n   public void testInnerFunctionClosureVariableReads() {\n     test(createModuleChain(\n            \"var y = new Foo(); y.baz();\"\n         });\n   }\n-  \n+\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n         \"Foo.prototype.methodA = function() {};\" +\n         \"this.methodA();\");\n   }\n+\n+  public void testGetterBaseline() {\n+    anchorUnusedVars = true;\n+    test(\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  methodA: function() {},\" +\n+        \"  methodB: function() { x(); }\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA(); }\",\n+\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  methodA: function() {}\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA(); }\");\n+  }\n+\n+  public void testGetter1() {\n+    test(\n+      \"function Foo() {}\" +\n+      \"Foo.prototype = { \" +\n+      \"  get methodA() {},\" +\n+      \"  get methodB() { x(); }\" +\n+      \"};\" +\n+      \"function x() { (new Foo).methodA; }\",\n+\n+      \"function Foo() {}\" +\n+      \"Foo.prototype = {};\");\n+    \n+    anchorUnusedVars = true;\n+    test(\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  get methodA() {},\" +\n+        \"  get methodB() { x(); }\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA; }\",\n+\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  get methodA() {}\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA; }\");\n+  }\n+\n+  public void testGetter2() {\n+    anchorUnusedVars = true;\n+    test(\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  get methodA() {},\" +\n+        \"  set methodA(a) {},\" +\n+        \"  get methodB() { x(); },\" +\n+        \"  set methodB(a) { x(); }\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA; }\",\n+\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = { \" +\n+        \"  get methodA() {},\" +\n+        \"  set methodA(a) {}\" +\n+        \"};\" +\n+        \"function x() { (new Foo).methodA; }\");\n+  }\n+\n }", "timestamp": 1292431658, "metainfo": ""}