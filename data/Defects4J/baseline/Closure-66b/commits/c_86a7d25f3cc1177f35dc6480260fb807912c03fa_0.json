{"sha": "86a7d25f3cc1177f35dc6480260fb807912c03fa", "log": "Fix bad folding of expressions containing object and array literals with side-effects.  R=nicksantos DELTA=144  (94 added, 0 deleted, 50 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1088   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n         // type system that can evaluate some impressions' boolean value but\n         // for now we will keep this pass lightweight.\n         if (condition != null) {\n-          TernaryValue val = NodeUtil.getBooleanValue(condition);\n+          TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n           if (val != TernaryValue.UNKNOWN) {\n             return val.toBoolean(true) == (Branch.ON_TRUE == branch);\n           }\n--- a/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n+++ b/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n       // TODO(user): Handle more complicated expression like true == true,\n       // etc....\n       if (condition != null) {\n-        TernaryValue val = NodeUtil.getBooleanValue(condition);\n+        TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n         if (val != TernaryValue.UNKNOWN) {\n           return val.toBoolean(true) == (branch == Branch.ON_TRUE);\n         }\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n             NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n \n         Node cond = NodeUtil.getConditionExpression(n);\n-        if (NodeUtil.getBooleanValue(cond) == TernaryValue.FALSE) {\n+        if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {\n           // Normally, we wouldn't be able to optimize BREAKs inside a loop\n           // but as we know the condition will always false, we can treat them\n           // as we would a CONTINUE.\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Note: unlike getBooleanValue this function does not return UNKNOWN\n    * for expressions with side-effects.\n    */\n-  static TernaryValue getExpressionBooleanValue(Node n) {\n+  static TernaryValue getImpureBooleanValue(Node n) {\n     switch (n.getType()) {\n       case Token.ASSIGN:\n       case Token.COMMA:\n         // For ASSIGN and COMMA the value is the value of the RHS.\n-        return getExpressionBooleanValue(n.getLastChild());\n+        return getImpureBooleanValue(n.getLastChild());\n       case Token.NOT:\n-        TernaryValue value = getExpressionBooleanValue(n.getLastChild());\n+        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n         return value.not();\n       case Token.AND: {\n-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n         return lhs.and(rhs);\n       }\n       case Token.OR:  {\n-        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n-        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n+        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n+        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n         return lhs.or(rhs);\n       }\n       case Token.HOOK:  {\n-        TernaryValue trueValue = getExpressionBooleanValue(\n+        TernaryValue trueValue = getImpureBooleanValue(\n             n.getFirstChild().getNext());\n-        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());\n+        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n         if (trueValue.equals(falseValue)) {\n           return trueValue;\n         } else {\n           return TernaryValue.UNKNOWN;\n         }\n       }\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // ignoring side-effects\n+        return TernaryValue.TRUE;\n+\n       default:\n-        return getBooleanValue(n);\n+        return getPureBooleanValue(n);\n     }\n   }\n \n   /**\n    * Gets the boolean value of a node that represents a literal. This method\n-   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n-   */\n-  static TernaryValue getBooleanValue(Node n) {\n+   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n+   * except it return UNKNOWN for known values with side-effects, use\n+   * getExpressionBooleanValue if you don't care about side-effects.\n+   */\n+  static TernaryValue getPureBooleanValue(Node n) {\n     switch (n.getType()) {\n       case Token.STRING:\n         return TernaryValue.forBoolean(n.getString().length() > 0);\n         return TernaryValue.forBoolean(n.getDouble() != 0);\n \n       case Token.NOT:\n-        return getBooleanValue(n.getLastChild()).not();\n+        return getPureBooleanValue(n.getLastChild()).not();\n \n       case Token.NULL:\n       case Token.FALSE:\n         break;\n \n       case Token.TRUE:\n+      case Token.REGEXP:\n+        return TernaryValue.TRUE;\n+\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n-      case Token.REGEXP:\n-        return TernaryValue.TRUE;\n+        if (!mayHaveSideEffects(n)) {\n+          return TernaryValue.TRUE;\n+        }\n     }\n \n     return TernaryValue.UNKNOWN;\n         return \"undefined\";\n \n       case Token.NOT:\n-        TernaryValue child = getBooleanValue(n.getFirstChild());\n+        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n         if (child != TernaryValue.UNKNOWN) {\n           return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n         }\n         return null;\n \n       case Token.NOT:\n-        TernaryValue child = getBooleanValue(n.getFirstChild());\n+        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n         if (child != TernaryValue.UNKNOWN) {\n           return child.toBoolean(true) ? 0.0 : 1.0; // reversed.\n         }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       return n;\n     }\n \n-    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+    TernaryValue leftVal = NodeUtil.getPureBooleanValue(left);\n     if (leftVal == TernaryValue.UNKNOWN) {\n       return n;\n     }\n \n     int type = n.getType();\n \n-    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+    TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left);\n \n     if (leftVal != TernaryValue.UNKNOWN) {\n       boolean lval = leftVal.toBoolean(true);\n           !lval && type == Token.AND) {\n         result = left;\n \n-      } else {\n+      } else if (!mayHaveSideEffects(left)) {\n         // (FALSE || x) => x\n         // (TRUE && x) => x\n         result = right;\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       if (NodeUtil.isName(lhsAssign) && NodeUtil.isName(condition)\n           && lhsAssign.getString().equals(condition.getString())) {\n         Node rhsAssign = getSimpleAssignmentValue(n);\n-        TernaryValue value = NodeUtil.getExpressionBooleanValue(rhsAssign);\n+        TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign);\n         if (value != TernaryValue.UNKNOWN) {\n           int replacementConditionNodeType =\n             (value.toBoolean(true)) ? Token.TRUE : Token.FALSE;\n     }\n \n     // Try transforms that apply to both IF and HOOK.\n-    TernaryValue condValue = NodeUtil.getExpressionBooleanValue(cond);\n+    TernaryValue condValue = NodeUtil.getImpureBooleanValue(cond);\n     if (condValue == TernaryValue.UNKNOWN) {\n       return n;  // We can't remove branches otherwise!\n     }\n     Node thenBody = cond.getNext();\n     Node elseBody = thenBody.getNext();\n \n-    TernaryValue condValue = NodeUtil.getExpressionBooleanValue(cond);\n+    TernaryValue condValue = NodeUtil.getImpureBooleanValue(cond);\n     if (condValue == TernaryValue.UNKNOWN) {\n       return n;  // We can't remove branches otherwise!\n     }\n   Node tryFoldWhile(Node n) {\n     Preconditions.checkArgument(n.getType() == Token.WHILE);\n     Node cond = NodeUtil.getConditionExpression(n);\n-    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+    if (NodeUtil.getPureBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n     }\n     NodeUtil.redeclareVarsInsideBranch(n);\n       return n;\n     }\n \n-    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+    if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n     }\n \n     NodeUtil.redeclareVarsInsideBranch(n);\n-    NodeUtil.removeChild(n.getParent(), n);\n+    if (!mayHaveSideEffects(cond)) {\n+      NodeUtil.removeChild(n.getParent(), n);\n+    } else {\n+      Node statement = new Node(Token.EXPR_RESULT, cond.detachFromParent())\n+          .copyInformationFrom(cond);\n+      n.getParent().replaceChild(n, statement);\n+    }\n     reportCodeChange();\n     return null;\n   }\n     Preconditions.checkArgument(n.getType() == Token.DO);\n \n     Node cond = NodeUtil.getConditionExpression(n);\n-    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+    if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n     }\n \n         NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));\n     Node block = n.removeFirstChild();\n \n-    n.getParent().replaceChild(n, block);\n+    Node parent =  n.getParent();\n+    parent.replaceChild(n, block);\n+    if (mayHaveSideEffects(cond)) {\n+      Node condStatement = new Node(Token.EXPR_RESULT, cond.detachFromParent())\n+          .copyInformationFrom(cond);\n+      parent.addChildAfter(condStatement, block);\n+    }\n     reportCodeChange();\n \n     return n;\n    * Remove always true loop conditions.\n    */\n   private void tryFoldForCondition(Node forCondition) {\n-    if (NodeUtil.getBooleanValue(forCondition) == TernaryValue.TRUE) {\n+    if (NodeUtil.getPureBooleanValue(forCondition) == TernaryValue.TRUE) {\n       forCondition.getParent().replaceChild(forCondition,\n           new Node(Token.EMPTY));\n       reportCodeChange();\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n             }\n \n            default:\n-             TernaryValue nVal = NodeUtil.getBooleanValue(first);\n+             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n              if (nVal != TernaryValue.UNKNOWN) {\n                boolean result = nVal.not().toBoolean(true);\n                int equivalentResult = result ? 1 : 0;\n         //   x || true  --> true\n         //   x && true --> x\n         //   x && false  --> false\n-        TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n-        if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {\n+        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n+        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n           int type = n.getType();\n           Node replacement = null;\n           boolean rval = rightVal.toBoolean(true);\n         //   x ? true : y     --> x || y\n         //   x ? y : false    --> x && y\n         Node replacement = null;\n-        if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE\n-            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n+        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n+        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n+        if (trueNodeVal == TernaryValue.TRUE\n+            && falseNodeVal == TernaryValue.FALSE) {\n           // Remove useless conditionals, keep the condition\n           condition.detachFromParent();\n           replacement = condition;\n-        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE\n-            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {\n+        } else if (trueNodeVal == TernaryValue.FALSE\n+            && falseNodeVal == TernaryValue.TRUE) {\n           // Remove useless conditionals, keep the condition\n           condition.detachFromParent();\n           replacement = new Node(Token.NOT, condition);\n-        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {\n+        } else if (trueNodeVal == TernaryValue.TRUE) {\n           // Remove useless true case.\n           n.detachChildren();\n           replacement = new Node(Token.OR, condition, falseNode);\n-        } else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n+        } else if (falseNodeVal == TernaryValue.FALSE) {\n           // Remove useless false case\n           n.detachChildren();\n           replacement = new Node(Token.AND, condition, trueNode);\n \n       default:\n         // while(true) --> while(1)\n-        TernaryValue nVal = NodeUtil.getBooleanValue(n);\n+        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n         if (nVal != TernaryValue.UNKNOWN) {\n           boolean result = nVal.toBoolean(true);\n           int equivalentResult = result ? 1 : 0;\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertBooleanFalse(\"void foo()\");\n     assertBooleanUnknown(\"b\");\n     assertBooleanUnknown(\"-'0.0'\");\n+\n+    // Known but getBooleanValue return false for expressions with side-effects\n+    assertBooleanUnknown(\"{a:foo()}\");\n+    assertBooleanUnknown(\"[foo()]\");\n   }\n \n   private void assertBooleanTrue(String val) {\n-    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));\n+    assertEquals(TernaryValue.TRUE, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n   private void assertBooleanFalse(String val) {\n-    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));\n+    assertEquals(\n+        TernaryValue.FALSE, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n   private void assertBooleanUnknown(String val) {\n-    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n+    assertEquals(\n+        TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val)));\n   }\n \n   public void testGetExpressionBooleanValue() {\n \n     assertExpressionBooleanUnknown(\"b\");\n     assertExpressionBooleanUnknown(\"-'0.0'\");\n+\n+    assertExpressionBooleanTrue(\"{a:foo()}\");\n+    assertExpressionBooleanTrue(\"[foo()]\");\n   }\n \n   private void assertExpressionBooleanTrue(String val) {\n     assertEquals(TernaryValue.TRUE,\n-        NodeUtil.getExpressionBooleanValue(getNode(val)));\n+        NodeUtil.getImpureBooleanValue(getNode(val)));\n   }\n \n   private void assertExpressionBooleanFalse(String val) {\n     assertEquals(TernaryValue.FALSE,\n-        NodeUtil.getExpressionBooleanValue(getNode(val)));\n+        NodeUtil.getImpureBooleanValue(getNode(val)));\n   }\n \n   private void assertExpressionBooleanUnknown(String val) {\n     assertEquals(TernaryValue.UNKNOWN,\n-        NodeUtil.getExpressionBooleanValue(getNode(val)));\n+        NodeUtil.getImpureBooleanValue(getNode(val)));\n   }\n \n   public void testGetStringValue() {\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   public void testFoldLogicalOp() {\n     fold(\"x = true && x\", \"x = x\");\n+    foldSame(\"x = [foo()] && x\");\n+\n     fold(\"x = false && x\", \"x = false\");\n     fold(\"x = true || x\", \"x = true\");\n     fold(\"x = false || x\", \"x = x\");\n     fold(\"'A'.toLowerCase()\", \"'a'\");\n     fold(\"'a'.toLowerCase()\", \"'a'\");\n     fold(\"'aBcDe'.toLowerCase()\", \"'abcde'\");\n+  }\n+\n+  public void testObjectLiteral() {\n+    test(\"(!{})\", \"false\");\n+    test(\"(!{a:1})\", \"false\");\n+    testSame(\"(!{a:foo()})\");\n+    testSame(\"(!{'a':foo()})\");\n+  }\n+\n+  public void testArrayLiteral() {\n+    test(\"(![])\", \"false\");\n+    test(\"(![1])\", \"false\");\n+    test(\"(![a])\", \"false\");\n+    testSame(\"(![foo()])\");\n   }\n \n   private static final List<String> LITERAL_OPERANDS =\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n     doCommaSplitting = false;\n     foldSame(\"x(),y(),z()\");\n   }\n+\n+  public void testObjectLiteral() {\n+    test(\"({})\", \"\");\n+    test(\"({a:1})\", \"\");\n+    test(\"({a:foo()})\", \"foo()\");\n+    test(\"({'a':foo()})\", \"foo()\");\n+  }\n+\n+  public void testArrayLiteral() {\n+    test(\"([])\", \"\");\n+    test(\"([1])\", \"\");\n+    test(\"([a])\", \"\");\n+    test(\"([foo()])\", \"foo()\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n     fold(\"do { foo() } while(true);\", \"do { foo() } while(true);\");\n     fold(\"do { var a = 0; } while(false);\", \"var a=0\");\n \n+    fold(\"do { var a = 0; } while(!{a:foo()});\", \"var a=0;foo()\");\n+\n     // Can't fold with break or continues.\n     foldSame(\"do { foo(); continue; } while(0)\");\n     foldSame(\"do { foo(); break; } while(0)\");\n-    }\n+  }\n \n   public void testMinimizeWhileConstantCondition() {\n     fold(\"while(true) foo()\", \"while(true) foo()\");\n     test(\"function f() { return; try{var x = 1}finally{} }\",\n         \"function f() { return; var x = 1; }\");\n   }\n+\n+  public void testObjectLiteral() {\n+    test(\"({})\", \"\");\n+    test(\"({a:1})\", \"\");\n+    test(\"({a:foo()})\", \"foo()\");\n+    test(\"({'a':foo()})\", \"foo()\");\n+  }\n+\n+  public void testArrayLiteral() {\n+    test(\"([])\", \"\");\n+    test(\"([1])\", \"\");\n+    test(\"([a])\", \"\");\n+    test(\"([foo()])\", \"foo()\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     doCommaSplitting = false;\n     foldSame(\"a(), b(), 1\");\n   }\n+\n+  public void testObjectLiteral() {\n+    test(\"({})\", \"1\");\n+    test(\"({a:1})\", \"1\");\n+    testSame(\"({a:foo()})\");\n+    testSame(\"({'a':foo()})\");\n+  }\n+\n+  public void testArrayLiteral() {\n+    test(\"([])\", \"1\");\n+    test(\"([1])\", \"1\");\n+    test(\"([a])\", \"1\");\n+    testSame(\"([foo()])\");\n+  }\n }", "timestamp": 1301095661, "metainfo": ""}