{"sha": "d48c365ba8251057a71a2e2b7aabff640209e31b", "log": "\"var arguments\" never shadows the built-in arguments array. Fixes issue 115.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n   private Scope scope;\n   private String sourceName;\n   private final RedeclarationHandler redeclarationHandler;\n+\n+  // The arguments variable is special, in that it's declared in every local\n+  // scope, but not explicitly declared.\n+  private static final String ARGUMENTS = \"arguments\";\n \n   public static final DiagnosticType VAR_MULTIPLY_DECLARED_ERROR =\n       DiagnosticType.error(\n           info = parent.getJSDocInfo();\n         }\n         allowDupe =\n-          info != null && info.getSuppressions().contains(\"duplicate\");\n+            info != null && info.getSuppressions().contains(\"duplicate\");\n \n         if (!allowDupe) {\n           compiler.report(\n   private void declareVar(String name, Node n, Node parent,\n                           Node gramps, JSType declaredType,\n                           Node nodeWithLineNumber) {\n-    if (scope.isDeclared(name, false)) {\n+    if (scope.isDeclared(name, false)\n+        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n       redeclarationHandler.onRedeclaration(\n           scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n   /** Externs for the test */\n   private final JSSourceFile[] externs = new JSSourceFile[] {\n     JSSourceFile.fromCode(\"externs\",\n-        \"/** @constructor */ function Window() {}\\n\"\n+        \"var arguments;\" +\n+        \"/** @constructor \\n * @param {...*} var_args \\n \" +\n+        \"* @return {!Array} */ \" +\n+        \"function Array(var_args) {}\\n\"\n+        + \"/** @constructor */ function Window() {}\\n\"\n         + \"/** @type {string} */ Window.prototype.name;\\n\"\n         + \"/** @type {Window} */ var window;\"\n         + \"/** @nosideeffects */ function noSideEffects() {}\")\n     useStringComparison = true;\n     test(\"eval('1'); var x = eval; x('2');\",\n          \"eval(\\\"1\\\");(0,eval)(\\\"2\\\");\");\n+  }\n+\n+  public void testIssue115() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CompilerRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.VERBOSE);\n+    test(\"function f() { \" +\n+         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n+         \"  return arguments[0]; \" +\n+         \"}\",\n+         \"function f() { \" +\n+         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n+         \"  return arguments[0]; \" +\n+         \"}\");\n   }\n \n   public void testDebugFlag1() {", "timestamp": 1267197065, "metainfo": ""}