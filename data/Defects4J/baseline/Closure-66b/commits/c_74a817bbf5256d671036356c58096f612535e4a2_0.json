{"sha": "74a817bbf5256d671036356c58096f612535e4a2", "log": "Change on 2010/04/08 by john          Part I: Add a pass that checks for references to the global RegExp object.          R=alan         DELTA=192  (185 added, 1 deleted, 6 changed)  Change on 2010/04/08 by nick          type annotation fixit. Fixes issue 140.          R=alan         DELTA=69  (41 added, 0 deleted, 28 changed)  Change on 2010/04/08 by alan          Fix the flow sensitive inlining case that breaks code.          R=john         DELTA=163  (158 added, 0 deleted, 5 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=jfazwv   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    * If type aware optimizations are on, type equality is checked.\n    */\n   abstract boolean areNodesEqualForInlining(Node n1, Node n2);\n+\n+  /**\n+   * Set if RegExp global properties are used.\n+   * @param references Whether there are references to the RegExp global object\n+   *     properties.\n+   */\n+  abstract void setHasRegExpGlobalReferences(boolean references);\n+  \n+  /**\n+   * @return Whether the AST constains references to the RegExp global object\n+   *     properties.\n+   */\n+  abstract boolean hasRegExpGlobalReferences();\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.mozilla.rhino.Token;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Look for references to the global RegExp object that would cause\n+ * regular expressions to be unoptimizable.\n+ * \n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+class CheckRegExp extends AbstractPostOrderCallback implements CompilerPass {\n+\n+  // TODO(johnlenz): Get this warning turned on by default.\n+  static final DiagnosticType REGEXP_REFERENCE =\n+    DiagnosticType.disabled(\"JSC_REGEXP_REFERENCE\",\n+        \"References to the global RegExp object prevents \" +\n+        \"optimization of regular expressions.\");\n+\n+  private final AbstractCompiler compiler;\n+  private boolean globalRegExpPropertiesUsed = false;\n+\n+  public boolean isGlobalRegExpPropertiesUsed() {\n+    return globalRegExpPropertiesUsed;\n+  }\n+\n+  public CheckRegExp(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (NodeUtil.isReferenceName(n)) {\n+      String name = n.getString();\n+      if (name.equals(\"RegExp\") && t.getScope().getVar(name) == null) {\n+        if (parent.getType() != Token.NEW || n != parent.getFirstChild()) {\n+          t.report(n, REGEXP_REFERENCE);\n+          globalRegExpPropertiesUsed = true;\n+        }\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   /** Whether to use threads. */\n   private boolean useThreads = true;\n \n+  /** \n+   * Whether to assume there are references to the RegExp Global object\n+   * properties.\n+   */\n+  private boolean hasRegExpGlobalReferences = true;\n+  \n   /** The function information map */\n   private FunctionInformationMap functionInformationMap;\n \n     typeRegistry = state.typeRegistry;\n     normalized = state.normalized;\n   }\n+\n+  @Override\n+  boolean hasRegExpGlobalReferences() {\n+    return hasRegExpGlobalReferences;\n+  }\n+\n+  @Override\n+  void setHasRegExpGlobalReferences(boolean references) {\n+    hasRegExpGlobalReferences = references;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     }\n \n     checks.add(checkVars);\n+    if (options.computeFunctionSideEffects) {\n+      checks.add(checkRegExp);\n+    }\n \n     if (options.checkShadowVars.isOn()) {\n       checks.add(checkShadowVars);\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new VarCheck(compiler);\n+    }\n+  };\n+\n+  /** Checks for RegExp references. */\n+  private final PassFactory checkRegExp =\n+      new PassFactory(\"checkRegExp\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      final CheckRegExp pass = new CheckRegExp(compiler);\n+\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node root) {\n+          pass.process(externs, root);\n+          compiler.setHasRegExpGlobalReferences(\n+              pass.isGlobalRegExpPropertiesUsed());\n+        }\n+      };\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   // A bit a hack to display the available groups on the command-line.\n   // New groups should be added to this list if they are public and should\n   // be listed on the command-line as an available option.\n-  static final String DIAGNOSTIC_GROUP_NAMES = \"accessControls, checkVars, \" +\n-      \"checkTypes, deprecated, fileoverviewTags, invalidCasts, \" +\n+  static final String DIAGNOSTIC_GROUP_NAMES = \"accessControls, checkRegExp,\" +\n+      \"checkTypes, checkVars, deprecated, fileoverviewTags, invalidCasts, \" +\n       \"missingProperties, nonStandardJsDocs, strictModuleDepCheck, \" +\n       \"undefinedVars, unknownDefines, visibility\";\n \n       DiagnosticGroups.registerGroup(\"undefinedVars\",\n           new DiagnosticGroup(VarCheck.UNDEFINED_VAR_ERROR));\n \n-  public static DiagnosticGroup CHECK_VARIABLES =\n-      DiagnosticGroups.registerGroup(\"checkVars\",\n-          new DiagnosticGroup(\n-              VarCheck.UNDEFINED_VAR_ERROR,\n-              SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n+  public static DiagnosticGroup CHECK_REGEXP =\n+    DiagnosticGroups.registerGroup(\"checkRegExp\",\n+        new DiagnosticGroup(\n+            CheckRegExp.REGEXP_REFERENCE));\n \n   public static DiagnosticGroup CHECK_TYPES =\n       DiagnosticGroups.registerGroup(\"checkTypes\",\n           new DiagnosticGroup(\n               TypeValidator.ALL_DIAGNOSTICS,\n               TypeCheck.ALL_DIAGNOSTICS));\n+\n+  public static DiagnosticGroup CHECK_VARIABLES =\n+    DiagnosticGroups.registerGroup(\"checkVars\",\n+        new DiagnosticGroup(\n+            VarCheck.UNDEFINED_VAR_ERROR,\n+            SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n \n   /**\n    * Adds warning levels by name.\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   private List<Candidate> candidates;\n   private MustBeReachingVariableDef reachingDef;\n   private MaybeReachingVariableUse reachingUses;\n+\n+  private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n+    new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node n) {\n+        // When the node is null it means, we reached the implicit return\n+        // where the function returns (possibly without an return statement)\n+        if (n == null) {\n+          return false;\n+        }\n+\n+        // TODO(user): We only care about calls to functions that\n+        // passes one of the dependent variable to a non-sideeffect free\n+        // function.\n+        if (NodeUtil.isCall(n) && NodeUtil.functionCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        if (NodeUtil.isNew(n) && NodeUtil.constructorCallHasSideEffects(n)) {\n+          return true;\n+        }\n+\n+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+  };\n \n   public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n     this.compiler = compiler;\n       // Check that the assignment isn't used as a R-Value.\n       // TODO(user): Certain cases we can still inline.\n       if (NodeUtil.isAssign(def) && !NodeUtil.isExprAssign(def.getParent())) {\n+        return false;\n+      }\n+\n+\n+      // The right of the definition has side effect:\n+      // Example, for x:\n+      // x = readProp(b), modifyProp(b); print(x);\n+      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar check as the above but this time, all the sub-expressions\n+      // left of the use of the variable.\n+      // x = readProp(b); modifyProp(b), print(x);\n+      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+      }\n+\n+      // Similar side effect check as above but this time the side effect is\n+      // else where along the path.\n+      // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+      CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n+        pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n+               cfg,\n+               cfg.getDirectedGraphNode(defCfgNode),\n+               cfg.getDirectedGraphNode(useCfgNode),\n+               SIDE_EFFECT_PREDICATE,\n+               Predicates.\n+                   <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+               false);\n+      if (pathCheck.somePathsSatisfyPredicate()) {\n         return false;\n       }\n \n       NodeTraversal.traverse(compiler, n, gatherCb);\n     }\n   }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the right of n.\n+   *\n+   * Example:\n+   *\n+   * NotChecked(), NotChecked(), n, Checked(), Checked();\n+   */\n+  private static boolean checkRightOf(\n+      Node n, Node expressionRoot, Predicate<Node> predicate) {\n+    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n+      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Given an expression by its root and sub-expression n, return true if there\n+   * the predicate is true for some expression on the left of n.\n+   *\n+   * Example:\n+   *\n+   * Checked(), Checked(), n, NotChecked(), NotChecked();\n+   */\n+  private static boolean checkLeftOf(\n+      Node n, Node expressionRoot, Predicate<Node> predicate) {\n+    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n+      for (Node cur = p.getParent().getFirstChild(); cur != p;\n+          cur = cur.getNext()) {\n+        if (predicate.apply(cur)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n   @Override\n   void add(Node n, Context context) {\n     Node parent = n.getParent();\n-    if (parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT) {\n+    if (parent != null \n+        && (parent.getType() == Token.BLOCK\n+            || parent.getType() == Token.SCRIPT)) {\n       if (n.getType() == Token.FUNCTION) {\n         add(getFunctionAnnotation(n));\n       } else if (n.getType() == Token.EXPR_RESULT\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class CheckRegExpTest extends CompilerTestCase {\n+  CheckRegExp last = null;\n+\n+  public CheckRegExpTest() {\n+    super(\"var RegExp;\", true);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    compiler.options.setWarningLevel(\n+        DiagnosticGroups.CHECK_REGEXP, CheckLevel.WARNING);\n+    last = new CheckRegExp(compiler);\n+    return last;\n+  }\n+\n+  private void testReference(String code, boolean expected) {\n+    testSame(code, (expected) ? CheckRegExp.REGEXP_REFERENCE : null);\n+    assertEquals(expected, last.isGlobalRegExpPropertiesUsed());\n+  }\n+\n+  public void testRegExp() {\n+    // creating regexp's is ok\n+    testReference(\"new RegExp();\", false);\n+    testReference(\"var x = new RegExp();\", false);\n+\n+    // Any other reference isn't\n+    testReference(\"RegExp.test();\", true);\n+    testReference(\"var x = RegExp.test();\", true);\n+    testReference(\"RegExp.exec();\", true);\n+    testReference(\"RegExp.$1;\", true);\n+    testReference(\"RegExp.foobar;\", true);\n+\n+    // Aliases aren't allowed\n+    testReference(\"var x = RegExp;\", true);\n+    testReference(\"var x = RegExp; x.test()\", true);\n+\n+    // No RegExp reference is ok\n+    testReference(\"var x;\", false);\n+    \n+    // Local RegExp is ok\n+    testReference(\"function f() {var RegExp; RegExp.test();}\", false);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.Node;\n+\n /**\n  * Unit tests for {@link FlowSensitiveInlineVariables}.\n  *\n *\n  */\n public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {\n+\n+  public static final String EXTERN_FUNCTIONS = \"\" +\n+      \"/** @nosideeffects */ function noSFX() {} \\n\" +\n+      \"                      function hasSFX() {} \\n\";\n+\n   @Override\n   public int getNumRepetitions() {\n     // Test repeatedly inline.\n   }\n \n   @Override\n-  protected CompilerPass getProcessor(Compiler compiler) {\n-    return new FlowSensitiveInlineVariables(compiler);\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    //return new FlowSensitiveInlineVariables(compiler);\n+    return new CompilerPass() {\n+      @Override\n+      public void process(Node externs, Node root) {\n+        (new MarkNoSideEffectCalls(compiler)).process(externs, root);\n+        (new FlowSensitiveInlineVariables(compiler)).process(externs, root);\n+      }\n+    };\n   }\n \n   public void testSimpleAssign() {\n \n   public void testMultiUseInTwoDifferentPath() {\n     noInline(\"var x = 1; if (print) { print(x) } else { alert(x) }\");\n+  }\n+\n+  public void testAssignmentBeforeDefinition() {\n+    inline(\"x = 1; var x = 0; print(x)\",\"x = 1; var x; print(0)\" );\n   }\n \n   public void testVarInConditionPath() {\n     noInline(\"var x = new Iterator(); x.next();\");\n   }\n \n+  // TODO(user): These should be inlinable.\n   public void testNoInlineArrayLits() {\n     noInline(\"var x = []; print(x)\");\n   }\n   public void testInlineConstructorCallsIntoLoop() {\n     // Is a bad idea, a similar case was found in closure string.js\n     noInline(\"var x = new Iterator();\" +\n-             \"for(var x = 0; x < 10; x++) {j = x.next()};\");\n+             \"for(i = 0; i < 10; i++) {j = x.next()}\");\n   }\n \n   public void testRemoveWithLabels() {\n     inline(\"var x = 1; L: M: N: x = 2; print(x)\", \"var x = 1; print(2)\");\n   }\n \n+  public void testInlineAcrossSideEffect1() {\n+    inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n+  }\n+\n+  public void testInlineAcrossSideEffect2() {\n+    // Think noSFX() as a function that reads y.foo and return it\n+    // and SFX() write some new value of y.foo. If that's the case,\n+    // inlining across hasSFX() is not valid.\n+\n+    // This is a case where hasSFX is right of the source of the inlining.\n+    noInline(\"var y; var x = noSFX(y), z = hasSFX(y); print(x)\");\n+    noInline(\"var y; var x = noSFX(y), z = new hasSFX(y); print(x)\");\n+    noInline(\"var y; var x = new noSFX(y), z = new hasSFX(y); print(x)\");\n+  }\n+\n+  public void testInlineAcrossSideEffect3() {\n+    // This is a case where hasSFX is left of the destination of the inlining.\n+    noInline(\"var y; var x = noSFX(y); hasSFX(y), print(x)\");\n+    noInline(\"var y; var x = noSFX(y); new hasSFX(y), print(x)\");\n+    noInline(\"var y; var x = new noSFX(y); new hasSFX(y), print(x)\");\n+  }\n+\n+  public void testInlineAcrossSideEffect4() {\n+    // This is a case where hasSFX is some control flow path between the\n+    // source and its destination.\n+    noInline(\"var y; var x = noSFX(y); hasSFX(y); print(x)\");\n+    noInline(\"var y; var x = noSFX(y); new hasSFX(y); print(x)\");\n+    noInline(\"var y; var x = new noSFX(y); new hasSFX(y); print(x)\");\n+  }\n+\n+  public void testCanInlineAcrossNoSideEffect() {\n+    inline(\"var y; var x = noSFX(Y), z = noSFX(); noSFX(); noSFX(), print(x)\",\n+           \"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(Y))\");\n+  }\n+\n   public void testInlineArguments() {\n     testSame(\"function _func(x) { print(x) }\");\n     testSame(\"function _func(x,y) { if(y) { x = 1 }; print(x) }\");\n   }\n \n   private void inline(String input, String expected) {\n-    test(\"function _func() {\" + input + \"}\",\n-        \"function _func() {\" + expected + \"}\");\n+    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n+        \"function _func() {\" + expected + \"}\", null, null);\n   }\n }", "timestamp": 1270822913, "metainfo": ""}