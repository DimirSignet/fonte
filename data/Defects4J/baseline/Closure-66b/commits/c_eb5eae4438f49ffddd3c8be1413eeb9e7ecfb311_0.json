{"sha": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311", "log": "Change on 2010/04/26 by nick          forbid getters and setters. fixes closure-compiler issue 154.          R=robert         DELTA=57  (55 added, 0 deleted, 2 changed)  Change on 2010/04/26 by nick          create a helper method for getting the transitive closure of a         number of roots.          R=alan         DELTA=172  (168 added, 2 deleted, 2 changed)  Change on 2010/04/26 by nick          create a new mechanism for type name resolution.          R=john         DELTA=222  (210 added, 5 deleted, 7 changed)  Change on 2010/04/27 by john          Remove unused variables in uncalled global functions when not removing         unused global names. Fixes issue 155.          R=nick         DELTA=42  (34 added, 3 deleted, 5 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=aepekd   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public String getDelegateSuperclassName();\n \n   /**\n-   * Defines the delegate proxy properties. Their types depend on properties of\n-   * the delegate base methods.\n-   *\n-   * @param delegateProxyMap Map from delegate proxy prototype to delegate base\n-   *     constructor.\n-   */\n-  public void defineDelegateProxyProperties(\n+   * Defines the delegate proxy prototype properties. Their types depend on \n+   * properties of the delegate base methods.\n+   *\n+   * @param delegateProxyPrototypes List of delegate proxy prototypes.\n+   */\n+  public void defineDelegateProxyPrototypeProperties(\n       JSTypeRegistry registry, Scope scope,\n-      Map<ObjectType, FunctionType> delegateProxyMap);\n+      List<ObjectType> delegateProxyPrototypes);\n \n   /**\n    * Gets the name of the global object.\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n-  public void defineDelegateProxyProperties(\n+  public void defineDelegateProxyPrototypeProperties(\n       JSTypeRegistry registry, Scope scope,\n-      Map<ObjectType, FunctionType> delegateProxyMap) {\n+      List<ObjectType> delegateProxyPrototypes) {\n     // do nothing.\n   }\n \n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       case Token.FUNCTION:\n         // If it's an exported function, or an function expression, assume\n         // that it'll be called.\n-        if (NodeUtil.isFunctionExpression(n) ||\n-            compiler_.getCodingConvention().isExported(\n-                n.getFirstChild().getString())) {\n+        if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {\n           traverseFunction(n, scope);\n         }\n         return;\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n       traverseNode(c, n, scope);\n     }\n+  }\n+\n+  /**\n+   * @param n The function node.\n+   * @return Whether the function is exported.\n+   */\n+  private boolean isExportedFunction(Node n, Scope scope) {\n+    Preconditions.checkState(NodeUtil.isFunctionDeclaration(n));\n+    // If we aren't removing global names, assume that all global functions\n+    // are exported.\n+    return (!removeGlobals && scope.isGlobal()) || \n+        compiler_.getCodingConvention().isExported(\n+           n.getFirstChild().getString());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n \n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n \n import javax.annotation.Nullable;\n \n   private final TypeValidator validator;\n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n-  private Map<ObjectType, FunctionType> delegateProxyMap = Maps.newHashMap();\n+  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n \n   /**\n    * Defer attachment of types to nodes until all type names\n         }\n       }\n \n-      codingConvention.defineDelegateProxyProperties(\n-          typeRegistry, newScope, delegateProxyMap);\n+      codingConvention.defineDelegateProxyPrototypeProperties(\n+          typeRegistry, newScope, delegateProxyPrototypes);\n     } else {\n       newScope = new Scope(parent, root);\n       LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);\n           codingConvention.applyDelegateRelationship(\n               delegateSuperObject, delegateBaseObject, delegatorObject,\n               delegateProxy, findDelegate);\n-          delegateProxyMap.put(delegateProxy.getPrototype(), delegateBaseCtor);\n+          delegateProxyPrototypes.add(delegateProxy.getPrototype());\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n \n package com.google.javascript.jscomp.deps;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.HashMultiset;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Multimaps;\n import com.google.common.collect.Multiset;\n+import com.google.common.collect.Sets;\n \n+import java.util.ArrayDeque;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Map;\n import java.util.PriorityQueue;\n+import java.util.Set;\n \n /**\n  * A sorted list of inputs with dependency information. Uses a stable\n   // A list of all the inputs that do not have provides.\n   private final List<INPUT> noProvides;\n \n+  private final Map<String, INPUT> provideMap = Maps.newHashMap();\n+\n   public SortedDependencies(List<INPUT> inputs) {\n     this.inputs = Lists.newArrayList(inputs);\n-\n-    final Map<String, INPUT> provides = Maps.newHashMap();\n     noProvides = Lists.newArrayList();\n \n     // Collect all symbols provided in these files.\n       }\n \n       for (String provide : currentProvides) {\n-        provides.put(provide, input);\n+        provideMap.put(provide, input);\n       }\n     }\n \n     final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n     for (INPUT input : inputs) {\n       for (String req : input.getRequires()) {\n-        INPUT dep = provides.get(req);\n+        INPUT dep = provideMap.get(req);\n         if (dep != null) {\n           deps.put(input, dep);\n         }\n \n   public List<INPUT> getSortedList() {\n     return Collections.<INPUT>unmodifiableList(sortedList);\n+  }\n+\n+  /**\n+   * Gets all the dependencies of the given roots. The inputs must be returned\n+   * in a stable order. In other words, if A comes before B, and A does not\n+   * transitively depend on B, then A must also come before B in the returned\n+   * list.\n+   */\n+  public List<INPUT> getSortedDependenciesOf(List<INPUT> roots) {\n+    Preconditions.checkArgument(inputs.containsAll(roots));\n+    Set<INPUT> included = Sets.newHashSet();\n+    Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots);\n+    while (!worklist.isEmpty()) {\n+      INPUT current = worklist.pop();\n+      if (included.add(current)) {\n+        for (String req : current.getRequires()) {\n+          INPUT dep = provideMap.get(req);\n+          if (dep != null) {\n+            worklist.add(dep);\n+          }\n+        }\n+      }\n+    }\n+\n+    ImmutableList.Builder builder = ImmutableList.builder();\n+    for (INPUT current : sortedList) {\n+      if (included.contains(current)) {\n+        builder.add(current);\n+      }\n+    }\n+    return builder.build();\n   }\n \n   public List<INPUT> getInputsWithoutProvides() {\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n       Node node = new Node(Token.OBJECTLIT);\n       for (ObjectProperty el : literalNode.getElements()) {\n-        node.addChildToBack(transformAsString(el.getLeft()));\n-        node.addChildToBack(transform(el.getRight()));\n+        if (el.isGetter()) {\n+          reportGetter(el);\n+        } else if (el.isSetter()) {\n+          reportSetter(el);\n+        } else {\n+          node.addChildToBack(transformAsString(el.getLeft()));\n+          node.addChildToBack(transform(el.getRight()));\n+        }\n       }\n       return node;\n     }\n     void reportDestructuringAssign(AstNode node) {\n       errorReporter.error(\n           \"destructuring assignment forbidden\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+    }\n+\n+    void reportGetter(AstNode node) {\n+      errorReporter.error(\n+          \"getters are not supported in Internet Explorer\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+    }\n+\n+    void reportSetter(AstNode node) {\n+      errorReporter.error(\n+          \"setters are not supported in Internet Explorer\",\n           sourceName,\n           node.getLineno(), \"\", 0);\n     }\n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n    * Evaluates the type expression into a {@code JSType} object.\n    */\n   public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n-    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n-    if (root.getBooleanProp(Node.BRACELESS_TYPE)) {\n-      type.forgiveUnknownNames();\n-    }\n-    return type;\n+    return registry.createFromTypeNodes(root, sourceName, scope,\n+        root.getBooleanProp(Node.BRACELESS_TYPE));\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * So we shouldn't emit warnings about it. This method is how we skip\n    * those warnings.\n    */\n-  public void forgiveUnknownNames() {}\n+  void forgiveUnknownNames() {}\n \n   public boolean isNoType() {\n     return false;\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   private final boolean tolerateUndefinedValues;\n \n   /**\n+   * The type registry has three modes, which control how type ASTs are\n+   * converted to types in {@link @createFromTypeNodes}.\n+   */\n+  public static enum ResolveMode {\n+    /**\n+     * Expressions are converted into Unknown blobs that can be\n+     * resolved into complex types.\n+     */\n+    LAZY_EXPRESSIONS,\n+\n+    /**\n+     * Expressions are evaluated. If any names in the expression point to\n+     * unknown types, then we create a proxy {@code NamedType} structure\n+     * until the type can be resolved.\n+     *\n+     * This is the legacy way of resolving ways, and may not exist in the\n+     * future.\n+     */\n+    LAZY_NAMES,\n+\n+    /**\n+     * Expressions and type names are evaluated aggressively. A warning\n+     * will be emitted if a type name fails to resolve to a real type.\n+     */\n+    IMMEDIATE\n+  }\n+\n+  private ResolveMode resolveMode = ResolveMode.LAZY_NAMES;\n+\n+  /**\n    * Constructs a new type registry populated with the built-in types.\n    */\n   public JSTypeRegistry(ErrorReporter reporter) {\n     namesToTypes = new HashMap<String, JSType>();\n     resetForTypeCheck();\n     this.tolerateUndefinedValues = tolerateUndefinedValues;\n+  }\n+\n+  /**\n+   * Set the current resolving mode of the type registry.\n+   * @see ResolveMode\n+   */\n+  public void setResolveMode(ResolveMode mode) {\n+    this.resolveMode = mode;\n   }\n \n   public ErrorReporter getErrorReporter() {\n    */\n   public JSType createFromTypeNodes(Node n, String sourceName,\n       StaticScope<JSType> scope) {\n+    return createFromTypeNodes(n, sourceName, scope, false);\n+  }\n+\n+  /**\n+   * Creates a JSType from the nodes representing a type.\n+   * @param n The node with type info.\n+   * @param sourceName The source file name.\n+   * @param scope A scope for doing type name lookups.\n+   * @param forgiving Whether we should be forgiving about type names\n+   *     that we can't find.\n+   */\n+  public JSType createFromTypeNodes(Node n, String sourceName,\n+      StaticScope<JSType> scope, boolean forgiving) {\n+    if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n+      return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+    }\n+\n     switch (n.getType()) {\n       case Token.LC: // Record type.\n         return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n \n       case Token.BANG: // Not nullable\n-        return createFromTypeNodes(n.getFirstChild(), sourceName, scope)\n+        return createFromTypeNodes(\n+            n.getFirstChild(), sourceName, scope, forgiving)\n             .restrictByNotNullOrUndefined();\n \n       case Token.QMARK: // Nullable or unknown\n           return getNativeType(UNKNOWN_TYPE);\n         }\n         return createDefaultObjectUnion(\n-            createFromTypeNodes(firstChild, sourceName, scope));\n+            createFromTypeNodes(firstChild, sourceName, scope, forgiving));\n \n       case Token.EQUALS: // Optional\n         return createOptionalType(\n       case Token.STRING:\n         JSType namedType = getType(scope, n.getString(), sourceName,\n             n.getLineno(), n.getCharno());\n+        if (forgiving) {\n+          namedType.forgiveUnknownNames();\n+        }\n+        if (resolveMode != ResolveMode.LAZY_NAMES) {\n+          namedType = namedType.resolveInternal(reporter, scope);\n+        }\n         if ((namedType instanceof ObjectType) &&\n             !(enumTypeNames.contains(n.getString()))) {\n           Node typeList = n.getFirstChild();\n             }\n           }\n           return createDefaultObjectUnion(namedType);\n-\n         } else {\n           return namedType;\n         }\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n     this.charno = charno;\n   }\n \n-  @Override\n-  public void forgiveUnknownNames() {\n+  void forgiveUnknownNames() {\n     forgiving = true;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n   }\n \n   @Override\n-  public void forgiveUnknownNames() {\n+  void forgiveUnknownNames() {\n     for (JSType type : getAlternates()) {\n       type.forgiveUnknownNames();\n     }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/UnresolvedTypeExpression.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+ \n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.JSTypeExpression;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * An {@code UnresolvedType} is a reference to some type expression.\n+ * This provides a convenient mechanism for implementing forward\n+ * references to types; a {@code UnresolvedType} can be used as a\n+ * placeholder until its reference is resolved.\n+ *\n+ * The {@code UnresolvedType} will behave like an opaque unknown type.\n+ * When its {@code #resolve} method is called, it will return the underlying\n+ * type. The underlying type can resolve to any JS type.<p>\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+class UnresolvedTypeExpression extends UnknownType {\n+  private static final long serialVersionUID = 1L;\n+\n+  private final Node typeExpr;\n+  private final String sourceName;\n+\n+  /**\n+   * If true, don't warn about unresolveable type names.\n+   *\n+   * NOTE(nicksantos): A lot of third-party code doesn't use our type syntax.\n+   * They have code like\n+   * {@code @return} the bus.\n+   * and they clearly don't mean that \"the\" is a type. In these cases, we're\n+   * forgiving and try to guess whether or not \"the\" is a type when it's not\n+   * clear.\n+   */\n+  private boolean forgiving = false;\n+\n+  /**\n+   * Create a named type based on the reference.\n+   */\n+  UnresolvedTypeExpression(JSTypeRegistry registry, Node typeExpr,\n+      String sourceName, boolean forgiving) {\n+    super(registry, false);\n+\n+    Preconditions.checkNotNull(typeExpr);\n+    this.typeExpr = typeExpr;\n+    this.sourceName = sourceName;\n+    this.forgiving = forgiving;\n+  }\n+\n+  /**\n+   * Resolve the referenced type within the enclosing scope.\n+   */\n+  @Override\n+  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n+    return registry.createFromTypeNodes(typeExpr, sourceName, enclosing,\n+        forgiving);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   public void testDebugFlag1() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=false\");\n-    testSame(\"function foo(a) {}\");\n+    test(\"function foo(a) {}\", \n+         \"function foo() {}\");\n   }\n \n   public void testDebugFlag2() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=true\");\n-    test(\"function foo(a) {}\",\n-         \"function foo($a$$) {}\");\n+    test(\"function foo(a) {alert(a)}\",\n+         \"function foo($a$$) {alert($a$$)}\");\n   }\n \n   public void testDebugFlag3() {\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n \n   private boolean removeGlobal = true;\n   private boolean preserveFunctionExpressionNames = false;\n-  \n+\n   public RemoveUnusedVarsTest() {\n     super(\"\", false);\n   }\n     removeGlobal = true;\n     preserveFunctionExpressionNames = false;\n   }\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new RemoveUnusedVars(\n          \"foo(function(){})\");\n \n     preserveFunctionExpressionNames = true;\n-    testSame(\"foo(function bar(){})\");    \n+    testSame(\"foo(function bar(){})\");\n+  }\n+\n+  public void testRemoveGlobal1() {\n+    removeGlobal = false;\n+    testSame(\"var x=1\");\n+    test(\"var y=function(x){var z;}\", \"var y=function(){}\");\n+  }\n+\n+  public void testRemoveGlobal2() {\n+    removeGlobal = false;\n+    testSame(\"var x=1\");\n+    test(\"function y(x){var z;}\", \"function y(){}\");\n   }\n   \n-\n-  public void testRemoveGlobal() {\n-    removeGlobal = false;\n-    testSame(\"var x=1\");\n-    test(\"var y=function(x){var z;}\", \"var y=function(){}\");\n-  }\n+  public void testRemoveGlobal3() {\n+    removeGlobal = false;\n+    testSame(\"var x=1\");\n+    test(\"function x(){function y(x){var z;}y()}\", \n+         \"function x(){function y(){}y()}\");\n+  }\n+  \n+  public void testRemoveGlobal4() {\n+    removeGlobal = false;\n+    testSame(\"var x=1\");\n+    test(\"function x(){function y(x){var z;}}\", \n+         \"function x(){}\");\n+  }   \n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link SortedDependencies}\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class SortedDependenciesTest extends TestCase {\n+\n+  public void testSort() {\n+    SimpleDependencyInfo a = new SimpleDependencyInfo(\n+        \"a\", \"a\", symbols(), symbols(\"b\", \"c\"));\n+    SimpleDependencyInfo b = new SimpleDependencyInfo(\n+        \"b\", \"b\", symbols(\"b\"), symbols(\"d\"));\n+    SimpleDependencyInfo c = new SimpleDependencyInfo(\n+        \"c\", \"c\", symbols(\"c\"), symbols(\"d\"));\n+    SimpleDependencyInfo d = new SimpleDependencyInfo(\n+        \"d\", \"d\", symbols(\"d\"), symbols());\n+    SimpleDependencyInfo e = new SimpleDependencyInfo(\n+        \"e\", \"e\", symbols(\"e\"), symbols());\n+    SimpleDependencyInfo f = new SimpleDependencyInfo(\n+        \"f\", \"f\", symbols(\"f\"), symbols());\n+\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(a, b, c, d));\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(d, b, c, a));\n+    assertSortedInputs(\n+        ImmutableList.of(d, c, b, a),\n+        ImmutableList.of(d, c, b, a));\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(d, a, b, c));\n+\n+    assertSortedDeps(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(a));\n+    assertSortedDeps(\n+        ImmutableList.of(d, c),\n+        ImmutableList.of(d, c, b, a),\n+        ImmutableList.of(c));\n+    assertSortedDeps(\n+        ImmutableList.of(d),\n+        ImmutableList.of(d, c, b, a),\n+        ImmutableList.of(d));\n+\n+    try {\n+      assertSortedDeps(\n+          ImmutableList.<SimpleDependencyInfo>of(),\n+          ImmutableList.of(a, b, c, d),\n+          ImmutableList.of(e));\n+      fail(\"Expected an exception\");\n+    } catch (IllegalArgumentException expected) {}\n+  }\n+\n+  public void testSort2() {\n+    SimpleDependencyInfo ab = new SimpleDependencyInfo(\n+        \"ab\", \"ab\", symbols(\"a\", \"b\"), symbols(\"d\", \"f\"));\n+    SimpleDependencyInfo c = new SimpleDependencyInfo(\n+        \"c\", \"c\", symbols(\"c\"), symbols(\"h\"));\n+    SimpleDependencyInfo d = new SimpleDependencyInfo(\n+        \"d\", \"d\", symbols(\"d\"), symbols(\"e\", \"f\"));\n+    SimpleDependencyInfo ef = new SimpleDependencyInfo(\n+        \"ef\", \"ef\", symbols(\"e\", \"f\"), symbols(\"g\", \"c\"));\n+    SimpleDependencyInfo g = new SimpleDependencyInfo(\n+        \"g\", \"g\", symbols(\"g\"), symbols());\n+    SimpleDependencyInfo hi = new SimpleDependencyInfo(\n+        \"hi\", \"hi\", symbols(\"h\", \"i\"), symbols());\n+\n+    assertSortedInputs(\n+        ImmutableList.of(g, hi, c, ef, d, ab),\n+        ImmutableList.of(ab, c, d, ef, g, hi));\n+\n+    assertSortedDeps(\n+        ImmutableList.of(g),\n+        ImmutableList.of(ab, c, d, ef, g, hi),\n+        ImmutableList.of(g));\n+    assertSortedDeps(\n+        ImmutableList.of(g, hi, c, ef, d),\n+        ImmutableList.of(ab, c, d, ef, g, hi),\n+        ImmutableList.of(d, hi));\n+  }\n+\n+  private void assertSortedInputs(\n+      List<SimpleDependencyInfo> expected,\n+      List<SimpleDependencyInfo> shuffled) {\n+    SortedDependencies<SimpleDependencyInfo> sorted =\n+        new SortedDependencies<SimpleDependencyInfo>(shuffled);\n+    assertEquals(expected, sorted.getSortedList());\n+  }\n+\n+  private void assertSortedDeps(\n+      List<SimpleDependencyInfo> expected,\n+      List<SimpleDependencyInfo> shuffled,\n+      List<SimpleDependencyInfo> roots) {\n+    SortedDependencies<SimpleDependencyInfo> sorted =\n+        new SortedDependencies<SimpleDependencyInfo>(shuffled);\n+    assertEquals(expected, sorted.getSortedDependenciesOf(roots));\n+  }\n+\n+  private List<String> symbols(String ... strings) {\n+    return Lists.newArrayList(strings);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n   public void testGeneratorsForbidden() {\n     parseError(\"var i = (x for (x in obj));\",\n         \"missing ) in parenthetical\");\n+  }\n+\n+  public void testGettersForbidden1() {\n+    parseError(\"var x = {get foo() { return 3; }};\",\n+        \"getters are not supported in Internet Explorer\");\n+  }\n+\n+  public void testGettersForbidden2() {\n+    parseError(\"var x = {get foo bar() { return 3; }};\",\n+        \"invalid property id\");\n+  }\n+\n+  public void testGettersForbidden3() {\n+    parseError(\"var x = {a getter:function b() { return 3; }};\",\n+        \"missing : after property id\", \"syntax error\");\n+  }\n+\n+  public void testGettersForbidden4() {\n+    parseError(\"var x = {\\\"a\\\" getter:function b() { return 3; }};\",\n+        \"missing : after property id\", \"syntax error\");\n+  }\n+\n+  public void testGettersForbidden5() {\n+    parseError(\"var x = {a: 2, get foo() { return 3; }};\",\n+        \"getters are not supported in Internet Explorer\");\n+  }\n+\n+  public void testSettersForbidden() {\n+    parseError(\"var x = {set foo() { return 3; }};\",\n+        \"setters are not supported in Internet Explorer\");\n+  }\n+\n+  public void testSettersForbidden2() {\n+    parseError(\"var x = {a setter:function b() { return 3; }};\",\n+        \"missing : after property id\", \"syntax error\");\n   }\n \n   public void testFileOverviewJSDoc1() {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SimpleErrorReporter;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n \n import junit.framework.TestCase;\n+\n \n /**\n  * Tests {@link JSTypeRegistry}.\n     typeRegistry.resolveTypesInScope(scope);\n     assertFalse(subNamed.isUnknownType());\n   }\n+\n+  public void testTypeResolutionModes() {\n+    SimpleErrorReporter reporter = new SimpleErrorReporter();\n+\n+    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter);\n+    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n+\n+    JSTypeRegistry lazyNameRegistry = new JSTypeRegistry(reporter);\n+    lazyNameRegistry.setResolveMode(ResolveMode.LAZY_NAMES);\n+\n+    JSTypeRegistry immediateRegistry = new JSTypeRegistry(reporter);\n+    immediateRegistry.setResolveMode(ResolveMode.IMMEDIATE);\n+\n+    Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n+    StaticScope<JSType> empty = new EmptyScope();\n+\n+    JSType type = lazyExprRegistry.createFromTypeNodes(\n+        expr, \"source.js\", empty);\n+    assertTrue(type instanceof UnresolvedTypeExpression);\n+    assertTrue(type.isUnknownType());\n+    assertEquals(\"?\", type.toString());\n+    assertNull(\"Unexpected warnings: \" + reporter.warnings(),\n+        reporter.warnings());\n+\n+    type = lazyNameRegistry.createFromTypeNodes(\n+        expr, \"source.js\", empty);\n+    assertTrue(type instanceof UnionType);\n+    assertTrue(type.isUnknownType());\n+    assertEquals(\"(foo|null)\", type.toString());\n+    assertNull(\"Unexpected warnings: \" + reporter.warnings(),\n+        reporter.warnings());\n+\n+    type = immediateRegistry.createFromTypeNodes(\n+        expr, \"source.js\", empty);\n+    assertTrue(type instanceof UnknownType);\n+    assertEquals(\"Expected warnings\", 1, reporter.warnings().size());\n+  }\n+\n+  private static class EmptyScope implements StaticScope<JSType> {\n+    public StaticSlot<JSType> getSlot(final String name) { return null; }\n+    public StaticSlot<JSType> getOwnSlot(String name) { return null; }\n+    public StaticScope<JSType> getParentScope() { return null; }\n+    public JSType getTypeOfThis() { return null; }\n+  }\n }", "timestamp": 1272394949, "metainfo": ""}