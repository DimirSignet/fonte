{"sha": "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b", "log": "fix silly 2004-era naming conventions (Nick) R=john DELTA=134  (0 added, 0 deleted, 134 changed)  Insert a place holder file for any empty modules. (Alan) R=nick DELTA=53  (46 added, 6 deleted, 1 changed)  Maps API extern update. (Contributed by Chad Killingsworth) Fixes issue 121 DELTA=86  (48 added, 16 deleted, 22 changed)   Google Loader API externs. (Contributed by Chad Killingsworth) Fixes issue 126 DELTA=54  (54 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       } catch (NumberFormatException ignored) {\n         numJsFiles = -1;\n       }\n-      if (numJsFiles < 1) {\n+      \n+      // We will allow modules of zero input.\n+      if (numJsFiles < 0) {\n         throw new FlagUsageException(\"Invalid js file count '\" + parts[1]\n             + \"' for module: \" + name);\n       }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n *\n  */\n public class Compiler extends AbstractCompiler {\n-  CompilerOptions options_ = null;\n+  CompilerOptions options = null;\n \n   private PassConfig passes = null;\n \n   // The externs inputs\n-  private CompilerInput[] externs_;\n+  private CompilerInput[] externs;\n \n   // The JS source modules\n-  private JSModule[] modules_;\n+  private JSModule[] modules;\n \n   // The graph of the JS source modules\n-  private JSModuleGraph moduleGraph_;\n+  private JSModuleGraph moduleGraph;\n \n   // The JS source inputs\n-  private CompilerInput[] inputs_;\n+  private CompilerInput[] inputs;\n \n   // error manager to which error management is delegated\n   private ErrorManager errorManager;\n   Node jsRoot;\n   Node externAndJsRoot;\n \n-  private Map<String, CompilerInput> inputsByName_;\n+  private Map<String, CompilerInput> inputsByName;\n \n   /** The source code map */\n-  private SourceMap sourceMap_;\n+  private SourceMap sourceMap;\n \n   /** The externs created from the exports.  */\n-  private String externExports_ = null;\n+  private String externExports = null;\n \n   /**\n    * Ids for function inlining so that each declared name remains\n   private boolean useThreads = true;\n \n   /** The function information map */\n-  private FunctionInformationMap functionInformationMap_;\n+  private FunctionInformationMap functionInformationMap;\n \n   /** Debugging information */\n-  private final StringBuilder debugLog_ = new StringBuilder();\n+  private final StringBuilder debugLog = new StringBuilder();\n \n   /** Detects Google-specific coding conventions. */\n   CodingConvention defaultCodingConvention = new GoogleCodingConvention();\n    * setting configuration for this logger affects all loggers\n    *  in other classes within the compiler.\n    */\n-  private static final Logger logger_ =\n+  private static final Logger logger =\n       Logger.getLogger(\"com.google.javascript.jscomp\");\n \n   private final PrintStream outStream;\n    * {@link CompilerOptions}.\n    */\n   private MessageFormatter createMessageFormatter() {\n-    boolean colorize = options_.shouldColorizeErrorOutput();\n-    return options_.errorFormat.toFormatter(this, colorize);\n+    boolean colorize = options.shouldColorizeErrorOutput();\n+    return options.errorFormat.toFormatter(this, colorize);\n   }\n \n   /**\n    * a normal compile() job.\n    */\n   public void initOptions(CompilerOptions options) {\n-    options_ = options;\n+    this.options = options;\n     if (errorManager == null) {\n       if (outStream == null) {\n         setErrorManager(\n-            new LoggerErrorManager(createMessageFormatter(), logger_));\n+            new LoggerErrorManager(createMessageFormatter(), logger));\n       } else {\n         PrintStreamErrorManager printer =\n             new PrintStreamErrorManager(createMessageFormatter(), outStream);\n-        printer.setSummaryDetailLevel(options_.summaryDetailLevel);\n+        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n         setErrorManager(printer);\n       }\n     }\n       CompilerOptions options) {\n     initOptions(options);\n     \n-    externs_ = makeCompilerInput(externs, true);\n-    modules_ = null;\n-    moduleGraph_ = null;\n-    inputs_ = makeCompilerInput(inputs, false);\n+    this.externs = makeCompilerInput(externs, true);\n+    this.modules = null;\n+    this.moduleGraph = null;\n+    this.inputs = makeCompilerInput(inputs, false);\n     initBasedOnOptions();\n \n     initInputsByNameMap();\n     initOptions(options);\n \n     checkFirstModule(modules);\n-\n-    externs_ = makeCompilerInput(externs, true);\n-    modules_ = modules;\n+    fillEmptyModules(modules);\n+\n+    this.externs = makeCompilerInput(externs, true);\n+    this.modules = modules;\n     // Generate the module graph, and report any errors in the module\n     // specification as errors.\n     try {\n-      moduleGraph_ = new JSModuleGraph(modules);\n+      this.moduleGraph = new JSModuleGraph(modules);\n     } catch (JSModuleGraph.ModuleDependenceException e) {\n       // problems with the module format.  Report as an error.  The\n       // message gives all details.\n           e.getModule().getName(), e.getDependentModule().getName()));\n       return;\n     }\n-    inputs_ = getAllInputsFromModules();\n+    this.inputs = getAllInputsFromModules();\n     initBasedOnOptions();\n \n     initInputsByNameMap();\n    */\n   private void initBasedOnOptions() {\n     // Create the source map if necessary.\n-    if (options_.sourceMapOutputPath != null) {\n-      sourceMap_ = new SourceMap();\n+    if (options.sourceMapOutputPath != null) {\n+      sourceMap = new SourceMap();\n     }\n   }\n \n           modules[0].getName()));\n     }\n   }\n-\n+  \n+  /**\n+   * Fill any empty modules with a place holder file. It makes any cross module\n+   * motion easier.\n+   */\n+  private void fillEmptyModules(JSModule[] modules) {\n+    for (int i = 1; i < modules.length; i ++) {\n+      JSModule module = modules[i];\n+      if (module.getInputs().isEmpty()) {\n+        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n+      }\n+    }\n+  }\n+  \n   static final DiagnosticType DUPLICATE_INPUT_IN_MODULES =\n       DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\",\n           \"Two modules cannot contain the same input, but module {0} and {1} \"\n    * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n    */\n   public void rebuildInputsFromModules() {\n-    inputs_ = getAllInputsFromModules();\n+    inputs = getAllInputsFromModules();\n     initInputsByNameMap();\n   }\n \n   private CompilerInput[] getAllInputsFromModules() {\n     List<CompilerInput> inputs = new ArrayList<CompilerInput>();\n     Map<String, JSModule> inputMap = new HashMap<String, JSModule>();\n-    for (JSModule module : modules_) {\n+    for (JSModule module : modules) {\n       for (CompilerInput input : module.getInputs()) {\n         String inputName = input.getName();\n         JSModule firstModule = inputMap.get(inputName);\n    * duplicate inputs.\n    */\n   void initInputsByNameMap() {\n-    inputsByName_ = new HashMap<String, CompilerInput>();\n-    for (CompilerInput input : externs_) {\n+    inputsByName = new HashMap<String, CompilerInput>();\n+    for (CompilerInput input : externs) {\n       String name = input.getName();\n-      if (!inputsByName_.containsKey(name)) {\n-        inputsByName_.put(name, input);\n+      if (!inputsByName.containsKey(name)) {\n+        inputsByName.put(name, input);\n       } else {\n         report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n       }\n     }\n-    for (CompilerInput input : inputs_) {\n+    for (CompilerInput input : inputs) {\n       String name = input.getName();\n-      if (!inputsByName_.containsKey(name)) {\n-        inputsByName_.put(name, input);\n+      if (!inputsByName.containsKey(name)) {\n+        inputsByName.put(name, input);\n       } else {\n         report(JSError.make(DUPLICATE_INPUT, name));\n       }\n     // increase the stack size for *every* thread (which is what -Xss does).\n     // Might want to add thread pool support for clients that compile a lot.\n \n-    final boolean dumpTraceReport = options_.tracer.isOn();\n+    final boolean dumpTraceReport = options.tracer.isOn();\n     final Object[] result = new Object[1];\n     final Throwable[] exception = new Throwable[1];\n     Runnable runnable = new Runnable() {\n       return;\n     }\n \n-    if (options_.nameAnonymousFunctionsOnly) {\n+    if (options.nameAnonymousFunctionsOnly) {\n       // TODO(nicksantos): Move this into an instrument() phase maybe?\n       check();\n       return;\n     }\n \n-    if (!options_.skipAllPasses) {\n+    if (!options.skipAllPasses) {\n       check();\n       if (hasErrors()) {\n         return;\n       }\n \n-      if (options_.externExportsPath != null) {\n+      if (options.externExportsPath != null) {\n         externExports();\n       }\n \n       // IDE-mode is defined to stop here, before the heavy rewriting begins.\n-      if (!options_.ideMode) {\n+      if (!options.ideMode) {\n         optimize();\n       }\n     }\n \n-    if (options_.recordFunctionInformation) {\n+    if (options.recordFunctionInformation) {\n       recordFunctionInformation();\n     }\n \n-    if (options_.devMode == DevMode.START_AND_END) {\n+    if (options.devMode == DevMode.START_AND_END) {\n       runSanityCheck();\n     }\n   }\n    * overriding this.\n    */\n   PassConfig createPassConfigInternal() {\n-    return new DefaultPassConfig(options_);\n+    return new DefaultPassConfig(options);\n   }\n \n   /**\n     runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n \n     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n-    if (options_.devMode == DevMode.EVERY_PASS) {\n+    if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     phaseOptimizer.consume(getPassConfig().getChecks());\n     }\n \n     // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n-    if (options_.nameAnonymousFunctionsOnly) {\n+    if (options.nameAnonymousFunctionsOnly) {\n       return;\n     }\n \n-    if (options_.removeTryCatchFinally) {\n+    if (options.removeTryCatchFinally) {\n       removeTryCatchFinally();\n     }\n \n-    if (!options_.stripTypes.isEmpty() ||\n-        !options_.stripNameSuffixes.isEmpty() ||\n-        !options_.stripTypePrefixes.isEmpty() ||\n-        !options_.stripNamePrefixes.isEmpty()) {\n-      stripCode(options_.stripTypes, options_.stripNameSuffixes,\n-          options_.stripTypePrefixes, options_.stripNamePrefixes);\n+    if (!options.stripTypes.isEmpty() ||\n+        !options.stripNameSuffixes.isEmpty() ||\n+        !options.stripTypePrefixes.isEmpty() ||\n+        !options.stripNamePrefixes.isEmpty()) {\n+      stripCode(options.stripTypes, options.stripNameSuffixes,\n+          options.stripTypePrefixes, options.stripNamePrefixes);\n     }\n \n     runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n   }\n \n   private void externExports() {\n-    logger_.info(\"Creating extern file for exports\");\n+    logger.info(\"Creating extern file for exports\");\n     startPass(\"externExports\");\n \n     ExternExportsPass pass = new ExternExportsPass(this);\n     process(pass);\n \n-    externExports_ = pass.getGeneratedExterns();\n+    externExports = pass.getGeneratedExterns();\n \n     endPass();\n   }\n   };\n \n   private void maybeSanityCheck() {\n-    if (options_.devMode == DevMode.EVERY_PASS) {\n+    if (options.devMode == DevMode.EVERY_PASS) {\n       runSanityCheck();\n     }\n   }\n    * Removes try/catch/finally statements for easier debugging.\n    */\n   void removeTryCatchFinally() {\n-    logger_.info(\"Remove try/catch/finally\");\n+    logger.info(\"Remove try/catch/finally\");\n     startPass(\"removeTryCatchFinally\");\n     RemoveTryCatch r = new RemoveTryCatch(this);\n     process(r);\n    */\n   void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n       Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n-    logger_.info(\"Strip code\");\n+    logger.info(\"Strip code\");\n     startPass(\"stripCode\");\n     StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n         stripTypePrefixes, stripNamePrefixes);\n    * Runs custom passes that are designated to run at a particular time.\n    */\n   private void runCustomPasses(CustomPassExecutionTime executionTime) {\n-    if (options_.customPasses != null) {\n+    if (options.customPasses != null) {\n       Tracer t = newTracer(\"runCustomPasses\");\n       try {\n-        for (CompilerPass p : options_.customPasses.get(executionTime)) {\n+        for (CompilerPass p : options.customPasses.get(executionTime)) {\n           process(p);\n         }\n       } finally {\n   Tracer newTracer(String passName) {\n     String comment = passName\n         + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker.recordPassStart(passName);\n     }\n     return new Tracer(\"Compiler\", comment);\n \n   void stopTracer(Tracer t, String passName) {\n     long result = t.stop();\n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker.recordPassStop(passName, result);\n     }\n   }\n    */\n   public Result getResult() {\n     PassConfig.State state = getPassConfig().getIntermediateState();\n-    return new Result(getErrors(), getWarnings(), debugLog_.toString(),\n+    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n         state.variableMap, state.propertyMap,\n-        state.anonymousFunctionNameMap, functionInformationMap_,\n-        sourceMap_, externExports_, state.cssNames);\n+        state.anonymousFunctionNameMap, functionInformationMap,\n+        sourceMap, externExports, state.cssNames);\n   }\n \n   /**\n \n   @Override\n   boolean areNodesEqualForInlining(Node n1, Node n2) {\n-    if (options_.ambiguateProperties ||\n-        options_.disambiguateProperties) {\n+    if (options.ambiguateProperties ||\n+        options.disambiguateProperties) {\n       // The type based optimizations require that type information is preserved\n       // during other optimizations.\n       return n1.checkTreeTypeAwareEqualsSilent(n2);\n \n   @Override\n   public CompilerInput getInput(String name) {\n-    return inputsByName_.get(name);\n+    return inputsByName.get(name);\n   }\n \n   @Override\n   public CompilerInput newExternInput(String name) {\n-    if (inputsByName_.containsKey(name)) {\n+    if (inputsByName.containsKey(name)) {\n       throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n     }\n     SourceAst ast = new SyntheticAst(name);\n     CompilerInput input = new CompilerInput(ast, name, true);\n-    inputsByName_.put(name, input);\n+    inputsByName.put(name, input);\n     externsRoot.addChildToFront(ast.getAstRoot(this));\n     return input;\n   }\n     Preconditions.checkState(\n         getInput(sourceName) == null,\n         \"Duplicate input of name \" + sourceName);\n-    inputsByName_.put(sourceName, new CompilerInput(ast));\n+    inputsByName.put(sourceName, new CompilerInput(ast));\n   }\n \n   @Override\n   JSModuleGraph getModuleGraph() {\n-    return moduleGraph_;\n+    return moduleGraph;\n   }\n \n   @Override\n       ChainableReverseAbstractInterpreter interpreter =\n           new SemanticReverseAbstractInterpreter(\n               getCodingConvention(), getTypeRegistry());\n-      if (options_.closurePass) {\n+      if (options.closurePass) {\n         interpreter = new ClosureReverseAbstractInterpreter(\n             getCodingConvention(), getTypeRegistry())\n             .append(interpreter).getFirst();\n    *     and the main root\n    */\n   Node parseInputs() {\n-    boolean devMode = options_.devMode != DevMode.OFF;\n+    boolean devMode = options.devMode != DevMode.OFF;\n \n     // If old roots exist (we are parsing a second time), detach each of the\n     // individual file parse trees.\n     jsRoot = new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n \n-    if (options_.tracer.isOn()) {\n+    if (options.tracer.isOn()) {\n       tracker = new PerformanceTracker(jsRoot,\n-          options_.tracer == TracerMode.ALL);\n+          options.tracer == TracerMode.ALL);\n       addChangeHandler(tracker.getCodeChangeHandler());\n     }\n \n       // Parse externs sources.\n       externsRoot = new Node(Token.BLOCK);\n       externsRoot.setIsSyntheticBlock(true);\n-      for (CompilerInput input : externs_) {\n+      for (CompilerInput input : externs) {\n         Node n = input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n         externsRoot.addChildToBack(n);\n       }\n \n-      for (CompilerInput input : inputs_) {\n+      for (CompilerInput input : inputs) {\n         Node n = input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n           }\n         }\n \n-        if (options_.sourceMapOutputPath != null ||\n-            options_.nameReferenceReportPath != null) {\n+        if (options.sourceMapOutputPath != null ||\n+            options.nameReferenceReportPath != null) {\n \n           // Annotate the nodes in the tree with information from the\n           // input file. This information is used to construct the SourceMap.\n   Node parseSyntheticCode(String js) {\n     CompilerInput input = new CompilerInput(\n         JSSourceFile.fromCode(\" [synthetic] \", js));\n-    inputsByName_.put(input.getName(), input);\n+    inputsByName.put(input.getName(), input);\n     return input.getAstRoot(this);\n   }\n \n   void initCompilerOptionsIfTesting() {\n-    if (options_ == null) {\n+    if (options == null) {\n       // initialization for tests that don't initialize the compiler\n       // by the normal mechanisms.\n       initOptions(new CompilerOptions());\n     initCompilerOptionsIfTesting();\n     CompilerInput input = new CompilerInput(\n         JSSourceFile.fromCode(\" [testcode] \", js));\n-    if (inputsByName_ == null) {\n-      inputsByName_ = Maps.newHashMap();\n-    }\n-    inputsByName_.put(input.getName(), input);\n+    if (inputsByName == null) {\n+      inputsByName = Maps.newHashMap();\n+    }\n+    inputsByName.put(input.getName(), input);\n     return input.getAstRoot(this);\n   }\n \n       public String[] call() throws Exception {\n         Tracer tracer = newTracer(\"toSourceArray\");\n         try {\n-          int numInputs = inputs_.length;\n+          int numInputs = inputs.length;\n           String[] sources = new String[numInputs];\n           CodeBuilder cb = new CodeBuilder();\n           for (int i = 0; i < numInputs; i++) {\n-            Node scriptNode = inputs_[i].getAstRoot(Compiler.this);\n+            Node scriptNode = inputs[i].getAstRoot(Compiler.this);\n             cb.reset();\n             toSource(cb, i, scriptNode);\n             sources[i] = cb.toString();\n                        final Node root) {\n     runInCompilerThread(new Callable<Void>() {\n       public Void call() throws Exception {\n-        if (options_.printInputDelimiter) {\n+        if (options.printInputDelimiter) {\n           if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n             cb.append(\"\\n\");  // Make sure that the label starts on a new line\n           }\n           Preconditions.checkState(root.getType() == Token.SCRIPT);\n           \n-          String delimiter = options_.inputDelimiter;\n+          String delimiter = options.inputDelimiter;\n           \n           String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n           Preconditions.checkState(sourceName != null);\n \n         // If there is a valid source map, then indicate to it that the current\n         // root node's mappings are offset by the given string builder buffer.\n-        if (options_.sourceMapOutputPath != null) {\n-          sourceMap_.setStartingPosition(\n+        if (options.sourceMapOutputPath != null) {\n+          sourceMap.setStartingPosition(\n               cb.getLineIndex(), cb.getColumnIndex());\n         }\n \n     initCompilerOptionsIfTesting();\n     \n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n-    builder.setPrettyPrint(options_.prettyPrint);\n-    builder.setLineBreak(options_.lineBreak);\n-    builder.setSourceMap(sourceMap_);\n-    builder.setOutputCharset(options_.outputCharset);\n+    builder.setPrettyPrint(options.prettyPrint);\n+    builder.setLineBreak(options.lineBreak);\n+    builder.setSourceMap(sourceMap);\n+    builder.setOutputCharset(options.outputCharset);\n     return builder.build();\n   }\n \n \n   public void optimize() {\n     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n-    if (options_.devMode == DevMode.EVERY_PASS) {\n+    if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     phaseOptimizer.consume(getPassConfig().getOptimizations());\n \n   @Override\n   void setCssRenamingMap(CssRenamingMap map) {\n-    options_.cssRenamingMap = map;\n+    options.cssRenamingMap = map;\n   }\n \n   @Override\n   CssRenamingMap getCssRenamingMap() {\n-    return options_.cssRenamingMap;\n+    return options.cssRenamingMap;\n   }\n \n   /**\n    * specifically for that target.\n    */\n   public void processDefines() {\n-    (new DefaultPassConfig(options_)).processDefines.create(this)\n+    (new DefaultPassConfig(options)).processDefines.create(this)\n         .process(externsRoot, jsRoot);\n   }\n \n   boolean isInliningForbidden() {\n-    return options_.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n-        options_.propertyRenaming ==\n+    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n+        options.propertyRenaming ==\n             PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n   }\n \n   /** Control Flow Analysis. */\n   ControlFlowGraph<Node> computeCFG() {\n-    logger_.info(\"Computing Control Flow Graph\");\n+    logger.info(\"Computing Control Flow Graph\");\n     Tracer tracer = newTracer(\"computeCFG\");\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);\n     process(cfa);\n   }\n \n   public void normalize() {\n-    logger_.info(\"Normalizing\");\n+    logger.info(\"Normalizing\");\n     startPass(\"normalize\");\n     process(new Normalize(this, false));\n     setNormalized();\n   }\n \n   void recordFunctionInformation() {\n-    logger_.info(\"Recording function information\");\n+    logger.info(\"Recording function information\");\n     startPass(\"recordFunctionInformation\");\n     RecordFunctionInformation recordFunctionInfoPass =\n         new RecordFunctionInformation(\n             this, getPassConfig().getIntermediateState().functionNames);\n     process(recordFunctionInfoPass);\n-    functionInformationMap_ = recordFunctionInfoPass.getMap();\n+    functionInformationMap = recordFunctionInfoPass.getMap();\n     endPass();\n   }\n \n \n   @Override\n   public CodingConvention getCodingConvention() {\n-    CodingConvention convention = options_.getCodingConvention();\n+    CodingConvention convention = options.getCodingConvention();\n     convention = convention != null ? convention : defaultCodingConvention;\n     return convention;\n   }\n \n   @Override\n   public boolean isIdeMode() {\n-    return options_.ideMode;\n+    return options.ideMode;\n   }\n \n   @Override\n \n   @Override\n   public boolean isTypeCheckingEnabled() {\n-    return options_.checkTypes;\n+    return options.checkTypes;\n   }\n \n \n   @Override\n   public void report(JSError error) {\n     CheckLevel level = error.level;\n-    WarningsGuard guard = options_.getWarningsGuard();\n+    WarningsGuard guard = options.getWarningsGuard();\n     if (guard != null) {\n       CheckLevel newLevel = guard.level(error);\n       if (newLevel != null) {\n   /** Called from the compiler passes, adds debug info */\n   @Override\n   void addToDebugLog(String str) {\n-    debugLog_.append(str);\n-    debugLog_.append('\\n');\n-    logger_.fine(str);\n+    debugLog.append(str);\n+    debugLog.append('\\n');\n+    logger.fine(str);\n   }\n \n   private SourceFile getSourceFileByName(String sourceName) {\n-    if (inputsByName_.containsKey(sourceName)) {\n-      return inputsByName_.get(sourceName).getSourceFile();\n+    if (inputsByName.containsKey(sourceName)) {\n+      return inputsByName.get(sourceName).getSourceFile();\n     }\n     return null;\n   }\n   @Override\n   Node getNodeForCodeInsertion(JSModule module) {\n     if (module == null) {\n-      if (inputs_.length == 0) {\n+      if (inputs.length == 0) {\n         throw new IllegalStateException(\"No inputs\");\n       }\n \n-      return inputs_[0].getAstRoot(this);\n+      return inputs[0].getAstRoot(this);\n     }\n \n     List<CompilerInput> inputs = module.getInputs();\n     if (inputs.size() > 0) {\n       return inputs.get(0).getAstRoot(this);\n     }\n-    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n-      inputs = m.getInputs();\n-      if (inputs.size() > 0) {\n-        return inputs.get(0).getAstRoot(this);\n-      }\n-    }\n     throw new IllegalStateException(\"Root module has no inputs\");\n   }\n \n   public SourceMap getSourceMap() {\n-    return sourceMap_;\n+    return sourceMap;\n   }\n \n   VariableMap getVariableMap() {\n   }\n \n   CompilerOptions getOptions() {\n-    return options_;\n+    return options;\n   }\n \n   FunctionInformationMap getFunctionalInformationMap() {\n-    return functionInformationMap_;\n+    return functionInformationMap;\n   }\n \n   /**\n    * Sets the logging level for the com.google.javascript.jscomp package.\n    */\n   public static void setLoggingLevel(Level level) {\n-    logger_.setLevel(level);\n+    logger.setLevel(level);\n   }\n \n   /** Gets the DOT graph of the AST generated at the end of compilation. */\n \n   @Override\n   public ErrorManager getErrorManager() {\n-    if (options_ == null) {\n+    if (options == null) {\n       initOptions(new CompilerOptions());\n     }\n     return errorManager;\n     IntermediateState state = new IntermediateState();\n     state.externsRoot = externsRoot;\n     state.jsRoot = jsRoot;\n-    state.externs = externs_;\n-    state.inputs = inputs_;\n-    state.modules = modules_;\n+    state.externs = externs;\n+    state.inputs = inputs;\n+    state.modules = modules;\n     state.passConfigState = getPassConfig().getIntermediateState();\n     state.typeRegistry = typeRegistry;\n     state.normalized = normalized;\n   public void setState(IntermediateState state) {\n     externsRoot = state.externsRoot;\n     jsRoot = state.jsRoot;\n-    externs_ = state.externs;\n-    inputs_ = state.inputs;\n-    modules_ = state.modules;\n+    externs = state.externs;\n+    inputs = state.inputs;\n+    modules = state.modules;\n     passes = createPassConfigInternal();\n     getPassConfig().setIntermediateState(state.passConfigState);\n     typeRegistry = state.typeRegistry;\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n   protected void setUp() throws Exception {\n     compiler = new Compiler();\n     compiler.initCompilerOptionsIfTesting();\n-    compiler.options_.setWarningLevel(\n+    compiler.getOptions().setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n     registry = compiler.getTypeRegistry();\n     initTypes();\n--- a/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n            // m2\n            \"var a = (new f).cloneFun();\"\n          });\n-  }  \n+  }\n+  \n+  public void testEmptyModule() {\n+    // When the dest module is empty, it might try to move the code to the\n+    // one of the modules that the empty module depends on. In some cases\n+    // this might ended up to be the same module as the definition of the code.\n+    // When that happens, CrossMooduleCodeMotion might report a code change\n+    // while nothing is moved. This should not be a problem if we know all\n+    // modules are non-empty.\n+    JSModule m1 = new JSModule(\"m1\");\n+    m1.add(JSSourceFile.fromCode(\"m1\", \"function x() {}\"));\n+    \n+    JSModule empty = new JSModule(\"empty\");\n+    empty.addDependency(m1);\n+    \n+    JSModule m2 = new JSModule(\"m2\");\n+    m2.add(JSSourceFile.fromCode(\"m2\", \"x()\"));\n+    m2.addDependency(empty);\n+    \n+    JSModule m3 = new JSModule(\"m3\");\n+    m3.add(JSSourceFile.fromCode(\"m3\", \"x()\"));\n+    m3.addDependency(empty);\n+    \n+    test(new JSModule[] {m1,empty,m2,m3},\n+        new String[] {\n+          \"\",\n+          \"function x() {}\",\n+          \"x()\",\n+          \"x()\"\n+    });\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testSuperclassMatch() throws Exception {\n-    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());\n     testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n         \"/** @constructor \\n @extends Foo */ var Bar = function() {};\\n\" +\n         \"Bar.inherits = function(x){};\" +\n   }\n \n   public void testSuperclassMatchWithMixin() throws Exception {\n-    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());\n     testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n         \"/** @constructor */ var Baz = function() {};\\n\" +\n         \"/** @constructor \\n @extends Foo */ var Bar = function() {};\\n\" +\n   }\n \n   public void testSuperclassMismatch1() throws Exception {\n-    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());\n     testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n         \"/** @constructor \\n @extends Object */ var Bar = function() {};\\n\" +\n         \"Bar.inherits = function(x){};\" +\n   }\n \n   public void testSuperclassMismatch2() throws Exception {\n-    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());\n     testTypes(\"/** @constructor */ var Foo = function(){};\\n\" +\n         \"/** @constructor */ var Bar = function(){};\\n\" +\n         \"Bar.inherits = function(x){};\" +", "timestamp": 1269323507, "metainfo": ""}