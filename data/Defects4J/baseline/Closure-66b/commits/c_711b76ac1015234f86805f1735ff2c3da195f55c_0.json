{"sha": "711b76ac1015234f86805f1735ff2c3da195f55c", "log": "Some non-contraversal changes from 304. Based on a patch by Ilia Kantor  R=nicksantos DELTA=333  (332 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=249   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     switch (n.getType()) {\n       case Token.TRUE:\n         return 1.0;\n+\n       case Token.FALSE:\n       case Token.NULL:\n         return 0.0;\n           return Double.POSITIVE_INFINITY;\n         }\n         return null;\n-    }\n+\n+      case Token.NEG:\n+        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME\n+            && n.getFirstChild().getString().equals(\"Infinity\")) {\n+          return Double.NEGATIVE_INFINITY;\n+        }\n+        return null;\n+\n+      case Token.STRING:\n+        // TODO(johnlenz): handle less common string conversion cases:\n+        // '-infinity', etc.\n+        String s = n.getString();\n+\n+        if (s.length() == 0) {\n+          return 0.0;\n+        }\n+\n+        if (s.length() > 2\n+            && s.charAt(0) == '0'\n+            && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n+            // Attempt to convert hex numbers.\n+          try {\n+            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n+          } catch (NumberFormatException e) {\n+            return null;\n+          }\n+        }\n+\n+        try {\n+          return Double.parseDouble(s);\n+        } catch (NumberFormatException e) {\n+          return null;\n+        }\n+    }\n+\n     return null;\n   }\n \n   }\n \n   /**\n+   * Returns true if the result of node evaluation is always a number\n+   */\n+  static boolean isNumericResult(Node n) {\n+    switch (n.getType()) {\n+      // NOTE: ADD is deliberately excluded as it may produce\n+      // a string.\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.POS:\n+      case Token.NEG:\n+      case Token.NUMBER:\n+        return true;\n+      case Token.NAME:\n+        String name = n.getString();\n+        if (name.equals(\"NaN\")) {\n+          return true;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return true;\n+        }\n+        return false;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the result of node evaluation is always a boolean\n+   */\n+  static boolean isBooleanResult(Node n) {\n+    // TODO(johnlenz): Add a recursive option to recurse into\n+    // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n+    switch (n.getType()) {\n+      // Primitives\n+      case Token.TRUE:\n+      case Token.FALSE:\n+      // Comparisons\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.LT:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.GE:\n+      // Queryies\n+      case Token.IN:\n+      case Token.INSTANCEOF:\n+      // Inversion\n+      case Token.NOT:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  static boolean isUndefined(Node n) {\n+    switch (n.getType()) {\n+      case Token.VOID:\n+        return true;\n+      case Token.NAME:\n+        return n.getString().equals(\"undefined\");\n+    }\n+    return false;\n+  }\n+\n+  static boolean isNull(Node n) {\n+    return n.getType() == Token.NULL;\n+  }\n+\n+  /**\n+   * @returns Whether the results is possibly a string.\n+   */\n+  static boolean mayBeString(Node n) {\n+    return !isNumericResult(n) && !isBooleanResult(n)\n+        && !isUndefined(n) && !isNull(n);\n+  }\n+\n+  /**\n    * Returns true if the operator is associative.\n    * e.g. (a * b) * c = a * (b * c)\n    * Note: \"+\" is not associative because it is also the concatenation\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     ImmutableSet<String> defines = ImmutableSet.of();\n     return NodeUtil.isValidDefineValue(value, defines);\n   }\n+\n+  public void testNumberValue() {\n+    assertEquals(0.0, NodeUtil.getNumberValue(getNode(\"''\")));\n+    assertEquals(2.0, NodeUtil.getNumberValue(getNode(\"'+2'\")));\n+    assertEquals(-1.6, NodeUtil.getNumberValue(getNode(\"'-1.6'\")));\n+    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'16'\")));\n+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'123e2'\")));\n+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'123E2'\")));\n+    assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'123e-2'\")));\n+    assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'123E-2'\")));\n+\n+    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'0x10'\")), 16.0);\n+    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'0X10'\")));\n+    assertEquals(77.0, NodeUtil.getNumberValue(getNode(\"'077'\")));\n+    assertEquals(\n+        Double.NEGATIVE_INFINITY,\n+        NodeUtil.getNumberValue(getNode(\"'-Infinity'\")));\n+    assertEquals(\n+        Double.POSITIVE_INFINITY,\n+        NodeUtil.getNumberValue(getNode(\"'Infinity'\")));\n+    assertEquals(\n+        null,\n+        NodeUtil.getNumberValue(getNode(\"'-infinity'\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'infinity'\")));\n+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode(\"'NaN'\")));\n+    assertEquals(\n+        null, NodeUtil.getNumberValue(getNode(\"'some unknown string'\")));\n+\n+    assertEquals(\n+        1.0, NodeUtil.getNumberValue(getNode(\"true\")));\n+    assertEquals(\n+        0.0, NodeUtil.getNumberValue(getNode(\"false\")));\n+    assertEquals(\n+        0.0, NodeUtil.getNumberValue(getNode(\"null\")));\n+    assertEquals(\n+        Double.NaN, NodeUtil.getNumberValue(getNode(\"void 0\")));\n+    assertEquals(\n+        Double.NaN, NodeUtil.getNumberValue(getNode(\"NaN\")));\n+    assertEquals(\n+        Double.POSITIVE_INFINITY,\n+        NodeUtil.getNumberValue(getNode(\"Infinity\")));\n+    assertEquals(\n+        Double.NEGATIVE_INFINITY,\n+        NodeUtil.getNumberValue(getNode(\"-Infinity\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"infinity\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"-infinity\")));\n+  }\n+\n+  public void testIsNumbericResult() {\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"1\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"true\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"+true\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"+1\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"-1\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"-Infinity\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"Infinity\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"NaN\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"undefined\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"void 0\")));\n+\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a << b\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a >> b\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a >>> b\")));\n+\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a == b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a != b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a === b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a !== b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a < b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a > b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a <= b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a >= b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a in b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a instanceof b\")));\n+\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"'a'\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"'a'+b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a+'b'\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a+b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a()\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"''.a\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a.b\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a.b()\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a().b()\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"new a()\")));\n+    \n+    // Definitely not numberic\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"([1,2])\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"({a:1})\")));    \n+\n+    // These are number but aren't handled yet, \"false\" here means \"unknown\".\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"1 && 2\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"1 || 2\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a ? 2 : 3\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a,1\")));\n+    assertFalse(NodeUtil.isNumericResult(getNode(\"a=1\")));\n+  }\n+  \n+  public void testIsBooleanResult() {\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));\n+\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));\n+\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));\n+\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));\n+    \n+    // Definitely not boolean\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));    \n+\n+    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"true || false\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));\n+  }  \n+\n+  public void testMayBeString() {\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"true\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"+true\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"+1\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"-1\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"-Infinity\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"Infinity\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"NaN\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"undefined\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"void 0\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"null\")));\n+\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a << b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a >> b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a >>> b\")));\n+\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a == b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a != b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a === b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a !== b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a < b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a > b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a <= b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a >= b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a in b\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a instanceof b\")));\n+\n+    assertTrue(NodeUtil.mayBeString(getNode(\"'a'\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"'a'+b\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a+'b'\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a+b\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a()\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"''.a\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a.b\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a.b()\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a().b()\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"new a()\")));\n+\n+    // These can't be strings but they aren't handled yet.\n+    assertTrue(NodeUtil.mayBeString(getNode(\"1 && 2\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"1 || 2\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"1 ? 2 : 3\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"1,2\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"a=1\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"1+1\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"true+true\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"null+null\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"NaN+NaN\")));\n+\n+    // These are not strings but they aren't primitives either\n+    assertTrue(NodeUtil.mayBeString(getNode(\"([1,2])\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"({a:1})\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"({}+1)\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"(1+{})\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"([]+1)\")));\n+    assertTrue(NodeUtil.mayBeString(getNode(\"(1+[])\")));\n+  }\n }", "timestamp": 1294776373, "metainfo": ""}