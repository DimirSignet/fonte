{"sha": "0f655dc72070acbdcc5fe3a1aecf91c11955c37b", "log": "Runtime type check. (Nada and Andrew)  Adds Database/readTransaction to the HTML5 externs  More user-friendly error messages for trailing commas (Nick)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n+    }\n+    \n+    @Override\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n     }\n     \n     public static com.google.javascript.jscomp.FunctionInformationMap.Entry parseFrom(\n       return size;\n     }\n     \n+    @Override\n+    protected Object writeReplace() throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n     public static com.google.javascript.jscomp.FunctionInformationMap.Module parseFrom(\n         com.google.protobuf.ByteString data)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n     size += getUnknownFields().getSerializedSize();\n     memoizedSerializedSize = size;\n     return size;\n+  }\n+  \n+  @Override\n+  protected Object writeReplace() throws java.io.ObjectStreamException {\n+    return super.writeReplace();\n   }\n   \n   public static com.google.javascript.jscomp.FunctionInformationMap parseFrom(\n--- a/gen/com/google/javascript/jscomp/Instrumentation.java\n+++ b/gen/com/google/javascript/jscomp/Instrumentation.java\n     size += getUnknownFields().getSerializedSize();\n     memoizedSerializedSize = size;\n     return size;\n+  }\n+  \n+  @Override\n+  protected Object writeReplace() throws java.io.ObjectStreamException {\n+    return super.writeReplace();\n   }\n   \n   public static com.google.javascript.jscomp.Instrumentation parseFrom(\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   //--------------------------------\n   // Special-purpose alterations\n   //--------------------------------\n+\n+  /** Inserts runtime type assertions for debugging. */\n+  boolean runtimeTypeCheck;\n+\n+  /**\n+   * A JS function to be used for logging runtime type assertion\n+   * failures. It will be passed the warning as a string and the\n+   * faulty expression as arguments.\n+   */\n+  String runtimeTypeCheckLogFunction;\n \n   /** A CodingConvention to use during the compile. */\n   private CodingConvention codingConvention;\n     exportTestFunctions = false;\n \n     // Alterations\n+    runtimeTypeCheck = false;\n+    runtimeTypeCheckLogFunction = null;\n     instrumentForCoverage = false;\n     instrumentForCoverageOnly = false;\n     ignoreCajaProperties = false;\n     this.chainCalls = value;\n   }\n \n+  /**\n+   * Enable runtime type checking, which adds JS type assertions for debugging.\n+   *\n+   * @param logFunction A JS function to be used for logging runtime type\n+   *     assertion failures.\n+   */\n+  public void enableRuntimeTypeCheck(String logFunction) {\n+    this.runtimeTypeCheck = true;\n+    this.runtimeTypeCheckLogFunction = logFunction;\n+  }\n+\n+  public void disableRuntimeTypeCheck() {\n+    this.runtimeTypeCheck = false;\n+  }\n+\n   public void setCodingConvention(CodingConvention codingConvention) {\n     this.codingConvention = codingConvention;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     // TODO(nicksantos): The order of these passes makes no sense, and needs\n     // to be re-arranged.\n+\n+    if (options.runtimeTypeCheck) {\n+      passes.add(runtimeTypeCheck);\n+    }\n \n     passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n \n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new IgnoreCajaProperties(compiler);\n+    }\n+  };\n+\n+  /** Inserts runtime type assertions for debugging. */\n+  private final PassFactory runtimeTypeCheck =\n+      new PassFactory(\"runtimeTypeCheck\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RuntimeTypeCheck(compiler,\n+          options.runtimeTypeCheckLogFunction);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n       DiagnosticType.warning(\"JSC_EXTRA_FILEOVERVIEW\", \"Parse error. {0}\");\n \n   static final DiagnosticType TRAILING_COMMA =\n-      DiagnosticType.error(\"JSC_TRAILING_COMMA\", \"Parse error. {0}\");\n+      DiagnosticType.error(\"JSC_TRAILING_COMMA\",\n+          \"Parse error. Internet Explorer has a non-standard \" +\n+          \"intepretation of trailing commas. Arrays will have the wrong \" +\n+          \"length and objects will not parse at all.\");\n \n   static final DiagnosticType DUPLICATE_PARAM =\n       DiagnosticType.error(\"JSC_DUPLICATE_PARAM\", \"Parse error. {0}\");\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.UnionType;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import com.google.common.io.CharStreams;\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Comparator;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Inserts runtime type assertions.\n+ *\n+ * <p>We add markers to user-defined interfaces and classes in order to check if\n+ * an object conforms to that type.\n+ *\n+ * <p>For each function, we insert a runtime type assertion for each parameter\n+ * and return value for which the compiler has a type.\n+ *\n+ * <p>The JavaScript code which implements the type assertions is in\n+ * js/runtime-type-check.js.\n+ *\n+*\n+*\n+ */\n+class RuntimeTypeCheck implements CompilerPass {\n+\n+  private static final Comparator<JSType> ALPHA = new Comparator<JSType>() {\n+    public int compare(JSType t1, JSType t2) {\n+      return getName(t1).compareTo(getName(t2));\n+    }\n+\n+    private String getName(JSType type) {\n+      if (type.isInstanceType()) {\n+        return ((ObjectType) type).getReferenceName();\n+      } else if (type.isNullType()\n+          || type.isBooleanValueType()\n+          || type.isNumberValueType()\n+          || type.isStringValueType()\n+          || type.isVoidType()) {\n+        return type.toString();\n+      } else {\n+        // Type unchecked at runtime, so we don't care about the sorting order.\n+        return \"\";\n+      }\n+    }\n+  };\n+\n+  private final AbstractCompiler compiler;\n+  private final String logFunction;\n+\n+  RuntimeTypeCheck(AbstractCompiler compiler, @Nullable String logFunction) {\n+    this.compiler = compiler;\n+    this.logFunction = logFunction;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new AddMarkers(compiler));\n+    NodeTraversal.traverse(compiler, root, new AddChecks(compiler));\n+    addBoilerplateCode();\n+  }\n+\n+  /**\n+   * Inserts marker properties for user-defined interfaces and classes.\n+   *\n+   * <p>For example, for a class C, we add\n+   * {@code C.prototype['instance_of__C']}, and for each interface I it\n+   * implements , we add {@code C.prototype['implements__I']}.\n+   *\n+   * <p>Since interfaces are not a runtime JS concept, we use these markers to\n+   * recognize an interface implementation at runtime. We also use markers for\n+   * user-defined classes, so that we can easily recognize them independently of\n+   * which module they are defined in and whether the module is loaded.\n+   */\n+  private static class AddMarkers\n+      extends NodeTraversal.AbstractPostOrderCallback {\n+\n+    private final AbstractCompiler compiler;\n+\n+    private AddMarkers(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (NodeUtil.isFunction(n)) {\n+        visitFunction(t, n);\n+      }\n+    }\n+\n+    private void visitFunction(NodeTraversal t, Node n) {\n+      FunctionType funType = (FunctionType) n.getJSType();\n+      if (!funType.isConstructor()) {\n+        return;\n+      }\n+\n+      Node nodeToInsertAfter = findNodeToInsertAfter(n);\n+\n+      nodeToInsertAfter = addMarker(funType, nodeToInsertAfter, null);\n+\n+      for (ObjectType interfaceType :\n+          Sets.newTreeSet(ALPHA, funType.getAllImplementedInterfaces())) {\n+        nodeToInsertAfter =\n+            addMarker(funType, nodeToInsertAfter, interfaceType);\n+      }\n+    }\n+\n+    private Node addMarker(\n+            FunctionType funType,\n+            Node nodeToInsertAfter,\n+            @Nullable ObjectType interfaceType) {\n+\n+      String className = funType.getInstanceType().getReferenceName();\n+\n+      // This can happen with anonymous classes declared with the type\n+      // {@code Function}.\n+      if (className == null) {\n+        return nodeToInsertAfter;\n+      }\n+\n+      Node classNode = NodeUtil.newQualifiedNameNode(className, -1, -1);\n+\n+      Node marker = Node.newString(\n+              interfaceType == null ?\n+              \"instance_of__\" + className :\n+              \"implements__\" + interfaceType.getReferenceName());\n+\n+      Node assign = new Node(Token.EXPR_RESULT, new Node(Token.ASSIGN,\n+          new Node(Token.GETELEM,\n+              new Node(Token.GETPROP,\n+                  classNode,\n+                  Node.newString(\"prototype\")), marker),\n+          new Node(Token.TRUE)));\n+\n+      nodeToInsertAfter.getParent().addChildAfter(assign, nodeToInsertAfter);\n+      compiler.reportCodeChange();\n+      nodeToInsertAfter = assign;\n+      return nodeToInsertAfter;\n+    }\n+\n+    /**\n+     * Find the node to insert the markers after. Typically, this node\n+     * corresponds to the constructor declaration, but we want to skip any of\n+     * the white-listed function calls.\n+     *\n+     * @param n the constructor function node\n+     * @return the node to insert after\n+     */\n+    private Node findNodeToInsertAfter(Node n) {\n+      Node nodeToInsertAfter = findEnclosingConstructorDeclaration(n);\n+\n+      Node next = nodeToInsertAfter.getNext();\n+      while (next != null && isClassDefiningCall(next)) {\n+        nodeToInsertAfter = next;\n+        next = nodeToInsertAfter.getNext();\n+      }\n+\n+      return nodeToInsertAfter;\n+    }\n+\n+    private Node findEnclosingConstructorDeclaration(Node n) {\n+      while (n.getParent().getType() != Token.SCRIPT &&\n+          n.getParent().getType() != Token.BLOCK) {\n+        n = n.getParent();\n+      }\n+      return n;\n+    }\n+\n+    private boolean isClassDefiningCall(Node next) {\n+      return NodeUtil.isExprCall(next) &&\n+          compiler.getCodingConvention().getClassesDefinedByCall(\n+              next.getFirstChild()) != null;\n+    }\n+  }\n+\n+  /**\n+   * Insert calls to the runtime type checking function {@code checkType}, which\n+   * takes an expression to check and a list of checkers (one of which must\n+   * match). It returns the expression back to facilitate checking of return\n+   * values. We have checkers for value types, class types (user-defined and\n+   * externed), and interface types.\n+   */\n+  private static class AddChecks\n+      extends NodeTraversal.AbstractPostOrderCallback {\n+\n+    private final AbstractCompiler compiler;\n+\n+    private AddChecks(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (NodeUtil.isFunction(n)) {\n+        visitFunction(t, n);\n+      } else if (n.getType() == Token.RETURN) {\n+        visitReturn(t, n);\n+      }\n+    }\n+\n+    /**\n+     * Insert checks for the parameters of the function.\n+     */\n+    private void visitFunction(NodeTraversal t, Node n) {\n+      FunctionType funType = (FunctionType) n.getJSType();\n+      Node block = n.getLastChild();\n+      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n+      Node prev = null;\n+      for (Node paramType : funType.getParameters()) {\n+        // Can this ever happen?\n+        if (paramName == null) {\n+          return;\n+        }\n+\n+        Node checkNode = createCheckTypeCallNode(\n+            paramType.getJSType(), paramName.getString());\n+\n+        if (checkNode == null) {\n+          // We don't know how to check this parameter type.\n+          paramName = paramName.getNext();\n+          continue;\n+        }\n+\n+        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n+        if (prev == null) {\n+          block.addChildToFront(checkNode);\n+        } else {\n+          block.addChildAfter(checkNode, prev);\n+        }\n+\n+        compiler.reportCodeChange();\n+        paramName = paramName.getNext();\n+        prev = checkNode;\n+      }\n+    }\n+\n+    private void visitReturn(NodeTraversal t, Node n) {\n+      Node function = t.getEnclosingFunction();\n+      FunctionType funType = (FunctionType) function.getJSType();\n+\n+      Node retValue = n.getFirstChild();\n+      if (retValue == null) {\n+        return;\n+      }\n+\n+      Node checkNode = createCheckTypeCallNode(\n+          funType.getReturnType(), retValue.cloneTree());\n+\n+      if (checkNode == null) {\n+        return;\n+      }\n+\n+      n.replaceChild(retValue, checkNode);\n+      compiler.reportCodeChange();\n+    }\n+\n+    private Node createCheckTypeCallNode(JSType type, String varName) {\n+      return createCheckTypeCallNode(type, Node.newString(Token.NAME, varName));\n+    }\n+\n+    /**\n+     * Creates a function call to check that the given expression matches the\n+     * given type at runtime.\n+     *\n+     * <p>For example, if the type is {@code (string|Foo)}, the function call is\n+     * {@code checkType(expr, [valueChecker('string'), classChecker('Foo')])}.\n+     *\n+     * @return the function call node or {@code null} if the type is not checked\n+     */\n+    private Node createCheckTypeCallNode(JSType type, Node expr) {\n+      Node arrayNode = new Node(Token.ARRAYLIT);\n+      Iterable<JSType> alternates = type.isUnionType()\n+               ? Sets.newTreeSet(ALPHA, ((UnionType) type).getAlternates())\n+               : ImmutableList.of(type);\n+      for (JSType alternate : alternates) {\n+        Node checkerNode = createCheckerNode(alternate);\n+        if (checkerNode == null) {\n+          return null;\n+        }\n+        arrayNode.addChildToBack(checkerNode);\n+      }\n+      return new Node(Token.CALL, jsCode(\"checkType\"), expr, arrayNode);\n+    }\n+\n+    /**\n+     * Creates a node which evaluates to a checker for the given type (which\n+     * must not be a union). We have checkers for value types, classes and\n+     * interfaces.\n+     *\n+     * @return the checker node or {@code null} if the type is not checked\n+     */\n+    private Node createCheckerNode(JSType type) {\n+      if (type.isNullType()) {\n+        return jsCode(\"nullChecker\");\n+\n+      } else if (type.isBooleanValueType()\n+          || type.isNumberValueType()\n+          || type.isStringValueType()\n+          || type.isVoidType()) {\n+        return new Node(Token.CALL,\n+            jsCode(\"valueChecker\"),\n+            Node.newString(type.toString()));\n+\n+      } else if (type.isInstanceType()) {\n+        ObjectType objType = (ObjectType) type;\n+\n+        String refName = objType.getReferenceName();\n+\n+        String sourceName =\n+            NodeUtil.getSourceName(objType.getConstructor().getSource());\n+        CompilerInput sourceInput = compiler.getInput(sourceName);\n+        if (sourceInput == null || sourceInput.isExtern()) {\n+          return new Node(Token.CALL,\n+                  jsCode(\"externClassChecker\"),\n+                  Node.newString(refName));\n+        }\n+\n+        return new Node(Token.CALL,\n+                jsCode(objType.getConstructor().isInterface() ?\n+                        \"interfaceChecker\" : \"classChecker\"),\n+                Node.newString(refName));\n+\n+      } else {\n+        // We don't check this type (e.g. unknown & all types).\n+        return null;\n+      }\n+    }\n+  }\n+\n+  private void addBoilerplateCode() {\n+    String boilerplateCode = getBoilerplateCode(logFunction);\n+\n+    Node js = compiler.parseSyntheticCode(boilerplateCode);\n+\n+    compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n+        js.removeChildren());\n+\n+    compiler.reportCodeChange();\n+  }\n+\n+  private static Node jsCode(String prop) {\n+    return NodeUtil.newQualifiedNameNode(\"jscomp.typecheck.\" + prop, -1, -1);\n+  }\n+\n+  @VisibleForTesting\n+  static String getBoilerplateCode(@Nullable String logFunction) {\n+    String boilerplateCode;\n+    try {\n+      boilerplateCode = CharStreams.toString(new InputStreamReader(\n+          RuntimeTypeCheck.class.getResourceAsStream(\n+          \"js/runtime_type_check.js\"), Charsets.UTF_8));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    boilerplateCode = boilerplateCode.replace(\"%%LOG%%\",\n+        logFunction == null ? \"function(warning, expr) {}\" : logFunction);\n+\n+    return boilerplateCode;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for error message filtering.\n+*\n+ */\n+public class RhinoErrorReporterTest extends TestCase {\n+\n+  public CompilerPass getProcessor(Compiler compiler) {\n+    return new CompilerPass() {\n+      public void process(Node externs, Node root) {}\n+    };\n+  }\n+\n+  public void testTrailingComma() throws Exception {\n+    String message =\n+        \"Parse error. Internet Explorer has a non-standard \" +\n+        \"intepretation of trailing commas. Arrays will have the wrong \" +\n+        \"length and objects will not parse at all.\";\n+    assertError(\n+        \"var x = [1,];\",\n+        RhinoErrorReporter.TRAILING_COMMA,\n+        message);\n+    assertError(\n+        \"var x = {1: 2,};\",\n+        RhinoErrorReporter.TRAILING_COMMA,\n+        message);\n+  }\n+\n+\n+  /**\n+   * Verifies that the compiler emits an error for the given code.\n+   */\n+  private void assertError(\n+      String code, DiagnosticType type, String description) {\n+    Compiler compiler = new Compiler();\n+    JSSourceFile[] externs = new JSSourceFile[] {};\n+    JSSourceFile[] inputs =  new JSSourceFile[] {\n+      JSSourceFile.fromCode(\"input\", code)\n+    };\n+    compiler.init(externs, inputs, new CompilerOptions());\n+    compiler.parseInputs();\n+    assertEquals(\"Expected error\", 1, compiler.getErrorCount());\n+\n+    JSError error =\n+        Iterables.getOnlyElement(Lists.newArrayList(compiler.getErrors()));\n+    assertEquals(type, error.getType());\n+    assertEquals(description, error.description);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for {@link RuntimeTypeCheck}.\n+ *\n+*\n+*\n+ */\n+public class RuntimeTypeCheckTest extends CompilerTestCase {\n+\n+  public RuntimeTypeCheckTest() {\n+    enableTypeCheck(CheckLevel.WARNING);\n+  }\n+\n+  public void testValue() {\n+    testChecks(\"/** @param {number} i */ function f(i) {}\",\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.valueChecker('number')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testNullValue() {\n+    testChecks(\"/** @param {null} i */ function f(i) {}\",\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, [jscomp.typecheck.nullChecker]);\" +\n+        \"}\");\n+  }\n+\n+  public void testValues() {\n+    testChecks(\"/** @param {number} i\\n@param {string} j*/ function f(i, j) {}\",\n+        \"function f(i, j) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.valueChecker('number')]);\" +\n+        \"  jscomp.typecheck.checkType(j, \" +\n+        \"      [jscomp.typecheck.valueChecker('string')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testSkipParamOK() {\n+    testChecks(\"/** @param {*} i\\n@param {string} j*/ function f(i, j) {}\",\n+        \"function f(i, j) {\" +\n+        \"  jscomp.typecheck.checkType(j, \" +\n+        \"      [jscomp.typecheck.valueChecker('string')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testUnion() {\n+    testChecks(\"/** @param {number|string} x */ function f(x) {}\",\n+        \"function f(x) {\" +\n+        \"  jscomp.typecheck.checkType(x, [\" +\n+        \"      jscomp.typecheck.valueChecker('number'), \" +\n+        \"      jscomp.typecheck.valueChecker('string')\" +\n+        \"]);\" +\n+        \"}\");\n+  }\n+\n+  public void testUntypedParam() {\n+    testChecks(\"/** ... */ function f(x) {}\", \"function f(x) {}\");\n+  }\n+\n+  public void testReturn() {\n+    testChecks(\"/** @return {string} */ function f() { return 'x'; }\",\n+        \"function f() {\" +\n+        \"  return jscomp.typecheck.checkType('x', \" +\n+        \"      [jscomp.typecheck.valueChecker('string')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testNativeClass() {\n+    testChecks(\"/** @param {!String} x */ function f(x) {}\",\n+        \"function f(x) {\" +\n+        \"  jscomp.typecheck.checkType(x, \" +\n+        \"      [jscomp.typecheck.externClassChecker('String')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testQualifiedClass() {\n+    testChecks(\"var goog = {}; /** @constructor */goog.Foo = function() {};\" +\n+        \"/** @param {!goog.Foo} x */ function f(x) {}\",\n+        \"var goog = {}; goog.Foo = function() {};\" +\n+        \"goog.Foo.prototype['instance_of__goog.Foo'] = true;\" +\n+        \"function f(x) {\" +\n+        \"  jscomp.typecheck.checkType(x, \" +\n+        \"    [jscomp.typecheck.classChecker('goog.Foo')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testInterface() {\n+    testChecks(\"/** @interface */function I() {}\" +\n+        \"/** @param {!I} i */function f(i) {}\",\n+        \"function I() {}\" +\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"    [jscomp.typecheck.interfaceChecker('I')])\" +\n+        \"}\");\n+  }\n+\n+  public void testImplementedInterface() {\n+    testChecks(\"/** @interface */function I() {}\" +\n+        \"/** @param {!I} i */function f(i) {}\" +\n+        \"/** @constructor\\n@implements {I} */function C() {}\",\n+        \"function I() {}\" +\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.interfaceChecker('I')])\" +\n+        \"}\" +\n+        \"function C() {}\" +\n+        \"C.prototype['instance_of__C'] = true;\" +\n+        \"C.prototype['implements__I'] = true;\");\n+  }\n+\n+  public void testExtendedInterface() {\n+    testChecks(\"/** @interface */function I() {}\" +\n+        \"/** @interface\\n@extends {I} */function J() {}\" +\n+        \"/** @param {!I} i */function f(i) {}\" +\n+        \"/** @constructor\\n@implements {J} */function C() {}\",\n+        \"function I() {}\" +\n+        \"function J() {}\" +\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.interfaceChecker('I')])\" +\n+        \"}\" +\n+        \"function C() {}\" +\n+        \"C.prototype['instance_of__C'] = true;\" +\n+        \"C.prototype['implements__I'] = true;\" +\n+        \"C.prototype['implements__J'] = true;\");\n+  }\n+\n+  public void testImplementedInterfaceOrdering() {\n+    testChecks(\"/** @interface */function I() {}\" +\n+        \"/** @param {!I} i */function f(i) {}\" +\n+        \"/** @constructor\\n@implements {I} */function C() {}\" +\n+        \"C.prototype.f = function() {};\",\n+        \"function I() {}\" +\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.interfaceChecker('I')])\" +\n+        \"}\" +\n+        \"function C() {}\" +\n+        \"C.prototype['instance_of__C'] = true;\" +\n+        \"C.prototype['implements__I'] = true;\" +\n+        \"C.prototype.f = function() {};\");\n+  }\n+\n+  public void testImplementedInterfaceOrderingGoogInherits() {\n+    testChecks(\"var goog = {}; goog.inherits = function(x, y) {};\" +\n+        \"/** @interface */function I() {}\" +\n+        \"/** @param {!I} i */function f(i) {}\" +\n+        \"/** @constructor */function B() {}\" +\n+        \"/** @constructor\\n@extends {B}\\n@implements {I} */function C() {}\" +\n+        \"goog.inherits(C, B);\" +\n+        \"C.prototype.f = function() {};\",\n+        \"var goog = {}; goog.inherits = function(x, y) {};\" +\n+        \"function I() {}\" +\n+        \"function f(i) {\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n+        \"      [jscomp.typecheck.interfaceChecker('I')])\" +\n+        \"}\" +\n+        \"function B() {}\" +\n+        \"B.prototype['instance_of__B'] = true;\" +\n+        \"function C() {}\" +\n+        \"goog.inherits(C, B);\" +\n+        \"C.prototype['instance_of__C'] = true;\" +\n+        \"C.prototype['implements__I'] = true;\" +\n+        \"C.prototype.f = function() {};\");\n+  }\n+\n+  public void testInnerConstructor() {\n+    testChecks(\"(function() { /** @constructor */ function C() {} })()\",\n+        \"(function() {\" +\n+        \"  function C() {} C.prototype['instance_of__C'] = true;\" +\n+        \"})()\");\n+  }\n+\n+  public void testReturnNothing() {\n+    testChecks(\"function f() { return; }\", \"function f() { return; }\");\n+  }\n+\n+  public void testFunctionType() {\n+    testChecks(\"/** @type {!Function} */function f() {}\", \"function f() {}\");\n+  }\n+\n+  private void testChecks(String js, String expected) {\n+    String boilerplateCode = RuntimeTypeCheck.getBoilerplateCode(null);\n+    test(js, boilerplateCode + expected);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    return new RuntimeTypeCheck(compiler, null);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+}", "timestamp": 1266628907, "metainfo": ""}