{"sha": "d964d232de65db2370c06ce04de9865a3b2c8c9f", "log": "Minor code removal improvement \"({}).prop = 3;\" has no side effects.  Improvements to test infrastructure.  Fix an edge case compiler crash in TypeValidator.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       default:\n         if (isSimpleOperatorType(n.getType()))\n           break;\n+\n+        if (isAssignmentOp(n)) {\n+          // Assignments will have side effects if\n+          // a) The RHS has side effects, or\n+          // b) The LHS has side effects, or\n+          // c) A name on the LHS will exist beyond the life of this statement.\n+          if (checkForStateChangeHelper(\n+                  n.getFirstChild(), checkForNewObjects) ||\n+              checkForStateChangeHelper(\n+                  n.getLastChild(), checkForNewObjects)) {\n+            return true;\n+          }\n+\n+          Node current = n.getFirstChild();\n+          for (;\n+               current.getType() == Token.GETPROP ||\n+               current.getType() == Token.GETELEM;\n+               current = current.getFirstChild()) { }\n+\n+          return !(isLiteralValue(current) ||\n+              current.getType() == Token.FUNCTION);\n+        }\n \n         return true;\n     }\n   }\n \n   /**\n+   * @return true if n or any of its children are of the specified type.\n+   *     Does not traverse into functions.\n+   */\n+  static boolean containsTypeInOuterScope(Node node, int type) {\n+    return containsType(node, type,\n+        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n+  }\n+\n+  /**\n    * @return true if n or any of its children are of the specified type\n    */\n   static boolean containsType(Node node,\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.StringUtil;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n \n /**\n  * A compiler pass that verifies the structure of the AST conforms\n     sanityCheckNormalization(externs, root);\n     Node reparsedRoot = sanityCheckCodeGeneration(root);\n     if (reparsedRoot != null) {\n-      sanityCheckSymbolTable(reparsedRoot, root);\n+      Node clonedExterns = externs.cloneTree();\n+      sanityCheckSymbolTable(\n+          new Node(Token.BLOCK,\n+              clonedExterns,\n+              new Node(Token.BLOCK, reparsedRoot)),\n+          root.getParent());\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n           \"Variable count does not match.\" +\n           \"\\nCached : {0}\\nActual : {1}\");\n \n+  static final DiagnosticType SCOPE_MISMATCH =\n+      DiagnosticType.error(\n+          \"JSC_SCOPE_MISMATCH\",\n+          \"Scope roots used with the symbol table do not match.\" +\n+          \"\\nExpected : {0}\\nActual : {1}\");\n+\n   private final AbstractCompiler compiler;\n   private final ScopeCreator scopeCreator;\n \n    */\n   @Override\n   public Scope createScope(Node n, Scope parent) {\n+    // We may only ask for local blocks and the global (all scripts) block.\n     Preconditions.checkArgument(\n-        n.getType() == Token.BLOCK || n.getType() == Token.FUNCTION);\n+        (n.getType() == Token.BLOCK && n.getParent() == null) ||\n+        n.getType() == Token.FUNCTION,\n+        \"May only create scopes for the global node and functions\");\n     ensureCacheInitialized();\n \n     if (!cache.scopes.containsKey(n)) {\n       for (int i = 0; i < expectedScopes.size(); i++) {\n         Scope expectedScope = expectedScopes.get(i);\n         Scope actualScope = actualScopes.get(i);\n+\n+        if (!checkNodesMatch(expectedScope.getRootNode(),\n+                actualScope.getRootNode())) {\n+          compiler.report(\n+              JSError.make(\n+                  SCOPE_MISMATCH,\n+                  expectedScope.getRootNode().toStringTree(),\n+                  actualScope.getRootNode().toStringTree()));\n+          continue;\n+        }\n+\n         if (expectedScope.getVarCount() != actualScope.getVarCount()) {\n           compiler.report(\n               JSError.make(\n           while (it.hasNext()) {\n             Var var = it.next();\n             Scope.Var actualVar = actualScope.getVar(var.getName());\n-            if (actualVar == null) {\n+            if (actualVar == null ||\n+                expectedScope.getVar(var.getName()) != var) {\n               compiler.report(\n                   JSError.make(MISSING_VARIABLE, var.getName()));\n-            } else if (!isNodeAttached(actualVar.getNameNode())) {\n+            } else if (\n+                !checkNodesMatch(\n+                    var.getNameNode(),\n+                    actualVar.getNameNode()) ||\n+                !isNodeAttached(actualVar.getNameNode())) {\n               compiler.report(\n                   JSError.make(MOVED_VARIABLE, var.getName()));\n             }\n           }\n         }\n       }\n+    }\n+\n+    /**\n+     * Check that the two nodes have the same relative position in the tree.\n+     */\n+    private boolean checkNodesMatch(Node nodeA, Node nodeB) {\n+      Node currentA = nodeA;\n+      Node currentB = nodeB;\n+      while (currentA != null && currentB != null) {\n+        if (currentA.getType() != currentB.getType() ||\n+            !currentA.isEquivalentTo(currentB)) {\n+          return false;\n+        }\n+\n+        currentA = currentA.getParent();\n+        currentB = currentB.getParent();\n+      }\n+\n+      return currentA == null && currentB == null;\n     }\n \n     private boolean isNodeAttached(Node node) {\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n \n     JSType type = getJSType(n);\n     if (dereference) {\n-      type = type.dereference();\n+      ObjectType dereferenced = type.dereference();\n+      if (dereferenced != null) {\n+        type = dereferenced;\n+      }\n     }\n \n     String qualifiedName = n.getQualifiedName();\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n       return;\n     }\n     if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n-        (removeNoOpStatements && !NodeUtil.mayEffectMutableState(n))) {\n+        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n       removeDeadExprStatementSafely(n, parent);\n     }\n   }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n             case IS_CONSTANT_NAME:   return \"is_constant_name\";\n             case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n             case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n-            case IS_NAMESPACE:         return \"is_namespace\";\n-            case IS_DISPATCHER:        return \"is_dispatcher\";\n-            default: Kit.codeBug();\n+            case IS_NAMESPACE:       return \"is_namespace\";\n+            case IS_DISPATCHER:      return \"is_dispatcher\";\n+            case DIRECTIVES:         return \"directives\";\n+            default:\n+              Kit.codeBug();\n \n \n         }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n import junit.framework.TestCase;\n       ErrorManager symbolTableErrorManager =\n           new BlackHoleErrorManager(compiler);\n       Node expectedRoot = parseExpectedJs(expected);\n+      expectedRoot.detachFromParent();\n       SymbolTable table = compiler.acquireSymbolTable();\n-      table.verify(expectedRoot, mainRoot);\n+      table.verify(\n+          new Node(Token.BLOCK, externsRoot.cloneTree(), expectedRoot),\n+          mainRoot.getParent());\n       table.release();\n \n       JSError[] stErrors = symbolTableErrorManager.getErrors();\n             \"\\n\" + explanation, explanation);\n       }\n     } else {\n-      assertEquals(\"There should be one error.\", 1, compiler.getErrorCount());\n-      assertEquals(error, compiler.getErrors()[0].getType());\n+      String errors = \"\";\n+      for (JSError actualError : compiler.getErrors()) {\n+        errors += actualError.description + \"\\n\";\n+      }\n+      assertEquals(\"There should be one error. \" + errors,\n+          1, compiler.getErrorCount());\n+      assertEquals(errors, error, compiler.getErrors()[0].getType());\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertSideEffect(false, \"new Array(4)\");\n     assertSideEffect(false, \"new Array('a', 'b', 'c')\");\n     assertSideEffect(true, \"new SomeClassINeverHeardOf()\");\n+    assertSideEffect(true, \"new SomeClassINeverHeardOf()\");\n+\n+    assertSideEffect(false, \"({}).foo = 4\");\n+    assertSideEffect(false, \"([]).foo = 4\");\n+    assertSideEffect(false, \"(function() {}).foo = 4\");\n+\n+    assertSideEffect(true, \"this.foo = 4\");\n+    assertSideEffect(true, \"a.foo = 4\");\n+    assertSideEffect(true, \"(function() { return n; })().foo = 4\");\n+    assertSideEffect(true, \"([]).foo = bar()\");\n   }\n \n   private void assertMutableState(boolean se, String js) {\n     assertTrue(labelNode.getType() == Token.LABEL);\n     assertTrue(NodeUtil.isLabelName(labelNode.getFirstChild()));\n     assertFalse(NodeUtil.isLabelName(labelNode.getLastChild()));\n-    \n+\n     Node whileNode = labelNode.getLastChild();\n     assertTrue(whileNode.getType() == Token.WHILE);\n     Node whileBlock = whileNode.getLastChild();\n     Node variableReference = firstStatement.getFirstChild();\n     assertTrue(variableReference.getType() == Token.NAME);\n     assertFalse(NodeUtil.isLabelName(variableReference));\n-    \n+\n     Node continueStatement = firstStatement.getNext();\n     assertTrue(continueStatement.getType() == Token.CONTINUE);\n     assertTrue(NodeUtil.isLabelName(continueStatement.getFirstChild()));\n     Node firstBreak = continueStatement.getNext();\n     assertTrue(firstBreak.getType() == Token.BREAK);\n     assertTrue(NodeUtil.isLabelName(firstBreak.getFirstChild()));\n-    \n+\n     Node secondBreak = firstBreak.getNext();\n     assertTrue(secondBreak.getType() == Token.BREAK);\n     assertFalse(secondBreak.hasChildren());\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     otherPass = new CompilerPass() {\n       @Override public void process(Node externs, Node root) {\n         SymbolTable st = getLastCompiler().acquireSymbolTable();\n-        st.createScope(root, null);\n+        st.createScope(root.getParent(), null);\n         Node script = root.getFirstChild();\n         script.removeChild(script.getFirstChild());\n         st.release();\n \n     test(\"var x;\", null, SymbolTable.VARIABLE_COUNT_MISMATCH);\n   }\n+\n+  public void testSymbolTableWrongRoot() throws Exception {\n+    otherPass = new CompilerPass() {\n+      @Override public void process(Node externs, Node root) {\n+        SymbolTable st = getLastCompiler().acquireSymbolTable();\n+        st.createScope(root, null);\n+        st.release();\n+      }\n+    };\n+\n+    try {\n+      testSame(\"var x;\");\n+    } catch (IllegalArgumentException e) {\n+      assertEquals(\n+          \"May only create scopes for the global node and functions\",\n+          e.getMessage());\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n     public void process(Node externs, Node root) {\n       SymbolTable table = compiler.acquireSymbolTable();\n-      (new NodeTraversal(compiler, this, table)).traverse(root);\n+      (new NodeTraversal(compiler, this, table)).traverseRoots(externs, root);\n       table.release();\n     }\n \n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     test(\"while(1) { break; var x=1; var y=1}\",\n         \"var y; var x; while(1) { break } \");\n   }\n+\n+  public void testAssignPropertyOnCreatedObject() {\n+    testSame(\"this.foo = 3;\");\n+    testSame(\"a.foo = 3;\");\n+    testSame(\"bar().foo = 3;\");\n+    testSame(\"({}).foo = bar();\");\n+    testSame(\"(new X()).foo = 3;\");\n+\n+    test(\"({}).foo = 3;\", \"\");\n+    test(\"(function() {}).prototype.toString = function(){};\", \"\");\n+    test(\"(function() {}).prototype['toString'] = function(){};\", \"\");\n+    test(\"(function() {}).prototype[f] = function(){};\", \"\");\n+  }\n }", "timestamp": 1261419221, "metainfo": ""}