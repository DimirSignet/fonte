{"sha": "9d52e4fe146533053ad96d3cc29d54d05c869154", "log": "Fix a NPE case in RemoveUnusedVars by separating the node changes from the analysis phase  R=johnlenz DELTA=61  (29 added, 17 deleted, 15 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=880   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n     }\n     traverseAndRemoveUnusedReferences(root);\n+    if (callSiteOptimizer != null) {\n+      callSiteOptimizer.applyChanges();\n+    }\n   }\n \n   /**\n     // TODO(johnlenz): Update type registry for function signature changes.\n \n     Node function = fnScope.getRootNode();\n+\n     Preconditions.checkState(function.getType() == Token.FUNCTION);\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n       // The parameters object literal setters can not be removed.\n   private static class CallSiteOptimizer {\n     private final AbstractCompiler compiler;\n     private final SimpleDefinitionFinder defFinder;\n+    private final List<Node> toRemove = Lists.newArrayList();\n+    private final List<Node> toReplaceWithZero = Lists.newArrayList();\n \n     CallSiteOptimizer(\n         AbstractCompiler compiler,\n       // In this path we try to modify all the call sites to remove unused\n       // function parameters.\n       boolean changeCallSignature = canChangeSignature(function);\n-      removeUnreferencedFunctionArgs(\n+      markUnreferencedFunctionArgs(\n           fnScope, function, referenced,\n           argList.getFirstChild(), 0, changeCallSignature);\n+    }\n+\n+    /**\n+     * Applies optimizations to all previously marked nodes.\n+     */\n+    public void applyChanges() {\n+      for (Node n : toRemove) {\n+        n.getParent().removeChild(n);\n+        compiler.reportCodeChange();\n+      }\n+      for (Node n : toReplaceWithZero) {\n+        n.getParent().replaceChild(n, Node.newNumber(0).copyInformationFrom(n));\n+        compiler.reportCodeChange();\n+      }\n     }\n \n     /**\n      * @param canChangeSignature Whether function signature can be change.\n      * @return Whether there is a following function parameter.\n      */\n-    private boolean removeUnreferencedFunctionArgs(\n+    private boolean markUnreferencedFunctionArgs(\n         Scope scope, Node function, Set<Var> referenced,\n         Node param, int paramIndex,\n         boolean canChangeSignature) {\n       if (param != null) {\n         // Take care of the following siblings first.\n-        boolean hasFollowing = removeUnreferencedFunctionArgs(\n+        boolean hasFollowing = markUnreferencedFunctionArgs(\n             scope, function, referenced, param.getNext(), paramIndex+1,\n             canChangeSignature);\n \n           // Remove an unused function parameter if all the call sites can\n           // be modified to remove it, or if it is the last parameter.\n           if (modifyAllCallSites || !hasFollowing) {\n-            getFunctionArgList(function).removeChild(param);\n-            compiler.reportCodeChange();\n+            toRemove.add(param);\n             return hasFollowing;\n           }\n         }\n             if (canModifyAllSites\n                 || (arg.getNext() == null\n                     && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n-              // Remove the arg completely\n-              argParent.removeChild(arg);\n-              compiler.reportCodeChange();\n+              toRemove.add(arg);\n             } else {\n               // replace the node in the arg with 0\n               if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n                   && (arg.getType() != Token.NUMBER || arg.getDouble() != 0)) {\n-                argParent.replaceChild(\n-                    arg, Node.newNumber(0).copyInformationFrom(arg));\n-                compiler.reportCodeChange();\n+                toReplaceWithZero.add(arg);\n               }\n             }\n           }\n         if (!isModifableCallSite(site)) {\n           continue;\n         }\n-        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n+        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n         while (arg != null) {\n-          Node next = arg.getNext();\n-          if (next != null && !NodeUtil.mayHaveSideEffects(next)) {\n-            arg.getParent().removeChildAfter(arg);\n-            compiler.reportCodeChange();\n-          } else {\n-            arg = next;\n-          }\n+          if (!NodeUtil.mayHaveSideEffects(arg)) {\n+            toRemove.add(arg);\n+          }\n+          arg = arg.getNext();\n         }\n       }\n     }\n       Collection<UseSite> useSites = defFinder.getUseSites(definition);\n       for (UseSite site : useSites) {\n         Node parent = site.node.getParent();\n-\n-        // Check if the reference has already been removed.\n-        if (parent == null) {\n-          continue;\n-        }\n \n         // Ignore references within goog.inherits calls.\n         if (NodeUtil.isCall(parent) &&\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n \n public class RemoveUnusedVarsTest extends CompilerTestCase {\n \n-  private boolean removeGlobal = true;\n-  private boolean preserveFunctionExpressionNames = false;\n-  private boolean modifyCallSites = false;\n+  private boolean removeGlobal;\n+  private boolean preserveFunctionExpressionNames;\n+  private boolean modifyCallSites;\n \n   public RemoveUnusedVarsTest() {\n     super(\"function alert() {}\");\n   public void setUp() {\n     removeGlobal = true;\n     preserveFunctionExpressionNames = false;\n-    modifyCallSites = true;\n+    modifyCallSites = false;\n   }\n \n   @Override\n   }\n \n   public void testFunctionArgRemoval() {\n-    this.modifyCallSites = false;\n     // remove all function arguments\n     test(\"var b=function(c,d){return};b(1,2)\",\n          \"var b=function(){return};b(1,2)\");\n   }\n \n   public void testLocalVarReferencesGlobalVar2() {\n-    this.modifyCallSites = false;\n     test(\"var a=3;function f(b, c){b=a; alert(c);} f();\",\n          \"function f(b, c) { alert(c); } f();\");\n     this.modifyCallSites = true;\n         \"a(new b)\");\n   }\n \n+  public void testRemoveUnusedVarsPossibleNpeCase() {\n+    this.modifyCallSites = true;\n+    test(\"var a = [];\" +\n+        \"var register = function(callback) {a[0] = callback};\" +\n+        \"register(function(transformer) {});\" +\n+        \"register(function(transformer) {});\",\n+        \"var register=function(){};register();register()\");\n+  }\n+\n   public void testDoNotOptimizeJSCompiler_renameProperty() {\n     this.modifyCallSites = true;\n \n   }\n \n   public void testDoNotOptimizeSetters() {\n-    // this.removeGlobal = false;\n-    // this.modifyCallSites = false;\n     testSame(\"({set s(a) {}})\");\n   }\n ", "timestamp": 1300218162, "metainfo": ""}