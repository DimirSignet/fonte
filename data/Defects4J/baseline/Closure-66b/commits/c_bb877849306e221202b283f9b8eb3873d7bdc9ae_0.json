{"sha": "bb877849306e221202b283f9b8eb3873d7bdc9ae", "log": "More constant folding tweaks. - Remove extraneous unary \"+\" - Convert number to integer for BIT ops (not shift) - reduce literals in numberic contexts  R=nicksantos DELTA=275  (225 added, 30 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=319   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n         return tryFoldTypeof(subtree);\n \n       case Token.NOT:\n+      case Token.POS:\n       case Token.NEG:\n       case Token.BITNOT:\n+        tryReduceOperandsForOp(subtree);\n         return tryFoldUnaryOperator(subtree);\n \n       default:\n+        tryReduceOperandsForOp(subtree);\n         return tryFoldBinaryOperator(subtree);\n     }\n   }\n     }\n   }\n \n+  private void tryReduceOperandsForOp(Node n) {\n+    switch (n.getType()) {\n+      case Token.ADD:\n+        Node left = n.getFirstChild();\n+        Node right = n.getLastChild();\n+        if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) {\n+          tryConvertOperandsToNumber(n);\n+        }\n+        break;\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+        // TODO(johnlenz): convert these to integers.\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_DIV:\n+        tryConvertToNumber(n.getLastChild());\n+        break;\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+      case Token.POS:\n+      case Token.NEG:\n+        tryConvertOperandsToNumber(n);\n+        break;\n+    }\n+  }\n+\n+  private void tryConvertOperandsToNumber(Node n) {\n+    Node next;\n+    for (Node c = n.getFirstChild(); c != null; c = next) {\n+      next = c.getNext();\n+      tryConvertToNumber(c);\n+    }\n+  }\n+\n+  private void tryConvertToNumber(Node n) {\n+    switch (n.getType()) {\n+      case Token.NUMBER:\n+        // Nothing to do\n+        return;\n+      case Token.AND:\n+      case Token.OR:\n+      case Token.COMMA:\n+        tryConvertToNumber(n.getLastChild());\n+        return;\n+      case Token.HOOK:\n+        tryConvertToNumber(n.getChildAtIndex(1));\n+        tryConvertToNumber(n.getLastChild());\n+        return;\n+      case Token.NAME:\n+        if (!NodeUtil.isUndefined(n)) {\n+          return;\n+        }\n+        break;\n+    }\n+\n+    Double result = NodeUtil.getNumberValue(n);\n+    if (result == null) {\n+      return;\n+    }\n+\n+    double value = result;\n+\n+    Node replacement;\n+    if (Double.isNaN(value)) {\n+      replacement = Node.newString(Token.NAME, \"NaN\");\n+    } else if (value == Double.POSITIVE_INFINITY) {\n+      replacement = Node.newString(Token.NAME, \"Infinity\");\n+    } else if (value == Double.NEGATIVE_INFINITY) {\n+      replacement = new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n+      replacement.copyInformationFromForTree(n);\n+    } else {\n+      replacement = Node.newNumber(value);\n+    }\n+\n+    n.getParent().replaceChild(n, replacement);\n+    reportCodeChange();\n+  }\n+\n   /**\n    * Folds 'typeof(foo)' if foo is a literal, e.g.\n    * typeof(\"bar\") --> \"string\"\n         parent.replaceChild(n, replacementNode);\n         reportCodeChange();\n         return replacementNode;\n+      case Token.POS:\n+        if (NodeUtil.isNumericResult(left)) {\n+          // POS does nothing to numeric values.\n+          parent.replaceChild(n, left.detachFromParent());\n+          reportCodeChange();\n+          return left;\n+        }\n+        return n;\n       case Token.NEG:\n         try {\n           if (left.getType() == Token.NAME) {\n   private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n     Node result = performArithmeticOp(n.getType(), left, right);\n     if (result != null) {\n+      result.copyInformationFromForTree(n);\n       n.getParent().replaceChild(n, result);\n       reportCodeChange();\n       return result;\n \n     double result;\n \n+    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n+    // to zero so this is a little akward here.\n+\n     Double lValObj = NodeUtil.getNumberValue(left);\n     if (lValObj == null) {\n       return null;\n \n     switch (opType) {\n       case Token.BITAND:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result = (int)lval & (int)rval;\n+        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n         break;\n       case Token.BITOR:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result = (int)lval | (int)rval;\n+        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n         break;\n       case Token.BITXOR:\n-        if (!areValidInts(lval, rval)) {\n-          return null;\n-        }\n-        result = (int)lval ^ (int)rval;\n+        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n         break;\n       case Token.ADD:\n         result = lval + rval;\n   }\n \n   /**\n-   * @return Whether the double can be precisely represented as a int.\n-   */\n-  private boolean isValidInt(double val) {\n-    return !(val < Integer.MIN_VALUE || val > Integer.MAX_VALUE)\n-        && val == (int)val;\n-  }\n-\n-  /**\n-   * @return Whether the parameters are doubles can be precisely represented\n-   * as a int.\n-   */\n-  private boolean areValidInts(double val1, double val2) {\n-    return isValidInt(val1) && isValidInt(val2);\n-  }\n-\n-  /**\n    * Expressions such as [foo() * 10 * 20] generate parse trees\n    * where no node has two const children ((foo() * 10) * 20), so\n    * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\n    */\n   private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n     int opType = n.getType();\n-    // Note: ADD is not associative when used as a string concat operator.\n+    // TODO(johnlenz): Add support for ADD in numberic contexts.\n     Preconditions.checkState(\n       NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType));\n-    // TODO(johnlenz): create and use a getNumberValue.\n-    if (right.getType() == Token.NUMBER && left.getType() == opType) {\n+\n+    // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n+    // other values are converted to numbers elsewhere.\n+    Double rightValObj = NodeUtil.getNumberValue(right);\n+    if (rightValObj != null && left.getType() == opType) {\n       Preconditions.checkState(left.getChildCount() == 2);\n \n       Node ll = left.getFirstChild();\n       Node lr = ll.getNext();\n \n-      Node valueToCombine;\n-      if (ll.getType() == Token.NUMBER) {\n-        valueToCombine = ll;\n-      } else if (lr.getType() == Token.NUMBER) {\n+      Node valueToCombine = ll;\n+      Node replacement = performArithmeticOp(opType, valueToCombine, right);\n+      if (replacement == null) {\n         valueToCombine = lr;\n-      } else {\n-        // Nothing to do.\n-        return n;\n-      }\n-\n-      Node replacement = performArithmeticOp(opType, valueToCombine, right);\n+        replacement = performArithmeticOp(opType, valueToCombine, right);\n+      }\n       if (replacement != null) {\n+        // Remove the child that has been combined\n         left.removeChild(valueToCombine);\n+        // Replace the left op with the remaining child.\n         n.replaceChild(left, left.removeFirstChild());\n+        // New \"-Infinity\" node need location info explicitly\n+        // added.\n+        replacement.copyInformationFromForTree(right);\n         n.replaceChild(right, replacement);\n         reportCodeChange();\n       }\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"a=~~0\", \"a=0\");\n     fold(\"a=~~10\", \"a=10\");\n     fold(\"a=~-7\", \"a=6\");\n+\n+    fold(\"a=+true\", \"a=1\");\n+    fold(\"a=+10\", \"a=10\");\n+    fold(\"a=+false\", \"a=0\");\n+    foldSame(\"a=+foo()\");\n+    foldSame(\"a=+f\");\n+    fold(\"a=+(f?true:false)\", \"a=+(f?1:0)\"); // TODO(johnlenz): foldable\n+    fold(\"a=+0\", \"a=0\");\n+    fold(\"a=+Infinity\", \"a=Infinity\");\n+    fold(\"a=+NaN\", \"a=NaN\");\n+    fold(\"a=+-7\", \"a=-7\");\n+    fold(\"a=+.5\", \"a=.5\");\n+\n     fold(\"a=~0x100000000\", \"a=~0x100000000\",\n          PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     fold(\"a=~-0x100000000\", \"a=~-0x100000000\",\n     fold(\"x = 3 || x\", \"x = 3\");\n     fold(\"x = false || 0\", \"x = 0\");\n \n-    // surprisingly unfoldable\n+    // unfoldable, because the right-side may be the result\n     fold(\"a = x && true\", \"a=x&&true\");\n     fold(\"a = x && false\", \"a=x&&false\");\n     fold(\"a = x || 3\", \"a=x||3\");\n \n     // make sure we fold only when we are supposed to -- not when doing so would\n     // lose information or when it is performed on nonsensical arguments.\n-    fold(\"x = 1 & 1.1\", \"x = 1&1.1\");\n-    fold(\"x = 1.1 & 1\", \"x = 1.1&1\");\n-    fold(\"x = 1 & 3000000000\", \"x = 1&3000000000\");\n-    fold(\"x = 3000000000 & 1\", \"x = 3000000000&1\");\n+    fold(\"x = 1 & 1.1\", \"x = 1\");\n+    fold(\"x = 1.1 & 1\", \"x = 1\");\n+    fold(\"x = 1 & 3000000000\", \"x = 0\");\n+    fold(\"x = 3000000000 & 1\", \"x = 0\");\n \n     // Try some cases with | as well\n     fold(\"x = 1 | 4\", \"x = 5\");\n     fold(\"x = 1 | 3\", \"x = 3\");\n-    fold(\"x = 1 | 1.1\", \"x = 1|1.1\");\n-    fold(\"x = 1 | 3000000000\", \"x = 1|3000000000\");\n+    fold(\"x = 1 | 1.1\", \"x = 1\");\n+    foldSame(\"x = 1 | 3E9\");\n+    fold(\"x = 1 | 3000000001\", \"x = -1294967295\");\n   }\n \n   public void testFoldBitwiseOp2() {\n     fold(\"x = 3 ^ y ^ 1\", \"x = y ^ 2\");\n     fold(\"x = y ^ 3 ^ 3\", \"x = y ^ 0\");\n     fold(\"x = 3 ^ y ^ 3\", \"x = y ^ 0\");\n+\n+    fold(\"x = Infinity | NaN\", \"x=0\");\n+    fold(\"x = 12 | NaN\", \"x=12\");\n+  }\n+\n+  public void testFoldingMixTypes() {\n+    fold(\"x = x + '2'\", \"x+='2'\");\n+    fold(\"x = +x + +'2'\", \"x = +x + 2\");\n+    fold(\"x = x - '2'\", \"x-=2\");\n+    fold(\"x = x ^ '2'\", \"x^=2\");\n+    fold(\"x = '2' ^ x\", \"x^=2\");\n+    fold(\"x = '2' & x\", \"x&=2\");\n+    fold(\"x = '2' | x\", \"x|=2\");\n+\n+    fold(\"x = '2' | y\", \"x=2|y\");\n+    fold(\"x = y | '2'\", \"x=y|2\");\n+    fold(\"x = y | (a && '2')\", \"x=y|(a&&2)\");\n+    fold(\"x = y | (a,'2')\", \"x=y|(a,2)\");\n+    fold(\"x = y | (a?'1':'2')\", \"x=y|(a?1:2)\");\n+    fold(\"x = y | ('x'?'1':'2')\", \"x=y|('x'?1:2)\");\n+  }\n+\n+  public void testFoldingAdd() {\n+    fold(\"x = null + true\", \"x=1\");\n+    foldSame(\"x = a + true\");\n   }\n \n   public void testFoldBitwiseOpStringCompare() {\n     fold(\"x = null * undefined\", \"x = NaN\");\n     fold(\"x = null * 1\", \"x = 0\");\n     fold(\"x = (null - 1) * 2\", \"x = -2\");\n-    foldSame(\"x = (null + 1) * 2\"); // We don't fold \"+\" with mixed types yet.\n+    fold(\"x = (null + 1) * 2\", \"x = 2\");\n+  }\n+\n+  public void testFoldArithmeticInfinity() {\n+    fold(\"x=-Infinity-2\", \"x=-Infinity\");\n+    fold(\"x=Infinity-2\", \"x=Infinity\");\n+    fold(\"x=Infinity*5\", \"x=Infinity\");\n   }\n \n   public void testFoldArithmeticStringComp() {\n     fold(\"x = (3 / 1.0) + (1 * 2)\", \"x = 5\");\n     fold(\"x = (1 == 1.0) && foo() && true\", \"x = foo()&&true\");\n     fold(\"x = 'abc' + 5 + 10\", \"x = \\\"abc510\\\"\");\n+  }\n+\n+  public void testFoldLeft() {\n+    foldSame(\"(+x - 1) + 2\"); // not yet\n+    foldSame(\"(+x + 1) + 2\"); // not yet\n   }\n \n   public void testFoldArrayLength() {\n   }\n \n   public void testFoldAdd1() {\n-    foldSame(\"x=false+1\");\n+    fold(\"x=false+1\",\"x=1\");\n+    fold(\"x=true+1\",\"x=2\");\n+    fold(\"x=1+false\",\"x=1\");\n+    fold(\"x=1+true\",\"x=2\");\n   }\n \n   public void testFoldLiteralNames() {\n     fold(\"true <= false\", \"false\");\n     fold(\"true > false\", \"true\");\n     fold(\"true < false\", \"false\");\n+  }\n+\n+  public void testFoldLeftChildConcat() {\n+    foldSame(\"x +5 + \\\"1\\\"\");\n+    fold(\"x+\\\"5\\\" + \\\"1\\\"\", \"x + \\\"51\\\"\");\n+  }\n+\n+  public void testFoldLeftChildOp() {\n+    fold(\"x * Infinity * 2\", \"x * Infinity\");\n+    foldSame(\"x - Infinity - 2\"); // want \"x-Infinity\"\n+    foldSame(\"x - 1 + Infinity\");\n+    foldSame(\"x - 2 + 1\");\n+    foldSame(\"x - 2 + 3\");\n+    foldSame(\"1 + x - 2 + 1\");\n+    foldSame(\"1 + x - 2 + 3\");\n+    foldSame(\"1 + x - 2 + 3 - 1\");\n+    foldSame(\"f(x)-0\");\n+    foldSame(\"x-0-0\");\n+    foldSame(\"x+2-2+2\");\n+    foldSame(\"x+2-2+2-2\");\n+    foldSame(\"x-2+2\");\n+    foldSame(\"x-2+2-2\");\n+    foldSame(\"x-2+2-2+2\");\n+\n+    foldSame(\"1+x-0-NaN\");\n+    foldSame(\"1+f(x)-0-NaN\");\n+    foldSame(\"1+x-0+NaN\");\n+    foldSame(\"1+f(x)-0+NaN\");\n+\n+    foldSame(\"1+x+NaN\"); // unfoldable\n+    foldSame(\"x+2-2\");   // unfoldable\n+    foldSame(\"x+2\");  // nothing to do\n+    foldSame(\"x-2\");  // nothing to do\n+  }\n+\n+  public void testFoldSimpleArithmeticOp() {\n+    foldSame(\"x*NaN\");\n+    foldSame(\"NaN/y\");\n+    foldSame(\"f(x)-0\");\n+    foldSame(\"f(x)*1\");\n+    foldSame(\"1*f(x)\");\n+    foldSame(\"0+a+b\");\n+    foldSame(\"0-a-b\");\n+    foldSame(\"a+b-0\");\n+    foldSame(\"(1+x)*NaN\");\n+\n+    foldSame(\"(1+f(x))*NaN\"); // don't fold side-effects\n+  }\n+\n+  public void testFoldLiteralsAsNumbers() {\n+    fold(\"x/'12'\",\"x/12\");\n+    fold(\"x/('12'+'6')\", \"x/126\");\n+    fold(\"true*x\", \"1*x\");\n+    fold(\"x/false\", \"x/0\");  // should we add an error check? :)\n   }\n \n   private static final List<String> LITERAL_OPERANDS =\n           \"0\",\n           \"1\",\n           \"''\",\n+          \"'123'\",\n           \"'abc'\",\n           \"'def'\",\n           \"NaN\",\n           \"Infinity\"\n           // TODO(nicksantos): Add more literals\n+          //-Infinity\n           //\"({})\",\n           //\"[]\",\n           //\"[0]\",", "timestamp": 1295479366, "metainfo": ""}