{"sha": "c9e89727dc8063d087d28e42629606f4fd74a6e5", "log": "Change on 2010/06/22 by nicksantos  \tvariable coalescing better be run AFTER ambiguate properties, and \tafter denormalization.  \tR=johnlenz \tDELTA=36  (20 added, 16 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=34005   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n   \n   /**\n+   *  Is the current AST normalized? (e.g. has the Normalize pass been run\n+   *  and has the Denormalize pass not yet been run?) \n+   */\n+  protected boolean isASTNormalized() {\n+    Preconditions.checkNotNull(currentTraversal);\n+    Preconditions.checkNotNull(currentTraversal.getCompiler());\n+    \n+    return currentTraversal.getCompiler().isNormalized();\n+  }\n+  \n+  /**\n    * Informs the optimization that a traversal will begin.  \n    */\n   void beginTraversal(NodeTraversal traversal) {\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n \n   AmbiguateProperties(AbstractCompiler compiler,\n       char[] reservedCharacters) {\n+    Preconditions.checkState(compiler.isNormalized());\n     this.compiler = compiler;\n     this.reservedCharacters = reservedCharacters;\n \n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n    * to foo, rename both variable to foo_bar.\n    */\n   CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n+    Preconditions.checkState(!compiler.isNormalized());\n+\n     this.compiler = compiler;\n     colorings = Lists.newLinkedList();\n     this.usePseudoNames = usePseudoNames;\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;\n-      if (x >= 100) {\n+      if (Math.abs(x) >= 100) {\n         while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n           mantissa /= 10;\n           exp++;\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n       case Token.DEC: {\n         Preconditions.checkState(childCount == 1);\n         String o = type == Token.INC ? \"++\" : \"--\";\n-        int postProp = n.getIntProp(Node.INCRDECR_PROP, 0);\n+        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n         // A non-zero post-prop value indicates a post inc/dec, default of zero\n         // is a pre-inc/dec.\n         if (postProp != 0) {\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n   private final Set<Node> nodesToCollapse = Sets.newHashSet();\n \n   CollapseVariableDeclarations(AbstractCompiler compiler) {\n+    Preconditions.checkState(!compiler.isNormalized());\n     this.compiler = compiler;\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     logger.info(\"Normalizing\");\n     startPass(\"normalize\");\n     process(new Normalize(this, false));\n-    setNormalized();\n     endPass();\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(extractPrototypeMemberDeclarations);\n     }\n \n-    if (options.coalesceVariableNames) {\n-      passes.add(coalesceVariableNames);\n-    }\n-\n     if (options.ambiguateProperties &&\n         (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n       passes.add(ambiguateProperties);\n       passes.add(aliasKeywords);\n     }\n \n+    passes.add(denormalize);\n+\n+    if (options.coalesceVariableNames) {\n+      passes.add(coalesceVariableNames);\n+    }\n+\n     if (options.collapseVariableDeclarations) {\n       passes.add(collapseVariableDeclarations);\n     }\n-\n-    passes.add(denormalize);\n \n     if (options.instrumentationTemplate != null) {\n       passes.add(instrumentFunctions);\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(),\n-            new PeepholeRemoveDeadCode());\n+            new PeepholeRemoveDeadCode(),\n+            new PeepholeFoldConstants());\n     }\n   };\n \n       new PassFactory(\"collapseVariableDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      compiler.setUnnormalized();\n       return new CollapseVariableDeclarations(compiler);\n     }\n   };\n       new PassFactory(\"groupVariableDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      compiler.setNormalized();\n       return new GroupVariableDeclarations(compiler);\n     }\n   };\n       new PassFactory(\"denormalize\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      compiler.setUnnormalized();\n       return new Denormalize(compiler);\n     }\n   };\n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+    compiler.setUnnormalized();\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.TernaryValue;\n-\n-import java.util.List;\n \n /**\n  * FoldConstants simplifies expressions which consist only of constants,\n class FoldConstants extends AbstractPostOrderCallback\n     implements CompilerPass {\n \n-  static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(\n-      \"JSC_DIVIDE_BY_0_ERROR\",\n-      \"Divide by 0\");\n-\n-  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n-      DiagnosticType.error(\n-          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n-          \"Array index not integer: {0}\");\n-\n-  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n-      DiagnosticType.error(\n-          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n-          \"Array index out of bounds: {0}\");\n-\n-  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n-      DiagnosticType.error(\n-          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n-          \"Can't negate non-numeric value: {0}\");\n-\n-  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n-      DiagnosticType.error(\n-          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n-          \"Operand out of range, bitwise operation will lose information: {0}\");\n-\n-  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n-      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n-      \"Shift amount out of bounds: {0}\");\n-\n-  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n-      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n-      \"Fractional bitwise operand: {0}\");\n-\n-  private final AbstractCompiler compiler;\n-\n   FoldConstants(AbstractCompiler compiler) {\n-    this.compiler = compiler;\n   }\n \n   public void process(Node externs, Node jsRoot) {\n-    NodeTraversal.traverse(compiler, jsRoot, this);\n+  \n   }\n \n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    int type = n.getType();\n-\n-    Node left = n.getFirstChild();\n-    if (left == null) {\n-      return;\n-    }\n-\n-    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {\n-      String newValue = null;\n-\n-      switch (left.getType()) {\n-        case Token.STRING:\n-          newValue = \"string\";\n-          break;\n-        case Token.NUMBER:\n-          newValue = \"number\";\n-          break;\n-        case Token.TRUE:\n-        case Token.FALSE:\n-          newValue = \"boolean\";\n-          break;\n-        case Token.NULL:\n-        case Token.OBJECTLIT:\n-        case Token.ARRAYLIT:\n-          newValue = \"object\";\n-          break;\n-        case Token.NAME:\n-          // We assume here that programs don't change the value of the\n-          // keyword undefined to something other than the value undefined.\n-          if (\"undefined\".equals(left.getString())) {\n-            newValue = \"undefined\";\n-          }\n-          break;\n-      }\n-\n-      if (newValue != null) {\n-        parent.replaceChild(n, Node.newString(newValue));\n-        t.getCompiler().reportCodeChange();\n-      }\n-\n-      return;\n-    }\n-\n-    if (type == Token.NOT ||\n-        type == Token.NEG ||\n-        type == Token.BITNOT) {\n-        Preconditions.checkState(n.hasOneChild());\n-\n-        if (NodeUtil.isExpressionNode(parent)) {\n-          // If the value of the NOT isn't used, then just throw\n-          // away the operator\n-          parent.replaceChild(n, n.removeFirstChild());\n-          t.getCompiler().reportCodeChange();\n-          return;\n-        }\n-\n-        TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n-        if (leftVal == TernaryValue.UNKNOWN) {\n-          return;\n-        }\n-\n-        switch (type) {\n-          case Token.NOT:\n-            int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;           \n-            parent.replaceChild(n, new Node(result));\n-            t.getCompiler().reportCodeChange();\n-            break;\n-\n-          case Token.NEG:\n-            try {\n-              if (left.getType() == Token.NAME) {\n-                if (left.getString().equals(\"Infinity\")) {\n-                  // \"-Infinity\" is valid and a literal, don't modify it.\n-                  return;\n-                } else if (left.getString().equals(\"NaN\")) {\n-                  // \"-NaN\" is \"NaN\".\n-                  n.removeChild(left);\n-                  parent.replaceChild(n, left);\n-                  t.getCompiler().reportCodeChange();\n-                  return;\n-                }\n-              }\n-\n-              double negNum = -left.getDouble();\n-              parent.replaceChild(n, Node.newNumber(negNum));\n-              t.getCompiler().reportCodeChange();\n-            } catch (UnsupportedOperationException ex) {\n-              // left is not a number node, so do not replace, but warn the\n-              // user because they can't be doing anything good\n-              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n-            }\n-            break;\n-\n-          case Token.BITNOT:\n-            try {\n-              double val = left.getDouble();\n-              if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n-                int intVal = (int) val;\n-                if (intVal == val) {\n-                  parent.replaceChild(n, Node.newNumber(~intVal));\n-                  t.getCompiler().reportCodeChange();\n-                } else {\n-                  error(t, FRACTIONAL_BITWISE_OPERAND, left);\n-                }\n-              } else {\n-                error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);\n-              }\n-            } catch (UnsupportedOperationException ex) {\n-              // left is not a number node, so do not replace, but warn the\n-              // user because they can't be doing anything good\n-              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n-            }\n-            break;\n-        }\n-        return;\n-    } \n-\n-    if (type == Token.NEW) {\n-      tryFoldStandardConstructors(t, n);\n-\n-      // The type might have changed from NEW to CALL, update it\n-      // and continue.\n-      type = n.getType();\n-    }\n-\n-    if (type == Token.NEW || type == Token.CALL) {\n-      if (Token.NAME == left.getType() && left.getNext() == null) {\n-        String className = left.getString();\n-        if (\"Array\".equals(className)) {\n-          if (tryFoldLiteralConstructor(\n-              t, n, parent, className, Token.ARRAYLIT)) {\n-            return;\n-          }\n-        } else if (\"Object\".equals(className)) {\n-          if (tryFoldLiteralConstructor(\n-              t, n, parent, className, Token.OBJECTLIT)) {\n-            return;\n-          }\n-        }\n-      }\n-    }\n-\n-    if (type == Token.EXPR_RESULT) {\n-        return;\n-    }\n-  \n-    if (type == Token.RETURN) {\n-      return;\n-    }\n-\n-    Node right = left.getNext();\n-    if (right == null) {\n-      return;\n-    }\n-\n-    // TODO(johnlenz) Use type information if available to fold\n-    // instanceof.\n-    if (type == Token.INSTANCEOF\n-        && NodeUtil.isLiteralValue(left)\n-        && !NodeUtil.mayHaveSideEffects(right)) {\n-      if (NodeUtil.isImmutableValue(left)) {\n-        // Non-object types are never instances.\n-        parent.replaceChild(n, new Node(Token.FALSE));\n-        t.getCompiler().reportCodeChange();\n-        return;\n-      }\n-\n-      if (right.getType() == Token.NAME\n-          && \"Object\".equals(right.getString())) {\n-        parent.replaceChild(n, new Node(Token.TRUE));\n-        t.getCompiler().reportCodeChange();\n-        return;\n-      }\n-    }\n-\n-    if (type == Token.AND ||\n-        type == Token.OR) {\n-      tryFoldAndOr(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.BITOR ||\n-        type == Token.BITAND) {\n-      tryFoldBitAndOr(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.LSH ||\n-        type == Token.RSH ||\n-        type == Token.URSH) {\n-      tryFoldShift(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.GETPROP) {\n-      tryFoldGetProp(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.CALL) {\n-      tryFoldStringJoin(t, n, left, right, parent);\n-      tryFoldStringIndexOf(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.ASSIGN) {\n-      tryFoldAssign(t, n, left, right);\n-    }\n-\n-    if (!NodeUtil.isLiteralValue(left) ||\n-        !NodeUtil.isLiteralValue(right)) {\n-\n-      if (type == Token.ADD)\n-        tryFoldLeftChildAdd(t, n, left, right, parent);\n-\n-      if (type == Token.LT ||\n-          type == Token.GT) {\n-        tryFoldComparison(t, n, left, right, parent);\n-      }\n-\n-      return; // The subsequent ops only work if the LHS & RHS are consts\n-    }\n-\n-    if (type == Token.ADD) {\n-      tryFoldAdd(t, n, left, right, parent);\n-      return;\n-    }\n-    if (type == Token.SUB ||\n-        type == Token.MUL ||\n-        type == Token.DIV) {\n-      tryFoldArithmetic(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.LT ||\n-        type == Token.GT ||\n-        type == Token.LE ||\n-        type == Token.GE ||\n-        type == Token.EQ ||\n-        type == Token.NE ||\n-        type == Token.SHEQ ||\n-        type == Token.SHNE) {\n-      tryFoldComparison(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.GETELEM) {\n-      tryFoldGetElem(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    // other types aren't handled\n+    \n   }\n \n-  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n-    // String, Number, and Boolean functions return non-object types, whereas\n-    // new String, new Number, and new Boolean return object types, so don't\n-    // include them here.\n-    ImmutableSet.of(\n-      \"Object\",\n-      \"Array\",\n-      \"RegExp\",\n-      \"Error\"\n-      );\n-  \n-  /**\n-   * Fold \"new Object()\" to \"Object()\".\n-   */\n-  private void tryFoldStandardConstructors(NodeTraversal t, Node n) {\n-    Preconditions.checkState(n.getType() == Token.NEW);\n-    \n-    if (n.getFirstChild().getType() == Token.NAME) {\n-      String className = n.getFirstChild().getString();\n-      if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n-        // The var check isn't really needed here due to name normalizations\n-        // but we do it here to simplify unit testing.\n-        Scope.Var var = t.getScope().getVar(className);\n-        if (var == null || var.isGlobal()) {\n-          n.setType(Token.CALL);\n-          compiler.reportCodeChange();\n-        }    \n-      }\n-    }\n-  }\n-\n-  private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n-    t.getCompiler().report(t.makeError(n, diagnostic, n.toString()));\n-  }\n-\n-  private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n-\n-    // Tries to convert x = x + y -> x += y;\n-    if (!right.hasChildren() ||\n-        right.getFirstChild().getNext() != right.getLastChild()) {\n-      // RHS must have two children.\n-      return;\n-    }\n-\n-    if (NodeUtil.mayHaveSideEffects(left)) {\n-      return;\n-    }\n-\n-    Node leftChild = right.getFirstChild();\n-    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n-      return;\n-    }\n-\n-    int newType = -1;\n-    switch (right.getType()) {\n-      case Token.ADD:\n-        newType = Token.ASSIGN_ADD;\n-        break;\n-      case Token.BITAND:\n-        newType = Token.ASSIGN_BITAND;\n-        break;\n-      case Token.BITOR:\n-        newType = Token.ASSIGN_BITOR;\n-        break;\n-      case Token.BITXOR:\n-        newType = Token.ASSIGN_BITXOR;\n-        break;\n-      case Token.DIV:\n-        newType = Token.ASSIGN_DIV;\n-        break;\n-      case Token.LSH:\n-        newType = Token.ASSIGN_LSH;\n-        break;\n-      case Token.MOD:\n-        newType = Token.ASSIGN_MOD;\n-        break;\n-      case Token.MUL:\n-        newType = Token.ASSIGN_MUL;\n-        break;\n-      case Token.RSH:\n-        newType = Token.ASSIGN_RSH;\n-        break;\n-      case Token.SUB:\n-        newType = Token.ASSIGN_SUB;\n-        break;\n-      case Token.URSH:\n-        newType = Token.ASSIGN_URSH;\n-        break;\n-      default:\n-        return;\n-    }\n-\n-    n.getParent().replaceChild(n, new Node(newType,\n-        left.detachFromParent(), right.getLastChild().detachFromParent()));\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-\n-   * Try to fold a AND/OR node.\n-   */\n-  void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right,\n-                    Node parent) {\n-    Node result = null;\n-\n-    int type = n.getType();\n-   \n-    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n-\n-    if (leftVal != TernaryValue.UNKNOWN) {\n-      boolean lval = leftVal.toBoolean(true);\n-\n-      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n-      // (FALSE && x) => FALSE\n-      if (lval && type == Token.OR ||\n-          !lval && type == Token.AND) {\n-        result = left;\n-\n-      } else {\n-        // (FALSE || x) => x\n-        // (TRUE && x) => x\n-        result = right;\n-      }\n-    } else {\n-      TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n-      if (rightVal != TernaryValue.UNKNOWN) {\n-  \n-      // Note: We cannot always fold when the constant is on the\n-      // right, because the typed value of the expression will depend\n-      // on the type of the constant on the right, even if the boolean\n-      // equivalent of the value does not. Specifically, in \"a = x ||\n-      // 0\", a will be numeric 0 if x is undefined (and hence is\n-      // e.g. a valid array index). However, it is safe to fold\n-      // e.g. \"if (x || true)\" because 'if' doesn't care if the\n-      // expression is 'true' or '3'.\n-      int pt = parent.getType();\n-      if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n-          (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n-          (pt == Token.HOOK && parent.getFirstChild() == n)) {\n-        boolean rval = rightVal.toBoolean(true);\n-\n-        // (x || FALSE) => x\n-        // (x && TRUE) => x\n-        if (type == Token.OR && !rval ||\n-            type == Token.AND && rval) {\n-          result = left;\n-        } else {\n-          // If x has no side-effects:\n-          //   (x || TRUE) => TRUE\n-          //   (x && FALSE) => FALSE\n-          if (!NodeUtil.mayHaveSideEffects(left)) {\n-            result = right;\n-          }\n-        }\n-        }\n-      }\n-    }\n-\n-    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so\n-    // there is not much need to worry about const values on left's\n-    // right child.\n-\n-    if (result != null) {\n-      // Fold it!\n-      n.removeChild(result);\n-      parent.replaceChild(n, result);\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n-   * where no node has two const children ((foo() + 'a') + 'b'), so\n-   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n-   * Specifically it folds Add exprssions where:\n-   *  - The left child is also and add expression\n-   *  - The right child is a constant value\n-   *  - The left child's right child is a STRING constant.\n-   *\n-   * WARNING: If javascript ever adds operator overloading, this will\n-   * probably stop being correct.\n-   */\n-  void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right,\n-                           Node parent) {\n-\n-    if (NodeUtil.isLiteralValue(right) &&\n-        left.getType() == Token.ADD &&\n-        left.getChildCount() == 2) {\n-\n-      Node ll = left.getFirstChild();\n-      Node lr = ll.getNext();\n-\n-      // Left's right child MUST be a string. We would not want to fold\n-      // foo() + 2 + 'a' because we don't know what foo() will return, and\n-      // therefore we don't know if left is a string concat, or a numeric add.\n-      if (lr.getType() != Token.STRING)\n-        return;\n-\n-      String leftString = NodeUtil.getStringValue(lr);\n-      String rightString = NodeUtil.getStringValue(right);\n-      if (leftString != null && rightString != null) {\n-        left.removeChild(ll);\n-        String result = leftString + rightString;\n-        n.replaceChild(left, ll);\n-        n.replaceChild(right, Node.newString(result));\n-        t.getCompiler().reportCodeChange();\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Try to fold a ADD node\n-   */\n-  void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right,\n-                  Node parent) {\n-    if (left.getType() == Token.STRING ||\n-        right.getType() == Token.STRING) {\n-\n-      // Add strings.\n-      String leftString = NodeUtil.getStringValue(left);\n-      String rightString = NodeUtil.getStringValue(right);\n-      if (leftString != null && rightString != null) {\n-        parent.replaceChild(n, Node.newString(leftString + rightString));\n-        t.getCompiler().reportCodeChange();\n-      }\n-    } else {\n-      // Try arithmetic add\n-      tryFoldArithmetic(t, n, left, right, parent);\n-    }\n-  }\n-\n-  /**\n-   * Try to fold arithmetic binary operators\n-   */\n-  void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right,\n-                         Node parent) {\n-\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-      double result;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      switch (n.getType()) {\n-        case Token.ADD:\n-          result = lval + rval;\n-          break;\n-        case Token.SUB:\n-          result = lval - rval;\n-          break;\n-        case Token.MUL:\n-          result = lval * rval;\n-          break;\n-        case Token.DIV:\n-          if (rval == 0) {\n-            error(t, DIVIDE_BY_0_ERROR, right);\n-            return;\n-          }\n-          result = lval / rval;\n-          break;\n-        default:\n-          throw new Error(\"Unknown arithmetic operator\");\n-      }\n-\n-      // length of the left and right value plus 1 byte for the operator.\n-      if (String.valueOf(result).length() <=\n-          String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-        parent.replaceChild(n, Node.newNumber(result));\n-        t.getCompiler().reportCodeChange();\n-      }\n-   }\n-  }\n-\n-  /**\n-   * Try to fold arithmetic binary operators\n-   */\n-  void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right,\n-                       Node parent) {\n-\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-      double result;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      // For now, we are being extra conservative, and only folding ints in\n-      // the range MIN_VALUE-MAX_VALUE\n-      if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n-          rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n-\n-        // Fall back through and let the javascript use the larger values\n-        return;\n-      }\n-\n-      // Convert the numbers to ints\n-      int lvalInt = (int) lval;\n-      if (lvalInt != lval) {\n-        return;\n-      }\n-\n-      int rvalInt = (int) rval;\n-      if (rvalInt != rval) {\n-        return;\n-      }\n-\n-      switch (n.getType()) {\n-        case Token.BITAND:\n-          result = lvalInt & rvalInt;\n-          break;\n-        case Token.BITOR:\n-          result = lvalInt | rvalInt;\n-          break;\n-        default:\n-          throw new Error(\"Unknown bitwise operator\");\n-      }\n-      parent.replaceChild(n, Node.newNumber(result));\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Try to fold shift operations\n-   */\n-  void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,\n-                    Node parent) {\n-\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-\n-      double result;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      // check ranges.  We do not do anything that would clip the double to\n-      // a 32-bit range, since the user likely does not intend that.\n-      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n-        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);\n-        return;\n-      }\n-\n-      // only the lower 5 bits are used when shifting, so don't do anything\n-      // if the shift amount is outside [0,32)\n-      if (!(rval >= 0 && rval < 32)) {\n-        error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n-        return;\n-      }\n-\n-      // Convert the numbers to ints\n-      int lvalInt = (int) lval;\n-      if (lvalInt != lval) {\n-        error(t, FRACTIONAL_BITWISE_OPERAND, left);\n-        return;\n-      }\n-\n-      int rvalInt = (int) rval;\n-      if (rvalInt != rval) {\n-        error(t, FRACTIONAL_BITWISE_OPERAND, right);\n-        return;\n-      }\n-\n-      switch (n.getType()) {\n-        case Token.LSH:\n-          result = lvalInt << rvalInt;\n-          break;\n-        case Token.RSH:\n-          result = lvalInt >> rvalInt;\n-          break;\n-        case Token.URSH:\n-          result = lvalInt >>> rvalInt;\n-          break;\n-        default:\n-          throw new AssertionError(\"Unknown shift operator: \" +\n-              Node.tokenToName(n.getType()));\n-      }\n-      parent.replaceChild(n, Node.newNumber(result));\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Try to fold comparison nodes, e.g ==\n-   */\n-  @SuppressWarnings(\"fallthrough\")\n-  void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right,\n-                         Node parent) {\n-\n-    int op = n.getType();\n-    boolean result;\n-\n-    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n-\n-    boolean rightLiteral = NodeUtil.isLiteralValue(right);\n-    boolean undefinedRight = ((Token.NAME == right.getType()\n-          && right.getString().equals(\"undefined\"))\n-          || (Token.VOID == right.getType()\n-              && NodeUtil.isLiteralValue(right.getFirstChild())));\n-\n-    switch (left.getType()) {\n-      case Token.VOID:\n-        if (!NodeUtil.isLiteralValue(left.getFirstChild())) {\n-          return;\n-        } else if (!rightLiteral) {\n-          return;\n-        } else {\n-          boolean nullRight = (Token.NULL == right.getType());\n-          boolean equivalent = undefinedRight || nullRight;\n-          switch (op) {\n-            case Token.EQ:\n-              // undefined is only equal to\n-              result = equivalent;\n-              break;\n-            case Token.NE:\n-              result = !equivalent;\n-              break;\n-            case Token.SHEQ:\n-              result = undefinedRight;\n-              break;\n-            case Token.SHNE:\n-              result = !undefinedRight;\n-              break;\n-            case Token.LT:\n-            case Token.GT:\n-            case Token.LE:\n-            case Token.GE:\n-              result = false;\n-              break;\n-            default:\n-              return;\n-          }\n-        }\n-        break;\n-\n-      case Token.NULL:\n-        if (undefinedRight) {\n-          result = (op == Token.EQ);\n-          break;\n-        }\n-        // fall through\n-      case Token.TRUE:\n-      case Token.FALSE:\n-        if (undefinedRight) {\n-          result = false;\n-          break;\n-        }\n-        // fall through\n-      case Token.THIS:\n-        int tt = right.getType();\n-        if (tt != Token.THIS &&\n-            tt != Token.TRUE &&\n-            tt != Token.FALSE &&\n-            tt != Token.NULL)\n-          return;\n-        switch (op) {\n-          case Token.SHEQ:\n-          case Token.EQ:\n-            result = left.getType() == right.getType();\n-            break;\n-\n-          case Token.SHNE:\n-          case Token.NE:\n-            result = left.getType() != right.getType();\n-            break;\n-\n-          default:\n-            return;  // we only handle == and != here\n-        }\n-        break;\n-\n-      case Token.STRING:\n-        if (undefinedRight) {\n-          result = false;\n-          break;\n-        }\n-        if (Token.STRING != right.getType()) {\n-          return;  // Only eval if they are the same type\n-        }\n-        switch (op) {\n-          case Token.SHEQ:\n-          case Token.EQ:\n-            result = left.getString().equals(right.getString());\n-            break;\n-\n-          case Token.SHNE:\n-          case Token.NE:\n-            result = !left.getString().equals(right.getString());\n-            break;\n-\n-          default:\n-            return;  // we only handle == and != here\n-        }\n-        break;\n-\n-      case Token.NUMBER:\n-        if (undefinedRight) {\n-          result = false;\n-          break;\n-        }\n-        if (Token.NUMBER != right.getType()) {\n-          return;  // Only eval if they are the same type\n-        }\n-        double lv = left.getDouble();\n-        double rv = right.getDouble();\n-\n-        switch (op) {\n-          case Token.SHEQ:\n-          case Token.EQ: result = lv == rv; break;\n-          case Token.SHNE:\n-          case Token.NE: result = lv != rv; break;\n-          case Token.LE: result = lv <= rv; break;\n-          case Token.LT: result = lv <  rv; break;\n-          case Token.GE: result = lv >= rv; break;\n-          case Token.GT: result = lv >  rv; break;\n-          default:\n-            return;  // don't handle that op\n-        }\n-        break;\n-\n-      case Token.NAME:\n-        if (rightLiteral) {\n-          boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n-          if (undefinedLeft) {\n-            boolean nullRight = (Token.NULL == right.getType());\n-            boolean equivalent = undefinedRight || nullRight;\n-            switch (op) {\n-              case Token.EQ:\n-                // undefined is only equal to\n-                result = equivalent;\n-                break;\n-              case Token.NE:\n-                result = !equivalent;\n-                break;\n-              case Token.SHEQ:\n-                result = undefinedRight;\n-                break;\n-              case Token.SHNE:\n-                result = !undefinedRight;\n-                break;\n-              case Token.LT:\n-              case Token.GT:\n-              case Token.LE:\n-              case Token.GE:\n-                result = false;\n-                break;\n-              default:\n-                return;\n-            }\n-            break;\n-          }\n-        }\n-\n-        if (Token.NAME != right.getType()) {\n-          return;  // Only eval if they are the same type\n-        }\n-        String ln = left.getString();\n-        String rn = right.getString();\n-        if (!ln.equals(rn)) {\n-          return;  // Not the same value name.\n-        }\n-\n-        switch (op) {\n-          // If we knew the named value wouldn't be NaN, it would be nice\n-          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n-          case Token.LT:\n-          case Token.GT:\n-            result = false;\n-            break;\n-          default:\n-            return;  // don't handle that op\n-        }\n-        break;\n-\n-      default:\n-        // assert, this should cover all consts\n-        return;\n-    }\n-\n-    parent.replaceChild(n, new Node(result ? Token.TRUE :\n-                                    Token.FALSE));\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   * Try to evaluate String.indexOf/lastIndexOf:\n-   *     \"abcdef\".indexOf(\"bc\") -> 1\n-   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n-   */\n-  void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,\n-                            Node parent) {\n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-      return;\n-    }\n-\n-    Node lstringNode = left.getFirstChild();\n-    Node functionName = lstringNode.getNext();\n-\n-    if ((lstringNode.getType() != Token.STRING) ||\n-        (!functionName.getString().equals(\"indexOf\") &&\n-        !functionName.getString().equals(\"lastIndexOf\"))) {\n-      return;\n-    }\n-\n-    String lstring = NodeUtil.getStringValue(lstringNode);\n-    boolean isIndexOf = functionName.getString().equals(\"indexOf\");\n-    Node firstArg = right;\n-    Node secondArg = right.getNext();\n-    String searchValue = NodeUtil.getStringValue(firstArg);\n-    // searchValue must be a valid string.\n-    if (searchValue == null) {\n-      return;\n-    }\n-    int fromIndex = isIndexOf ? 0 : lstring.length();\n-    if (secondArg != null) {\n-      // Third-argument and non-numeric second arg are problematic. Discard.\n-      if ((secondArg.getNext() != null) ||\n-          (secondArg.getType() != Token.NUMBER)) {\n-        return;\n-      } else {\n-        fromIndex = (int) secondArg.getDouble();\n-      }\n-    }\n-    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n-                             : lstring.lastIndexOf(searchValue, fromIndex);\n-    Node newNode = Node.newNumber(indexVal);\n-    parent.replaceChild(n, newNode);\n-\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n-   */\n-  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n-                         Node parent) {\n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-      return;\n-    }\n-\n-    Node arrayNode = left.getFirstChild();\n-    Node functionName = arrayNode.getNext();\n-\n-    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n-        !functionName.getString().equals(\"join\")) {\n-      return;\n-    }\n-\n-    String joinString = NodeUtil.getStringValue(right);\n-    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = null;\n-    int foldedSize = 0;\n-    Node prev = null;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb == null) {\n-          sb = new StringBuilder();\n-        } else {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb != null) {\n-          Preconditions.checkNotNull(prev);\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(\n-              Node.newString(sb.toString()).copyInformationFrom(prev));\n-          sb = null;\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      prev = elem;\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb != null) {\n-      Preconditions.checkNotNull(prev);\n-      // + 2 for the quotes.\n-      foldedSize += sb.length() + 2;\n-      arrayFoldedChildren.add(\n-          Node.newString(sb.toString()).copyInformationFrom(prev));\n-    }\n-    // one for each comma.\n-    foldedSize += arrayFoldedChildren.size() - 1;\n-\n-    int originalSize = InlineCostEstimator.getCost(n);\n-    switch (arrayFoldedChildren.size()) {\n-      case 0:\n-        Node emptyStringNode = Node.newString(\"\");\n-        parent.replaceChild(n, emptyStringNode);\n-        break;\n-\n-      case 1:\n-        Node foldedStringNode = arrayFoldedChildren.remove(0);\n-        if (foldedSize > originalSize) {\n-          return;\n-        }\n-        arrayNode.detachChildren();\n-        if (foldedStringNode.getType() != Token.STRING) {\n-          // If the Node is not a string literal, ensure that\n-          // it is coerced to a string.\n-          Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\").copyInformationFrom(right), \n-              foldedStringNode);\n-          foldedStringNode = replacement;\n-        }\n-        parent.replaceChild(n, foldedStringNode);\n-        break;\n-\n-      default:\n-        // No folding could actually be performed.\n-        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n-          return;\n-        }\n-        int kJoinOverhead = \"[].join()\".length();\n-        foldedSize += kJoinOverhead;\n-        foldedSize += InlineCostEstimator.getCost(right);\n-        if (foldedSize > originalSize) {\n-          return;\n-        }\n-        arrayNode.detachChildren();\n-        for (Node node : arrayFoldedChildren) {\n-          arrayNode.addChildToBack(node);\n-        }\n-        break;\n-    }\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   * Try to fold array-element. e.g [1, 2, 3][10];\n-   */\n-  void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right,\n-                      Node parent) {\n-    if (left.getType() == Token.ARRAYLIT) {\n-\n-      if (right.getType() != Token.NUMBER) {\n-        // Sometimes people like to use complex expressions to index into\n-        // arrays, or strings to index into array methods.\n-        return;\n-      }\n-\n-      double index = right.getDouble();\n-      int intIndex = (int) index;\n-      if (intIndex != index) {\n-        t.getCompiler().report(t.makeError(right,\n-            INVALID_GETELEM_INDEX_ERROR, String.valueOf(index)));\n-        return;\n-      }\n-\n-      if (intIndex < 0) {\n-        t.getCompiler().report(t.makeError(n, INDEX_OUT_OF_BOUNDS_ERROR,\n-            String.valueOf(intIndex)));\n-        return;\n-      }\n-\n-      Node elem = left.getFirstChild();\n-      for (int i = 0; elem != null && i < intIndex; i++) {\n-        elem = elem.getNext();\n-      }\n-\n-      if (elem == null) {\n-        t.getCompiler().report(t.makeError(n, INDEX_OUT_OF_BOUNDS_ERROR,\n-            String.valueOf(intIndex)));\n-        return;\n-      }\n-\n-      // Replace the entire GETELEM with the value\n-      left.removeChild(elem);\n-      parent.replaceChild(n, elem);\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n-   */\n-  void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,\n-                      Node parent) {\n-    if (right.getType() == Token.STRING &&\n-        right.getString().equals(\"length\")) {\n-      int knownLength = -1;\n-      switch (left.getType()) {\n-        case Token.ARRAYLIT:\n-          if (NodeUtil.mayHaveSideEffects(left)) {\n-            // Nope, can't fold this, without handling the side-effects.\n-            return;\n-          }\n-          knownLength = left.getChildCount();\n-          break;\n-        case Token.STRING:\n-          knownLength = left.getString().length();\n-          break;\n-        default:\n-          // Not a foldable case, forget it.\n-          return;\n-      }\n-\n-      Preconditions.checkState(knownLength != -1);\n-      Node lengthNode = Node.newNumber(knownLength);\n-      parent.replaceChild(n, lengthNode);\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Replaces a new Array or Object node with an object literal, unless the\n-   * call to Array or Object is to a local function with the same name.\n-   *\n-   * @param t\n-   * @param n new call node (assumed to be of type TokenStream.NEW)\n-   * @param parent\n-   * @param type type of object literal to replace the new call node with\n-   */\n-  boolean tryFoldLiteralConstructor(\n-      NodeTraversal t, Node n, Node parent, String className, int type) {\n-    // Ignore calls to local functions with the same name.\n-    Scope.Var var = t.getScope().getVar(className);\n-    if (var != null && var.isLocal()) {\n-      // no change.\n-      return false;\n-    }\n-\n-    Node literalNode = new Node(type);\n-    parent.replaceChild(n, literalNode);\n-    t.getCompiler().reportCodeChange();\n-    return true;\n-\n-  } \n-}\n-\n+}\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n     this.compiler = compiler;\n     this.assertOnChange = assertOnChange;\n+\n+    // TODO(nicksantos): assertOnChange should only be true if the tree\n+    // is normalized.\n   }\n \n   private void reportCodeChange(String changeDescription) {\n     removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n+\n+    compiler.setNormalized();\n   }\n \n   public static class PropogateConstantAnnotations\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n+\n+import java.util.List;\n+\n+/**\n+ * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n+ *\n+*\n+*\n+ */\n+public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n+\n+  static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(\n+      \"JSC_DIVIDE_BY_0_ERROR\",\n+      \"Divide by 0\");\n+\n+  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n+          \"Array index not integer: {0}\");\n+\n+  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n+          \"Array index out of bounds: {0}\");\n+\n+  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n+          \"Can't negate non-numeric value: {0}\");\n+\n+  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n+      DiagnosticType.error(\n+          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n+          \"Operand out of range, bitwise operation will lose information: {0}\");\n+\n+  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n+      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n+      \"Shift amount out of bounds: {0}\");\n+\n+  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n+      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n+      \"Fractional bitwise operand: {0}\");\n+  \n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    switch(subtree.getType()) {\n+      case Token.CALL:\n+        return tryFoldKnownMethods(subtree);\n+        \n+      case Token.TYPEOF:\n+        return tryFoldTypeof(subtree);\n+        \n+      case Token.NOT:\n+      case Token.NEG:\n+      case Token.BITNOT:\n+        return tryFoldUnaryOperator(subtree);\n+        \n+      default:\n+        return tryFoldBinaryOperator(subtree);\n+    }\n+  }\n+  \n+  private Node tryFoldBinaryOperator(Node subtree) {\n+    Node left = subtree.getFirstChild();\n+    \n+    if (left == null) {\n+      return subtree;\n+    }\n+    \n+    Node right = left.getNext();\n+    \n+    if (right == null) {\n+      return subtree;\n+    }\n+    \n+    // If we've reached here, node is truly a binary operator.\n+    switch(subtree.getType()) {\n+      case Token.GETPROP:\n+        return tryFoldGetProp(subtree, left, right);\n+        \n+      case Token.GETELEM:\n+        return tryFoldGetElem(subtree, left, right);\n+        \n+      case Token.INSTANCEOF:\n+        return tryFoldInstanceof(subtree, left, right);\n+        \n+      case Token.AND:\n+      case Token.OR:\n+        return tryFoldAndOr(subtree, left, right);    \n+        \n+      case Token.BITAND:\n+      case Token.BITOR:\n+        return tryFoldBitAndOr(subtree, left, right);\n+\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+        return tryFoldShift(subtree, left, right);\n+        \n+      case Token.ASSIGN:\n+        return tryFoldAssign(subtree, left, right);\n+\n+      case Token.ADD:\n+        return tryFoldAdd(subtree, left, right);\n+        \n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.DIV:\n+        return tryFoldArithmetic(subtree, left, right);\n+        \n+      case Token.LT:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.GE:\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+        return tryFoldComparison(subtree, left, right);\n+        \n+      default:\n+        return subtree;\n+    }\n+  }\n+  \n+  /**\n+   * Folds 'typeof(foo)' if foo is a literal, e.g.\n+   * typeof(\"bar\") --> \"string\"\n+   * typeof(6) --> \"number\"\n+   */\n+  private Node tryFoldTypeof(Node originalTypeofNode) {\n+    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n+\n+    Node argumentNode = originalTypeofNode.getFirstChild();\n+    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n+      return originalTypeofNode;\n+    }\n+    \n+    String typeNameString = null;\n+\n+    switch (argumentNode.getType()) {\n+      case Token.STRING:\n+        typeNameString = \"string\";\n+        break;\n+      case Token.NUMBER:\n+        typeNameString = \"number\";\n+        break;\n+      case Token.TRUE:\n+      case Token.FALSE:\n+        typeNameString = \"boolean\";\n+        break;\n+      case Token.NULL:\n+      case Token.OBJECTLIT:\n+      case Token.ARRAYLIT:\n+        typeNameString = \"object\";\n+        break;\n+      case Token.NAME:          \n+        // We assume here that programs don't change the value of the\n+        // keyword undefined to something other than the value undefined.\n+        if (\"undefined\".equals(argumentNode.getString())) {\n+          typeNameString = \"undefined\";\n+        }\n+        break;\n+    }\n+\n+    if (typeNameString != null) {\n+      Node newNode = Node.newString(typeNameString);\n+      originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n+      reportCodeChange();\n+      \n+      return newNode;\n+    }\n+  \n+    return originalTypeofNode;\n+  }\n+  \n+  private Node tryFoldUnaryOperator(Node n) {\n+    Preconditions.checkState(n.hasOneChild());\n+\n+    Node left = n.getFirstChild();\n+    Node parent = n.getParent();\n+    \n+    if (left == null) {\n+      return n;\n+    }\n+    \n+    if (NodeUtil.isExpressionNode(parent)) {\n+      // If the value isn't used, then just throw\n+      // away the operator\n+      parent.replaceChild(n, n.removeFirstChild());\n+      reportCodeChange();\n+      return null;\n+    }\n+\n+    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+    if (leftVal == TernaryValue.UNKNOWN) {\n+      return n;\n+    }\n+\n+    switch (n.getType()) {\n+      case Token.NOT:\n+        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;           \n+        Node replacementNode = new Node(result);\n+        parent.replaceChild(n, replacementNode);\n+        reportCodeChange();\n+        return replacementNode;\n+      case Token.NEG:\n+        try {\n+          if (left.getType() == Token.NAME) {\n+            if (left.getString().equals(\"Infinity\")) {\n+              // \"-Infinity\" is valid and a literal, don't modify it.\n+              return n;\n+            } else if (left.getString().equals(\"NaN\")) {\n+              // \"-NaN\" is \"NaN\".\n+              n.removeChild(left);\n+              parent.replaceChild(n, left);\n+              reportCodeChange();\n+              return left;\n+            }\n+          }\n+\n+          double negNum = -left.getDouble();\n+          \n+          Node negNumNode = Node.newNumber(negNum);\n+          parent.replaceChild(n, negNumNode);\n+          reportCodeChange();\n+          return negNumNode;\n+        } catch (UnsupportedOperationException ex) {\n+          // left is not a number node, so do not replace, but warn the\n+          // user because they can't be doing anything good\n+          error(NEGATING_A_NON_NUMBER_ERROR, left);\n+          return n;\n+        }\n+      case Token.BITNOT:\n+        try {\n+          double val = left.getDouble();\n+          if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n+            int intVal = (int) val;\n+            if (intVal == val) {\n+              Node notIntValNode = Node.newNumber(~intVal);\n+              parent.replaceChild(n, notIntValNode);\n+              reportCodeChange();\n+              return notIntValNode;\n+            } else {\n+              error(FRACTIONAL_BITWISE_OPERAND, left);\n+              return n;\n+            }\n+          } else {\n+            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+            return n;\n+          }\n+        } catch (UnsupportedOperationException ex) {\n+          // left is not a number node, so do not replace, but warn the\n+          // user because they can't be doing anything good\n+          error(NEGATING_A_NON_NUMBER_ERROR, left);\n+          return n;\n+        }    \n+        default:\n+          return n;\n+    }\n+  }\n+  \n+  /**\n+   * Try to fold {@code left instanceof right} into {@code true} \n+   * or {@code false}.\n+   */\n+  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);\n+     \n+    // TODO(johnlenz) Use type information if available to fold\n+    // instanceof.\n+    if (NodeUtil.isLiteralValue(left)\n+        && !NodeUtil.mayHaveSideEffects(right)) {\n+      \n+      Node replacementNode = null;\n+      \n+      if (NodeUtil.isImmutableValue(left)) {\n+        // Non-object types are never instances.\n+        replacementNode = new Node(Token.FALSE);\n+      } else if (right.getType() == Token.NAME\n+          && \"Object\".equals(right.getString())) {\n+        replacementNode = new Node(Token.TRUE);\n+      }\n+      \n+      if (replacementNode != null) {\n+        n.getParent().replaceChild(n, replacementNode);\n+        reportCodeChange();\n+        return replacementNode;\n+      }     \n+    }\n+    \n+    return n;\n+  }\n+  \n+  private Node tryFoldAssign(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n+\n+    // Tries to convert x = x + y -> x += y;\n+    if (!right.hasChildren() ||\n+        right.getFirstChild().getNext() != right.getLastChild()) {\n+      // RHS must have two children.\n+      return n;\n+    }\n+\n+    if (NodeUtil.mayHaveSideEffects(left)) {\n+      return n;\n+    }\n+\n+    Node leftChild = right.getFirstChild();\n+    if (!areNodesEqualForInlining(left, leftChild)) {\n+      return n;\n+    }\n+\n+    int newType = -1;\n+    switch (right.getType()) {\n+      case Token.ADD:\n+        newType = Token.ASSIGN_ADD;\n+        break;\n+      case Token.BITAND:\n+        newType = Token.ASSIGN_BITAND;\n+        break;\n+      case Token.BITOR:\n+        newType = Token.ASSIGN_BITOR;\n+        break;\n+      case Token.BITXOR:\n+        newType = Token.ASSIGN_BITXOR;\n+        break;\n+      case Token.DIV:\n+        newType = Token.ASSIGN_DIV;\n+        break;\n+      case Token.LSH:\n+        newType = Token.ASSIGN_LSH;\n+        break;\n+      case Token.MOD:\n+        newType = Token.ASSIGN_MOD;\n+        break;\n+      case Token.MUL:\n+        newType = Token.ASSIGN_MUL;\n+        break;\n+      case Token.RSH:\n+        newType = Token.ASSIGN_RSH;\n+        break;\n+      case Token.SUB:\n+        newType = Token.ASSIGN_SUB;\n+        break;\n+      case Token.URSH:\n+        newType = Token.ASSIGN_URSH;\n+        break;\n+      default:\n+        return n;\n+    }\n+\n+    Node newNode = new Node(newType,\n+        left.detachFromParent(), right.getLastChild().detachFromParent());\n+    n.getParent().replaceChild(n, newNode);\n+    \n+    reportCodeChange();\n+    \n+    return newNode;\n+  }\n+  \n+  /**\n+   * Try to fold a AND/OR node.\n+   */\n+  private Node tryFoldAndOr(Node n, Node left, Node right) {\n+    Node parent = n.getParent();\n+    \n+    Node result = null;\n+\n+    int type = n.getType();\n+   \n+    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+\n+    if (leftVal != TernaryValue.UNKNOWN) {\n+      boolean lval = leftVal.toBoolean(true);\n+\n+      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n+      // (FALSE && x) => FALSE\n+      if (lval && type == Token.OR ||\n+          !lval && type == Token.AND) {\n+        result = left;\n+\n+      } else {\n+        // (FALSE || x) => x\n+        // (TRUE && x) => x\n+        result = right;\n+      }\n+    } else {\n+      TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n+      if (rightVal != TernaryValue.UNKNOWN) {\n+  \n+      // Note: We cannot always fold when the constant is on the\n+      // right, because the typed value of the expression will depend\n+      // on the type of the constant on the right, even if the boolean\n+      // equivalent of the value does not. Specifically, in \"a = x ||\n+      // 0\", a will be numeric 0 if x is undefined (and hence is\n+      // e.g. a valid array index). However, it is safe to fold\n+      // e.g. \"if (x || true)\" because 'if' doesn't care if the\n+      // expression is 'true' or '3'.\n+      int pt = parent.getType();\n+      if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n+          (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n+          (pt == Token.HOOK && parent.getFirstChild() == n)) {\n+        boolean rval = rightVal.toBoolean(true);\n+\n+        // (x || FALSE) => x\n+        // (x && TRUE) => x\n+        if (type == Token.OR && !rval ||\n+            type == Token.AND && rval) {\n+          result = left;\n+        } else {\n+          // If x has no side-effects:\n+          //   (x || TRUE) => TRUE\n+          //   (x && FALSE) => FALSE\n+          if (!NodeUtil.mayHaveSideEffects(left)) {\n+            result = right;\n+          }\n+        }\n+        }\n+      }\n+    }\n+\n+    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so\n+    // there is not much need to worry about const values on left's\n+    // right child.\n+\n+    if (result != null) {\n+      // Fold it!\n+      n.removeChild(result);\n+      parent.replaceChild(n, result);\n+      reportCodeChange();\n+      \n+      return result;\n+    } else {\n+      return n;\n+    }\n+  }\n+  \n+  /**\n+   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n+   * where no node has two const children ((foo() + 'a') + 'b'), so\n+   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n+   * Specifically it folds Add exprssions where:\n+   *  - The left child is also and add expression\n+   *  - The right child is a constant value\n+   *  - The left child's right child is a STRING constant.\n+   *\n+   * WARNING: If javascript ever adds operator overloading, this will\n+   * probably stop being correct.\n+   */\n+  private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n+\n+    if (NodeUtil.isLiteralValue(right) &&\n+        left.getType() == Token.ADD &&\n+        left.getChildCount() == 2) {\n+\n+      Node ll = left.getFirstChild();\n+      Node lr = ll.getNext();\n+\n+      // Left's right child MUST be a string. We would not want to fold\n+      // foo() + 2 + 'a' because we don't know what foo() will return, and\n+      // therefore we don't know if left is a string concat, or a numeric add.\n+      if (lr.getType() != Token.STRING) {\n+        return n;\n+      }\n+      \n+      String leftString = NodeUtil.getStringValue(lr);\n+      String rightString = NodeUtil.getStringValue(right);\n+      if (leftString != null && rightString != null) {\n+        left.removeChild(ll);\n+        String result = leftString + rightString;\n+        n.replaceChild(left, ll);\n+        n.replaceChild(right, Node.newString(result));\n+        reportCodeChange();\n+      }\n+    }\n+    \n+    return n;\n+  }\n+\n+  /**\n+   * Try to fold an ADD node with constant operands\n+   */\n+  private Node tryFoldAddConstant(Node n, Node left, Node right) {\n+    if (left.getType() == Token.STRING ||\n+        right.getType() == Token.STRING) {\n+\n+      // Add strings.\n+      String leftString = NodeUtil.getStringValue(left);\n+      String rightString = NodeUtil.getStringValue(right);\n+      if (leftString != null && rightString != null) {\n+        Node newStringNode = Node.newString(leftString + rightString);\n+        n.getParent().replaceChild(n, newStringNode);\n+        reportCodeChange();\n+        return newStringNode;\n+      }\n+    } else {\n+      // Try arithmetic add\n+      return tryFoldArithmetic(n, left, right);\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Try to fold arithmetic binary operators\n+   */\n+  private Node tryFoldArithmetic(Node n, Node left, Node right) {\n+    if (left.getType() == Token.NUMBER &&\n+        right.getType() == Token.NUMBER) {\n+      double result;\n+      double lval = left.getDouble();\n+      double rval = right.getDouble();\n+\n+      switch (n.getType()) {\n+        case Token.ADD:\n+          result = lval + rval;\n+          break;\n+        case Token.SUB:\n+          result = lval - rval;\n+          break;\n+        case Token.MUL:\n+          result = lval * rval;\n+          break;\n+        case Token.DIV:\n+          if (rval == 0) {\n+            error(DIVIDE_BY_0_ERROR, right);\n+            return n;\n+          }\n+          result = lval / rval;\n+          break;\n+        default:\n+          throw new Error(\"Unknown arithmetic operator\");\n+      }\n+\n+      // length of the left and right value plus 1 byte for the operator.\n+      if (String.valueOf(result).length() <=\n+          String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n+        Node newNumber = Node.newNumber(result);\n+        n.getParent().replaceChild(n, newNumber);\n+        reportCodeChange();\n+        return newNumber;\n+      }\n+   }\n+    return n;\n+  }\n+   \n+  private Node tryFoldAdd(Node node, Node left, Node right) {\n+    Preconditions.checkArgument(node.getType() == Token.ADD);\n+    \n+    if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {\n+      // 6 + 7\n+      return tryFoldAddConstant(node, left, right);\n+    } else {\n+      // a + 7 or 6 + a\n+      return tryFoldLeftChildAdd(node, left, right);\n+    }\n+  }\n+  \n+  /**\n+   * Try to fold arithmetic binary operators\n+   */\n+  private Node tryFoldBitAndOr(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() == Token.BITAND\n+        || n.getType() == Token.BITOR);\n+    \n+    if (left.getType() == Token.NUMBER &&\n+        right.getType() == Token.NUMBER) {\n+      double resultDouble;\n+      double lval = left.getDouble();\n+      double rval = right.getDouble();\n+\n+      // For now, we are being extra conservative, and only folding ints in\n+      // the range MIN_VALUE-MAX_VALUE\n+      if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n+          rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n+\n+        // Fall back through and let the javascript use the larger values\n+        return n;\n+      }\n+\n+      // Convert the numbers to ints\n+      int lvalInt = (int) lval;\n+      if (lvalInt != lval) {\n+        return n;\n+      }\n+\n+      int rvalInt = (int) rval;\n+      if (rvalInt != rval) {\n+        return n;\n+      }\n+\n+      switch (n.getType()) {\n+        case Token.BITAND:\n+          resultDouble = lvalInt & rvalInt;\n+          break;\n+        case Token.BITOR:\n+          resultDouble = lvalInt | rvalInt;\n+          break;\n+        default:\n+          throw new Error(\"Unknown bitwise operator\");\n+      }\n+      \n+      Node newNumber = Node.newNumber(resultDouble);\n+      n.getParent().replaceChild(n, newNumber);\n+      reportCodeChange();\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Try to fold shift operations\n+   */\n+  private Node tryFoldShift(Node n, Node left, Node right) {\n+    if (left.getType() == Token.NUMBER &&\n+        right.getType() == Token.NUMBER) {\n+\n+      double result;\n+      double lval = left.getDouble();\n+      double rval = right.getDouble();\n+\n+      // check ranges.  We do not do anything that would clip the double to\n+      // a 32-bit range, since the user likely does not intend that.\n+      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n+        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+        return n;\n+      }\n+\n+      // only the lower 5 bits are used when shifting, so don't do anything\n+      // if the shift amount is outside [0,32)\n+      if (!(rval >= 0 && rval < 32)) {\n+        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n+        return n;\n+      }\n+\n+      // Convert the numbers to ints\n+      int lvalInt = (int) lval;\n+      if (lvalInt != lval) {\n+        error(FRACTIONAL_BITWISE_OPERAND, left);\n+        return n;\n+      }\n+\n+      int rvalInt = (int) rval;\n+      if (rvalInt != rval) {\n+        error(FRACTIONAL_BITWISE_OPERAND, right);\n+        return n;\n+      }\n+\n+      switch (n.getType()) {\n+        case Token.LSH:\n+          result = lvalInt << rvalInt;\n+          break;\n+        case Token.RSH:\n+          result = lvalInt >> rvalInt;\n+          break;\n+        case Token.URSH:\n+          result = lvalInt >>> rvalInt;\n+          break;\n+        default:\n+          throw new AssertionError(\"Unknown shift operator: \" +\n+              Node.tokenToName(n.getType()));\n+      }\n+      \n+      Node newNumber = Node.newNumber(result);\n+      n.getParent().replaceChild(n, newNumber);\n+      reportCodeChange();\n+      \n+      return newNumber;\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Try to fold comparison nodes, e.g ==\n+   */\n+  @SuppressWarnings(\"fallthrough\")\n+  private Node tryFoldComparison(Node n, Node left, Node right) {\n+    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {\n+      // We only handle non-literal operands for LT and GT.\n+      if (n.getType() != Token.GT && n.getType() != Token.LT) {\n+        return n;\n+      }\n+    }\n+    \n+    int op = n.getType();\n+    boolean result;\n+\n+    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n+\n+    boolean rightLiteral = NodeUtil.isLiteralValue(right);\n+    boolean undefinedRight = ((Token.NAME == right.getType()\n+          && right.getString().equals(\"undefined\"))\n+          || (Token.VOID == right.getType()\n+              && NodeUtil.isLiteralValue(right.getFirstChild())));\n+\n+    switch (left.getType()) {\n+      case Token.VOID:\n+        if (!NodeUtil.isLiteralValue(left.getFirstChild())) {\n+          return n;\n+        } else if (!rightLiteral) {\n+          return n;\n+        } else {\n+          boolean nullRight = (Token.NULL == right.getType());\n+          boolean equivalent = undefinedRight || nullRight;\n+          switch (op) {\n+            case Token.EQ:\n+              // undefined is only equal to\n+              result = equivalent;\n+              break;\n+            case Token.NE:\n+              result = !equivalent;\n+              break;\n+            case Token.SHEQ:\n+              result = undefinedRight;\n+              break;\n+            case Token.SHNE:\n+              result = !undefinedRight;\n+              break;\n+            case Token.LT:\n+            case Token.GT:\n+            case Token.LE:\n+            case Token.GE:\n+              result = false;\n+              break;\n+            default:\n+              return n;\n+          }\n+        }\n+        break;\n+\n+      case Token.NULL:\n+        if (undefinedRight) {\n+          result = (op == Token.EQ);\n+          break;\n+        }\n+        // fall through\n+      case Token.TRUE:\n+      case Token.FALSE:\n+        if (undefinedRight) {\n+          result = false;\n+          break;\n+        }\n+        // fall through\n+      case Token.THIS:\n+        int tt = right.getType();\n+        if (tt != Token.THIS &&\n+            tt != Token.TRUE &&\n+            tt != Token.FALSE &&\n+            tt != Token.NULL) {\n+          return n;\n+        }\n+        switch (op) {\n+          case Token.SHEQ:\n+          case Token.EQ:\n+            result = left.getType() == right.getType();\n+            break;\n+\n+          case Token.SHNE:\n+          case Token.NE:\n+            result = left.getType() != right.getType();\n+            break;\n+\n+          default:\n+            return n;  // we only handle == and != here\n+        }\n+        break;\n+\n+      case Token.STRING:\n+        if (undefinedRight) {\n+          result = false;\n+          break;\n+        }\n+        if (Token.STRING != right.getType()) {\n+          return n;  // Only eval if they are the same type\n+        }\n+        switch (op) {\n+          case Token.SHEQ:\n+          case Token.EQ:\n+            result = left.getString().equals(right.getString());\n+            break;\n+\n+          case Token.SHNE:\n+          case Token.NE:\n+            result = !left.getString().equals(right.getString());\n+            break;\n+\n+          default:\n+            return n;  // we only handle == and != here\n+        }\n+        break;\n+\n+      case Token.NUMBER:\n+        if (undefinedRight) {\n+          result = false;\n+          break;\n+        }\n+        if (Token.NUMBER != right.getType()) {\n+          return n;  // Only eval if they are the same type\n+        }\n+        double lv = left.getDouble();\n+        double rv = right.getDouble();\n+\n+        switch (op) {\n+          case Token.SHEQ:\n+          case Token.EQ: result = lv == rv; break;\n+          case Token.SHNE:\n+          case Token.NE: result = lv != rv; break;\n+          case Token.LE: result = lv <= rv; break;\n+          case Token.LT: result = lv <  rv; break;\n+          case Token.GE: result = lv >= rv; break;\n+          case Token.GT: result = lv >  rv; break;\n+          default:\n+            return n;  // don't handle that op\n+        }\n+        break;\n+\n+      case Token.NAME:\n+        if (rightLiteral) {\n+          boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n+          if (undefinedLeft) {\n+            boolean nullRight = (Token.NULL == right.getType());\n+            boolean equivalent = undefinedRight || nullRight;\n+            switch (op) {\n+              case Token.EQ:\n+                // undefined is only equal to\n+                result = equivalent;\n+                break;\n+              case Token.NE:\n+                result = !equivalent;\n+                break;\n+              case Token.SHEQ:\n+                result = undefinedRight;\n+                break;\n+              case Token.SHNE:\n+                result = !undefinedRight;\n+                break;\n+              case Token.LT:\n+              case Token.GT:\n+              case Token.LE:\n+              case Token.GE:\n+                result = false;\n+                break;\n+              default:\n+                return n;\n+            }\n+            break;\n+          }\n+        }\n+\n+        if (Token.NAME != right.getType()) {\n+          return n;  // Only eval if they are the same type\n+        }\n+        String ln = left.getString();\n+        String rn = right.getString();\n+        if (!ln.equals(rn)) {\n+          return n;  // Not the same value name.\n+        }\n+\n+        switch (op) {\n+          // If we knew the named value wouldn't be NaN, it would be nice\n+          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n+          case Token.LT:\n+          case Token.GT:\n+            result = false;\n+            break;\n+          default:\n+            return n;  // don't handle that op\n+        }\n+        break;\n+\n+      default:\n+        // assert, this should cover all consts\n+        return n;\n+    }\n+\n+    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+    \n+    return newNode;\n+  }\n+  \n+  private Node tryFoldKnownMethods(Node subtree) {\n+    // For now we only support .join() and .indexOf()\n+    \n+    subtree = tryFoldStringJoin(subtree);\n+    \n+    if (subtree.getType() == Token.CALL) {\n+      subtree = tryFoldStringIndexOf(subtree);\n+    }\n+    \n+    return subtree;\n+  }\n+  \n+  /**\n+   * Try to evaluate String.indexOf/lastIndexOf:\n+   *     \"abcdef\".indexOf(\"bc\") -> 1\n+   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n+   */\n+  private Node tryFoldStringIndexOf(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    \n+    Node left = n.getFirstChild();\n+    \n+    if (left == null) {\n+      return n;\n+    }\n+    \n+    Node right = left.getNext();\n+    \n+    if (right == null) {\n+      return n;\n+    }\n+    \n+    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n+      return n;\n+    }\n+\n+    Node lstringNode = left.getFirstChild();\n+    Node functionName = lstringNode.getNext();\n+\n+    if ((lstringNode.getType() != Token.STRING) ||\n+        (!functionName.getString().equals(\"indexOf\") &&\n+        !functionName.getString().equals(\"lastIndexOf\"))) {\n+      return n;\n+    }\n+\n+    String lstring = NodeUtil.getStringValue(lstringNode);\n+    boolean isIndexOf = functionName.getString().equals(\"indexOf\");\n+    Node firstArg = right;\n+    Node secondArg = right.getNext();\n+    String searchValue = NodeUtil.getStringValue(firstArg);\n+    // searchValue must be a valid string.\n+    if (searchValue == null) {\n+      return n;\n+    }\n+    int fromIndex = isIndexOf ? 0 : lstring.length();\n+    if (secondArg != null) {\n+      // Third-argument and non-numeric second arg are problematic. Discard.\n+      if ((secondArg.getNext() != null) ||\n+          (secondArg.getType() != Token.NUMBER)) {\n+        return n;\n+      } else {\n+        fromIndex = (int) secondArg.getDouble();\n+      }\n+    }\n+    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n+                             : lstring.lastIndexOf(searchValue, fromIndex);\n+    Node newNode = Node.newNumber(indexVal);\n+    n.getParent().replaceChild(n, newNode);\n+\n+    reportCodeChange();\n+    \n+    return newNode;\n+  }\n+\n+  /**\n+   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n+   */\n+  private Node tryFoldStringJoin(Node n) {\n+    Node left = n.getFirstChild();\n+    \n+    if (left == null) {\n+      return n;\n+    }\n+    \n+    Node right = left.getNext();\n+    \n+    if (right == null) {\n+      return n;\n+    }\n+    \n+    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n+      return n;\n+    }\n+\n+    Node arrayNode = left.getFirstChild();\n+    Node functionName = arrayNode.getNext();\n+\n+    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n+        !functionName.getString().equals(\"join\")) {\n+      return n;\n+    }\n+\n+    String joinString = NodeUtil.getStringValue(right);\n+    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n+    StringBuilder sb = null;\n+    int foldedSize = 0;\n+    Node prev = null;\n+    Node elem = arrayNode.getFirstChild();\n+    // Merges adjacent String nodes.\n+    while (elem != null) {\n+      if (NodeUtil.isImmutableValue(elem)) {\n+        if (sb == null) {\n+          sb = new StringBuilder();\n+        } else {\n+          sb.append(joinString);\n+        }\n+        sb.append(NodeUtil.getStringValue(elem));\n+      } else {\n+        if (sb != null) {\n+          Preconditions.checkNotNull(prev);\n+          // + 2 for the quotes.\n+          foldedSize += sb.length() + 2;\n+          arrayFoldedChildren.add(\n+              Node.newString(sb.toString()).copyInformationFrom(prev));\n+          sb = null;\n+        }\n+        foldedSize += InlineCostEstimator.getCost(elem);\n+        arrayFoldedChildren.add(elem);\n+      }\n+      prev = elem;\n+      elem = elem.getNext();\n+    }\n+\n+    if (sb != null) {\n+      Preconditions.checkNotNull(prev);\n+      // + 2 for the quotes.\n+      foldedSize += sb.length() + 2;\n+      arrayFoldedChildren.add(\n+          Node.newString(sb.toString()).copyInformationFrom(prev));\n+    }\n+    // one for each comma.\n+    foldedSize += arrayFoldedChildren.size() - 1;\n+\n+    int originalSize = InlineCostEstimator.getCost(n);\n+    switch (arrayFoldedChildren.size()) {\n+      case 0:\n+        Node emptyStringNode = Node.newString(\"\");\n+        n.getParent().replaceChild(n, emptyStringNode);\n+        reportCodeChange();\n+        return emptyStringNode;\n+      case 1:\n+        Node foldedStringNode = arrayFoldedChildren.remove(0);\n+        if (foldedSize > originalSize) {\n+          return n;\n+        }\n+        arrayNode.detachChildren();\n+        if (foldedStringNode.getType() != Token.STRING) {\n+          // If the Node is not a string literal, ensure that\n+          // it is coerced to a string.\n+          Node replacement = new Node(Token.ADD,\n+              Node.newString(\"\").copyInformationFrom(right), \n+              foldedStringNode);\n+          foldedStringNode = replacement;\n+        }\n+        n.getParent().replaceChild(n, foldedStringNode);\n+        reportCodeChange();\n+        return foldedStringNode;\n+      default:\n+        // No folding could actually be performed.\n+        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n+          return n;\n+        }\n+        int kJoinOverhead = \"[].join()\".length();\n+        foldedSize += kJoinOverhead;\n+        foldedSize += InlineCostEstimator.getCost(right);\n+        if (foldedSize > originalSize) {\n+          return n;\n+        }\n+        arrayNode.detachChildren();\n+        for (Node node : arrayFoldedChildren) {\n+          arrayNode.addChildToBack(node);\n+        }\n+        reportCodeChange();\n+        break;\n+    }\n+   \n+    return n;\n+  }\n+\n+  /**\n+   * Try to fold array-element. e.g [1, 2, 3][10];\n+   */\n+  private Node tryFoldGetElem(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() == Token.GETELEM);\n+ \n+    if (left.getType() == Token.ARRAYLIT) {\n+\n+      if (right.getType() != Token.NUMBER) {\n+        // Sometimes people like to use complex expressions to index into\n+        // arrays, or strings to index into array methods.\n+        return n;\n+      }\n+\n+      double index = right.getDouble();\n+      int intIndex = (int) index;\n+      if (intIndex != index) {\n+        error(INVALID_GETELEM_INDEX_ERROR, right);\n+        return n;\n+      }\n+\n+      if (intIndex < 0) {\n+        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+        return n;\n+      }\n+\n+      Node elem = left.getFirstChild();\n+      for (int i = 0; elem != null && i < intIndex; i++) {\n+        elem = elem.getNext();\n+      }\n+\n+      if (elem == null) {\n+        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+        return n;\n+      }\n+\n+      // Replace the entire GETELEM with the value\n+      left.removeChild(elem);\n+      n.getParent().replaceChild(n, elem);\n+      reportCodeChange();\n+      return elem;\n+    }\n+    return n;\n+  }\n+  \n+  /**\n+   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n+   */\n+  private Node tryFoldGetProp(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() == Token.GETPROP);\n+ \n+    if (right.getType() == Token.STRING &&\n+        right.getString().equals(\"length\")) {\n+      int knownLength = -1;\n+      switch (left.getType()) {\n+        case Token.ARRAYLIT:\n+          if (NodeUtil.mayHaveSideEffects(left)) {\n+            // Nope, can't fold this, without handling the side-effects.\n+            return n;\n+          }\n+          knownLength = left.getChildCount();\n+          break;\n+        case Token.STRING:\n+          knownLength = left.getString().length();\n+          break;\n+        default:\n+          // Not a foldable case, forget it.\n+          return n;\n+      }\n+\n+      Preconditions.checkState(knownLength != -1);\n+      Node lengthNode = Node.newNumber(knownLength);\n+      n.getParent().replaceChild(n, lengthNode);\n+      reportCodeChange();\n+      \n+      return lengthNode;\n+    }\n+    \n+    return n;\n+  }\n+  \n+}\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n    * Tries apply our various peephole minimizations on the passed in node.\n    */\n   @Override\n+  @SuppressWarnings(\"fallthrough\")\n   public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n       case Token.RETURN:\n-        return tryReduceReturn(node);        \n+        return tryReduceReturn(node);  \n+        \n       case Token.NOT:\n         return tryMinimizeNot(node);\n+        \n       case Token.IF:\n         tryMinimizeCondition(node.getFirstChild());\n-        return tryMinimizeIf(node);     \n+        return tryMinimizeIf(node);   \n+        \n       case Token.EXPR_RESULT:\n         tryMinimizeCondition(node.getFirstChild());\n         return node;\n+        \n       case Token.HOOK:\n-          tryMinimizeCondition(node.getFirstChild());\n+        tryMinimizeCondition(node.getFirstChild());\n         return node;\n+        \n       case Token.WHILE:\n       case Token.DO:\n       case Token.FOR:\n         return node;\n         \n       case Token.NEW:\n-      case Token.CALL:{\n-        Node left = node.getFirstChild();\n-        if (left != null) {\n-          if (Token.NAME == left.getType()) {\n-            String className = left.getString();\n-            if (\"RegExp\".equals(className)) {\n-              return tryFoldRegularExpressionConstructor(node);\n-            }\n-          }\n-        }    \n-      }\n-        return node;\n-        default:\n+        node = tryFoldStandardConstructors(node);\n+        if (node.getType() != Token.CALL) {\n+          return node;\n+        }\n+        // Fall through on purpose because tryFoldStandardConstructors() may\n+        // convert a NEW node into a CALL node\n+      case Token.CALL:\n+        return tryFoldLiteralConstructor(node);\n+        \n+      default:\n           return node; //Nothing changed\n     }\n   }\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  Node tryMinimizeIf(Node n) {\n+  private Node tryMinimizeIf(Node n) {\n     \n     Node parent = n.getParent();\n     \n    *   \n    *   Returns the replacement for n, or the original if no change was made\n    */\n-  Node tryMinimizeCondition(Node n) {\n+  private Node tryMinimizeCondition(Node n) {\n     Node parent = n.getParent();\n     \n     switch (n.getType()) {\n     \n     return n;\n   }\n+  \n+  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n+    // String, Number, and Boolean functions return non-object types, whereas\n+    // new String, new Number, and new Boolean return object types, so don't\n+    // include them here.\n+    ImmutableSet.of(\n+      \"Object\",\n+      \"Array\",\n+      \"RegExp\",\n+      \"Error\"\n+      );\n+  \n+  /**\n+   * Fold \"new Object()\" to \"Object()\".\n+   */\n+  private Node tryFoldStandardConstructors(Node n) {\n+    Preconditions.checkState(n.getType() == Token.NEW);\n+    \n+    // If name normalization has been run then we know that\n+    // new Object() does in fact refer to what we think it is\n+    // and not some custom-defined Object().\n+    if (isASTNormalized()) {\n+      if (n.getFirstChild().getType() == Token.NAME) {\n+        String className = n.getFirstChild().getString();\n+        if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n+            n.setType(Token.CALL);\n+            reportCodeChange();\n+        }\n+      }\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Replaces a new Array or Object node with an object literal, unless the\n+   * call to Array or Object is to a local function with the same name.\n+   */\n+  private Node tryFoldLiteralConstructor(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL\n+        || n.getType() == Token.NEW);\n+  \n+    Node constructorNameNode = n.getFirstChild();\n+    \n+    Node newLiteralNode = null;\n+    \n+    // We require the AST to be normalized to ensure that, say,\n+    // Object() really refers to the built-in Object constructor\n+    // and not a user-defined constructor with the same name.\n+\n+    if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {\n+\n+      String className = constructorNameNode.getString();\n+\n+      if (\"RegExp\".equals(className)) {\n+        // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n+        return tryFoldRegularExpressionConstructor(n);\n+      } else {\n+        boolean constructorHasArguments = constructorNameNode.getNext() != null;\n+\n+        if (!constructorHasArguments) {\n+          if (\"Array\".equals(className)) {\n+            // \"Array()\" --> \"[]\"\n+            newLiteralNode = new Node(Token.ARRAYLIT);\n+          } else if (\"Object\".equals(className)) {\n+            // \"Object()\" --> \"{}\"\n+            newLiteralNode = new Node(Token.OBJECTLIT);\n+          }\n+        }\n+        if (newLiteralNode != null) {\n+          n.getParent().replaceChild(n, newLiteralNode);\n+          reportCodeChange();\n+          return newLiteralNode;\n+        }   \n+      }\n+    }\n+    return n;\n+  } \n \n   private Node tryFoldRegularExpressionConstructor(Node n) { \n     Node parent = n.getParent();\n     Node pattern = constructor.getNext();  // e.g.  ^foobar$\n     Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n \n+    // Only run on normalized AST to make sure RegExp() is actually\n+    // the RegExp we expect (if the AST has been normalized then\n+    // other RegExp's will have been renamed to something like RegExp$1)\n+    if (!isASTNormalized()) {\n+      return n;\n+    }\n+    \n     if (null == pattern || (null != flags && null != flags.getNext())) {\n       // too few or too many arguments\n       return n;\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n       \"module {1}\");\n \n   static final DiagnosticType NAME_REFERENCE_IN_EXTERNS_ERROR =\n-    DiagnosticType.warning(\n+    DiagnosticType.error(\n       \"JSC_NAME_REFERENCE_IN_EXTERNS\",\n       \"accessing name {0} in externs has no effect\");\n+\n+  static final DiagnosticType UNDEFINED_EXTERN_VAR_ERROR =\n+    DiagnosticType.error(\n+      \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n+      \"name {0} is not undefined in the externs.\");\n \n   static final DiagnosticType INVALID_FUNCTION_DECL =\n     DiagnosticType.error(\"JSC_INVALID_FUNCTION_DECL\",\n         // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n         // current scope.\n       } else {\n-        t.report(n, UNDEFINED_VAR_ERROR, varName);\n+        // The extern checks are stricter, don't report a second error.\n+        if (!t.getInput().isExtern()) {\n+          t.report(n, UNDEFINED_VAR_ERROR, varName);\n+        }\n \n         if (sanityCheck) {\n           throw new IllegalStateException(\"Unexpected variable \" + varName);\n         switch (parent.getType()) {\n           case Token.VAR:\n           case Token.FUNCTION:\n-          case Token.GETPROP:\n           case Token.LP:\n             // These are okay.\n+            break;\n+          case Token.GETPROP:\n+            if (n == parent.getFirstChild()) {\n+              Scope scope = t.getScope();\n+              Scope.Var var = scope.getVar(n.getString());\n+              if (var == null) {\n+                t.report(n, UNDEFINED_EXTERN_VAR_ERROR, n.getString());\n+              }\n+            }\n             break;\n           default:\n             t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n package com.google.javascript.rhino;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.jstype.JSType;\n     private String str;\n   }\n \n+  // PropListItems are immutable so that they can be shared.\n   private static class PropListItem implements Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    PropListItem next;\n-    int type;\n-    int intValue;\n-    Object objectValue;\n+    final PropListItem next;\n+    final int type;\n+    final int intValue;\n+    final Object objectValue;\n+\n+    PropListItem(int type, int intValue, PropListItem next) {\n+      this(type, intValue, null, next);\n+    }\n+\n+    PropListItem(int type, Object objectValue, PropListItem next) {\n+      this(type, 0, objectValue, next);\n+    }\n+\n+    PropListItem(\n+        int type, int intValue, Object objectValue, PropListItem next) {\n+      this.type = type;\n+      this.intValue = intValue;\n+      this.objectValue = objectValue;\n+      this.next = next;\n+    }\n   }\n \n \n     child.parent = null;\n   }\n \n-  private PropListItem lookupProperty(int propType) {\n+  @VisibleForTesting\n+  PropListItem lookupProperty(int propType) {\n     PropListItem x = propListHead;\n     while (x != null && propType != x.type) {\n       x = x.next;\n     return x;\n   }\n \n-  private PropListItem ensureProperty(int propType) {\n-    PropListItem item = lookupProperty(propType);\n+  public void removeProp(int propType) {\n+    PropListItem result = removeProp(propListHead, propType);\n+    if (result != propListHead) {\n+      propListHead = result;\n+    }\n+  }\n+\n+  /**\n+   * @param item The item to inspect\n+   * @param propType The property to look for\n+   * @return The replacement list if the property was removed, or\n+   *   'item' otherwise.\n+   */\n+  private PropListItem removeProp(PropListItem item, int propType) {\n     if (item == null) {\n-      item = new PropListItem();\n-      item.type = propType;\n-      item.next = propListHead;\n-      propListHead = item;\n-    }\n-    return item;\n-  }\n-\n-  public void removeProp(int propType) {\n-    PropListItem x = propListHead;\n-    if (x != null) {\n-      PropListItem prev = null;\n-      while (x.type != propType) {\n-        prev = x;\n-        x = x.next;\n-        if (x == null) {\n-          return;\n-        }\n-      }\n-      if (prev == null) {\n-        propListHead = x.next;\n+      return null;\n+    } else if (item.type == propType) {\n+      return item.next;\n+    } else {\n+      PropListItem result = removeProp(item.next, propType);\n+      if (result != item.next) {\n+        return new PropListItem(\n+            item.type, item.intValue, item.objectValue, result);\n       } else {\n-        prev.next = x.next;\n+        return item;\n       }\n     }\n   }\n   }\n \n   public boolean getBooleanProp(int propType) {\n-    return getIntProp(propType, 0) != 0;\n-  }\n-\n-  public int getIntProp(int propType, int defaultValue) {\n+    return getIntProp(propType) != 0;\n+  }\n+\n+  /**\n+   * Returns the integer value for the property, or 0 if the property\n+   * is not defined.\n+   */\n+  public int getIntProp(int propType) {\n     PropListItem item = lookupProperty(propType);\n     if (item == null) {\n-      return defaultValue;\n+      return 0;\n     }\n     return item.intValue;\n   }\n     return item.intValue;\n   }\n \n-  public void putProp(int propType, Object prop) {\n-    if (prop == null) {\n-      removeProp(propType);\n-    } else {\n-      PropListItem item = ensureProperty(propType);\n-      item.objectValue = prop;\n-    }\n-  }\n-\n-  public void putBooleanProp(int propType, boolean prop) {\n-    putIntProp(propType, prop ? 1 : 0);\n-  }\n-\n-  public void putIntProp(int propType, int prop) {\n-    PropListItem item = ensureProperty(propType);\n-    item.intValue = prop;\n+  public void putProp(int propType, Object value) {\n+    removeProp(propType);\n+    if (value != null) {\n+      propListHead = new PropListItem(propType, value, propListHead);\n+    }\n+  }\n+\n+  public void putBooleanProp(int propType, boolean value) {\n+    putIntProp(propType, value ? 1 : 0);\n+  }\n+\n+  public void putIntProp(int propType, int value) {\n+    removeProp(propType);\n+    if (value != 0) {\n+      propListHead = new PropListItem(propType, value, propListHead);\n+    }\n   }\n \n   // Gets all the property types, in sorted order.\n         return false;\n       }\n     } else if (type == Token.INC || type == Token.DEC) {\n-      int post1 = this.getIntProp(INCRDECR_PROP, 0);\n-      int post2 = node.getIntProp(INCRDECR_PROP, 0);\n+      int post1 = this.getIntProp(INCRDECR_PROP);\n+      int post2 = node.getIntProp(INCRDECR_PROP);\n       if (post1 != post2) {\n         return false;\n       }\n     } else if (type == Token.STRING) {\n-      int quoted1 = this.getIntProp(QUOTED_PROP, 0);\n-      int quoted2 = node.getIntProp(QUOTED_PROP, 0);\n+      int quoted1 = this.getIntProp(QUOTED_PROP);\n+      int quoted2 = node.getIntProp(QUOTED_PROP);\n       if (quoted1 != quoted2) {\n         return false;\n       }\n     Node result;\n     try {\n       result = (Node) super.clone();\n+      // PropListItem lists are immutable and can be shared so there is no\n+      // need to clone them here.\n       result.next = null;\n       result.first = null;\n       result.last = null;\n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n \n   public AmbiguatePropertiesTest() {\n     super(EXTERNS);\n+    enableNormalize();\n+    enableTypeCheck(CheckLevel.WARNING);\n   }\n \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       public void process(Node externs, Node root) {\n-        new TypeCheck(compiler,\n-            new SemanticReverseAbstractInterpreter(\n-                compiler.getCodingConvention(), compiler.getTypeRegistry()),\n-            compiler.getTypeRegistry())\n-            .processForTesting(externs, root);\n-\n         lastPass = new AmbiguateProperties(compiler, new char[]{'$'});\n         lastPass.process(externs, root);\n       }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n   }\n \n   public void testExponents() {\n-    assertPrint(\"1\", \"1\");\n-    assertPrint(\"10\", \"10\");\n-    assertPrint(\"100\", \"100\");\n-    assertPrint(\"1000\", \"1E3\");\n-    assertPrint(\"10000\", \"1E4\");\n-    assertPrint(\"100000\", \"1E5\");\n-    assertPrint(\"-1\", \"-1\");\n-    assertPrint(\"-10\", \"-10\");\n-    assertPrint(\"-100\", \"-100\");\n-    assertPrint(\"-1000\", \"-1E3\");\n-    assertPrint(\"-123412340000\", \"-12341234E4\");\n-    assertPrint(\"1000000000000000000\", \"1E18\");\n-    assertPrint(\"100000.0\", \"1E5\");\n-    assertPrint(\"100000.1\", \"100000.1\");\n-\n-    assertPrint(\"0.000001\", \"1.0E-6\");\n+    assertPrintNumber(\"1\", 1);\n+    assertPrintNumber(\"10\", 10);\n+    assertPrintNumber(\"100\", 100);\n+    assertPrintNumber(\"1E3\", 1000);\n+    assertPrintNumber(\"1E4\", 10000);\n+    assertPrintNumber(\"1E5\", 100000);\n+    assertPrintNumber(\"-1\", -1);\n+    assertPrintNumber(\"-10\", -10);\n+    assertPrintNumber(\"-100\", -100);\n+    assertPrintNumber(\"-1E3\", -1000);\n+    assertPrintNumber(\"-12341234E4\", -123412340000L);\n+    assertPrintNumber(\"1E18\", 1000000000000000000L);\n+    assertPrintNumber(\"1E5\", 100000.0);\n+    assertPrintNumber(\"100000.1\", 100000.1);\n+\n+    assertPrintNumber(\"1.0E-6\", 0.000001);\n+  }\n+\n+  // Make sure to test as both a String and a Node, because\n+  // negative numbers do not parse consistently from strings.\n+  private void assertPrintNumber(String expected, double number) {\n+    assertPrint(String.valueOf(number), expected);\n+    assertPrintNode(expected, Node.newNumber(number));\n+  }\n+\n+  private void assertPrintNumber(String expected, int number) {\n+    assertPrint(String.valueOf(number), expected);\n+    assertPrintNode(expected, Node.newNumber(number));\n   }\n \n   public void testDirectEval() {\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n    */\n   public void testSame(String externs, String js, DiagnosticType warning) {\n     testSame(externs, js, warning, null);\n+  }\n+\n+  /**\n+   * Verifies that the compiler pass's JS output is the same as its input\n+   * and (optionally) that an expected warning is issued.\n+   *\n+   * @param externs Externs input\n+   * @param js Input and output\n+   * @param diag Expected error or warning, or null if none is expected\n+   * @param error true if diag is an error, false if it is a warning\n+   */\n+  public void testSame(\n+      String externs, String js, DiagnosticType diag, boolean error) {\n+    if (error) {\n+      test(externs, js, js, diag, null);\n+    } else {\n+      test(externs, js, js, null, diag);\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n import com.google.javascript.rhino.Node;\n \n public class FoldConstantsTest extends CompilerTestCase {\n+\n+  // Externs for builtin constructors\n+  // Needed for testFoldLiteralConstructors() and testFoldRegExp...()\n+  private static final String FOLD_CONSTANTS_TEST_EXTERNS =\n+      \"var Object = function(){};\\n\" +\n+      \"var RegExp = function(a){};\\n\" +\n+      \"var Array = function(a){};\\n\";\n+\n   private boolean runFoldConstantsFirst = true;\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private FoldConstantsTest(boolean compareAsTree) {\n-    super(\"\", compareAsTree);\n+    super(FOLD_CONSTANTS_TEST_EXTERNS, compareAsTree);\n   }\n \n   public FoldConstantsTest() {\n-    super();\n+    super(FOLD_CONSTANTS_TEST_EXTERNS);\n   }\n \n   @Override\n         PeepholeOptimizationsPass peepholePass =\n             new PeepholeOptimizationsPass(compiler,\n                 new PeepholeSubstituteAlternateSyntax(),\n-                new PeepholeRemoveDeadCode());\n+                new PeepholeRemoveDeadCode(),\n+                new PeepholeFoldConstants());\n \n         peepholePass.process(externs, js);\n       }\n     runFoldConstantsFirst = true;\n   }\n \n+  void assertResultString(String js, String expected) {\n+    assertResultString(js, expected, false);\n+  }\n   // TODO(user): This is same as fold() except it uses string comparison. Any\n   // test that needs tell us where a folding is constructing an invalid AST.\n-  void assertResultString(String js, String expected) {\n+  void assertResultString(String js, String expected, boolean normalize) {\n     FoldConstantsTest scTest = new FoldConstantsTest(false);\n+\n+    if (normalize) {\n+      scTest.enableNormalize();\n+    } else {\n+      scTest.disableNormalize();\n+    }\n+\n     scTest.test(js, expected);\n   }\n \n     fold(\"a=~~10\", \"a=10\");\n     fold(\"a=~-7\", \"a=6\");\n     fold(\"a=~0x100000000\", \"a=~0x100000000\",\n-         FoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     fold(\"a=~-0x100000000\", \"a=~-0x100000000\",\n-         FoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n-    fold(\"a=~.5\", \"~.5\", FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    fold(\"a=~.5\", \"~.5\", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n   }\n \n   public void testUnaryOpsStringCompare() {\n     fold(\"x = -1 >>> 1\", \"x = \" + 0x7fffffff);\n \n     fold(\"3000000000 << 1\", \"3000000000<<1\",\n-         FoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     fold(\"1 << 32\", \"1<<32\",\n-         FoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n     fold(\"1 << -1\", \"1<<32\",\n-         FoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n     fold(\"3000000000 >> 1\", \"3000000000>>1\",\n-         FoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     fold(\"1 >> 32\", \"1>>32\",\n-         FoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n-    fold(\"1.5 << 0\",  \"1.5<<0\",  FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 << .5\",   \"1.5<<0\",  FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1.5 >>> 0\", \"1.5>>>0\", FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 >>> .5\",  \"1.5>>>0\", FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1.5 >> 0\",  \"1.5>>0\",  FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 >> .5\",   \"1.5>>0\",  FoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+    fold(\"1.5 << 0\",  \"1.5<<0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 << .5\",   \"1.5<<0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 >>> .5\",  \"1.5>>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1.5 >> 0\",  \"1.5>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 >> .5\",   \"1.5>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n   }\n \n   public void testFoldBitShiftsStringCompare() {\n     fold(\"x = 2.25 * 3\", \"x = 6.75\");\n     fold(\"z = x * y\", \"z = x * y\");\n     fold(\"x = y * 5\", \"x = y * 5\");\n-    fold(\"x = 1 / 0\", \"\", FoldConstants.DIVIDE_BY_0_ERROR);\n+    fold(\"x = 1 / 0\", \"\", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);\n   }\n \n   public void testFoldArithmeticStringComp() {\n   public void testFoldGetElem() {\n     fold(\"x = [10, 20][0]\", \"x = 10\");\n     fold(\"x = [10, 20][1]\", \"x = 20\");\n-    fold(\"x = [10, 20][0.5]\", \"\", FoldConstants.INVALID_GETELEM_INDEX_ERROR);\n-    fold(\"x = [10, 20][-1]\",    \"\", FoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n-    fold(\"x = [10, 20][2]\",     \"\", FoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n+    fold(\"x = [10, 20][0.5]\", \"\",\n+        PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n+    fold(\"x = [10, 20][-1]\",    \"\",\n+        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n+    fold(\"x = [10, 20][2]\",     \"\",\n+        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n   }\n \n   public void testFoldComplex() {\n   }\n \n   public void testFoldRegExpConstructor() {\n-    // Cannot fold\n-    // Too few arguments\n+    enableNormalize();\n+\n+    // Cannot fold all the way to a literal because there are too few arguments.\n     fold(\"x = new RegExp\",                    \"x = RegExp()\");\n     // Empty regexp should not fold to // since that is a line comment in js\n     fold(\"x = new RegExp(\\\"\\\")\",              \"x = RegExp(\\\"\\\")\");\n     String longRegexp = \"\";\n     for (int i = 0; i < 200; i++) longRegexp += \"x\";\n     foldSame(\"x = RegExp(\\\"\" + longRegexp + \"\\\")\");\n+\n+    // Shouldn't fold RegExp unnormalized because\n+    // we can't be sure that RegExp hasn't been redefined\n+    disableNormalize();\n+\n+    foldSame(\"x = new RegExp(\\\"foobar\\\")\");\n   }\n \n   public void testFoldRegExpConstructorStringCompare() {\n     // Might have something to do with the internal representation of \\n and how\n     // it is used in node comparison.\n-    assertResultString(\"x=new RegExp(\\\"\\\\n\\\", \\\"i\\\")\", \"x=/\\\\n/i\");\n+    assertResultString(\"x=new RegExp(\\\"\\\\n\\\", \\\"i\\\")\", \"x=/\\\\n/i\", true);\n   }\n \n   public void testFoldTypeof() {\n   }\n \n   public void testFoldLiteralConstructors() {\n-    // Can fold\n+    enableNormalize();\n+\n+    // Can fold when normalized\n     fold(\"x = new Array\", \"x = []\");\n     fold(\"x = new Array()\", \"x = []\");\n     fold(\"x = Array()\", \"x = []\");\n     fold(\"x = new Object()\", \"x = ({})\");\n     fold(\"x = Object()\", \"x = ({})\");\n \n+    disableNormalize();\n+    // Cannot fold above when not normalized\n+    foldSame(\"x = new Array\");\n+    foldSame(\"x = new Array()\");\n+    foldSame(\"x = Array()\");\n+    foldSame(\"x = new Object\");\n+    foldSame(\"x = new Object()\");\n+    foldSame(\"x = Object()\");\n+\n+    enableNormalize();\n     // Cannot fold, there are arguments\n     fold(\"x = new Array(7)\", \"x = Array(7)\");\n \n     foldSame(\"var x = new String(1)\");\n     foldSame(\"var x = new Number(1)\");\n     foldSame(\"var x = new Boolean(1)\");\n+\n+    enableNormalize();\n+\n     fold(\"var x = new Object('a')\", \"var x = Object('a')\");\n     fold(\"var x = new RegExp('')\", \"var x = RegExp('')\");\n     fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   }\n \n   public void testVarReferenceInExterns() {\n-    testSame(\"asdf;\", \"var asdf;\", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n+    testSame(\"asdf;\", \"var asdf;\",\n+        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR, true);\n   }\n \n   public void testCallInExterns() {\n     testSame(\"yz();\", \"function yz() {}\",\n-             VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n+        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR, true);\n+  }\n+\n+  public void testPropReferenceInExterns1() {\n+    testSame(\"asdf.foo;\", \"var asdf;\",\n+        VarCheck.UNDEFINED_EXTERN_VAR_ERROR, true);\n+  }\n+\n+  public void testPropReferenceInExterns2() {\n+    testSame(\"asdf.foo;\", \"\",\n+        VarCheck.UNDEFINED_EXTERN_VAR_ERROR, true);\n   }\n \n   public void testVarInWithBlock() {\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n     assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME));\n   }\n \n+  public void testBooleanProp() {\n+    Node n = getNode(\"a\");\n+\n+    n.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n+\n+    assertNull(n.lookupProperty(Node.IS_CONSTANT_NAME));\n+    assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+\n+    n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+\n+    assertNotNull(n.lookupProperty(Node.IS_CONSTANT_NAME));\n+    assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+\n+    n.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n+\n+    assertNull(n.lookupProperty(Node.IS_CONSTANT_NAME));\n+    assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+  }\n+\n+  // Verify that annotations on cloned nodes are properly handled.\n+  public void testCloneAnnontations2() {\n+    Node n = getNode(\"a\");\n+    n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    n.putBooleanProp(Node.IS_DISPATCHER, true);\n+    assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+    assertTrue(n.getBooleanProp(Node.IS_DISPATCHER));\n+\n+    Node nodeClone = n.cloneNode();\n+    assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME));\n+    assertTrue(nodeClone.getBooleanProp(Node.IS_DISPATCHER));\n+\n+    n.putBooleanProp(Node.IS_DISPATCHER, false);\n+    assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+    assertFalse(n.getBooleanProp(Node.IS_DISPATCHER));\n+\n+    assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME));\n+    assertTrue(nodeClone.getBooleanProp(Node.IS_DISPATCHER));\n+  }\n+\n   private static Node getNode(String js) {\n     Node root = parse(\"var a=(\" + js + \");\");\n     Node expr = root.getFirstChild();", "timestamp": 1277247642, "metainfo": ""}