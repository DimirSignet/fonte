{"sha": "086aeab1deabfa192544f14670d7d2fd2b12cffe", "log": "Fix chrome.tabs.sendRequest extern in javascript/chrome_externs.js.  (Matias)  Fork common.base.Tracer, so that it can be open-sourced in our codebase. Make it package-private until it gets open-sourced properly as a public library of guava. (Nick)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n-import com.google.common.base.Tracer;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Tracer;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n+/*\n+ * Copyright 2002 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Tracer provides a simple way to trace the handling of a request.\n+ *\n+ * By timing likely slow points in the code you can quickly pinpoint\n+ * why a request is slow.\n+ *\n+ * <p>Example usage:\n+ * <pre>\n+ * Tracer.initCurrentThreadTrace(); // must be called in each Thread\n+ * Tracer wholeRequest = new Tracer(null, \"Request \" + params);\n+ * try {\n+ *   ...\n+ *   t = new Tracer(\"Database\", \"getName()\");\n+ *   try {\n+ *     name = database.getName();\n+ *   } finally {\n+ *     t.stop();\n+ *   }\n+ *   ...\n+ *   t = new Tracer(null, \"call sendmail\");\n+ *   try {\n+ *     sendMessage();\n+ *   } finally {\n+ *     t.stop();\n+ *   }\n+ *   ...\n+ *   t = new Tracer(\"Database\", \"updateinfo()\");\n+ *   try {\n+ *     database.updateinfo(\"new info\");\n+ *   } finally {\n+ *     t.stop();\n+ *   }\n+ *   ...\n+ * } finally {\n+ *   if (wholeRequest.stop() > 1000) {\n+ *     // more than a second, better log\n+ *     Tracer.logAndClearCurrentThreadTrace();\n+ *   } else {\n+ *     Tracer.clearCurrentThreadTrace();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * Now slow requests will produce a report like this:\n+ * <pre>\n+ *       10.452 Start        Request cmd=dostuff\n+ *     3 10.455 Start        [Database] getName()\n+ *    34 10.489 Done   34 ms [Database] getName()\n+ *     3 10.491 Start        call sendmail\n+ *  1042 11.533 Done 1042 ms call sendmail\n+ *     0 11.533 Start        [Database] updateinfo()\n+ *     3 11.536 Done    3 ms [Database] updateinfo()\n+ *    64 11.600 Done 1148 ms Request cmd=dostuff\n+ *   TOTAL Database 2 (37 ms)\n+ * </pre>\n+ *\n+ * If you enabled pretty-printing by calling {@link Tracer#setPrettyPrint},\n+ * it will print more easily readable reports that use indentation to visualize\n+ * the tracer hierarchy and dynamically adjusts the padding to handle large\n+ * durations. Like:\n+ * <pre>\n+ *       10.452 Start        Request cmd=dostuff\n+ *     3 10.455 Start        | [Database] getName()\n+ *    34 10.489 Done   34 ms | [Database] getName()\n+ *     3 10.491 Start        | call sendmail\n+ *  1042 11.533 Done 1042 ms | call sendmail\n+ *     0 11.533 Start        | [Database] updateinfo()\n+ *     3 11.536 Done    3 ms | [Database] updateinfo()\n+ *    64 11.600 Done 1148 ms Request cmd=dostuff\n+ *   TOTAL Database 2 (37 ms)\n+ * </pre>\n+ * Pretty-printing is an application global setting and should only be called\n+ * in the main setup of an application, not in library code.\n+ *\n+ * Now you can easily see that sendmail is causing your problems, not\n+ * the two database calls.\n+ *\n+ * You can easily add additional tracing statistics to your Trace output by\n+ * adding additional tracing statistics. Simply add to your initialization code:\n+ * <pre>\n+ *    Tracer.addTracingStatistic(myTracingStatistic)\n+ * </pre>\n+ * where myTracingStatistic implements the {@link TracingStatistic} interface.\n+ * The class {@link com.google.monitoring.tracing.TracingStatistics} contains\n+ * several useful statistics such as cpu time, wait time, and memory usage.\n+ * If you add your own tracing statistics, the output is not quite as pretty,\n+ * but includes additional useful information.\n+ * <pre>\n+ *    31.980 Start        [LockManager] Waiting for user lock\n+ *   9 31.989 Done    9 ms    0ms cpu;  5944bytes;  [LockManager] Waiting for user lock\n+ *   0 31.989 Start        [CssClientImpl] ThreadGet (1 thread)\n+ *   5 31.994 Done    5 ms    0ms cpu;  2832bytes;  [CssClientImpl] ThreadGet (1 thread)\n+ *   0 31.994 Start        [MessageSorter] sort\n+ *   0 31.994 Done    0 ms    0ms cpu;   600bytes;  [MessageSorter] sort\n+ *   0 31.994 Start        [ConversationView] getMessageSummaries\n+ *   0 31.994 Start        [ConversationView] creating message summary 0\n+ *   1 31.995 Done    1 ms    0ms cpu;  5800bytes;  [ConversationView] creating message summary 0\n+ *   0 31.995 Start        [ConversationView] creating message summary 1\n+ *   0 31.995 Done    0 ms    0ms cpu;  5464bytes;  [ConversationView] creating message summary 1\n+ *   . . .\n+ * TOTAL NameDetector 3 (0 ms; 0 ms cpu;  784 bytes)\n+ * TOTAL Format 4 (1 ms; 0 ms cpu; 7344 bytes)\n+ * TOTAL ConversationView 5 (4 ms; 0 ms cpu; 55456 bytes)\n+ </pre>\n+\n+ * <p>If a Trace is given a type (the first argument to the constructor) and\n+ * multiple Traces are done on that type then a \"TOTAL line will be\n+ * produced showing the total number of traces and the sum of the time\n+ * (\"TOTAL Database 2 (37 ms)\" in our example). These traces should be\n+ * mutually exclusive or else the sum won't make sense (the time will\n+ * be double counted if the second starts before the first ends).\n+ *\n+ * <p>It is also possible to have a \"silent\" Tracer which does not appear\n+ * in the trace because it was faster than the silence threshold. This\n+ * threshold can be set for the for the current ThreadTrace with\n+ * setDefaultSilenceThreshold(threshold), or on a per-Tracer basis with\n+ * t.stop(threshold). Silent tracers are still counted in the type\n+ * totals, so these events are not completely lost.\n+ *\n+ * <p><b>WARNING:</b> This code makes a big assumption that\n+ * everything for a given trace is done within a single thread.\n+ * It uses threads to identify requests. It is fine to have multiple\n+ * requests traced in multiple simultaneous threads but it is not ok\n+ * to have any given request traced in multiple threads. (the results\n+ * will be scattered accross reports).\n+ *\n+ * Java objects do not support destructors (as in C++) so Tracer is not robust\n+ * when exceptions are thrown. Each Tracer object should be wrapped in a\n+ * try/finally block so that if an exception is thrown, the Tracer.stop()\n+ * method is guaranteed to be called.\n+ *\n+ * <p>A thread must call {@link Tracer#initCurrentThreadTrace()} to enable the\n+ * Tracer logging, otherwise Tracer does nothing.  The requirement to call\n+ * {@code initCurrentThreadTrace} avoids the situtation where Tracer is called\n+ * without the explicit knowledge of the application authors because they\n+ * happen to use a class in another package that uses Tracer. If {@link\n+ * Tracer#logCurrentThreadTrace} is called without calling {@link\n+ * Tracer#initCurrentThreadTrace()}, then a Third Eye WARNING message is logged,\n+ * which should help track down the problem.\n+ *\n+*\n+ */\n+final class Tracer {\n+  // package-private for access from unit tests\n+  static final Logger logger =\n+      Logger.getLogger(Tracer.class.getName());\n+\n+  /**\n+   * Whether pretty printing is enabled. This is intended to be set once\n+   * at application startup.\n+   */\n+  private static volatile boolean defaultPrettyPrint;\n+\n+  /* This list is guaranteed to only increase in length.  It contains a list of additional\n+   * statistics that the user wants to keep track of.\n+   */\n+  private static List<TracingStatistic> extraTracingStatistics =\n+      new CopyOnWriteArrayList<TracingStatistic>();\n+\n+  /** Values returned by extraTracingStatistics */\n+  private long[] extraTracingValues;\n+\n+  /** The type for grouping traces, may be null */\n+  private final @Nullable String type;\n+\n+  /** A comment string for the report */\n+  private final String comment;\n+\n+  /** Start time of the trace */\n+  private final long startTimeMs;\n+\n+  /** Stop time of the trace, non-final */\n+  private long stopTimeMs;\n+\n+  /**\n+   * Record our starter thread in order to trap Traces that are started in one\n+   * thread and stopped in another\n+   */\n+  final Thread startThread;\n+\n+  /**\n+   * We limit the number of events in a Trace in order to catch memory\n+   * leaks (a thread that keeps logging events and never clears them).\n+   * This number is arbitrary and can be increased if necessary (though\n+   * if there are more than 1000 events then the Tracer is probably being\n+   * misused).\n+   */\n+  static final int MAX_TRACE_SIZE = 1000;\n+\n+  /**\n+   * For unit testing. Can't use {@link com.google.common.time} because\n+   * this code is in base and has minimal dependencies.\n+   */\n+  static interface InternalClock {\n+    long currentTimeMillis();\n+  }\n+\n+  /**\n+   * Default clock that calls through to the system clock. Can be overridden\n+   * in unit tests.\n+   */\n+  static InternalClock clock = new InternalClock() {\n+    public long currentTimeMillis() {\n+      return System.currentTimeMillis();\n+    }\n+  };\n+\n+  /**\n+   * Create and start a tracer.\n+   * Both type and comment may be null. See class comment for usage.\n+   *\n+   * @param type The type for totalling\n+   * @param comment Comment about this tracer\n+   */\n+  Tracer(@Nullable String type, @Nullable String comment) {\n+    this.type = type;\n+    this.comment = comment == null ? \"\" : comment;\n+    startTimeMs = clock.currentTimeMillis();\n+    startThread = Thread.currentThread();\n+    if (!extraTracingStatistics.isEmpty()) {\n+      int size = extraTracingStatistics.size();\n+      extraTracingValues = new long[size];\n+      int i = 0;\n+      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n+        extraTracingValues[i] = tracingStatistic.start(startThread);\n+        i++;\n+      }\n+    }\n+\n+    ThreadTrace trace = getThreadTrace();\n+\n+    // Do nothing if the current thread trace wasn't initialized.\n+    if (!trace.isInitialized()) {\n+      return;\n+    }\n+\n+    // Check if we are creating too many Tracers.\n+    if (trace.events.size() >= MAX_TRACE_SIZE) {\n+      logger.log(Level.WARNING,\n+                  \"Giant thread trace. Too many Tracers created. \"\n+                    + \"Clearing to avoid memory leak.\",\n+                  new Throwable(trace.toString()));\n+      trace.truncateEvents();\n+    }\n+\n+    // Check if we forgot to close the Tracers.\n+    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n+      logger.log(Level.WARNING,\n+                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n+                    + \"or Tracer.stop() is not wrapped in a \"\n+                    + \"try/finally block. \"\n+                    + \"Clearing to avoid memory leak.\",\n+                  new Throwable(trace.toString()));\n+      trace.truncateOutstandingEvents();\n+    }\n+\n+    trace.startEvent(this);\n+  }\n+\n+  /**\n+   * Create a tracer that isn't summed as part of a total\n+   *\n+   * @param comment  Comment about this tracer\n+   */\n+  Tracer(String comment) {\n+    this(null, comment);\n+  }\n+\n+  /**\n+   * Construct a tracer whose type is based on the short name of the object\n+   * @param object   Object to use as type name\n+   * @param comment  A comment\n+   * @return  new Tracer.\n+   */\n+  static Tracer shortName(Object object, String comment) {\n+    if (object == null) {\n+      return new Tracer(comment);\n+    }\n+    return new Tracer(object.getClass().getSimpleName(), comment);\n+  }\n+\n+  /**\n+   * Converts 'v' to a string and pads it with up to 16 spaces for\n+   * improved alignment.\n+   * @param v The value to convert.\n+   * @param digits_column_width The desired with of the string.\n+   */\n+  private static String longToPaddedString(long v, int digits_column_width) {\n+    int digit_width = numDigits(v);\n+    StringBuilder sb = new StringBuilder();\n+    appendSpaces(sb, digits_column_width - digit_width);\n+    sb.append(v);\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Gets the number of digits in an integer when printed in base 10. Assumes\n+   * a positive integer.\n+   * @param n The value.\n+   * @return The number of digits in the string.\n+   */\n+  private static int numDigits(long n) {\n+    int i = 0;\n+    do {\n+      i++;\n+      n = n / 10;\n+    } while (n > 0);\n+    return i;\n+  }\n+\n+  /**\n+   * Gets a string of spaces of the length specified.\n+   * @param sb The string builder to append to.\n+   * @param numSpaces The number of spaces in the string.\n+   */\n+  @VisibleForTesting\n+  static void appendSpaces(StringBuilder sb, int numSpaces) {\n+    if (numSpaces > 16) {\n+      logger.warning(\"Tracer.appendSpaces called with large numSpaces\");\n+      // Avoid long loop in case some bug in the caller\n+      numSpaces = 16;\n+    }\n+    while (numSpaces >= 5) {\n+      sb.append(\"     \");\n+      numSpaces -= 5;\n+    }\n+\n+    // We know it's less than 5 now\n+    switch (numSpaces) {\n+      case 1:\n+        sb.append(\" \");\n+        break;\n+      case 2:\n+        sb.append(\"  \");\n+        break;\n+      case 3:\n+        sb.append(\"   \");\n+        break;\n+      case 4:\n+        sb.append(\"    \");\n+        break;\n+    }\n+  }\n+  \n+  /**\n+   * Adds a new tracing statistic to a trace\n+   *\n+   * @param tracingStatistic to enable a run\n+   * @return The index of this statistic (for use with stat.extraInfo()), or\n+   *         -1 if the statistic is not enabled.\n+   */\n+  static int addTracingStatistic(TracingStatistic tracingStatistic) {\n+    // Check to see if we can enable the tracing statistic before actually\n+    // adding it.\n+    if (tracingStatistic.enable()) {\n+      // No synchronization needed, since this is a copy-on-write array.\n+      extraTracingStatistics.add(tracingStatistic);\n+      // 99.9% of the time, this will be O(1) and return extraTracingStatistics.length - 1\n+      return extraTracingStatistics.lastIndexOf(tracingStatistic);\n+    } else {\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * For testing purposes only.  These removes all current tracers.  Severe errors can occur\n+   * if there are any active tracers going on when this is called.\n+   *\n+   * The test suite uses this to remove any tracers that it has added.\n+   */\n+  @VisibleForTesting\n+  static void clearTracingStatisticsTestingOnly() {\n+    extraTracingStatistics.clear();\n+  }\n+\n+  /**\n+   * Stop the trace.\n+   * This may only be done once and must be done from the same thread\n+   * that started it.\n+   * @param silence_threshold Traces for time less than silence_threshold\n+   * ms will be left out of the trace report. A value of -1 indicates\n+   * that the current ThreadTrace silence_threshold should be used.\n+   * @return The time that this trace actually ran\n+   */\n+  long stop(int silence_threshold) {\n+    Preconditions.checkState(Thread.currentThread() == startThread);\n+\n+    ThreadTrace trace = getThreadTrace();\n+    // Do nothing if the thread trace was not initialized.\n+    if (!trace.isInitialized()) {\n+      return 0;\n+    }\n+\n+    stopTimeMs = clock.currentTimeMillis();\n+    if (extraTracingValues != null) {\n+      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n+      // a new statistic may have been added\n+      for (int i = 0; i < extraTracingValues.length; i++) {\n+        long value = extraTracingStatistics.get(i).stop(startThread);\n+        extraTracingValues[i] = value - extraTracingValues[i];\n+      }\n+    }\n+\n+    // Do nothing if the thread trace was not initialized.\n+    if (!trace.isInitialized()) {\n+      return 0;\n+    }\n+\n+    trace.endEvent(this, silence_threshold);\n+    return stopTimeMs - startTimeMs;\n+  }\n+\n+  /** Stop the trace using the default silence_threshold\n+   *\n+   * @return  The time that this trace actually ran.\n+   */\n+  long stop() {\n+    return stop(-1);\n+  }\n+\n+  @Override public String toString() {\n+    if (type == null) {\n+      return comment;\n+    } else {\n+      return \"[\" + type + \"] \" + comment;\n+    }\n+  }\n+\n+  static void setDefaultSilenceThreshold(int threshold) {\n+    getThreadTrace().defaultSilenceThreshold = threshold;\n+  }\n+\n+  /**\n+   * Initialize the trace associated with the current thread by clearing\n+   * out any existing trace. There shouldn't be a trace so if one is\n+   * found we log it as an error.\n+   */\n+  static void initCurrentThreadTrace() {\n+    ThreadTrace events = getThreadTrace();\n+    if (!events.isEmpty()) {\n+      logger.log(Level.WARNING,\n+                 \"Non-empty timer log:\\n\" + events,\n+                 new Throwable());\n+      clearThreadTrace();\n+\n+      // Grab a new thread trace if we find a previous non-empty ThreadTrace.\n+      events = getThreadTrace();\n+    }\n+\n+    // Mark the thread trace as initialized.\n+    events.init();\n+  }\n+\n+  static void initCurrentThreadTrace(int default_silence_threshold) {\n+    initCurrentThreadTrace();\n+    setDefaultSilenceThreshold(default_silence_threshold);\n+  }\n+\n+  /**\n+   * Returns a timer report similar to the one described in the class comment.\n+   *\n+   * @return The timer report as a string\n+   */\n+  static String getCurrentThreadTraceReport() {\n+    return getThreadTrace().toString();\n+  }\n+\n+  /**\n+   * Logs a timer report similar to the one described in the class comment.\n+   */\n+  static void logCurrentThreadTrace() {\n+    ThreadTrace trace = getThreadTrace();\n+\n+    // New threads must call Tracer.initCurrentThreadTrace() before Tracer\n+    // statistics are gathered. This is a recent change (Jun 2007) that\n+    // prevents spurious Third Eye messages when an application uses a class in\n+    // a different package that happens to call Tracer without knowledge of the\n+    // application authors.\n+    if (!trace.isInitialized()) {\n+      logger.log(Level.WARNING,\n+                 \"Tracer log requested for this thread but was not \"\n+                 + \"initialized using Tracer.initCurrentThreadTrace().\",\n+                 new Throwable());\n+      return;\n+    }\n+\n+    if (!trace.isEmpty()) {\n+      logger.log(Level.INFO, \"timers:\\n{0}\", getCurrentThreadTraceReport());\n+    }\n+  }\n+\n+  /**\n+   * Throw away any Trace associated with the current thread.\n+   */\n+  static void clearCurrentThreadTrace() {\n+    clearThreadTrace();\n+  }\n+\n+  /**\n+   * logCurrentThreadTrace() then clearCurrentThreadTrace()\n+   */\n+  static void logAndClearCurrentThreadTrace() {\n+    logCurrentThreadTrace();\n+    clearThreadTrace();\n+  }\n+\n+  /**\n+   * Sets whether pretty printing is enabled. See class-level comment. This\n+   * only affects tracers created after this is called.\n+   * @param enabled Whether to enable pretty printing.\n+   */\n+  static void setPrettyPrint(boolean enabled) {\n+    defaultPrettyPrint = enabled;\n+  }\n+\n+  /** Statistics for a given tracer type */\n+  static final class Stat {\n+    private int count;\n+    private int silent;\n+    private int clockTime;\n+    private int[] extraInfo;\n+\n+    /** total count of tracers of a type, including silent\n+     *\n+     * @return total count of tracers, including silent tracers\n+     */\n+    int getCount() { return count; }\n+\n+    /** total count of silent tracers of a type\n+     *\n+     * @return total count of silent tracers\n+     */\n+    int getSilentCount() { return silent; }\n+\n+    /** total time spent in tracers of a type, in ms\n+     *\n+     * @return total time spent in tracer, in ms\n+     */\n+    int getTotalTime() { return clockTime; }\n+\n+    /** total time spent doing additional things that we are clocking */\n+    @VisibleForTesting\n+    int getExtraInfo(int index) {\n+      return index >= extraInfo.length ? 0 : extraInfo[index];\n+    }\n+\n+  }\n+\n+  /**\n+   * This map tracks counts of tracers for each type over all time.\n+   */\n+  private static @Nullable AtomicTracerStatMap typeToCountMap;\n+\n+  /**\n+   * This map tracks counts of silent tracers for each type over all time.\n+   */\n+  private static @Nullable AtomicTracerStatMap typeToSilentMap;\n+\n+  /**\n+   * This map tracks time (ms) for each type over all time.\n+   */\n+  private static @Nullable AtomicTracerStatMap typeToTimeMap;\n+\n+  /**\n+   * This method MUST be called before getTypeToCountMap (and friends)\n+   * will return a valid map.  This is because computing this information\n+   * imposes a synchronization penalty on every Tracer that is stopped.\n+   */\n+  static synchronized void enableTypeMaps() {\n+    if (typeToCountMap == null) {\n+      typeToCountMap = new AtomicTracerStatMap();\n+      typeToSilentMap = new AtomicTracerStatMap();\n+      typeToTimeMap = new AtomicTracerStatMap();\n+    }\n+  }\n+\n+  /**\n+   * Used for exporting this data via varz.  Accesses to this\n+   * map must be synchronized on the map.  If enableTypeMaps has not\n+   * been called, this will return null.\n+   */\n+  static @Nullable Map<String, Long> getTypeToCountMap() {\n+    return typeToCountMap != null ? typeToCountMap.getMap() : null;\n+  }\n+\n+  /**\n+   * Used for exporting this data via varz.  Accesses to this\n+   * map must be synchronized on the map.  If enableTypeMaps has not\n+   * been called, this will return null.\n+   */\n+  static @Nullable Map<String, Long> getTypeToSilentMap() {\n+    return typeToSilentMap != null ? typeToSilentMap.getMap() : null;\n+  }\n+\n+  /**\n+   * Used for exporting this data via varz.  Accesses to this\n+   * map must be synchronized on the map.  If enableTypeMaps has not\n+   * been called, this will return null.\n+   */\n+  static @Nullable Map<String, Long> getTypeToTimeMap() {\n+    return typeToTimeMap != null ? typeToTimeMap.getMap() : null;\n+  }\n+\n+  /** Gets the Stat for a tracer type; never returns null */\n+  static Stat getStatsForType(String type) {\n+    Stat stat = getThreadTrace().stats.get(type);\n+    return stat != null ? stat : ZERO_STAT;\n+  }\n+\n+  private static final Stat ZERO_STAT = new Stat();\n+\n+  /** Return the sec.ms part of time (if time = \"20:06:11.566\",  \"11.566\") */\n+  private static String formatTime(long time) {\n+    int sec = (int) ((time / 1000) % 60);\n+    int ms = (int) (time % 1000);\n+    return String.format(\"%02d.%03d\", sec, ms);\n+  }\n+\n+  /** An event is created every time a Tracer is created or stopped */\n+  private static final class Event {\n+    boolean isStart;   // else is_stop\n+    Tracer tracer;\n+\n+    Event(boolean start, Tracer t) {\n+      isStart = start;\n+      tracer = t;\n+    }\n+\n+    long eventTime() {\n+      return isStart ? tracer.startTimeMs : tracer.stopTimeMs;\n+    }\n+\n+    /**\n+     * Converts the event to a formatted string.\n+     * @param prevEventTime The time of the previous event which appears at\n+     *     the left most part of the trace line.\n+     * @param indent The indentation to put before the tracer to show the\n+     *     hieararchy.\n+     * @param digitsColWidth How many characters the digits should use.\n+     * @return The formatted string.\n+     */\n+    String toString(long prevEventTime, String indent, int digitsColWidth) {\n+      StringBuilder sb = new StringBuilder(120);\n+\n+      if (prevEventTime == -1) {\n+        appendSpaces(sb, digitsColWidth);\n+      } else {\n+        sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth));\n+      }\n+\n+      sb.append(' ');\n+      sb.append(formatTime(eventTime()));\n+      if (isStart) {\n+        sb.append(\" Start \");\n+        appendSpaces(sb, digitsColWidth);\n+        sb.append(\"   \");\n+      } else {\n+        sb.append(\" Done \");\n+        long delta = tracer.stopTimeMs - tracer.startTimeMs;\n+        sb.append(longToPaddedString(delta, digitsColWidth));\n+        sb.append(\" ms \");\n+        if (tracer.extraTracingValues != null) {\n+          for (int i = 0; i < tracer.extraTracingValues.length; i++) {\n+            delta = tracer.extraTracingValues[i];\n+            sb.append(String.format(\"%4d\", delta));\n+            sb.append(extraTracingStatistics.get(i).getUnits());\n+            sb.append(\";  \");\n+          }\n+        }\n+      }\n+      sb.append(indent);\n+      sb.append(tracer.toString());\n+      return sb.toString();\n+    }\n+  }\n+\n+  /** Stores a thread's Trace */\n+  static final class ThreadTrace {\n+\n+    /** Events taking less than this number of milliseconds are not reported. */\n+    int defaultSilenceThreshold; // non-final\n+\n+    /** The Events corresponding to each startEvent/stopEvent */\n+    final ArrayList<Event> events = new ArrayList<Event>();\n+\n+    /** Tracers that have not had their .stop() called */\n+    final HashSet<Tracer> outstandingEvents = new HashSet<Tracer>();\n+\n+    /** Map from type to Stat object */\n+    final Map<String, Stat> stats = new HashMap<String, Stat>();\n+\n+    /**\n+     * True if {@code outstandingEvents} has been cleared because we exceeded\n+     * the max trace limit.\n+     */\n+    boolean isOutstandingEventsTruncated = false;\n+\n+    /**\n+     * True if {@code events} has been cleared because we exceeded the max\n+     * trace limit.\n+     */\n+    boolean isEventsTruncated = false;\n+\n+    /**\n+     * Set to true if {@link Tracer#initCurrentThreadTrace()} was called by\n+     * the current thread.\n+     */\n+    boolean isInitialized = false;\n+\n+    /**\n+     * Whether pretty printing is enabled for the trace.\n+     */\n+    boolean prettyPrint = false;\n+\n+    /** Initialize the trace.  */\n+    void init() {\n+      isInitialized = true;\n+    }\n+\n+    /** Is initialized? */\n+    boolean isInitialized() {\n+      return isInitialized;\n+    }\n+\n+    /**\n+     * Called by the constructor {@link Tracer#Tracer(String, String)} to create\n+     * a start event.\n+     */\n+    void startEvent(Tracer t) {\n+      events.add(new Event(true, t));\n+      boolean notAlreadyOutstanding = outstandingEvents.add(t);\n+      Preconditions.checkState(notAlreadyOutstanding);\n+    }\n+\n+    /**\n+     * Called by {@link Tracer#stop()} to create a stop event.\n+     */\n+    void endEvent(Tracer t, int silenceThreshold) {\n+      boolean wasOutstanding = outstandingEvents.remove(t);\n+      if (!wasOutstanding) {\n+        if (isOutstandingEventsTruncated) {\n+          // The events stack overflowed and was truncated, so just log a\n+          // warning. Otherwise, we get an exception which is extremely\n+          // confusing.\n+          logger.log(Level.WARNING,\n+                      \"event not found, probably because the event stack \"\n+                          + \"overflowed and was truncated\",\n+                      new Throwable());\n+        } else {\n+          // throw an exception if the event was not found and the events stack\n+          // is pristine\n+          throw new IllegalStateException();\n+        }\n+      }\n+\n+      long elapsed = t.stopTimeMs - t.startTimeMs;\n+\n+      if (silenceThreshold == -1) {   // use default\n+        silenceThreshold = defaultSilenceThreshold;\n+      }\n+\n+      if (elapsed < silenceThreshold) {\n+        // If this one is silent then we need to remove the start Event\n+        boolean removed = false;\n+        for (int i = 0; i < events.size(); i++) {\n+          Event e = events.get(i);\n+          if (e.tracer == t) {\n+            Preconditions.checkState(e.isStart);\n+            events.remove(i);\n+            removed = true;\n+            break;\n+          }\n+        }\n+\n+        // Only assert if we didn't find the original and the events\n+        // weren't truncated.\n+        Preconditions.checkState(removed || isEventsTruncated);\n+      } else {\n+        events.add(new Event(false, t));\n+      }\n+\n+      if (t.type != null) {\n+        Stat stat = stats.get(t.type);\n+        if (stat == null) {\n+          stat = new Stat();\n+          if (!extraTracingStatistics.isEmpty()) {\n+            stat.extraInfo = new int[extraTracingStatistics.size()];\n+          }\n+          stats.put(t.type, stat);\n+        }\n+\n+        stat.count++;\n+        if (typeToCountMap != null) {\n+          typeToCountMap.incrementBy(t.type, 1);\n+        }\n+\n+        stat.clockTime += elapsed;\n+        if (typeToTimeMap != null) {\n+          typeToTimeMap.incrementBy(t.type, elapsed);\n+        }\n+\n+        if (stat.extraInfo != null && t.extraTracingValues != null) {\n+          int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length);\n+          for (int i = 0; i < overlapLength; i++) {\n+            stat.extraInfo[i] += t.extraTracingValues[i];\n+            AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat();\n+            if (map != null) {\n+              map.incrementBy(t.type, t.extraTracingValues[i]);\n+            }\n+          }\n+        }\n+\n+        if (elapsed < silenceThreshold) {\n+          stat.silent++;\n+          if (typeToSilentMap != null) {\n+            typeToSilentMap.incrementBy(t.type, 1);\n+          }\n+        }\n+      }\n+    }\n+\n+    boolean isEmpty() {\n+      return events.size() == 0 && outstandingEvents.size() == 0;\n+    }\n+\n+    void truncateOutstandingEvents() {\n+      isOutstandingEventsTruncated = true;\n+      outstandingEvents.clear();\n+    }\n+\n+    void truncateEvents() {\n+      isEventsTruncated = true;\n+      events.clear();\n+    }\n+\n+    /** Produces the lovely Trace seen in the class comments */\n+    // Nullness checker does not understand that prettyPrint => indent != null\n+    @SuppressWarnings(\"nullness\")\n+    @Override public String toString() {\n+\n+      int numDigits = getMaxDigits();\n+      StringBuilder sb = new StringBuilder();\n+      long etime = -1;\n+      LinkedList<String> indent = prettyPrint ? new LinkedList<String>() : null;\n+      for (Event e : events) {\n+        if (prettyPrint && !e.isStart && !indent.isEmpty()) {\n+          indent.pop();\n+        }\n+        sb.append(\" \");\n+        if (prettyPrint) {\n+          sb.append(e.toString(etime, Joiner.on(\"\").join(indent), numDigits));\n+        } else {\n+          sb.append(e.toString(etime, \"\", 4));\n+        }\n+        etime = e.eventTime();\n+        sb.append('\\n');\n+        if (prettyPrint && e.isStart) {\n+          indent.push(\"|  \");\n+        }\n+      }\n+\n+      if (outstandingEvents.size() != 0) {\n+        long now = clock.currentTimeMillis();\n+\n+        sb.append(\" Unstopped timers:\\n\");\n+        for (Tracer t : outstandingEvents) {\n+          sb.append(\"  \").\n+            append(t).\n+            append(\" (\").\n+            append(now - t.startTimeMs).\n+            append(\" ms, started at \").\n+            append(formatTime(t.startTimeMs)).\n+            append(\")\\n\");\n+        }\n+      }\n+\n+      for (String key : stats.keySet()) {\n+        Stat stat = stats.get(key);\n+        if (stat.count > 1) {\n+          sb.append(\" TOTAL \").\n+             append(key).\n+             append(\" \").\n+             append(stat.count).\n+             append(\" (\").\n+             append(stat.clockTime).\n+             append(\" ms\");\n+          if (stat.extraInfo != null) {\n+            for (int i = 0; i < stat.extraInfo.length; i++) {\n+              sb.append(\"; \");\n+              sb.append(stat.extraInfo[i]).\n+                 append(' ').\n+                 append(extraTracingStatistics.get(i).getUnits());\n+            }\n+          }\n+          sb.append(\")\\n\");\n+        }\n+      }\n+      return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the maximum number of digits that can appear in the tracer output\n+     * in the gaps between tracers or the duration of a tracer. This is used\n+     * by the pretty printing case so that all of the tracers are aligned.\n+     */\n+    private int getMaxDigits() {\n+      long etime = -1;\n+      long max_time = 0;\n+      for (Event e : events) {\n+        if (etime != -1) {\n+          long time = e.eventTime() - etime;\n+          max_time = Math.max(max_time, time);\n+        }\n+        if (!e.isStart) {\n+          long time = e.tracer.stopTimeMs - e.tracer.startTimeMs;\n+          max_time = Math.max(max_time, time);\n+        }\n+        etime = e.eventTime();\n+      }\n+      // Minimum is 3 to preserve an indent even when max is small. \n+      return Math.max(3, numDigits(max_time));\n+    }\n+  }\n+\n+  /** Holds the ThreadTrace for each thread.  */\n+  private static ThreadLocal<ThreadTrace> traces = new ThreadLocal<ThreadTrace>();\n+\n+  /**\n+   * Get the ThreadTrace for the current thread, creating one if necessary.\n+   */\n+  static ThreadTrace getThreadTrace() {\n+    ThreadTrace t = traces.get();\n+    if (t == null) {\n+      t = new ThreadTrace();\n+      t.prettyPrint = defaultPrettyPrint;\n+      traces.set(t);\n+    }\n+    return t;\n+  }\n+\n+  /** Remove any ThreadTrace associated with the current thread */\n+  static void clearThreadTrace() {\n+    traces.set(null);\n+  }\n+\n+  /**\n+   * A TracingStatistic allows the program to add additional optional statistics to the trace\n+   * output.\n+   *\n+   * The class {@link com.google.monitoring.tracing.TracingStatistics} contains several\n+   * useful tracing statistics\n+   *\n+*\n+   */\n+  static interface TracingStatistic {\n+    /**\n+     * This method is called at the start of the trace.  It should return a numeric result\n+     * indicating the amount of the specific resource in use before the call started\n+     * @param thread  The current thread\n+     * @return   A numeric value indicating the amount of the resource already used.\n+     */\n+    long start(Thread thread);\n+\n+    /**\n+     * This method is called at the end of the trace.  It should return a numeric result\n+     * indicating the amount of the specific resource in use after the call ends. The actual\n+     * reported result will be the result end() - start()\n+     * @param thread  The current thread\n+     * @return   A numeric value indicating the amount of the resource currently used.\n+     */\n+    long stop(Thread thread);\n+\n+    /**\n+     * Called when this tracing statistic is first enabled.  A return value of True indicates that\n+     * this statistic can successfully run in the current JVM.\n+     *\n+     * @return  An indication of whether this statistic can be implemented in the current JVM.\n+     */\n+    boolean enable();\n+\n+    /** Returns this tracing statistic's trace map.\n+     *\n+     * @return This tracing statistic's trace map.\n+     */\n+    AtomicTracerStatMap getTracingStat();\n+\n+    /** A string that should be appended to the numeric output indicating what this is.\n+     *\n+     * @return  A string indicating the units of this statistic and what it is.\n+     */\n+    String getUnits();\n+  }\n+\n+  /**\n+   * This class encapsulates a map for keeping track of tracing statistics.\n+   * It allows the caller to atomically increment named fields.\n+   *\n+*\n+   */\n+  static final class AtomicTracerStatMap {\n+    private ConcurrentMap<String, Long> map = new ConcurrentHashMap<String, Long>();\n+\n+    /**\n+     * Atomically increment the specified field by the specified amount.\n+     *\n+     * @param key      the name of the field\n+     * @param delta    the amount by which to increment the field\n+     */\n+    // Nullness checker is not powerful enough to prove null-safety of this method\n+    @SuppressWarnings(\"nullness\")\n+        void incrementBy(String key, long delta) {\n+      // We use a compareAndSet strategy to update the map, which is much\n+      // faster when there isn't too much contention.  Look at a value, and\n+      // conditionally update the map if the value hasn't changed.\n+      // If it has changed, repeat.\n+      Long oldValue = map.get(key);\n+      if (oldValue == null) {\n+        // Currently, the slot is empty\n+        oldValue = map.putIfAbsent(key, delta);\n+        if (oldValue == null) {\n+          // The slot was still empty when we set it\n+          return;\n+        } else {\n+          // Someone filled in the slot behind our back.  oldValue has its current value\n+        }\n+      }\n+      while (true) {\n+        if (map.replace(key, oldValue, oldValue + delta)) {\n+          break;\n+        }\n+        // Nullness checker doesn't understand that this cannot return null.\n+        oldValue = map.get(key);\n+      }\n+    }\n+\n+    /**\n+     * Returns a map of key:value pairs.\n+     */\n+    Map<String, Long> getMap() {\n+      return map;\n+    }\n+  }\n+}", "timestamp": 1266511633, "metainfo": ""}