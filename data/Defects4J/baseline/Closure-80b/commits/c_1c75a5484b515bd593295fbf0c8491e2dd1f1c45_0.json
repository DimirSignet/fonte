{"sha": "1c75a5484b515bd593295fbf0c8491e2dd1f1c45", "log": "remove all uses of Sets of types. equality can change over time, so this is not safe. This means we need to be much more explicit in how we collapse type duplicates in unions and in type tightening  R=johnlenz DELTA=319  (210 added, 52 deleted, 57 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=121   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-\n import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n-\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n \n       // If we didn't find a type that has the property, then check if there\n       // exists a property with this name anywhere in the externs.\n-      Set<ObjectType> types = getTypeRegistry().getTypesWithProperty(prop);\n-      for (ObjectType type : types) {\n-        actions.addAll(getImplicitActionsFromPropNonUnion(type, prop, fnNode));\n+      for (ObjectType type :\n+               getTypeRegistry().getEachReferenceTypeWithProperty(prop)) {\n+        actions.addAll(\n+            getImplicitActionsFromPropNonUnion(\n+                  type, prop, fnNode));\n       }\n       return actions;\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n   // A map of properties to the types on which those properties have been\n   // declared.\n-  private final Map<String, Set<ObjectType>> typesIndexedByProperty =\n+  private final Map<String, UnionTypeBuilder> typesIndexedByProperty =\n       Maps.newHashMap();\n+\n+  // A map of properties to each reference type on which those\n+  // properties have been declared. Each type has a unique name used\n+  // for de-duping.\n+  private final Map<String, Map<String, ObjectType>>\n+      eachRefTypeIndexedByProperty = Maps.newHashMap();\n \n   // A map of properties to the greatest subtype on which those properties have\n   // been declared. This is filled lazily from the types declared in\n    */\n   public void resetForTypeCheck() {\n     typesIndexedByProperty.clear();\n+    eachRefTypeIndexedByProperty.clear();\n     initializeBuiltInTypes();\n     namesToTypes.clear();\n     namespaces.clear();\n       createFunctionType(ALL_TYPE, true, NO_TYPE);\n     registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n         GREATEST_FUNCTION_TYPE);\n+\n+    // Register the prototype property. See the comments below in\n+    // registerPropertyOnType about the bootstrapping process.\n+    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n   }\n \n   private void initializeRegistry() {\n    * show up in the type registry\").\n    */\n   public void registerPropertyOnType(String propertyName, JSType type) {\n-    ObjectType owner = null;\n-\n-    // Properties can only be defined on object types, so normalize everything\n-    // to discrete object types.\n-    if (type instanceof ObjectType) {\n-      owner = (ObjectType) type;\n-    } else if (getNativeType(ALL_TYPE).isSubtype(type)) {\n-      owner = getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n+    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n+    if (typeSet == null) {\n+      typeSet = new UnionTypeBuilder(this);\n+      typesIndexedByProperty.put(propertyName, typeSet);\n+    }\n+\n+    typeSet.addAlternate(type);\n+    addReferenceTypeIndexedByProperty(propertyName, type);\n+\n+    // Clear cached values that depend on typesIndexedByProperty.\n+    greatestSubtypeByProperty.remove(propertyName);\n+  }\n+\n+  private void addReferenceTypeIndexedByProperty(\n+      String propertyName, JSType type) {\n+    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n+      Map<String, ObjectType> typeSet =\n+          eachRefTypeIndexedByProperty.get(propertyName);\n+      if (typeSet == null) {\n+        typeSet = Maps.newHashMap();\n+        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n+      }\n+      ObjectType objType = (ObjectType) type;\n+      typeSet.put(objType.getReferenceName(), objType);\n+    } else if (type instanceof NamedType) {\n+      addReferenceTypeIndexedByProperty(\n+          propertyName, ((NamedType) type).getReferencedType());\n     } else if (type instanceof UnionType) {\n       for (JSType alternate : ((UnionType) type).getAlternates()) {\n-        registerPropertyOnType(propertyName, alternate);\n+        addReferenceTypeIndexedByProperty(propertyName, alternate);\n       }\n     }\n-\n-    if (owner == null) {\n-      return;\n-    }\n-\n-    Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName);\n-    if (typeSet == null) {\n-      typesIndexedByProperty.put(\n-          propertyName, typeSet = new LinkedHashSet<ObjectType>());\n-    }\n-    greatestSubtypeByProperty.remove(propertyName);\n-    typeSet.add(owner);\n   }\n \n   /**\n           .getGreatestSubtype(type);\n     }\n     if (typesIndexedByProperty.containsKey(propertyName)) {\n-      UnionTypeBuilder builder = new UnionTypeBuilder(this);\n-      for (JSType alt : typesIndexedByProperty.get(propertyName)) {\n-        builder.addAlternate(alt);\n-      }\n-      JSType built = builder.build();\n+      JSType built = typesIndexedByProperty.get(propertyName).build();\n       greatestSubtypeByProperty.put(propertyName, built);\n       return built.getGreatestSubtype(type);\n     }\n    */\n   public boolean canPropertyBeDefined(JSType type, String propertyName) {\n     if (typesIndexedByProperty.containsKey(propertyName)) {\n-      for (JSType alt : typesIndexedByProperty.get(propertyName)) {\n+      for (JSType alt :\n+               typesIndexedByProperty.get(propertyName).getAlternates()) {\n         if (!alt.getGreatestSubtype(type).isEmptyType()) {\n           return true;\n         }\n       }\n     }\n-\n     return false;\n   }\n \n   /**\n    * Returns each type that has a property {@code propertyName} defined on it.\n-   */\n-  public Set<ObjectType> getTypesWithProperty(String propertyName) {\n-    Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName);\n-    if (typeSet == null) {\n-      Set<ObjectType> set = new LinkedHashSet<ObjectType>();\n-      set.add(getNativeObjectType(NO_TYPE));\n-      return set;\n-    }\n-    return typeSet;\n+   *\n+   * Like most types in our type system, the collection of types returned\n+   * will be collapsed. This means that if a type is defined on\n+   * {@code Object} and on {@code Array}, it would be reasonable for this\n+   * method to return either {@code [Object, Array]} or just {@code [Object]}.\n+   */\n+  public Iterable<JSType> getTypesWithProperty(String propertyName) {\n+    if (typesIndexedByProperty.containsKey(propertyName)) {\n+      return typesIndexedByProperty.get(propertyName).getAlternates();\n+    } else {\n+      return ImmutableList.of();\n+    }\n+  }\n+\n+  /**\n+   * Returns each reference type that has a property {@code propertyName}\n+   * defined on it.\n+   *\n+   * Unlike most types in our type system, the collection of types returned\n+   * will not be collapsed. This means that if a type is defined on\n+   * {@code Object} and on {@code Array}, this method must return\n+   * {@code [Object, Array]}. It would not be correct to collapse them to\n+   * {@code [Object]}.\n+   */\n+  public Iterable<ObjectType> getEachReferenceTypeWithProperty(\n+      String propertyName) {\n+    if (eachRefTypeIndexedByProperty.containsKey(propertyName)) {\n+      return eachRefTypeIndexedByProperty.get(propertyName).values();\n+    } else {\n+      return ImmutableList.of();\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    */\n   public final boolean defineDeclaredProperty(String propertyName,\n       JSType type, boolean inExterns) {\n+    boolean result = defineProperty(propertyName, type, false, inExterns);\n+\n     // All property definitions go through this method\n-    // or defineInferredProperty.\n+    // or defineDeclaredProperty. Because the properties defined an an\n+    // object can affect subtyping, it's slightly more efficient\n+    // to register this after defining the property.\n     registry.registerPropertyOnType(propertyName, this);\n \n-    return defineProperty(propertyName, type, false, inExterns);\n+    return result;\n   }\n \n   /**\n    */\n   public final boolean defineInferredProperty(String propertyName,\n       JSType type, boolean inExterns) {\n-    // All property definitions go through this method\n-    // or defineDeclaredProperty.\n-    registry.registerPropertyOnType(propertyName, this);\n-\n     if (hasProperty(propertyName)) {\n       JSType originalType = getPropertyType(propertyName);\n       type = originalType == null ? type :\n           originalType.getLeastSupertype(type);\n     }\n \n-    return defineProperty(propertyName, type, true, inExterns);\n+    boolean result = defineProperty(propertyName, type, true, inExterns);\n+\n+    // All property definitions go through this method\n+    // or defineDeclaredProperty. Because the properties defined an an\n+    // object can affect subtyping, it's slightly more efficient\n+    // to register this after defining the property.\n+    registry.registerPropertyOnType(propertyName, this);\n+\n+    return result;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n         String propName = entry.getKey();\n         JSType propType = entry.getValue();\n         UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n-        for (ObjectType alt : registry.getTypesWithProperty(propName)) {\n+        for (ObjectType alt :\n+                 registry.getEachReferenceTypeWithProperty(propName)) {\n           JSType altPropType = alt.getPropertyType(propName);\n           if (altPropType != null && !alt.isEquivalentTo(this) &&\n               alt.isSubtype(that) &&\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n   /**\n    * A {@link UnionType} contains a given type (alternate) iff the member\n-   * vector contains it.  Since the {@link #equals} method above conforms to\n-   * the necessary semantics for the collection, everything works out just\n-   * fine.\n+   * vector contains it.\n    *\n    * @param alternate The alternate which might be in this union.\n    *\n    * @return {@code true} if the alternate is in the union\n    */\n-  public boolean contains(JSType alternate) {\n-    return alternates.contains(alternate);\n+  public boolean contains(JSType type) {\n+    for (JSType alt : alternates) {\n+      if (alt.isEquivalentTo(type)) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n \n   UnionTypeBuilder(JSTypeRegistry registry) {\n     this.registry = registry;\n+  }\n+\n+  Iterable<JSType> getAlternates() {\n+    JSType specialCaseType = reduceAlternatesWithoutUnion();\n+    if (specialCaseType != null) {\n+      return ImmutableList.of(specialCaseType);\n+    }\n+    return alternates;\n   }\n \n   /**\n   }\n \n   /**\n+   * Reduce the alternates into a non-union type.\n+   * If the alternates can't be accurately represented with a non-union\n+   * type, return null.\n+   */\n+  private JSType reduceAlternatesWithoutUnion() {\n+    if (isAllType) {\n+      return registry.getNativeType(ALL_TYPE);\n+    } else if (isNativeUnknownType) {\n+      if (areAllUnknownsChecked) {\n+        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n+      } else {\n+        return registry.getNativeType(UNKNOWN_TYPE);\n+      }\n+    } else {\n+      int size = alternates.size();\n+      if (size > MAX_UNION_SIZE) {\n+        return registry.getNativeType(UNKNOWN_TYPE);\n+      } else if (size > 1) {\n+        return null;\n+      } else if (size == 1) {\n+        return alternates.iterator().next();\n+      } else {\n+        return registry.getNativeType(NO_TYPE);\n+      }\n+    }\n+  }\n+\n+  /**\n    * Creates a union.\n    * @return A UnionType if it has two or more alternates, the\n    *    only alternate if it has one and otherwise {@code NO_TYPE}.\n    */\n   JSType build() {\n     if (result == null) {\n-      if (isAllType) {\n-        result = registry.getNativeType(ALL_TYPE);\n-      } else if (isNativeUnknownType) {\n-        if (areAllUnknownsChecked) {\n-          result = registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n-        } else {\n-          result = registry.getNativeType(UNKNOWN_TYPE);\n-        }\n-      } else {\n-        int size = alternates.size();\n-        if (size > MAX_UNION_SIZE) {\n-          result = registry.getNativeType(UNKNOWN_TYPE);\n-        } else {\n-          if (size > 1) {\n-            result = new UnionType(registry, getAlternateListCopy());\n-          } else if (size == 1) {\n-            result = alternates.iterator().next();\n-          } else {\n-            result = registry.getNativeType(NO_TYPE);\n-          }\n-        }\n+      result = reduceAlternatesWithoutUnion();\n+      if (result == null) {\n+        result = new UnionType(registry, getAlternateListCopy());\n       }\n     }\n     return result;\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n     return resolvedType;\n   }\n \n+  public static void assertTypeNotEquals(JSType a, JSType b) {\n+    assertTypeNotEquals(\"\", a, b);\n+  }\n+\n+  public static void assertTypeNotEquals(String message, JSType a, JSType b) {\n+    Assert.assertFalse(\n+        message +\n+        (message.isEmpty() ? \"\" : \"\\n\") +\n+        \"Type: \" + b + \"\\n\",\n+        a.isEquivalentTo(b));\n+    Assert.assertFalse(\n+        message +\n+        \" Equals is not symmetric.\\n\" +\n+        \"Type: \" + b + \"\\n\",\n+        b.isEquivalentTo(a));\n+  }\n+\n   public static void assertTypeEquals(JSType a, JSType b) {\n     assertTypeEquals(\"\", a, b);\n   }\n         \"Expected: \" + a + \"\\n\" +\n         \"Actual  : \" + b,\n         a.isEquivalentTo(b));\n+    Assert.assertTrue(\n+        message +\n+        \" Equals is not symmetric.\\n\" +\n+        \"Expected: \" + b + \"\\n\" +\n+        \"Actual  : \" + a,\n+        b.isEquivalentTo(a));\n   }\n }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n     assertEquals(\n-        Sets.newHashSet(objectType),\n+        Lists.newArrayList(objectType),\n         registry.getTypesWithProperty(\"x\"));\n   }\n \n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n     assertEquals(\n-        Sets.newHashSet(OBJECT_TYPE),\n+        Lists.newArrayList(OBJECT_TYPE),\n         registry.getTypesWithProperty(\"x\"));\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n     assertEquals(\n-        Sets.newHashSet(objectType),\n+        Lists.newArrayList(objectType),\n         registry.getTypesWithProperty(\"x\"));\n   }\n \n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n     assertEquals(\n-        Sets.newHashSet(OBJECT_TYPE),\n+        Lists.newArrayList(OBJECT_TYPE),\n         registry.getTypesWithProperty(\"x\"));\n   }\n \n         \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n         \"SubFoo.prototype.bar = 0;\" +\n         \"/** @param {{bar: number}} x */ function f(x) { return x.baz; }\");\n+  }\n+\n+  public void testMissingProperty37() throws Exception {\n+    // This used to emit a missing property warning because we couldn't\n+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.\n+    testTypes(\n+        \"/** @param {{isVisible: boolean}} x */ function f(x){\" +\n+        \"  x.isVisible = false;\" +\n+        \"}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/**\\n\" +\n+        \" * @constructor \\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/** @type {boolean} */ SubFoo.prototype.isVisible = true;\" +\n+        \"/**\\n\" +\n+        \" * @param {Foo} x\\n\" +\n+        \" * @return {boolean}\\n\" +\n+        \" */\\n\" +\n+        \"function g(x) { return x.isVisible; }\");\n   }\n \n   public void testLends1() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n \n import com.google.common.base.Predicate;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n     assertFalse(foo.hasProperty(\"bar\"));\n     assertEquals(registry.getNativeType(UNKNOWN_TYPE),\n         foo.getPropertyType(\"bar\"));\n-    assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"bar\"));\n+    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"bar\"));\n   }\n \n   public void testConstructorProperty() {\n \n     JSType fooBar = foo.getPropertyType(\"Bar\");\n     assertEquals(\"function (this:foo.Bar): undefined\", fooBar.toString());\n-    assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"Bar\"));\n+    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n   public void testEnumProperty() {\n \n     JSType fooBar = foo.getPropertyType(\"Bar\");\n     assertEquals(\"enum{foo.Bar}\", fooBar.toString());\n-    assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"Bar\"));\n+    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n   public void testInferredProperty() {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n // TODO(nicksantos): Split some of this up into per-class unit tests.\n public class JSTypeTest extends BaseJSTypeTestCase {\n     assertTypeCanAssignToItself(namedGoogBar);\n     googBar.canAssignTo(namedGoogBar);\n     namedGoogBar.canAssignTo(googBar);\n-    assertTrue(googBar.isEquivalentTo(googBar));\n-    assertFalse(googBar.isEquivalentTo(googSubBar));\n+    assertTypeEquals(googBar, googBar);\n+    assertTypeNotEquals(googBar, googSubBar);\n \n     Asserts.assertResolvesToSame(googBar);\n     Asserts.assertResolvesToSame(googSubBar);\n   }\n \n   public void testWeirdBug() {\n-    assertFalse(googBar.isEquivalentTo(googBar.getInstanceType()));\n-    assertFalse(googBar.getInstanceType().isEquivalentTo(googBar));\n+    assertTypeNotEquals(googBar, googBar.getInstanceType());\n     assertFalse(googBar.isSubtype(googBar.getInstanceType()));\n     assertFalse(googBar.getInstanceType().isSubtype(googBar));\n   }\n     NamedType a = new NamedType(jst, \"type1\", \"source\", 1, 0);\n     NamedType b = new NamedType(jst, \"type1\", \"source\", 1, 0);\n     assertTrue(a.isEquivalentTo(b));\n-\n-    // test != to non-NamedType\n-    assertFalse(a.equals(\"type1\"));\n \n     // test == instance of referenced type\n     assertTrue(namedGoogBar.isEquivalentTo(googBar.getInstanceType()));\n \n   public void testRegisterProperty() {\n     int i = 0;\n-    Set<JSType> allObjects = Sets.newHashSet();\n+    List<JSType> allObjects = Lists.newArrayList();\n     for (JSType type : types) {\n       String propName = \"ALF\" + i++;\n       if (type instanceof ObjectType) {\n+\n         ObjectType objType = (ObjectType) type;\n         objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false);\n         objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false);\n+\n         assertTypeEquals(type,\n             registry.getGreatestSubtypeWithProperty(type, propName));\n-        assertEquals(Sets.newHashSet(type),\n-            registry.getTypesWithProperty(propName));\n+\n+        List<JSType> typesWithProp =\n+            Lists.newArrayList(registry.getTypesWithProperty(propName));\n+        String message = type.toString();\n+        assertEquals(message, 1, typesWithProp.size());\n+        assertTypeEquals(type, typesWithProp.get(0));\n+\n         assertTypeEquals(NO_TYPE,\n             registry.getGreatestSubtypeWithProperty(type, \"GRRR\"));\n         allObjects.add(type);\n       }\n     }\n-    assertEquals(registry.getTypesWithProperty(\"GRRR\"),\n-        Sets.newHashSet(NO_TYPE));\n-    assertEquals(allObjects, registry.getTypesWithProperty(\"allHaz\"));\n+    assertTypeListEquals(registry.getTypesWithProperty(\"GRRR\"),\n+        Lists.newArrayList(NO_TYPE));\n+    assertTypeListEquals(allObjects,\n+        registry.getTypesWithProperty(\"allHaz\"));\n   }\n \n   public void testRegisterPropertyMemoization() {\n   }\n \n   public void testObjectGetSubTypes() throws Exception {\n-    assertTrue(OBJECT_FUNCTION_TYPE.getSubTypes().contains(googBar));\n-    assertTrue(googBar.getSubTypes().contains(googSubBar));\n-    assertFalse(googBar.getSubTypes().contains(googSubSubBar));\n-    assertFalse(googSubBar.getSubTypes().contains(googSubBar));\n-    assertTrue(googSubBar.getSubTypes().contains(googSubSubBar));\n+    assertTrue(\n+        containsType(\n+            OBJECT_FUNCTION_TYPE.getSubTypes(), googBar));\n+    assertTrue(\n+        containsType(\n+            googBar.getSubTypes(), googSubBar));\n+    assertFalse(\n+        containsType(\n+            googBar.getSubTypes(), googSubSubBar));\n+    assertFalse(\n+        containsType(\n+            googSubBar.getSubTypes(), googSubBar));\n+    assertTrue(\n+        containsType(\n+            googSubBar.getSubTypes(), googSubSubBar));\n   }\n \n   public void testImplementingType() throws Exception {\n-    assertTrue(registry.getDirectImplementors(\n-        interfaceType.getInstanceType()).contains(googBar));\n+    assertTrue(\n+        containsType(\n+            registry.getDirectImplementors(\n+                interfaceType.getInstanceType()),\n+            googBar));\n+  }\n+\n+  private static boolean containsType(\n+      Iterable<? extends JSType> types, JSType type) {\n+    for (JSType alt : types) {\n+      if (alt.isEquivalentTo(type)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean assertTypeListEquals(\n+      Iterable<? extends JSType> typeListA,\n+      Iterable<? extends JSType> typeListB) {\n+    for (JSType alt : typeListA) {\n+      assertTrue(\n+          \"List : \" + typeListA + \"\\n\" +\n+          \"does not contain: \" + alt,\n+          containsType(typeListA, alt));\n+    }\n+    for (JSType alt : typeListB) {\n+      assertTrue(\n+          \"List : \" + typeListB + \"\\n\" +\n+          \"does not contain: \" + alt,\n+          containsType(typeListB, alt));\n+    }\n+    return false;\n   }\n \n   private ArrowType createArrowType(Node params) {\n   private void assertTypeEquals(String msg, JSType a, JSType b) {\n     Asserts.assertTypeEquals(msg, a, b);\n   }\n+\n+  private void assertTypeNotEquals(JSType a, JSType b) {\n+    Asserts.assertTypeNotEquals(a, b);\n+  }\n+\n+  private void assertTypeNotEquals(String msg, JSType a, JSType b) {\n+    Asserts.assertTypeNotEquals(msg, a, b);\n+  }\n }", "timestamp": 1292256629, "metainfo": ""}