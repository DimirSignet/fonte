{"sha": "1a7fbd18b47c102152869c3b046b65ff0f12fc43", "log": "Allow more folding of Token.ADD.  R=acleung DELTA=160  (107 added, 4 deleted, 49 changed)  Hi Jason!  Revision created by MOE tool push_codebase. MOE_MIGRATION=453   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Apply the supplied predicate against the potential\n+   * all possible result of the expression.\n+   */\n+  static boolean valueCheck(Node n, Predicate<Node> p) {\n+    switch (n.getType()) {\n+      case Token.ASSIGN:\n+      case Token.COMMA:\n+        return valueCheck(n.getLastChild(), p);\n+      case Token.AND:\n+      case Token.OR:\n+        return valueCheck(n.getFirstChild(), p)\n+            && valueCheck(n.getLastChild(), p);\n+      case Token.HOOK:\n+        return valueCheck(n.getFirstChild().getNext(), p)\n+            && valueCheck(n.getLastChild(), p);\n+      default:\n+        return p.apply(n);\n+    }\n+  }\n+\n+  static class NumbericResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return isNumericResultHelper(n);\n+    }\n+  }\n+\n+  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =\n+      new NumbericResultPredicate();\n+\n+  /**\n    * Returns true if the result of node evaluation is always a number\n    */\n   static boolean isNumericResult(Node n) {\n+    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);\n+  }\n+\n+  static boolean isNumericResultHelper(Node n) {\n     switch (n.getType()) {\n-      // NOTE: ADD is deliberately excluded as it may produce\n-      // a string.\n+      case Token.ADD:\n+        return !mayBeString(n.getFirstChild())\n+            && !mayBeString(n.getLastChild());\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n     }\n   }\n \n+  static class BooleanResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return isBooleanResultHelper(n);\n+    }\n+  }\n+\n+  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =\n+      new BooleanResultPredicate();\n+\n   /**\n    * @return Whether the result of node evaluation is always a boolean\n    */\n   static boolean isBooleanResult(Node n) {\n+    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n+  }\n+\n+  static boolean isBooleanResultHelper(Node n) {\n     // TODO(johnlenz): Add a recursive option to recurse into\n     // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n     switch (n.getType()) {\n     return n.getType() == Token.NULL;\n   }\n \n+  static class MayBeStringResultPredicate implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return mayBeStringHelper(n);\n+    }\n+  }\n+\n+  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n+      new MayBeStringResultPredicate();\n+\n   /**\n    * @returns Whether the results is possibly a string.\n    */\n   static boolean mayBeString(Node n) {\n+    return mayBeString(n, true);\n+  }\n+\n+  static boolean mayBeString(Node n, boolean recurse) {\n+    if (recurse) {\n+      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n+    } else {\n+      return mayBeStringHelper(n);\n+    }\n+  }\n+\n+  static boolean mayBeStringHelper(Node n) {\n     return !isNumericResult(n) && !isBooleanResult(n)\n         && !isUndefined(n) && !isNull(n);\n   }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n    *  - The right child is a constant value\n    *  - The left child's right child is a STRING constant.\n    */\n-  private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n+  private Node tryFoldChildAddString(Node n, Node left, Node right) {\n \n     if (NodeUtil.isLiteralValue(right, false) &&\n-        left.getType() == Token.ADD &&\n-        left.getChildCount() == 2) {\n+        left.getType() == Token.ADD) {\n \n       Node ll = left.getFirstChild();\n       Node lr = ll.getNext();\n       // Left's right child MUST be a string. We would not want to fold\n       // foo() + 2 + 'a' because we don't know what foo() will return, and\n       // therefore we don't know if left is a string concat, or a numeric add.\n-      if (lr.getType() != Token.STRING) {\n-        return n;\n-      }\n-\n-      String leftString = NodeUtil.getStringValue(lr);\n-      String rightString = NodeUtil.getStringValue(right);\n-      if (leftString != null && rightString != null) {\n-        left.removeChild(ll);\n-        String result = leftString + rightString;\n-        n.replaceChild(left, ll);\n-        n.replaceChild(right, Node.newString(result));\n-        reportCodeChange();\n+      if (lr.getType() == Token.STRING) {\n+        String leftString = NodeUtil.getStringValue(lr);\n+        String rightString = NodeUtil.getStringValue(right);\n+        if (leftString != null && rightString != null) {\n+          left.removeChild(ll);\n+          String result = leftString + rightString;\n+          n.replaceChild(left, ll);\n+          n.replaceChild(right, Node.newString(result));\n+          reportCodeChange();\n+          return n;\n+        }\n+      }\n+    }\n+\n+    if (NodeUtil.isLiteralValue(left, false) &&\n+        right.getType() == Token.ADD) {\n+\n+      Node rl = right.getFirstChild();\n+      Node rr = right.getLastChild();\n+\n+      // Left's right child MUST be a string. We would not want to fold\n+      // foo() + 2 + 'a' because we don't know what foo() will return, and\n+      // therefore we don't know if left is a string concat, or a numeric add.\n+      if (rl.getType() == Token.STRING) {\n+        String leftString = NodeUtil.getStringValue(left);\n+        String rightString = NodeUtil.getStringValue(rl);\n+        if (leftString != null && rightString != null) {\n+          right.removeChild(rr);\n+          String result = leftString + rightString;\n+          n.replaceChild(right, rr);\n+          n.replaceChild(left, Node.newString(result));\n+          reportCodeChange();\n+          return n;\n+        }\n       }\n     }\n \n   /**\n    * Try to fold an ADD node with constant operands\n    */\n-  private Node tryFoldAddConstant(Node n, Node left, Node right) {\n+  private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n     if (left.getType() == Token.STRING ||\n         right.getType() == Token.STRING) {\n-\n       // Add strings.\n       String leftString = NodeUtil.getStringValue(left);\n       String rightString = NodeUtil.getStringValue(right);\n         reportCodeChange();\n         return newStringNode;\n       }\n-    } else {\n-      // Try arithmetic add\n-      return tryFoldArithmeticOp(n, left, right);\n-    }\n+    }\n+\n+\n \n     return n;\n   }\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD\n-        && (left.getType() != Token.NUMBER\n-            || right.getType() != Token.NUMBER)) {\n+        && (NodeUtil.mayBeString(left, false)\n+            || NodeUtil.mayBeString(right, false))) {\n       return null;\n     }\n \n    */\n   private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n     int opType = n.getType();\n-    // TODO(johnlenz): Add support for ADD in numberic contexts.\n     Preconditions.checkState(\n-      NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType));\n+        (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n+        || n.getType() == Token.ADD);\n+\n+    Preconditions.checkState(\n+        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n \n     // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n     // other values are converted to numbers elsewhere.\n   private Node tryFoldAdd(Node node, Node left, Node right) {\n     Preconditions.checkArgument(node.getType() == Token.ADD);\n \n-    if (NodeUtil.isLiteralValue(left, false) &&\n-        NodeUtil.isLiteralValue(right, false)) {\n-      // 6 + 7\n-      return tryFoldAddConstant(node, left, right);\n+    if (NodeUtil.mayBeString(node, true)) {\n+      if (NodeUtil.isLiteralValue(left, false) &&\n+          NodeUtil.isLiteralValue(right, false)) {\n+        // '6' + 7\n+        return tryFoldAddConstantString(node, left, right);\n+      } else {\n+        // a + 7 or 6 + a\n+        return tryFoldChildAddString(node, left, right);\n+      }\n     } else {\n-      // a + 7 or 6 + a\n-      return tryFoldLeftChildAdd(node, left, right);\n+      // Try arithmetic add\n+      Node result = tryFoldArithmeticOp(node, left, right);\n+      if (result != node) {\n+        return result;\n+      }\n+      return tryFoldLeftChildOp(node, left, right);\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertFalse(NodeUtil.isNumericResult(getNode(\"([1,2])\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"({a:1})\")));\n \n-    // These are number but aren't handled yet, \"false\" here means \"unknown\".\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"1 && 2\")));\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"1 || 2\")));\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"a ? 2 : 3\")));\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"a,1\")));\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"a=1\")));\n+    // Recurse into the expression when necessary.\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"1 && 2\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"1 || 2\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a ? 2 : 3\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a,1\")));\n+    assertTrue(NodeUtil.isNumericResult(getNode(\"a=1\")));\n   }\n \n   public void testIsBooleanResult() {\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));\n \n     // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n-    assertFalse(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n-    assertFalse(NodeUtil.isBooleanResult(getNode(\"true || false\")));\n-    assertFalse(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n-    assertFalse(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n+    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));\n   }\n \n     assertTrue(NodeUtil.mayBeString(getNode(\"new a()\")));\n \n     // These can't be strings but they aren't handled yet.\n-    assertTrue(NodeUtil.mayBeString(getNode(\"1 && 2\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"1 || 2\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"1 ? 2 : 3\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"1,2\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"a=1\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"1+1\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"true+true\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"null+null\")));\n-    assertTrue(NodeUtil.mayBeString(getNode(\"NaN+NaN\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1 && 2\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1 || 2\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1 ? 2 : 3\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1,2\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"a=1\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"1+1\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"true+true\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"null+null\")));\n+    assertFalse(NodeUtil.mayBeString(getNode(\"NaN+NaN\")));\n \n     // These are not strings but they aren't primitives either\n     assertTrue(NodeUtil.mayBeString(getNode(\"([1,2])\")));\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   public void testFoldLeft() {\n     foldSame(\"(+x - 1) + 2\"); // not yet\n-    foldSame(\"(+x + 1) + 2\"); // not yet\n+    fold(\"(+x + 1) + 2\", \"+x + 3\");\n   }\n \n   public void testFoldArrayLength() {\n   public void testFoldLeftChildConcat() {\n     foldSame(\"x +5 + \\\"1\\\"\");\n     fold(\"x+\\\"5\\\" + \\\"1\\\"\", \"x + \\\"51\\\"\");\n+    // fold(\"\\\"a\\\"+(c+\\\"b\\\")\",\"\\\"a\\\"+c+\\\"b\\\"\");\n+    fold(\"\\\"a\\\"+(\\\"b\\\"+c)\",\"\\\"ab\\\"+c\");\n   }\n \n   public void testFoldLeftChildOp() {", "timestamp": 1297119556, "metainfo": ""}