{"sha": "2e68acb05c7a37396c9efc449e14226b6d3fb7eb", "log": "Changes needed to support getters and setters in simple mode.  R=nicksantos DELTA=166  (146 added, 2 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=110   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n          keyNode = keyNode.getNext()) {\n       Node valueNode = keyNode.getFirstChild();\n \n-      // Object literal keys may be strings or numbers.  Numbers are\n-      // skipped because name tokens may not start with a number.\n+      // Object literal keys may be STRING, GET, SET or NUMBER.  Numbers are\n+      // skipped because name tokens may not start with a number. Get and Set\n+      // are skipped because they can not be named.\n       if (keyNode.getType() == Token.STRING) {\n         // concatenate the context and key name to get a new qualified name.\n         String name = namer.getCombinedName(context, namer.getName(keyNode));\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n       // exists in the AST.  We will have to change the return type of\n       // getLValue sooner or later in order to provide this added\n       // flexibility.\n-      return new Node(Token.GETPROP,\n-                      new Node(Token.OBJECTLIT),\n-                      name.cloneNode());\n+\n+      switch (name.getType()) {\n+        case Token.STRING:\n+          return new Node(Token.GETPROP,\n+            new Node(Token.OBJECTLIT),\n+            name.cloneNode());\n+        case Token.NUMBER:\n+          return new Node(Token.GETELEM,\n+            new Node(Token.OBJECTLIT),\n+            name.cloneNode());\n+        case Token.SET:\n+        case Token.GET:\n+          // TODO(johnlenz): revisit. Not sure what to do here.\n+          throw new IllegalStateException(\"not yet implemented\");\n+        default:\n+          throw new IllegalStateException(\"unexpected\");\n+      }\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n       return;\n     }\n \n-    // Never try to decompose anobject literal key.\n+    // Never try to decompose an object literal key.\n     Preconditions.checkState(!NodeUtil.isObjectLitKey(n, n.getParent()));\n \n     // Decompose the children in reverse evaluation order.  This simplifies\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @param parent The node's parent\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n-    // TODO(nicksantos): What about NUMBER?\n-    return node.getType() == Token.STRING &&\n-        parent.getType() == Token.OBJECTLIT;\n+    switch (node.getType()) {\n+      case Token.NUMBER:\n+      case Token.STRING:\n+        return parent.getType() == Token.OBJECTLIT;\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n+    return false;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n \n         case Token.NAME:\n         case Token.STRING:\n+        case Token.GET:\n+        case Token.SET:\n           annotateConstantsByConvention(n, parent);\n           break;\n       }\n      */\n     private void annotateConstantsByConvention(Node n, Node parent) {\n       Preconditions.checkState(\n-          n.getType() == Token.NAME || n.getType() == Token.STRING);\n+          n.getType() == Token.NAME \n+          || n.getType() == Token.STRING\n+          || n.getType() == Token.GET\n+          || n.getType() == Token.SET);\n \n       // There are only two cases where a string token\n       // may be a variable reference: The right side of a GETPROP\n--- a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n+++ b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n              key = key.getNext()) {\n            // We only want keys that are strings (not numbers), and only keys\n            // that were unquoted.\n-           if (key.getType() == Token.STRING) {\n+           if (key.getType() != Token.NUMBER) {\n              if (!key.isQuotedString()) {\n                key.putProp(Node.ORIGINALNAME_PROP, key.getString());\n              }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n \n import com.google.common.base.Predicate;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n import java.io.IOException;\n \n             || NodeUtil.isFunction(node)\n             || NodeUtil.isName(node)\n             || NodeUtil.isGet(node)\n-            || (NodeUtil.isString(node) &&\n-                (node.getParent().getType() == Token.OBJECTLIT ||\n-                 NodeUtil.isGet(node.getParent())));\n+            || NodeUtil.isObjectLitKey(node, node.getParent())\n+            || (NodeUtil.isString(node) && NodeUtil.isGet(node.getParent()));\n       }\n     };\n   }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n   private Compiler lastCompiler;\n \n   /**\n+   * Whether to acceptES5 source.\n+   */\n+  private boolean acceptES5 = true;\n+\n+  /**\n    * Constructs a test.\n    *\n    * @param externs Externs JS as a string\n   protected CompilerOptions getOptions() {\n     CompilerOptions options = new CompilerOptions();\n \n+    if (this.acceptES5) {\n+      options.languageIn = LanguageMode.ECMASCRIPT5;\n+    }\n+\n     // This doesn't affect whether checkSymbols is run--it just affects\n     // whether variable warnings are filtered.\n     options.checkSymbols = true;\n   /** The most recently used JSComp instance. */\n   Compiler getLastCompiler() {\n     return lastCompiler;\n+  }\n+\n+  /**\n+   * Whether to allow ECMASCRIPT5 source parsing.\n+   */\n+  protected void enableEcmaScript5(boolean acceptES5) {\n+    this.acceptES5 = acceptES5;\n   }\n \n   /**\n     lastCompiler = compiler;\n \n     CompilerOptions options = getOptions();\n+\n+    if (this.acceptES5) {\n+      options.languageIn = LanguageMode.ECMASCRIPT5;\n+    }\n     // Note that in this context, turning on the checkTypes option won't\n     // actually cause the type check to run.\n     options.checkTypes = parseTypeInfo;\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n         \"var temp_const$$1 = temp_const$$0.b;\" +\n         \"y = (temp_const$$0.b = temp_const$$1 + foo()) + goo().a\");\n   }\n+  \n+  public void testExposeObjectLit1() {\n+    // Validate that getter and setters methods are see as side-effect\n+    // free and that values can move past them.  We don't need to be \n+    // concerned with exposing the getter or setter here but the\n+    // decomposer does not have a method of exposing properties only variables.\n+    helperMoveExpression(\n+        \"var x = {get a() {}, b: foo()};\",\n+        \"foo\",\n+        \"var temp$$0=foo();var x = {get a() {}, b: temp$$0};\");\n+\n+    helperMoveExpression(\n+        \"var x = {set a(p) {}, b: foo()};\",\n+        \"foo\",\n+        \"var temp$$0=foo();var x = {set a(p) {}, b: temp$$0};\");\n+  }\n \n   /** Test case helpers. */\n \n \n   private void helperCanExposeFunctionExpression(\n       DecompositionType expectedResult, String code, int call) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = getCompiler();\n     Set<String> knownConstants = Sets.newHashSet();\n     ExpressionDecomposer decomposer = new ExpressionDecomposer(\n         compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n       String fnName,\n       Set<String> knownConstants\n       ) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = getCompiler();\n     if (knownConstants == null) {\n       knownConstants = Sets.newHashSet();\n     }\n       String expectedResult,\n       Set<String> knownConstants\n       ) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = getCompiler();\n     if (knownConstants == null) {\n       knownConstants = Sets.newHashSet();\n     }\n       String expectedResult,\n       Set<String> knownConstants\n       ) {\n-    Compiler compiler = new Compiler();\n+    Compiler compiler = getCompiler();\n     if (knownConstants == null) {\n       knownConstants = Sets.newHashSet();\n     }\n         \"\\n\" + explanation, explanation);\n   }\n \n+  private static Compiler getCompiler() {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.languageIn = LanguageMode.ECMASCRIPT5;\n+    compiler.initOptions(options);\n+    return compiler;\n+  }\n+  \n   private static Node findCall(Node n, String name) {\n     return findCall(n, name, 1);\n   }\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n     assertEquals(\"NaN\", NodeUtil.getStringValue(getNode(\"NaN\")));\n     assertEquals(\"Infinity\", NodeUtil.getStringValue(getNode(\"Infinity\")));\n     assertEquals(null, NodeUtil.getStringValue(getNode(\"x\")));\n+  }\n+\n+  public void testIsObjectLiteralKey1() throws Exception {\n+    testIsObjectLiteralKey(\n+      parseExpr(\"({})\"), false);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"a\"), false);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"'a'\"), false);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"1\"), false);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"({a: 1})\").getFirstChild(), true);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"({1: 1})\").getFirstChild(), true);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"({get a(){}})\").getFirstChild(), true);\n+    testIsObjectLiteralKey(\n+      parseExpr(\"({set a(b){}})\").getFirstChild(), true);\n+  }\n+\n+  private Node parseExpr(String js) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.languageIn = LanguageMode.ECMASCRIPT5;\n+    compiler.initOptions(options);\n+    Node root = compiler.parseTestCode(js);\n+    return root.getFirstChild().getFirstChild();\n+  }\n+\n+  private void testIsObjectLiteralKey(Node node, boolean expected) {\n+    assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent()));\n   }\n \n   public void testGetFunctionName1() throws Exception {\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n     }\n   }\n \n-  public void testPropertyIsConstant() throws Exception {\n+  public void testPropertyIsConstant1() throws Exception {\n     testSame(\"var a = {};a.CONST = 3; var b = a.CONST;\");\n+    Node n = getLastCompiler().getRoot();\n+\n+    Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n+    assertEquals(2, constantNodes.size());\n+    for (Node hasProp : constantNodes) {\n+      assertEquals(\"CONST\", hasProp.getString());\n+    }\n+  }\n+\n+  public void testPropertyIsConstant2() throws Exception {\n+    testSame(\"var a = {CONST: 3}; var b = a.CONST;\");\n+    Node n = getLastCompiler().getRoot();\n+\n+    Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n+    assertEquals(2, constantNodes.size());\n+    for (Node hasProp : constantNodes) {\n+      assertEquals(\"CONST\", hasProp.getString());\n+    }\n+  }\n+\n+  public void testGetterPropertyIsConstant() throws Exception {\n+    testSame(\"var a = { get CONST() {return 3} }; \" +\n+    \t\t \"var b = a.CONST;\");\n+    Node n = getLastCompiler().getRoot();\n+\n+    Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n+    assertEquals(2, constantNodes.size());\n+    for (Node hasProp : constantNodes) {\n+      assertEquals(\"CONST\", hasProp.getString());\n+    }\n+  }\n+\n+  public void testSetterPropertyIsConstant() throws Exception {\n+    // Verifying that a SET is properly annotated.\n+    testSame(\"var a = { set CONST(b) {throw 'invalid'} }; \" +\n+             \"var c = a.CONST;\");\n     Node n = getLastCompiler().getRoot();\n \n     Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n                         \"USE GETPROP o.a -> [NUMBER]\"));\n \n     checkDefinitionsInJs(\n+      \"({1 : 1}); o[1]\",\n+      ImmutableSet.<String>of());\n+\n+\n+    checkDefinitionsInJs(\n         \"var a = {b : 1}; a.b\",\n         ImmutableSet.of(\"DEF NAME a -> <null>\",\n                         \"DEF STRING null -> NUMBER\",", "timestamp": 1292001278, "metainfo": ""}