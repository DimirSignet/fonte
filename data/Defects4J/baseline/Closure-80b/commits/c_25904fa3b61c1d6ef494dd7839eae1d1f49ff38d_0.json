{"sha": "25904fa3b61c1d6ef494dd7839eae1d1f49ff38d", "log": "Some eclipse warnings clean up.  R=nicksantos DELTA=65  (4 added, 35 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1190007   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n    *\n    * var GLOBAL_window = window;\n    *\n-   * @param globalName Name of global\n+   * @param global Name of global\n    * @param root Root of output tree that function can be added to\n    */\n   private void addGlobalAliasNode(Symbol global, Node root) {\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n  * <li>Flow Direction: Implement {@link #isForward()}.\n  * <li>Lattice Elements: Implement {@link LatticeElement}.\n  * <li>JOIN Operation: Implement\n- *    {@link JoinOp#join(LatticeElement, LatticeElement)}.\n+ *    {@link JoinOp#apply}.\n  * <li>Flow Equations: Implement\n  * {@link #flowThrough(Object, LatticeElement)}.\n  * <li>Initial Entry Value: Implement {@link #createEntryLattice()}.\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       }\n       return false;\n     }\n-  };\n+  }\n \n   private class ImplementedTypeValidator implements Predicate<JSType> {\n     @Override\n       }\n       return false;\n     }\n-  };\n+  }\n \n   private class ThisTypeValidator implements Predicate<JSType> {\n     @Override\n       }\n       return true;\n     }\n-  };\n+  }\n \n   /**\n    * @param fnName The function name.\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     resolveInlineConflicts();\n     decomposeExpressions(fnNames);\n     NodeTraversal.traverse(compiler, root,\n-        new CallVisitor(fns, anonFns, new Inline(injector)));\n+        new CallVisitor(\n+            fns, anonFns, new Inline(injector, specializationState)));\n \n     removeInlinedFunctions();\n   }\n    * Returns the function the traversal is currently traversing, or null\n    * if in the global scope.\n    */\n-  private Node getContainingFunction(NodeTraversal t) {\n+  private static Node getContainingFunction(NodeTraversal t) {\n     return (t.inGlobalScope()) ? null : t.getScopeRoot();\n   }\n \n   /**\n    * Inline functions at the call sites.\n    */\n-  private class Inline implements CallVisitorCallback {\n+  private static class Inline implements CallVisitorCallback {\n     private final FunctionInjector injector;\n-\n-    Inline(FunctionInjector injector) {\n+    private final SpecializeModule.SpecializationState specializationState;\n+\n+    Inline(FunctionInjector injector,\n+        SpecializeModule.SpecializationState specializationState) {\n       this.injector = injector;\n+      this.specializationState = specializationState;\n     }\n \n     public void visitCallSite(\n--- a/src/com/google/javascript/jscomp/JsMessage.java\n+++ b/src/com/google/javascript/jscomp/JsMessage.java\n         return hash64(null, 0, 0, seed);\n       }\n       return hash64(value.getBytes(), seed);\n-    }\n-\n-    /**\n-     * Hash byte array to a 64 bit value. The digits of pi are used\n-     * for the hash seed.\n-     *\n-     * @param value the bytes to hash\n-     * @param offset the starting position of value where bytes are\n-     * used for the hash computation\n-     * @param length number of bytes of value that are used for the\n-     * hash computation\n-     * @return 64 bit hash value\n-     */\n-    private static long hash64(byte[] value, int offset, int length) {\n-      return hash64(value, offset, length, SEED64);\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   /**\n    * Gets the function's name. This method recognizes the forms:\n    * <ul>\n-   * <li>{@code {'name': function() ...}}</li>\n-   * <li>{@code {name: function() ...}}</li>\n+   * <li>{@code &#123;'name': function() ...&#125;}</li>\n+   * <li>{@code &#123;name: function() ...&#125;}</li>\n    * <li>{@code function name() ...}</li>\n    * <li>{@code var name = function() ...}</li>\n    * <li>{@code qualified.name = function() ...}</li>\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n     }\n \n     /**\n-     * Function appeared in externs file.\n-     */\n-    boolean isExtern() {\n-      return extern;\n-    }\n-\n-    /**\n      * @returns false if function known to have side effects.\n      */\n     boolean mayBePure() {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n import java.util.*;\n import java.util.Map;\n-import java.util.logging.Logger;\n \n /**\n  * Garbage collection for variable and function definitions. Basically performs\n  *\n  */\n class RemoveUnusedVars implements CompilerPass {\n-  private static final Logger logger =\n-    Logger.getLogger(RemoveUnusedVars.class.getName());\n \n   private final AbstractCompiler compiler;\n \n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n         case Token.GETPROP:\n           Node propNode = n.getFirstChild().getNext();\n           if (propNode.getType() == Token.STRING) {\n-            maybeMarkCandidate(propNode, t);\n+            maybeMarkCandidate(propNode);\n           }\n           break;\n         case Token.OBJECTLIT:\n             // that were unquoted.\n             if (key.getType() == Token.STRING) {\n               if (!key.isQuotedString()) {\n-                maybeMarkCandidate(key, t);\n+                maybeMarkCandidate(key);\n               } else {\n                 // Ensure that we never rename some other property in a way\n                 // that could conflict with this quoted key.\n      * and increments the property name's access count.\n      *\n      * @param n The STRING node for a property\n-     * @param t The traversal\n      */\n-    private void maybeMarkCandidate(Node n, NodeTraversal t) {\n+    private void maybeMarkCandidate(Node n) {\n       String name = n.getString();\n       if (!externedNames.contains(name)) {\n         stringNodesToRename.add(n);\n-        countPropertyOccurrence(name, t);\n+        countPropertyOccurrence(name);\n       }\n     }\n \n           continue;\n         }\n         if (!externedNames.contains(name)) {\n-          countPropertyOccurrence(name, t);\n+          countPropertyOccurrence(name);\n         }\n       }\n     }\n      * Increments the occurrence count for a property name.\n      *\n      * @param name The property name\n-     * @param t The node traversal\n      */\n-    private void countPropertyOccurrence(String name, NodeTraversal t) {\n+    private void countPropertyOccurrence(String name) {\n       Property prop = propertyMap.get(name);\n       if (prop == null) {\n-        prop = new Property(name, t.getInput());\n+        prop = new Property(name);\n         propertyMap.put(name, prop);\n       }\n       prop.numOccurrences++;\n    */\n   private class Property {\n     final String oldName;\n-    final CompilerInput input;\n     String newName;\n     int numOccurrences;\n \n-    Property(String name, CompilerInput input) {\n+    Property(String name) {\n       this.oldName = name;\n-      this.input = input;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n     int prototypeCount;\n     int objLitCount;\n     int refCount;\n-    CompilerInput input;\n \n     Property(String name) {\n       this.oldName = name;\n       this.prototypeCount = 0;\n       this.objLitCount = 0;\n       this.refCount = 0;\n-      this.input = null;\n     }\n \n     int count() {\n      */\n     private void markPrototypePropertyCandidate(Node n, CompilerInput input) {\n       stringNodes.add(n);\n-      getProperty(n.getString(), input).prototypeCount++;\n+      getProperty(n.getString()).prototypeCount++;\n     }\n \n     /**\n      */\n     private void markObjLitPropertyCandidate(Node n, CompilerInput input) {\n       stringNodes.add(n);\n-      getProperty(n.getString(), input).objLitCount++;\n+      getProperty(n.getString()).objLitCount++;\n     }\n \n     /**\n      */\n     private void markPropertyAccessCandidate(Node n, CompilerInput input) {\n       stringNodes.add(n);\n-      getProperty(n.getString(), input).refCount++;\n+      getProperty(n.getString()).refCount++;\n     }\n \n     /**\n      * Gets the current property for the given name, creating a new one if\n      * none exists.\n      */\n-    private Property getProperty(String name, CompilerInput input) {\n+    private Property getProperty(String name) {\n       Property prop = properties.get(name);\n       if (prop == null) {\n         prop = new Property(name);\n         properties.put(name, prop);\n-\n-        // Kind of arbitrary--if a property appears in multiple inputs, we\n-        // consider it belonging to the first one we saw it in.\n-        prop.input = input;\n       }\n       return prop;\n     }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n   /**\n    * Given a node, determines whether that node names a prototype\n-   * property, and if so, returns the qualfied name node representing\n+   * property, and if so, returns the qualified name node representing\n    * the owner of that property. Otherwise, returns null.\n    */\n   private static Node getPrototypePropertyOwner(Node n) {", "timestamp": 1289597904, "metainfo": ""}