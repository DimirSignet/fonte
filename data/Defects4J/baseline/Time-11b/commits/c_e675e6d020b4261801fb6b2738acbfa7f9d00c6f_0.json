{"sha": "e675e6d020b4261801fb6b2738acbfa7f9d00c6f", "log": "Refactor year classes into BaseGJChronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n         31,29,31,30,31,30,31,31,30,31,30,31\n     };\n \n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n     private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n     private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n \n         // Now create fields that have unique behavior for Gregorian and Julian\n         // chronologies.\n \n-        fields.year = new GJYearDateTimeField(this);\n+        fields.year = new BasicYearDateTimeField(this);\n         fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n \n         // Define one-based centuryOfEra and yearOfCentury.\n     }\n \n     /**\n-     * @param instant millis from 1970-01-01T00:00:00Z\n-     */\n-    final long setYear(long instant, int year) {\n+     * Sets the year.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param year  the year to set\n+     */\n+    long setYear(long instant, int year) {\n         int thisYear = getYear(instant);\n         int dayOfYear = getDayOfYear(instant, thisYear);\n         int millisOfDay = getMillisOfDay(instant);\n         return instant;\n     }\n \n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (isLeapYear(subtrahendYear)) {\n+                if (!isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n     abstract boolean isLeapYear(int year);\n \n     abstract long calculateFirstDayOfYearMillis(int year);\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * A year field suitable for many calendars.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class BasicYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -98628754872287L;\n+\n+    /** The underlying basic chronology. */\n+    protected final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param chronology  the chronology this field belogs to\n+     */\n+    BasicYearDateTimeField(BaseGJChronology chronology) {\n+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n+        int newYear = FieldUtils.safeAdd(thisYear, years);\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return iChronology.setYear(instant, year);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);\n+        }\n+        return iChronology.getYearDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n         return getInstance(zone);\n     }\n \n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to 30 day months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to 30 day months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n     long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n         throws IllegalArgumentException\n     {\n         if (getBase() == null) {\n             super.assemble(fields);\n \n-            fields.year = new CopticYearDateTimeField(this);\n+            fields.year = new BasicYearDateTimeField(this);\n             fields.years = fields.year.getDurationField();\n \n             // Coptic, like Julian, has no year zero.", "timestamp": 1108767745, "metainfo": ""}