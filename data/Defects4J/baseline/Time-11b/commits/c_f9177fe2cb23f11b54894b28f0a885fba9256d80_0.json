{"sha": "f9177fe2cb23f11b54894b28f0a885fba9256d80", "log": "Hibernate support moved to independent subproject of contrib   ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+/**\n+ * Persist {@link org.joda.time.DateTime} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentDateTime implements EnhancedUserType\n+{\n+\tpublic final static PersistentDateTime INSTANCE = new PersistentDateTime();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIMESTAMP,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return DateTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        DateTime dtx = (DateTime) x;\n+        DateTime dty = (DateTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);\n+\t\tif (timestamp == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new DateTime(timestamp);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tHibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((DateTime) value).toDate(), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new DateTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new DateTime(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.UserType;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+/**\n+ * Persist {@link org.joda.time.DateTime} via hibernate.<br />\n+ * The timezone will be stored in an extra column\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentDateTimeTZ implements UserType\n+{\n+\tpublic final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIMESTAMP,\n+        Types.VARCHAR,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return DateTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        DateTime dtx = (DateTime) x;\n+        DateTime dty = (DateTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, strings[0]);\n+        Object timezone = Hibernate.STRING.nullSafeGet(resultSet, strings[1]);\n+        if (timestamp == null || timezone == null)\n+        {\n+            return null;\n+        }\n+\n+        return new DateTime(timestamp, DateTimeZone.forID(timezone.toString()));\n+    }\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+            Hibernate.STRING.nullSafeSet(preparedStatement, null, index+1);\n+        }\n+        else\n+        {\n+            DateTime dt = (DateTime) value;\n+\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, dt.toDate(), index);\n+            Hibernate.STRING.nullSafeSet(preparedStatement, dt.getZone().getID(), index+1);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new DateTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.YearMonthDay;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+/**\n+ * Persist {@link org.joda.time.YearMonthDay} via hibernate\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentYearMonthDay implements EnhancedUserType\n+{\n+\tpublic final static PersistentYearMonthDay INSTANCE = new PersistentYearMonthDay();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.DATE,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return YearMonthDay.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        YearMonthDay dtx = (YearMonthDay) x;\n+        YearMonthDay dty = (YearMonthDay) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject date = Hibernate.DATE.nullSafeGet(resultSet, string);\n+\t\tif (date == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new YearMonthDay(date);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tHibernate.DATE.nullSafeSet(preparedStatement, ((YearMonthDay) value).toDateMidnight().toDate(), index);\n+\t\t}\n+\t}\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new YearMonthDay(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new YearMonthDay(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Event.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * PO to be stored using hibernate\n+ */\n+public class Event implements Serializable\n+{\n+    private int id;\n+    private DateTime dateTime;\n+\n+    public Event()\n+    {\n+    }\n+\n+    public int getId()\n+    {\n+        return id;\n+    }\n+\n+    public void setId(int id)\n+    {\n+        this.id = id;\n+    }\n+\n+    public DateTime getDateTime()\n+    {\n+        return dateTime;\n+    }\n+\n+    public void setDateTime(DateTime dateTime)\n+    {\n+        this.dateTime = dateTime;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/EventTZ.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * PO to be stored using hibernate\n+ */\n+public class EventTZ implements Serializable\n+{\n+    private int id;\n+    private DateTime dateTime;\n+\n+    public EventTZ()\n+    {\n+    }\n+\n+    public int getId()\n+    {\n+        return id;\n+    }\n+\n+    public void setId(int id)\n+    {\n+        this.id = id;\n+    }\n+\n+    public DateTime getDateTime()\n+    {\n+        return dateTime;\n+    }\n+\n+    public void setDateTime(DateTime dateTime)\n+    {\n+        this.dateTime = dateTime;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/HibernateTestCase.java\n+package org.joda.time.contrib.hibernate;\n+\n+import junit.framework.TestCase;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.hibernate.dialect.HSQLDialect;\n+import org.hibernate.tool.hbm2ddl.SchemaUpdate;\n+\n+public abstract class HibernateTestCase extends TestCase\n+{\n+\tprivate SessionFactory factory;\n+\n+\tprotected SessionFactory getSessionFactory()\n+\t{\n+\t\tif (this.factory == null)\n+\t\t{\n+\t\t\tConfiguration cfg = new Configuration();\n+\n+\t\t\tsetupConfiguration(cfg);\n+\n+\t\t\tcfg.setProperty(\"hibernate.connection.driver_class\", \"org.hsqldb.jdbcDriver\");\n+\t\t\tcfg.setProperty(\"hibernate.connection.url\", \"jdbc:hsqldb:mem:hbmtest\");\n+\t\t\tcfg.setProperty(\"hibernate.dialect\", HSQLDialect.class.getName());\n+\n+\t\t\tcfg.setProperty(\"hibernate.show_sql\", \"true\");\n+\t\t\tSessionFactory factory = cfg.buildSessionFactory();\n+\n+\t\t\tSchemaUpdate update = new SchemaUpdate(cfg);\n+\t\t\tupdate.execute(true, true);\n+\n+\t\t\tthis.factory = factory;\n+\t\t}\n+\t\treturn factory;\n+\t}\n+\n+\tprotected abstract void setupConfiguration(Configuration cfg);\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Schedule.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.YearMonthDay;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * PO to be stored using hibernate\n+ */\n+public class Schedule implements Serializable\n+{\n+    private int id;\n+    private YearMonthDay startDate;\n+\n+    public Schedule()\n+    {\n+    }\n+\n+    public int getId()\n+    {\n+        return id;\n+    }\n+\n+    public void setId(int id)\n+    {\n+        this.id = id;\n+    }\n+\n+\tpublic YearMonthDay getStartDate()\n+\t{\n+\t\treturn startDate;\n+\t}\n+\n+\tpublic void setStartDate(YearMonthDay startDate)\n+\t{\n+\t\tthis.startDate = startDate;\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentDateTime.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentDateTime extends HibernateTestCase\n+{\n+    private DateTime[] writeReadTimes = new DateTime[]\n+    {\n+        new DateTime(2004, 2, 25, 17, 3, 45, 760),\n+        new DateTime(1980, 3, 11,  2, 3, 45,   0, DateTimeZone.forOffsetHours(2))\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            Event event = new Event();\n+            event.setId(i);\n+            event.setDateTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Event eventReread = (Event) session.get(Event.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getDateTime());\n+\n+            // we loose the timezone, so we have to normalize both to offset=0\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime.toDateTime(DateTimeZone.forOffsetHours(0)),\n+                eventReread.getDateTime().toDateTime(DateTimeZone.forOffsetHours(0)));\n+\n+            session.close();\n+        }\n+    }\n+\n+    public void testStoreWithTimezone() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            EventTZ event = new EventTZ();\n+            event.setId(i);\n+            event.setDateTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            EventTZ eventReread = (EventTZ) session.get(EventTZ.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getDateTime());\n+\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime, eventReread.getDateTime());\n+\n+            session.close();\n+        }\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/event.hbm.xml\"));\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml\"));\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentYearMonthDay.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.YearMonthDay;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentYearMonthDay extends HibernateTestCase\n+{\n+    private YearMonthDay[] writeReadTimes = new YearMonthDay[]\n+    {\n+        new YearMonthDay(2004, 2, 25),\n+        new YearMonthDay(1980, 3, 11)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            YearMonthDay writeReadTime = writeReadTimes[i];\n+\n+            Schedule event = new Schedule();\n+            event.setId(i);\n+            event.setStartDate(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            YearMonthDay writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getStartDate());\n+\n+            assertEquals(\"get failed - returned different date\", writeReadTime, eventReread.getStartDate());\n+\n+            session.close();\n+        }\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml\"));\n+\t}\n+}", "timestamp": 1121728852, "metainfo": ""}