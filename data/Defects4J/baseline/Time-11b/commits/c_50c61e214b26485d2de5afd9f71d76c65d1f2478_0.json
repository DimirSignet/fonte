{"sha": "50c61e214b26485d2de5afd9f71d76c65d1f2478", "log": "Fix bugs in partial add methods when starting from a leap day   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n \n     }\n \n     //-----------------------------------------------------------------------\n+    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+        // overridden as superclass algorithm can't handle\n+        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n+        if (valueToAdd == 0) {\n+            return values;\n+        }\n+        if (DateTimeUtils.isContiguous(partial)) {\n+            long instant = 0L;\n+            for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+            }\n+            instant = add(instant, valueToAdd);\n+            return iChronology.get(partial, instant);\n+        } else {\n+            return super.add(partial, fieldIndex, values, valueToAdd);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Add to the Month component of the specified time instant\n      * wrapping around within that component if necessary.\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n             return iGregorianField.add(instant, value);\n         }\n \n+        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+            // overridden as superclass algorithm can't handle\n+            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n+            if (valueToAdd == 0) {\n+                return values;\n+            }\n+            if (DateTimeUtils.isContiguous(partial)) {\n+                long instant = 0L;\n+                for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n+                }\n+                instant = add(instant, valueToAdd);\n+                return GJChronology.this.get(partial, instant);\n+            } else {\n+                return super.add(partial, fieldIndex, values, valueToAdd);\n+            }\n+        }\n+\n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n             return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n         }\n         }\n \n         public int getMaximumValue(ReadablePartial partial) {\n-            return iGregorianField.getMaximumValue(partial);\n+            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n+            return getMaximumValue(instant);\n         }\n \n         public int getMaximumValue(ReadablePartial partial, int[] values) {\n-            return iGregorianField.getMaximumValue(partial, values);\n+            Chronology chrono = GJChronology.getInstanceUTC();\n+            long instant = 0L;\n+            for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                DateTimeField field = partial.getFieldType(i).getField(chrono);\n+                if (values[i] <= field.getMaximumValue(instant)) {\n+                    instant = field.set(instant, values[i]);\n+                }\n+            }\n+            return getMaximumValue(instant);\n         }\n \n         public long roundFloor(long instant) {\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n                 }\n                 nextField = instant.getField(fieldIndex - 1);\n                 // test only works if this field is UTC (ie. local)\n-                if (getRangeDurationField() != nextField.getDurationField()) {\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n                     throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                 }\n                 nextField = instant.getField(fieldIndex - 1);\n-                if (getRangeDurationField() != nextField.getDurationField()) {\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n                 }\n                 nextField = instant.getField(fieldIndex - 1);\n                 // test only works if this field is UTC (ie. local)\n-                if (getRangeDurationField() != nextField.getDurationField()) {\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n                     continue;\n                 }\n                 nextField = instant.getField(fieldIndex - 1);\n-                if (getRangeDurationField() != nextField.getDurationField()) {\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                     throw new IllegalArgumentException(\"Fields invalid for add\");\n                 }\n             }\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n  */\n public class TestYearMonthDay_Properties extends TestCase {\n \n-    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n-    \n     private long TEST_TIME_NOW =\n             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n             \n     }\n \n     //-----------------------------------------------------------------------\n-    private void check(YearMonthDay test, int hour, int min, int sec) {\n-        assertEquals(hour, test.getYear());\n-        assertEquals(min, test.getMonthOfYear());\n-        assertEquals(sec, test.getDayOfMonth());\n+    private void check(YearMonthDay test, int year, int month, int day) {\n+        assertEquals(year, test.getYear());\n+        assertEquals(month, test.getMonthOfYear());\n+        assertEquals(day, test.getDayOfMonth());\n     }\n }\n--- a/JodaTime/src/test/org/joda/time/chrono/TestGJChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestGJChronology.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.DateMidnight;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DurationFieldType;\n import org.joda.time.Instant;\n import org.joda.time.Period;\n+import org.joda.time.TimeOfDay;\n import org.joda.time.YearMonthDay;\n \n /**\n         testAdd(\"1582-10-15\", DurationFieldType.days(), 10, \"1582-10-25\");\n     }\n \n+    public void testYearEndAddDays() {\n+        testAdd(\"1582-11-05\", DurationFieldType.days(), 28, \"1582-12-03\");\n+        testAdd(\"1582-12-05\", DurationFieldType.days(), 28, \"1583-01-02\");\n+        \n+        testAdd(\"2005-11-05\", DurationFieldType.days(), 28, \"2005-12-03\");\n+        testAdd(\"2005-12-05\", DurationFieldType.days(), 28, \"2006-01-02\");\n+    }\n+\n     public void testSubtractDays() {\n         // This is a test for a bug in version 1.0. The dayOfMonth range\n         // duration field did not match the monthOfYear duration field. This\n         DurationField field = type.getField(GJChronology.getInstance(DateTimeZone.UTC));\n         int diff = field.getDifference(dtEnd.getMillis(), dtStart.getMillis());\n         assertEquals(amt, diff);\n-    }\n+        \n+        if (type == DurationFieldType.years() ||\n+            type == DurationFieldType.months() ||\n+            type == DurationFieldType.days()) {\n+            YearMonthDay ymdStart = new YearMonthDay(start, GJChronology.getInstance(DateTimeZone.UTC));\n+            YearMonthDay ymdEnd = new YearMonthDay(end, GJChronology.getInstance(DateTimeZone.UTC));\n+            assertEquals(ymdEnd, ymdStart.withFieldAdded(type, amt));\n+            assertEquals(ymdStart, ymdEnd.withFieldAdded(type, -amt));\n+        }\n+    }\n+\n+    public void testTimeOfDayAdd() {\n+        TimeOfDay start = new TimeOfDay(12, 30, GJChronology.getInstance());\n+        TimeOfDay end = new TimeOfDay(10, 30, GJChronology.getInstance());\n+        assertEquals(end, start.plusHours(22));\n+        assertEquals(start, end.minusHours(22));\n+        assertEquals(end, start.plusMinutes(22 * 60));\n+        assertEquals(start, end.minusMinutes(22 * 60));\n+    }\n+\n+    public void testMaximumValue() {\n+        DateMidnight dt = new DateMidnight(1570, 1, 1, GJChronology.getInstance());\n+        while (dt.getYear() < 1590) {\n+            dt = dt.plusDays(1);\n+            YearMonthDay ymd = dt.toYearMonthDay();\n+            assertEquals(dt.year().getMaximumValue(), ymd.year().getMaximumValue());\n+            assertEquals(dt.monthOfYear().getMaximumValue(), ymd.monthOfYear().getMaximumValue());\n+            assertEquals(dt.dayOfMonth().getMaximumValue(), ymd.dayOfMonth().getMaximumValue());\n+        }\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.DateMidnight;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.Partial;\n+import org.joda.time.TimeOfDay;\n+import org.joda.time.YearMonthDay;\n \n /**\n  * This class is a Junit unit test for ISOChronology.\n         }\n     }\n \n+    public void testCutoverAddYears() {\n+        testAdd(\"1582-01-01\", DurationFieldType.years(), 1, \"1583-01-01\");\n+        testAdd(\"1582-02-15\", DurationFieldType.years(), 1, \"1583-02-15\");\n+        testAdd(\"1582-02-28\", DurationFieldType.years(), 1, \"1583-02-28\");\n+        testAdd(\"1582-03-01\", DurationFieldType.years(), 1, \"1583-03-01\");\n+        testAdd(\"1582-09-30\", DurationFieldType.years(), 1, \"1583-09-30\");\n+        testAdd(\"1582-10-01\", DurationFieldType.years(), 1, \"1583-10-01\");\n+        testAdd(\"1582-10-04\", DurationFieldType.years(), 1, \"1583-10-04\");\n+        testAdd(\"1582-10-15\", DurationFieldType.years(), 1, \"1583-10-15\");\n+        testAdd(\"1582-10-16\", DurationFieldType.years(), 1, \"1583-10-16\");\n+        testAdd(\"1580-01-01\", DurationFieldType.years(), 4, \"1584-01-01\");\n+        testAdd(\"1580-02-29\", DurationFieldType.years(), 4, \"1584-02-29\");\n+        testAdd(\"1580-10-01\", DurationFieldType.years(), 4, \"1584-10-01\");\n+        testAdd(\"1580-10-10\", DurationFieldType.years(), 4, \"1584-10-10\");\n+        testAdd(\"1580-10-15\", DurationFieldType.years(), 4, \"1584-10-15\");\n+        testAdd(\"1580-12-31\", DurationFieldType.years(), 4, \"1584-12-31\");\n+    }\n+\n+    public void testAddMonths() {\n+        testAdd(\"1582-01-01\", DurationFieldType.months(), 1, \"1582-02-01\");\n+        testAdd(\"1582-01-01\", DurationFieldType.months(), 6, \"1582-07-01\");\n+        testAdd(\"1582-01-01\", DurationFieldType.months(), 12, \"1583-01-01\");\n+        testAdd(\"1582-11-15\", DurationFieldType.months(), 1, \"1582-12-15\");\n+        testAdd(\"1582-09-04\", DurationFieldType.months(), 2, \"1582-11-04\");\n+        testAdd(\"1582-09-05\", DurationFieldType.months(), 2, \"1582-11-05\");\n+        testAdd(\"1582-09-10\", DurationFieldType.months(), 2, \"1582-11-10\");\n+        testAdd(\"1582-09-15\", DurationFieldType.months(), 2, \"1582-11-15\");\n+        testAdd(\"1580-01-01\", DurationFieldType.months(), 48, \"1584-01-01\");\n+        testAdd(\"1580-02-29\", DurationFieldType.months(), 48, \"1584-02-29\");\n+        testAdd(\"1580-10-01\", DurationFieldType.months(), 48, \"1584-10-01\");\n+        testAdd(\"1580-10-10\", DurationFieldType.months(), 48, \"1584-10-10\");\n+        testAdd(\"1580-10-15\", DurationFieldType.months(), 48, \"1584-10-15\");\n+        testAdd(\"1580-12-31\", DurationFieldType.months(), 48, \"1584-12-31\");\n+    }\n+\n+    private void testAdd(String start, DurationFieldType type, int amt, String end) {\n+        DateTime dtStart = new DateTime(start, ISOChronology.getInstanceUTC());\n+        DateTime dtEnd = new DateTime(end, ISOChronology.getInstanceUTC());\n+        assertEquals(dtEnd, dtStart.withFieldAdded(type, amt));\n+        assertEquals(dtStart, dtEnd.withFieldAdded(type, -amt));\n+\n+        DurationField field = type.getField(ISOChronology.getInstanceUTC());\n+        int diff = field.getDifference(dtEnd.getMillis(), dtStart.getMillis());\n+        assertEquals(amt, diff);\n+        \n+        if (type == DurationFieldType.years() ||\n+            type == DurationFieldType.months() ||\n+            type == DurationFieldType.days()) {\n+            YearMonthDay ymdStart = new YearMonthDay(start, ISOChronology.getInstanceUTC());\n+            YearMonthDay ymdEnd = new YearMonthDay(end, ISOChronology.getInstanceUTC());\n+            assertEquals(ymdEnd, ymdStart.withFieldAdded(type, amt));\n+            assertEquals(ymdStart, ymdEnd.withFieldAdded(type, -amt));\n+        }\n+    }\n+\n+    public void testTimeOfDayAdd() {\n+        TimeOfDay start = new TimeOfDay(12, 30);\n+        TimeOfDay end = new TimeOfDay(10, 30);\n+        assertEquals(end, start.plusHours(22));\n+        assertEquals(start, end.minusHours(22));\n+        assertEquals(end, start.plusMinutes(22 * 60));\n+        assertEquals(start, end.minusMinutes(22 * 60));\n+    }\n+\n+    public void testPartialDayOfYearAdd() {\n+        Partial start = new Partial().with(DateTimeFieldType.year(), 2000).with(DateTimeFieldType.dayOfYear(), 366);\n+        Partial end = new Partial().with(DateTimeFieldType.year(), 2004).with(DateTimeFieldType.dayOfYear(), 366);\n+        assertEquals(end, start.withFieldAdded(DurationFieldType.days(), 365 + 365 + 365 + 366));\n+        assertEquals(start, end.withFieldAdded(DurationFieldType.days(), -(365 + 365 + 365 + 366)));\n+    }\n+\n+    public void testMaximumValue() {\n+        DateMidnight dt = new DateMidnight(1570, 1, 1);\n+        while (dt.getYear() < 1590) {\n+            dt = dt.plusDays(1);\n+            YearMonthDay ymd = dt.toYearMonthDay();\n+            assertEquals(dt.year().getMaximumValue(), ymd.year().getMaximumValue());\n+            assertEquals(dt.monthOfYear().getMaximumValue(), ymd.monthOfYear().getMaximumValue());\n+            assertEquals(dt.dayOfMonth().getMaximumValue(), ymd.dayOfMonth().getMaximumValue());\n+        }\n+    }\n+\n }", "timestamp": 1134090254, "metainfo": ""}