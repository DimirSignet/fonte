{"sha": "7f40c2c885cc3258933223397cc03d8704290120", "log": "Bug fixes in set matching parse.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n         }\n         int length = parsers.length;\n         if (length == 1) {\n-            // If the last element is null, an exception is still thrown.\n-            return append(printer, parsers[0]);\n+            if (parsers[0] == null) {\n+                throw new IllegalArgumentException(\"No parser supplied\");\n+            }\n+            return append0(printer, parsers[0]);\n         }\n \n         DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n             return iParsedLengthEstimate;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {\n             DateTimeParser[] parsers = iParsers;\n             int length = parsers.length;\n \n-            Object state = bucket.saveState();\n-            \n+            final Object originalState = bucket.saveState();\n+            boolean isOptional = false;\n+\n+            int bestValidPos = position;\n+            Object bestValidState = null;\n+\n             int bestInvalidPos = position;\n-            int bestInvalidParser = 0;\n-            int bestValidPos = position;\n-            int bestValidParser = 0;\n \n             for (int i=0; i<length; i++) {\n-                if (i != 0) {\n-                    bucket.undoChanges(state);\n-                }\n-\n                 DateTimeParser parser = parsers[i];\n                 if (parser == null) {\n                     // The empty parser wins only if nothing is better.\n-                    if (bestValidPos > position) {\n-                        break;\n+                    if (bestValidPos <= position) {\n+                        return position;\n                     }\n-                    return position;\n-                }\n-\n+                    isOptional = true;\n+                    break;\n+                }\n                 int parsePos = parser.parseInto(bucket, text, position);\n                 if (parsePos >= position) {\n-                    if (parsePos >= text.length()) {\n-                        return parsePos;\n-                    }\n                     if (parsePos > bestValidPos) {\n+                        if (parsePos >= text.length() ||\n+                            (i + 1) >= length || parsers[i + 1] == null) {\n+\n+                            // Completely parsed text or no more parsers to\n+                            // check. Skip the rest.\n+                            return parsePos;\n+                        }\n                         bestValidPos = parsePos;\n-                        bestValidParser = i;\n+                        bestValidState = bucket.saveState();\n                     }\n                 } else {\n-                    parsePos = ~parsePos;\n-                    if (parsePos > bestInvalidPos) {\n-                        bestInvalidPos = parsePos;\n-                        bestInvalidParser = i;\n+                    bucket.undoChanges(originalState);\n+                    if (parsePos < 0) {\n+                        parsePos = ~parsePos;\n+                        if (parsePos > bestInvalidPos) {\n+                            bestInvalidPos = parsePos;\n+                        }\n                     }\n                 }\n             }\n \n-            if (bestValidPos > position) {\n-                if (bestValidParser == length - 1) {\n-                    // The best valid parser was the last one, so the bucket is\n-                    // already in the best state.\n-                    return bestValidPos;\n-                }\n-                bucket.undoChanges(state);\n-                // Call best valid parser again to restore bucket state.\n-                return parsers[bestValidParser].parseInto(bucket, text, position);\n-            }\n-\n-            if (bestInvalidParser == length - 1) {\n-                // The best invalid parser was the last one, so the bucket is\n-                // already in the best state.\n-                return ~bestInvalidPos;\n-            }\n-\n-            bucket.undoChanges(state);\n-            // Call best invalid parser again to restore bucket state.\n-            return parsers[bestInvalidParser].parseInto(bucket, text, position);\n+            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n+                // Restore the state to the best valid parse.\n+                if (bestValidState != null) {\n+                    bucket.undoChanges(bestValidState);\n+                }\n+                return bestValidPos;\n+            }\n+\n+            return ~bestInvalidPos;\n         }\n     }\n }", "timestamp": 1073251373, "metainfo": ""}