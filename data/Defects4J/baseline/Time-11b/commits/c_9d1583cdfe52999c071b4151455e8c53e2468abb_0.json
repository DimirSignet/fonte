{"sha": "9d1583cdfe52999c071b4151455e8c53e2468abb", "log": "Fix bug where Chronology instances were compared by identity instead of equals()   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n         }\n \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+\n+        /**\n          * Gets the datetime being used.\n          * \n          * @return the datetime\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n         }\n         \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n          * Gets the datetime being used.\n          * \n          * @return the datetime\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n         }\n         \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n          * Gets the LocalDate object linked to this property.\n          * \n          * @return the linked LocalDate\n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n         }\n         \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n          * Gets the LocalDateTime object linked to this property.\n          * \n          * @return the linked LocalDateTime\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n         }\n         \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n          * Gets the LocalTime object linked to this property.\n          * \n          * @return the linked LocalTime\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n         }\n         \n         /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n          * Gets the mutable datetime being used.\n          * \n          * @return the mutable datetime\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n         if (this == readableInstant) {\n             return true;\n         }\n-        if (readableInstant instanceof ReadableInstant) {\n-            ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n-            if (getMillis() == otherInstant.getMillis()) {\n-                Chronology chrono = getChronology();\n-                if (chrono == otherInstant.getChronology()) {\n-                    return true;\n-                }\n-                if (chrono != null && chrono.equals(otherInstant.getChronology())) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n+        if (readableInstant instanceof ReadableInstant == false) {\n+            return false;\n+        }\n+        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n+        return\n+            getMillis() == otherInstant.getMillis() &&\n+            FieldUtils.equals(getChronology(), otherInstant.getChronology());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n             return false;\n         }\n         ReadableInterval other = (ReadableInterval) readableInterval;\n-        return (getStartMillis() == other.getStartMillis() &&\n-                getEndMillis() == other.getEndMillis() &&\n-                getChronology() == other.getChronology());\n+        return \n+            getStartMillis() == other.getStartMillis() &&\n+            getEndMillis() == other.getEndMillis() &&\n+            FieldUtils.equals(getChronology(), other.getChronology());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n import org.joda.time.DurationFieldType;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n \n /**\n                 return false;\n             }\n         }\n-        return (getChronology() == other.getChronology());\n+        return FieldUtils.equals(getChronology(), other.getChronology());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n         return LenientDateTimeField.getInstance(field);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A lenient chronology is only equal to a lenient chronology with the\n+     * same base chronology.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof LenientChronology == false) {\n+            return false;\n+        }\n+        LenientChronology chrono = (LenientChronology) obj;\n+        return getBase().equals(chrono.getBase());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 236548278 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n     public String toString() {\n         return \"LenientChronology[\" + getBase().toString() + ']';\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n import org.joda.time.ReadableDateTime;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.DecoratedDurationField;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.ISODateTimeFormat;\n \n         return limitField;\n     }\n \n-    public String toString() {\n-        return getBase().toString();\n-    }\n-\n     void checkLimits(long instant, String desc) {\n         DateTime limit;\n         if ((limit = iLowerLimit) != null && instant < limit.getMillis()) {\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A limit chronology is only equal to a limit chronology with the\n+     * same base chronology and limits.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof LimitChronology == false) {\n+            return false;\n+        }\n+        LimitChronology chrono = (LimitChronology) obj;\n+        return\n+            getBase().equals(chrono.getBase()) &&\n+            FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) &&\n+            FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        int hash = 317351877;\n+        hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0);\n+        hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0);\n+        hash += getBase().hashCode() * 7;\n+        return hash;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n+    public String toString() {\n+        return \"LimitChronology[\" + getBase().toString() + \", \" +\n+            (getLowerLimit() == null ? \"NoLimit\" : getLowerLimit().toString()) + \", \" +\n+            (getUpperLimit() == null ? \"NoLimit\" : getUpperLimit().toString()) + ']';\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Extends IllegalArgumentException such that the exception message is not\n      * generated unless it is actually requested.\n--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n         return StrictDateTimeField.getInstance(field);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A strict chronology is only equal to a strict chronology with the\n+     * same base chronology.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof StrictChronology == false) {\n+            return false;\n+        }\n+        StrictChronology chrono = (StrictChronology) obj;\n+        return getBase().equals(chrono.getBase());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 352831696 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n     public String toString() {\n         return \"StrictChronology[\" + getBase().toString() + ']';\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n         return zonedField;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A zoned chronology is only equal to a zoned chronology with the\n+     * same base chronology and zone.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof ZonedChronology == false) {\n+            return false;\n+        }\n+        ZonedChronology chrono = (ZonedChronology) obj;\n+        return\n+            getBase().equals(chrono.getBase()) &&\n+            getZone().equals(chrono.getZone());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n     public String toString() {\n         return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n     }\n \n+    //-----------------------------------------------------------------------\n     /*\n      * Because time durations are typically smaller than time zone offsets, the\n      * arithmetic methods subtract the original offset. This produces a more\n      * the new offset is subtracted off. This behavior, if applied to time\n      * fields, can nullify or reverse an add when crossing a transition.\n      */\n-\n     static class ZonedDurationField extends BaseDurationField {\n         private static final long serialVersionUID = -485345310999208286L;\n \n--- a/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n         if (this == object) {\n             return true;\n         }\n-        if (object instanceof AbstractPartialFieldProperty) {\n-            AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n-            if (get() == other.get() &&\n-                getFieldType() == other.getFieldType() &&\n-                getReadablePartial().getChronology() == other.getReadablePartial().getChronology()) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        if (object instanceof AbstractPartialFieldProperty == false) {\n+            return false;\n+        }\n+        AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n+        return\n+            get() == other.get() &&\n+            getFieldType() == other.getFieldType() &&\n+            FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n import java.io.Serializable;\n import java.util.Locale;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n      */\n     protected abstract long getMillis();\n \n+    /**\n+     * Gets the chronology of the datetime that this property is linked to.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException, and must be\n+     * implemented by subclasses to enable the equals() and hashCode() methods.\n+     * \n+     * @return the chronology\n+     * @since 1.4\n+     */\n+    protected Chronology getChronology() {\n+        throw new UnsupportedOperationException(\n+                \"The method getChronology() was added in v1.4 and needs \" +\n+                \"to be implemented by subclasses of AbstractReadableInstantFieldProperty\");\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value of this property from the instant.\n         if (this == object) {\n             return true;\n         }\n-        if (object instanceof AbstractReadableInstantFieldProperty) {\n-            AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n-            if (get() == other.get() &&\n-                getField().equals(other.getField())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        if (object instanceof AbstractReadableInstantFieldProperty == false) {\n+            return false;\n+        }\n+        AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n+        return \n+            get() == other.get() &&\n+            getFieldType().equals(other.getFieldType()) &&\n+            FieldUtils.equals(getChronology(), other.getChronology());\n     }\n \n     /**\n      * @return the hashcode\n      */\n     public int hashCode() {\n-        return get() * 17 + getField().hashCode();\n+        return get() * 17 + getFieldType().hashCode() + getChronology().hashCode();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java\n         return (wrapRange - remByRange) + minValue;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects as equals handling null.\n+     * \n+     * @param object1  the first object\n+     * @param object2  the second object\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if (object1 == null || object2 == null) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestChronology.java\n+++ b/JodaTime/src/test/org/joda/time/TestChronology.java\n \n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.EthiopicChronology;\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.IslamicChronology;\n import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.LimitChronology;\n+import org.joda.time.chrono.StrictChronology;\n+import org.joda.time.chrono.ZonedChronology;\n \n /**\n  * This class is a Junit unit test for Chronology.\n         assertEquals(CopticChronology.getInstance(), Chronology.getCoptic(null));\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode_ISO() {\n+        Chronology chrono1 = ISOChronology.getInstanceUTC();\n+        Chronology chrono2 = ISOChronology.getInstanceUTC();\n+        Chronology chrono3 = ISOChronology.getInstance();\n+        \n+        assertEquals(true, chrono1.equals(chrono2));\n+        assertEquals(false, chrono1.equals(chrono3));\n+        \n+        DateTime dt1 = new DateTime(0L, chrono1);\n+        DateTime dt2 = new DateTime(0L, chrono2);\n+        DateTime dt3 = new DateTime(0L, chrono3);\n+        \n+        assertEquals(true, dt1.equals(dt2));\n+        assertEquals(false, dt1.equals(dt3));\n+        \n+        assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode_Lenient() {\n+        Chronology chrono1 = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n+        Chronology chrono2 = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n+        Chronology chrono3 = LenientChronology.getInstance(ISOChronology.getInstance());\n+        \n+        assertEquals(true, chrono1.equals(chrono2));\n+        assertEquals(false, chrono1.equals(chrono3));\n+        \n+        DateTime dt1 = new DateTime(0L, chrono1);\n+        DateTime dt2 = new DateTime(0L, chrono2);\n+        DateTime dt3 = new DateTime(0L, chrono3);\n+        \n+        assertEquals(true, dt1.equals(dt2));\n+        assertEquals(false, dt1.equals(dt3));\n+        \n+        assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode_Strict() {\n+        Chronology chrono1 = StrictChronology.getInstance(ISOChronology.getInstanceUTC());\n+        Chronology chrono2 = StrictChronology.getInstance(ISOChronology.getInstanceUTC());\n+        Chronology chrono3 = StrictChronology.getInstance(ISOChronology.getInstance());\n+        \n+        assertEquals(true, chrono1.equals(chrono2));\n+        assertEquals(false, chrono1.equals(chrono3));\n+        \n+        DateTime dt1 = new DateTime(0L, chrono1);\n+        DateTime dt2 = new DateTime(0L, chrono2);\n+        DateTime dt3 = new DateTime(0L, chrono3);\n+        \n+        assertEquals(true, dt1.equals(dt2));\n+        assertEquals(false, dt1.equals(dt3));\n+        \n+        assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode_Limit() {\n+        DateTime lower = new DateTime(0L);\n+        DateTime higherA = new DateTime(1000000L);\n+        DateTime higherB = new DateTime(2000000L);\n+        \n+        Chronology chrono1 = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA);\n+        Chronology chrono2A = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA);\n+        Chronology chrono2B = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherB);\n+        Chronology chrono3 = LimitChronology.getInstance(ISOChronology.getInstance(), lower, higherA);\n+        \n+        assertEquals(true, chrono1.equals(chrono2A));\n+        assertEquals(false, chrono1.equals(chrono2B));\n+        assertEquals(false, chrono1.equals(chrono3));\n+        \n+        DateTime dt1 = new DateTime(0L, chrono1);\n+        DateTime dt2A = new DateTime(0L, chrono2A);\n+        DateTime dt2B = new DateTime(0L, chrono2B);\n+        DateTime dt3 = new DateTime(0L, chrono3);\n+        \n+        assertEquals(true, dt1.equals(dt2A));\n+        assertEquals(false, dt1.equals(dt2B));\n+        assertEquals(false, dt1.equals(dt3));\n+        \n+        assertEquals(true, chrono1.hashCode() == chrono2A.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono2B.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode_Zoned() {\n+        DateTimeZone zoneA = DateTimeZone.forID(\"Europe/Paris\");\n+        DateTimeZone zoneB = DateTimeZone.forID(\"Asia/Tokyo\");\n+        \n+        Chronology chrono1 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA);\n+        Chronology chrono2 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA);\n+        Chronology chrono3 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneB);\n+        \n+        assertEquals(true, chrono1.equals(chrono2));\n+        assertEquals(false, chrono1.equals(chrono3));\n+        \n+        DateTime dt1 = new DateTime(0L, chrono1);\n+        DateTime dt2 = new DateTime(0L, chrono2);\n+        DateTime dt3 = new DateTime(0L, chrono3);\n+        \n+        assertEquals(true, dt1.equals(dt2));\n+        assertEquals(false, dt1.equals(dt3));\n+        \n+        assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n+        assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n+        ISOChronology isoParis = ISOChronology.getInstance(paris);\n+        \n+        assertEquals(\"ISOChronology[Europe/Paris]\", isoParis.toString());\n+        assertEquals(\"GJChronology[Europe/Paris]\", GJChronology.getInstance(paris).toString());\n+        assertEquals(\"GregorianChronology[Europe/Paris]\", GregorianChronology.getInstance(paris).toString());\n+        assertEquals(\"JulianChronology[Europe/Paris]\", JulianChronology.getInstance(paris).toString());\n+        assertEquals(\"BuddhistChronology[Europe/Paris]\", BuddhistChronology.getInstance(paris).toString());\n+        assertEquals(\"CopticChronology[Europe/Paris]\", CopticChronology.getInstance(paris).toString());\n+        assertEquals(\"EthiopicChronology[Europe/Paris]\", EthiopicChronology.getInstance(paris).toString());\n+        assertEquals(\"IslamicChronology[Europe/Paris]\", IslamicChronology.getInstance(paris).toString());\n+        \n+        assertEquals(\"LenientChronology[ISOChronology[Europe/Paris]]\", LenientChronology.getInstance(isoParis).toString());\n+        assertEquals(\"StrictChronology[ISOChronology[Europe/Paris]]\", StrictChronology.getInstance(isoParis).toString());\n+        assertEquals(\"LimitChronology[ISOChronology[Europe/Paris], NoLimit, NoLimit]\", LimitChronology.getInstance(isoParis, null, null).toString());\n+        assertEquals(\"ZonedChronology[ISOChronology[UTC], Europe/Paris]\", ZonedChronology.getInstance(isoParis, paris).toString());\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestDateMidnight_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Properties.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n+\n /**\n  * This class is a Junit unit test for DateTime.\n  *\n public class TestDateMidnight_Properties extends TestCase {\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n \n     //private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n       assertEquals(new DateMidnight(2004, 3, 1), febTestInterval.getEnd());\n     }\n \n+    public void testPropertyEqualsHashCodeLenient() {\n+        DateMidnight test1 = new DateMidnight(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        DateMidnight test2 = new DateMidnight(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        DateMidnight test1 = new DateMidnight(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        DateMidnight test2 = new DateMidnight(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n import junit.framework.TestSuite;\n \n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n \n /**\n  * This class is a Junit unit test for DateTime.\n public class TestDateTime_Properties extends TestCase {\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n \n     //private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n       assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 54), testInterval.getEnd());\n     }\n \n+    public void testPropertyEqualsHashCodeLenient() {\n+        DateTime test1 = new DateTime(1970, 6, 9, 0, 0, 0, 0, LenientChronology.getInstance(COPTIC_PARIS));\n+        DateTime test2 = new DateTime(1970, 6, 9, 0, 0, 0, 0, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        DateTime test1 = new DateTime(1970, 6, 9, 0, 0, 0, 0, StrictChronology.getInstance(COPTIC_PARIS));\n+        DateTime test2 = new DateTime(1970, 6, 9, 0, 0, 0, 0, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n import org.joda.time.chrono.CopticChronology;\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n \n /**\n  * This class is a Junit unit test for Instant.\n         assertEquals(true, test1.equals(new MockInterval()));\n         assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));\n     }\n-    \n+\n     class MockInterval extends AbstractInterval {\n         public MockInterval() {\n             super();\n         }\n     }\n \n+    public void testEqualsHashCodeLenient() {\n+        Interval test1 = new Interval(\n+                new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)),\n+                new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS)));\n+        Interval test2 = new Interval(\n+                new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)),\n+                new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS)));\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+    }\n+\n+    public void testEqualsHashCodeStrict() {\n+        Interval test1 = new Interval(\n+                new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)),\n+                new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS)));\n+        Interval test2 = new Interval(\n+                new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)),\n+                new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS)));\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void test_useCase_ContainsOverlapAbutGap() {\n         // this is a simple test to ensure that the use case of these methods is OK\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Basics.java\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n         assertEquals(true, test1.equals(new YearMonthDay(1970, 6, 9, COPTIC_PARIS)));\n         assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n-    \n+\n     class MockInstant extends MockPartial {\n         public Chronology getChronology() {\n             return COPTIC_UTC;\n         }\n     }\n \n+    public void testEqualsHashCodeLenient() {\n+        LocalDate test1 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        LocalDate test2 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+    }\n+\n+    public void testEqualsHashCodeStrict() {\n+        LocalDate test1 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        LocalDate test2 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testCompareTo() {\n         LocalDate test1 = new LocalDate(2005, 6, 2);\n--- a/JodaTime/src/test/org/joda/time/TestLocalDate_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDate_Properties.java\n import junit.framework.TestSuite;\n \n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n \n /**\n  * This class is a Junit unit test for YearMonthDay.\n  * @author Stephen Colebourne\n  */\n public class TestLocalDate_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n \n     private long TEST_TIME_NOW =\n             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n         assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n     }\n \n+    public void testPropertyEqualsHashCodeLenient() {\n+        LocalDate test1 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        LocalDate test2 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        LocalDate test1 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        LocalDate test2 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n     //-----------------------------------------------------------------------\n     private void check(LocalDate test, int year, int month, int day) {\n         assertEquals(year, test.getYear());\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Properties.java\n import junit.framework.TestSuite;\n \n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n \n /**\n  * This class is a Junit unit test for YearMonthDay.\n  * @author Stephen Colebourne\n  */\n public class TestYearMonthDay_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n \n     private long TEST_TIME_NOW =\n             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n         assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode());\n     }\n \n+    public void testPropertyEqualsHashCodeLenient() {\n+        YearMonthDay test1 = new YearMonthDay(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        YearMonthDay test2 = new YearMonthDay(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n+    public void testPropertyEqualsHashCodeStrict() {\n+        YearMonthDay test1 = new YearMonthDay(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        YearMonthDay test2 = new YearMonthDay(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS));\n+        assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n+        assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth()));\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+        assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode());\n+        assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode());\n+    }\n+\n     //-----------------------------------------------------------------------\n     private void check(YearMonthDay test, int year, int month, int day) {\n         assertEquals(year, test.getYear());", "timestamp": 1161450000, "metainfo": ""}