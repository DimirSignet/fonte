{"sha": "44e2b4553860afcafb8ff969c8f416cda3b62f01", "log": "More performance enhancements for Local* classes  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n import java.util.Locale;\n import java.util.Set;\n \n-import org.joda.time.base.AbstractPartial;\n+import org.joda.time.base.BaseLocal;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.PartialConverter;\n  * @since 1.3\n  */\n public final class LocalDate\n-        extends AbstractPartial\n+        extends BaseLocal\n         implements ReadablePartial, Serializable {\n \n     /** Serialization lock */\n      * \n      * @return the number of milliseconds since 1970-01-01T00:00:00\n      */\n-    long getLocalMillis() {\n+    protected long getLocalMillis() {\n         return iLocalMillis;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n import java.util.Date;\n import java.util.Locale;\n \n-import org.joda.time.base.AbstractPartial;\n+import org.joda.time.base.BaseLocal;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.PartialConverter;\n  * @since 1.3\n  */\n public final class LocalDateTime\n-        extends AbstractPartial\n+        extends BaseLocal\n         implements ReadablePartial, Serializable {\n \n     /** Serialization lock */\n      *\n      * @return the number of milliseconds since 1970-01-01T00:00:00\n      */\n-    long getLocalMillis() {\n+    protected long getLocalMillis() {\n         return iLocalMillis;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n import java.util.Locale;\n import java.util.Set;\n \n-import org.joda.time.base.AbstractPartial;\n+import org.joda.time.base.BaseLocal;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.PartialConverter;\n  * @since 1.3\n  */\n public final class LocalTime\n-        extends AbstractPartial\n+        extends BaseLocal\n         implements ReadablePartial, Serializable {\n \n     /** Serialization lock */\n      * \n      * @return the number of milliseconds since 1970-01-01T00:00:00\n      */\n-    long getLocalMillis() {\n+    protected long getLocalMillis() {\n         return iLocalMillis;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BaseLocal.java\n+/*\n+ *  Copyright 2001-2007 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+/**\n+ * BaseLocal is an abstract implementation of ReadablePartial that\n+ * use a local milliseconds internal representation.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link org.joda.time.ReadablePartial} interface should be used when different \n+ * kinds of partial objects are to be referenced.\n+ * <p>\n+ * BasePartial subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.5\n+ */\n+public abstract class BaseLocal\n+        extends AbstractPartial {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 276453175381783L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a partial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    protected BaseLocal() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the local milliseconds from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * <p>\n+     * This method is useful in certain circustances for high performance\n+     * access to the datetime fields.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     */\n+    protected abstract long getLocalMillis();\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n /*\n- *  Copyright 2001-2006 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n             long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n             Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n-            chrono = DateTimeUtils.getChronology(chrono);\n             iType = type;\n             iValues = chrono.get(this, startMillis, endMillis);\n         }\n         if (start == null || end == null) {\n             throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n         }\n-        if (start.size() != end.size()) {\n-            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n-        }\n-        for (int i = 0, isize = start.size(); i < isize; i++) {\n-            if (start.getFieldType(i) != end.getFieldType(i)) {\n+        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n+            // for performance\n+            type = checkPeriodType(type);\n+            long startMillis = ((BaseLocal) start).getLocalMillis();\n+            long endMillis = ((BaseLocal) end).getLocalMillis();\n+            Chronology chrono = start.getChronology();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            iType = type;\n+            iValues = chrono.get(this, startMillis, endMillis);\n+        } else {\n+            if (start.size() != end.size()) {\n                 throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n             }\n-        }\n-        if (DateTimeUtils.isContiguous(start) == false) {\n-            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n-        }\n-        iType = checkPeriodType(type);\n-        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n-        iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n+            for (int i = 0, isize = start.size(); i < isize; i++) {\n+                if (start.getFieldType(i) != end.getFieldType(i)) {\n+                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+                }\n+            }\n+            if (DateTimeUtils.isContiguous(start) == false) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n+            }\n+            iType = checkPeriodType(type);\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n+            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n+        }\n     }\n \n     /**\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2007 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(0, test.getMillis());\n     }\n \n+    public void testConstructor_RP_RP2Local() throws Throwable {\n+        LocalDate dt1 = new LocalDate(2004, 6, 9);\n+        LocalDate dt2 = new LocalDate(2005, 5, 17);\n+        Period test = new Period(dt1, dt2);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(11, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+    }\n+\n     public void testConstructor_RP_RP3() throws Throwable {\n         YearMonthDay dt1 = null;\n         YearMonthDay dt2 = new YearMonthDay(2005, 7, 17);\n     public void testConstructor_RP_RP_PeriodType2() throws Throwable {\n         YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);\n         YearMonthDay dt2 = new YearMonthDay(2005, 5, 17);\n+        Period test = new Period(dt1, dt2, PeriodType.yearMonthDay());\n+        assertEquals(PeriodType.yearMonthDay(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(11, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(8, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+    }\n+\n+    public void testConstructor_RP_RP_PeriodType2Local() throws Throwable {\n+        LocalDate dt1 = new LocalDate(2004, 6, 9);\n+        LocalDate dt2 = new LocalDate(2005, 5, 17);\n         Period test = new Period(dt1, dt2, PeriodType.yearMonthDay());\n         assertEquals(PeriodType.yearMonthDay(), test.getPeriodType());\n         assertEquals(0, test.getYears());", "timestamp": 1176153888, "metainfo": ""}