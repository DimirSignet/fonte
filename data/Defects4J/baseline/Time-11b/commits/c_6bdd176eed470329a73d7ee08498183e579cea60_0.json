{"sha": "6bdd176eed470329a73d7ee08498183e579cea60", "log": "Change Chronology to abstract class   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n  * information on the Joda project, please see <http://www.joda.org/>.\n  */\n package org.joda.time;\n+\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * Chronology provides access to the individual date time fields for a\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public interface Chronology {\n-    \n+public abstract class Chronology {\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the default zone.\n+     * <p>\n+     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n+     * This chronology is the default, and is suitable for all normal datetime processing.\n+     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n+     * as it applies the modern Gregorian calendar rules before that date.\n+     *\n+     * @return the ISO chronology\n+     */\n+    public static Chronology getISO() {\n+        return ISOChronology.getInstance();\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the UTC zone.\n+     * <p>\n+     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n+     * This chronology is the default, and is suitable for all normal datetime processing.\n+     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n+     * as it applies the modern Gregorian calendar rules before that date.\n+     *\n+     * @return the ISO chronology\n+     */\n+    public static Chronology getISOUTC() {\n+        return ISOChronology.getInstanceUTC();\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the specified zone.\n+     * <p>\n+     * {@link ISOChronology} defines all fields in line with the ISO8601 standard.\n+     * This chronology is the default, and is suitable for all normal datetime processing.\n+     * It is <i>unsuitable</i> for historical datetimes before October 15, 1582\n+     * as it applies the modern Gregorian calendar rules before that date.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return the ISO chronology\n+     */\n+    public static Chronology getISO(DateTimeZone zone) {\n+        return ISOChronology.getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the GJChronology in the default zone.\n+     * <p>\n+     * {@link GJChronology} defines all fields using standard meanings.\n+     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n+     * The Gregorian calendar system is used after October 15, 1582, while the\n+     * Julian calendar system is used before.\n+     * <p>\n+     * When dealing solely with dates in the modern era, from 1600 onwards,\n+     * we recommend using ISOChronology, which is the default.\n+     *\n+     * @return the GJ chronology\n+     */\n+    public static Chronology getGJ() {\n+        return GJChronology.getInstance();\n+    }\n+\n+    /**\n+     * Gets an instance of the GJChronology in the UTC zone.\n+     * <p>\n+     * {@link GJChronology} defines all fields using standard meanings.\n+     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n+     * The Gregorian calendar system is used after October 15, 1582, while the\n+     * Julian calendar system is used before.\n+     * <p>\n+     * When dealing solely with dates in the modern era, from 1600 onwards,\n+     * we recommend using ISOChronology, which is the default.\n+     *\n+     * @return the GJ chronology\n+     */\n+    public static Chronology getGJUTC() {\n+        return GJChronology.getInstanceUTC();\n+    }\n+\n+    /**\n+     * Gets an instance of the GJChronology in the specified zone.\n+     * <p>\n+     * {@link GJChronology} defines all fields using standard meanings.\n+     * This chronology is intended to be used as a replacement for <code>GregorianCalendar</code>.\n+     * The Gregorian calendar system is used after October 15, 1582, while the\n+     * Julian calendar system is used before.\n+     * <p>\n+     * When dealing solely with dates in the modern era, from 1600 onwards,\n+     * we recommend using ISOChronology, which is the default.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return the GJ chronology\n+     */\n+    public static Chronology getGJ(DateTimeZone zone) {\n+        return GJChronology.getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the DateTimeZone that this Chronology operates in, or null if\n      * unspecified.\n      *\n      * @return DateTimeZone null if unspecified\n      */\n-    DateTimeZone getZone();\n+    public abstract DateTimeZone getZone();\n \n     /**\n      * Returns an instance of this Chronology that operates in the UTC time\n      *\n      * @return a version of this chronology that ignores time zones\n      */\n-    Chronology withUTC();\n+    public abstract Chronology withUTC();\n     \n     /**\n      * Returns an instance of this Chronology that operates in any time zone.\n      * @param zone to use, or default if null\n      * @see org.joda.time.chrono.ZonedChronology\n      */\n-    Chronology withZone(DateTimeZone zone);\n+    public abstract Chronology withZone(DateTimeZone zone);\n \n     /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * @param millisOfDay millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n         throws IllegalArgumentException;\n \n     /**\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                            int hourOfDay, int minuteOfHour,\n                            int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException;\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n      */\n-    long getDateTimeMillis(long instant,\n+    public abstract long getDateTimeMillis(long instant,\n                            int hourOfDay, int minuteOfHour,\n                            int secondOfMinute, int millisOfSecond)\n         throws IllegalArgumentException;\n      * @param values  the values to validate, not null, match fields in partial\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    void validate(ReadablePartial instant, int[] values);\n+    public abstract void validate(ReadablePartial instant, int[] values);\n \n     // Millis\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField millis();\n+    public abstract DurationField millis();\n \n     /**\n      * Get the millis of second field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField millisOfSecond();\n+    public abstract DateTimeField millisOfSecond();\n \n     /**\n      * Get the millis of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField millisOfDay();\n+    public abstract DateTimeField millisOfDay();\n \n     // Second\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField seconds();\n+    public abstract DurationField seconds();\n \n     /**\n      * Get the second of minute field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField secondOfMinute();\n+    public abstract DateTimeField secondOfMinute();\n \n     /**\n      * Get the second of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField secondOfDay();\n+    public abstract DateTimeField secondOfDay();\n \n     // Minute\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField minutes();\n+    public abstract DurationField minutes();\n \n     /**\n      * Get the minute of hour field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField minuteOfHour();\n+    public abstract DateTimeField minuteOfHour();\n \n     /**\n      * Get the minute of day field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField minuteOfDay();\n+    public abstract DateTimeField minuteOfDay();\n \n     // Hour\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField hours();\n+    public abstract DurationField hours();\n \n     /**\n      * Get the hour of day (0-23) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField hourOfDay();\n+    public abstract DateTimeField hourOfDay();\n \n     /**\n      * Get the hour of day (offset to 1-24) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField clockhourOfDay();\n+    public abstract DateTimeField clockhourOfDay();\n \n     /**\n      * Get the hour of am/pm (0-11) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField hourOfHalfday();\n+    public abstract DateTimeField hourOfHalfday();\n \n     /**\n      * Get the hour of am/pm (offset to 1-12) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField clockhourOfHalfday();\n+    public abstract DateTimeField clockhourOfHalfday();\n \n     /**\n      * Get the AM(0) PM(1) field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField halfdayOfDay();\n+    public abstract DateTimeField halfdayOfDay();\n \n     // Day\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField days();\n+    public abstract DurationField days();\n \n     /**\n      * Get the day of week field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField dayOfWeek();\n+    public abstract DateTimeField dayOfWeek();\n \n     /**\n      * Get the day of month field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField dayOfMonth();\n+    public abstract DateTimeField dayOfMonth();\n \n     /**\n      * Get the day of year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField dayOfYear();\n+    public abstract DateTimeField dayOfYear();\n \n     // Week\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField weeks();\n+    public abstract DurationField weeks();\n \n     /**\n      * Get the week of a week based year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField weekOfWeekyear();\n+    public abstract DateTimeField weekOfWeekyear();\n \n     /**\n      * Get the weekyears duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField weekyears();\n+    public abstract DurationField weekyears();\n \n     /**\n      * Get the year of a week based year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField weekyear();\n+    public abstract DateTimeField weekyear();\n \n     // Month\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField months();\n+    public abstract DurationField months();\n \n     /**\n      * Get the month of year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField monthOfYear();\n+    public abstract DateTimeField monthOfYear();\n \n     // Year\n     //-----------------------------------------------------------------------\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField years();\n+    public abstract DurationField years();\n \n     /**\n      * Get the year field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField year();\n+    public abstract DateTimeField year();\n \n     /**\n      * Get the year of era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField yearOfEra();\n+    public abstract DateTimeField yearOfEra();\n \n     /**\n      * Get the year of century field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField yearOfCentury();\n+    public abstract DateTimeField yearOfCentury();\n \n     /**\n      * Get the centuries duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField centuries();\n+    public abstract DurationField centuries();\n \n     /**\n      * Get the century of era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField centuryOfEra();\n+    public abstract DateTimeField centuryOfEra();\n \n     /**\n      * Get the eras duration field for this chronology.\n      * \n      * @return DurationField or UnsupportedDurationField if unsupported\n      */\n-    DurationField eras();\n+    public abstract DurationField eras();\n \n     /**\n      * Get the era field for this chronology.\n      * \n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n-    DateTimeField era();\n+    public abstract DateTimeField era();\n \n     /**\n      * Gets a debugging toString.\n      * \n      * @return a debugging string\n      */\n-    String toString();\n+    public abstract String toString();\n \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public abstract class AssembledChronology extends AbstractChronology {\n+public abstract class AssembledChronology extends BaseChronology {\n \n     private static final long serialVersionUID = -6728465968995518215L;\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.UnsupportedDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * AbstractChronology provides a skeleton implementation for chronology\n+ * classes. Many utility methods are defined, but all fields are unsupported.\n+ * <p>\n+ * AbstractChronology is thread-safe and immutable, and all subclasses must be\n+ * as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class BaseChronology\n+        extends Chronology\n+        implements Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -7310865996721419676L;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected BaseChronology() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone that this Chronology operates in, or null if\n+     * unspecified.\n+     *\n+     * @return DateTimeZone null if unspecified\n+     */\n+    public abstract DateTimeZone getZone();\n+\n+    /**\n+     * Returns an instance of this Chronology that operates in the UTC time\n+     * zone. Chronologies that do not operate in a time zone or are already\n+     * UTC must return themself.\n+     *\n+     * @return a version of this chronology that ignores time zones\n+     */\n+    public abstract Chronology withUTC();\n+    \n+    /**\n+     * Returns an instance of this Chronology that operates in any time zone.\n+     *\n+     * @return a version of this chronology with a specific time zone\n+     * @param zone to use, or default if null\n+     * @see org.joda.time.chrono.ZonedChronology\n+     */\n+    public abstract Chronology withZone(DateTimeZone zone);\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, and millisecond values. The set of given values must refer\n+     * to a valid datetime, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param millisOfDay millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, from from the given instant,\n+     * hour, minute, second, and millisecond values. The set of given values\n+     * must refer to a valid datetime, or else an IllegalArgumentException is\n+     * thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param instant instant to start from\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Validates whether the fields stored in a partial instant are valid.\n+     * <p>\n+     * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}\n+     * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.\n+     *\n+     * @param instant  the partial instant to validate\n+     * @param values  the values to validate, not null\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public void validate(ReadablePartial instant, int[] values) {\n+        DateTimeField[] fields = instant.getFields();\n+        // check values in standard range, catching really stupid cases like -1\n+        // this means that the second check will not hit trouble\n+        for (int i = 0; i < fields.length; i++) {\n+            if (values[i] < fields[i].getMinimumValue()) {\n+                throw new IllegalArgumentException(\"Value \" + values[i] +\n+                        \" for \" + fields[i].getName() + \" is less than minimum\");\n+            }\n+            if (values[i] > fields[i].getMaximumValue()) {\n+                throw new IllegalArgumentException(\"Value \" + values[i] +\n+                        \" for \" + fields[i].getName() + \" is greater than maximum\");\n+            }\n+        }\n+        // check values in specific range, catching really cases like 30th Feb\n+        for (int i = 0; i < fields.length; i++) {\n+            if (values[i] < fields[i].getMinimumValue(instant, values)) {\n+                throw new IllegalArgumentException(\"Value \" + values[i] +\n+                        \" for \" + fields[i].getName() + \" is less than minimum\");\n+            }\n+            if (values[i] > fields[i].getMaximumValue(instant, values)) {\n+                throw new IllegalArgumentException(\"Value \" + values[i] +\n+                        \" for \" + fields[i].getName() + \" is greater than maximum\");\n+            }\n+        }\n+    }\n+\n+    // Millis\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.getInstance(\"millis\");\n+    }\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return UnsupportedDateTimeField.getInstance(\"millisOfSecond\", millis());\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"millisOfDay\", millis());\n+    }\n+\n+    // Second\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.getInstance(\"seconds\");\n+    }\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return UnsupportedDateTimeField.getInstance(\"secondOfMinute\", seconds());\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"secondOfDay\", seconds());\n+    }\n+\n+    // Minute\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.getInstance(\"minutes\");\n+    }\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"minuteOfDay\", minutes());\n+    }\n+\n+    // Hour\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.getInstance(\"hours\");\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"hourOfDay\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfDay\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(\"hourOfHalfday\", hours());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(\"clockhourOfHalfday\", hours());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return UnsupportedDateTimeField.getInstance\n+            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n+    }\n+\n+    // Day\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.getInstance(\"days\");\n+    }\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * <p>DayOfWeek values are defined in\n+     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.\n+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfWeek\", days());\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfMonth\", days());\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfYear() {\n+        return UnsupportedDateTimeField.getInstance(\"dayOfYear\", days());\n+    }\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.getInstance(\"weeks\");\n+    }\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return UnsupportedDateTimeField.getInstance(\"weekOfWeekyear\", weeks());\n+    }\n+\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weekyears() {\n+        return UnsupportedDurationField.getInstance(\"weekyears\");\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekyear() {\n+        return UnsupportedDateTimeField.getInstance(\"weekyear\", weekyears());\n+    }\n+\n+    // Month\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.getInstance(\"months\");\n+    }\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField monthOfYear() {\n+        return UnsupportedDateTimeField.getInstance(\"monthOfYear\", months());\n+    }\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.getInstance(\"years\");\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField year() {\n+        return UnsupportedDateTimeField.getInstance(\"year\", years());\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfEra() {\n+        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n+    }\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfCentury() {\n+        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n+    }\n+\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField centuries() {\n+        return UnsupportedDurationField.getInstance(\"centuries\");\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField centuryOfEra() {\n+        return UnsupportedDateTimeField.getInstance(\"centuryOfEra\", centuries());\n+    }\n+\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField eras() {\n+        return UnsupportedDurationField.getInstance(\"eras\");\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField era() {\n+        return UnsupportedDateTimeField.getInstance(\"era\", eras());\n+    }\n+\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public abstract String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.NonZeroDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.field.PreciseDurationField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * AbstractGJChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.0\n+ */\n+public abstract class BaseGJChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 8283225332206808863L;\n+\n+    static final long MILLIS_1970_TO_2000 = 946684800000L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+\n+    private static final DurationField cMillisField;\n+    private static final DurationField cSecondsField;\n+    private static final DurationField cMinutesField;\n+    private static final DurationField cHoursField;\n+    private static final DurationField cHalfdaysField;\n+    private static final DurationField cDaysField;\n+    private static final DurationField cWeeksField;\n+\n+    private static final DateTimeField cMillisOfSecondField;\n+    private static final DateTimeField cMillisOfDayField;\n+    private static final DateTimeField cSecondOfMinuteField;\n+    private static final DateTimeField cSecondOfDayField;\n+    private static final DateTimeField cMinuteOfHourField;\n+    private static final DateTimeField cMinuteOfDayField;\n+    private static final DateTimeField cHourOfDayField;\n+    private static final DateTimeField cHourOfHalfdayField;\n+    private static final DateTimeField cClockhourOfDayField;\n+    private static final DateTimeField cClockhourOfHalfdayField;\n+    private static final DateTimeField cHalfdayOfDayField;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i=0; i<12; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+        }\n+\n+        cMillisField = MillisDurationField.INSTANCE;\n+        cSecondsField = new PreciseDurationField\n+            (\"seconds\", DateTimeConstants.MILLIS_PER_SECOND);\n+        cMinutesField = new PreciseDurationField\n+            (\"minutes\", DateTimeConstants.MILLIS_PER_MINUTE);\n+        cHoursField = new PreciseDurationField\n+            (\"hours\", DateTimeConstants.MILLIS_PER_HOUR);\n+        cHalfdaysField = new PreciseDurationField\n+            (\"halfdays\", DateTimeConstants.MILLIS_PER_DAY / 2);\n+        cDaysField = new PreciseDurationField\n+            (\"days\", DateTimeConstants.MILLIS_PER_DAY);\n+        cWeeksField = new PreciseDurationField\n+            (\"weeks\", DateTimeConstants.MILLIS_PER_WEEK);\n+\n+        cMillisOfSecondField = new PreciseDateTimeField\n+            (\"millisOfSecond\", cMillisField, cSecondsField);\n+\n+        cMillisOfDayField = new PreciseDateTimeField\n+            (\"millisOfDay\", cMillisField, cDaysField);\n+             \n+        cSecondOfMinuteField = new PreciseDateTimeField\n+            (\"secondOfMinute\", cSecondsField, cMinutesField);\n+\n+        cSecondOfDayField = new PreciseDateTimeField\n+            (\"secondOfDay\", cSecondsField, cDaysField);\n+\n+        cMinuteOfHourField = new PreciseDateTimeField\n+            (\"minuteOfHour\", cMinutesField, cHoursField);\n+\n+        cMinuteOfDayField = new PreciseDateTimeField\n+            (\"minuteOfDay\", cMinutesField, cDaysField);\n+\n+        cHourOfDayField = new PreciseDateTimeField\n+            (\"hourOfDay\", cHoursField, cDaysField);\n+\n+        cHourOfHalfdayField = new PreciseDateTimeField\n+            (\"hourOfHalfday\", cHoursField, cHalfdaysField);\n+\n+        cClockhourOfDayField = new NonZeroDateTimeField\n+            (cHourOfDayField, \"clockhourOfDay\");\n+\n+        cClockhourOfHalfdayField = new NonZeroDateTimeField\n+            (cHourOfHalfdayField, \"clockhourOfHalfday\");\n+\n+        cHalfdayOfDayField = new HalfdayField();\n+    }\n+\n+    private transient YearInfo[] iYearInfoCache;\n+    private transient int iYearInfoCacheMask;\n+\n+    private final int iMinDaysInFirstWeek;\n+\n+    BaseGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param);\n+\n+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n+            throw new IllegalArgumentException\n+                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+        }\n+\n+        iMinDaysInFirstWeek = minDaysInFirstWeek;\n+\n+        Integer i;\n+        try {\n+            i = Integer.getInteger(getClass().getName().concat(\".yearInfoCacheSize\"));\n+        } catch (SecurityException e) {\n+            i = null;\n+        }\n+\n+        int cacheSize;\n+        if (i == null) {\n+            cacheSize = 1024; // (1 << 10)\n+        } else {\n+            cacheSize = i.intValue();\n+            // Ensure cache size is even power of 2.\n+            cacheSize--;\n+            int shift = 0;\n+            while (cacheSize > 0) {\n+                shift++;\n+                cacheSize >>= 1;\n+            }\n+            cacheSize = 1 << shift;\n+        }\n+\n+        iYearInfoCache = new YearInfo[cacheSize];\n+        iYearInfoCacheMask = cacheSize - 1;\n+    }\n+\n+    public DateTimeZone getZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+\n+        FieldUtils.verifyValueBounds(\"millisOfDay\", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n+    }\n+\n+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                        int hourOfDay, int minuteOfHour,\n+                                        int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        FieldUtils.verifyValueBounds(\"hourOfDay\", hourOfDay, 0, 23);\n+        FieldUtils.verifyValueBounds(\"minuteOfHour\", minuteOfHour, 0, 59);\n+        FieldUtils.verifyValueBounds(\"secondOfMinute\", secondOfMinute, 0, 59);\n+        FieldUtils.verifyValueBounds(\"millisOfSecond\", millisOfSecond, 0, 999);\n+\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iMinDaysInFirstWeek;\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        String name = getClass().getName();\n+        int index = name.lastIndexOf('.');\n+        if (index >= 0) {\n+            name = name.substring(index + 1);\n+        }\n+        sb.append(name);\n+        sb.append('[');\n+        DateTimeZone zone = getZone();\n+        if (zone != null) {\n+            sb.append(zone.getID());\n+            sb.append(\", \");\n+        }\n+        sb.append(\"mdfw=\");\n+        sb.append(getMinimumDaysInFirstWeek());\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // First copy fields that are the same for all Gregorian and Julian\n+        // chronologies.\n+\n+        fields.millis = cMillisField;\n+        fields.seconds = cSecondsField;\n+        fields.minutes = cMinutesField;\n+        fields.hours = cHoursField;\n+        //fields.halfdays = cHalfdaysField;  Doesn't exist in public interface\n+        fields.days = cDaysField;\n+        fields.weeks = cWeeksField;\n+\n+        fields.millisOfSecond = cMillisOfSecondField;\n+        fields.millisOfDay = cMillisOfDayField;\n+        fields.secondOfMinute = cSecondOfMinuteField;\n+        fields.secondOfDay = cSecondOfDayField;\n+        fields.minuteOfHour = cMinuteOfHourField;\n+        fields.minuteOfDay = cMinuteOfDayField;\n+        fields.hourOfDay = cHourOfDayField;\n+        fields.hourOfHalfday = cHourOfHalfdayField;\n+        fields.clockhourOfDay = cClockhourOfDayField;\n+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n+        fields.halfdayOfDay = cHalfdayOfDayField;\n+\n+        // Now create fields that have unique behavior for Gregorian and Julian\n+        // chronologies.\n+\n+        fields.year = new GJYearDateTimeField(this);\n+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n+\n+        // Define one-based centuryOfEra and yearOfCentury.\n+        DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, \"\", 99);\n+        fields.centuryOfEra = new DividedDateTimeField\n+            (field, \"centuryOfEra\", \"centuries\", 100);\n+        \n+        field = new RemainderDateTimeField\n+            ((DividedDateTimeField)fields.centuryOfEra, \"\");\n+        fields.yearOfCentury = new OffsetDateTimeField(field, \"yearOfCentury\", 1);\n+\n+        fields.era = new GJEraDateTimeField(this);\n+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n+        fields.dayOfMonth = new GJDayOfMonthDateTimeField(this, fields.days);\n+        fields.dayOfYear = new GJDayOfYearDateTimeField(this, fields.days);\n+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n+        fields.weekyear = new GJWeekyearDateTimeField(this);\n+        fields.weekOfWeekyear = new GJWeekOfWeekyearDateTimeField(this, fields.weeks);\n+\n+        // The remaining (imprecise) durations are available from the newly\n+        // created datetime fields.\n+\n+        fields.years = fields.year.getDurationField();\n+        fields.centuries = fields.centuryOfEra.getDurationField();\n+        fields.months = fields.monthOfYear.getDurationField();\n+        fields.weekyears = fields.weekyear.getDurationField();\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     * @param year The year to use.\n+     * @return 366 if a leap year, otherwise 365.\n+     */\n+    final int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 366 : 365;\n+    }\n+\n+    final int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Gets the maximum days in the specified month.\n+     * \n+     * @param month  the month\n+     * @return the max days\n+     */\n+    final int getDaysInMonthMax(int month) {\n+        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+    }\n+\n+    /**\n+     * Returns the total number of milliseconds elapsed in the year, by the end\n+     * of the month.\n+     */\n+    final long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Get the number of weeks in the year.\n+     * @param year  the year to use.\n+     * @return number of weeks in the year.\n+     */\n+    final int getWeeksInYear(int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Get the millis for the first week of a year.\n+     * @param year  the year to use.\n+     * @return millis\n+     */\n+    final long getFirstWeekOfYearMillis(int year) {\n+        long jan1millis = getYearMillis(year);\n+        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n+        \n+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n+            // First week is end of previous year because it doesn't have enough days.\n+            return jan1millis + (8 - jan1dayOfWeek)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            // First week is start of this year because it has enough days.\n+            return jan1millis - (jan1dayOfWeek - 1)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a year.\n+     *\n+     * @param year The year to use.\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMillis(int year) {\n+        return getYearInfo(year).iFirstDayMillis;\n+        //return calculateFirstDayOfYearMillis(year);\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a month.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMonthMillis(int year, int month) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return millis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for a particular date.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @param dayOfMonth The day of the month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        // day\n+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+    \n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getYear(long instant) {\n+        // Get an initial estimate of the year, and the millis value that\n+        // represents the start of that year. Then verify estimate and fix if\n+        // necessary.\n+\n+        long unitMillis = getAverageMillisPerYear();\n+        long i2 = instant + getApproxMillisAtEpoch();\n+        if (i2 < 0) {\n+            i2 = i2 - unitMillis + 1;\n+        }\n+        int year = (int) (i2 / unitMillis);\n+\n+        long yearStart = getYearMillis(year);\n+        long diff = instant - yearStart;\n+\n+        if (diff < 0) {\n+            if (diff < -DateTimeConstants.MILLIS_PER_DAY * 2L) {\n+                // Too much error, assume operation overflowed.\n+                return getYearOverflow(instant);\n+            }\n+            year--;\n+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n+            if (diff >= DateTimeConstants.MILLIS_PER_DAY * 367L) {\n+                // Too much error, assume operation overflowed.\n+                return getYearOverflow(instant);\n+            }\n+            // One year may need to be added to fix estimate.\n+            long oneYear;\n+            if (isLeapYear(year)) {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+\n+            yearStart += oneYear;\n+\n+            if ((yearStart ^ instant) < 0) {\n+                // Sign mismatch, operation may have overflowed.\n+                if ((yearStart <  0 && (yearStart - oneYear) >= 0) ||\n+                    (yearStart >= 0 && (yearStart - oneYear) <  0)   ) {\n+                    // It overflowed.\n+                    return getYearOverflow(instant);\n+                }\n+            }\n+\n+            if (yearStart <= instant) {\n+                // Didn't go too far, so actually add one year.\n+                year++;\n+            }\n+        }\n+\n+        return year;\n+    }\n+\n+    private final int getYearOverflow(long instant) {\n+        if (instant > 0) {\n+            int year = getMaxYear();\n+            long yearStartMillis = getYearMillis(year);\n+            if (isLeapYear(year)) {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+            long yearEndMillis = yearStartMillis - 1;\n+\n+            if (instant <= yearEndMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too large: \" + instant + \" > \" + yearEndMillis);\n+        } else {\n+            int year = getMinYear();\n+            long yearStartMillis = getYearMillis(year);\n+            if (instant >= yearStartMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too small: \" + instant + \" < \" + yearStartMillis);\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final long setYear(long instant, int year) {\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeapYear(thisYear)) {\n+                // Current date is Feb 29 or later.\n+                if (!isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Current date is Mar 01 or later.\n+                if (isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getMonthOfYear(long millis) {\n+        return getMonthOfYear(millis, getYear(millis));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfMonth(long millis) {\n+        int year = getYear(millis);\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getDayOfMonth(long millis, int year) {\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     * @param month precalculated month of millis\n+     */\n+    final int getDayOfMonth(long millis, int year, int month) {\n+        long dateMillis = getYearMillis(year);\n+        if (month > 1) {\n+            dateMillis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfYear(long instant) {\n+        return getDayOfYear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getDayOfYear(long instant, int year) {\n+        long yearStart = getYearMillis(year);\n+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getWeekyear(long instant) {\n+        int year = getYear(instant);\n+        int week = getWeekOfWeekyear(instant, year);\n+        if (week == 1) {\n+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n+        } else if (week > 51) {\n+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+        } else {\n+            return year;\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getWeekOfWeekyear(long instant) {\n+        return getWeekOfWeekyear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    final int getWeekOfWeekyear(long instant, int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        if (instant < firstWeekMillis1) {\n+            return getWeeksInYear(year - 1);\n+        }\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        if (instant >= firstWeekMillis2) {\n+            return 1;\n+        }\n+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getDayOfWeek(long instant) {\n+        // 1970-01-01 is day of week 4, Thursday.\n+\n+        long daysSince19700101;\n+        if (instant >= 0) {\n+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+                / DateTimeConstants.MILLIS_PER_DAY;\n+            if (daysSince19700101 < -3) {\n+                return 7 + (int) ((daysSince19700101 + 4) % 7);\n+            }\n+        }\n+\n+        return 1 + (int) ((daysSince19700101 + 3) % 7);\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    final int getMillisOfDay(long instant) {\n+        if (instant >= 0) {\n+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n+        } else {\n+            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n+        }\n+    }\n+\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        FieldUtils.verifyValueBounds(\"year\", year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(\"monthOfYear\", monthOfYear, 1, 12);\n+\n+        boolean isLeap = isLeapYear(year);\n+\n+        FieldUtils.verifyValueBounds(\"dayOfMonth\", dayOfMonth, 1,\n+                                     (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n+                                     [monthOfYear - 1]);\n+\n+        long instant = getYearMillis(year);\n+\n+        if (monthOfYear > 1) {\n+            instant += \n+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n+                [monthOfYear - 2];\n+        }\n+\n+        if (dayOfMonth != 1) {\n+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+\n+        return instant;\n+    }\n+\n+    abstract boolean isLeapYear(int year);\n+\n+    abstract long calculateFirstDayOfYearMillis(int year);\n+\n+    abstract int getMinYear();\n+\n+    abstract int getMaxYear();\n+\n+    abstract long getAverageMillisPerYear();\n+\n+    abstract long getAverageMillisPerMonth();\n+\n+    /**\n+     * Returns a constant representing the approximate number of milliseconds\n+     * elapsed from year 0 of this chronology. This constant <em>must</em> be\n+     * defined as:\n+     * <pre>\n+     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch\n+     * <pre>\n+     * where epoch is 1970-01-01 (Gregorian).\n+     */\n+    abstract long getApproxMillisAtEpoch();\n+\n+    // Although accessed by multiple threads, this method doesn't need to be synchronized.\n+    private YearInfo getYearInfo(int year) {\n+        YearInfo[] cache = iYearInfoCache;\n+        int index = year & iYearInfoCacheMask;\n+        YearInfo info = cache[index];\n+        if (info == null || info.iYear != year) {\n+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n+            cache[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    private static class HalfdayField extends PreciseDateTimeField {\n+        private static final long serialVersionUID = 581601443656929254L;\n+\n+        HalfdayField() {\n+            super(\"halfdayOfDay\", cHalfdaysField, cDaysField);\n+        }\n+\n+        protected String getAsText(int fieldValue, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();\n+        }\n+    }\n+\n+    private static class YearInfo {\n+        public final int iYear;\n+        public final long iFirstDayMillis;\n+\n+        YearInfo(int year, long firstDayMillis) {\n+            iYear = year;\n+            iFirstDayMillis = firstDayMillis;\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class CopticChronology extends AbstractGJChronology {\n+public final class CopticChronology extends BaseGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -5972804258688333942L;\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n \n     private static final long serialVersionUID = -5441610762799659434L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    CopticDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+    CopticDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n         super(\"dayOfMonth\", days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java\n \n     private static final long serialVersionUID = 7741038885247700323L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    CopticMonthOfYearDateTimeField(AbstractGJChronology chronology, DurationField months) {\n+    CopticMonthOfYearDateTimeField(BaseGJChronology chronology, DurationField months) {\n         super(\"monthOfYear\", months);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n \n     private static final long serialVersionUID = 8990199361773280783L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    CopticYearDateTimeField(AbstractGJChronology chronology) {\n+    CopticYearDateTimeField(BaseGJChronology chronology) {\n         super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n         FieldUtils.verifyValueBounds\n             (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n \n-\t\tAbstractGJChronology chrono = iChronology;\n+\t\tBaseGJChronology chrono = iChronology;\n \n         int thisYear = chrono.getYear(instant);\n         int dayOfYear = chrono.getDayOfYear(instant, thisYear);\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n \n     private static final long serialVersionUID = -4677223814028011723L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+    GJDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n         super(\"dayOfMonth\", days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n     /** Serialization version */\n     private static final long serialVersionUID = -3857947176719041436L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJDayOfWeekDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+    GJDayOfWeekDateTimeField(BaseGJChronology chronology, DurationField days) {\n         super(\"dayOfWeek\", days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n \n     private static final long serialVersionUID = -6821236822336841037L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJDayOfYearDateTimeField(AbstractGJChronology chronology, DurationField days) {\n+    GJDayOfYearDateTimeField(BaseGJChronology chronology, DurationField days) {\n         super(\"dayOfYear\", days);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n     /** Serialization version */\n     private static final long serialVersionUID = 4240986525305515528L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJEraDateTimeField(AbstractGJChronology chronology) {\n+    GJEraDateTimeField(BaseGJChronology chronology) {\n         super(\"era\");\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n     private static final int MIN = DateTimeConstants.JANUARY;\n     private static final int MAX = DateTimeConstants.DECEMBER;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJMonthOfYearDateTimeField(AbstractGJChronology chronology) {\n+    GJMonthOfYearDateTimeField(BaseGJChronology chronology) {\n         super(\"monthOfYear\", \"months\", chronology.getAverageMillisPerMonth());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n \n     private static final long serialVersionUID = -1587436826395135328L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJWeekOfWeekyearDateTimeField(AbstractGJChronology chronology, DurationField weeks) {\n+    GJWeekOfWeekyearDateTimeField(BaseGJChronology chronology, DurationField weeks) {\n         super(\"weekOfWeekyear\", weeks);\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java\n \n     private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJWeekyearDateTimeField(AbstractGJChronology chronology) {\n+    GJWeekyearDateTimeField(BaseGJChronology chronology) {\n         super(\"weekyear\", \"weekyears\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n \n     private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n-    GJYearDateTimeField(AbstractGJChronology chronology) {\n+    GJYearDateTimeField(BaseGJChronology chronology) {\n         super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n \n     private static final long serialVersionUID = -5961050944769862059L;\n \n-    private final AbstractGJChronology iChronology;\n+    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor.\n      */\n-    GJYearOfEraDateTimeField(DateTimeField yearField, AbstractGJChronology chronology) {\n+    GJYearOfEraDateTimeField(DateTimeField yearField, BaseGJChronology chronology) {\n         super(yearField, \"yearOfEra\");\n         iChronology = chronology;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class GregorianChronology extends AbstractGJChronology {\n+public final class GregorianChronology extends BaseGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -861407383323710522L;\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class JulianChronology extends AbstractGJChronology {\n+public final class JulianChronology extends BaseGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -8731039522547897247L;\n     static class NoYearZeroField extends DelegatedDateTimeField {\n         private static final long serialVersionUID = -8869148464118507846L;\n \n-        final AbstractGJChronology iChronology;\n+        final BaseGJChronology iChronology;\n         private transient int iMinYear;\n \n-        NoYearZeroField(AbstractGJChronology chronology, DateTimeField field) {\n+        NoYearZeroField(BaseGJChronology chronology, DateTimeField field) {\n             super(field);\n             iChronology = chronology;\n             int min = super.getMinimumValue();\n     static class NoWeekyearZeroField extends NoYearZeroField {\n         private static final long serialVersionUID = -5013429014495501104L;\n \n-        NoWeekyearZeroField(AbstractGJChronology chronology, DateTimeField field) {\n+        NoWeekyearZeroField(BaseGJChronology chronology, DateTimeField field) {\n             super(chronology, field);\n         }\n         \n--- a/JodaTime/src/test/org/joda/time/MockNullZoneChronology.java\n+++ b/JodaTime/src/test/org/joda/time/MockNullZoneChronology.java\n  */\n package org.joda.time;\n \n-import org.joda.time.chrono.AbstractChronology;\n+import org.joda.time.chrono.BaseChronology;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n  * \n  * @author Stephen Colebourne\n  */\n-class MockNullZoneChronology extends AbstractChronology {\n+class MockNullZoneChronology extends BaseChronology {\n \n     public DateTimeZone getZone() {\n         return null;\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        suite.addTest(TestChronology.suite());\n+        \n         suite.addTest(TestInstant_Constructors.suite());\n         suite.addTest(TestInstant_Basics.suite());\n         \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for Chronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestChronology extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestChronology.class);\n+    }\n+\n+    public TestChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetISO() {\n+        assertEquals(ISOChronology.getInstance(), Chronology.getISO());\n+    }\n+\n+    public void testGetISOUTC() {\n+        assertEquals(ISOChronology.getInstanceUTC(), Chronology.getISOUTC());\n+    }\n+\n+    public void testGetISO_Zone() {\n+        assertEquals(ISOChronology.getInstance(PARIS), Chronology.getISO(PARIS));\n+        assertEquals(ISOChronology.getInstance(), Chronology.getISO(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetGJ() {\n+        assertEquals(GJChronology.getInstance(), Chronology.getGJ());\n+    }\n+\n+    public void testGetGJUTC() {\n+        assertEquals(GJChronology.getInstanceUTC(), Chronology.getGJUTC());\n+    }\n+\n+    public void testGetGJ_Zone() {\n+        assertEquals(GJChronology.getInstance(PARIS), Chronology.getGJ(PARIS));\n+        assertEquals(GJChronology.getInstance(), Chronology.getGJ(null));\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n import junit.framework.TestSuite;\n \n import org.joda.time.base.AbstractInstant;\n-import org.joda.time.chrono.AbstractChronology;\n+import org.joda.time.chrono.BaseChronology;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n         }\n     }\n \n-    class MockEqualsChronology extends AbstractChronology {\n+    class MockEqualsChronology extends BaseChronology {\n         public boolean equals(Object obj) {\n             return obj instanceof MockEqualsChronology;\n         }\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java\n import junit.framework.TestSuite;\n \n import org.joda.time.base.AbstractInstant;\n-import org.joda.time.chrono.AbstractChronology;\n+import org.joda.time.chrono.BaseChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n \n         }\n     }\n \n-    class MockEqualsChronology extends AbstractChronology {\n+    class MockEqualsChronology extends BaseChronology {\n         public boolean equals(Object obj) {\n             return obj instanceof MockEqualsChronology;\n         }\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n-import org.joda.time.chrono.AbstractChronology;\n+import org.joda.time.chrono.BaseChronology;\n \n /**\n  * A reference Gregorian/Julian chronology implementation, intended for testing\n  *\n  * @author Brian S O'Neill\n  */\n-abstract class TestGJChronology extends AbstractChronology {\n+abstract class TestGJChronology extends BaseChronology {\n     static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;\n \n     /**\n--- a/JodaTime/src/test/org/joda/time/convert/MockBadChronology.java\n+++ b/JodaTime/src/test/org/joda/time/convert/MockBadChronology.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.chrono.AbstractChronology;\n+import org.joda.time.chrono.BaseChronology;\n \n /**\n  * A basic mock testing class for an unknown calendar.\n  *\n  * @author Stephen Colebourne\n  */\n-class MockBadChronology extends AbstractChronology {\n+class MockBadChronology extends BaseChronology {\n     \n     MockBadChronology() {\n         super();", "timestamp": 1093187730, "metainfo": ""}