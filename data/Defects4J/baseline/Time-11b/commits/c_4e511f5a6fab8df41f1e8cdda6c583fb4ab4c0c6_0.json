{"sha": "4e511f5a6fab8df41f1e8cdda6c583fb4ab4c0c6", "log": "Fix withMaximumValue()/withMinimumValue() to handle DST gap  https://sourceforge.net/p/joda-time/bugs/159/", "commit": "\n--- a/src/main/java/org/joda/time/DateTime.java\n+++ b/src/main/java/org/joda/time/DateTime.java\n /*\n- *  Copyright 2001-2011 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n          * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result\n          * to force the later time during a DST overlap if desired.\n          * <p>\n+         * From v2.2, this method handles a daylight svaings time gap, setting the\n+         * time to the last instant before the gap.\n+         * <p>\n          * The DateTime attached to this property is unchanged by this call.\n          *\n          * @return a copy of the DateTime with this field set to its maximum\n          * @since 1.2\n          */\n         public DateTime withMaximumValue() {\n-            return setCopy(getMaximumValue());\n+            try {\n+                return setCopy(getMaximumValue());\n+            } catch (RuntimeException ex) {\n+                if (IllegalInstantException.isIllegalInstant(ex)) {\n+                    // adding MILLIS_PER_DAY is not perfect, but will work in almost all situations\n+                    long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n+                    return new DateTime(beforeGap, getChronology());\n+                }\n+                throw ex;\n+            }\n         }\n         \n         /**\n          * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result\n          * to force the earlier time during a DST overlap if desired.\n          * <p>\n+         * From v2.2, this method handles a daylight svaings time gap, setting the\n+         * time to the first instant after the gap.\n+         * <p>\n          * The DateTime attached to this property is unchanged by this call.\n          *\n          * @return a copy of the DateTime with this field set to its minimum\n          * @since 1.2\n          */\n         public DateTime withMinimumValue() {\n-            return setCopy(getMinimumValue());\n+            try {\n+                return setCopy(getMinimumValue());\n+            } catch (RuntimeException ex) {\n+                if (IllegalInstantException.isIllegalInstant(ex)) {\n+                    // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations\n+                    long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n+                    return new DateTime(afterGap, getChronology());\n+                }\n+                throw ex;\n+            }\n         }\n         \n         //-----------------------------------------------------------------------\n--- a/src/main/java/org/joda/time/IllegalInstantException.java\n+++ b/src/main/java/org/joda/time/IllegalInstantException.java\n         return \"Illegal instant due to time zone offset transition (daylight savings time 'gap'): \" + localDateTime + zone;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the exception is, or has a cause, of {@code IllegalInstantException}.\n+     * \n+     * @param ex  the exception to check\n+     * @return true if an {@code IllegalInstantException}\n+     */\n+    public static boolean isIllegalInstant(Throwable ex) {\n+        if (ex instanceof IllegalInstantException) {\n+            return true;\n+        }\n+        while (ex.getCause() != null && ex.getCause() != ex) {\n+            return isIllegalInstant(ex.getCause());\n+        }\n+        return false;\n+    }\n+\n }\n--- a/src/test/java/org/joda/time/TestDateTime_Properties.java\n+++ b/src/test/java/org/joda/time/TestDateTime_Properties.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         assertEquals(\"2004-06-30T00:00:00.000+01:00\", copy.toString());\n     }\n \n+    public void testPropertyWithMaximumValueMillisOfDayDSTGap() {\n+        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n+        DateTime dt = new DateTime(1926, 4, 17, 18, 0, 0, 0, paris);  // DST gap 23:00 to 00:00\n+        DateTime test = dt.millisOfDay().withMaximumValue();\n+        assertEquals(\"1926-04-17T22:59:59.999Z\", test.toString());\n+    }\n+\n     public void testPropertyWithMinimumValueDayOfMonth() {\n         DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime copy = test.dayOfMonth().withMinimumValue();\n         assertEquals(\"2004-06-09T00:00:00.000+01:00\", test.toString());\n         assertEquals(\"2004-06-01T00:00:00.000+01:00\", copy.toString());\n+    }\n+\n+    public void testPropertyWithMinimumValueMillisOfDayDSTGap() {\n+        DateTimeZone gaza = DateTimeZone.forID(\"Asia/Gaza\");\n+        DateTime dt = new DateTime(2001, 4, 20, 18, 0, 0, 0, gaza);  // DST gap 00:00 to 01:00\n+        DateTime test = dt.millisOfDay().withMinimumValue();\n+        assertEquals(\"2001-04-20T01:00:00.000+03:00\", test.toString());\n     }\n \n     public void testPropertyCompareToDayOfMonth() {", "timestamp": 1357563879, "metainfo": ""}