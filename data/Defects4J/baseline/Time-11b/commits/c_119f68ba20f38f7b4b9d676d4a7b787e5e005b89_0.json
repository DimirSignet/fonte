{"sha": "119f68ba20f38f7b4b9d676d4a7b787e5e005b89", "log": "Update duration following period changes   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n     }\n \n     /**\n-     * Adds to this duration returning a new Duration instance.\n-     * <p>\n-     * If the addition is zero, this instance is returned.\n-     * \n-     * @param durationToAdd  the duration to add to this one\n-     * @return the new duration instance\n-     */\n-    public Duration withDurationAdded(long durationToAdd) {\n-        return withDurationAdded(durationToAdd, 1);\n-    }\n-\n-    /**\n-     * Adds to this duration returning a new Duration instance.\n+     * Returns a new duration with this length plus that specified multiplied by the scalar.\n+     * This instance is immutable and is not altered.\n      * <p>\n      * If the addition is zero, this instance is returned.\n      * \n     }\n \n     /**\n-     * Adds to this duration returning a new Duration instance.\n-     * <p>\n-     * If the addition is zero, this instance is returned.\n-     * \n-     * @param durationToAdd  the duration to add to this one, null means zero\n-     * @return the new duration instance\n-     */\n-    public Duration withDurationAdded(ReadableDuration durationToAdd) {\n-        if (durationToAdd == null) {\n-            return this;\n-        }\n-        return withDurationAdded(durationToAdd.getMillis(), 1);\n-    }\n-\n-    /**\n-     * Adds to this duration returning a new Duration instance.\n+     * Returns a new duration with this length plus that specified multiplied by the scalar.\n+     * This instance is immutable and is not altered.\n      * <p>\n      * If the addition is zero, this instance is returned.\n      * \n         return withDurationAdded(durationToAdd.getMillis(), scalar);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new duration with this length plus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to add to this one\n+     * @return the new duration instance\n+     */\n+    public Duration plus(long amount) {\n+        return withDurationAdded(amount, 1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length plus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the amount is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to add to this one, null means zero\n+     * @return the new duration instance\n+     */\n+    public Duration plus(ReadableDuration amount) {\n+        if (amount == null) {\n+            return this;\n+        }\n+        return withDurationAdded(amount.getMillis(), 1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length minus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to take away from this one\n+     * @return the new duration instance\n+     */\n+    public Duration minus(long amount) {\n+        return withDurationAdded(amount, -1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length minus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the amount is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to take away from this one, null means zero\n+     * @return the new duration instance\n+     */\n+    public Duration minus(ReadableDuration amount) {\n+        if (amount == null) {\n+            return this;\n+        }\n+        return withDurationAdded(amount.getMillis(), -1);\n+    }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a Period instance using the All type.\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the ISO chronology.\n      * <p>\n-     * Only precise fields in the period type will be used.\n-     * For AllType, this is the time fields only.\n+     * Only precise fields in the period type will be used. Thus, only the hour,\n+     * minute, second and millisecond fields on the period will be used.\n      * The year, month, week and day fields will not be populated.\n-     * The period constructed will always be precise.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly.\n-     * <p>\n      * If the duration is larger than one day then all the remaining duration will\n-     * be stored in the largest available precise field, hours in this case.\n+     * be stored in the largest available field, hours in this case.\n      * <p>\n      * For example, a duration effectively equal to (365 + 60 + 5) days will be\n      * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n      * <p>\n-     * For more control over the conversion process, you have two options:\n-     * <ul>\n-     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n-     * <li>specify a period type that contains precise definitions of the day and larger\n-     * fields, such as the UTC or precise types.\n-     * </ul>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n      * \n      * @return a Period created using the millisecond duration from this instance\n      */\n     Period toPeriod();\n-\n-    /**\n-     * Converts this duration to a Period instance specifying a period type\n-     * to control how the duration is split into fields.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * Imprecise fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is large then all the remaining duration will\n-     * be stored in the largest available precise field.\n-     * For details as to which fields are precise, review the period type javadoc.\n-     * \n-     * @param type  the period type determining how to split the duration into fields\n-     * @return a Period created using the millisecond duration from this instance\n-     */\n-    Period toPeriod(PeriodType type);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n \n import org.joda.time.Duration;\n import org.joda.time.Period;\n-import org.joda.time.PeriodType;\n import org.joda.time.ReadableDuration;\n import org.joda.time.format.FormatUtils;\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this duration to a Period instance using the All type.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * For AllType, this is the time fields only.\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the ISO chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used. Thus, only the hour,\n+     * minute, second and millisecond fields on the period will be used.\n      * The year, month, week and day fields will not be populated.\n-     * The period constructed will always be precise.\n      * <p>\n      * If the duration is small, less than one day, then this method will perform\n      * as you might expect and split the fields evenly.\n-     * <p>\n      * If the duration is larger than one day then all the remaining duration will\n-     * be stored in the largest available precise field, hours in this case.\n+     * be stored in the largest available field, hours in this case.\n      * <p>\n      * For example, a duration effectively equal to (365 + 60 + 5) days will be\n      * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n      * <p>\n-     * For more control over the conversion process, you have two options:\n-     * <ul>\n-     * <li>convert the duration to an {@link org.joda.time.Interval}, and from\n-     * there obtain the period\n-     * <li>specify a period type that contains precise definitions of the day\n-     * and larger fields, such as the UTC or precise types.\n-     * </ul>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n      * \n      * @return a Period created using the millisecond duration from this instance\n      */\n     public Period toPeriod() {\n         return new Period(getMillis());\n-    }\n-\n-    /**\n-     * Converts this duration to a Period instance specifying a period type\n-     * to control how the duration is split into fields.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * Imprecise fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is large then all the remaining duration will\n-     * be stored in the largest available precise field.\n-     * For details as to which fields are precise, review the period type javadoc.\n-     * \n-     * @param type  the period type determining how to split the duration into fields, null means All type\n-     * @return a Period created using the millisecond duration from this instance\n-     */\n-    public Period toPeriod(PeriodType type) {\n-        return new Period(getMillis(), type);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/BaseDuration.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseDuration.java\n \n import java.io.Serializable;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n+import org.joda.time.Interval;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n import org.joda.time.ReadableDuration;\n import org.joda.time.ReadableInstant;\n import org.joda.time.convert.ConverterManager;\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class BaseDuration\n+public abstract class BaseDuration\n         extends AbstractDuration\n         implements ReadableDuration, Serializable {\n \n      *\n      * @param duration  the duration, in milliseconds\n      */\n-    public BaseDuration(long duration) {\n+    protected BaseDuration(long duration) {\n         super();\n         iMillis = duration;\n     }\n      * @param endInstant  interval end, in milliseconds\n      * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n-    public BaseDuration(long startInstant, long endInstant) {\n+    protected BaseDuration(long startInstant, long endInstant) {\n         super();\n         iMillis = FieldUtils.safeAdd(endInstant, -startInstant);\n     }\n      * @param end  interval end, null means now\n      * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n-    public BaseDuration(ReadableInstant start, ReadableInstant end) {\n+    protected BaseDuration(ReadableInstant start, ReadableInstant end) {\n         super();\n         if (start == end) {\n             iMillis = 0L;\n      * @param duration  duration to convert\n      * @throws IllegalArgumentException if duration is invalid\n      */\n-    public BaseDuration(Object duration) {\n+    protected BaseDuration(Object duration) {\n         super();\n         DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n         iMillis = converter.getDurationMillis(duration);\n         iMillis = duration;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a Period instance using the specified period type\n+     * and the ISO chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * At most these are hours, minutes, seconds and millis - the period\n+     * type may restrict the selection further.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)}.\n+     * \n+     * @param type  the period type to use, null means standard\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(PeriodType type) {\n+        return new Period(getMillis(), type);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the specified chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Exactly which fields are precise depends on the chronology.\n+     * Only the time fields are precise for ISO chronology with a time zone.\n+     * However, ISO UTC also has precise days and weeks.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant)}.\n+     * \n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(Chronology chrono) {\n+        return new Period(getMillis(), chrono);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance using the specified period type\n+     * and chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Exactly which fields are precise depends on the chronology.\n+     * Only the time fields are precise for ISO chronology with a time zone.\n+     * However, ISO UTC also has precise days and weeks.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)}.\n+     * \n+     * @param type  the period type to use, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(PeriodType type, Chronology chrono) {\n+        return new Period(getMillis(), type, chrono);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by adding the duration to a start\n+     * instant to obtain an interval using the standard period type.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the standard period type and the length of this duration.\n+     * \n+     * @param startInstant  the instant to calculate the period from, null means now\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodFrom(ReadableInstant startInstant) {\n+        return new Period(startInstant, this);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by adding the duration to a start\n+     * instant to obtain an interval.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the period type and the length of this duration.\n+     * \n+     * @param startInstant  the instant to calculate the period from, null means now\n+     * @param type  the period type determining how to split the duration into fields, null means All type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) {\n+        return new Period(startInstant, this, type);\n+    }\n+\n+    /**\n+     * Converts this duration to an Interval starting at the specified instant.\n+     * \n+     * @param startInstant  the instant to start the instant from, null means now\n+     * @return an Interval starting at the specified instant\n+     */\n+    public Interval toIntervalFrom(ReadableInstant startInstant) {\n+        return new Interval(startInstant, this);\n+    }\n+\n }\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n     }\n     \n     //-----------------------------------------------------------------------\n-    public void testToPeriod1() {\n+    public void testToPeriod() {\n         long length =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         Duration test = new Duration(length);\n         Period result = test.toPeriod();\n-        assertEquals(PeriodType.standard(), result.getPeriodType());\n-        // only time fields are precise in AllType\n-        assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n-        assertEquals(0, result.getMonths());\n-        assertEquals(0, result.getWeeks());\n-        assertEquals(0, result.getDays());\n-        assertEquals((450 * 24) + 5, result.getHours());\n-        assertEquals(6, result.getMinutes());\n-        assertEquals(7, result.getSeconds());\n-        assertEquals(8, result.getMillis());\n-    }\n-\n-    public void testToPeriod_PeriodType1() {\n-        long length =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        Duration test = new Duration(length);\n-        Period result = test.toPeriod(null);\n-        assertEquals(PeriodType.standard(), result.getPeriodType());\n-        // only time fields are precise in AllType\n-        assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n-        assertEquals(0, result.getMonths());\n-        assertEquals(0, result.getWeeks());\n-        assertEquals(0, result.getDays());\n-        assertEquals((450 * 24) + 5, result.getHours());\n-        assertEquals(6, result.getMinutes());\n-        assertEquals(7, result.getSeconds());\n-        assertEquals(8, result.getMillis());\n-    }\n-\n-//    public void testToPeriod_PeriodType2() {\n-//        long length =\n-//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-//        Duration test = new Duration(length);\n-//        Period result = test.toPeriod(PeriodType.getPreciseAllType());\n-//        assertEquals(PeriodType.getPreciseAllType(), result.getPeriodType());\n-//        // only time fields are precise in AllType\n-//        assertEquals(1, result.getYears());\n-//        assertEquals(2, result.getMonths());\n-//        assertEquals(3, result.getWeeks());\n-//        assertEquals(4, result.getDays());\n-//        assertEquals(5, result.getHours());\n-//        assertEquals(6, result.getMinutes());\n-//        assertEquals(7, result.getSeconds());\n-//        assertEquals(8, result.getMillis());\n-//        assertEquals(true, result.isPrecise());\n-//        assertEquals(length, result.toDurationMillis());\n-//    }\n+        assertEquals(new Period(test), result);\n+        assertEquals(new Period(test.getMillis()), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriod_PeriodType() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved());\n+        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved()), result);\n+        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved()), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriod_Chronology() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        Period result = test.toPeriod(Chronology.getISOUTC());\n+        assertEquals(new Period(test, Chronology.getISOUTC()), result);\n+        assertEquals(new Period(test.getMillis(), Chronology.getISOUTC()), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriod_PeriodType_Chronology() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC());\n+        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC()), result);\n+        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC()), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriodFrom() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        Period result = test.toPeriodFrom(dt);\n+        assertEquals(new Period(dt, test), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriodFrom_PeriodType() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        Period result = test.toPeriodFrom(dt, PeriodType.standard().withMillisRemoved());\n+        assertEquals(new Period(dt, test, PeriodType.standard().withMillisRemoved()), result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToIntervalFrom() {\n+        long length =\n+            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+        Duration test = new Duration(length);\n+        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        Interval result = test.toIntervalFrom(dt);\n+        assertEquals(new Interval(dt, test), result);\n+    }\n \n     //-----------------------------------------------------------------------\n     public void testWithMillis1() {\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testWithDurationAdded_long1() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationAdded(8000L);\n-        assertEquals(8123L, result.getMillis());\n-    }\n-\n-    public void testWithDurationAdded_long2() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationAdded(0L);\n-        assertSame(test, result);\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testWithDurationAdded_long_int1() {\n         Duration test = new Duration(123L);\n         Duration result = test.withDurationAdded(8000L, 1);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testWithDurationAdded_RD1() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationAdded(new Duration(8000L));\n+    public void testPlus_long1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.plus(8000L);\n         assertEquals(8123L, result.getMillis());\n     }\n \n-    public void testWithDurationAdded_RD2() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationAdded(new Duration(0L));\n-        assertSame(test, result);\n-    }\n-\n-    public void testWithDurationAdded_RD3() {\n-        Duration test = new Duration(123L);\n-        Duration result = test.withDurationAdded(null);\n+    public void testPlus_long2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.plus(0L);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinus_long1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.minus(8000L);\n+        assertEquals(123L - 8000L, result.getMillis());\n+    }\n+\n+    public void testMinus_long2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.minus(0L);\n         assertSame(test, result);\n     }\n \n     public void testWithDurationAdded_RD_int6() {\n         Duration test = new Duration(123L);\n         Duration result = test.withDurationAdded(null, 0);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_RD1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.plus(new Duration(8000L));\n+        assertEquals(8123L, result.getMillis());\n+    }\n+\n+    public void testPlus_RD2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.plus(new Duration(0L));\n+        assertSame(test, result);\n+    }\n+\n+    public void testPlus_RD3() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.plus(null);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinus_RD1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.minus(new Duration(8000L));\n+        assertEquals(123L - 8000L, result.getMillis());\n+    }\n+\n+    public void testMinus_RD2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.minus(new Duration(0L));\n+        assertSame(test, result);\n+    }\n+\n+    public void testMinus_RD3() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.minus(null);\n         assertSame(test, result);\n     }\n ", "timestamp": 1094402909, "metainfo": ""}