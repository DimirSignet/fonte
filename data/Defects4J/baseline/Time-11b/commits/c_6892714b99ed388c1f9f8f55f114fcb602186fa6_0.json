{"sha": "6892714b99ed388c1f9f8f55f114fcb602186fa6", "log": "Checkstyle fixes   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n      * @param dayOfMonth day of month to use\n      * @param millisOfDay millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n-        throws IllegalArgumentException;\n+     * @throws IllegalArgumentException if the values are invalid\n+     */\n+    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay);\n \n     /**\n      * Returns a datetime millisecond instant, formed from the given year,\n      * @param secondOfMinute second to use\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the values are invalid\n      */\n     public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                            int hourOfDay, int minuteOfHour,\n-                           int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException;\n+                           int secondOfMinute, int millisOfSecond);\n \n     /**\n      * Returns a datetime millisecond instant, from from the given instant,\n      * @param secondOfMinute second to use\n      * @param millisOfSecond millisecond to use\n      * @return millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the values are invalid\n      */\n     public abstract long getDateTimeMillis(long instant,\n                            int hourOfDay, int minuteOfHour,\n-                           int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException;\n+                           int secondOfMinute, int millisOfSecond);\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @param chronology  the chronology to use, not null\n+     * @return the updated instant, rounded to midnight\n      */\n     protected long checkInstant(long instant, Chronology chronology) {\n         return chronology.dayOfMonth().roundFloor(instant);\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n     //-----------------------------------------------------------------------\n     /**\n      * Support serialization singletons.\n+     * \n+     * @return the resolved singleton instance\n      */\n     private Object readResolve() {\n         return getInstance(iLowerLimit, iUpperLimit);\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n      * For example, a leap year would return true, a non leap year would return\n      * false.\n      * \n+     * @param instant  the instant to check for leap status\n      * @return true if the field is 'leap'\n      */\n     public abstract boolean isLeap(long instant);\n      * <p>\n      * For example, a leap year would return one, a non leap year would return\n      * zero.\n+     * \n+     * @param instant  the instant to check for leap status\n+     * @return the amount, in units of the leap duration field, that the field is leap\n      */\n     public abstract int getLeapAmount(long instant);\n \n     /**\n      * If this field were to leap, then it would be in units described by the\n      * returned duration. If this field doesn't ever leap, null is returned.\n+     * \n+     * @return the leap duration field if field can be leap, null if it can't\n      */\n     public abstract DurationField getLeapDurationField();\n \n--- a/JodaTime/src/java/org/joda/time/DateTimeFieldType.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldType.java\n     /** Serialization version */\n     private static final long serialVersionUID = -42615285973990L;\n \n-    // Ordinals for standard field types.\n+    /** Ordinal values for standard field types. */\n     static final byte\n         ERA = 1,\n         YEAR_OF_ERA = 2,\n         private final byte iOrdinal;\n \n         /** The unit duration of the field. */\n-        private transient final DurationFieldType iUnitType;\n+        private final transient DurationFieldType iUnitType;\n         /** The range duration of the field. */\n-        private transient final DurationFieldType iRangeType;\n+        private final transient DurationFieldType iRangeType;\n \n         /**\n          * Constructor.\n          * \n          * @param name  the name to use\n+         * @param ordinal  the byte value for the oridinal index\n+         * @param unitType  the unit duration type\n+         * @param rangeType  the range duration type\n          */\n         StandardDateTimeFieldType(String name, byte ordinal,\n                                   DurationFieldType unitType, DurationFieldType rangeType) {\n             iRangeType = rangeType;\n         }\n \n+        /** @inheritdoc */\n         public DurationFieldType getDurationType() {\n             return iUnitType;\n         }\n \n+        /** @inheritdoc */\n         public DurationFieldType getRangeDurationType() {\n             return iRangeType;\n         }\n \n+        /** @inheritdoc */\n         public DateTimeField getField(Chronology chronology) {\n             chronology = DateTimeUtils.getChronology(chronology);\n \n             switch (iOrdinal) {\n-            case ERA:\n-                return chronology.era();\n-            case YEAR_OF_ERA:\n-                return chronology.yearOfEra();\n-            case CENTURY_OF_ERA:\n-                return chronology.centuryOfEra();\n-            case YEAR_OF_CENTURY:\n-                return chronology.yearOfCentury();\n-            case YEAR:\n-                return chronology.year();\n-            case DAY_OF_YEAR:\n-                return chronology.dayOfYear();\n-            case MONTH_OF_YEAR:\n-                return chronology.monthOfYear();\n-            case DAY_OF_MONTH:\n-                return chronology.dayOfMonth();\n-            case WEEKYEAR_OF_CENTURY:\n-                return chronology.weekyearOfCentury();\n-            case WEEKYEAR:\n-                return chronology.weekyear();\n-            case WEEK_OF_WEEKYEAR:\n-                return chronology.weekOfWeekyear();\n-            case DAY_OF_WEEK:\n-                return chronology.dayOfWeek();\n-            case HALFDAY_OF_DAY:\n-                return chronology.halfdayOfDay();\n-            case HOUR_OF_HALFDAY:\n-                return chronology.hourOfHalfday();\n-            case CLOCKHOUR_OF_HALFDAY:\n-                return chronology.clockhourOfHalfday();\n-            case CLOCKHOUR_OF_DAY:\n-                return chronology.clockhourOfDay();\n-            case HOUR_OF_DAY:\n-                return chronology.hourOfDay();\n-            case MINUTE_OF_DAY:\n-                return chronology.minuteOfDay();\n-            case MINUTE_OF_HOUR:\n-                return chronology.minuteOfHour();\n-            case SECOND_OF_DAY:\n-                return chronology.secondOfDay();\n-            case SECOND_OF_MINUTE:\n-                return chronology.secondOfMinute();\n-            case MILLIS_OF_DAY:\n-                return chronology.millisOfDay();\n-            case MILLIS_OF_SECOND:\n-                return chronology.millisOfSecond();\n-            default:\n-                // Shouldn't happen.\n-                throw new InternalError();\n+                case ERA:\n+                    return chronology.era();\n+                case YEAR_OF_ERA:\n+                    return chronology.yearOfEra();\n+                case CENTURY_OF_ERA:\n+                    return chronology.centuryOfEra();\n+                case YEAR_OF_CENTURY:\n+                    return chronology.yearOfCentury();\n+                case YEAR:\n+                    return chronology.year();\n+                case DAY_OF_YEAR:\n+                    return chronology.dayOfYear();\n+                case MONTH_OF_YEAR:\n+                    return chronology.monthOfYear();\n+                case DAY_OF_MONTH:\n+                    return chronology.dayOfMonth();\n+                case WEEKYEAR_OF_CENTURY:\n+                    return chronology.weekyearOfCentury();\n+                case WEEKYEAR:\n+                    return chronology.weekyear();\n+                case WEEK_OF_WEEKYEAR:\n+                    return chronology.weekOfWeekyear();\n+                case DAY_OF_WEEK:\n+                    return chronology.dayOfWeek();\n+                case HALFDAY_OF_DAY:\n+                    return chronology.halfdayOfDay();\n+                case HOUR_OF_HALFDAY:\n+                    return chronology.hourOfHalfday();\n+                case CLOCKHOUR_OF_HALFDAY:\n+                    return chronology.clockhourOfHalfday();\n+                case CLOCKHOUR_OF_DAY:\n+                    return chronology.clockhourOfDay();\n+                case HOUR_OF_DAY:\n+                    return chronology.hourOfDay();\n+                case MINUTE_OF_DAY:\n+                    return chronology.minuteOfDay();\n+                case MINUTE_OF_HOUR:\n+                    return chronology.minuteOfHour();\n+                case SECOND_OF_DAY:\n+                    return chronology.secondOfDay();\n+                case SECOND_OF_MINUTE:\n+                    return chronology.secondOfMinute();\n+                case MILLIS_OF_DAY:\n+                    return chronology.millisOfDay();\n+                case MILLIS_OF_SECOND:\n+                    return chronology.millisOfSecond();\n+                default:\n+                    // Shouldn't happen.\n+                    throw new InternalError();\n             }\n         }\n \n          */\n         private Object readResolve() {\n             switch (iOrdinal) {\n-            case ERA:\n-                return ERA_TYPE;\n-            case YEAR_OF_ERA:\n-                return YEAR_OF_ERA_TYPE;\n-            case CENTURY_OF_ERA:\n-                return CENTURY_OF_ERA_TYPE;\n-            case YEAR_OF_CENTURY:\n-                return YEAR_OF_CENTURY_TYPE;\n-            case YEAR:\n-                return YEAR_TYPE;\n-            case DAY_OF_YEAR:\n-                return DAY_OF_YEAR_TYPE;\n-            case MONTH_OF_YEAR:\n-                return MONTH_OF_YEAR_TYPE;\n-            case DAY_OF_MONTH:\n-                return DAY_OF_MONTH_TYPE;\n-            case WEEKYEAR_OF_CENTURY:\n-                return WEEKYEAR_OF_CENTURY_TYPE;\n-            case WEEKYEAR:\n-                return WEEKYEAR_TYPE;\n-            case WEEK_OF_WEEKYEAR:\n-                return WEEK_OF_WEEKYEAR_TYPE;\n-            case DAY_OF_WEEK:\n-                return DAY_OF_WEEK_TYPE;\n-            case HALFDAY_OF_DAY:\n-                return HALFDAY_OF_DAY_TYPE;\n-            case HOUR_OF_HALFDAY:\n-                return HOUR_OF_HALFDAY_TYPE;\n-            case CLOCKHOUR_OF_HALFDAY:\n-                return CLOCKHOUR_OF_HALFDAY_TYPE;\n-            case CLOCKHOUR_OF_DAY:\n-                return CLOCKHOUR_OF_DAY_TYPE;\n-            case HOUR_OF_DAY:\n-                return HOUR_OF_DAY_TYPE;\n-            case MINUTE_OF_DAY:\n-                return MINUTE_OF_DAY_TYPE;\n-            case MINUTE_OF_HOUR:\n-                return MINUTE_OF_HOUR_TYPE;\n-            case SECOND_OF_DAY:\n-                return SECOND_OF_DAY_TYPE;\n-            case SECOND_OF_MINUTE:\n-                return SECOND_OF_MINUTE_TYPE;\n-            case MILLIS_OF_DAY:\n-                return MILLIS_OF_DAY_TYPE;\n-            case MILLIS_OF_SECOND:\n-                return MILLIS_OF_SECOND_TYPE;\n-            default:\n-                // Shouldn't happen.\n-                return this;\n+                case ERA:\n+                    return ERA_TYPE;\n+                case YEAR_OF_ERA:\n+                    return YEAR_OF_ERA_TYPE;\n+                case CENTURY_OF_ERA:\n+                    return CENTURY_OF_ERA_TYPE;\n+                case YEAR_OF_CENTURY:\n+                    return YEAR_OF_CENTURY_TYPE;\n+                case YEAR:\n+                    return YEAR_TYPE;\n+                case DAY_OF_YEAR:\n+                    return DAY_OF_YEAR_TYPE;\n+                case MONTH_OF_YEAR:\n+                    return MONTH_OF_YEAR_TYPE;\n+                case DAY_OF_MONTH:\n+                    return DAY_OF_MONTH_TYPE;\n+                case WEEKYEAR_OF_CENTURY:\n+                    return WEEKYEAR_OF_CENTURY_TYPE;\n+                case WEEKYEAR:\n+                    return WEEKYEAR_TYPE;\n+                case WEEK_OF_WEEKYEAR:\n+                    return WEEK_OF_WEEKYEAR_TYPE;\n+                case DAY_OF_WEEK:\n+                    return DAY_OF_WEEK_TYPE;\n+                case HALFDAY_OF_DAY:\n+                    return HALFDAY_OF_DAY_TYPE;\n+                case HOUR_OF_HALFDAY:\n+                    return HOUR_OF_HALFDAY_TYPE;\n+                case CLOCKHOUR_OF_HALFDAY:\n+                    return CLOCKHOUR_OF_HALFDAY_TYPE;\n+                case CLOCKHOUR_OF_DAY:\n+                    return CLOCKHOUR_OF_DAY_TYPE;\n+                case HOUR_OF_DAY:\n+                    return HOUR_OF_DAY_TYPE;\n+                case MINUTE_OF_DAY:\n+                    return MINUTE_OF_DAY_TYPE;\n+                case MINUTE_OF_HOUR:\n+                    return MINUTE_OF_HOUR_TYPE;\n+                case SECOND_OF_DAY:\n+                    return SECOND_OF_DAY_TYPE;\n+                case SECOND_OF_MINUTE:\n+                    return SECOND_OF_MINUTE_TYPE;\n+                case MILLIS_OF_DAY:\n+                    return MILLIS_OF_DAY_TYPE;\n+                case MILLIS_OF_SECOND:\n+                    return MILLIS_OF_SECOND_TYPE;\n+                default:\n+                    // Shouldn't happen.\n+                    return this;\n             }\n         }\n     }\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n      * <p>\n      * This method changes the behaviour of {@link #currentTimeMillis()}.\n      * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n+     * \n+     * @throws SecurityException if the application does not have sufficient security rights\n      */\n     public static final void setCurrentMillisSystem() throws SecurityException {\n         checkPermission();\n      * Whenever the current time is queried, the same millisecond time will be returned.\n      * \n      * @param fixedMillis  the fixed millisecond time to use\n+     * @throws SecurityException if the application does not have sufficient security rights\n      */\n     public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n         checkPermission();\n      * and then offset by adding the millisecond value specified here.\n      * \n      * @param offsetMillis  the fixed millisecond time to use\n+     * @throws SecurityException if the application does not have sufficient security rights\n      */\n     public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n         checkPermission();\n     /**\n      * Base class defining a millisecond provider.\n      */\n-    static abstract class MillisProvider {\n+    abstract static class MillisProvider {\n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n         abstract long getMillis();\n     }\n \n      * System millis provider.\n      */\n     static class SystemMillisProvider extends MillisProvider {\n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n         long getMillis() {\n             return System.currentTimeMillis();\n         }\n      * Fixed millisecond provider.\n      */\n     static class FixedMillisProvider extends MillisProvider {\n+        /** The fixed millis value. */\n         private final long iMillis;\n+        \n+        /**\n+         * Constructor.\n+         * @param offsetMillis  the millis offset\n+         */\n         FixedMillisProvider(long fixedMillis) {\n             iMillis = fixedMillis;\n         }\n+        \n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n         long getMillis() {\n             return iMillis;\n         }\n      * Offset from system millis provider.\n      */\n     static class OffsetMillisProvider extends MillisProvider {\n+        /** The millis offset. */\n         private final long iMillis;\n+        \n+        /**\n+         * Constructor.\n+         * @param offsetMillis  the millis offset\n+         */\n         OffsetMillisProvider(long offsetMillis) {\n             iMillis = offsetMillis;\n         }\n+        \n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n         long getMillis() {\n             return System.currentTimeMillis() + iMillis;\n         }\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n     /** The time zone for Universal Coordinated Time */\n     public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n \n+    /** The instance that is providing time zones. */\n     private static Provider cProvider;\n+    /** The instance that is providing time zone names. */\n     private static NameProvider cNameProvider;\n+    /** The set of ID strings. */\n     private static Set cAvailableIDs;\n-\n+    /** The default time zone. */\n     private static DateTimeZone cDefault;\n-\n+    /** A formatter for printing and parsing zones. */\n     private static DateTimeFormatter cOffsetFormatter;\n \n     /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n         try {\n             try {\n                 cDefault = getInstance(System.getProperty(\"user.timezone\"));\n-            } catch (RuntimeException ignored) {\n+            } catch (RuntimeException ex) {\n+                // ignored\n             }\n             if (cDefault == null) {\n                 cDefault = getInstance(java.util.TimeZone.getDefault());\n             }\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n         }\n \n         if (cDefault == null) {\n      * \n      * @param zone  the default datetime zone object, must not be null\n      * @throws IllegalArgumentException if the zone is null\n+     * @throws SecurityException if the application has insufficient security rights\n      */\n     public static void setDefault(DateTimeZone zone) throws SecurityException {\n         SecurityManager sm = System.getSecurityManager();\n             convId = zone.getDisplayName();\n             if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                 convId = convId.substring(3);\n-                int offset = -(int)offsetFormatter().parseMillis(convId);\n+                int offset = -(int) offsetFormatter().parseMillis(convId);\n                 if (offset == 0L) {\n                     return DateTimeZone.UTC;\n                 } else {\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n \n+    /**\n+     * Gets the zone using a fixed offset amount.\n+     * \n+     * @param id  the zone id\n+     * @param offset  the offset in millis\n+     * @return the zone\n+     */\n     private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n         if (iFixedOffsetCache == null) {\n             iFixedOffsetCache = new HashMap();\n                 System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n             if (providerClass != null) {\n                 try {\n-                    provider = (Provider)Class.forName(providerClass).newInstance();\n-                }\n-                catch (Exception ex) {\n+                    provider = (Provider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n                     Thread thread = Thread.currentThread();\n                     thread.getThreadGroup().uncaughtException(thread, ex);\n                 }\n             }\n         } catch (SecurityException ex) {\n+            // ignored\n         }\n \n         if (provider == null) {\n \n         int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n         FormatUtils.appendPaddedInteger(buf, hours, 2);\n-        offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n \n         int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n         buf.append(':');\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n      * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n      * @return the human-readable short name in the specified locale\n      */\n     public String getShortName(long instant, Locale locale) {\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n      * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n      * @return the human-readable long name in the specified locale\n      */\n     public String getName(long instant, Locale locale) {\n \n     /**\n      * Gets the datetime zone as a string, which is simply its ID.\n+     * @return the id of the zone\n      */\n     public String toString() {\n         return getID();\n      * By default, when DateTimeZones are serialized, only a \"stub\" object\n      * referring to the id is written out. When the stub is read in, it\n      * replaces itself with a DateTimeZone object.\n+     * @return a stub object to go in the stream\n      */\n     protected Object writeReplace() throws ObjectStreamException {\n         return new Stub(iID);\n      * Used to serialize DateTimeZones by id.\n      */\n     private static final class Stub implements Serializable {\n+        /** Serialization lock. */\n         private static final long serialVersionUID = -6471952376487863581L;\n-\n+        /** The ID of the zone. */\n         private transient String iID;\n \n+        /**\n+         * Constructor.\n+         * @param id  the id of the zone\n+         */\n         Stub(String id) {\n             iID = id;\n         }\n             iID = in.readUTF();\n         }\n \n-        protected Object readResolve() throws ObjectStreamException {\n+        private Object readResolve() throws ObjectStreamException {\n             return getInstance(iID);\n         }\n     }", "timestamp": 1099700215, "metainfo": ""}