{"sha": "b86efe73e72ece8e5ceeed48d05228aa1725c9ad", "log": "Add Partial, new immutable implementation of ReadablePartial   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Partial.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Partial is an immutable partial datetime where the fields supported\n+ * are defined by the constructor.\n+ * <p>\n+ * Calculations on Partial are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n+ * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * Partial is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.1\n+ */\n+public final class Partial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 12324121189002L;\n+\n+    /** The chronology in use. */\n+    private final Chronology iChronology;\n+    /** The set of field types. */\n+    private final DateTimeFieldType[] iTypes;\n+    /** The values of each field in this partial. */\n+    private final int[] iValues;\n+    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n+    private transient DateTimeFormatter[] iFormatter;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial()\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     */\n+    public Partial() {\n+        this((Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial(chrono)\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     *\n+     * @param chronology  the chronology, null means ISO\n+     */\n+    public Partial(Chronology chrono) {\n+        super();\n+        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n+        iTypes = new DateTimeFieldType[0];\n+        iValues = new int[0];\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value) {\n+        this(type, value, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        iTypes = new DateTimeFieldType[] {type};\n+        iValues = new int[] {value};\n+        chronology.validate(this, iValues);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values) {\n+        this(types, values, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (types == null) {\n+            throw new IllegalArgumentException(\"Types array must not be null\");\n+        }\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"Values array must not be null\");\n+        }\n+        if (values.length != types.length) {\n+            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n+        }\n+        if (types.length == 0) {\n+            iTypes = types;\n+            iValues = values;\n+            return;\n+        }\n+        for (int i = 0; i < types.length; i++) {\n+            if (types[i] == null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n+            }\n+        }\n+        DurationField lastUnitField = null;\n+        for (int i = 0; i < types.length; i++) {\n+            DateTimeFieldType loopType = types[i];\n+            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+            if (i > 0) {\n+                int compare = lastUnitField.compareTo(loopUnitField);\n+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n+                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                            types[i - 1].getName() + \" < \" + loopType.getName());\n+                } else if (compare == 0) {\n+                    if (types[i - 1].getRangeDurationType() == null) {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    } else {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n+                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    }\n+                }\n+            }\n+            lastUnitField = loopUnitField;\n+        }\n+        \n+        iTypes = (DateTimeFieldType[]) types.clone();\n+        chronology.validate(this, values);\n+        iValues = (int[]) values.clone();\n+    }\n+\n+    /**\n+     * Constructs a Partial by copying all the fields and types from\n+     * another partial.\n+     * <p>\n+     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n+     */\n+    public Partial(ReadablePartial partial) {\n+        super();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n+        iTypes = new DateTimeFieldType[partial.size()];\n+        iValues = new int[partial.size()];\n+        for (int i = 0; i < partial.size(); i++) {\n+            iTypes[i] = partial.getFieldType(i);\n+            iValues[i] = partial.getValue(i);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param partial  the partial to copy\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Partial partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iTypes = partial.iTypes;\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified chronology, fields and values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param chronology  the chronology\n+     * @param types  the types to create the partial from\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n+        super();\n+        iChronology = chronology;\n+        iTypes = types;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        return iTypes[index].getField(chrono);\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) iTypes.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Partial instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as Partial\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public Partial withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n+            newChronology.validate(newPartial, iValues);\n+            return newPartial;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * If this partial did not previously support the field, the new one will.\n+     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed/added in the returned instance.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial with(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        int index = indexOf(fieldType);\n+        if (index == -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n+            int[] newValues = new int[newTypes.length];\n+            \n+            // find correct insertion point to keep largest-smallest order\n+            int i = 0;\n+            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n+            if (unitField.isSupported()) {\n+                for (; i < iTypes.length; i++) {\n+                    DateTimeFieldType loopType = iTypes[i];\n+                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+                    if (loopUnitField.isSupported()) {\n+                        int compare = unitField.compareTo(loopUnitField);\n+                        if (compare > 0) {\n+                            break;\n+                        } else if (compare == 0) {\n+                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n+                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                            if (rangeField.compareTo(loopRangeField) > 0) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            System.arraycopy(iTypes, 0, newTypes, 0, i);\n+            System.arraycopy(iValues, 0, newValues, 0, i);\n+            newTypes[i] = fieldType;\n+            newValues[i] = value;\n+            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+            \n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified field removed.\n+     * <p>\n+     * If this partial did not previously support the field, no error occurs.\n+     *\n+     * @param fieldType  the field type to remove, may be null\n+     * @return a copy of this instance with the field removed\n+     */\n+    public Partial without(DateTimeFieldType fieldType) {\n+        int index = indexOf(fieldType);\n+        if (index != -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n+            int[] newValues = new int[size() - 1];\n+            System.arraycopy(iTypes, 0, newTypes, 0, index);\n+            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n+            System.arraycopy(iValues, 0, newValues, 0, index);\n+            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this Partial with the specified field set to a new value.\n+     * <p>\n+     * If this partial does not support the field, an exception is thrown.\n+     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance if supported.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * However, it will not wrap around if the top maximum is reached.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * If the maximum is reached, the addition will wra.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using the method\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiplyToInt(period.getValue(i), scalar));\n+            }\n+        }\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods for getting and manipulating the partial.\n+     * <p>\n+     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n+     *\n+     * @param type  the field type to get the property for, not null\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The specified object must be a ReadablePartial whose field types\n+     * match those of this partial. Normally that means that the partials\n+     * must be the same class.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(Object partial) {\n+        if (this == partial) {\n+            return 0;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (size() != other.size()) {\n+            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+            }\n+        }\n+        // fields are ordered largest first\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) > other.getValue(i)) {\n+                return 1;\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return -1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is this partial later than the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is after the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isAfter(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) > 0;\n+    }\n+\n+    /**\n+     * Is this partial earlier than the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is before the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isBefore(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) < 0;\n+    }\n+\n+    /**\n+     * Is this partial the same as the specified partial.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param date  an date to check against, null means now\n+     * @return true if this date is the same as the date passed in\n+     * @throws IllegalArgumentException if the specified YearMonthDay is null\n+     */\n+    public boolean isEqual(Partial date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(date) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a formatter suitable for the fields in this partial.\n+     * <p>\n+     * If there is no appropriate ISO format, null is returned.\n+     * This method may return a formatter that does not display all the\n+     * fields of the partial. This might occur when you have overlapping\n+     * fields, such as dayOfWeek and dayOfMonth.\n+     *\n+     * @return a formatter suitable for the fields in this partial, null\n+     *  if none is suitable\n+     */\n+    public DateTimeFormatter getFormatter() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            if (size() == 0) {\n+                return null;\n+            }\n+            f = new DateTimeFormatter[2];\n+            try {\n+                List list = new ArrayList(Arrays.asList(iTypes));\n+                f[0] = ISODateTimeFormat.forFields(list, true, false);\n+                if (list.size() == 0) {\n+                    f[1] = f[0];\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                // ignore\n+            }\n+            iFormatter = f;\n+        }\n+        return f[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in an appropriate ISO8601 format.\n+     * <p>\n+     * This method will output the partial in one of two ways.\n+     * If {@link #getFormatter()}\n+     * \n+     * If there is no appropriate ISO format a dump of the fields is output\n+     * via {@link #toStringList()}. An appropr\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            getFormatter();\n+            f = iFormatter;\n+            if (f == null) {\n+                return toStringList();\n+            }\n+        }\n+        DateTimeFormatter f1 = f[1];\n+        if (f1 == null) {\n+            return toStringList();\n+        }\n+        return f1.print(this);\n+    }\n+\n+    /**\n+     * Gets a string version of the partial that lists all the fields.\n+     * <p>\n+     * This method exists to provide a better debugging toString than\n+     * the standard toString. This method lists all the fields and their\n+     * values in a style similar to the collections framework.\n+     *\n+     * @return a toString format that lists all the fields\n+     */\n+    public String toStringList() {\n+        int size = size();\n+        StringBuffer buf = new StringBuffer(20 * size);\n+        buf.append('[');\n+        for (int i = 0; i < size; i++) {\n+            if (i > 0) {\n+                buf.append(',').append(' ');\n+            }\n+            buf.append(iTypes[i].getName());\n+            buf.append('=');\n+            buf.append(iValues[i]);\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 53278362873888L;\n+\n+        /** The partial */\n+        private final Partial iPartial;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(Partial partial, int fieldIndex) {\n+            super();\n+            iPartial = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iPartial.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public Partial getPartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iPartial.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this Partial.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this Partial wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the Partial.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial setCopy(int value) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text, Locale locale) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestYearMonthDay_Constructors.suite());\n         suite.addTest(TestYearMonthDay_Properties.suite());\n         \n+        suite.addTest(TestPartial_Basics.suite());\n+        suite.addTest(TestPartial_Constructors.suite());\n+        suite.addTest(TestPartial_Properties.suite());\n+        \n         suite.addTest(TestAbstractPartial.suite());\n         suite.addTest(TestBasePartial.suite());\n         \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestPartial_Basics.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * This class is a Junit unit test for Partial.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestPartial_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final int OFFSET = 1;\n+    private static final Chronology COPTIC_PARIS = Chronology.getCoptic(PARIS);\n+    private static final Chronology COPTIC_LONDON = Chronology.getCoptic(LONDON);\n+    private static final Chronology COPTIC_TOKYO = Chronology.getCoptic(TOKYO);\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology ISO_PARIS = Chronology.getISO(PARIS);\n+    private static final Chronology ISO_LONDON = Chronology.getISO(LONDON);\n+    private static final Chronology ISO_TOKYO = Chronology.getISO(TOKYO);\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology BUDDHIST_PARIS = Chronology.getBuddhist(PARIS);\n+    private static final Chronology BUDDHIST_LONDON = Chronology.getBuddhist(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = Chronology.getBuddhist(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestPartial_Basics.class);\n+    }\n+\n+    public TestPartial_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(DateTimeFieldType.secondOfMinute());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(2, test.size());\n+    }\n+\n+    public void testGetFieldType() {\n+        Partial test = createHourMinPartial();\n+        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));\n+        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));\n+        try {\n+            test.getFieldType(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getFieldType(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFieldTypes() {\n+        Partial test = createHourMinPartial();\n+        DateTimeFieldType[] fields = test.getFieldTypes();\n+        assertEquals(2, fields.length);\n+        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);\n+        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);\n+        assertNotSame(test.getFieldTypes(), test.getFieldTypes());\n+    }\n+\n+    public void testGetField() {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        assertSame(Chronology.getCopticUTC().hourOfDay(), test.getField(0));\n+        assertSame(Chronology.getCopticUTC().minuteOfHour(), test.getField(1));\n+        try {\n+            test.getField(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getField(5);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        DateTimeField[] fields = test.getFields();\n+        assertEquals(2, fields.length);\n+        assertSame(Chronology.getCopticUTC().hourOfDay(), fields[0]);\n+        assertSame(Chronology.getCopticUTC().minuteOfHour(), fields[1]);\n+        assertNotSame(test.getFields(), test.getFields());\n+    }\n+\n+    public void testGetValue() {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        assertEquals(10, test.getValue(0));\n+        assertEquals(20, test.getValue(1));\n+        try {\n+            test.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            test.getValue(2);\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        int[] values = test.getValues();\n+        assertEquals(2, values.length);\n+        assertEquals(10, values[0]);\n+        assertEquals(20, values[1]);\n+        assertNotSame(test.getValues(), test.getValues());\n+    }\n+\n+    public void testIsSupported() {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.millisOfSecond()));\n+        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        Partial test1 = createHourMinPartial(COPTIC_PARIS);\n+        Partial test2 = createHourMinPartial(COPTIC_PARIS);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        Partial test3 = createHourMinPartial2(COPTIC_PARIS);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n+        assertEquals(new TimeOfDay(10, 20, 30, 40), createTODPartial(ISO_UTC));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        Partial test1 = createHourMinPartial();\n+        Partial test1a = createHourMinPartial();\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        Partial test2 = createHourMinPartial2(ISO_UTC);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        Partial test3 = createHourMinPartial2(COPTIC_UTC);\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(0, new TimeOfDay(10, 20, 30, 40).compareTo(createTODPartial(ISO_UTC)));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            test1.compareTo(new YearMonthDay());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            createTODPartial(ISO_UTC).without(DateTimeFieldType.hourOfDay()).compareTo(new YearMonthDay());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsEqual_TOD() {\n+        Partial test1 = createHourMinPartial();\n+        Partial test1a = createHourMinPartial();\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        Partial test2 = createHourMinPartial2(ISO_UTC);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        Partial test3 = createHourMinPartial2(COPTIC_UTC);\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        try {\n+            createHourMinPartial().isEqual(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsBefore_TOD() {\n+        Partial test1 = createHourMinPartial();\n+        Partial test1a = createHourMinPartial();\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        Partial test2 = createHourMinPartial2(ISO_UTC);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        Partial test3 = createHourMinPartial2(COPTIC_UTC);\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        try {\n+            createHourMinPartial().isBefore(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAfter_TOD() {\n+        Partial test1 = createHourMinPartial();\n+        Partial test1a = createHourMinPartial();\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        Partial test2 = createHourMinPartial2(ISO_UTC);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        Partial test3 = createHourMinPartial2(COPTIC_UTC);\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        try {\n+            createHourMinPartial().isAfter(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testWithChronologyRetainFields_Chrono() {\n+        Partial base = createHourMinPartial(COPTIC_PARIS);\n+        Partial test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n+        check(base, 10, 20);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 10, 20);\n+        assertEquals(BUDDHIST_UTC, test.getChronology());\n+    }\n+\n+    public void testWithChronologyRetainFields_sameChrono() {\n+        Partial base = createHourMinPartial(COPTIC_PARIS);\n+        Partial test = base.withChronologyRetainFields(COPTIC_TOKYO);\n+        assertSame(base, test);\n+    }\n+\n+    public void testWithChronologyRetainFields_nullChrono() {\n+        Partial base = createHourMinPartial(COPTIC_PARIS);\n+        Partial test = base.withChronologyRetainFields(null);\n+        check(base, 10, 20);\n+        assertEquals(COPTIC_UTC, base.getChronology());\n+        check(test, 10, 20);\n+        assertEquals(ISO_UTC, test.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWith1() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.with(DateTimeFieldType.hourOfDay(), 15);\n+        check(test, 10, 20);\n+        check(result, 15, 20);\n+    }\n+\n+    public void testWith2() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.with(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWith3a() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.with(DateTimeFieldType.secondOfMinute(), 15);\n+        check(test, 10, 20);\n+        assertEquals(3, result.size());\n+        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));\n+        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(1));\n+        assertEquals(DateTimeFieldType.secondOfMinute(), result.getFieldType(2));\n+        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(15, result.get(DateTimeFieldType.secondOfMinute()));\n+    }\n+\n+    public void testWith3b() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.with(DateTimeFieldType.minuteOfDay(), 15);\n+        check(test, 10, 20);\n+        assertEquals(3, result.size());\n+        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfDay()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));\n+        assertEquals(DateTimeFieldType.minuteOfDay(), result.getFieldType(1));\n+        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));\n+        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(15, result.get(DateTimeFieldType.minuteOfDay()));\n+    }\n+\n+    public void testWith3c() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.with(DateTimeFieldType.dayOfMonth(), 15);\n+        check(test, 10, 20);\n+        assertEquals(3, result.size());\n+        assertEquals(true, result.isSupported(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(DateTimeFieldType.dayOfMonth(), result.getFieldType(0));\n+        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(1));\n+        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));\n+        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(15, result.get(DateTimeFieldType.dayOfMonth()));\n+    }\n+\n+    public void testWith3d() {\n+        Partial test = new Partial(DateTimeFieldType.year(), 2005);\n+        Partial result = test.with(DateTimeFieldType.monthOfYear(), 6);\n+        assertEquals(2, result.size());\n+        assertEquals(2005, result.get(DateTimeFieldType.year()));\n+        assertEquals(6, result.get(DateTimeFieldType.monthOfYear()));\n+    }        \n+\n+    public void testWith3e() {\n+        Partial test = new Partial(DateTimeFieldType.era(), 1);\n+        Partial result = test.with(DateTimeFieldType.halfdayOfDay(), 0);\n+        assertEquals(2, result.size());\n+        assertEquals(1, result.get(DateTimeFieldType.era()));\n+        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));\n+        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n+        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));\n+    }        \n+\n+    public void testWith3f() {\n+        Partial test = new Partial(DateTimeFieldType.halfdayOfDay(), 0);\n+        Partial result = test.with(DateTimeFieldType.era(), 1);\n+        assertEquals(2, result.size());\n+        assertEquals(1, result.get(DateTimeFieldType.era()));\n+        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));\n+        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n+        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));\n+    }        \n+\n+    public void testWith4() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.with(DateTimeFieldType.hourOfDay(), 10);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithout1() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.without(DateTimeFieldType.year());\n+        check(test, 10, 20);\n+        check(result, 10, 20);\n+    }\n+\n+    public void testWithout2() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.without((DateTimeFieldType) null);\n+        check(test, 10, 20);\n+        check(result, 10, 20);\n+    }\n+\n+    public void testWithout3() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.without(DateTimeFieldType.hourOfDay());\n+        check(test, 10, 20);\n+        assertEquals(1, result.size());\n+        assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(0));\n+    }\n+\n+    public void testWithout4() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.without(DateTimeFieldType.minuteOfHour());\n+        check(test, 10, 20);\n+        assertEquals(1, result.size());\n+        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n+        assertEquals(false, result.isSupported(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));\n+    }\n+\n+    public void testWithout5() {\n+        Partial test = new Partial(DateTimeFieldType.hourOfDay(), 12);\n+        Partial result = test.without(DateTimeFieldType.hourOfDay());\n+        assertEquals(0, result.size());\n+        assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithField1() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withField(DateTimeFieldType.hourOfDay(), 15);\n+        check(test, 10, 20);\n+        check(result, 15, 20);\n+    }\n+\n+    public void testWithField2() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withField(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithField3() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withField(DateTimeFieldType.dayOfMonth(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithField4() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withField(DateTimeFieldType.hourOfDay(), 10);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldAdded1() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withFieldAdded(DurationFieldType.hours(), 6);\n+        \n+        assertEquals(createHourMinPartial(), test);\n+        check(test, 10, 20);\n+        check(result, 16, 20);\n+    }\n+\n+    public void testWithFieldAdded2() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAdded(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAdded3() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAdded(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAdded4() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withFieldAdded(DurationFieldType.hours(), 0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithFieldAdded5() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAdded(DurationFieldType.days(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAdded6() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), 16);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAdded7() {\n+        Partial test = createHourMinPartial(23, 59, ISO_UTC);\n+        try {\n+            test.withFieldAdded(DurationFieldType.minutes(), 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        check(test, 23, 59);\n+        \n+        test = createHourMinPartial(23, 59, ISO_UTC);\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        check(test, 23, 59);\n+    }\n+\n+    public void testWithFieldAdded8() {\n+        Partial test = createHourMinPartial(0, 0, ISO_UTC);\n+        try {\n+            test.withFieldAdded(DurationFieldType.minutes(), -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        check(test, 0, 0);\n+        \n+        test = createHourMinPartial(0, 0, ISO_UTC);\n+        try {\n+            test.withFieldAdded(DurationFieldType.hours(), -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        check(test, 0, 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithFieldAddWrapped1() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 6);\n+        \n+        assertEquals(createHourMinPartial(), test);\n+        check(test, 10, 20);\n+        check(result, 16, 20);\n+    }\n+\n+    public void testWithFieldAddWrapped2() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAddWrapped(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAddWrapped3() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAddWrapped(null, 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAddWrapped4() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 0);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithFieldAddWrapped5() {\n+        Partial test = createHourMinPartial();\n+        try {\n+            test.withFieldAddWrapped(DurationFieldType.days(), 6);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20);\n+    }\n+\n+    public void testWithFieldAddWrapped6() {\n+        Partial test = createHourMinPartial();\n+        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 16);\n+        \n+        assertEquals(createHourMinPartial(), test);\n+        check(test, 10, 20);\n+        check(result, 2, 20);\n+    }\n+\n+    public void testWithFieldAddWrapped7() {\n+        Partial test = createHourMinPartial(23, 59, ISO_UTC);\n+        Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), 1);\n+        check(test, 23, 59);\n+        check(result, 0, 0);\n+        \n+        test = createHourMinPartial(23, 59, ISO_UTC);\n+        result = test.withFieldAddWrapped(DurationFieldType.hours(), 1);\n+        check(test, 23, 59);\n+        check(result, 0, 59);\n+    }\n+\n+    public void testWithFieldAddWrapped8() {\n+        Partial test = createHourMinPartial(0, 0, ISO_UTC);\n+        Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), -1);\n+        check(test, 0, 0);\n+        check(result, 23, 59);\n+        \n+        test = createHourMinPartial(0, 0, ISO_UTC);\n+        result = test.withFieldAddWrapped(DurationFieldType.hours(), -1);\n+        check(test, 0, 0);\n+        check(result, 23, 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_RP() {\n+        Partial test = createHourMinPartial(BUDDHIST_LONDON);\n+        Partial result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n+        check(test, 10, 20);\n+        check(result, 15, 26);\n+        \n+        result = test.plus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinus_RP() {\n+        Partial test = createHourMinPartial(BUDDHIST_LONDON);\n+        Partial result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n+        check(test, 10, 20);\n+        check(result, 9, 19);\n+        \n+        result = test.minus((ReadablePeriod) null);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_RI() {\n+        Partial base = createHourMinPartial(COPTIC_PARIS);\n+        DateTime dt = new DateTime(0L); // LONDON zone\n+        assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n+        \n+        DateTime test = base.toDateTime(dt);\n+        check(base, 10, 20);\n+        assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:00.000+01:00\", test.toString());\n+    }\n+\n+    public void testToDateTime_nullRI() {\n+        Partial base = createHourMinPartial(1, 2, ISO_UTC);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);\n+        \n+        DateTime test = base.toDateTime((ReadableInstant) null);\n+        check(base, 1, 2);\n+        assertEquals(\"1970-01-02T01:02:07.008+01:00\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProperty() {\n+        Partial test = createHourMinPartial();\n+        assertNotNull(test.property(DateTimeFieldType.hourOfDay()));\n+        assertNotNull(test.property(DateTimeFieldType.minuteOfHour()));\n+        try {\n+            test.property(DateTimeFieldType.secondOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Partial test = createHourMinPartial(COPTIC_PARIS);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Partial result = (Partial) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetFormatter1() {\n+        Partial test = new Partial(DateTimeFieldType.year(), 2005);\n+        assertEquals(\"2005\", test.getFormatter().print(test));\n+        \n+        test = test.with(DateTimeFieldType.monthOfYear(), 6);\n+        assertEquals(\"2005-06\", test.getFormatter().print(test));\n+        \n+        test = test.with(DateTimeFieldType.dayOfMonth(), 25);\n+        assertEquals(\"2005-06-25\", test.getFormatter().print(test));\n+        \n+        test = test.without(DateTimeFieldType.monthOfYear());\n+        assertEquals(\"2005--25\", test.getFormatter().print(test));\n+    }\n+\n+    public void testGetFormatter2() {\n+        Partial test = new Partial();\n+        assertEquals(null, test.getFormatter());\n+        \n+        test = test.with(DateTimeFieldType.era(), 1);\n+        assertEquals(null, test.getFormatter());\n+        \n+        test = test.with(DateTimeFieldType.halfdayOfDay(), 0);\n+        assertEquals(null, test.getFormatter());\n+    }\n+\n+    public void testGetFormatter3() {\n+        Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5);\n+        assertEquals(\"-W-5\", test.getFormatter().print(test));\n+        \n+        // contrast with testToString5\n+        test = test.with(DateTimeFieldType.dayOfMonth(), 13);\n+        assertEquals(\"---13\", test.getFormatter().print(test));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString1() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(\"10:20\", test.toString());\n+    }\n+\n+    public void testToString2() {\n+        Partial test = new Partial();\n+        assertEquals(\"[]\", test.toString());\n+    }\n+\n+    public void testToString3() {\n+        Partial test = new Partial(DateTimeFieldType.year(), 2005);\n+        assertEquals(\"2005\", test.toString());\n+        \n+        test = test.with(DateTimeFieldType.monthOfYear(), 6);\n+        assertEquals(\"2005-06\", test.toString());\n+        \n+        test = test.with(DateTimeFieldType.dayOfMonth(), 25);\n+        assertEquals(\"2005-06-25\", test.toString());\n+        \n+        test = test.without(DateTimeFieldType.monthOfYear());\n+        assertEquals(\"2005--25\", test.toString());\n+    }\n+\n+    public void testToString4() {\n+        Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5);\n+        assertEquals(\"-W-5\", test.toString());\n+        \n+        test = test.with(DateTimeFieldType.dayOfMonth(), 13);\n+        assertEquals(\"[dayOfMonth=13, dayOfWeek=5]\", test.toString());\n+    }\n+\n+    public void testToString5() {\n+        Partial test = new Partial(DateTimeFieldType.era(), 1);\n+        assertEquals(\"[era=1]\", test.toString());\n+        \n+        test = test.with(DateTimeFieldType.halfdayOfDay(), 0);\n+        assertEquals(\"[era=1, halfdayOfDay=0]\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"10:20\", test.toString((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(\"10 20\", test.toString(\"H m\", Locale.ENGLISH));\n+        assertEquals(\"10:20\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"10 20\", test.toString(\"H m\", null));\n+        assertEquals(\"10:20\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_DTFormatter() {\n+        Partial test = createHourMinPartial();\n+        assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n+        assertEquals(\"10:20\", test.toString((DateTimeFormatter) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private Partial createHourMinPartial() {\n+        return createHourMinPartial(ISO_UTC);\n+    }\n+\n+    private Partial createHourMinPartial(Chronology chrono) {\n+        return createHourMinPartial(10, 20, chrono);\n+    }\n+\n+    private Partial createHourMinPartial2(Chronology chrono) {\n+        return createHourMinPartial(15, 20, chrono);\n+    }\n+\n+    private Partial createHourMinPartial(int hour, int min, Chronology chrono) {\n+        return new Partial(\n+            new DateTimeFieldType[] {DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour()},\n+            new int[] {hour, min},\n+            chrono);\n+    }\n+\n+    private Partial createTODPartial(Chronology chrono) {\n+        return new Partial(\n+            new DateTimeFieldType[] {\n+                    DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(),\n+                    DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond()},\n+            new int[] {10, 20, 30, 40},\n+            chrono);\n+    }\n+\n+    private void check(Partial test, int hour, int min) {\n+        assertEquals(test.toString(), hour, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(test.toString(), min, test.get(DateTimeFieldType.minuteOfHour()));\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestPartial_Constructors.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for Partial.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestPartial_Constructors extends TestCase {\n+\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+    private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);\n+    private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();\n+    private static final int OFFSET = 1;\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestPartial_Constructors.class);\n+    }\n+\n+    public TestPartial_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor() throws Throwable {\n+        Partial test = new Partial();\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(0, test.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_Chrono() throws Throwable {\n+        Partial test = new Partial((Chronology) null);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(0, test.size());\n+        \n+        test = new Partial(GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(0, test.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_Type_int() throws Throwable {\n+        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1, test.size());\n+        assertEquals(4, test.getValue(0));\n+        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx1_Type_int() throws Throwable {\n+        try {\n+            new Partial(null, 4);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx2_Type_int() throws Throwable {\n+        try {\n+            new Partial(DateTimeFieldType.dayOfYear(), 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_Type_int_Chrono() throws Throwable {\n+        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1, test.size());\n+        assertEquals(4, test.getValue(0));\n+        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx_Type_int_Chrono() throws Throwable {\n+        try {\n+            new Partial(null, 4, ISO_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx2_Type_int_Chrono() throws Throwable {\n+        try {\n+            new Partial(DateTimeFieldType.dayOfYear(), 0, ISO_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_TypeArray_intArray() throws Throwable {\n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(),\n+            DateTimeFieldType.dayOfYear()\n+        };\n+        int[] values = new int[] {2005, 33};\n+        Partial test = new Partial(types, values);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(2, test.size());\n+        assertEquals(2005, test.getValue(0));\n+        assertEquals(2005, test.get(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(33, test.getValue(1));\n+        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n+        assertEquals(true, Arrays.equals(test.getValues(), values));\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor2_TypeArray_intArray() throws Throwable {\n+        DateTimeFieldType[] types = new DateTimeFieldType[0];\n+        int[] values = new int[0];\n+        Partial test = new Partial(types, values);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(0, test.size());\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx1_TypeArray_intArray() throws Throwable {\n+        try {\n+            new Partial((DateTimeFieldType[]) null, new int[] {1});\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx3_TypeArray_intArray() throws Throwable {\n+        try {\n+            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx5_TypeArray_intArray() throws Throwable {\n+        try {\n+            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, new int[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"same length\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx6_TypeArray_intArray() throws Throwable {\n+        try {\n+            new Partial(new DateTimeFieldType[] {null, DateTimeFieldType.dayOfYear()}, new int[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"contain null\");\n+        }\n+        try {\n+            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear(), null}, new int[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"contain null\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n+        int[] values = new int[] {1, 1, 1};\n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx8_TypeArray_intArray() throws Throwable {\n+        int[] values = new int[] {1, 1, 1};\n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not\", \"duplicate\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.era(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not\", \"duplicate\");\n+        }\n+        \n+        types = new DateTimeFieldType[] {\n+            DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth() };\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not\", \"duplicate\");\n+        }\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx9_TypeArray_intArray() throws Throwable {\n+        int[] values = new int[] {3, 0};\n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek()};\n+        try {\n+            new Partial(types, values);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_TypeArray_intArray_Chrono() throws Throwable {\n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(),\n+            DateTimeFieldType.dayOfYear()\n+        };\n+        int[] values = new int[] {2005, 33};\n+        Partial test = new Partial(types, values, GREGORIAN_PARIS);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(2, test.size());\n+        assertEquals(2005, test.getValue(0));\n+        assertEquals(2005, test.get(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(33, test.getValue(1));\n+        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n+        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n+        assertEquals(true, Arrays.equals(test.getValues(), values));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructor_Partial() throws Throwable {\n+        YearMonthDay ymd = new YearMonthDay(2005, 6, 25, GREGORIAN_PARIS);\n+        Partial test = new Partial(ymd);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(3, test.size());\n+        assertEquals(2005, test.getValue(0));\n+        assertEquals(2005, test.get(DateTimeFieldType.year()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n+        assertEquals(6, test.getValue(1));\n+        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n+        assertEquals(25, test.getValue(2));\n+        assertEquals(25, test.get(DateTimeFieldType.dayOfMonth()));\n+        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n+    }\n+\n+    /**\n+     * Test constructor\n+     */\n+    public void testConstructorEx_Partial() throws Throwable {\n+        try {\n+            new Partial((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertMessageContains(ex, \"must not be null\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the exception message is valid.\n+     * \n+     * @param ex  the exception to check\n+     * @param str  the string to check\n+     */\n+    private void assertMessageContains(Exception ex, String str) {\n+        assertEquals(ex.getMessage() + \": \" + str, true, ex.getMessage().indexOf(str) >= 0);\n+    }\n+\n+    /**\n+     * Checks if the exception message is valid.\n+     * \n+     * @param ex  the exception to check\n+     * @param str1  the string to check\n+     * @param str2  the string to check\n+     */\n+    private void assertMessageContains(Exception ex, String str1, String str2) {\n+        assertEquals(ex.getMessage() + \": \" + str1 + \"/\" + str2, true,\n+            ex.getMessage().indexOf(str1) >= 0 &&\n+            ex.getMessage().indexOf(str2) >= 0 &&\n+            ex.getMessage().indexOf(str1) < ex.getMessage().indexOf(str2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestPartial_Properties.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Partial.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestPartial_Properties extends TestCase {\n+\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    \n+    private DateTimeZone zone = null;\n+    private static final DateTimeFieldType[] TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.hourOfDay(),\n+        DateTimeFieldType.minuteOfHour(),\n+        DateTimeFieldType.secondOfMinute(),\n+        DateTimeFieldType.millisOfSecond()\n+    };\n+    private static final int[] VALUES = new int[] {10, 20, 30, 40};\n+    private static final int[] VALUES1 = new int[] {1, 2, 3, 4};\n+    private static final int[] VALUES2 = new int[] {5, 6, 7, 8};\n+\n+//    private long TEST_TIME_NOW =\n+//        10L * DateTimeConstants.MILLIS_PER_HOUR\n+//        + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+//        + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+//        + 40L;\n+//        \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestPartial_Properties.class);\n+    }\n+\n+    public TestPartial_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        assertSame(test.getChronology().hourOfDay(), test.property(DateTimeFieldType.hourOfDay()).getField());\n+        assertEquals(\"hourOfDay\", test.property(DateTimeFieldType.hourOfDay()).getName());\n+        assertEquals(\"Property[hourOfDay]\", test.property(DateTimeFieldType.hourOfDay()).toString());\n+        assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getReadablePartial());\n+        assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getPartial());\n+        assertEquals(10, test.property(DateTimeFieldType.hourOfDay()).get());\n+        assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsString());\n+        assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsText());\n+        assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsText(Locale.FRENCH));\n+        assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsShortText());\n+        assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.hourOfDay()).getDurationField());\n+        assertEquals(test.getChronology().days(), test.property(DateTimeFieldType.hourOfDay()).getRangeDurationField());\n+        assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumTextLength(null));\n+        assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValue());\n+        assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValueOverall());\n+        assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValue());\n+        assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValueOverall());\n+    }\n+\n+//    public void testPropertyAddHour() {\n+//        Partial test = new Partial(TYPES, VALUES);\n+//        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9);\n+//        check(test, 10, 20, 30, 40);\n+//        check(copy, 19, 20, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0);\n+//        check(copy, 10, 20, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13);\n+//        check(copy, 23, 20, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(14);\n+//        check(copy, 0, 20, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10);\n+//        check(copy, 0, 20, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11);\n+//        check(copy, 23, 20, 30, 40);\n+//    }\n+//\n+    public void testPropertyAddHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13);\n+        check(copy, 23, 20, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.hourOfDay()).addToCopy(14);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10);\n+        check(copy, 0, 20, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 19, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(0);\n+        check(copy, 10, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(18);\n+        check(copy, 4, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(-15);\n+        check(copy, 19, 20, 30, 40);\n+    }\n+\n+    public void testPropertySetHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.hourOfDay()).setCopy(24);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(DateTimeFieldType.hourOfDay()).setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextHour() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 12, 20, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToHour() {\n+        Partial test1 = new Partial(TYPES, VALUES1);\n+        Partial test2 = new Partial(TYPES, VALUES2);\n+        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test2) < 0);\n+        assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(test1) > 0);\n+        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test1) == 0);\n+        try {\n+            test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt2) < 0);\n+        assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) > 0);\n+        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) == 0);\n+        try {\n+            test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        assertSame(test.getChronology().minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()).getField());\n+        assertEquals(\"minuteOfHour\", test.property(DateTimeFieldType.minuteOfHour()).getName());\n+        assertEquals(\"Property[minuteOfHour]\", test.property(DateTimeFieldType.minuteOfHour()).toString());\n+        assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getReadablePartial());\n+        assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getPartial());\n+        assertEquals(20, test.property(DateTimeFieldType.minuteOfHour()).get());\n+        assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsString());\n+        assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsText());\n+        assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsText(Locale.FRENCH));\n+        assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText());\n+        assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().minutes(), test.property(DateTimeFieldType.minuteOfHour()).getDurationField());\n+        assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.minuteOfHour()).getRangeDurationField());\n+        assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumTextLength(null));\n+        assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValue());\n+        assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValueOverall());\n+        assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValue());\n+        assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValueOverall());\n+    }\n+\n+//    public void testPropertyAddMinute() {\n+//        Partial test = new Partial(TYPES, VALUES);\n+//        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9);\n+//        check(test, 10, 20, 30, 40);\n+//        check(copy, 10, 29, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39);\n+//        check(copy, 10, 59, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40);\n+//        check(copy, 11, 0, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45);\n+//        check(copy, 12, 5, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39);\n+//        check(copy, 23, 59, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40);\n+//        check(copy, 0, 0, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9);\n+//        check(copy, 10, 11, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19);\n+//        check(copy, 10, 1, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20);\n+//        check(copy, 10, 0, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21);\n+//        check(copy, 9, 59, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20));\n+//        check(copy, 0, 0, 30, 40);\n+//        \n+//        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21));\n+//        check(copy, 23, 59, 30, 40);\n+//    }\n+\n+    public void testPropertyAddMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39);\n+        check(copy, 10, 59, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40);\n+        check(copy, 11, 0, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45);\n+        check(copy, 12, 5, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39);\n+        check(copy, 23, 59, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9);\n+        check(copy, 10, 11, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19);\n+        check(copy, 10, 1, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20);\n+        check(copy, 10, 0, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21);\n+        check(copy, 9, 59, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20));\n+        check(copy, 0, 0, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        check(test, 10, 20, 30, 40);\n+    }\n+\n+    public void testPropertyAddWrapFieldMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(9);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 29, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(49);\n+        check(copy, 10, 9, 30, 40);\n+        \n+        copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(-47);\n+        check(copy, 10, 33, 30, 40);\n+    }\n+\n+    public void testPropertySetMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy(12);\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+        \n+        try {\n+            test.property(DateTimeFieldType.minuteOfHour()).setCopy(60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.property(DateTimeFieldType.minuteOfHour()).setCopy(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertySetTextMinute() {\n+        Partial test = new Partial(TYPES, VALUES);\n+        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy(\"12\");\n+        check(test, 10, 20, 30, 40);\n+        check(copy, 10, 12, 30, 40);\n+    }\n+\n+    public void testPropertyCompareToMinute() {\n+        Partial test1 = new Partial(TYPES, VALUES1);\n+        Partial test2 = new Partial(TYPES, VALUES2);\n+        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test2) < 0);\n+        assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) > 0);\n+        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) == 0);\n+        try {\n+            test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadablePartial) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt2) < 0);\n+        assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) > 0);\n+        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) == 0);\n+        try {\n+            test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(Partial test, int hour, int min, int sec, int milli) {\n+        assertEquals(hour, test.get(DateTimeFieldType.hourOfDay()));\n+        assertEquals(min, test.get(DateTimeFieldType.minuteOfHour()));\n+        assertEquals(sec, test.get(DateTimeFieldType.secondOfMinute()));\n+        assertEquals(milli, test.get(DateTimeFieldType.millisOfSecond()));\n+    }\n+}", "timestamp": 1119828576, "metainfo": ""}