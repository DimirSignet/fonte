{"sha": "233ac67186840969dadbc86b371ad15c673ed0ca", "log": "Add chronology to interval   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n     /** Serialization version */\n     private static final long serialVersionUID = 4922451897541386752L;\n \n-    /**\n-     * Constructs an interval from a start and end instant.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an interval from a start and end instant with the ISO default chronology.\n      * \n      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public Interval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with a chronology.\n+     * \n+     * @param chronology  the chronology to use, null is ISO default\n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public Interval(long startInstant, long endInstant, Chronology chronology) {\n+        super(startInstant, endInstant, chronology);\n     }\n \n     /**\n      * Constructs an interval from a start and end instant.\n+     * <p>\n+     * The chronology used is that of the start instant.\n      * \n      * @param start  start of this interval, null means now\n      * @param end  end of this interval, null means now\n     }\n \n     /**\n-     * Constructs a time interval as a copy of another.\n+     * Constructs a time interval by converting or copying from another object.\n      * \n      * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null or invalid\n+     * @throws IllegalArgumentException if the interval is invalid\n      */\n     public Interval(Object interval) {\n-        super(interval);\n+        super(interval, null);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object,\n+     * overriding the chronology.\n+     * \n+     * @param interval  the time interval to copy\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public Interval(Object interval, Chronology chronology) {\n+        super(interval, chronology);\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the same start and end, but a different chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @return an interval with a different chronology\n+     */\n+    public Interval withChronology(Chronology chronology) {\n+        if (getChronology() == chronology) {\n+            return this;\n+        }\n+        return new Interval(getStartMillis(), getEndMillis(), chronology);\n+    }\n+\n     /**\n      * Creates a new interval with the specified start millisecond instant.\n      *\n      * @return an interval with the end from this interval and the specified start\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public Interval withStartInstant(ReadableInstant start) {\n+    public Interval withStart(ReadableInstant start) {\n         long startMillis = DateTimeUtils.getInstantMillis(start);\n         return withStartMillis(startMillis);\n     }\n     }\n \n     /**\n-     * Creates a new interval with the specified start instant.\n+     * Creates a new interval with the specified end instant.\n      *\n      * @param end  the end instant for the new interval, null means now\n      * @return an interval with the start from this interval and the specified end\n      * @throws IllegalArgumentException if the resulting interval has end before start\n      */\n-    public Interval withEndInstant(ReadableInstant end) {\n+    public Interval withEnd(ReadableInstant end) {\n         long endMillis = DateTimeUtils.getInstantMillis(end);\n         return withEndMillis(endMillis);\n     }\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n     /** Serialization version */\n     private static final long serialVersionUID = -5982824024992428470L;\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.\n      */\n     public MutableInterval() {\n-        super(0L, 0L);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start and end instant.\n+        super(0L, 0L, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with the ISO default chronology.\n      * \n      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public MutableInterval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with a chronology.\n+     * \n+     * @param chronology  the chronology to use, null is ISO default\n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public MutableInterval(long startInstant, long endInstant, Chronology chronology) {\n+        super(startInstant, endInstant, chronology);\n     }\n \n     /**\n      * Constructs an interval from a start and end instant.\n+     * <p>\n+     * The chronology used is that of the start instant.\n      * \n      * @param start  start of this interval, null means now\n      * @param end  end of this interval, null means now\n     }\n \n     /**\n-     * Constructs a time interval as a copy of another.\n+     * Constructs a time interval by converting or copying from another object.\n      * \n      * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null or invalid\n+     * @throws IllegalArgumentException if the interval is invalid\n      */\n     public MutableInterval(Object interval) {\n-        super(interval);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    // NOTE: All updates go via setInterval(long,long), setStartMillis(long)\n-    // or setEndMillis(long) on this class\n-    \n-    /**\n-     * Sets this interval from two millisecond instants.\n+        super(interval, null);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object,\n+     * overriding the chronology.\n+     * \n+     * @param interval  the time interval to copy\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public MutableInterval(Object interval, Chronology chronology) {\n+        super(interval, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets this interval from two millisecond instants retaining the chronology.\n      *\n      * @param startInstant  the start of the time interval\n      * @param endInstant  the start of the time interval\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setInterval(long startInstant, long endInstant) {\n-        super.setInterval(startInstant, endInstant);\n+        super.setInterval(startInstant, endInstant, getChronology());\n     }\n \n     /**\n         }\n         long startMillis = interval.getStartMillis();\n         long endMillis = interval.getEndMillis();\n-        setInterval(startMillis, endMillis);\n-    }\n-\n-    /**\n-     * Sets this interval from two instants.\n+        Chronology chrono = interval.getChronology();\n+        super.setInterval(startMillis, endMillis, chrono);\n+    }\n+\n+    /**\n+     * Sets this interval from two instants, replacing the chronology with\n+     * that from the start instant.\n      *\n      * @param start  the start of the time interval\n      * @param end  the start of the time interval\n         } else {\n             long startMillis = DateTimeUtils.getInstantMillis(start);\n             long endMillis = DateTimeUtils.getInstantMillis(end);\n-            setInterval(startMillis, endMillis);\n+            Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+            super.setInterval(startMillis, endMillis, chrono);\n         }\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Sets the chronology of this time interval.\n+     *\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setChronology(Chronology chrono) {\n+        super.setInterval(getStartMillis(), getEndMillis(), chrono);\n+    }\n+\n     /**\n      * Sets the start of this time interval.\n      *\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setStartMillis(long startInstant) {\n-        super.setStartMillis(startInstant);\n+        super.setInterval(startInstant, getEndMillis(), getChronology());\n     }\n \n     /**\n      * @param start  the start of the time interval, null means now\n      * @throws IllegalArgumentException if the end is before the start\n      */\n-    public void setStartInstant(ReadableInstant start) {\n+    public void setStart(ReadableInstant start) {\n         long startMillis = DateTimeUtils.getInstantMillis(start);\n-        setStartMillis(startMillis);\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        super.setInterval(startMillis, getEndMillis(), getChronology());\n+    }\n+\n     /** \n      * Sets the end of this time interval.\n      *\n      * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setEndMillis(long endInstant) {\n-        super.setEndMillis(endInstant);\n+        super.setInterval(getStartMillis(), endInstant, getChronology());\n     }\n \n     /** \n      * @param end  the end of the time interval, null means now\n      * @throws IllegalArgumentException if the end is before the start\n      */\n-    public void setEndInstant(ReadableInstant end) {\n+    public void setEnd(ReadableInstant end) {\n         long endMillis = DateTimeUtils.getInstantMillis(end);\n-        setEndMillis(endMillis);\n+        super.setInterval(getStartMillis(), endMillis, getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public void setPeriodAfterStart(ReadablePeriod period) {\n-        setPeriodAfterStart(period, null);\n-    }\n-\n-    /**\n-     * Sets the period of this time interval, preserving the start instant.\n-     *\n-     * @param period  new period for interval, null means zero length\n-     * @param chrono  the chronology to add using, null means ISO default\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    public void setPeriodAfterStart(ReadablePeriod period, Chronology chrono) {\n         if (period == null) {\n             setEndMillis(getStartMillis());\n         } else {\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            setEndMillis(chrono.add(getStartMillis(), period, 1));\n+            setEndMillis(getChronology().add(getStartMillis(), period, 1));\n         }\n     }\n \n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public void setPeriodBeforeEnd(ReadablePeriod period) {\n-        setPeriodBeforeEnd(period, null);\n-    }\n-\n-    /**\n-     * Sets the period of this time interval, preserving the end instant.\n-     *\n-     * @param period  new period for interval, null means zero length\n-     * @param chrono  the chronology to add using, null means ISO default\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    public void setPeriodBeforeEnd(ReadablePeriod period, Chronology chrono) {\n         if (period == null) {\n             setStartMillis(getEndMillis());\n         } else {\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            setStartMillis(chrono.add(getEndMillis(), period, -1));\n+            setStartMillis(getChronology().add(getEndMillis(), period, -1));\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Sets the chronology of this time interval.\n+     *\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setChronology(Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Sets the start of this time interval.\n      *\n      * @param millisInstant  the start of the time interval,\n      * @param instant  the start of the time interval\n      * @throws IllegalArgumentException if the end is before the start\n      */\n-    void setStartInstant(ReadableInstant instant);\n+    void setStart(ReadableInstant instant);\n \n     //-----------------------------------------------------------------------\n     /** \n      * @param instant  the end of the time interval\n      * @throws IllegalArgumentException if the end is before the start\n      */\n-    void setEndInstant(ReadableInstant instant);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the duration of this time interval, preserving the start instant.\n-     *\n-     * @param millisDuration  new duration for interval\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    void setDurationAfterStart(long millisDuration);\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the end instant.\n-     *\n-     * @param millisDuration  new duration for interval\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    void setDurationBeforeEnd(long millisDuration);\n+    void setEnd(ReadableInstant instant);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Sets the period of this time interval, preserving the start instant.\n      *\n      * @param period  new period for interval, null means zero length\n-     * @param chrono  the chronology to add using, null means ISO default\n      * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    void setPeriodAfterStart(ReadablePeriod period, Chronology chrono);\n+    void setPeriodAfterStart(ReadablePeriod period);\n \n     /**\n      * Sets the period of this time interval, preserving the end instant.\n      *\n      * @param period  new period for interval, null means zero length\n-     * @param chrono  the chronology to add using, null means ISO default\n      * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    void setPeriodBeforeEnd(ReadablePeriod period, Chronology chrono);\n+    void setPeriodBeforeEnd(ReadablePeriod period);\n \n }\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n public interface ReadableInterval {\n \n     /**\n+     * Gets the chronology of the interval, which is the chronology of the first datetime.\n+     *\n+     * @return the chronology of the interval\n+     */\n+    Chronology getChronology();\n+\n+    /**\n      * Gets the start of this time interval which is inclusive.\n      *\n      * @return the start of the time interval,\n     long getStartMillis();\n \n     /**\n-     * Gets the start of this time interval, which is inclusive, as an Instant.\n+     * Gets the start of this time interval, which is inclusive, as a DateTime.\n      *\n      * @return the start of the time interval\n      */\n-    Instant getStartInstant();\n+    DateTime getStart();\n \n     /** \n      * Gets the end of this time interval which is exclusive.\n     long getEndMillis();\n \n     /** \n-     * Gets the end of this time interval, which is exclusive, as an Instant.\n+     * Gets the end of this time interval, which is exclusive, as a DateTime.\n      *\n      * @return the end of the time interval\n      */\n-    Instant getEndInstant();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the duration of this time interval in milliseconds.\n-     * <p>\n-     * The duration is equal to the end millis minus the start millis.\n-     *\n-     * @return the duration of the time interval in milliseconds\n-     * @throws ArithmeticException if the duration exceeds the capacity of a long\n-     */\n-    long getDurationMillis();\n-\n+    DateTime getEnd();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant, null means now\n+     * @return true if this time interval contains the instant\n+     */\n+    boolean contains(ReadableInstant instant);\n+    \n+    /**\n+     * Does this time interval contain the specified time interval completely.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the time interval to compare to, null means now\n+     * @return true if this time interval contains the time interval\n+     */\n+    boolean contains(ReadableInterval interval);\n+    \n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * The intervals overlap if at least some of the time interval is in common.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the time interval to compare to, null means now\n+     * @return true if the time intervals overlap\n+     */\n+    boolean overlaps(ReadableInterval interval);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval after the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is after the instant\n+     */\n+    boolean isAfter(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval entirely after the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is after the interval specified\n+     */\n+    boolean isAfter(ReadableInterval interval);\n+    \n+    /**\n+     * Is this time interval before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is before the instant\n+     */\n+    boolean isBefore(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval entirely before the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is before the interval specified\n+     */\n+    boolean isBefore(ReadableInterval interval);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this interval as an immutable <code>Interval</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Interval</code>.\n+     *\n+     * @return the interval as an Interval object\n+     */\n+    Interval toInterval();\n+\n+    /**\n+     * Get this time interval as a <code>MutableInterval</code>.\n+     * <p>\n+     * This will always return a new <code>MutableInterval</code> with the same interval.\n+     *\n+     * @return the time interval as a MutableInterval object\n+     */\n+    MutableInterval toMutableInterval();\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the millisecond duration of this time interval.\n-     * <p>\n-     * If this interval was constructed using a Duration then that object will\n-     * be returned. Otherwise a new Duration instance is returned.\n      *\n      * @return the millisecond duration of the time interval\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    Duration getDuration();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Does this time interval contain the specified instant.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param instant  the instant, null means now\n-     * @return true if this time interval contains the instant\n-     */\n-    boolean contains(ReadableInstant instant);\n-    \n-    /**\n-     * Does this time interval contain the specified time interval completely.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param interval  the time interval to compare to, null means now\n-     * @return true if this time interval contains the time interval\n-     */\n-    boolean contains(ReadableInterval interval);\n-    \n-    /**\n-     * Does this time interval overlap the specified time interval.\n-     * <p>\n-     * The intervals overlap if at least some of the time interval is in common.\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param interval  the time interval to compare to, null means now\n-     * @return true if the time intervals overlap\n-     */\n-    boolean overlaps(ReadableInterval interval);\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Is this time interval after the specified instant.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param instant  the instant to compare to, null means now\n-     * @return true if this time interval is after the instant\n-     */\n-    boolean isAfter(ReadableInstant instant);\n-    \n-    /**\n-     * Is this time interval entirely after the specified interval.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param interval  the interval to compare to, null means now\n-     * @return true if this time interval is after the interval specified\n-     */\n-    boolean isAfter(ReadableInterval interval);\n-    \n-    /**\n-     * Is this time interval before the specified instant.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param instant  the instant to compare to, null means now\n-     * @return true if this time interval is before the instant\n-     */\n-    boolean isBefore(ReadableInstant instant);\n-    \n-    /**\n-     * Is this time interval entirely before the specified interval.\n-     * <p>\n-     * Intervals are inclusive of the start instant and exclusive of the end.\n-     * \n-     * @param interval  the interval to compare to, null means now\n-     * @return true if this time interval is before the interval specified\n-     */\n-    boolean isBefore(ReadableInterval interval);\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Get this interval as an immutable <code>Interval</code> object.\n-     * <p>\n-     * This will either typecast this instance, or create a new <code>Interval</code>.\n-     *\n-     * @return the interval as an Interval object\n-     */\n-    Interval toInterval();\n-\n-    /**\n-     * Get this time interval as a <code>MutableInterval</code>.\n-     * <p>\n-     * This will always return a new <code>MutableInterval</code> with the same interval.\n-     *\n-     * @return the time interval as a MutableInterval object\n-     */\n-    MutableInterval toMutableInterval();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts the duration of the interval to a <code>Period</code> using the\n-     * All period type.\n+    Duration toDuration();\n+\n+    /**\n+     * Gets the millisecond duration of this time interval.\n+     *\n+     * @return the millisecond duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    long toDurationMillis();\n+\n+    /**\n+     * Converts the duration of the interval to a period using the\n+     * standard period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n-     * The time period may not be precise - if you want the millisecond duration\n-     * then you should use {@link #getDuration()}.\n      *\n      * @return a time period derived from the interval\n      */\n     Period toPeriod();\n \n     /**\n-     * Converts the duration of the interval to a <code>Period</code> using the\n+     * Converts the duration of the interval to a period using the\n      * specified period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n-     * The time period may not be precise - if you want the millisecond duration\n-     * then you should use {@link #getDuration()}.\n-     *\n-     * @param type  the requested type of the duration, null means AllType\n+     *\n+     * @param type  the requested type of the duration, null means standard\n      * @return a time period derived from the interval\n      */\n     Period toPeriod(PeriodType type);\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n-     * on start and end millis. All ReadableInterval instances are accepted.\n+     * on start and end millis plus the chronology.\n+     * All ReadableInterval instances are accepted.\n      * <p>\n      * To compare the duration of two time intervals, use {@link #getDuration()}\n      * to get the durations and compare those.\n      * <pre>int result = 97;\n      * result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));\n      * result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));\n+     * result = 31 * result + getChronology().hashCode();\n      * return result;</pre>\n      *\n      * @return a hash code\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n  */\n package org.joda.time.base;\n \n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.Duration;\n-import org.joda.time.Instant;\n import org.joda.time.Interval;\n import org.joda.time.MutableInterval;\n import org.joda.time.Period;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the start of this time interval, which is inclusive, as an Instant.\n+     * Gets the start of this time interval, which is inclusive, as a DateTime.\n      *\n      * @return the start of the time interval\n      */\n-    public Instant getStartInstant() {\n-        return new Instant(getStartMillis());\n+    public DateTime getStart() {\n+        return new DateTime(getStartMillis(), getChronology());\n     }\n \n     /** \n-     * Gets the end of this time interval, which is exclusive, as an Instant.\n+     * Gets the end of this time interval, which is exclusive, as a DateTime.\n      *\n      * @return the end of the time interval\n      */\n-    public Instant getEndInstant() {\n-        return new Instant(getEndMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the duration of this time interval in milliseconds.\n-     * <p>\n-     * The duration is equal to the end millis minus the start millis.\n-     *\n-     * @return the duration of the time interval in milliseconds\n-     * @throws ArithmeticException if the duration exceeds the capacity of a long\n-     */\n-    public long getDurationMillis() {\n-        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n-    }\n-\n-    /**\n-     * Gets a <code>Duration</code> holding the millisecond duration of this time interval.\n-     *\n-     * @return the duration of the time interval\n-     * @throws ArithmeticException if the duration exceeds the capacity of a long\n-     */\n-    public Duration getDuration() {\n-        long durMillis = getDurationMillis();\n-        if (durMillis == 0) {\n-            return Duration.ZERO;\n-        } else {\n-            return new Duration(durMillis);\n-        }\n+    public DateTime getEnd() {\n+        return new DateTime(getEndMillis(), getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the duration of this time interval in milliseconds.\n+     * <p>\n+     * The duration is equal to the end millis minus the start millis.\n+     *\n+     * @return the duration of the time interval in milliseconds\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public long toDurationMillis() {\n+        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n+    }\n+\n+    /**\n+     * Gets the duration of this time interval.\n+     * <p>\n+     * The duration is equal to the end millis minus the start millis.\n+     *\n+     * @return the duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public Duration toDuration() {\n+        long durMillis = toDurationMillis();\n+        if (durMillis == 0) {\n+            return Duration.ZERO;\n+        } else {\n+            return new Duration(durMillis);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Converts the duration of the interval to a <code>Period</code> using the\n      * All period type.\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n-     * The time period may not be precise - if you want the millisecond duration\n-     * then you should use {@link #getDuration()}.\n      *\n      * @return a time period derived from the interval\n      */\n      * <p>\n      * This method should be used to exract the field values describing the\n      * difference between the start and end instants.\n-     * The time period may not be precise - if you want the millisecond duration\n-     * then you should use {@link #getDuration()}.\n      *\n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n-     * on start and end millis. All ReadableInterval instances are accepted.\n+     * on start and end millis plus the chronology.\n+     * All ReadableInterval instances are accepted.\n      * <p>\n      * To compare the duration of two time intervals, use {@link #getDuration()}\n      * to get the durations and compare those.\n         }\n         ReadableInterval other = (ReadableInterval) readableInterval;\n         return (getStartMillis() == other.getStartMillis() &&\n-                getEndMillis() == other.getEndMillis());\n+                getEndMillis() == other.getEndMillis() &&\n+                getChronology() == other.getChronology());\n     }\n \n     /**\n         int result = 97;\n         result = 31 * result + ((int) (start ^ (start >>> 32)));\n         result = 31 * result + ((int) (end ^ (end >>> 32)));\n+        result = 31 * result + getChronology().hashCode();\n         return result;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/base/BaseInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseInterval.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n+import org.joda.time.MutableInterval;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDuration;\n import org.joda.time.ReadableInstant;\n     /** Serialization version */\n     private static final long serialVersionUID = 576586928732749278L;\n \n+    /** The chronology of the interval */\n+    private Chronology iChronology;\n     /** The start of the interval */\n     private long iStartMillis;\n     /** The end of the interval */\n      * \n      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n-     * @throws IllegalArgumentException if the end is before the start\n-     */\n-    protected BaseInterval(long startInstant, long endInstant) {\n-        super();\n+     * @param chrono  the chronology to use, null is ISO default\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected BaseInterval(long startInstant, long endInstant, Chronology chrono) {\n+        super();\n+        iChronology = DateTimeUtils.getChronology(chrono);\n         checkInterval(startInstant, endInstant);\n         iStartMillis = startInstant;\n         iEndMillis = endInstant;\n         super();\n         if (start == null && end == null) {\n             iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n+            iChronology = Chronology.getISO();\n+        } else {\n+            iChronology = DateTimeUtils.getInstantChronology(start);\n             iStartMillis = DateTimeUtils.getInstantMillis(start);\n             iEndMillis = DateTimeUtils.getInstantMillis(end);\n             checkInterval(iStartMillis, iEndMillis);\n      */\n     protected BaseInterval(ReadableInstant start, ReadableDuration duration) {\n         super();\n+        iChronology = DateTimeUtils.getInstantChronology(start);\n         iStartMillis = DateTimeUtils.getInstantMillis(start);\n         long durationMillis = DateTimeUtils.getDurationMillis(duration);\n         iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n      */\n     protected BaseInterval(ReadableDuration duration, ReadableInstant end) {\n         super();\n+        iChronology = DateTimeUtils.getInstantChronology(end);\n         iEndMillis = DateTimeUtils.getInstantMillis(end);\n         long durationMillis = DateTimeUtils.getDurationMillis(duration);\n         iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n      */\n     protected BaseInterval(ReadableInstant start, ReadablePeriod period) {\n         super();\n+        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+        iChronology = chrono;\n         iStartMillis = DateTimeUtils.getInstantMillis(start);\n         if (period == null) {\n             iEndMillis = iStartMillis;\n         } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(start);\n             iEndMillis = chrono.add(iStartMillis, period, 1);\n         }\n         checkInterval(iStartMillis, iEndMillis);\n      */\n     protected BaseInterval(ReadablePeriod period, ReadableInstant end) {\n         super();\n+        Chronology chrono = DateTimeUtils.getInstantChronology(end);\n+        iChronology = chrono;\n         iEndMillis = DateTimeUtils.getInstantMillis(end);\n         if (period == null) {\n             iStartMillis = iEndMillis;\n         } else {\n-            Chronology chrono = DateTimeUtils.getInstantChronology(end);\n             iStartMillis = chrono.add(iEndMillis, period, -1);\n         }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n-     * Constructs a time interval as a copy of another.\n+     * Constructs a time interval converting or copying from another object\n+     * that describes an interval.\n      * \n      * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null or invalid\n-     */\n-    protected BaseInterval(Object interval) {\n+     * @param chrono  the chronology to use, null means let converter decide\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    protected BaseInterval(Object interval, Chronology chrono) {\n         super();\n         IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n-        if (this instanceof ReadWritableInterval) {\n-            converter.setInto((ReadWritableInterval) this, interval);\n-        } else {\n-            long[] millis = converter.getIntervalMillis(interval);\n-            iStartMillis = millis[0];\n-            iEndMillis = millis[1];\n+        if (converter.isReadableInterval(interval, chrono)) {\n+            ReadableInterval input = (ReadableInterval) interval;\n+            iChronology = (chrono != null ? chrono : input.getChronology());\n+            iStartMillis = input.getStartMillis();\n+            iEndMillis = input.getEndMillis();\n+        } else if (this instanceof ReadWritableInterval) {\n+            converter.setInto((ReadWritableInterval) this, interval, chrono);\n+        } else {\n+            MutableInterval mi = new MutableInterval();\n+            converter.setInto(mi, interval, chrono);\n+            iChronology = mi.getChronology();\n+            iStartMillis = mi.getStartMillis();\n+            iEndMillis = mi.getEndMillis();\n         }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology of this interval.\n+     *\n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n     /**\n      * Gets the start of this time interval which is inclusive.\n      *\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Sets the start of this time interval which is inclusive.\n-     *\n-     * @param startInstant  the new start of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    protected void setStartMillis(long startInstant) {\n-        checkInterval(startInstant, iEndMillis);\n-        iStartMillis = startInstant;\n-    }\n-\n-    /**\n-     * Sets the end of this time interval which is exclusive.\n-     *\n-     * @param endInstant  the new end of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    protected void setEndMillis(long endInstant) {\n-        checkInterval(iStartMillis, endInstant);\n-        iEndMillis = endInstant;\n-    }\n-\n-    /**\n-     * Sets this interval from two millisecond instants.\n+     * Sets this interval from two millisecond instants and a chronology.\n      *\n      * @param startInstant  the start of the time interval\n      * @param endInstant  the start of the time interval\n-     * @throws IllegalArgumentException if the end is before the start\n-     */\n-    protected void setInterval(long startInstant, long endInstant) {\n+     * @param chrono  the chronology, not null\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected void setInterval(long startInstant, long endInstant, Chronology chrono) {\n         checkInterval(startInstant, endInstant);\n         iStartMillis = startInstant;\n         iEndMillis = endInstant;\n+        iChronology = DateTimeUtils.getChronology(chrono);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n+     *\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public boolean isReadableInterval(Object object, Chronology chrono) {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets a debugging string version of this converter.\n      * \n      * @return a debugging string\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  * <ul>\n  * <li>ReadableInterval\n  * <li>String\n+ * <li>null (zero-length from now to now)\n  * </ul>\n  *\n  * @author Stephen Colebourne\n         iIntervalConverters = new ConverterSet(new Converter[] {\n             ReadableIntervalConverter.INSTANCE,\n             StringConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n         });\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n import org.joda.time.ReadWritableInterval;\n \n /**\n public interface IntervalConverter extends Converter {\n \n     /**\n-     * Extracts the start and end millisecond instants from the object.\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n      *\n      * @param object  the object to convert, must not be null\n-     * @return the start millis and end millis in an array of size two\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n      * @throws ClassCastException if the object is invalid\n      */\n-    long[] getIntervalMillis(Object object);\n+    boolean isReadableInterval(Object object, Chronology chrono);\n \n     /**\n      * Extracts interval endpoint values from an object of this converter's\n      * type, and sets them into the given ReadWritableInterval.\n      *\n-     * @param interval interval to get modified\n+     * @param writableInterval  interval to get modified, not null\n      * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n      * @throws ClassCastException if the object is invalid\n      */\n-    void setInto(ReadWritableInterval interval, Object object);\n+    void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono);\n \n }\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.Period;\n+import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n \n /**\n  * @since 1.0\n  */\n class NullConverter extends AbstractConverter\n-        implements InstantConverter, DurationConverter, PeriodConverter {\n+        implements InstantConverter, DurationConverter, PeriodConverter, IntervalConverter {\n     \n     /**\n      * Singleton instance.\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param writableInterval interval to get modified, not null\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @throws NullPointerException if the interval is null\n+     */\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n+        writableInterval.setChronology(chrono);\n+        long now = DateTimeUtils.currentTimeMillis();\n+        writableInterval.setInterval(now, now);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns null.\n      * \n      * @return null\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n      * @param object  the interval\n      */\n     public long getDurationMillis(Object object) {\n-        return (((ReadableInterval) object)).getDurationMillis();\n+        return (((ReadableInterval) object)).toDurationMillis();\n     }\n \n     //-----------------------------------------------------------------------\n      * @param chrono  the chronology to use\n      */\n     public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n-        writablePeriod.setPeriod((ReadableInterval) object, chrono);\n+        ReadableInterval interval = (ReadableInterval) object;\n+        writablePeriod.setPeriod(interval, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Extracts the start and end millisecond instants from the object.\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n      *\n      * @param object  the object to convert, must not be null\n-     * @return the start millis and end millis in an array of size two\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n      * @throws ClassCastException if the object is invalid\n      */\n-    public long[] getIntervalMillis(Object object) {\n-        ReadableInterval interval = (ReadableInterval) object;\n-        return new long[] {interval.getStartMillis(), interval.getEndMillis()};\n+    public boolean isReadableInterval(Object object, Chronology chrono) {\n+        return true;\n     }\n \n     /**\n-     * Sets the values of the mutable interval from the specified interval.\n-     * \n-     * @param writableInterval  the interval to set\n-     * @param object  the interval to set from\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param writableInterval interval to get modified, not null\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @throws ClassCastException if the object is invalid\n      */\n-    public void setInto(ReadWritableInterval writableInterval, Object object) {\n-        ReadableInterval interval = (ReadableInterval) object;\n-        writableInterval.setInterval(interval);\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n+        ReadableInterval input = (ReadableInterval) object;\n+        writableInterval.setInterval(input);\n+        if (chrono != null) {\n+            writableInterval.setChronology(chrono);\n+        } else {\n+            writableInterval.setChronology(input.getChronology());\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.Period;\n import org.joda.time.ReadWritableInterval;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Extracts the start and end millisecond instants from the object.\n-     *\n-     * @param object  the object to convert, must not be null\n-     * @return the start millis and end millis in an array\n-     * @throws ClassCastException if the object is invalid\n-     */\n-    public long[] getIntervalMillis(Object object) {\n-        return parseInterval(null, object);\n-    }\n-\n-    /**\n      * Sets the value of the mutable interval from the string.\n      * \n      * @param writableInterval  the interval to set\n      * @param object  the string to set from\n-     */\n-    public void setInto(ReadWritableInterval writableInterval, Object object) {\n-        parseInterval(writableInterval, object);\n-    }\n-\n-    /**\n-     * Sets the value of the mutable interval from the string.\n-     * \n-     * @param writableInterval  the interval to populate, may be null\n-     * @param object  the string to set from\n-     * @return an array of size two, containing the start and end millis if interval input is null\n-     */\n-    private long[] parseInterval(ReadWritableInterval writableInterval, Object object) {\n+     * @param chrono  the chronology to use, may be null\n+     */\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n         String str = (String) object;\n \n         int separator = str.indexOf('/');\n \n         DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n         PeriodFormatter periodParser = ISOPeriodFormat.getInstance().standard();\n-        long startInstant, endInstant;\n-        Period period;\n+        long startInstant = 0, endInstant = 0;\n+        Period period = null;\n+        Chronology parsedChrono = null;\n         \n         // before slash\n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n-            startInstant = 0;\n             period = periodParser.parsePeriod(getPeriodType(leftStr), leftStr);\n         } else {\n-            startInstant = dateTimeParser.parseMillis(leftStr);\n-            period = null;\n+            DateTime start = dateTimeParser.parseDateTime(leftStr);\n+            startInstant = start.getMillis();\n+            parsedChrono = start.getChronology();\n         }\n         \n         // after slash\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n             period = periodParser.parsePeriod(getPeriodType(rightStr), rightStr);\n-            endInstant = ISOChronology.getInstance().add(startInstant, period, 1); // TODO\n-        } else {\n-            endInstant = dateTimeParser.parseMillis(rightStr);\n+            chrono = (chrono != null ? chrono : parsedChrono);\n+            endInstant = chrono.add(startInstant, period, 1);\n+        } else {\n+            DateTime end = dateTimeParser.parseDateTime(rightStr);\n+            endInstant = end.getMillis();\n+            parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n+            chrono = (chrono != null ? chrono : parsedChrono);\n             if (period != null) {\n-                startInstant = ISOChronology.getInstance().add(endInstant, period, -1); // TODO\n+                startInstant = chrono.add(endInstant, period, -1);\n             }\n         }\n         \n-        // return data avoiding object creation and code duplication\n-        if (writableInterval == null) {\n-            return new long[] {startInstant, endInstant};\n-        } else {\n-            writableInterval.setInterval(startInstant, endInstant);\n-            return null;\n-        }\n+        writableInterval.setInterval(startInstant, endInstant);\n+        writableInterval.setChronology(chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n     public void testGetMillis() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         assertEquals(TEST_TIME1, test.getStartMillis());\n-        assertEquals(TEST_TIME1, test.getStartInstant().getMillis());\n+        assertEquals(TEST_TIME1, test.getStart().getMillis());\n         assertEquals(TEST_TIME2, test.getEndMillis());\n-        assertEquals(TEST_TIME2, test.getEndInstant().getMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());\n+        assertEquals(TEST_TIME2, test.getEnd().getMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n     }\n \n     public void testGetDuration1() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n     }\n \n     public void testGetDuration2() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME1);\n-        assertSame(Duration.ZERO, test.getDuration());\n+        assertSame(Duration.ZERO, test.toDuration());\n     }\n \n     public void testEqualsHashCode() {\n         assertEquals(false, test1.hashCode() == test3.hashCode());\n         assertEquals(false, test2.hashCode() == test3.hashCode());\n         \n-        MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        assertEquals(true, test1.equals(test4));\n-        assertEquals(true, test2.equals(test4));\n-        assertEquals(false, test3.equals(test4));\n-        assertEquals(true, test4.equals(test1));\n-        assertEquals(true, test4.equals(test2));\n-        assertEquals(false, test4.equals(test3));\n-        assertEquals(true, test1.hashCode() == test4.hashCode());\n-        assertEquals(true, test2.hashCode() == test4.hashCode());\n-        assertEquals(false, test3.hashCode() == test4.hashCode());\n+        Interval test4 = new Interval(TEST_TIME1, TEST_TIME1, Chronology.getGJ());\n+        assertEquals(true, test4.equals(test4));\n+        assertEquals(false, test1.equals(test4));\n+        assertEquals(false, test2.equals(test4));\n+        assertEquals(false, test4.equals(test1));\n+        assertEquals(false, test4.equals(test2));\n+        assertEquals(false, test1.hashCode() == test4.hashCode());\n+        assertEquals(false, test2.hashCode() == test4.hashCode());\n+        \n+        MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        assertEquals(true, test1.equals(test5));\n+        assertEquals(true, test2.equals(test5));\n+        assertEquals(false, test3.equals(test5));\n+        assertEquals(true, test5.equals(test1));\n+        assertEquals(true, test5.equals(test2));\n+        assertEquals(false, test5.equals(test3));\n+        assertEquals(true, test1.hashCode() == test5.hashCode());\n+        assertEquals(true, test2.hashCode() == test5.hashCode());\n+        assertEquals(false, test3.hashCode() == test5.hashCode());\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockInterval()));\n     class MockInterval extends AbstractInterval {\n         public MockInterval() {\n             super();\n+        }\n+        public Chronology getChronology() {\n+            return Chronology.getISO();\n         }\n         public long getStartMillis() {\n             return TEST_TIME1;\n     //-----------------------------------------------------------------------\n     public void testWithStartInstant_RI1() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n-        Interval result = test.withStartInstant(new Instant(TEST_TIME1 - 1));\n+        Interval result = test.withStart(new Instant(TEST_TIME1 - 1));\n         assertEquals(TEST_TIME1 - 1, result.getStartMillis());\n         assertEquals(TEST_TIME2, result.getEndMillis());\n     }\n     public void testWithStartInstant_RI2() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         try {\n-            test.withStartInstant(new Instant(TEST_TIME2 + 1));\n+            test.withStart(new Instant(TEST_TIME2 + 1));\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n     public void testWithStartInstant_RI3() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n-        Interval result = test.withStartInstant(null);\n+        Interval result = test.withStart(null);\n         assertEquals(TEST_TIME_NOW, result.getStartMillis());\n         assertEquals(TEST_TIME2, result.getEndMillis());\n     }\n     //-----------------------------------------------------------------------\n     public void testWithEndInstant_RI1() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n-        Interval result = test.withEndInstant(new Instant(TEST_TIME2 - 1));\n+        Interval result = test.withEnd(new Instant(TEST_TIME2 - 1));\n         assertEquals(TEST_TIME1, result.getStartMillis());\n         assertEquals(TEST_TIME2 - 1, result.getEndMillis());\n     }\n     public void testWithEndInstant_RI2() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         try {\n-            test.withEndInstant(new Instant(TEST_TIME1 - 1));\n+            test.withEnd(new Instant(TEST_TIME1 - 1));\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n     public void testWithEndInstant_RI3() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n-        Interval result = test.withEndInstant(null);\n+        Interval result = test.withEnd(null);\n         assertEquals(TEST_TIME1, result.getStartMillis());\n         assertEquals(TEST_TIME_NOW, result.getEndMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n         Interval test = new Interval(dt1.getMillis(), dt2.getMillis());\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         Interval test = new Interval(dt1.getMillis(), dt1.getMillis());\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt1.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     public void testConstructor_long_long3() throws Throwable {\n             new Interval(dt1.getMillis(), dt2.getMillis());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_long_Chronology1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), Chronology.getGJ());\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getGJ(), test.getChronology());\n+    }\n+\n+    public void testConstructor_long_long_Chronology2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), null);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    public void testConstructor_RI_RI8() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getGJ());\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Interval test = new Interval(dt1, dt2);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getGJ(), test.getChronology());\n+    }\n+\n+    public void testConstructor_RI_RI9() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getGJ());\n+        Interval test = new Interval(dt1, dt2);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_RI_RP1() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n     }\n \n     public void testConstructor_RI_RP3() throws Throwable {\n-        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstanceUTC().months().add(result, 6);\n-        result = ISOChronology.getInstanceUTC().days().add(result, 3);\n-        result = ISOChronology.getInstanceUTC().hours().add(result, 1);\n+        result = Chronology.getISOUTC().months().add(result, 6);\n+        result = Chronology.getISOUTC().days().add(result, 3);\n+        result = Chronology.getISOUTC().hours().add(result, 1);\n         \n         Interval test = new Interval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n     }\n \n     public void testConstructor_RP_RI3() throws Throwable {\n-        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstanceUTC().months().add(result, -6);\n-        result = ISOChronology.getInstanceUTC().days().add(result, -3);\n-        result = ISOChronology.getInstanceUTC().hours().add(result, -1);\n+        result = Chronology.getISOUTC().months().add(result, -6);\n+        result = Chronology.getISOUTC().days().add(result, -3);\n+        result = Chronology.getISOUTC().hours().add(result, -1);\n         \n         Interval test = new Interval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Interval base = new Interval(dt1, dt2);\n-        Duration dur = base.getDuration();\n         \n         Interval test = new Interval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertNotSame(dur, test.getDuration());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableInterval base = new MutableInterval(dt1, dt2);\n-        Duration dur = base.getDuration();\n         \n         Interval test = new Interval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertNotSame(dur, test.getDuration());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n     public void testConstructor_Object5() throws Throwable {\n         IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(\"\");\n         IntervalConverter conv = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {\n-                return new long[] {1234L, 5678L};\n+            public boolean isReadableInterval(Object object, Chronology chrono) {\n+                return false;\n             }\n-            public void setInto(ReadWritableInterval interval, Object object) {\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {\n+                interval.setChronology(chrono);\n+                interval.setInterval(1234L, 5678L);\n             }\n             public Class getSupportedType() {\n                 return String.class;\n     public void testConstructor_Object6() throws Throwable {\n         IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 0L));\n         IntervalConverter conv = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {\n-                return new long[] {1234L, 5678L};\n+            public boolean isReadableInterval(Object object, Chronology chrono) {\n+                return false;\n             }\n-            public void setInto(ReadWritableInterval interval, Object object) {\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {\n+                interval.setChronology(chrono);\n+                interval.setInterval(1234L, 5678L);\n             }\n             public Class getSupportedType() {\n                 return ReadableInterval.class;\n         try {\n             ConverterManager.getInstance().addIntervalConverter(conv);\n             Interval base = new Interval(-1000L, 1000L);\n-            Duration dur = base.getDuration();\n             Interval test = new Interval(base);\n             assertEquals(1234L, test.getStartMillis());\n             assertEquals(5678L, test.getEndMillis());\n-            assertNotSame(dur, test.getDuration());\n         } finally {\n             ConverterManager.getInstance().addIntervalConverter(oldConv);\n         }\n     }\n \n     class MockInterval implements ReadableInterval {\n+        public Chronology getChronology() {\n+            return Chronology.getISO();\n+        }\n         public long getStartMillis() {\n             return 1234L;\n         }\n-        public Instant getStartInstant() {\n-            return new Instant(1234L);\n+        public DateTime getStart() {\n+            return new DateTime(1234L);\n         }\n         public long getEndMillis() {\n             return 5678L;\n         }\n-        public Instant getEndInstant() {\n-            return new Instant(5678L);\n-        }\n-        public long getDurationMillis() {\n+        public DateTime getEnd() {\n+            return new DateTime(5678L);\n+        }\n+        public long toDurationMillis() {\n             return (5678L - 1234L);\n         }\n-        public Duration getDuration() {\n+        public Duration toDuration() {\n             return new Duration(5678L - 1234L);\n         }\n         public boolean contains(long millisInstant) {\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n     public void testGetMillis() {\n         MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n         assertEquals(TEST_TIME1, test.getStartMillis());\n-        assertEquals(TEST_TIME1, test.getStartInstant().getMillis());\n+        assertEquals(TEST_TIME1, test.getStart().getMillis());\n         assertEquals(TEST_TIME2, test.getEndMillis());\n-        assertEquals(TEST_TIME2, test.getEndInstant().getMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());\n+        assertEquals(TEST_TIME2, test.getEnd().getMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n     }\n \n     public void testGetDuration1() {\n         MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());\n-        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n+        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n     }\n \n     public void testGetDuration2() {\n         MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME1);\n-        assertSame(Duration.ZERO, test.getDuration());\n+        assertSame(Duration.ZERO, test.toDuration());\n     }\n \n     public void testEqualsHashCode() {\n         public MockInterval() {\n             super();\n         }\n+        public Chronology getChronology() {\n+            return Chronology.getISO();\n+        }\n         public long getStartMillis() {\n             return TEST_TIME1;\n         }\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n         MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis());\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         MutableInterval test = new MutableInterval(dt1.getMillis(), dt1.getMillis());\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt1.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     public void testConstructor_long_long3() throws Throwable {\n             new MutableInterval(dt1.getMillis(), dt2.getMillis());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_long_Chronology1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), Chronology.getGJ());\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getGJ(), test.getChronology());\n+    }\n+\n+    public void testConstructor_long_long_Chronology2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), null);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    public void testConstructor_RI_RI8() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getGJ());\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        MutableInterval test = new MutableInterval(dt1, dt2);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getGJ(), test.getChronology());\n+    }\n+\n+    public void testConstructor_RI_RI9() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getGJ());\n+        MutableInterval test = new MutableInterval(dt1, dt2);\n+        assertEquals(dt1.getMillis(), test.getStartMillis());\n+        assertEquals(dt2.getMillis(), test.getEndMillis());\n+        assertEquals(Chronology.getISO(), test.getChronology());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testConstructor_RI_RP1() throws Throwable {\n         DateTime dt = new DateTime(TEST_TIME_NOW);\n     }\n \n     public void testConstructor_RI_RP3() throws Throwable {\n-        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstanceUTC().months().add(result, 6);\n-        result = ISOChronology.getInstanceUTC().days().add(result, 3);\n-        result = ISOChronology.getInstanceUTC().hours().add(result, 1);\n+        result = Chronology.getISOUTC().months().add(result, 6);\n+        result = Chronology.getISOUTC().days().add(result, 3);\n+        result = Chronology.getISOUTC().hours().add(result, 1);\n         \n         MutableInterval test = new MutableInterval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n     }\n \n     public void testConstructor_RP_RI3() throws Throwable {\n-        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n+        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());\n         Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n-        result = ISOChronology.getInstanceUTC().months().add(result, -6);\n-        result = ISOChronology.getInstanceUTC().days().add(result, -3);\n-        result = ISOChronology.getInstanceUTC().hours().add(result, -1);\n+        result = Chronology.getISOUTC().months().add(result, -6);\n+        result = Chronology.getISOUTC().days().add(result, -3);\n+        result = Chronology.getISOUTC().hours().add(result, -1);\n         \n         MutableInterval test = new MutableInterval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n     public void testConstructor_Object5() throws Throwable {\n         IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(\"\");\n         IntervalConverter conv = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {\n-                return null;\n+            public boolean isReadableInterval(Object object, Chronology chrono) {\n+                return false;\n             }\n-            public void setInto(ReadWritableInterval interval, Object object) {\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {\n+                interval.setChronology(chrono);\n                 interval.setInterval(1234L, 5678L);\n             }\n             public Class getSupportedType() {\n     public void testConstructor_Object6() throws Throwable {\n         IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new MutableInterval(0L, 0L));\n         IntervalConverter conv = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {\n-                return null;\n+            public boolean isReadableInterval(Object object, Chronology chrono) {\n+                return false;\n             }\n-            public void setInto(ReadWritableInterval interval, Object object) {\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {\n+                interval.setChronology(chrono);\n                 interval.setInterval(1234L, 5678L);\n             }\n             public Class getSupportedType() {\n     }\n \n     class MockInterval implements ReadableInterval {\n+        public Chronology getChronology() {\n+            return Chronology.getISO();\n+        }\n         public long getStartMillis() {\n             return 1234L;\n         }\n-        public Instant getStartInstant() {\n-            return new Instant(1234L);\n+        public DateTime getStart() {\n+            return new DateTime(1234L);\n         }\n         public long getEndMillis() {\n             return 5678L;\n         }\n-        public Instant getEndInstant() {\n-            return new Instant(5678L);\n-        }\n-        public long getDurationMillis() {\n+        public DateTime getEnd() {\n+            return new DateTime(5678L);\n+        }\n+        public long toDurationMillis() {\n             return (5678L - 1234L);\n         }\n-        public Duration getDuration() {\n+        public Duration toDuration() {\n             return new Duration(5678L - 1234L);\n         }\n         public boolean contains(long millisInstant) {\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Updates.java\n     }\n     \n     class MockBadInterval extends AbstractInterval {\n+        public Chronology getChronology() {\n+            return Chronology.getISO();\n+        }\n         public long getStartMillis() {\n             return TEST_TIME1 - 1;\n         }\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetStartInstant_RI1() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        test.setStartInstant(new Instant(TEST_TIME1 - 1));\n-        assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n-        assertEquals(TEST_TIME2, test.getEndMillis());\n-    }\n-\n-    public void testSetStartInstant_RI2() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        try {\n-            test.setStartInstant(new Instant(TEST_TIME2 + 1));\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetStartInstant_RI3() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        test.setStartInstant(null);\n+    public void testSetStart_RI1() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        test.setStart(new Instant(TEST_TIME1 - 1));\n+        assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n+        assertEquals(TEST_TIME2, test.getEndMillis());\n+    }\n+\n+    public void testSetStart_RI2() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        try {\n+            test.setStart(new Instant(TEST_TIME2 + 1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetStart_RI3() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        test.setStart(null);\n         assertEquals(TEST_TIME_NOW, test.getStartMillis());\n         assertEquals(TEST_TIME2, test.getEndMillis());\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testSetEndInstant_RI1() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        test.setEndInstant(new Instant(TEST_TIME2 + 1));\n-        assertEquals(TEST_TIME1, test.getStartMillis());\n-        assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n-    }\n-\n-    public void testSetEndInstant_RI2() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        try {\n-            test.setEndInstant(new Instant(TEST_TIME1 - 1));\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetEndInstant_RI3() {\n-        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n-        test.setEndInstant(null);\n+    public void testSetEnd_RI1() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        test.setEnd(new Instant(TEST_TIME2 + 1));\n+        assertEquals(TEST_TIME1, test.getStartMillis());\n+        assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n+    }\n+\n+    public void testSetEnd_RI2() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        try {\n+            test.setEnd(new Instant(TEST_TIME1 - 1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetEnd_RI3() {\n+        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n+        test.setEnd(null);\n         assertEquals(TEST_TIME1, test.getStartMillis());\n         assertEquals(TEST_TIME_NOW, test.getEndMillis());\n     }\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n     public void testConstructor_RI_RD1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration dur = new Interval(dt1, dt2).getDuration();\n+        Duration dur = new Interval(dt1, dt2).toDuration();\n         MutablePeriod test = new MutablePeriod(dt1, dur);\n         assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n     public void testConstructor_RI_RD_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration dur = new Interval(dt1, dt2).getDuration();\n+        Duration dur = new Interval(dt1, dt2).toDuration();\n         MutablePeriod test = new MutablePeriod(dt1, dur, PeriodType.yearDayTime());\n         assertEquals(PeriodType.yearDayTime(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n     public void testConstructor_RI_RD1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration dur = new Interval(dt1, dt2).getDuration();\n+        Duration dur = new Interval(dt1, dt2).toDuration();\n         Period test = new Period(dt1, dur);\n         assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n     public void testConstructor_RI_RD_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Duration dur = new Interval(dt1, dt2).getDuration();\n+        Duration dur = new Interval(dt1, dt2).toDuration();\n         Period test = new Period(dt1, dur, PeriodType.yearDayTime());\n         assertEquals(PeriodType.yearDayTime(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n+    private static int INTERVAL_SIZE = 3;\n+\n     public void testGetIntervalConverter() {\n         IntervalConverter c = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 1000L));\n         assertEquals(ReadableInterval.class, c.getSupportedType());\n         c = ConverterManager.getInstance().getIntervalConverter(\"\");\n         assertEquals(String.class, c.getSupportedType());\n         \n+        c = ConverterManager.getInstance().getIntervalConverter(null);\n+        assertEquals(null, c.getSupportedType());\n+        \n         try {\n             ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         try {\n-            ConverterManager.getInstance().getIntervalConverter(null);\n+            ConverterManager.getInstance().getIntervalConverter(new Long(0));\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n     //-----------------------------------------------------------------------\n     public void testGetIntervalConverters() {\n         IntervalConverter[] array = ConverterManager.getInstance().getIntervalConverters();\n-        assertEquals(2, array.length);\n+        assertEquals(INTERVAL_SIZE, array.length);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAddIntervalConverter1() {\n         IntervalConverter c = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {return null;}\n-            public void setInto(ReadWritableInterval interval, Object object) {}\n+            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         try {\n             IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);\n             assertEquals(null, removed);\n             assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType());\n-            assertEquals(3, ConverterManager.getInstance().getIntervalConverters().length);\n+            assertEquals(INTERVAL_SIZE + 1, ConverterManager.getInstance().getIntervalConverters().length);\n         } finally {\n             ConverterManager.getInstance().removeIntervalConverter(c);\n         }\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testAddIntervalConverter2() {\n         IntervalConverter c = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {return null;}\n-            public void setInto(ReadWritableInterval interval, Object object) {}\n+            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}\n             public Class getSupportedType() {return String.class;}\n         };\n         try {\n             IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);\n             assertEquals(StringConverter.INSTANCE, removed);\n             assertEquals(String.class, ConverterManager.getInstance().getIntervalConverter(\"\").getSupportedType());\n-            assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+            assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n         } finally {\n             ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);\n         }\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testAddIntervalConverter3() {\n         IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(null);\n         assertEquals(null, removed);\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testAddIntervalConverterSecurity() {\n             System.setSecurityManager(null);\n             Policy.setPolicy(ALLOW);\n         }\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);\n             assertEquals(StringConverter.INSTANCE, removed);\n-            assertEquals(1, ConverterManager.getInstance().getIntervalConverters().length);\n+            assertEquals(INTERVAL_SIZE - 1, ConverterManager.getInstance().getIntervalConverters().length);\n         } finally {\n             ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);\n         }\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testRemoveIntervalConverter2() {\n         IntervalConverter c = new IntervalConverter() {\n-            public long[] getIntervalMillis(Object object) {return null;}\n-            public void setInto(ReadWritableInterval interval, Object object) {}\n+            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}\n+            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(c);\n         assertEquals(null, removed);\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testRemoveIntervalConverter3() {\n         IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(null);\n         assertEquals(null, removed);\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     public void testRemoveIntervalConverterSecurity() {\n             System.setSecurityManager(null);\n             Policy.setPolicy(ALLOW);\n         }\n-        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);\n+        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        assertEquals(\"ConverterManager[6 instant,5 duration,5 period,2 interval]\", ConverterManager.getInstance().toString());\n+        assertEquals(\"ConverterManager[6 instant,5 duration,5 period,3 interval]\", ConverterManager.getInstance().toString());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.MutablePeriod;\n import org.joda.time.PeriodType;\n-import org.joda.time.MutablePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     //-----------------------------------------------------------------------\n+    public void testIsReadableInterval_Object_Chronology() throws Exception {\n+        assertEquals(false, NullConverter.INSTANCE.isReadableInterval(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testToString() {\n         assertEquals(\"Converter[null]\", NullConverter.INSTANCE.toString());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetIntervalMillis_Object() throws Exception {\n+    public void testIsReadableInterval_Object_Chronology() throws Exception {\n         Interval i = new Interval(1234L, 5678L);\n-        long[] data = ReadableIntervalConverter.INSTANCE.getIntervalMillis(i);\n-        assertEquals(1234L, data[0]);\n-        assertEquals(5678L, data[1]);\n+        assertEquals(true, ReadableIntervalConverter.INSTANCE.isReadableInterval(i, null));\n     }\n \n-    public void testSetIntoInterval_Object() throws Exception {\n+    public void testSetIntoInterval_Object1() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        MutableInterval m = new MutableInterval(-1000L, 1000L, Chronology.getCoptic());\n+        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);\n+        assertEquals(0L, m.getStartMillis());\n+        assertEquals(123L, m.getEndMillis());\n+        assertEquals(Chronology.getCoptic(), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object2() throws Exception {\n         Interval i = new Interval(0L, 123L);\n         MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        ReadableIntervalConverter.INSTANCE.setInto(m, i);\n+        ReadableIntervalConverter.INSTANCE.setInto(m, i, Chronology.getGJ());\n         assertEquals(0L, m.getStartMillis());\n         assertEquals(123L, m.getEndMillis());\n+        assertEquals(Chronology.getGJ(), m.getChronology());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetIntervalMillis_Object() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        long[] data = StringConverter.INSTANCE.getIntervalMillis(\"2004-06-09/P1Y2M\");\n-        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).getMillis(), data[0]);\n-        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0).getMillis(), data[1]);\n-    }\n-\n-    public void testSetIntoInterval_Object1() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        StringConverter.INSTANCE.setInto(m, \"2004-06-09/P1Y2M\");\n-        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n-        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n-    }\n-\n-    public void testSetIntoInterval_Object2() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        StringConverter.INSTANCE.setInto(m, \"P1Y2M/2004-06-09\");\n-        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n-        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n-    }\n-\n-    public void testSetIntoInterval_Object3() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        StringConverter.INSTANCE.setInto(m, \"2003-08-09/2004-06-09\");\n-        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n-        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n-    }\n-\n-    public void testSetIntoIntervalEx_Object1() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetIntoIntervalEx_Object2() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"/\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetIntoIntervalEx_Object3() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"P1Y/\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetIntoIntervalEx_Object4() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"/P1Y\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    public void testSetIntoIntervalEx_Object5() throws Exception {\n-        MutableInterval m = new MutableInterval(-1000L, 1000L);\n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"P1Y/P2Y\");\n+    public void testIsReadableInterval_Object_Chronology() throws Exception {\n+        assertEquals(false, StringConverter.INSTANCE.isReadableInterval(\"\", null));\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology1() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2004-06-09/P1Y2M\", null);\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getStart());\n+        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0), m.getEnd());\n+        assertEquals(Chronology.getISO(), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology2() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"P1Y2M/2004-06-09\", null);\n+        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0), m.getStart());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());\n+        assertEquals(Chronology.getISO(), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology3() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2003-08-09/2004-06-09\", null);\n+        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0), m.getStart());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());\n+        assertEquals(Chronology.getISO(), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology4() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2004-06-09T+06:00/P1Y2M\", null);\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());\n+        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());\n+        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology5() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"P1Y2M/2004-06-09T+06:00\", null);\n+        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());\n+        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());\n+    }\n+\n+    public void testSetIntoInterval_Object_Chronology6() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2003-08-09T+06:00/2004-06-09T+07:00\", null);\n+        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());\n+        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());\n+    }\n+\n+    public void testSetIntoIntervalEx_Object_Chronology1() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object_Chronology2() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"/\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object_Chronology3() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"P1Y/\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object_Chronology4() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"/P1Y\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object_Chronology5() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"P1Y/P2Y\", null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }", "timestamp": 1094429710, "metainfo": ""}