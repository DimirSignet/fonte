{"sha": "158c9d2f00a9b95a8d6c46eb112a35273b70fc12", "log": "Additional persister which stores the timezone in an extra column test cases   ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.UserType;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+/**\n+ * Persist {@link org.joda.time.DateTime} via hibernate.<br />\n+ * The timezone will be stored in an extra column\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentDateTimeTZ implements UserType\n+{\n+    private static final int[] SQL_TYPES = new int[]\n+    {\n+        Types.TIMESTAMP,\n+        Types.VARCHAR,\n+    };\n+\n+    public int[] sqlTypes()\n+    {\n+        return SQL_TYPES;\n+    }\n+\n+    public Class returnedClass()\n+    {\n+        return DateTime.class;\n+    }\n+\n+    public boolean equals(Object x, Object y) throws HibernateException\n+    {\n+        if (x == y)\n+        {\n+            return true;\n+        }\n+        if (x == null || y == null)\n+        {\n+            return false;\n+        }\n+        DateTime dtx = (DateTime) x;\n+        DateTime dty = (DateTime) y;\n+\n+        return dtx.equals(dty);\n+    }\n+\n+    public int hashCode(Object object) throws HibernateException\n+    {\n+        return object.hashCode();\n+    }\n+\n+    public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+    {\n+        Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, strings[0]);\n+        Object timezone = Hibernate.STRING.nullSafeGet(resultSet, strings[1]);\n+        if (timestamp == null || timezone == null)\n+        {\n+            return null;\n+        }\n+\n+        return new DateTime(timestamp, DateTimeZone.forID(timezone.toString()));\n+    }\n+\n+    public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+    {\n+        if (value == null)\n+        {\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);\n+            Hibernate.STRING.nullSafeSet(preparedStatement, null, index+1);\n+        }\n+        else\n+        {\n+            DateTime dt = (DateTime) value;\n+\n+            Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, dt.toDate(), index);\n+            Hibernate.STRING.nullSafeSet(preparedStatement, dt.getZone().getID(), index+1);\n+        }\n+    }\n+\n+    public Object deepCopy(Object value) throws HibernateException\n+    {\n+        if (value == null)\n+        {\n+            return null;\n+        }\n+\n+        return new DateTime(value);\n+    }\n+\n+    public boolean isMutable()\n+    {\n+        return false;\n+    }\n+\n+    public Serializable disassemble(Object value) throws HibernateException\n+    {\n+        return (Serializable) value;\n+    }\n+\n+    public Object assemble(Serializable cached, Object value) throws HibernateException\n+    {\n+        return cached;\n+    }\n+\n+    public Object replace(Object original, Object target, Object owner) throws HibernateException\n+    {\n+        return original;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/src/test/org/joda/time/contrib/hibernate/Event.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * PO to be stored using hibernate\n+ */\n+public class Event implements Serializable\n+{\n+    private int id;\n+    private DateTime dateTime;\n+\n+    public Event()\n+    {\n+    }\n+\n+    public int getId()\n+    {\n+        return id;\n+    }\n+\n+    public void setId(int id)\n+    {\n+        this.id = id;\n+    }\n+\n+    public DateTime getDateTime()\n+    {\n+        return dateTime;\n+    }\n+\n+    public void setDateTime(DateTime dateTime)\n+    {\n+        this.dateTime = dateTime;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/src/test/org/joda/time/contrib/hibernate/EventTZ.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * PO to be stored using hibernate\n+ */\n+public class EventTZ implements Serializable\n+{\n+    private int id;\n+    private DateTime dateTime;\n+\n+    public EventTZ()\n+    {\n+    }\n+\n+    public int getId()\n+    {\n+        return id;\n+    }\n+\n+    public void setId(int id)\n+    {\n+        this.id = id;\n+    }\n+\n+    public DateTime getDateTime()\n+    {\n+        return dateTime;\n+    }\n+\n+    public void setDateTime(DateTime dateTime)\n+    {\n+        this.dateTime = dateTime;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/src/test/org/joda/time/contrib/hibernate/TestPersistentDateTime.java\n+package org.joda.time.contrib.hibernate;\n+\n+import junit.framework.TestCase;\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.hibernate.dialect.HSQLDialect;\n+import org.hibernate.tool.hbm2ddl.SchemaUpdate;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentDateTime extends TestCase\n+{\n+    private SessionFactory factory;\n+\n+    private DateTime writeReadTimes[] = new DateTime[]\n+    {\n+        new DateTime(2004, 2, 25, 17, 3, 45, 760),\n+        new DateTime(1980, 3, 11,  2, 3, 45,   0, DateTimeZone.forOffsetHours(2))\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            Event event = new Event();\n+            event.setId(i);\n+            event.setDateTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Event eventReread = (Event) session.get(Event.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getDateTime());\n+\n+            // we loose the timezone, so we have to normalize both to offset=0\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime.toDateTime(DateTimeZone.forOffsetHours(0)),\n+                eventReread.getDateTime().toDateTime(DateTimeZone.forOffsetHours(0)));\n+\n+            session.close();\n+        }\n+    }\n+\n+    public void testStoreWithTimezone() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            EventTZ event = new EventTZ();\n+            event.setId(i);\n+            event.setDateTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            DateTime writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            EventTZ eventReread = (EventTZ) session.get(EventTZ.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getDateTime());\n+\n+            assertEquals(\"get failed - returned different time\",\n+                writeReadTime, eventReread.getDateTime());\n+\n+            session.close();\n+        }\n+    }\n+\n+    private SessionFactory getSessionFactory()\n+    {\n+        if (this.factory == null)\n+        {\n+            Configuration cfg = new Configuration();\n+\n+            cfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/event.hbm.xml\"));\n+            cfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml\"));\n+\n+            cfg.setProperty(\"hibernate.connection.driver_class\", \"org.hsqldb.jdbcDriver\");\n+            cfg.setProperty(\"hibernate.connection.url\", \"jdbc:hsqldb:mem:hbmtest\");\n+            cfg.setProperty(\"hibernate.dialect\", HSQLDialect.class.getName());\n+\n+            cfg.setProperty(\"hibernate.show_sql\", \"true\");\n+            SessionFactory factory = cfg.buildSessionFactory();\n+\n+            SchemaUpdate update = new SchemaUpdate(cfg);\n+            update.execute(false, true);\n+\n+            this.factory = factory;\n+        }\n+        return factory;\n+    }\n+}", "timestamp": 1116361941, "metainfo": ""}