{"sha": "69b17f730e0383439b5f4abb2c2c0858df61240b", "log": "Fix DateTime parsing of text containing non-letters, also make less greedy [1788282]  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import java.io.IOException;\n import java.io.Writer;\n import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n import org.joda.time.ReadablePartial;\n+import org.joda.time.MutableDateTime.Property;\n import org.joda.time.field.MillisDurationField;\n import org.joda.time.field.PreciseDateTimeField;\n \n     static class TextField\n             implements DateTimePrinter, DateTimeParser {\n \n+        private static Map cParseCache = new HashMap();\n         private final DateTimeFieldType iFieldType;\n         private final boolean iShort;\n \n         }\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            int limit = text.length();\n-            int i = position;\n-            for (; i<limit; i++) {\n-                char c = text.charAt(i);\n-                if (c < 'A') {\n-                    break;\n-                }\n-                if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || Character.isLetter(c)) {\n-                    continue;\n-                }\n-                break;\n-            }\n-\n-            if (i == position) {\n-                return ~position;\n-            }\n-\n             Locale locale = bucket.getLocale();\n-            bucket.saveField(iFieldType, text.substring(position, i), locale);\n-\n-            return i;\n+            // handle languages which might have non ASCII A-Z or punctuation\n+            // bug 1788282\n+            Set validValues = null;\n+            int maxLength = 0;\n+            synchronized (cParseCache) {\n+                Map innerMap = (Map) cParseCache.get(locale);\n+                if (innerMap == null) {\n+                    innerMap = new HashMap();\n+                    cParseCache.put(locale, innerMap);\n+                }\n+                Object[] array = (Object[]) innerMap.get(iFieldType);\n+                if (array == null) {\n+                    validValues = new HashSet(32);\n+                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n+                    Property property = dt.property(iFieldType);\n+                    int min = property.getMinimumValueOverall();\n+                    int max = property.getMaximumValueOverall();\n+                    if (max - min > 32) {  // protect against invalid fields\n+                        return ~position;\n+                    }\n+                    maxLength = property.getMaximumTextLength(locale);\n+                    for (int i = min; i <= max; i++) {\n+                        property.set(i);\n+                        validValues.add(property.getAsShortText(locale));\n+                        validValues.add(property.getAsText(locale));\n+                    }\n+                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n+                        // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n+                        validValues.add(\"BCE\");\n+                        validValues.add(\"CE\");\n+                        maxLength = 3;\n+                    }\n+                    array = new Object[] {validValues, new Integer(maxLength)};\n+                    innerMap.put(iFieldType, array);\n+                } else {\n+                    validValues = (Set) array[0];\n+                    maxLength = ((Integer) array[1]).intValue();\n+                }\n+            }\n+            // match the longest string first using our knowledge of the max length\n+            int limit = Math.min(text.length(), position + maxLength);\n+            for (int i = limit; i > position; i--) {\n+                String match = text.substring(position, i);\n+                if (validValues.contains(match)) {\n+                    bucket.saveField(iFieldType, match, locale);\n+                    return i;\n+                }\n+            }\n+            return ~position;\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.chrono.GJChronology;\n         assertEquals(dt, f.parseDateTime(\"2004/03/09\"));\n     }\n \n+    //-----------------------------------------------------------------------\n     public void testParse_pivotYear() {\n         DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd.MM.yy\").withPivotYear(2050).withZone(DateTimeZone.UTC);\n         \n         assertEquals(date.getYear(), 99);\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testFormatParse_textMonthJanShort_UK() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\")\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 1, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(str, \"23 Jan 2007\");\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 23);\n+    }\n+\n+    public void testParse_textMonthJanLong_UK() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\")\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        DateTime date = dateFormatter.parseDateTime(\"23 January 2007\");\n+        check(date, 2007, 1, 23);\n+    }\n+\n+    public void testFormatParse_textMonthJanShort_France() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\")\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 1, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"23 janv. 2007\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 23);\n+    }\n+\n+    public void testFormatParse_textMonthJanLong_France() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\")\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        DateTime date = dateFormatter.parseDateTime(\"23 janvier 2007\");\n+        check(date, 2007, 1, 23);\n+    }\n+\n+    public void testFormatParse_textMonthApr_France() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\")\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 2, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"23 f\\u00E9vr. 2007\", str);  // e acute\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 2, 23);\n+    }\n+\n+    public void testFormatParse_textMonthAtEnd_France() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM\")\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"23 juin\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 1970, 6, 23);\n+    }\n+\n+    public void testFormatParse_textMonthApr_Korean() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"EEEE, d MMMM yyyy HH:mm\")\n+            .withLocale(Locale.KOREAN).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 3, 8, 22, 0, 0, 0, UTC).toString(dateFormatter);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        assertEquals(new DateTime(2007, 3, 8, 22, 0, 0, 0, UTC), date);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFormatParse_textHalfdayAM_UK() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendClockhourOfHalfday(2)\n+            .appendLiteral('-')\n+            .appendHalfdayOfDayText()\n+            .appendLiteral('-')\n+            .appendYear(4, 4)\n+            .toFormatter()\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 18, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$06-PM-2007\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 1);\n+    }\n+\n+    public void testFormatParse_textHalfdayAM_France() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendClockhourOfHalfday(2)\n+            .appendLiteral('-')\n+            .appendHalfdayOfDayText()\n+            .appendLiteral('-')\n+            .appendYear(4, 4)\n+            .toFormatter()\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 18, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$06-PM-2007\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFormatParse_textEraAD_UK() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendEraText()\n+            .appendYear(4, 4)\n+            .toFormatter()\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$AD2007\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 1);\n+    }\n+\n+    public void testFormatParse_textEraAD_France() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendEraText()\n+            .appendYear(4, 4)\n+            .toFormatter()\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$ap. J.-C.2007\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 2007, 1, 1);\n+    }\n+\n+    public void testFormatParse_textEraBC_France() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendEraText()\n+            .appendYear(4, 4)\n+            .toFormatter()\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(-1, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$BC-0001\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, -1, 1, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFormatParse_textYear_UK() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendText(DateTimeFieldType.year())\n+            .toFormatter()\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$2007\", str);\n+        try {\n+            dateFormatter.parseDateTime(str);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testFormatParse_textYear_France() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendText(DateTimeFieldType.year())\n+            .toFormatter()\n+            .withLocale(Locale.FRANCE).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$2007\", str);\n+        try {\n+            dateFormatter.parseDateTime(str);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFormatParse_textAdjoiningHelloWorld_UK() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendDayOfMonth(2)\n+            .appendMonthOfYearShortText()\n+            .appendLiteral(\"HelloWorld\")\n+            .toFormatter()\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$23JunHelloWorld\", str);\n+        dateFormatter.parseDateTime(str);\n+    }\n+\n+    public void testFormatParse_textAdjoiningMonthDOW_UK() {\n+        DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder()\n+            .appendLiteral('$')\n+            .appendDayOfMonth(2)\n+            .appendMonthOfYearShortText()\n+            .appendDayOfWeekShortText()\n+            .toFormatter()\n+            .withLocale(Locale.UK).withZone(DateTimeZone.UTC);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"$23JunSat\", str);\n+        dateFormatter.parseDateTime(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void check(DateTime test, int hour, int min, int sec) {\n+        assertEquals(hour, test.getYear());\n+        assertEquals(min, test.getMonthOfYear());\n+        assertEquals(sec, test.getDayOfMonth());\n+    }\n+\n }", "timestamp": 1193438071, "metainfo": ""}