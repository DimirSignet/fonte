{"sha": "25aa041404f53d3525e35c891fcca2c4c7764296", "log": "Support object onversion.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n package org.joda.time;\n \n import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.IntervalConverter;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n \n  * This class should generally not be used directly by API users. The \n  * {@link ReadableInterval} interface should be used when different \n  * kinds of intervals are to be referenced.\n+ * <p>\n+ * AbstractInterval subclasses may be mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n     }\n     \n     /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval the time interval to convert\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public AbstractInterval(Object interval) {\n+        super();\n+        if (interval instanceof ReadableInterval) {\n+            ReadableInterval ri = (ReadableInterval) interval;\n+            iStartMillis = ri.getStartMillis();\n+            iEndMillis = ri.getEndMillis();\n+        } else {\n+            IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n+            if (this instanceof ReadWritableInterval) {\n+                converter.setInto((ReadWritableInterval) this, interval);\n+            } else {\n+                MutableInterval mi = new MutableInterval(0, 0);\n+                converter.setInto(mi, interval);\n+                iStartMillis = mi.getStartMillis();\n+                iEndMillis = mi.getEndMillis();\n+            }\n+        }\n+    }\n+\n+    /**\n      * Constructs an interval from a start and end instant.\n      * \n      * @param startInstant  start of this interval, as milliseconds from\n      * \n      * @param start  start of this interval\n      * @param duration  duration of this interval\n+     * @throws IllegalArgumentException if start or duration is null\n      */\n     public AbstractInterval(ReadableInstant start, ReadableDuration duration) {\n         super();\n      * \n      * @param duration duration of this interval\n      * @param end end of this interval\n+     * @throws IllegalArgumentException if duration or end is null\n      */\n     public AbstractInterval(ReadableDuration duration, ReadableInstant end) {\n         super();\n      *\n      * @return the start of the interval\n      */\n-    public long getStartMillis() {\n+    public final long getStartMillis() {\n         return iStartMillis;\n     }\n \n      *\n      * @return the start of the time interval\n      */\n-    public Instant getStartInstant() {\n+    public final Instant getStartInstant() {\n         if (iStartInstant == null) {\n             iStartInstant = new Instant(getStartMillis());\n         }\n      *\n      * @return the start of the interval\n      */\n-    public long getEndMillis() {\n+    public final long getEndMillis() {\n         return iEndMillis;\n     }\n \n      *\n      * @return the end of the time interval\n      */\n-    public Instant getEndInstant() {\n+    public final Instant getEndInstant() {\n         if (iEndInstant == null) {\n             iEndInstant = new Instant(getEndMillis());\n         }\n      *\n      * @return the duration of the time interval in milliseconds\n      */\n-    public long getDurationMillis() {\n+    public final long getDurationMillis() {\n         return (getEndMillis() - getStartMillis());\n     }\n \n      *\n      * @return the duration of the time interval\n      */\n-    public Duration getDuration() {\n+    public final Duration getDuration() {\n         if (iDuration == null) {\n-            iDuration = new Duration(DurationType.getDayHourType(),\n+            iDuration = new Duration(DurationType.getPreciseYearMonthType(),\n                                      getEndMillis() - getStartMillis());\n         }\n         return iDuration;\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval contains the millisecond\n      */\n-    public boolean contains(long millisInstant) {\n+    public final boolean contains(long millisInstant) {\n         return (millisInstant >= getStartMillis() && millisInstant <= getEndMillis());\n     }\n     \n      * @return true if this time interval contains the instant\n      * @throws IllegalArgumentException if the instant is null\n      */\n-    public boolean contains(ReadableInstant instant) {\n+    public final boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n      * @return true if this interval contains the time interval\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public boolean contains(ReadableInterval interval) {\n+    public final boolean contains(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      * @return true if the time intervals overlap\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public boolean overlaps(ReadableInterval interval) {\n+    public final boolean overlaps(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is before the instant\n      */\n-    public boolean isBefore(long millisInstant) {\n+    public final boolean isBefore(long millisInstant) {\n         return (getStartMillis() < millisInstant && getEndMillis() < millisInstant);\n     }\n     \n      * @return true if this time interval is before the instant\n      * @throws IllegalArgumentException if the instant is null\n      */\n-    public boolean isBefore(ReadableInstant instant) {\n+    public final boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is after the instant\n      */\n-    public boolean isAfter(long millisInstant) {\n+    public final boolean isAfter(long millisInstant) {\n         return (getStartMillis() > millisInstant && getEndMillis() > millisInstant);\n     }\n     \n      * @return true if this time interval is after the instant\n      * @throws IllegalArgumentException if the instant is null\n      */\n-    public boolean isAfter(ReadableInstant instant) {\n+    public final boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n      * \n      * @return an immutable interval object\n      */\n-    public Interval toInterval() {\n+    public final Interval toInterval() {\n         if (this instanceof Interval) {\n             return (Interval) this;\n         }\n      * \n      * @return a mutable interval object\n      */\n-    public MutableInterval toMutableInterval() {\n+    public final MutableInterval toMutableInterval() {\n         return new MutableInterval(this);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n  * class. The duration of the time interval is always a precise amount of\n  * milliseconds even if a variable length duration was passed into the\n  * constructor.\n+ * <p>\n+ * Interval is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n  * @author Sean Geoghegan\n      * @throws IllegalArgumentException if the interval is null\n      */\n     public Interval(ReadableInterval interval) {\n+        super(interval);\n+    }\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval  the time interval to convert\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public Interval(Object interval) {\n         super(interval);\n     }\n \n      * \n      * @param start  start of this interval\n      * @param duration  duration of this interval\n+     * @throws IllegalArgumentException if start or duration is null\n      */\n     public Interval(ReadableInstant start, ReadableDuration duration) {\n         super(start, duration);\n      * \n      * @param duration duration of this interval\n      * @param end end of this interval\n+     * @throws IllegalArgumentException if duration or end is null\n      */\n     public Interval(ReadableDuration duration, ReadableInstant end) {\n         super(duration, end);\n     }\n-\n-    /** \n-     * Creates new TimePeriod.\n-     *\n-     * TimePeriod is created from an ISO formatted\n-     * TimePeriod string. Only accepts strings in the\n-     * ISO_STANDARD_BASIC_FORMAT pattern.\n-     *\n-     * @param period an ISO interval string\n-     */\n-    /* TODO\n-    public Interval(String period) throws ParseException {\n-        Interval temp = (Interval)TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(period);\n-        iStartMillis = temp.iStartMillis;\n-        iEndMillis = temp.iEndMillis;\n-    }\n-    */\n \n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are", "timestamp": 1072051365, "metainfo": ""}