{"sha": "c2eb7b74ad0089ae97c4197ebf4079c03f4c9cfd", "log": "Add new separator functionality to meet ISO8601 requirements   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n \n     private static PeriodFormatter toFormatter(List formatters) {\n         int size = formatters.size();\n-        if (size >= 2 && formatters.get(1) instanceof Separator) {\n-            PeriodFormatter before = (PeriodFormatter) formatters.get(0);\n-            if (size == 2) {\n-                // Separator at the end would never format anything.\n-                return before;\n-            }\n-            return ((Separator) formatters.get(1)).finish\n-                (before, toFormatter(formatters.subList(2, size)));\n+        if (size >= 1 && formatters.get(0) instanceof Separator) {\n+            Separator sep = (Separator) formatters.get(0);\n+            return sep.finish(toFormatter(formatters.subList(1, size)));\n         }\n         return createComposite(formatters);\n     }\n     }\n \n     /**\n-     * Instructs the printer to emit specific text, and the parser to expect\n-     * it. The parser is case-insensitive.\n+     * Instructs the printer to emit specific text, and the parser to expect it.\n+     * The parser is case-insensitive.\n      *\n      * @return this PeriodFormatterBuilder\n      * @throws IllegalArgumentException if text is null\n     }\n \n     /**\n-     * During printing, separators are only printed if fields are printed\n-     * following the latest one.\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * will only output the comma if both the days and hours fields are output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n      * <p>\n      * Note: appending a separator discontinues any further work on the latest\n      * appended field.\n      *\n-     * @return this PeriodFormatterBuilder\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n      */\n     public PeriodFormatterBuilder appendSeparator(String text) {\n-        return appendSeparator(text, text);\n-    }\n-\n-    /**\n-     * During printing, separators are only printed if fields are printed\n-     * following the latest one.\n-     * <p>\n-     * During parsing, either text parameter is accepted, and is\n-     * case-insensitive.\n+        return appendSeparator(text, text, true, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output only if fields are printed after the separator.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * will only output the comma if the hours fields is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n      * <p>\n      * Note: appending a separator discontinues any further work on the latest\n      * appended field.\n      *\n-     * @param finalText alternate used if this is the final separator\n-     * printed\n-     * @return this PeriodFormatterBuilder\n-     */\n-    public PeriodFormatterBuilder appendSeparator(String text,\n-                                                    String finalText) {\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n+        return appendSeparator(text, text, false, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output only if fields are printed after the separator.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * will only output the comma if the days fields is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n+        return appendSeparator(text, text, true, false);\n+    }\n+\n+    /**\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * This method changes the separator depending on whether it is the last separator\n+     * to be output.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n+     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n+     * and '1' if just one field is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @param finalText  the text used used if this is the final separator to be printed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n+        return appendSeparator(text, finalText, true, true);\n+    }\n+\n+    private PeriodFormatterBuilder appendSeparator(String text, String finalText, boolean useBefore, boolean useAfter) {\n         if (text == null || finalText == null) {\n             throw new IllegalArgumentException();\n         }\n \n         clearPrefix();\n-\n+        \n+        // optimise zero formatter case\n         List formatters = iFormatters;\n-\n         if (formatters.size() == 0) {\n-            // Separator at the beginning would never print anything.\n+            if (useAfter && useBefore == false) {\n+                formatters.add(new Separator(text, finalText, Literal.EMPTY, useBefore, useAfter));\n+            }\n             return this;\n         }\n-\n-        // Create a composite over all the fields between separators.\n+        \n+        // find the last separator added\n         int i;\n         Separator lastSeparator = null;\n         for (i=formatters.size(); --i>=0; ) {\n                 break;\n             }\n         }\n-\n+        \n+        // merge formatters\n         if (lastSeparator != null && formatters.size() == 0) {\n-            // Merge two adjacent separators together.\n-            iFormatters.set(i, lastSeparator.merge(text, finalText));\n+            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n         } else {\n             PeriodFormatter composite = createComposite(formatters);\n             formatters.clear();\n-            formatters.add(composite);\n-            \n-            // The separator will be finished later.\n-            formatters.add(new Separator(text, finalText));\n-        }\n-            \n+            formatters.add(new Separator(text, finalText, composite, useBefore, useAfter));\n+        }\n+        \n         return this;\n     }\n \n     }\n \n     private static PeriodFormatter createComposite(List formatters) {\n-        if (formatters.size() == 1) {\n-            return (PeriodFormatter)formatters.get(0);\n-        } else {\n-            return new Composite(formatters);\n+        switch (formatters.size()) {\n+            case 0:\n+                return Literal.EMPTY;\n+            case 1:\n+                return (PeriodFormatter) formatters.get(0);\n+            default:\n+                return new Composite(formatters);\n         }\n     }\n \n     private static final class Literal extends AbstractPeriodFormatter\n         implements PeriodFormatter\n     {\n+        static final Literal EMPTY = new Literal(\"\");\n         private final String iText;\n \n         Literal(String text) {\n         private final String iText;\n         private final String iFinalText;\n \n-        private final PeriodFormatter iBefore;\n-        private final PeriodFormatter iAfter;\n-\n-        Separator(String text, String finalText) {\n-            this(text, finalText, null, null);\n-        }\n-\n-        Separator(String text, String finalText,\n-                  PeriodFormatter before, PeriodFormatter after) {\n+        private final boolean iUseBefore;\n+        private final boolean iUseAfter;\n+\n+        private PeriodFormatter iBefore;\n+        private PeriodFormatter iAfter;\n+\n+        Separator(String text, String finalText, PeriodFormatter before, boolean useBefore, boolean useAfter) {\n             iText = text;\n             iFinalText = finalText;\n             iBefore = before;\n-            iAfter = after;\n+            iUseBefore = useBefore;\n+            iUseAfter = useAfter;\n         }\n \n         public int countFieldsToPrint(ReadablePeriod period, int stopAt) {\n         }\n \n         public int calculatePrintedLength(ReadablePeriod period) {\n-            int sum = iBefore.calculatePrintedLength(period)\n-                + iAfter.calculatePrintedLength(period);\n-\n-            if (iBefore.countFieldsToPrint(period, 1) > 0) {\n-                int afterCount = iAfter.countFieldsToPrint(period, 2);\n-                if (afterCount > 0) {\n-                    sum += (afterCount > 1 ? iText : iFinalText).length();\n-                }\n-            }\n-\n+            PeriodPrinter before = iBefore;\n+            PeriodPrinter after = iAfter;\n+            \n+            int sum = before.calculatePrintedLength(period)\n+                    + after.calculatePrintedLength(period);\n+            \n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2);\n+                        if (afterCount > 0) {\n+                            sum += (afterCount > 1 ? iText : iFinalText).length();\n+                        }\n+                    } else {\n+                        sum += iText.length();\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1) > 0) {\n+                sum += iText.length();\n+            }\n+            \n             return sum;\n         }\n \n         public void printTo(StringBuffer buf, ReadablePeriod period) {\n             PeriodPrinter before = iBefore;\n             PeriodPrinter after = iAfter;\n-\n+            \n             before.printTo(buf, period);\n-\n-            if (before.countFieldsToPrint(period, 1) > 0) {\n-                int afterCount = after.countFieldsToPrint(period, 2);\n-                if (afterCount > 0) {\n-                    buf.append(afterCount > 1 ? iText : iFinalText);\n-                }\n-            }\n-\n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2);\n+                        if (afterCount > 0) {\n+                            buf.append(afterCount > 1 ? iText : iFinalText);\n+                        }\n+                    } else {\n+                        buf.append(iText);\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1) > 0) {\n+                buf.append(iText);\n+            }\n             after.printTo(buf, period);\n         }\n \n         public void printTo(Writer out, ReadablePeriod period) throws IOException {\n             PeriodPrinter before = iBefore;\n             PeriodPrinter after = iAfter;\n-\n+            \n             before.printTo(out, period);\n-\n-            if (before.countFieldsToPrint(period, 1) > 0) {\n-                int afterCount = after.countFieldsToPrint(period, 2);\n-                if (afterCount > 0) {\n-                    out.write(afterCount > 1 ? iText : iFinalText);\n-                }\n-            }\n-\n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2);\n+                        if (afterCount > 0) {\n+                            out.write(afterCount > 1 ? iText : iFinalText);\n+                        }\n+                    } else {\n+                        out.write(iText);\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1) > 0) {\n+                out.write(iText);\n+            }\n             after.printTo(out, period);\n         }\n \n             final int oldPos = position;\n \n             position = iBefore.parseInto(period, periodStr, position);\n-\n             if (position < 0) {\n                 return position;\n             }\n-\n             if (position > oldPos) {\n                 // Since position advanced, this separator is\n                 // allowed. Optionally parse it.\n                     position += iFinalText.length();\n                 }\n             }\n-\n-            return iAfter.parseInto(period, periodStr, position);\n-        }\n-\n-        Separator merge(String text, String finalText) {\n-            return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);\n-        }\n-\n-        Separator finish(PeriodFormatter before, PeriodFormatter after) {\n-            return new Separator(iText, iFinalText, before, after);\n+            position = iAfter.parseInto(period, periodStr, position);\n+            return position;\n+        }\n+\n+        Separator finish(PeriodFormatter after) {\n+            iAfter = after;\n+            return this;\n         }\n     }\n ", "timestamp": 1093460696, "metainfo": ""}