{"sha": "5e94133c0575581268fa38d1f3c6214952861786", "log": "Fix from testing   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n import java.io.Serializable;\n import java.util.Comparator;\n \n+import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n \n /**\n      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n      * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n      * @return a comparator over all fields between the limits\n+     * @throws IllegalArgumentException if the lower limit is greater than the upper\n      */\n     public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n         if (lowerLimit == null && upperLimit == null) {\n             return INSTANCE;\n         }\n+        if (lowerLimit != null && upperLimit != null) {\n+            if (lowerLimit.getDurationField().getUnitMillis() > upperLimit.getDurationField().getUnitMillis()) {\n+                throw new IllegalArgumentException(\"Lower limit greater than upper: \" +\n+                    lowerLimit.getName() + \" > \" + upperLimit.getName());\n+            }\n+        }\n         return new DateTimeComparator(lowerLimit, upperLimit);\n     }\n \n      * @return a comparator over all date fields\n      */\n     public static DateTimeComparator getDateOnlyInstance(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstance();\n+        }\n         return getInstance(chrono.dayOfYear(), null);\n     }\n \n      * @return a comparator over all time fields\n      */\n     public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstance();\n+        }\n         return getInstance(null, chrono.dayOfYear());\n     }\n \n      * @param lowerLimit  the lower field limit, null means no limit\n      * @param upperLimit  the upper field limit, null means no limit\n      */\n-    private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+    protected DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n         super();\n         iLowerLimit = lowerLimit;\n         iUpperLimit = upperLimit;\n         long lhsMillis = getMillisFromObject(lhsObj);\n         long rhsMillis = getMillisFromObject(rhsObj);\n \n-        DateTimeField field;\n-        if ((field = iLowerLimit) != null) {\n-            lhsMillis = field.roundFloor(lhsMillis);\n-            rhsMillis = field.roundFloor(rhsMillis);\n-        }\n-\n-        if ((field = iUpperLimit) != null) {\n-            lhsMillis = field.remainder(lhsMillis);\n-            rhsMillis = field.remainder(rhsMillis);\n+        if (iLowerLimit != null) {\n+            lhsMillis = iLowerLimit.roundFloor(lhsMillis);\n+            rhsMillis = iLowerLimit.roundFloor(rhsMillis);\n+        }\n+\n+        if (iUpperLimit != null) {\n+            lhsMillis = iUpperLimit.remainder(lhsMillis);\n+            rhsMillis = iUpperLimit.remainder(rhsMillis);\n         }\n \n         if (lhsMillis < rhsMillis) {\n      * @return a debugging string\n      */\n     public String toString() {\n-        return \"DateTimeComparator[lowerLimit:\"\n-            + (iLowerLimit == null ? \"none\" : iLowerLimit.getName())\n-            + \",upperLimit:\"\n-            + (iUpperLimit == null ? \"none\" : iUpperLimit.getName())\n+        return \"DateTimeComparator[\"\n+            + (iLowerLimit == null ? \"\" : iLowerLimit.getName())\n+            + (iLowerLimit == null && iUpperLimit == null ? \"\" : \"-\")\n+            + (iUpperLimit == null ? \"\" : iUpperLimit.getName())\n             + \"]\";\n     }\n \n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class DateTimeUtils {\n+public class DateTimeUtils {\n \n     /** The singleton instance of the system millisecond provider */\n     private static final SystemMillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();\n     /**\n      * Restrictive constructor\n      */\n-    private DateTimeUtils() {\n+    protected DateTimeUtils() {\n         super();\n     }\n \n      * \n      * @return the current time in milliseconds from 1970-01-01T00:00:00Z\n      */\n-    public static long currentTimeMillis() {\n+    public static final long currentTimeMillis() {\n         return cMillisProvider.getMillis();\n     }\n \n      * This method changes the behaviour of {@link #currentTimeMillis()}.\n      * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n      */\n-    public static void setCurrentMillisSystem() throws SecurityException {\n+    public static final void setCurrentMillisSystem() throws SecurityException {\n         checkPermission();\n         cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n     }\n      * \n      * @param fixedMillis  the fixed millisecond time to use\n      */\n-    public static void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n+    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n         checkPermission();\n         cMillisProvider = new FixedMillisProvider(fixedMillis);\n     }\n      * \n      * @param offsetMillis  the fixed millisecond time to use\n      */\n-    public static void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n+    public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n         checkPermission();\n         cMillisProvider = new OffsetMillisProvider(offsetMillis);\n     }", "timestamp": 1090156322, "metainfo": ""}