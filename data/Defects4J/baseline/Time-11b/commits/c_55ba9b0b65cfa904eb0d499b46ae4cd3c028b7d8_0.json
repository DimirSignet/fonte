{"sha": "55ba9b0b65cfa904eb0d499b46ae4cd3c028b7d8", "log": "Add basic tests for chronologies   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n         DateTimeZone zone = getZone();\n         if (zone != null) {\n             sb.append(zone.getID());\n-            sb.append(\", \");\n-        }\n-        sb.append(\"mdfw=\");\n-        sb.append(getMinimumDaysInFirstWeek());\n+        }\n+        if (getMinimumDaysInFirstWeek() != 4) {\n+            sb.append(\",mdfw=\");\n+            sb.append(getMinimumDaysInFirstWeek());\n+        }\n         sb.append(']');\n         return sb.toString();\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n         if (getParam() == null) {\n             DateTimeField field = fields.year;\n             fields.year = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n-            fields.yearOfEra = fields.year;\n+            \n+            field = fields.yearOfEra;\n+            fields.yearOfEra = new OffsetDateTimeField(fields.year, field.getName(), BUDDHIST_OFFSET);\n             \n             field = fields.weekyear;\n             fields.weekyear = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n import org.joda.time.Instant;\n     }\n \n     /**\n-     * The default GregorianJulian cutover point\n+     * The default GregorianJulian cutover point.\n      */\n     static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n \n      * @param zone  the time zone to use, null is default\n      * @param gregorianCutover  the cutover to use, null means default\n      */\n-    public static GJChronology getInstance(DateTimeZone zone,\n-                                           ReadableInstant gregorianCutover) \n-    {\n+    public static GJChronology getInstance(\n+            DateTimeZone zone,\n+            ReadableInstant gregorianCutover) {\n+        \n         return getInstance(zone, gregorianCutover, 4);\n     }\n     \n      * @param gregorianCutover  the cutover to use, null means default\n      * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n      */\n-    public static synchronized GJChronology getInstance(DateTimeZone zone,\n-                                                        ReadableInstant gregorianCutover,\n-                                                        int minDaysInFirstWeek)\n-    {\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n+    public static synchronized GJChronology getInstance(\n+            DateTimeZone zone,\n+            ReadableInstant gregorianCutover,\n+            int minDaysInFirstWeek) {\n+        \n+        zone = DateTimeUtils.getZone(zone);\n         Instant cutoverInstant;\n         if (gregorianCutover == null) {\n             cutoverInstant = DEFAULT_CUTOVER;\n      * @param gregorianCutover  the cutover to use\n      * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n      */\n-    public static synchronized GJChronology getInstance(DateTimeZone zone,\n-                                                        long gregorianCutover,\n-                                                        int minDaysInFirstWeek)\n-    {\n+    public static GJChronology getInstance(\n+            DateTimeZone zone,\n+            long gregorianCutover,\n+            int minDaysInFirstWeek) {\n+        \n         Instant cutoverInstant;\n         if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n             cutoverInstant = null;\n         return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n     }\n \n+    //-----------------------------------------------------------------------\n     private JulianChronology iJulianChronology;\n     private GregorianChronology iGregorianChronology;\n     private Instant iCutoverInstant;\n \n-    long iCutoverMillis;\n-    long iGapDuration;\n+    private long iCutoverMillis;\n+    private long iGapDuration;\n \n     /**\n      * @param julian chronology used before the cutover instant\n         return iCutoverInstant;\n     }\n \n-    public final int getMinimumDaysInFirstWeek() {\n+    /**\n+     * Gets the minimum days needed for a week to be the first week in a year.\n+     * \n+     * @return the minimum days\n+     */\n+    public int getMinimumDaysInFirstWeek() {\n         return iGregorianChronology.getMinimumDaysInFirstWeek();\n     }\n \n      */\n     public String toString() {\n         StringBuffer sb = new StringBuffer(60);\n-        sb.append(\"GJCutoverChronology\");\n+        sb.append(\"GJChronology\");\n         sb.append('[');\n         sb.append(getZone().getID());\n-        sb.append(\", \");\n-\n-        sb.append(\"cutover=\");\n-        ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n-        DateTimePrinter printer;\n-        if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n-            printer = format.date();\n-        } else {\n-            printer = format.dateTime();\n-        }\n-        printer.printTo(sb, iCutoverMillis);\n-\n-        sb.append(\", mdfw=\");\n-        sb.append(getMinimumDaysInFirstWeek());\n+        \n+        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n+            sb.append(\",cutover=\");\n+            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());\n+            DateTimePrinter printer;\n+            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n+                printer = format.date();\n+            } else {\n+                printer = format.dateTime();\n+            }\n+            printer.printTo(sb, iCutoverMillis);\n+        }\n+        \n+        if (getMinimumDaysInFirstWeek() != 4) {\n+            sb.append(\",mdfw=\");\n+            sb.append(getMinimumDaysInFirstWeek());\n+        }\n         sb.append(']');\n-\n+        \n         return sb.toString();\n     }\n \n         return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n      * assumes that calls to add and addWrapField are unaffected by the cutover.\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Cutover field for variable length fields. These fields internally call\n      * set whenever add is called. As a result, the same correction applied to\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Links the duration back to a ImpreciseCutoverField.\n      */\n--- a/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        \n+        suite.addTest(TestBuddhistChronology.suite());\n+        suite.addTest(TestCopticChronology.suite());\n+        suite.addTest(TestGJChronology.suite());\n+        suite.addTest(TestGregorianChronology.suite());\n+        suite.addTest(TestJulianChronology.suite());\n         suite.addTest(TestISOChronology.suite());\n+        \n         return suite;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestBuddhistChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for BuddhistChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestBuddhistChronology extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestBuddhistChronology.class);\n+    }\n+\n+    public TestBuddhistChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, BuddhistChronology.getInstanceUTC().getZone());\n+        assertSame(BuddhistChronology.class, BuddhistChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, BuddhistChronology.getInstance().getZone());\n+        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, BuddhistChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, BuddhistChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, BuddhistChronology.getInstance(null).getZone());\n+        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO));\n+        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(LONDON));\n+        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(PARIS));\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());\n+        assertSame(BuddhistChronology.getInstance(), BuddhistChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(LONDON).withUTC());\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(TOKYO).withUTC());\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC().withUTC());\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance().withZone(PARIS));\n+        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"BuddhistChronology[Europe/London]\", BuddhistChronology.getInstance(LONDON).toString());\n+        assertEquals(\"BuddhistChronology[Asia/Tokyo]\", BuddhistChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"BuddhistChronology[Europe/London]\", BuddhistChronology.getInstance().toString());\n+        assertEquals(\"BuddhistChronology[UTC]\", BuddhistChronology.getInstanceUTC().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", BuddhistChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", BuddhistChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", BuddhistChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", BuddhistChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", BuddhistChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", BuddhistChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", BuddhistChronology.getInstance().days().getName());\n+        assertEquals(\"hours\", BuddhistChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", BuddhistChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", BuddhistChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", BuddhistChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, BuddhistChronology.getInstance().eras().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().years().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().months().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().days().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().hours().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, BuddhistChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstance().years().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstance().months().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstance().days().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, BuddhistChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(false, BuddhistChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, BuddhistChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", BuddhistChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", BuddhistChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", BuddhistChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", BuddhistChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", BuddhistChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", BuddhistChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyear\", BuddhistChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", BuddhistChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", BuddhistChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", BuddhistChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", BuddhistChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, BuddhistChronology.getInstance().era().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().year().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", BuddhistChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", BuddhistChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", BuddhistChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", BuddhistChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", BuddhistChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", BuddhistChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", BuddhistChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", BuddhistChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", BuddhistChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", BuddhistChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", BuddhistChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, BuddhistChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, BuddhistChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestCopticChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for CopticChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestCopticChronology extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestCopticChronology.class);\n+    }\n+\n+    public TestCopticChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, CopticChronology.getInstanceUTC().getZone());\n+        assertSame(CopticChronology.class, CopticChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, CopticChronology.getInstance().getZone());\n+        assertSame(CopticChronology.class, CopticChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, CopticChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, CopticChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, CopticChronology.getInstance(null).getZone());\n+        assertSame(CopticChronology.class, CopticChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO));\n+        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(LONDON));\n+        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(PARIS));\n+        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC());\n+        assertSame(CopticChronology.getInstance(), CopticChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(LONDON).withUTC());\n+        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(TOKYO).withUTC());\n+        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC().withUTC());\n+        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance().withZone(PARIS));\n+        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"CopticChronology[Europe/London]\", CopticChronology.getInstance(LONDON).toString());\n+        assertEquals(\"CopticChronology[Asia/Tokyo]\", CopticChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"CopticChronology[Europe/London]\", CopticChronology.getInstance().toString());\n+        assertEquals(\"CopticChronology[UTC]\", CopticChronology.getInstanceUTC().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", CopticChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", CopticChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", CopticChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", CopticChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", CopticChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", CopticChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", CopticChronology.getInstance().days().getName());\n+        assertEquals(\"hours\", CopticChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", CopticChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", CopticChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", CopticChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, CopticChronology.getInstance().eras().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().years().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().months().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().days().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().hours().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, CopticChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, CopticChronology.getInstance().years().isPrecise());\n+        assertEquals(false, CopticChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, CopticChronology.getInstance().months().isPrecise());\n+        assertEquals(false, CopticChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, CopticChronology.getInstance().days().isPrecise());\n+        assertEquals(true, CopticChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, CopticChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, CopticChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, CopticChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, CopticChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, CopticChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, CopticChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, CopticChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", CopticChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", CopticChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", CopticChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", CopticChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", CopticChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", CopticChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyear\", CopticChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", CopticChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", CopticChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", CopticChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", CopticChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, CopticChronology.getInstance().era().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().year().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", CopticChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", CopticChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", CopticChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", CopticChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", CopticChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", CopticChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", CopticChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", CopticChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", CopticChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", CopticChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", CopticChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, CopticChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, CopticChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestGJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+/**\n+ * This class is a Junit unit test for GJChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJChronology extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJChronology.class);\n+    }\n+\n+    public TestGJChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, GJChronology.getInstanceUTC().getZone());\n+        assertSame(GJChronology.class, GJChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, GJChronology.getInstance().getZone());\n+        assertSame(GJChronology.class, GJChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, GJChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, GJChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, GJChronology.getInstance(null).getZone());\n+        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    public void testFactory_Zone_long_int() {\n+        GJChronology chrono = GJChronology.getInstance(TOKYO, 0L, 2);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(new Instant(0L), chrono.getGregorianCutover());\n+        assertEquals(2, chrono.getMinimumDaysInFirstWeek());\n+        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, 0L, 2).getClass());\n+        \n+        try {\n+            GJChronology.getInstance(TOKYO, 0L, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            GJChronology.getInstance(TOKYO, 0L, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testFactory_Zone_RI() {\n+        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L));\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(new Instant(0L), chrono.getGregorianCutover());\n+        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L)).getClass());\n+        \n+        DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);\n+        chrono = GJChronology.getInstance(TOKYO, null);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());\n+    }\n+\n+    public void testFactory_Zone_RI_int() {\n+        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L), 2);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(new Instant(0L), chrono.getGregorianCutover());\n+        assertEquals(2, chrono.getMinimumDaysInFirstWeek());\n+        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L), 2).getClass());\n+        \n+        DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);\n+        chrono = GJChronology.getInstance(TOKYO, null, 2);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());\n+        assertEquals(2, chrono.getMinimumDaysInFirstWeek());\n+        \n+        try {\n+            GJChronology.getInstance(TOKYO, new Instant(0L), 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            GJChronology.getInstance(TOKYO, new Instant(0L), 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO));\n+        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(LONDON));\n+        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(PARIS));\n+        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC());\n+        assertSame(GJChronology.getInstance(), GJChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(LONDON).withUTC());\n+        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(TOKYO).withUTC());\n+        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC().withUTC());\n+        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance().withZone(PARIS));\n+        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"GJChronology[Europe/London]\", GJChronology.getInstance(LONDON).toString());\n+        assertEquals(\"GJChronology[Asia/Tokyo]\", GJChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"GJChronology[Europe/London]\", GJChronology.getInstance().toString());\n+        assertEquals(\"GJChronology[UTC]\", GJChronology.getInstanceUTC().toString());\n+        assertEquals(\"GJChronology[UTC,cutover=1970-01-01]\", GJChronology.getInstance(DateTimeZone.UTC, 0L, 4).toString());\n+        assertEquals(\"GJChronology[UTC,cutover=1970-01-01T00:00:00.001Z,mdfw=2]\", GJChronology.getInstance(DateTimeZone.UTC, 1L, 2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", GJChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", GJChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", GJChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", GJChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", GJChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", GJChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", GJChronology.getInstance().days().getName());\n+        assertEquals(\"hours\", GJChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", GJChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", GJChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", GJChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, GJChronology.getInstance().eras().isSupported());\n+        assertEquals(true, GJChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, GJChronology.getInstance().years().isSupported());\n+        assertEquals(true, GJChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, GJChronology.getInstance().months().isSupported());\n+        assertEquals(true, GJChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, GJChronology.getInstance().days().isSupported());\n+        assertEquals(true, GJChronology.getInstance().hours().isSupported());\n+        assertEquals(true, GJChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, GJChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, GJChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, GJChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, GJChronology.getInstance().years().isPrecise());\n+        assertEquals(false, GJChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, GJChronology.getInstance().months().isPrecise());\n+        assertEquals(false, GJChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, GJChronology.getInstance().days().isPrecise());\n+        assertEquals(true, GJChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, GJChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, GJChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, GJChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, GJChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, GJChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, GJChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(false, GJChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, GJChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", GJChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", GJChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", GJChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", GJChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", GJChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", GJChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyear\", GJChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", GJChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", GJChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", GJChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", GJChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, GJChronology.getInstance().era().isSupported());\n+        assertEquals(true, GJChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, GJChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, GJChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, GJChronology.getInstance().year().isSupported());\n+        assertEquals(true, GJChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, GJChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, GJChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, GJChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, GJChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, GJChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", GJChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", GJChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", GJChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", GJChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", GJChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", GJChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", GJChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", GJChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", GJChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", GJChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", GJChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, GJChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, GJChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, GJChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, GJChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, GJChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, GJChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestGregorianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for GregorianChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGregorianChronology extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGregorianChronology.class);\n+    }\n+\n+    public TestGregorianChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, GregorianChronology.getInstanceUTC().getZone());\n+        assertSame(GregorianChronology.class, GregorianChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, GregorianChronology.getInstance().getZone());\n+        assertSame(GregorianChronology.class, GregorianChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, GregorianChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, GregorianChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, GregorianChronology.getInstance(null).getZone());\n+        assertSame(GregorianChronology.class, GregorianChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    public void testFactory_Zone_int() {\n+        GregorianChronology chrono = GregorianChronology.getInstance(TOKYO, 2);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(2, chrono.getMinimumDaysInFirstWeek());\n+        \n+        try {\n+            GregorianChronology.getInstance(TOKYO, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            GregorianChronology.getInstance(TOKYO, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO));\n+        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(LONDON));\n+        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(PARIS));\n+        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC());\n+        assertSame(GregorianChronology.getInstance(), GregorianChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(LONDON).withUTC());\n+        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(TOKYO).withUTC());\n+        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC().withUTC());\n+        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance().withZone(PARIS));\n+        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"GregorianChronology[Europe/London]\", GregorianChronology.getInstance(LONDON).toString());\n+        assertEquals(\"GregorianChronology[Asia/Tokyo]\", GregorianChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"GregorianChronology[Europe/London]\", GregorianChronology.getInstance().toString());\n+        assertEquals(\"GregorianChronology[UTC]\", GregorianChronology.getInstanceUTC().toString());\n+        assertEquals(\"GregorianChronology[UTC,mdfw=2]\", GregorianChronology.getInstance(DateTimeZone.UTC, 2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", GregorianChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", GregorianChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", GregorianChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", GregorianChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", GregorianChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", GregorianChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", GregorianChronology.getInstance().days().getName());\n+        assertEquals(\"hours\", GregorianChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", GregorianChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", GregorianChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", GregorianChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, GregorianChronology.getInstance().eras().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().years().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().months().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().days().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().hours().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, GregorianChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstance().years().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstance().months().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstance().days().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, GregorianChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(false, GregorianChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, GregorianChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", GregorianChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", GregorianChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", GregorianChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", GregorianChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", GregorianChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", GregorianChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyear\", GregorianChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", GregorianChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", GregorianChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", GregorianChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", GregorianChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, GregorianChronology.getInstance().era().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().year().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", GregorianChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", GregorianChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", GregorianChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", GregorianChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", GregorianChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", GregorianChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", GregorianChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", GregorianChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", GregorianChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", GregorianChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", GregorianChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, GregorianChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, GregorianChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n import org.joda.time.DateTimeZone;\n \n /**\n- * This class is a Junit unit test for Instant.\n+ * This class is a Junit unit test for ISOChronology.\n  *\n  * @author Stephen Colebourne\n  */\n     //-----------------------------------------------------------------------\n     public void testFactoryUTC() {\n         assertEquals(DateTimeZone.UTC, ISOChronology.getInstanceUTC().getZone());\n+        assertSame(ISOChronology.class, ISOChronology.getInstanceUTC().getClass());\n     }\n \n     public void testFactory() {\n         assertEquals(LONDON, ISOChronology.getInstance().getZone());\n+        assertSame(ISOChronology.class, ISOChronology.getInstance().getClass());\n     }\n \n     public void testFactory_Zone() {\n         assertEquals(TOKYO, ISOChronology.getInstance(TOKYO).getZone());\n         assertEquals(PARIS, ISOChronology.getInstance(PARIS).getZone());\n         assertEquals(LONDON, ISOChronology.getInstance(null).getZone());\n-    }\n-\n+        assertSame(ISOChronology.class, ISOChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testEquality() {\n         assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO));\n         assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON));\n         assertEquals(\"ISOChronology[UTC]\", ISOChronology.getInstanceUTC().toString());\n     }\n \n+    //-----------------------------------------------------------------------\n     public void testDurationFields() {\n         assertEquals(\"eras\", ISOChronology.getInstance().eras().getName());\n         assertEquals(\"centuries\", ISOChronology.getInstance().centuries().getName());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestJulianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for JulianChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestJulianChronology extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestJulianChronology.class);\n+    }\n+\n+    public TestJulianChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, JulianChronology.getInstanceUTC().getZone());\n+        assertSame(JulianChronology.class, JulianChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, JulianChronology.getInstance().getZone());\n+        assertSame(JulianChronology.class, JulianChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, JulianChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, JulianChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, JulianChronology.getInstance(null).getZone());\n+        assertSame(JulianChronology.class, JulianChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    public void testFactory_Zone_int() {\n+        JulianChronology chrono = JulianChronology.getInstance(TOKYO, 2);\n+        assertEquals(TOKYO, chrono.getZone());\n+        assertEquals(2, chrono.getMinimumDaysInFirstWeek());\n+        \n+        try {\n+            JulianChronology.getInstance(TOKYO, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            JulianChronology.getInstance(TOKYO, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO));\n+        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(LONDON));\n+        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(PARIS));\n+        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC());\n+        assertSame(JulianChronology.getInstance(), JulianChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(LONDON).withUTC());\n+        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(TOKYO).withUTC());\n+        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC().withUTC());\n+        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance().withZone(PARIS));\n+        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"JulianChronology[Europe/London]\", JulianChronology.getInstance(LONDON).toString());\n+        assertEquals(\"JulianChronology[Asia/Tokyo]\", JulianChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"JulianChronology[Europe/London]\", JulianChronology.getInstance().toString());\n+        assertEquals(\"JulianChronology[UTC]\", JulianChronology.getInstanceUTC().toString());\n+        assertEquals(\"JulianChronology[UTC,mdfw=2]\", JulianChronology.getInstance(DateTimeZone.UTC, 2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", JulianChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", JulianChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", JulianChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", JulianChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", JulianChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", JulianChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", JulianChronology.getInstance().days().getName());\n+        assertEquals(\"hours\", JulianChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", JulianChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", JulianChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", JulianChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, JulianChronology.getInstance().eras().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().years().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().months().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().days().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().hours().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, JulianChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, JulianChronology.getInstance().years().isPrecise());\n+        assertEquals(false, JulianChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, JulianChronology.getInstance().months().isPrecise());\n+        assertEquals(false, JulianChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, JulianChronology.getInstance().days().isPrecise());\n+        assertEquals(true, JulianChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, JulianChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, JulianChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, JulianChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, JulianChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, JulianChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, JulianChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(false, JulianChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, JulianChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", JulianChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", JulianChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", JulianChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", JulianChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", JulianChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", JulianChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyear\", JulianChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", JulianChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", JulianChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", JulianChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", JulianChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, JulianChronology.getInstance().era().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().year().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", JulianChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", JulianChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", JulianChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", JulianChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", JulianChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", JulianChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", JulianChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", JulianChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", JulianChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", JulianChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", JulianChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, JulianChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, JulianChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+}", "timestamp": 1093191406, "metainfo": ""}