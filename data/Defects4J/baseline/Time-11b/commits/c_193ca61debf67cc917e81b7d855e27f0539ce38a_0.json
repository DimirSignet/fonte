{"sha": "193ca61debf67cc917e81b7d855e27f0539ce38a", "log": "Add DateMidnight   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n      * using <code>ISOChronology</code> in the default time zone.\n      */\n     protected AbstractDateTime() {\n-        super();\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = DateTimeUtils.currentTimeMillis();\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n     }\n \n     /**\n      * @param zone  the time zone, null means default zone\n      */\n     protected AbstractDateTime(final DateTimeZone zone) {\n-        super();\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = DateTimeUtils.currentTimeMillis();\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n     }\n \n     /**\n      * @param chronology  the chronology, null means ISOChronology in default zone\n      */\n     protected AbstractDateTime(final Chronology chronology) {\n-        super();\n-        iChronology = selectChronology(chronology);\n-        iMillis = DateTimeUtils.currentTimeMillis();\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n      */\n     protected AbstractDateTime(final long instant) {\n-        super();\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = instant;\n+        this(instant, ISOChronology.getInstance());\n     }\n \n     /**\n      * @param zone  the time zone, null means default zone\n      */\n     protected AbstractDateTime(final long instant, final DateTimeZone zone) {\n-        super();\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = instant;\n+        this(instant, ISOChronology.getInstance(zone));\n     }\n \n     /**\n     protected AbstractDateTime(final long instant, final Chronology chronology) {\n         super();\n         iChronology = selectChronology(chronology);\n-        iMillis = instant;\n+        iMillis = round(instant, iChronology);\n     }\n \n     //-----------------------------------------------------------------------\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         iChronology = selectChronology(converter.getChronology(instant));\n-        iMillis = converter.getInstantMillis(instant);\n+        iMillis = round(converter.getInstantMillis(instant), iChronology);\n     }\n \n     /**\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         iChronology = selectChronology(converter.getChronology(instant, zone));\n-        iMillis = converter.getInstantMillis(instant, zone);\n+        iMillis = round(converter.getInstantMillis(instant, zone), iChronology);\n     }\n \n     /**\n         super();\n         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n         iChronology = selectChronology(converter.getChronology(instant, chronology));\n-        iMillis = converter.getInstantMillis(instant, chronology);\n+        iMillis = round(converter.getInstantMillis(instant, chronology), iChronology);\n     }\n \n     //-----------------------------------------------------------------------\n             final int minuteOfHour,\n             final int secondOfMinute,\n             final int millisOfSecond) {\n-        super();\n-        iChronology = ISOChronology.getInstance();\n-        iMillis = iChronology.getDateTimeMillis(\n-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance());\n     }\n \n     /**\n             final int secondOfMinute,\n             final int millisOfSecond,\n             final DateTimeZone zone) {\n-        super();\n-        iChronology = ISOChronology.getInstance(zone);\n-        iMillis = iChronology.getDateTimeMillis(\n-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n     }\n \n     /**\n             final Chronology chronology) {\n         super();\n         iChronology = selectChronology(chronology);\n-        iMillis = iChronology.getDateTimeMillis(\n-            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iMillis = round(instant, iChronology);\n+    }\n+\n+    /**\n+     * Rounds the specified instant as required by the subclass.\n+     * This method must not access instance variables.\n+     * <p>\n+     * This implementation performs no rounding and returns the instant.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param chronology  the chronology to use, not null\n+     */\n+    protected long round(long instant, Chronology chronology) {\n+        return instant;\n     }\n \n     // Accessors\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.property.AbstractReadableInstantFieldProperty;\n+\n+/**\n+ * DateMidnight defines a date where the time component is fixed at midnight.\n+ * The class uses a time zone, if supplied, so midnight is local unless a UTC\n+ * time zone is used.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getDayOfMonth()</code>\n+ * <li><code>dayOfMonth().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * DateMidnight is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class DateMidnight extends AbstractDateTime\n+        implements ReadableDateTime, Serializable {\n+    \n+    /** Serialization lock */\n+    private static final long serialVersionUID = 156371964018738L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     */\n+    public DateMidnight() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateMidnight(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public DateMidnight(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateMidnight(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, ISOChronology in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\n+    }\n+\n+    /**\n+     * Rounds the specified instant as required by the subclass.\n+     * This method must not access instance variables.\n+     * <p>\n+     * This implementation performs no rounding and returns the instant.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param chronology  the chronology to use, not null\n+     */\n+    protected long round(long instant, Chronology chronology) {\n+        return chronology.dayOfMonth().roundFloor(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * The returned object will have a local time of midnight.\n+     * <p>\n+     * Only the millis will change, the chronology and time zone are kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public final DateMidnight withMillis(long newMillis) {\n+        Chronology chrono = getChronology();\n+        newMillis = round(newMillis, chrono);\n+        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * The returned object will have a local time of midnight in the new chronology.\n+     * <p>\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     */\n+    public final DateMidnight withChronology(Chronology newChronology) {\n+        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with a different time zone, preserving the\n+     * millisecond instant.\n+     * The returned object will have a local time of midnight.\n+     * <p>\n+     * This method is useful for finding the local time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London, the result\n+     * from this method with Europe/Paris would be 13:30.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method changes alters the time zone, and does not change the\n+     * millisecond instant, with the effect that the field values usually change.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newDateTimeZone  the new time zone\n+     * @return a copy of this instant with a different time zone\n+     * @see #withZoneRetainFields\n+     */\n+    public final DateMidnight withZone(DateTimeZone newDateTimeZone) {\n+        return withChronology(getChronology().withZone(newDateTimeZone));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with a different time zone, preserving the\n+     * field values.\n+     * The returned object will have a local time of midnight.\n+     * <p>\n+     * This method is useful for finding the millisecond time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method alters the time zone and the millisecond instant to keep\n+     * the field values the same.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newDateTimeZone  the new time zone\n+     * @return a copy of this instant with a different time zone\n+     * @see #withZone\n+     */\n+    public final DateMidnight withZoneRetainFields(DateTimeZone newDateTimeZone) {\n+        final long originalMillis = getMillis();\n+        final Chronology originalChrono = getChronology();\n+        final DateTimeZone originalZone;\n+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {\n+            // Without an original chronology or time zone, no new time zone\n+            // can be set. Call withMillis to let it decide if a clone should\n+            // be made or not.\n+            return withMillis(originalMillis);\n+        }\n+\n+        DateMidnight newInstant = withChronology(originalChrono.withZone(newDateTimeZone));\n+        newDateTimeZone = newInstant.getZone();\n+\n+        if (newDateTimeZone == null || newDateTimeZone == originalZone) {\n+            // New time zone didn't stick or didn't change. Skip millis adjustment.\n+            return newInstant;\n+        }\n+\n+        long newMillis = originalMillis + originalZone.getOffset(originalMillis);\n+        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);\n+\n+        return newInstant.withMillis(newMillis);\n+    }\n+\n+    // Date properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public final Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public final Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public final Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public final Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public final Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public final Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     */\n+    public final Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property.\n+     * \n+     * @return the day of week property\n+     */\n+    public final Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-dd'T'00:00:00.000Z).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setMillis(long millis) {\n+    }\n+\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are\n+     * immutable.\n+     */\n+    protected final void setChronology(Chronology chronology) {\n+    }\n+\n+    /**\n+     * DateTimeFieldProperty binds a DateMidnight to a DateTimeField allowing powerful\n+     * datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.monthOfYear().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateMidnight - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n+     * DateMidnight dt20 = dt.year().addToCopy(20);\n+     * </pre>\n+     * Serious modification of dates (ie. more than just changing one or two fields)\n+     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n+     * <p>\n+     * DateMidnight.Property itself is thread-safe and immutable.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static class Property extends AbstractReadableInstantFieldProperty {\n+    \n+        /** Serialization lock */\n+        private static final long serialVersionUID = 257629620L;\n+        \n+        /** The instant this property is working against */\n+        private final DateMidnight iInstant;\n+        /** The field this property is working against */\n+        private final DateTimeField iField;\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        public Property(DateMidnight instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+\n+        /**\n+         * Gets the instant being used.\n+         * \n+         * @return the instant\n+         */\n+        public ReadableInstant getReadableInstant() {\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Gets the datetime being used.\n+         * \n+         * @return the datetime\n+         */\n+        public DateMidnight getDateMidnight() {\n+            return iInstant;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addToCopy(int value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+\n+        /**\n+         * Adds to this field in a copy of this DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addToCopy(long value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+\n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addWrapFieldToCopy(int value) {\n+            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight setCopy(int value) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n+        }\n+    \n+        /**\n+         * Sets this field in a copy of the DateMidnight to a parsed text value.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateMidnight setCopy(String text, Locale locale) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the DateMidnight to a parsed text value.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public final DateMidnight setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundFloorCopy() {\n+            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundCeilingCopy() {\n+            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n+         * favoring the floor if halfway.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfFloorCopy() {\n+            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n+         * favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfCeilingCopy() {\n+            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.\n+         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfEvenCopy() {\n+            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n+        }\n+\n+    }\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        suite.addTest(TestInstant_Constructors.suite());\n+        suite.addTest(TestInstant_Basics.suite());\n+        \n         suite.addTest(TestDateTime_Constructors.suite());\n         suite.addTest(TestDateTime_Basics.suite());\n         suite.addTest(TestDateTime_Properties.suite());\n+        \n+        suite.addTest(TestDateMidnight_Constructors.suite());\n+        \n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n-        suite.addTest(TestInstant_Constructors.suite());\n-        suite.addTest(TestInstant_Basics.suite());\n //        suite.addTest(TestParseISO.suite());\n         return suite;\n     }\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for DateMidnight.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateMidnight_Constructors extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW_UTC =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+    private long TEST_TIME_NOW_LONDON =\n+            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME_NOW_PARIS =\n+            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+    \n+    // 2002-04-05\n+    private long TEST_TIME1_UTC =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    private long TEST_TIME1_LONDON =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME1_PARIS =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+    \n+    // 2003-05-06\n+    private long TEST_TIME2_UTC =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    private long TEST_TIME2_LONDON =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+             - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME2_PARIS =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+             - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+    \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateMidnight_Constructors.class);\n+    }\n+\n+    public TestDateMidnight_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW_UTC).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1_UTC).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2_UTC).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        DateMidnight test = new DateMidnight();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone)\n+     */\n+    public void testConstructor_DateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone=null)\n+     */\n+    public void testConstructor_nullDateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight((DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        DateMidnight test = new DateMidnight((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME2_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone)\n+     */\n+    public void testConstructor_long1_DateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone)\n+     */\n+    public void testConstructor_long2_DateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME2_PARIS, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone=null)\n+     */\n+    public void testConstructor_long_nullDateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME2_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1_UTC);\n+        DateMidnight test = new DateMidnight(date);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_invalidObject() throws Throwable {\n+        try {\n+            new DateMidnight(new Object());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        DateMidnight test = new DateMidnight((Object) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateMidnight test = new DateMidnight(new Integer(0));\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_Object_DateTimeZone() throws Throwable {\n+        Date date = new Date(TEST_TIME1_UTC);\n+        DateMidnight test = new DateMidnight(date, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {\n+        try {\n+            new DateMidnight(new Object(), PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, DateTimeZone)\n+     */\n+    public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight((Object) null, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone=null)\n+     */\n+    public void testConstructor_Object_nullDateTimeZone() throws Throwable {\n+        Date date = new Date(TEST_TIME1_UTC);\n+        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, DateTimeZone=null)\n+     */\n+    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1_UTC);\n+        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_invalidObject_Chronology() throws Throwable {\n+        try {\n+            new DateMidnight(new Object(), GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1_UTC);\n+        DateMidnight test = new DateMidnight(date, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        DateMidnight test = new DateMidnight(2002, 6, 9);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(LONDON, test.getZone());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new DateMidnight(Integer.MIN_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(Integer.MAX_VALUE, 6, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 0, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 13, 9);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 31);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateMidnight(2002, 7, 31);\n+        try {\n+            new DateMidnight(2002, 7, 32);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, DateTimeZone)\n+     */\n+    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 0, 9, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 13, 9, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 31, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateMidnight(2002, 7, 31, PARIS);\n+        try {\n+            new DateMidnight(2002, 7, 32, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, DateTimeZone=null)\n+     */\n+    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {\n+        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        try {\n+            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());\n+        try {\n+            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+    }\n+\n+}", "timestamp": 1089579738, "metainfo": ""}