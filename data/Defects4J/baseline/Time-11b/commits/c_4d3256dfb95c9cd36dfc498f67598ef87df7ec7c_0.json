{"sha": "4d3256dfb95c9cd36dfc498f67598ef87df7ec7c", "log": "Merge commit '6b1b998c82879495a0587fc0559314e9605061bc'", "commit": "\n--- a/src/main/java/org/joda/time/chrono/BaseChronology.java\n+++ b/src/main/java/org/joda/time/chrono/BaseChronology.java\n             DateTimeField field = partial.getField(i);\n             if (value < field.getMinimumValue()) {\n                 throw new IllegalFieldValueException\n-                    (field.getType(), new Integer(value),\n-                     new Integer(field.getMinimumValue()), null);\n+                    (field.getType(), Integer.valueOf(value),\n+                     Integer.valueOf(field.getMinimumValue()), null);\n             }\n             if (value > field.getMaximumValue()) {\n                 throw new IllegalFieldValueException\n-                    (field.getType(), new Integer(value),\n-                     null, new Integer(field.getMaximumValue()));\n+                    (field.getType(), Integer.valueOf(value),\n+                     null, Integer.valueOf(field.getMaximumValue()));\n             }\n         }\n         // check values in specific range, catching really odd cases like 30th Feb\n             DateTimeField field = partial.getField(i);\n             if (value < field.getMinimumValue(partial, values)) {\n                 throw new IllegalFieldValueException\n-                    (field.getType(), new Integer(value),\n-                     new Integer(field.getMinimumValue(partial, values)), null);\n+                    (field.getType(), Integer.valueOf(value),\n+                     Integer.valueOf(field.getMinimumValue(partial, values)), null);\n             }\n             if (value > field.getMaximumValue(partial, values)) {\n                 throw new IllegalFieldValueException\n-                    (field.getType(), new Integer(value),\n-                     null, new Integer(field.getMaximumValue(partial, values)));\n+                    (field.getType(), Integer.valueOf(value),\n+                     null, Integer.valueOf(field.getMaximumValue(partial, values)));\n             }\n         }\n     }\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n                     // Verify that new value stuck.\n                     if (get(instant) != value) {\n                         throw new IllegalFieldValueException\n-                            (iGregorianField.getType(), new Integer(value), null, null);\n+                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                     }\n                 }\n             } else {\n                     // Verify that new value stuck.\n                     if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n-                            (iJulianField.getType(), new Integer(value), null, null);\n+                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                     }\n                 }\n             }\n--- a/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java\n+++ b/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java\n \n         Integer[] integers = new Integer[13];\n         for (int i=0; i<13; i++) {\n-            integers[i] = new Integer(i);\n+            integers[i] = Integer.valueOf(i);\n         }\n \n         iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n--- a/src/main/java/org/joda/time/chrono/JulianChronology.java\n+++ b/src/main/java/org/joda/time/chrono/JulianChronology.java\n         if (year <= 0) {\n             if (year == 0) {\n                 throw new IllegalFieldValueException\n-                    (DateTimeFieldType.year(), new Integer(year), null, null);\n+                    (DateTimeFieldType.year(), Integer.valueOf(year), null, null);\n             }\n             year++;\n         }\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n             localInstant = iField.set(localInstant, value);\n             long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n-                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n+                throw new IllegalFieldValueException(iField.getType(), Integer.valueOf(value),\n                     \"Illegal instant due to time zone offset transition: \" +\n                     DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                     \" (\" + iZone.getID() + \")\");\n--- a/src/main/java/org/joda/time/field/DelegatedDurationField.java\n+++ b/src/main/java/org/joda/time/field/DelegatedDurationField.java\n         return iField.compareTo(durationField);\n     }\n \n+    public boolean equals(Object o) {\n+        if (o instanceof DelegatedDurationField) {\n+            return iField.equals(((DelegatedDurationField) o).iField);\n+        }\n+\n+        return false;\n+    }\n+\n+    public int hashCode() {\n+        return iField.hashCode() ^ iType.hashCode();\n+    }\n+\n     public String toString() {\n         return (iType == null) ? iField.toString() :\n             (\"DurationField[\" + iType + ']');\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n                                          int value, int lowerBound, int upperBound) {\n         if ((value < lowerBound) || (value > upperBound)) {\n             throw new IllegalFieldValueException\n-                (field.getType(), new Integer(value),\n-                 new Integer(lowerBound), new Integer(upperBound));\n+                (field.getType(), Integer.valueOf(value),\n+                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n         }\n     }\n \n                                          int value, int lowerBound, int upperBound) {\n         if ((value < lowerBound) || (value > upperBound)) {\n             throw new IllegalFieldValueException\n-                (fieldType, new Integer(value),\n-                 new Integer(lowerBound), new Integer(upperBound));\n+                (fieldType, Integer.valueOf(value),\n+                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n         }\n     }\n \n                                          int value, int lowerBound, int upperBound) {\n         if ((value < lowerBound) || (value > upperBound)) {\n             throw new IllegalFieldValueException\n-                (fieldName, new Integer(value),\n-                 new Integer(lowerBound), new Integer(upperBound));\n+                (fieldName, Integer.valueOf(value),\n+                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n         }\n     }\n \n--- a/src/main/java/org/joda/time/field/MillisDurationField.java\n+++ b/src/main/java/org/joda/time/field/MillisDurationField.java\n         }\n     }\n \n+    public boolean equals(Object o) {\n+        if (o instanceof MillisDurationField) {\n+            return getUnitMillis() == ((MillisDurationField) o).getUnitMillis();\n+        }\n+\n+        return false;\n+    }\n+\n+    public int hashCode() {\n+        return (int)getUnitMillis();\n+    }\n+\n     /**\n      * Get a suitable debug string.\n      * \n--- a/src/main/java/org/joda/time/field/SkipDateTimeField.java\n+++ b/src/main/java/org/joda/time/field/SkipDateTimeField.java\n         if (value <= iSkip) {\n             if (value == iSkip) {\n                 throw new IllegalFieldValueException\n-                    (DateTimeFieldType.year(), new Integer(value), null, null);\n+                    (DateTimeFieldType.year(), Integer.valueOf(value), null, null);\n             }\n             value++;\n         }\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n      * @since 1.1\n      */\n     public DateTimeFormatter withPivotYear(int pivotYear) {\n-        return withPivotYear(new Integer(pivotYear));\n+        return withPivotYear(Integer.valueOf(pivotYear));\n     }\n \n     /**\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n                         validValues.add(\"ce\");\n                         maxLength = 3;\n                     }\n-                    array = new Object[] {validValues, new Integer(maxLength)};\n+                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                     innerMap.put(iFieldType, array);\n                 } else {\n                     validValues = (Set<String>) array[0];\n--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n                         periodStr.regionMatches\n                         (true, position, parsedForm, 0, parsedForm.length())) {\n                         \n-                        position += parsedForm.length();\n+                        position += (parsedForm == null) ? 0 : parsedForm.length();\n                         found = true;\n                         break;\n                     }\n--- a/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n                                           boolean advanceDayOfWeek,\n                                           int millisOfDay)\n     {\n-        OfYear ofYear = new OfYear\n-            (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n         if (iRuleSets.size() > 0) {\n+            OfYear ofYear = new OfYear\n+                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n             RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n             lastRuleSet.setUpperLimit(year, ofYear);\n         }\n--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n                         file.getParentFile().mkdirs();\n                     }\n                     OutputStream out = new FileOutputStream(file);\n-                    builder.writeTo(zone.iName, out);\n-                    out.close();\n+                    try {\n+                        builder.writeTo(zone.iName, out);\n+                    } finally {\n+                        out.close();\n+                    }\n \n                     // Test if it can be read back.\n                     InputStream in = new FileInputStream(file);\n \n             OutputStream out = new FileOutputStream(file);\n             DataOutputStream dout = new DataOutputStream(out);\n-            // Sort and filter out any duplicates that match case.\n-            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n-            zimap.putAll(map);\n-            writeZoneInfoMap(dout, zimap);\n-            dout.close();\n+            try {\n+                // Sort and filter out any duplicates that match case.\n+                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n+                zimap.putAll(map);\n+                writeZoneInfoMap(dout, zimap);\n+            } finally {\n+                dout.close();\n+            }\n         }\n \n         return map;\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getZone() == null) {\n+        if (iOffsetParsed && bucket.getOffset() != null) {\n             int parsedOffset = bucket.getOffset();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n             chrono = chrono.withZone(parsedZone);\n+        } else if (bucket.getZone() != null) {\n+            chrono = chrono.withZone(bucket.getZone());\n         }\n         instant.setChronology(chrono);\n+        if (iZone != null) {\n+            instant.setZone(iZone);\n+        }\n         return newPos;\n     }\n \n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\n+                if (bucket.getOffset() != null) {  // treat withOffsetParsed() as being true\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n                 return new LocalDateTime(millis, chrono);\n             }\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getZone() == null) {\n+                if (iOffsetParsed && bucket.getOffset() != null) {\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n-                return new DateTime(millis, chrono);\n+                DateTime dt = new DateTime(millis, chrono);\n+                if (iZone != null) {\n+                    dt = dt.withZone(iZone);\n+                }\n+                return dt;\n             }\n         } else {\n             newPos = ~newPos;\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getZone() == null) {\n+                if (iOffsetParsed && bucket.getOffset() != null) {\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n-                return new MutableDateTime(millis, chrono);\n+                MutableDateTime dt = new MutableDateTime(millis, chrono);\n+                if (iZone != null) {\n+                    dt.setZone(iZone);\n+                }\n+                return dt;\n             }\n         } else {\n             newPos = ~newPos;\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     }\n \n     /**\n-     * Instructs the printer to emit a locale-specific time zone name. A\n-     * parser cannot be created from this builder if a time zone name is\n-     * appended.\n+     * Instructs the printer to emit a locale-specific time zone name.\n+     * Using this method prevents parsing, because time zone names are not unique.\n+     * See {@link #appendTimeZoneName(Map)}.\n      *\n      * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n-        return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);\n+        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n+     * Time zone names are not unique, thus the API forces you to supply the lookup.\n+     * The names are searched in the order of the map, thus it is strongly recommended\n+     * to use a {@code LinkedHashMap} or similar.\n+     *\n+     * @param parseLookup  the table of names, not null\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n+        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n+        return append0(pp, pp);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific time zone name.\n+     * Using this method prevents parsing, because time zone names are not unique.\n+     * See {@link #appendTimeZoneShortName(Map)}.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n+        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n     }\n \n     /**\n      * Instructs the printer to emit a short locale-specific time zone\n-     * name. A parser cannot be created from this builder if time zone\n-     * name is appended.\n-     *\n-     * @return this DateTimeFormatterBuilder, for chaining\n-     */\n-    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n-        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);\n+     * name, providing a lookup for parsing.\n+     * Time zone names are not unique, thus the API forces you to supply the lookup.\n+     * The names are searched in the order of the map, thus it is strongly recommended\n+     * to use a {@code LinkedHashMap} or similar.\n+     *\n+     * @param parseLookup  the table of names, not null\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n+        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n+        return append0(pp, pp);\n     }\n \n     /**\n      * Instructs the printer to emit the identifier of the time zone.\n-     * This field cannot currently be parsed.\n+     * From version 2.0, this field can be parsed.\n      *\n      * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneId() {\n-        return append0(new TimeZoneName(TimeZoneName.ID), null);\n+        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n     }\n \n     /**\n \n     //-----------------------------------------------------------------------\n     static class TimeZoneName\n-            implements DateTimePrinter {\n+            implements DateTimePrinter, DateTimeParser {\n \n         static final int LONG_NAME = 0;\n         static final int SHORT_NAME = 1;\n-        static final int ID = 2;\n-\n+\n+        private final Map<String, DateTimeZone> iParseLookup;\n         private final int iType;\n \n-        TimeZoneName(int type) {\n+        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n             super();\n             iType = type;\n+            iParseLookup = parseLookup;\n         }\n \n         public int estimatePrintedLength() {\n                     return displayZone.getName(instant, locale);\n                 case SHORT_NAME:\n                     return displayZone.getShortName(instant, locale);\n-                case ID:\n-                    return displayZone.getID();\n             }\n             return \"\";\n         }\n \n         public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             // no zone info\n+        }\n+\n+        public int estimateParsedLength() {\n+            return (iType == SHORT_NAME ? 4 : 20);\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            String str = text.substring(position);\n+            for (String name : iParseLookup.keySet()) {\n+                if (str.startsWith(name)) {\n+                    bucket.setZone(iParseLookup.get(name));\n+                    return position + name.length();\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static enum TimeZoneId\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        INSTANCE;\n+        static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\n+        static final int MAX_LENGTH;\n+        static {\n+            int max = 0;\n+            for (String id : ALL_IDS) {\n+                max = Math.max(max, id.length());\n+            }\n+            MAX_LENGTH = max;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return MAX_LENGTH;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(displayZone != null ? displayZone.getID() : \"\");\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(displayZone != null ? displayZone.getID() : \"\");\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            // no zone info\n+        }\n+\n+        public int estimateParsedLength() {\n+            return MAX_LENGTH;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            String str = text.substring(position);\n+            for (String id : ALL_IDS) {\n+                if (str.startsWith(id)) {\n+                    bucket.setZone(DateTimeZone.forID(id));\n+                    return position + id.length();\n+                }\n+            }\n+            return ~position;\n         }\n     }\n \n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n     \n     // TimeZone to switch to in computeMillis. If null, use offset.\n     private DateTimeZone iZone;\n-    private int iOffset;\n+    private Integer iOffset;\n     /** The locale to use for parsing. */\n     private Locale iLocale;\n     /** Used for parsing two-digit years. */\n         super();\n         chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n+        iZone = chrono.getZone();\n         iChrono = chrono.withUTC();\n         iLocale = (locale == null ? Locale.getDefault() : locale);\n-        setZone(chrono.getZone());\n         iPivotYear = pivotYear;\n         iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the time zone used by computeMillis, or null if an offset is\n-     * used instead.\n+     * Returns the time zone used by computeMillis.\n      */\n     public DateTimeZone getZone() {\n         return iZone;\n     }\n-    \n-    /**\n-     * Set a time zone to be used when computeMillis is called, which\n-     * overrides any set time zone offset.\n-     *\n-     * @param zone the date time zone to operate in, or null if UTC\n+\n+    /**\n+     * Set a time zone to be used when computeMillis is called.\n+     *\n+     * @param zone the date time zone to operate in, not null\n      */\n     public void setZone(DateTimeZone zone) {\n         iSavedState = null;\n-        iZone = zone == DateTimeZone.UTC ? null : zone;\n-        iOffset = 0;\n-    }\n-    \n+        iZone = zone;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the time zone offset in milliseconds used by computeMillis,\n-     * unless getZone doesn't return null.\n-     */\n-    public int getOffset() {\n+     * Returns the time zone offset in milliseconds used by computeMillis.\n+     */\n+    public Integer getOffset() {\n         return iOffset;\n     }\n-    \n-    /**\n-     * Set a time zone offset to be used when computeMillis is called, which\n-     * overrides the time zone.\n-     */\n-    public void setOffset(int offset) {\n+\n+    /**\n+     * Set a time zone offset to be used when computeMillis is called.\n+     */\n+    public void setOffset(Integer offset) {\n         iSavedState = null;\n         iOffset = offset;\n-        iZone = null;\n     }\n \n     //-----------------------------------------------------------------------\n             throw e;\n         }\n         \n-        if (iZone == null) {\n+        if (iOffset != null) {\n             millis -= iOffset;\n-        } else {\n+        } else if (iZone != null) {\n             int offset = iZone.getOffsetFromLocal(millis);\n             millis -= offset;\n             if (offset != iZone.getOffset(millis)) {\n \n     class SavedState {\n         final DateTimeZone iZone;\n-        final int iOffset;\n+        final Integer iOffset;\n         final SavedField[] iSavedFields;\n         final int iSavedFieldsCount;\n         \n--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  */\n package org.joda.time.format;\n \n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n import org.joda.time.DateTime;\n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDateTime;\n \n /**\n  * This class is a Junit unit test for DateTimeFormatterBuilder.\n  */\n public class TestDateTimeFormatterBuilder extends TestCase {\n \n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+\n     public static void main(String[] args) {\n         junit.textui.TestRunner.run(suite());\n     }\n         } catch (IllegalArgumentException e) {\n         }\n     }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_appendTimeZoneId() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n+        bld.appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        assertEquals(\"Asia/Tokyo\", f.print(new DateTime(2007, 3, 4, 0, 0, 0, TOKYO)));\n+        assertEquals(TOKYO, f.parseDateTime(\"Asia/Tokyo\").getZone());\n+        try {\n+            f.parseDateTime(\"Nonsense\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseZoneTokyo() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n+        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n+    }\n+\n+    public void test_printParseZoneParis() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, PARIS);\n+        assertEquals(\"2007-03-04 12:30 Europe/Paris\", f.print(dt));\n+        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n+        assertEquals(dt, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n+    }\n+\n+    public void test_printParseOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n+        assertEquals(dt.withZone(DateTimeZone.getDefault()), f.parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(dt, f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+    }\n+\n+    public void test_printParseOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n+        assertEquals(dt, f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt.withZone(PARIS), f.withZone(PARIS).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+    }\n+\n+    public void test_parseWrongOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+        // parses offset time returning offset zone\n+        assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+        // parses offset time then converts to default zone\n+        assertEquals(expected.withZone(DateTimeZone.getDefault()), f.parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+    }\n+\n+    public void test_parseWrongOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n+        // parses offset time then adjusts to parsed zone\n+        assertEquals(expected.withZone(TOKYO), f.parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time returning offset zone (ignores zone)\n+        assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_localPrintParseZoneTokyo() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n+    }\n+\n+    public void test_localPrintParseOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+    }\n+\n+    public void test_localPrintParseOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n+        assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(expected, f.withZone(PARIS).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+    }\n+\n+    public void test_localParseWrongOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        // parses offset time then adjusts to parsed zone\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time returning offset zone (ignores zone)\n+        assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_printParseShortName() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName();\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 GMT\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 BST\", f.print(dt2));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 GMT\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseShortNameWithLookup() {\n+        Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>();\n+        lookup.put(\"GMT\", LONDON);\n+        lookup.put(\"BST\", LONDON);\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName(lookup);\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 GMT\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 BST\", f.print(dt2));\n+        \n+        assertEquals(dt1, f.parseDateTime(\"2011-01-04 12:30 GMT\"));\n+        assertEquals(dt2, f.parseDateTime(\"2011-07-04 12:30 BST\"));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 EST\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_printParseLongName() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneName();\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 Greenwich Mean Time\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 British Summer Time\", f.print(dt2));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 GMT\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseLongNameWithLookup() {\n+        Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>();\n+        lookup.put(\"Greenwich Mean Time\", LONDON);\n+        lookup.put(\"British Summer Time\", LONDON);\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneName(lookup);\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-01-04 12:30 Greenwich Mean Time\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n+        assertEquals(\"2011-07-04 12:30 British Summer Time\", f.print(dt2));\n+        \n+        assertEquals(dt1, f.parseDateTime(\"2011-01-04 12:30 Greenwich Mean Time\"));\n+        assertEquals(dt2, f.parseDateTime(\"2011-07-04 12:30 British Summer Time\"));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 EST\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n }", "timestamp": 1312029596, "metainfo": ""}