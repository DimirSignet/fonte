{"sha": "a23eb4c8a802acd34aa2789be8a5a282decc6c1f", "log": "Make class names follow consistent naming pattern.   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.property;\n+\n+import java.util.Locale;\n+import java.io.Serializable;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * AbstractReadableInstantFieldProperty is a base class for binding a\n+ * ReadableInstant to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ * <p>\n+ * AbstractReadableInstantFieldProperty itself is thread-safe and immutable,\n+ * but the ReadableInstant being operated on may be mutable and not\n+ * thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractReadableInstantFieldProperty implements Serializable {\n+    \n+    static final long serialVersionUID = 1971226328211649661L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public AbstractReadableInstantFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public abstract ReadableInstant getInstant();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the instant.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     */\n+    public int get() {\n+        return getField().get(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public final String getAsText() {\n+        return getField().getAsText(getInstant().getMillis(), null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getInstant().getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public final String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant the subtrahend\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public int getDifference(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return getField().getDifference(getInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant the subtrahend\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public long getDifferenceAsLong(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    /**\n+     * Gets whether this field is leap.\n+     * \n+     * @return true if a leap field\n+     * @see DateTimeField#isLeap\n+     */\n+    public boolean isLeap() {\n+        return getField().isLeap(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is leap.\n+     * \n+     * @return the amount by which the field is leap\n+     * @see DateTimeField#getLeapAmount\n+     */\n+    public int getLeapAmount() {\n+        return getField().getLeapAmount(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return getField().getLeapDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getInstant().getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field.\n+     *\n+     * @see DateTimeField#remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder() {\n+        return getField().remainder(getInstant().getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java\n  *\n  * @author Brian S O'Neill\n  */\n-public class DateOnlyFieldProperty extends AbstractDateTimeFieldProperty {\n+public class DateOnlyFieldProperty extends AbstractReadableInstantFieldProperty {\n \n     static final long serialVersionUID = -7764886769525930067L;\n \n--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {\n+public class DateTimeFieldProperty extends AbstractReadableInstantFieldProperty {\n     \n     static final long serialVersionUID = -6983323811635733510L;\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.property;\n+\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadWritableInstant;\n+\n+/**\n+ * ReadWritabelInstantFieldProperty binds a ReadWritableInstant to a\n+ * DateTimeField allowing powerful datetime functionality to be easily\n+ * accessed.\n+ * <p>\n+ * The example below shows how to use the property to change the value of a\n+ * MutableDateTime object.\n+ * <pre>\n+ * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 0, 0, 0, 0);\n+ * dt.year().add(20);\n+ * dt.second().roundFloor();\n+ * dt.minute().set(10);\n+ * </pre>\n+ * <p>\n+ * ReadWritableInstantFieldPropery itself is thread-safe and immutable, but the\n+ * ReadWritableInstant being operated on may not be thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class ReadWritableInstantFieldProperty extends AbstractReadableInstantFieldProperty {\n+\n+    static final long serialVersionUID = -4481126543819298617L;\n+\n+    /** The instant this property is working against */\n+    private final ReadWritableInstant iInstant;\n+    /** The field this property is working against */\n+    private final DateTimeField iField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param instant  the instant to set\n+     * @param field  the field to use\n+     */\n+    public ReadWritableInstantFieldProperty(ReadWritableInstant instant, DateTimeField field) {\n+        super();\n+        iInstant = instant;\n+        iField = field;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public ReadableInstant getInstant() {\n+        return iInstant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the millis value.\n+     * \n+     * @param value  the value to add\n+     * @see DateTimeField#add(long,int)\n+     */\n+    public void add(int value) {\n+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Adds a value to the millis value.\n+     * \n+     * @param value  the value to add\n+     * @see DateTimeField#add(long,long)\n+     */\n+    public void add(long value) {\n+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Adds a value, possibly wrapped, to the millis value.\n+     * \n+     * @param value  the value to add\n+     * @see DateTimeField#addWrapped\n+     */\n+    public void addWrapped(int value) {\n+        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets a value.\n+     * \n+     * @param value  the value to set.\n+     * @see DateTimeField#set(long,int)\n+     */\n+    public void set(int value) {\n+        iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Sets a text value.\n+     * \n+     * @param text  the text value to set\n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n+     */\n+    public void set(String text, Locale locale) {\n+        iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n+    }\n+\n+    /**\n+     * Sets a text value.\n+     * \n+     * @param text  the text value to set\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     * @see DateTimeField#set(long,java.lang.String)\n+     */\n+    public final void set(String text) {\n+        set(text, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field.\n+     *\n+     * @see DateTimeField#roundFloor\n+     */\n+    public void roundFloor() {\n+        iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the highest whole unit of this field.\n+     *\n+     * @see DateTimeField#roundCeiling\n+     */\n+    public void roundCeiling() {\n+        iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field, favoring the floor if\n+     * halfway.\n+     *\n+     * @see DateTimeField#roundHalfFloor\n+     */\n+    public void roundHalfFloor() {\n+        iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field, favoring the ceiling if\n+     * halfway.\n+     *\n+     * @see DateTimeField#roundHalfCeiling\n+     */\n+    public void roundHalfCeiling() {\n+        iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If halfway, the ceiling\n+     * is favored over the floor only if it makes this field's value even.\n+     *\n+     * @see DateTimeField#roundHalfEven\n+     */\n+    public void roundHalfEven() {\n+        iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java\n  *\n  * @author Brian S O'Neill\n  */\n-public class TimeOnlyFieldProperty extends AbstractDateTimeFieldProperty {\n+public class TimeOnlyFieldProperty extends AbstractReadableInstantFieldProperty {\n \n     static final long serialVersionUID = 8826542069120527929L;\n ", "timestamp": 1073201399, "metainfo": ""}