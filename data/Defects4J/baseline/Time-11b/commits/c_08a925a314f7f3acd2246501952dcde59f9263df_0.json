{"sha": "08a925a314f7f3acd2246501952dcde59f9263df", "log": "Add DateMidnight tests   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateMidnight.java\n+++ b/JodaTime/src/java/org/joda/time/DateMidnight.java\n \n /**\n  * DateMidnight defines a date where the time component is fixed at midnight.\n- * The class uses a time zone, if supplied, so midnight is local unless a UTC\n- * time zone is used.\n+ * The class uses a time zone, thus midnight is local unless a UTC time zone is used.\n+ * <p>\n+ * It is important to emphasise that this class represents the time of midnight on\n+ * any given day.\n+ * Note that midnight is defined as 00:00, which is at the very start of a day.\n+ * <p>\n+ * This class does not represent a day, but the millisecond instant at midnight.\n+ * If you need a class that represnts the whole day, then an {@link Interval} or\n+ * a {@link YearMonthDay} may be more suitable.\n  * <p>\n  * This class uses a Chronology internally. The Chronology determines how the\n  * millisecond instant value is converted into the date time fields.\n     }\n \n     /**\n-     * Gets a copy of this instant with a different chronology.\n-     * The returned object will have a local time of midnight in the new chronology.\n-     * <p>\n-     * The returned object will be either be a new instance or <code>this</code>.\n+     * Gets a copy of this instant with a different chronology, potentially\n+     * changing the day in unexpected ways.\n+     * <p>\n+     * This method creates a new DateMidnight using the midnight millisecond value\n+     * and the new chronology. If the same or similar chronology is specified, but\n+     * with a different time zone, the day may change. This occurs because the new\n+     * DateMidnight rounds down the millisecond value to get to midnight, and the\n+     * time zone change may result in a rounding down to a different day.\n+     * <p>\n+     * For example, changing time zone from London (+00:00) to Paris (+01:00) will\n+     * retain the same day, but changing from Paris to London will change the day.\n+     * (When its midnight in London its the same day in Paris, but when its midnight\n+     * in Paris its still the previous day in London)\n+     * <p>\n+     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}\n+     * to change time zones.\n      *\n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n     }\n \n     /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * millisecond instant.\n-     * The returned object will have a local time of midnight.\n-     * <p>\n-     * This method is useful for finding the local time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London, the result\n-     * from this method with Europe/Paris would be 13:30.\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone, and does not change the\n-     * millisecond instant, with the effect that the field values usually change.\n-     * The returned object will be either be a new instance or <code>this</code>.\n+     * Gets a copy of this instant with a different time zone, preserving the day\n+     * The returned object will have a local time of midnight in the new zone on\n+     * the same day as the original instant.\n      *\n      * @param newDateTimeZone  the new time zone\n      * @return a copy of this instant with a different time zone\n-     * @see #withZoneRetainFields\n-     */\n-    public final DateMidnight withZone(DateTimeZone newDateTimeZone) {\n-        return withChronology(getChronology().withZone(newDateTimeZone));\n-    }\n-\n-    /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * field values.\n-     * The returned object will have a local time of midnight.\n-     * <p>\n-     * This method is useful for finding the millisecond time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n-     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method alters the time zone and the millisecond instant to keep\n-     * the field values the same.\n-     * The returned object will be either be a new instance or <code>this</code>.\n-     *\n-     * @param newDateTimeZone  the new time zone\n-     * @return a copy of this instant with a different time zone\n-     * @see #withZone\n      */\n     public final DateMidnight withZoneRetainFields(DateTimeZone newDateTimeZone) {\n         final long originalMillis = getMillis();\n             // be made or not.\n             return withMillis(originalMillis);\n         }\n-\n-        DateMidnight newInstant = withChronology(originalChrono.withZone(newDateTimeZone));\n-        newDateTimeZone = newInstant.getZone();\n-\n-        if (newDateTimeZone == null || newDateTimeZone == originalZone) {\n-            // New time zone didn't stick or didn't change. Skip millis adjustment.\n-            return newInstant;\n+        if (newDateTimeZone == null) {\n+            newDateTimeZone = DateTimeZone.getDefault();\n         }\n \n         long newMillis = originalMillis + originalZone.getOffset(originalMillis);\n         newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);\n \n-        return newInstant.withMillis(newMillis);\n+        return new DateMidnight(newMillis, originalChrono.withZone(newDateTimeZone));\n     }\n \n     // Date properties\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateTime_Properties.suite());\n         \n         suite.addTest(TestDateMidnight_Constructors.suite());\n+        suite.addTest(TestDateMidnight_Basics.suite());\n         \n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateMidnight_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for DateMidnight.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateMidnight_Basics extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    private static final DateTimeZone NEWYORK = DateTimeZone.getInstance(\"America/New_York\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW_UTC =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+    private long TEST_TIME_NOW_LONDON =\n+            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME_NOW_PARIS =\n+            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1_UTC =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    private long TEST_TIME1_LONDON =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME1_PARIS =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2_UTC =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    private long TEST_TIME2_LONDON =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+             - DateTimeConstants.MILLIS_PER_HOUR;\n+    private long TEST_TIME2_PARIS =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+             - 2*DateTimeConstants.MILLIS_PER_HOUR;\n+    \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateMidnight_Basics.class);\n+    }\n+\n+    public TestDateMidnight_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW_UTC).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1_UTC).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2_UTC).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        DateMidnight test = new DateMidnight();\n+        assertEquals(1, test.get(ISOChronology.getInstance().era()));\n+        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));\n+        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));\n+        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));\n+        assertEquals(2002, test.get(ISOChronology.getInstance().year()));\n+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));\n+        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));\n+        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));\n+        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().hourOfHalfday()));\n+        assertEquals(24, test.get(ISOChronology.getInstance().clockhourOfDay()));\n+        assertEquals(12, test.get(ISOChronology.getInstance().clockhourOfHalfday()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfDay()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetMethods() {\n+        DateMidnight test = new DateMidnight();\n+        \n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(LONDON, test.getZone());\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        \n+        assertEquals(1, test.getEra());\n+        assertEquals(20, test.getCenturyOfEra());\n+        assertEquals(2, test.getYearOfCentury());\n+        assertEquals(2002, test.getYearOfEra());\n+        assertEquals(2002, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        assertEquals(2002, test.getWeekyear());\n+        assertEquals(23, test.getWeekOfWeekyear());\n+        assertEquals(7, test.getDayOfWeek());\n+        assertEquals(160, test.getDayOfYear());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(0, test.getMinuteOfHour());\n+        assertEquals(0, test.getMinuteOfDay());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getSecondOfDay());\n+        assertEquals(0, test.getMillisOfSecond());\n+        assertEquals(0, test.getMillisOfDay());\n+    }\n+\n+    public void testEqualsHashCode() {\n+        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance())));\n+    }\n+    \n+    class MockInstant extends AbstractInstant {\n+        public String toString() {\n+            return null;\n+        }\n+        public long getMillis() {\n+            return TEST_TIME1_LONDON;\n+        }\n+        public Chronology getChronology() {\n+            return ISOChronology.getInstance();\n+        }\n+    }\n+\n+    public void testCompareTo() {\n+        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(-1, test3.compareTo(test2));  // midnight paris before london\n+        \n+        assertEquals(+1, test2.compareTo(new MockInstant()));\n+        assertEquals(0, test1.compareTo(new MockInstant()));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    public void testIsEqual() {\n+        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(false, test3.isEqual(test2));  // midnight paris before london\n+        \n+        assertEquals(false, test2.isEqual(new MockInstant()));\n+        assertEquals(true, test1.isEqual(new MockInstant()));\n+        assertEquals(false, test1.isEqual(null));\n+    }\n+    \n+    public void testIsBefore() {\n+        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(true, test3.isBefore(test2));  // midnight paris before london\n+        \n+        assertEquals(false, test2.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(null));\n+    }\n+    \n+    public void testIsAfter() {\n+        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));  // midnight paris before london\n+        \n+        assertEquals(true, test2.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        DateMidnight result = (DateMidnight) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(\"2002-06-09T00:00:00.000+01:00\", test.toString());\n+        \n+        test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS);\n+        assertEquals(\"2002-06-09T00:00:00.000+02:00\", test.toString());\n+        \n+        test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK);\n+        assertEquals(\"2002-06-08T00:00:00.000-04:00\", test.toString());  // the 8th\n+    }\n+\n+    public void testToString_String() {\n+        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(\"2002 00\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"2002-06-09T00:00:00.000+01:00\", test.toString(null));\n+    }\n+\n+    public void testToString_String_String() {\n+        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(\"Sun 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"dim. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"2002-06-09T00:00:00.000+01:00\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"Sun 9/6\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"2002-06-09T00:00:00.000+01:00\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInstant() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        Instant result = test.toInstant();\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+    }\n+\n+    public void testToDateMidnight() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateTime result = test.toDateTime();\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+    }\n+\n+    public void testToDateTime_DateTimeZone() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateTime result = test.toDateTime(LONDON);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(PARIS, result.getZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        result = test.toDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_PARIS, result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+    }\n+\n+    public void testToDateTime_Chronology() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateTime result = test.toDateTime(ISOChronology.getInstance());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));\n+        result = test.toDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_PARIS, result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToTrustedISODateMidnight() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateTime result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new MockUntrustedDateMidnight(TEST_TIME1_UTC);\n+        result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, new MockUntrustedZone(\"Europe/Paris\"));\n+        result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+    }\n+\n+    static class MockUntrustedDateMidnight extends DateMidnight {\n+        MockUntrustedDateMidnight(long millis) {\n+            super(millis);\n+        }\n+    }\n+\n+    static class MockUntrustedZone extends DateTimeZone {\n+        MockUntrustedZone(String id) {\n+            super(id);\n+        }\n+        public String getNameKey(long instant) {\n+            return null;\n+        }\n+        public int getOffset(long instant) {\n+            return 60 * 60 * 1000;\n+        }\n+        public int getStandardOffset(long instant) {\n+            return 60 * 60 * 1000;\n+        }\n+        public boolean isFixed() {\n+            return true;\n+        }\n+        public long nextTransition(long instant) {\n+            return 0;\n+        }\n+        public long previousTransition(long instant) {\n+            return 0;\n+        }\n+        public boolean equals(Object object) {\n+            return false;\n+        }\n+    }\n+\n+    public void testToMutableDateTime() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        MutableDateTime result = test.toMutableDateTime();\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_DateTimeZone() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        MutableDateTime result = test.toMutableDateTime(LONDON);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toMutableDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        result = test.toMutableDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toMutableDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_Chronology() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));\n+        result = test.toMutableDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.toMutableDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToDate() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        Date result = test.toDate();\n+        assertEquals(test.getMillis(), result.getTime());\n+    }\n+\n+    public void testToCalendar_Locale() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        Calendar result = test.toCalendar(null);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        result = test.toCalendar(null);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        result = test.toCalendar(Locale.UK);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+    }\n+\n+    public void testToGregorianCalendar() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        GregorianCalendar result = test.toGregorianCalendar();\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+\n+        test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n+        result = test.toGregorianCalendar();\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithMillis_long() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight result = test.withMillis(TEST_TIME2_UTC);\n+        assertEquals(TEST_TIME2_LONDON, result.getMillis());\n+        assertEquals(test.getChronology(), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));\n+        result = test.withMillis(TEST_TIME2_UTC);\n+        assertEquals(TEST_TIME2_PARIS, result.getMillis());\n+        assertEquals(test.getChronology(), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.withMillis(TEST_TIME1_UTC);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithChronology_Chronology() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight result = test.withChronology(GregorianChronology.getInstance(PARIS));\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+        assertEquals(TEST_TIME1_PARIS, result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));\n+        result = test.withChronology(null);\n+        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n+        // midnight Paris is previous day in London\n+        assertEquals(TEST_TIME1_LONDON - DateTimeConstants.MILLIS_PER_DAY, result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.withChronology(null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC);\n+        result = test.withChronology(ISOChronology.getInstance());\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithZoneRetainFields_DateTimeZone() {\n+        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n+        DateMidnight result = test.withZoneRetainFields(PARIS);\n+        assertEquals(TEST_TIME1_LONDON, test.getMillis());\n+        assertEquals(TEST_TIME1_PARIS, result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+        \n+        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));\n+        result = test.withZoneRetainFields(null);\n+        assertEquals(TEST_TIME1_PARIS, test.getMillis());\n+        assertEquals(TEST_TIME1_LONDON, result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(), result.getChronology());\n+    }\n+    \n+    public void testImmutable() {\n+        MockChangeDateMidnight test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        test.testSetMillis();\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        \n+        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        test.testSetMillisObject();\n+        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n+        \n+        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetChronology();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        \n+        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetZone();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        \n+        test = new MockChangeDateMidnight(TEST_TIME_NOW_UTC);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetZoneRetainFields();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+    }\n+    \n+    static class MockChangeDateMidnight extends DateMidnight {\n+        MockChangeDateMidnight(long instant) {\n+            super(instant);\n+        }\n+        public void testSetMillis() {\n+            setMillis(0L);\n+        }\n+        public void testSetMillisObject() {\n+            setMillis(new Date(0L));\n+        }\n+        public void testSetChronology() {\n+            setChronology(GregorianChronology.getInstance(PARIS));\n+        }\n+        public void testSetZone() {\n+            setZone(PARIS);\n+        }\n+        public void testSetZoneRetainFields() {\n+            setZoneRetainFields(PARIS);\n+        }\n+    }\n+\n+}", "timestamp": 1089585467, "metainfo": ""}