{"sha": "86d15ea163e5731450a4da7d3fcfa49e29f8c16c", "log": "Refactor GJ named classes to less specific Basic named classes   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n  * @author Guy Allard\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n- * @since 1.0\n+ * @since 1.1, refactored from GJDayOfMonthDateTimeField\n  */\n final class BasicDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJDayOfYearDateTimeField\n+ */\n+final class BasicDayOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -6821236822336841037L;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicDayOfYearDateTimeField(BaseGJChronology chronology, DurationField days) {\n+        super(DateTimeFieldType.dayOfYear(), days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the day of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfYear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int year = iChronology.getYear(instant);\n+        return iChronology.getDaysInYear(year);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.year())) {\n+            int year = partial.get(DateTimeFieldType.year());\n+            return iChronology.getDaysInYear(year);\n+        }\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.year()) {\n+                int year = values[i];\n+                return iChronology.getDaysInYear(year);\n+            }\n+        }\n+        return 366;\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 365 ? getMaximumValue(instant) : 365;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of a week based year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJWeekOfWeekyearDateTimeField\n+ */\n+final class BasicWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -1587436826395135328L;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicWeekOfWeekyearDateTimeField(BaseGJChronology chronology, DurationField weeks) {\n+        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the week of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @param instant  the time instant in millis to query.\n+     * @return the week of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekOfWeekyear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weekyears();\n+    }\n+\n+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to\n+    // apply a corrective alignment since weeks begin on day of week 1, Monday.\n+\n+    public long roundFloor(long instant) {\n+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long remainder(long instant) {\n+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int weekyear = iChronology.getWeekyear(instant);\n+        return iChronology.getWeeksInYear(weekyear);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.weekyear())) {\n+            int weekyear = partial.get(DateTimeFieldType.weekyear());\n+            return iChronology.getWeeksInYear(weekyear);\n+        }\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) {\n+                int weekyear = values[i];\n+                return iChronology.getWeeksInYear(weekyear);\n+            }\n+        }\n+        return 53;\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 52 ? getMaximumValue(instant) : 52;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of the weekyear component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJWeekyearDateTimeField\n+ */\n+final class BasicWeekyearDateTimeField extends ImpreciseDateTimeField {\n+    \n+    private static final long serialVersionUID = 6215066916806820644L;\n+\n+    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicWeekyearDateTimeField(BaseGJChronology chronology) {\n+        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Year of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get\n+     * @param instant  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekyear(instant);\n+    }\n+\n+    /**\n+     * Add the specified years to the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return add(instant, FieldUtils.safeToInt(value));\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapField\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int years) {\n+        return add(instant, years);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendWeekyear = get(minuendInstant);\n+        int subtrahendWeekyear = get(subtrahendInstant);\n+\n+        long minuendRem = remainder(minuendInstant);\n+        long subtrahendRem = remainder(subtrahendInstant);\n+\n+        // Balance leap weekyear differences on remainders.\n+        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {\n+            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+\n+        int difference = minuendWeekyear - subtrahendWeekyear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year of a week based year component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#set\n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (-9999,9999) to set the date to.\n+     * @return the updated DateTime.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, Math.abs(year),\n+                                     iChronology.getMinYear(), iChronology.getMaxYear());\n+        //\n+        // Do nothing if no real change is requested.\n+        //\n+        int thisWeekyear = get( instant );\n+        if ( thisWeekyear == year ) {\n+            return instant;\n+        }\n+        //\n+        // Calculate the DayOfWeek (to be preserved).\n+        //\n+        int thisDow = iChronology.getDayOfWeek(instant);\n+        //\n+        // Calculate the maximum weeks in the target year.\n+        //\n+        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n+        int weeksInToYear = iChronology.getWeeksInYear( year );\n+        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n+            weeksInToYear : weeksInFromYear;\n+        //\n+        // Get the current week of the year. This will be preserved in\n+        // the output unless it is greater than the maximum possible\n+        // for the target weekyear.  In that case it is adjusted\n+        // to the maximum possible.\n+        //\n+        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n+        if ( setToWeek > maxOutWeeks ) {\n+            setToWeek = maxOutWeeks;\n+        }\n+        //\n+        // Get a wroking copy of the current date-time.\n+        // This can be a convenience for debugging.\n+        //\n+        long workInstant = instant; // Get a copy\n+        //\n+        // Attempt to get close to the proper weekyear.\n+        // Note - we cannot currently call ourself, so we just call\n+        // set for the year.  This at least gets us close.\n+        //\n+        workInstant = iChronology.setYear( workInstant, year );\n+        //\n+        // Calculate the weekyear number for the get close to value\n+        // (which might not be equal to the year just set).\n+        //\n+        int workWoyYear = get( workInstant );\n+\n+        //\n+        // At most we are off by one year, which can be \"fixed\" by\n+        // adding/subtracting a week.\n+        //\n+        if ( workWoyYear < year ) {\n+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n+        } else if ( workWoyYear > year ) {\n+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+        //\n+        // Set the proper week in the current weekyear.\n+        //\n+\n+        // BEGIN: possible set WeekOfWeekyear logic.\n+        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n+        // No range check required (we already know it is OK).\n+        workInstant = workInstant + (setToWeek - currentWoyWeek)\n+            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+        // END: possible set WeekOfWeekyear logic.\n+\n+        //\n+        // Reset DayOfWeek to previous value.\n+        //\n+        // Note: This works fine, but it ideally shouldn't invoke other\n+        // fields from within a field.\n+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n+        //\n+        // Return result.\n+        //\n+        return workInstant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        // Note: This works fine, but it ideally shouldn't invoke other\n+        // fields from within a field.\n+        instant = iChronology.weekOfWeekyear().roundFloor(instant);\n+        int wow = iChronology.getWeekOfWeekyear(instant);\n+        if (wow > 1) {\n+            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekyear();\n+    }\n+}", "timestamp": 1121804802, "metainfo": ""}