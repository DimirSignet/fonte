{"sha": "234861794362a0194bf8f2b850b7f8d3df21afe2", "log": "Reorganize test classes, factoring out older ones   ", "commit": "\n--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java\n         for (int i = 0; i < var.length; i++) {\n             long millis = var[i];\n             long sum = field.add(millis, 1);\n-            assertEquals(var, i, 1, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, 1, field.getDifference(sum, millis));\n             sum = field.add(millis, -1);\n-            assertEquals(var, i, -1, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, -1, field.getDifference(sum, millis));\n             sum = field.add(millis, 0);\n-            assertEquals(var, i, 0, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, 0, field.getDifference(sum, millis));\n             sum = field.add(millis, 2);\n-            assertEquals(var, i, 2, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, 2, field.getDifference(sum, millis));\n             sum = field.add(millis, 8);\n-            assertEquals(var, i, 8, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, 8, field.getDifference(sum, millis));\n             sum = field.add(millis, 9);\n-            assertEquals(var, i, 9, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, 9, field.getDifference(sum, millis));\n             sum = field.add(millis, -13);\n-            assertEquals(var, i, -13, (int)field.getDifference(sum, millis));\n+            assertEquals(var, i, -13, field.getDifference(sum, millis));\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java\n+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java\n  * created by Stephen Colebourne <scolebourne@joda.org>. For more\n  * information on the Joda project, please see <http://www.joda.org/>.\n  */\n-package org.joda.test.time ;\n+package org.joda.test.time;\n //\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n--- a/JodaTime/src/test/org/joda/test/time/TestInstant.java\n+++ b/JodaTime/src/test/org/joda/test/time/TestInstant.java\n \n import junit.framework.TestSuite;\n \n+import org.joda.test.time.*;\n import org.joda.time.AbstractInstant;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DateTime;\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/ClassLoadTest.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.AbstractDateTime;\n+import org.joda.time.AbstractInstant;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableDateTime;\n+\n+/**\n+ * This class displays what the ClassLoader is up to.\n+ * Run using JVM -verbose:class.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClassLoadTest {\n+\n+    // run using JVM -verbose:class\n+    public static void main(String[] args) {\n+        System.out.println(\"-----------------------------------------------\");\n+        System.out.println(\"-----------AbstractInstant---------------------\");\n+        Class cls = AbstractInstant.class;\n+        System.out.println(\"-----------ReadableDateTime--------------------\");\n+        cls = ReadableDateTime.class;\n+        System.out.println(\"-----------AbstractDateTime--------------------\");\n+        cls = AbstractDateTime.class;\n+        System.out.println(\"-----------DateTime----------------------------\");\n+        cls = DateTime.class;\n+        System.out.println(\"-----------DateTimeZone------------------------\");\n+        cls = DateTimeZone.class;\n+        System.out.println(\"-----------new DateTime()----------------------\");\n+        DateTime dt = new DateTime();\n+        System.out.println(\"-----------new DateTime(ReadableInstant)-------\");\n+        dt = new DateTime(dt);\n+        System.out.println(\"-----------new DateTime(Long)------------------\");\n+        dt = new DateTime(new Long(0));\n+        System.out.println(\"-----------------------------------------------\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for all tests in this package.\n+ * \n+ * @version $Revision$ $Date$\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAll extends TestCase {\n+\n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(TestDateTimeComparator.suite());\n+        suite.addTest(TestParseISO.suite());\n+        return suite;\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = {\n+            TestAll.class.getName()\n+        };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestAllPackages.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for all tests in Joda Time.\n+ * \n+ * @version $Revision$ $Date$\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAllPackages extends TestCase {\n+\n+    public TestAllPackages(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(org.joda.time.TestAll.suite());\n+        suite.addTest(org.joda.time.chrono.gj.TestAll.suite());\n+        suite.addTest(org.joda.time.partial.TestAll.suite());\n+        return suite;\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = {\n+            TestAllPackages.class.getName()\n+        };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeComparator.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.*;\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeComparator;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.DateTimeComparator class.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeComparator extends BulkTest {\n+\n+    /**\n+     * The main method for this test program.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestDateTimeComparator.class);\n+    }\n+    /**\n+     * TestDateTimeComparator constructor.\n+     * @param name\n+     */\n+    public TestDateTimeComparator(String name) {\n+        super(name);\n+    }\n+    /**\n+     * A reference to a DateTime object.\n+     */\n+    DateTime aDateTime = null;\n+    /**\n+     * A reference to a DateTime object.\n+     */\n+    DateTime bDateTime = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for millis of seconds.\n+     */\n+    Comparator cMillis = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for seconds.\n+     */\n+    Comparator cSecond = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for minutes.\n+     */\n+    Comparator cMinute = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for hours.\n+     */\n+    Comparator cHour = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the week.\n+     */\n+    Comparator cDayOfWeek = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the month.\n+     */\n+    Comparator cDayOfMonth = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the year.\n+     */\n+    Comparator cDayOfYear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for week of the weekyear.\n+     */\n+    Comparator cWeekOfWeekyear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for year given a week of the year.\n+     */\n+    Comparator cWeekyear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for months.\n+     */\n+    Comparator cMonth = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for year.\n+     */\n+    Comparator cYear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for the date portion of an\n+     * object.\n+     */\n+    Comparator cDate = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for the time portion of an\n+     * object.\n+     */\n+    Comparator cTime = null;\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    public void setUp() /* throws Exception */ {\n+        Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+        // super.setUp();\n+        // Obtain comparator's\n+        cMillis = DateTimeComparator.getInstance(null, chrono.secondOfMinute());\n+        cSecond = DateTimeComparator.getInstance(chrono.secondOfMinute(), chrono.minuteOfHour());\n+        cMinute = DateTimeComparator.getInstance(chrono.minuteOfHour(), chrono.hourOfDay());\n+        cHour = DateTimeComparator.getInstance(chrono.hourOfDay(), chrono.dayOfYear());\n+        cDayOfWeek = DateTimeComparator.getInstance(chrono.dayOfWeek(), chrono.weekOfWeekyear());\n+        cDayOfMonth = DateTimeComparator.getInstance(chrono.dayOfMonth(), chrono.monthOfYear());\n+        cDayOfYear = DateTimeComparator.getInstance(chrono.dayOfYear(), chrono.year());\n+        cWeekOfWeekyear = DateTimeComparator.getInstance(chrono.weekOfWeekyear(), chrono.weekyear());\n+        cWeekyear = DateTimeComparator.getInstance(chrono.weekyear());\n+        cMonth = DateTimeComparator.getInstance(chrono.monthOfYear(), chrono.year());\n+        cYear = DateTimeComparator.getInstance(chrono.year());\n+        cDate = DateTimeComparator.getDateOnlyInstance(chrono);\n+        cTime = DateTimeComparator.getTimeOnlyInstance(chrono);\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+        aDateTime = null;\n+        bDateTime = null;\n+        //\n+        cMillis = null;\n+        cSecond = null;\n+        cMinute = null;\n+        cHour = null;\n+        cDayOfWeek = null;\n+        cDayOfMonth = null;\n+        cDayOfYear = null;\n+        cWeekOfWeekyear = null;\n+        cWeekyear = null;\n+        cMonth = null;\n+        cYear = null;\n+        cDate = null;\n+        cTime = null;\n+    }\n+\n+    /**\n+     * Test all basic comparator operation with DateTime objects.\n+     */\n+    public void testBasicComps1() {\n+        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n+        assertEquals( \"getMillis\", aDateTime.getMillis(),\n+            bDateTime.getMillis() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+\n+    /**\n+     * Test all basic comparator operation with ReadableInstant objects.\n+     */\n+    public void testBasicComps2() {\n+        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n+        assertEquals( \"getMillis\", aDateTime.getMillis(),\n+            bDateTime.getMillis() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with java Date objects.\n+     */\n+    public void testBasicComps3() {\n+        Date aDateTime\n+            = new Date( System.currentTimeMillis() );\n+        Date bDateTime\n+            = new Date( aDateTime.getTime() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with Long objects.\n+     */\n+    public void testBasicComps4() {\n+        Long aDateTime\n+            = new Long( System.currentTimeMillis() );\n+        Long bDateTime\n+            = new Long( aDateTime.longValue() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with Calendar objects.\n+     */\n+    public void testBasicComps5() {\n+        Calendar aDateTime\n+            = Calendar.getInstance();   // right now\n+        Calendar bDateTime = aDateTime;\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+\n+    /**\n+     * Test unequal comparisons with millis of second comparators.\n+     */\n+    public void testMillis() {\n+        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );\n+        assertEquals( \"MillisM1\", -1, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MillisP1\", 1, cMillis.compare( bDateTime, aDateTime ) );\n+    }   // end of testMillis\n+\n+    /**\n+     * Test unequal comparisons with second comparators.\n+     */\n+    public void testSecond() {\n+        aDateTime = getADate( \"1969-12-31T23:59:58\" );\n+        bDateTime = getADate( \"1969-12-31T23:50:59\" );\n+        assertEquals( \"SecondM1a\", -1, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SecondP1a\", 1, cSecond.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:01\" );\n+        assertEquals( \"SecondM1b\", -1, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SecondP1b\", 1, cSecond.compare( bDateTime, aDateTime ) );\n+    }   // end of testSecond\n+\n+    /**\n+     * Test unequal comparisons with minute comparators.\n+     */\n+    public void testMinute() {\n+        aDateTime = getADate( \"1969-12-31T23:58:00\" );\n+        bDateTime = getADate( \"1969-12-31T23:59:00\" );\n+        assertEquals( \"MinuteM1a\", -1, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MinuteP1a\", 1, cMinute.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T00:01:00\" );\n+        assertEquals( \"MinuteM1b\", -1, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MinuteP1b\", 1, cMinute.compare( bDateTime, aDateTime ) );\n+    }   // end of testMinute\n+\n+    /**\n+     * Test unequal comparisons with hour comparators.\n+     */\n+    public void testHour() {\n+        aDateTime = getADate( \"1969-12-31T22:00:00\" );\n+        bDateTime = getADate( \"1969-12-31T23:00:00\" );\n+        assertEquals( \"HourM1a\", -1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourP1a\", 1, cHour.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T01:00:00\" );\n+        assertEquals( \"HourM1b\", -1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourP1b\", 1, cHour.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1969-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"HourP1c\", 1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourM1c\", -1, cHour.compare( bDateTime, aDateTime ) );\n+    }   // end of testHour\n+\n+    /**\n+     * Test unequal comparisons with day of week comparators.\n+     */\n+    public void testDOW() {\n+        /*\n+         * Dates chosen when I wrote the code, so I know what day of\n+         * the week it is.\n+         */\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOWM1a\", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOWP1a\", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOW\n+\n+    /**\n+     * Test unequal comparisons with day of month comparators.\n+     */\n+    public void testDOM() {\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOMM1a\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOMP1a\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-12-01T00:00:00\" );\n+        bDateTime = getADate( \"1814-04-30T00:00:00\" );\n+        assertEquals( \"DOMM1b\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOMP1b\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOM\n+\n+    /**\n+     * Test unequal comparisons with day of year comparators.\n+     */\n+    public void testDOY() {\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOYM1a\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOYP1a\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-02-29T00:00:00\" );\n+        bDateTime = getADate( \"1814-11-30T00:00:00\" );\n+        assertEquals( \"DOYM1b\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOYP1b\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOY\n+\n+    /**\n+     * Test unequal comparisons with week of weekyear comparators.\n+     */\n+    public void testWOW() {\n+        // 1st week of year contains Jan 04.\n+        aDateTime = getADate( \"2000-01-04T00:00:00\" );\n+        bDateTime = getADate( \"2000-01-11T00:00:00\" );\n+        assertEquals( \"WOWM1a\", -1,\n+            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOWP1a\", 1,\n+            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-01-04T00:00:00\" );\n+        bDateTime = getADate( \"1999-12-31T00:00:00\" );\n+        assertEquals( \"WOWM1b\", -1,\n+            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOWP1b\", 1,\n+            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n+    }   // end of testMillis\n+\n+    /**\n+     * Test unequal comparisons with year given the week comparators.\n+     */\n+    public void testWOYY() {\n+        // How do I test the end conditions of this?\n+        // Don't understand ......\n+        aDateTime = getADate( \"1998-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1999-01-01T00:00:00\" );\n+        assertEquals( \"YOYYZ\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        bDateTime = getADate( \"1999-01-04T00:00:00\" );\n+        assertEquals( \"YOYYM1\", -1, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YOYYP1\", 1, cWeekyear.compare( bDateTime, aDateTime ) );\n+    }   // end of testWOYY\n+\n+    /**\n+     * Test unequal comparisons with month comparators.\n+     */\n+    public void testMonth() {\n+        aDateTime = getADate( \"2002-04-30T00:00:00\" );\n+        bDateTime = getADate( \"2002-05-01T00:00:00\" );\n+        assertEquals( \"MONTHM1a\", -1, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTHP1a\", 1, cMonth.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1900-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1899-12-31T00:00:00\" );\n+        assertEquals( \"MONTHM1b\", -1, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTHP1b\", 1, cMonth.compare( bDateTime, aDateTime ) );\n+    }   // end of testMonth\n+\n+    /**\n+     * Test unequal comparisons with year comparators.\n+     */\n+    public void testYear() {\n+        aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+        bDateTime = getADate( \"2001-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1a\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1a\", 1, cYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1968-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1b\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1b\", 1, cYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1969-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1c\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1c\", 1, cYear.compare( bDateTime, aDateTime ) );\n+    }   // end of testYear\n+\n+    /*\n+     * 'List' processing tests follow.\n+     */\n+\n+     /**\n+      * Test sorting with full default comparator.\n+      */\n+     public void testListBasic() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-01-20T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListBasic\", !isSorted1, isSorted2);\n+     } // end of testListBasic\n+\n+     /**\n+      * Test sorting with millis of second comparator.\n+      */\n+    public void testListMillis() {\n+        //\n+        List sl = new ArrayList();\n+        long base = 12345L * 1000L;\n+        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );\n+        //\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMillis );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListLillis\", !isSorted1, isSorted2);\n+    } // end of testListSecond\n+\n+\n+     /**\n+      * Test sorting with second comparator.\n+      */\n+    public void testListSecond() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:10\",\n+            \"1999-02-01T00:00:30\",\n+            \"1999-02-01T00:00:25\",\n+            \"1999-02-01T00:00:18\",\n+            \"1999-02-01T00:00:01\",\n+            \"1999-02-01T00:00:59\",\n+            \"1999-02-01T00:00:22\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cSecond );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListSecond\", !isSorted1, isSorted2);\n+    } // end of testListSecond\n+\n+     /**\n+      * Test sorting with minute comparator.\n+      */\n+    public void testListMinute() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:10:00\",\n+            \"1999-02-01T00:30:00\",\n+            \"1999-02-01T00:25:00\",\n+            \"1999-02-01T00:18:00\",\n+            \"1999-02-01T00:01:00\",\n+            \"1999-02-01T00:59:00\",\n+            \"1999-02-01T00:22:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMinute );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListMinute\", !isSorted1, isSorted2);\n+    } // end of testListMinute\n+\n+     /**\n+      * Test sorting with hour comparator.\n+      */\n+    public void testListHour() {\n+        String[] dtStrs = {\n+            \"1999-02-01T10:00:00\",\n+            \"1999-02-01T23:00:00\",\n+            \"1999-02-01T01:00:00\",\n+            \"1999-02-01T15:00:00\",\n+            \"1999-02-01T05:00:00\",\n+            \"1999-02-01T20:00:00\",\n+            \"1999-02-01T17:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cHour );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListHour\", !isSorted1, isSorted2);\n+    } // end of testListHour\n+\n+\n+     /**\n+      * Test sorting with day of week comparator.\n+      */\n+    public void testListDOW() {\n+        String[] dtStrs = {\n+            /* 2002-04-15 = Monday */\n+            \"2002-04-21T10:00:00\",\n+            \"2002-04-16T10:00:00\",\n+            \"2002-04-15T10:00:00\",\n+            \"2002-04-17T10:00:00\",\n+            \"2002-04-19T10:00:00\",\n+            \"2002-04-18T10:00:00\",\n+            \"2002-04-20T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfWeek );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOW\", !isSorted1, isSorted2);\n+    } // end of testListDOW\n+\n+     /**\n+      * Test sorting with day of month comparator.\n+      */\n+    public void testListDOM() {\n+        String[] dtStrs = {\n+            /* 2002-04-14 = Sunday */\n+            \"2002-04-20T10:00:00\",\n+            \"2002-04-16T10:00:00\",\n+            \"2002-04-15T10:00:00\",\n+            \"2002-04-17T10:00:00\",\n+            \"2002-04-19T10:00:00\",\n+            \"2002-04-18T10:00:00\",\n+            \"2002-04-14T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfMonth );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOM\", !isSorted1, isSorted2);\n+    } // end of testListDOM\n+\n+     /**\n+      * Test sorting with day of year comparator.\n+      */\n+    public void testListDOY() {\n+        String[] dtStrs = {\n+            \"2002-04-20T10:00:00\",\n+            \"2002-01-16T10:00:00\",\n+            \"2002-12-31T10:00:00\",\n+            \"2002-09-14T10:00:00\",\n+            \"2002-09-19T10:00:00\",\n+            \"2002-02-14T10:00:00\",\n+            \"2002-10-30T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfYear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOY\", !isSorted1, isSorted2);\n+    } // end of testListDOY\n+\n+     /**\n+      * Test sorting with week of weekyear comparator.\n+      */\n+    public void testListWOW() {\n+        String[] dtStrs = {\n+            \"2002-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\",\n+            \"2002-12-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-02-01T10:00:00\",\n+            \"2002-10-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cWeekOfWeekyear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListWOW\", !isSorted1, isSorted2);\n+    } // end of testListWOW\n+\n+     /**\n+      * Test sorting with year (given week) comparator.\n+      */\n+    public void testListYOYY() {\n+        // ?? How to catch end conditions ??\n+        String[] dtStrs = {\n+            \"2010-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cWeekyear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListYOYY\", !isSorted1, isSorted2);\n+    } // end of testListYOYY\n+\n+\n+     /**\n+      * Test sorting with month comparator.\n+      */\n+    public void testListMonth() {\n+        String[] dtStrs = {\n+            \"2002-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\",\n+            \"2002-12-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-02-01T10:00:00\",\n+            \"2002-10-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMonth );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListMonth\", !isSorted1, isSorted2);\n+    } // end of testListMonth\n+\n+     /**\n+      * Test sorting with year comparator.\n+      */\n+     public void testListYear() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-02-01T00:00:00\",\n+            \"2525-02-01T00:00:00\",\n+            \"1776-02-01T00:00:00\",\n+            \"1863-02-01T00:00:00\",\n+            \"1066-02-01T00:00:00\",\n+            \"2100-02-01T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cYear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListYear\", !isSorted1, isSorted2);\n+     } // end of testListYear\n+\n+     /**\n+      * Test sorting with date only comparator.\n+      */\n+    public void testListDate() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-10-03T00:00:00\",\n+            \"2525-05-20T00:00:00\",\n+            \"1776-12-25T00:00:00\",\n+            \"1863-01-31T00:00:00\",\n+            \"1066-09-22T00:00:00\",\n+            \"2100-07-04T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDate );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDate\", !isSorted1, isSorted2);\n+    } // end of testListDate\n+\n+     /**\n+      * Test sorting with time only comparator.\n+      */\n+    public void testListTime() {\n+        String[] dtStrs = {\n+            \"1999-02-01T01:02:05\",\n+            \"1999-02-01T22:22:22\",\n+            \"1999-02-01T05:30:45\",\n+            \"1999-02-01T09:17:59\",\n+            \"1999-02-01T09:17:58\",\n+            \"1999-02-01T15:30:00\",\n+            \"1999-02-01T17:00:44\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cTime );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListTime\", !isSorted1, isSorted2);\n+    } // end of testListTime\n+\n+\n+    /**\n+     * Test comparator operation with null object(s).\n+     */\n+    public void testNullDT() {\n+        try\n+        {\n+            aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+            assertEquals(\"NULLDT Expected Fail\", 0,     // should not matter\n+                    cYear.compare( null, aDateTime ) );\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            return;\n+        }\n+        fail(\"null object failed\");\n+    } // end of testNullDT\n+\n+    /**\n+     * Test comparator operation with an invalid object type.\n+     */\n+    public void testInvalidObj() {\n+        try\n+        {\n+            aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+            assertEquals(\"INVLO Expected Fail\", 0,  // should not matter\n+                    cYear.compare( \"FreeBird\" , aDateTime ) );\n+        }\n+        catch(ClassCastException cce)\n+        {\n+            return;\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            return;\n+        }\n+        fail(\"Invalid object failed\");\n+    } // end of testInvalidObj\n+\n+\n+    /*\n+     * -----------------------------------------\n+     * private convenience methods\n+     * -----------------------------------------\n+     */\n+    /*\n+     * getADate\n+     */\n+    private DateTime getADate(String s) {\n+        DateTime retDT = null;\n+        try\n+        {\n+            retDT = new DateTime( s, DateTimeZone.UTC );\n+        }\n+        catch(IllegalArgumentException pe)\n+        {\n+            pe.printStackTrace();\n+        }\n+        return retDT;\n+    } // end of getADate\n+    /*\n+     * loadAList\n+     */\n+    private List loadAList(String[] someStrs) {\n+        List newList = new ArrayList();\n+        try\n+        {\n+            for (int i = 0; i < someStrs.length; ++i) {\n+                newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );\n+            } // end of the for\n+        }\n+        catch(IllegalArgumentException pe)\n+        {\n+            pe.printStackTrace();\n+        }\n+        return newList;\n+    } // end of loadAList\n+    /*\n+     * isListSorted\n+     */\n+    private boolean isListSorted( List tl ) {\n+        // tl must be populated with DateTime objects.\n+        DateTime lhDT = (DateTime)tl.get(0);\n+        DateTime rhDT = null;\n+        Long lhVal = new Long( lhDT.getMillis() );\n+        Long rhVal = null;\n+        for (int i = 1; i < tl.size(); ++i) {\n+            rhDT = (DateTime)tl.get(i);\n+            rhVal = new Long( rhDT.getMillis() );\n+            if ( lhVal.compareTo( rhVal) > 0 ) return false;\n+            //\n+            lhVal = rhVal;  // swap for next iteration\n+            lhDT = rhDT;    // swap for next iteration\n+        } // end of the for\n+        return true;\n+    } // end of isListSorted\n+\n+} // end of class TestDateTimeComparator\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestParseISO.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.*;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Unit test the parsing of ISO format datetimes\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ */\n+public class TestParseISO extends BulkTest {\n+    \n+    private static final int DEFAULT = 99999;\n+\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    \n+    /**\n+     * TestSuite suite() is a junit required method.\n+     * @see org.joda.test.time.BulkTest\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestParseISO.class);\n+    }\n+    \n+    /**\n+     * TestConstructors constructor.\n+     * @param name\n+     */\n+    public TestParseISO(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    \n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    // Dates\n+    //-----------------------------------------------------------------------\n+    public void testSpecCompleteDate() {\n+        new DMatcher(\"5.2.1.1\", \"1999-10-20\", \"19991020\",\n+            19, 99, 10, 20, DEFAULT).run();\n+    }        \n+    //-----------------------------------------------------------------------\n+    public void testSpecReducedPrecisionCYM() {\n+        new DMatcher(\"5.2.1.2\", \"1999-10\", \"199910\",\n+            19, 99, 10, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecReducedPrecisionCY() {\n+        new DMatcher(\"5.2.1.2\", \"1999\", \"1999\",\n+            19, 99, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecReducedPrecisionC() {\n+        new DMatcher(\"5.2.1.2\", \"20\", \"20\",\n+            20, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();\n+        new DMatcher(\"5.2.1.2\", \"19\", \"19\",\n+            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecTruncatedYMD() {\n+        new DMatcher(\"5.2.1.3\", \"85-04-11\", \"850411\",\n+            DEFAULT, 85, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecTruncatedYM() {\n+        new DMatcher(\"5.2.1.3\", \"-85-04\", \"-8504\",\n+            DEFAULT, 85, 4, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecTruncatedY() {\n+        new DMatcher(\"5.2.1.3\", \"-85\", \"-85\",\n+            DEFAULT, 85, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecTruncatedMD() {\n+        new DMatcher(\"5.2.1.3\", \"--04-11\", \"--0411\",\n+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecTruncatedM() {\n+        new DMatcher(\"5.2.1.3\", \"--04\", \"--04\",\n+            DEFAULT, DEFAULT, 4, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecTruncatedD() {\n+        new DMatcher(\"5.2.1.3\", \"---11\", \"---11\",\n+            DEFAULT, DEFAULT, DEFAULT, 11, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecExpandedCYMD() {\n+        new DMatcher(\"5.2.1.4\", \"+001985-04-11\", \"+0019850411\",\n+            19, 85, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecExpandedCYM() {\n+        new DMatcher(\"5.2.1.4\", \"+001985-04\", \"+00198504\",\n+            19, 85, 4, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecExpandedCY() {\n+        new DMatcher(\"5.2.1.4\", \"+001985\", \"+001985\",\n+            19, 85, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecExpandedC() {\n+        // Not supported - could only tell difference from CY if you knew\n+        // number of digits representing year\n+//        new DMatcher(\"5.2.1.4\", \"+0019\", \"+0019\",\n+//            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).assert();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    // Ordinal based date\n+    //-----------------------------------------------------------------------\n+    public void testSpecOrdinalComplete() {\n+        new DMatcher(\"5.2.2.1\", \"1985-101\", \"1985101\",\n+            19, 85, 4, 11, DEFAULT).run();\n+        new DMatcher(\"5.2.2.1\", \"1985-021\", \"1985021\",\n+            19, 85, 1, 21, DEFAULT).run();\n+        new DMatcher(\"5.2.2.1\", \"1985-006\", \"1985006\",\n+            19, 85, 1, 6, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecOrdinalTruncatedYD() {\n+        new DMatcher(\"5.2.2.2\", \"85-101\", \"85101\",\n+            DEFAULT, 85, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecOrdinalTruncatedD() {\n+        new DMatcher(\"5.2.2.2\", \"-101\", \"-101\",\n+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecOrdinalExpandedYD() {\n+        new DMatcher(\"5.2.2.3\", \"+001985-101\", \"+001985101\",\n+            19, 85, 4, 11, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    // Week based date\n+    //-----------------------------------------------------------------------\n+    public void testSpecWeekComplete() {\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-1\", \"1985W151\",\n+            19, 85, 4, 8, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-2\", \"1985W152\",\n+            19, 85, 4, 9, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-3\", \"1985W153\",\n+            19, 85, 4, 10, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-4\", \"1985W154\",\n+            19, 85, 4, 11, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-5\", \"1985W155\",\n+            19, 85, 4, 12, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-6\", \"1985W156\",\n+            19, 85, 4, 13, DEFAULT).run();\n+        new DMatcher(\"5.2.3.1\", \"1985-W15-7\", \"1985W157\",\n+            19, 85, 4, 14, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecWeekReducedPrecision() {\n+        // test date is Sunday, which should be left alone\n+        new DMatcher(\"5.2.3.2\", \"1985-W15\", \"1985W15\",\n+            19, 85, 4, 14, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecWeekTruncatedYWD() {\n+        new DMatcher(\"5.2.3.2\", \"85-W154\", \"85W154\",\n+            DEFAULT, 85, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecWeekTruncatedYW() {\n+        // test date is Sunday, which should be left alone\n+        new DMatcher(\"5.2.3.2\", \"85-W15\", \"85W15\",\n+            DEFAULT, 85, 4, 14, DEFAULT).run();\n+    }\n+    public void testSpecWeekTruncatedDWD() {\n+        // decade not supported\n+    }\n+    public void testSpecWeekTruncatedDW() {\n+        // decade not supported\n+    }\n+    public void testSpecWeekTruncatedWD() {\n+        new DMatcher(\"5.2.3.2\", \"-W154\", \"-W154\",\n+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();\n+    }\n+    public void testSpecWeekTruncatedW() {\n+        // test date is Sunday, which should be left alone\n+        new DMatcher(\"5.2.3.2\", \"-W15\", \"-W15\",\n+            DEFAULT, DEFAULT, 4, 14, DEFAULT).run();\n+    }\n+    public void testSpecWeekTruncatedD() {\n+        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov\n+        new DMatcher(\"5.2.3.3\", \"-W-4\", \"-W-4\",\n+            DEFAULT, DEFAULT, 11, 30, DEFAULT).run();\n+    }\n+    public void testSpecWeekExpandedYWD() {\n+        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov\n+        new DMatcher(\"5.2.3.4\", \"+001985-W15-4\", \"+001985W154\",\n+            19, 85, 4, 11, DEFAULT).run();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Times\n+    //-----------------------------------------------------------------------\n+    public void testSpecTimeComplete() {\n+        new TMatcher(\"5.3.1.1\", \"23:20:50\", \"232050\",\n+            23, 20, 50, 0, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecTimeReducedPrecisionHM() {\n+        new TMatcher(\"5.3.1.2\", \"23:20\", \"2320\",\n+            23, 20, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecTimeReducedPrecisionH() {\n+        new TMatcher(\"5.3.1.2\", \"23\", \"23\",\n+            23, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecTimeFractionalHMS() {\n+        new TMatcher(\"5.3.1.3\", \"23:20:50.607\", \"232050.607\",\n+            23, 20, 50, 607, DEFAULT).run();\n+        new TMatcher(\"5.3.1.3\", \"23:20:50,607\", \"232050,607\",\n+            23, 20, 50, 607, DEFAULT).run();\n+    }\n+    public void testSpecTimeFractionalHM() {\n+        new TMatcher(\"5.3.1.3\", \"23:20.4\", \"2320.4\",\n+            23, 20, 24, 0, DEFAULT).run();\n+        new TMatcher(\"5.3.1.3\", \"23:20,4\", \"2320,4\",\n+            23, 20, 24, 0, DEFAULT).run();\n+    }\n+    public void testSpecTimeFractionalH() {\n+        new TMatcher(\"5.3.1.3\", \"23.25\", \"23.25\",\n+            23, 15, 0, 0, DEFAULT).run();\n+        new TMatcher(\"5.3.1.3\", \"23.25\", \"23,25\",\n+            23, 15, 0, 0, DEFAULT).run();\n+    }\n+    //-----------------------------------------------------------------------\n+    public void testSpecTimeTruncatedMS() {\n+        new TMatcher(\"5.3.1.4\", \"-20:50\", \"-2050\",\n+            DEFAULT, 20, 50, 0, DEFAULT).run();\n+    }\n+    public void testSpecTimeTruncatedM() {\n+        new TMatcher(\"5.3.1.4\", \"-20\", \"-20\",\n+            DEFAULT, 20, DEFAULT, DEFAULT, DEFAULT).run();\n+    }\n+    public void testSpecTimeTruncatedS() {\n+        new TMatcher(\"5.3.1.4\", \"--50\", \"--50\",\n+            DEFAULT, DEFAULT, 50, 0, DEFAULT).run();\n+    }\n+    public void testSpecTimeTruncatedFractionMS() {\n+        new TMatcher(\"5.3.1.4\", \"-20:50.607\", \"-2050.607\",\n+            DEFAULT, 20, 50, 607, DEFAULT).run();\n+    }\n+    public void testSpecTimeTruncatedFractionM() {\n+        new TMatcher(\"5.3.1.4\", \"-20.4\", \"-20.4\",\n+            DEFAULT, 20, 24, 0, DEFAULT).run();\n+    }\n+    public void testSpecTimeTruncatedFractionS() {\n+        new TMatcher(\"5.3.1.4\", \"--50.607\", \"--50.607\",\n+            DEFAULT, DEFAULT, 50, 607, DEFAULT).run();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Perform test.\n+     */        \n+    protected static abstract class Matcher extends Assert {\n+        String spec, extended, basic;\n+        int century, yearOfCentury, monthOfYear, dayOfMonth, hour, min, sec, milli, zone;\n+        MutableDateTime dt;\n+        \n+        protected Matcher(String spec, String extended, String basic) {\n+            this.spec = spec;\n+            this.extended = extended;\n+            this.basic = basic;\n+        }\n+        \n+        protected abstract void run();\n+        protected void assertDate() {\n+            String msg = \"\\nSpec:   \" + spec + \"\\nParsed: \" + extended + \"\\nTo:     \" + dt;\n+            assertEquals(msg + \"\\nCentury: \", century, dt.getCenturyOfEra());\n+            assertEquals(msg + \"\\nYear: \", yearOfCentury, dt.getYearOfCentury());\n+            assertEquals(msg + \"\\nMonth: \", monthOfYear, dt.getMonthOfYear());\n+            assertEquals(msg + \"\\nDay: \", dayOfMonth, dt.getDayOfMonth());\n+            assertEquals(msg + \"\\nHour: \", hour, dt.getHourOfDay());\n+            assertEquals(msg + \"\\nMinute: \", min, dt.getMinuteOfHour());\n+            assertEquals(msg + \"\\nSecond: \", sec, dt.getSecondOfMinute());\n+            assertEquals(msg + \"\\nMilli: \", milli, dt.getMillisOfSecond());\n+            DateTimeZone z;\n+            if (zone == DEFAULT) {\n+                z = DateTimeZone.getDefault();\n+            } else if (zone == 0) {\n+                    z = DateTimeZone.UTC;\n+            } else {\n+                String str = \"0\" + Math.abs(zone) + \":00\";\n+                str = str.substring(str.length() - 4);\n+                str = (zone < 0 ? \"-\" : \"+\") + str;\n+                z = DateTimeZone.getInstance(str);\n+            }\n+            assertEquals(msg + \"\\nZone: \", z, dt.getZone());\n+        }\n+        protected void parse(DateTimeParser p) {\n+            int result = p.parseInto(dt, extended, 0);\n+            assertTrue(\"\\nSpec:   \" + spec + \"\\nParsed: \" + extended + \"\\nTo:     \"\n+                + dt + \"\\nParse failed at: \" + ~result,\n+                result >= 0);\n+        }\n+    }\n+    protected static class DTMatcher extends Matcher {\n+        protected DTMatcher(String spec, String extended, String basic,\n+                int century, int yearOfCentury, int monthOfYear, int dayOfMonth,\n+                int hour, int min, int sec, int milli, int zone) {\n+            super(spec, extended, basic);\n+            this.century = (century == DEFAULT ? 19 : century);\n+            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);\n+            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);\n+            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);\n+            this.hour = (hour == DEFAULT ? 10 : hour);\n+            this.min = (min == DEFAULT ? 32 : min);\n+            this.sec = (sec == DEFAULT ? 40 : sec);\n+            this.milli = (milli == DEFAULT ? 205 : milli);\n+            this.zone = zone;\n+        }            \n+        protected void run() {\n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            super.assertDate();\n+        }\n+    }\n+    protected static class DMatcher extends Matcher {\n+        protected DMatcher(String spec, String extended, String basic,\n+                int century, int yearOfCentury, int monthOfYear, int dayOfMonth, int zone) {\n+            super(spec, extended, basic);\n+            this.century = (century == DEFAULT ? 19 : century);\n+            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);\n+            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);\n+            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);\n+            this.hour = 10;\n+            this.min = 32;\n+            this.sec = 40;\n+            this.milli = 205;\n+            this.zone = zone;\n+        }\n+        protected void run() {\n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().dateParser());\n+            super.assertDate();\n+        \n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            super.assertDate();\n+        }\n+    }\n+    protected static class TMatcher extends Matcher {\n+        protected TMatcher(String spec, String extended, String basic,\n+                int hour, int min, int sec, int milli, int zone) {\n+            super(spec, extended, basic);\n+            this.century = 19;\n+            this.yearOfCentury = 72;\n+            this.monthOfYear = 12;\n+            this.dayOfMonth = 3;\n+            this.hour = (hour == DEFAULT ? 10 : hour);\n+            this.min = (min == DEFAULT ? 32 : min);\n+            this.sec = (sec == DEFAULT ? 40 : sec);\n+            this.milli = (milli == DEFAULT ? 205 : milli);\n+            this.zone = zone;\n+        }\n+        protected void run() {\n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().timeParser());\n+            super.assertDate();\n+            \n+            extended = \"T\" + extended;\n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().timeParser());\n+            super.assertDate();\n+            \n+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);\n+            parse(ISODateTimeFormat.getInstance().dateTimeParser());\n+            super.assertDate();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Random;\n+\n+import junit.framework.TestCase;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.JulianChronology;\n+\n+/**\n+ * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj\n+ * against the implementations in this package. It tests all the date fields\n+ * against their principal methods.\n+ * <p>\n+ * Randomly generated values are fed into the DateTimeField methods and the\n+ * results are compared between the two chronologies. If any result doesn't\n+ * match, an error report is generated and the program exits. Each time this\n+ * test program is run, the pseudo random number generator is seeded with the\n+ * same value. This ensures consistent results between test runs.\n+ * <p>\n+ * The main method accepts three optional arguments: iterations, mode, seed. By\n+ * default, iterations is set to 1,000,000. The test will take several minutes\n+ * to run, depending on the computer's performance. Every 5 seconds a progress\n+ * message is printed.\n+ * <p>\n+ * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for\n+ * proleptic julian. To override the default random number generator seed, pass\n+ * in a thrid argument which accepts a long signed integer.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class MainTest extends TestCase {\n+    public static final int GREGORIAN_MODE = 0;\n+    public static final int JULIAN_MODE = 1;\n+\n+    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;\n+    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;\n+    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;\n+    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;\n+    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;\n+\n+    // Show progess reports every 5 seconds.\n+    private static final long UPDATE_INTERVAL = 5000;\n+\n+    /**\n+     * Arguments: iterations [mode [seed]]\n+     */\n+    public static void main(String[] args) throws Exception {\n+        int iterations = 1000000;\n+        int mode = GREGORIAN_MODE;\n+        long seed = 1345435247779935L;\n+\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+            if (args.length > 1) {\n+                if (args[1].startsWith(\"g\")) {\n+                    mode = GREGORIAN_MODE;\n+                } else if (args[1].startsWith(\"j\")) {\n+                    mode = JULIAN_MODE;\n+                } else {\n+                    throw new IllegalArgumentException\n+                        (\"Unknown mode: \" + args[1]);\n+                }\n+                if (args.length > 2) {\n+                    seed = Long.parseLong(args[2]);\n+                }\n+            }\n+        }\n+\n+        new MainTest(iterations, mode, seed).testChronology();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private final int iIterations;\n+    private final int iMode;\n+    private final long iSeed;\n+    private final Chronology iTest;\n+    private final Chronology iActual;\n+\n+    /**\n+     * @param iterations number of test iterations to perform\n+     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian\n+     * @param seed seed for random number generator\n+     */\n+    public MainTest(int iterations, int mode, long seed) {\n+        super(\"testChronology\");\n+        iIterations = iterations;\n+        iMode = mode;\n+        iSeed = seed;\n+        if (mode == GREGORIAN_MODE) {\n+            iTest = new TestGregorianChronology();\n+            iActual = GregorianChronology.getInstanceUTC();\n+        } else {\n+            iTest = new TestJulianChronology();\n+            iActual = JulianChronology.getInstanceUTC();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Main junit test\n+     */\n+    public void testChronology() {\n+        int iterations = iIterations;\n+        long seed = iSeed;\n+        String modeStr;\n+        if (iMode == GREGORIAN_MODE) {\n+            modeStr = \"Gregorian\";\n+        } else {\n+            modeStr = \"Julian\";\n+        }\n+\n+        System.out.println(\"Testing \" + modeStr + \" chronology over \" + iterations + \" iterations\");\n+\n+        Random rnd = new Random(seed);\n+        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;\n+\n+        for (int i=0; i<iterations; i++) {\n+            long now = System.currentTimeMillis();\n+            if (now >= updateMillis) {\n+                updateMillis = now + UPDATE_INTERVAL;\n+                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;\n+                if (complete < 100) {\n+                    System.out.println(\"\" + complete + \"% complete (i=\" + i + \")\");\n+                }\n+            }\n+\n+            long millis = randomMillis(rnd);\n+            int value = rnd.nextInt(200) - 100;\n+            // millis2 is used for difference tests.\n+            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;\n+\n+            try {\n+                testFields(millis, value, millis2);\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Failure index: \" + i);\n+                System.out.println(\"Test millis: \" + millis);\n+                System.out.println(\"Test value: \" + value);\n+                System.out.println(\"Test millis2: \" + millis2);\n+                fail(e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"100% complete (i=\" + iterations + \")\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void testFields(long millis, int value, long millis2) {\n+        testField(iTest.year(), iActual.year(), millis, value, millis2);\n+        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);\n+        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);\n+        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);\n+        testField(iTest.weekOfWeekyear(),\n+                  iActual.weekOfWeekyear(), millis, value, millis2);\n+        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);\n+        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);\n+    }\n+\n+    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,\n+                           int value, long millis2)\n+    {\n+        int a, b;\n+        long x, y;\n+        boolean m, n;\n+\n+        // get test\n+        a = fieldA.get(millis);\n+        b = fieldB.get(millis);\n+        testValue(fieldA, fieldB, \"get\", millis, a, b);\n+\n+        // getMaximumValue test\n+        // Restrict this test to the fields that matter.\n+        Class fieldClass = fieldA.getClass();\n+        if (fieldClass == TestGJDayOfYearField.class ||\n+            fieldClass == TestGJDayOfMonthField.class ||\n+            fieldClass == TestGJWeekOfWeekyearField.class) {\n+            \n+            a = fieldA.getMaximumValue(millis);\n+            b = fieldB.getMaximumValue(millis);\n+            testValue(fieldA, fieldB, \"getMaximumValue\", millis, a, b);\n+        }\n+\n+        // set test\n+        a = getWrappedValue\n+            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));\n+        b = getWrappedValue\n+            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));\n+        if (iMode == JULIAN_MODE && a == 0\n+            && (fieldA.getName().equals(\"year\") || fieldA.getName().equals(\"weekyear\"))) {\n+            // Exclude setting Julian year of zero.\n+        } else {\n+            x = fieldA.set(millis, a);\n+            y = fieldB.set(millis, b);\n+            testMillis(fieldA, fieldB, \"set\", millis, x, y, a, b);\n+        }\n+\n+        // roundFloor test\n+        x = fieldA.roundFloor(millis);\n+        y = fieldB.roundFloor(millis);\n+        testMillis(fieldA, fieldB, \"roundFloor\", millis, x, y);\n+\n+        // roundCeiling test\n+        x = fieldA.roundCeiling(millis);\n+        y = fieldB.roundCeiling(millis);\n+        testMillis(fieldA, fieldB, \"roundCeiling\", millis, x, y);\n+\n+        // roundHalfFloor test\n+        x = fieldA.roundHalfFloor(millis);\n+        y = fieldB.roundHalfFloor(millis);\n+        testMillis(fieldA, fieldB, \"roundHalfFloor\", millis, x, y);\n+\n+        // roundHalfEven test\n+        x = fieldA.roundHalfEven(millis);\n+        y = fieldB.roundHalfEven(millis);\n+        testMillis(fieldA, fieldB, \"roundHalfEven\", millis, x, y);\n+\n+        // remainder test\n+        x = fieldA.remainder(millis);\n+        y = fieldB.remainder(millis);\n+        testMillis(fieldA, fieldB, \"remainder\", millis, x, y);\n+\n+        // add test\n+        x = fieldA.add(millis, value);\n+        y = fieldB.add(millis, value);\n+        testMillis(fieldA, fieldB, \"add\", millis, x, y);\n+\n+        // addWrapped test\n+        x = fieldA.addWrapped(millis, value);\n+        y = fieldB.addWrapped(millis, value);\n+        testMillis(fieldA, fieldB, \"addWrapped\", millis, x, y);\n+\n+        // getDifference test\n+        x = fieldA.getDifference(millis, millis2);\n+        y = fieldB.getDifference(millis, millis2);\n+        try {\n+            testValue(fieldA, fieldB, \"getDifference\", millis, x, y);\n+        } catch (RuntimeException e) {\n+            System.out.println(\"Test datetime 2: \" + makeDatetime(millis2));\n+            throw e;\n+        }\n+\n+        // isLeap test\n+        m = fieldA.isLeap(millis);\n+        n = fieldB.isLeap(millis);\n+        testBoolean(fieldA, fieldB, \"isLeap\", millis, m, n);\n+\n+        // getLeapAmount test\n+        a = fieldA.getLeapAmount(millis);\n+        b = fieldB.getLeapAmount(millis);\n+        testValue(fieldA, fieldB, \"getLeapAmount\", millis, a, b);\n+    }\n+\n+    private int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+    private void testValue(DateTimeField fieldA, DateTimeField fieldB,\n+                           String method, long millis, long valueA, long valueB) {\n+        if (valueA != valueB) {\n+            failValue(fieldA, fieldB, method, millis, valueA, valueB);\n+        }\n+    }\n+\n+    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB) {\n+        if (millisA != millisB) {\n+            failMillis(fieldA, fieldB, method, millis, millisA, millisB);\n+        }\n+    }\n+\n+    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB,\n+                            int valueA, int valueB) {\n+        if (millisA != millisB) {\n+            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);\n+        }\n+    }\n+\n+    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,\n+                             String method, long millis, boolean boolA, boolean boolB) {\n+        if (boolA != boolB) {\n+            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);\n+        }\n+    }\n+\n+    private void failValue(DateTimeField fieldA, DateTimeField fieldB,\n+                           String method, long millis, long valueA, long valueB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(valueA + \" != \" + valueB);\n+        throw new RuntimeException();\n+    }\n+\n+    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(makeDatetime(millisA) + \" != \" + makeDatetime(millisB));\n+        System.out.println(millisA + \" != \" + millisB);\n+        System.out.println(\"Original value as reported by first field: \" +\n+                           fieldA.get(millis));\n+        System.out.println(\"Original value as reported by second field: \" +\n+                           fieldB.get(millis));\n+        System.out.println(\"First new value as reported by first field: \" +\n+                           fieldA.get(millisA));\n+        System.out.println(\"First new value as reported by second field: \" +\n+                           fieldB.get(millisA));\n+        System.out.println(\"Second new value as reported by first field: \" +\n+                           fieldA.get(millisB));\n+        System.out.println(\"Second new value as reported by second field: \" +\n+                           fieldB.get(millisB));\n+        throw new RuntimeException();\n+    }\n+\n+    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB,\n+                            int valueA, int valueB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(makeDatetime(millisA) + \" != \" + makeDatetime(millisB));\n+        System.out.println(millisA + \" != \" + millisB);\n+        System.out.println(\"Original value as reported by first field: \" +\n+                           fieldA.get(millis));\n+        System.out.println(\"Original value as reported by second field: \" +\n+                           fieldB.get(millis));\n+        System.out.println(\"First new value as reported by first field: \" +\n+                           fieldA.get(millisA));\n+        System.out.println(\"First new value as reported by second field: \" +\n+                           fieldB.get(millisA));\n+        System.out.println(\"Second new value as reported by first field: \" +\n+                           fieldA.get(millisB));\n+        System.out.println(\"Second new value as reported by second field: \" +\n+                           fieldB.get(millisB));\n+        System.out.println(\"Value to set for first field: \" + valueA);\n+        System.out.println(\"Value to set for second field: \" + valueB);\n+        throw new RuntimeException();\n+    }\n+\n+    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,\n+                             String method, long millis, boolean boolA, boolean boolB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(boolA + \" != \" + boolB);\n+        throw new RuntimeException();\n+    }\n+\n+    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {\n+        if (fieldA.getName().equals(fieldB.getName())) {\n+            return fieldA.getName();\n+        } else {\n+            return fieldA.getName() + \"/\" + fieldB.getName();\n+        }\n+    }\n+\n+    private String makeDatetime(long millis) {\n+        return makeDatetime(millis, iActual);\n+    }\n+\n+    private String makeDatetime(long millis, Chronology chrono) {\n+        return chrono.dayOfWeek().getAsShortText(millis) + \" \"\n+            + new DateTime(millis, chrono).toString() + \" / \" +\n+            chrono.weekyear().get(millis) + \"-W\" + chrono.weekOfWeekyear().get(millis) +\n+            \"-\" + chrono.dayOfWeek().get(millis);\n+    }\n+\n+    private String makeDate(long millis) {\n+        return makeDate(millis, iActual);\n+    }\n+\n+    private String makeDate(long millis, Chronology chrono) {\n+        return chrono.dayOfWeek().getAsShortText(millis) + \" \"\n+            + new DateTime(millis, chrono).toString(\"yyyy-MM-dd\") + \" / \" +\n+            chrono.weekyear().get(millis) + \"-W\" + chrono.weekOfWeekyear().get(millis) +\n+            \"-\" + chrono.dayOfWeek().get(millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static long randomMillis(Random rnd) {\n+        long millis = rnd.nextLong();\n+        if (millis >= 0) {\n+            millis = millis % MAX_MILLIS;\n+        } else {\n+            millis = millis % -MIN_MILLIS;\n+        }\n+        return millis;\n+    }\n+\n+    private static void dump(Chronology chrono, long millis) {\n+        System.out.println(\"year:           \" + chrono.year().get(millis));\n+        System.out.println(\"monthOfYear:    \" + chrono.monthOfYear().get(millis));\n+        System.out.println(\"dayOfMonth:     \" + chrono.dayOfMonth().get(millis));\n+        System.out.println(\"weekyear:       \" + chrono.weekyear().get(millis));\n+        System.out.println(\"weekOfWeekyear: \" + chrono.weekOfWeekyear().get(millis));\n+        System.out.println(\"dayOfWeek:      \" + chrono.dayOfWeek().get(millis));\n+        System.out.println(\"dayOfYear:      \" + chrono.dayOfYear().get(millis));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestAll.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for all tests in this package.\n+ * \n+ * @version $Revision$ $Date$\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAll extends TestCase {\n+\n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(new MainTest(200, 0, 1345435247779935L));\n+        suite.addTest(new MainTest(200, 1, 1345435247779935L));\n+        return suite;\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = {\n+            TestAll.class.getName()\n+        };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.chrono.AbstractChronology;\n+\n+/**\n+ * A reference Gregorian/Julian chronology implementation, intended for testing\n+ * purposes only. Correctness is favored over performance. The key functions\n+ * for date calculations are based on ones provided in \"Calendrical\n+ * Calculations\", ISBN 0-521-77752-6.\n+ *\n+ * <p>In theory, this class can be used to test any other Gregorian/Julian\n+ * chronology as long as almost all datetime fields are implemented differently\n+ * between the two. Fields that would most likely be implemented the same are\n+ * not supported by this class.\n+ *\n+ * <p>Unsupported features\n+ * <ul>\n+ * <li>time zones\n+ * <li>time of day\n+ * <li>year of era\n+ * <li>year of century\n+ * <li>century of era\n+ * <li>era\n+ * </ul>\n+ *\n+ * @author Brian S O'Neill\n+ */\n+abstract class TestGJChronology extends AbstractChronology {\n+    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;\n+\n+    /**\n+     * Divide with round-negative behavior.\n+     *\n+     * @param divisor must be positive\n+     */\n+    static long div(long dividend, long divisor) {\n+        if (divisor < 0) {\n+            throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n+        }\n+        if (dividend >= 0) {\n+            return dividend / divisor;\n+        } else {\n+            return (dividend + 1) / divisor - 1;\n+        }\n+    }\n+\n+    /**\n+     * Modulus with round-negative behavior, result is always positive.\n+     *\n+     * @param divisor must be positive\n+     */\n+    static long mod(long dividend, long divisor) {\n+        if (divisor < 0) {\n+            throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n+        }\n+        if (dividend >= 0) {\n+            return dividend % divisor;\n+        } else {\n+            return (dividend + 1) % divisor - 1 + divisor;\n+        }\n+    }\n+\n+    static long amod(long dividend, long divisor) {\n+        long mod = mod(dividend, divisor);\n+        return (mod == 0) ? divisor : mod;\n+    }\n+\n+    /** Milliseconds from 0001-01-01 to the epoch. */\n+    private final long iEpochMillis;\n+\n+    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {\n+        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;\n+    }\n+\n+    public DateTimeZone getZone() {\n+        return null;\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public long getTimeOnlyMillis(long millis) {\n+        return mod(millis, MILLIS_PER_DAY);\n+    }\n+\n+    public long getDateOnlyMillis(long millis) {\n+        return millis - mod(millis, MILLIS_PER_DAY);\n+    }\n+\n+    public DurationField days() {\n+        return dayOfWeek().getDurationField();\n+    }\n+\n+    public DateTimeField dayOfWeek() {\n+        return new TestGJDayOfWeekField(this);\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return new TestGJDayOfMonthField(this); \n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        return new TestGJDayOfYearField(this);\n+    }\n+\n+    public DurationField weeks() {\n+        return weekOfWeekyear().getDurationField();\n+    }\n+\n+    public DateTimeField weekOfWeekyear() {\n+        return new TestGJWeekOfWeekyearField(this);\n+    }\n+\n+    public DurationField weekyears() {\n+        return weekyear().getDurationField();\n+    }\n+\n+    public DateTimeField weekyear() {\n+        return new TestGJWeekyearField(this);\n+    }\n+\n+    public DurationField months() {\n+        return monthOfYear().getDurationField();\n+    }\n+\n+    public DateTimeField monthOfYear() {\n+        return new TestGJMonthOfYearField(this);\n+    }\n+\n+    public DurationField years() {\n+        return year().getDurationField();\n+    }\n+\n+    public DateTimeField year() {\n+        return new TestGJYearField(this);\n+    }\n+\n+    abstract long millisPerYear();\n+\n+    abstract long millisPerMonth();\n+\n+    abstract boolean isLeapYear(int year);\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    abstract int gjYearFromFixed(long date);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    abstract int[] gjFromFixed(long date);\n+\n+    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    abstract int[] isoFromFixed(long date);\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromMillis(long millis) {\n+        return div(millis + iEpochMillis, MILLIS_PER_DAY);\n+    }\n+\n+    /**\n+     * @param fixed days from 0001-01-01\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromFixed(long fixed) {\n+        return fixed * MILLIS_PER_DAY - iEpochMillis;\n+    }\n+\n+    /**\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return gj year\n+     */\n+    int gjYearFromMillis(long millis) {\n+        return gjYearFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromMillis(long millis) {\n+        return gjFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromMillis(long millis) {\n+        return isoFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday\n+     * @param date days from 0001-01-01, on or before weekday\n+     */\n+    long weekdayOnOrBefore(long date, int weekday) {\n+        return date - mod(date - mod(weekday, 7), 7);\n+    }\n+\n+    long weekdayOnOrAfter(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 6, weekday);\n+    }\n+\n+    long weekdayNearest(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 3, weekday);\n+    }\n+\n+    long weekdayBefore(long date, int weekday) {\n+        return weekdayOnOrBefore(date - 1, weekday);\n+    }\n+\n+    long weekdayAfter(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 7, weekday);\n+    }\n+\n+    long nthWeekday(int n, int weekday,\n+                    int year, int monthOfYear, int dayOfMonth)\n+    {\n+        if (n > 0) {\n+            return 7 * n + weekdayBefore\n+                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);\n+        } else {\n+            return 7 * n + weekdayAfter\n+                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);\n+        }\n+    }\n+\n+    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {\n+        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);\n+    }\n+\n+    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {\n+        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+abstract class TestGJDateTimeField extends ImpreciseDateTimeField {\n+    protected final TestGJChronology iChronology;\n+\n+    public TestGJDateTimeField(String name, String duratioName,\n+                               long unitMillis, TestGJChronology chrono) {\n+        super(name, duratioName, unitMillis);\n+        iChronology = chrono;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return add(instant, (long)value);\n+    }\n+\n+    public abstract long add(long instant, long value);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfMonthField extends TestGJDateTimeField {\n+    public TestGJDayOfMonthField(TestGJChronology chrono) {\n+        super(\"dayOfMonth\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[2];\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        return iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromGJ(ymd[0], ymd[1], value);\n+    }\n+\n+    public long add(long millis, long value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 31;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+        if (iChronology.year().isLeap(millis)) {\n+            lengths[2] = 29;\n+        }\n+        return lengths[iChronology.monthOfYear().get(millis)];\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfWeekField extends TestGJDateTimeField {\n+    public TestGJDayOfWeekField(TestGJChronology chrono) {\n+        super(\"dayOfWeek\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+    }\n+\n+    public int get(long millis) {\n+        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);\n+        if (dayOfWeek == 0) {\n+            dayOfWeek = 7;\n+        }\n+        return dayOfWeek;\n+    }\n+\n+    public long set(long millis, int value) {\n+        return add(millis, (long) value - get(millis));\n+    }\n+\n+    public long add(long millis, long value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 7;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfYearField extends TestGJDateTimeField {\n+    public TestGJDayOfYearField(TestGJChronology chrono) {\n+        super(\"dayOfYear\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+    }\n+\n+    public int get(long millis) {\n+        int year = iChronology.gjYearFromMillis(millis);\n+        return (int)(iChronology.fixedFromMillis(millis)\n+                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;\n+    }\n+\n+    public long set(long millis, int value) {\n+        return add(millis, (long) value - get(millis));\n+    }\n+\n+    public long add(long millis, long value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        return iChronology.year().isLeap(millis) ? 366 : 365;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJMonthOfYearField extends TestGJDateTimeField {\n+    public TestGJMonthOfYearField(TestGJChronology chrono) {\n+        super(\"monthOfYear\", \"months\", chrono.millisPerMonth(), chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[1];\n+    }\n+\n+    public long set(long millis, int value) {\n+        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        // First set to start of month...\n+        millis = iChronology.millisFromGJ(ymd[0], value, 1);\n+        // ...and use dayOfMonth field to check range.\n+        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);\n+        if (ymd[2] > maxDay) {\n+            ymd[2] = maxDay;\n+        }\n+        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);\n+    }\n+\n+    public long add(long millis, long value) {\n+        int newYear = iChronology.year().get(millis)\n+            + (int)iChronology.div(value, 12);\n+        int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n+        if (newMonth > 12) {\n+            newYear++;\n+            newMonth -= 12;\n+        }\n+        int newDay = iChronology.dayOfMonth().get(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis) \n+            + iChronology.millisFromGJ(newYear, newMonth, newDay);\n+        while (get(millis) != newMonth) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        return isLeap(millis) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 12;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJWeekOfWeekyearField extends TestGJDateTimeField {\n+    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {\n+        super(\"weekOfWeekyear\", \"weeks\",\n+              (long)(chrono.MILLIS_PER_DAY * 7), chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.isoFromMillis(millis)[1];\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        return iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromISO(wwd[0], value, wwd[2]);\n+    }\n+\n+    public long add(long millis, long value) {\n+        return iChronology.dayOfYear().add(millis, value * 7);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        // Move millis to end of weekyear.\n+        millis = iChronology.weekyear().roundFloor(millis);\n+        millis = iChronology.weekyear().add(millis, 1);\n+        millis = iChronology.dayOfYear().add(millis, -1);\n+        return get(millis);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        return iChronology.millisFromISO(wwd[0], wwd[1], 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJWeekyearField extends TestGJDateTimeField {\n+    public TestGJWeekyearField(TestGJChronology chrono) {\n+        super(\"weekyear\", \"weekyears\", chrono.millisPerYear(), chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.isoFromMillis(millis)[0];\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromISO(value, wwd[1], wwd[2]);\n+        if (wwd[1] == 53) {\n+            int[] wwd2 = iChronology.isoFromMillis(millis);\n+            if (wwd2[0] != value) {\n+                // Set year doesn't have 53 weeks, so back off a week.\n+                millis = iChronology.dayOfYear().add(millis, -7);\n+            }\n+        }\n+        return millis;\n+    }\n+\n+    public long add(long millis, long value) {\n+        return set(millis, (int)(get(millis) + value));\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        return iChronology.weekOfWeekyear().getMaximumValue(millis) > 52;\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        return iChronology.weekOfWeekyear().getMaximumValue(millis) - 52;\n+    } \n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.millisFromISO(get(millis), 1, 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DurationField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJYearField extends TestGJDateTimeField {\n+    public TestGJYearField(TestGJChronology chrono) {\n+        super(\"year\", \"years\", chrono.millisPerYear(), chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjYearFromMillis(millis);\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);\n+        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+\n+    public long add(long millis, long value) {\n+        return set(millis, (int)(get(millis) + value));\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        return iChronology.isLeapYear(get(millis));\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        return isLeap(millis) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.millisFromGJ(get(millis), 1, 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGregorianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * A reference Gregorian chronology implementation, intended for testing\n+ * purposes only. Correctness is favored over performance. The key functions\n+ * for date calculations are based on ones provided in \"Calendrical\n+ * Calculations\", ISBN 0-521-77752-6.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class TestGregorianChronology extends TestGJChronology {\n+    /**\n+     * Constructs with an epoch of 1970-01-01.\n+     */\n+    public TestGregorianChronology() {\n+        super(1970, 1, 1);\n+    }\n+\n+    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {\n+        super(epochYear, epochMonth, epochDay);\n+    }\n+\n+    public String toString() {\n+        return \"TestGregorianChronology\";\n+    }\n+\n+    long millisPerYear() {\n+        return (long)(365.2425 * MILLIS_PER_DAY);\n+    }\n+\n+    long millisPerMonth() {\n+        return (long)(365.2425 * MILLIS_PER_DAY / 12);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        if (mod(year, 4) == 0) {\n+            int t = (int)mod(year, 400);\n+            if (t != 100 && t != 200 & t != 300) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        long year_m1 = year - 1;\n+        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)\n+            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n+        if (monthOfYear > 2) {\n+            f += isLeapYear(year) ? -1 : -2;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    int gjYearFromFixed(long date) {\n+        long d0 = date - 1;\n+        long n400 = div(d0, 146097);\n+        long d1 = mod(d0, 146097);\n+        long n100 = div(d1, 36524);\n+        long d2 = mod(d1, 36524);\n+        long n4 = div(d2, 1461);\n+        long d3 = mod(d2, 1461);\n+        long n1 = div(d3, 365);\n+        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;\n+        if (!(n100 == 4 || n1 == 4)) {\n+            year += 1;\n+        }\n+\n+        int year_i = (int)year;\n+        if (year_i == year) {\n+            return year_i;\n+        } else {\n+            throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n+        }\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromFixed(long date) {\n+        int year = gjYearFromFixed(date);\n+        long priorDays = date - fixedFromGJ(year, 1, 1);\n+        long correction;\n+        if (date < fixedFromGJ(year, 3, 1)) {\n+            correction = 0;\n+        } else if (isLeapYear(year)) {\n+            correction = 1;\n+        } else {\n+            correction = 2;\n+        }\n+        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n+        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);\n+\n+        return new int[]{year, monthOfYear, day};\n+    }\n+\n+    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromFixed(long date) {\n+        int weekyear = gjYearFromFixed(date - 3);\n+        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {\n+            weekyear += 1;\n+        }\n+        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n+        int dayOfWeek = (int)amod(date, 7);\n+        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * A reference Julian chronology implementation, intended for testing purposes\n+ * only. Correctness is favored over performance. The key functions for date\n+ * calculations are based on ones provided in \"Calendrical Calculations\", ISBN\n+ * 0-521-77752-6.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class TestJulianChronology extends TestGJChronology {\n+\n+    private static final long JULIAN_EPOCH;\n+\n+    static {\n+        // Constant as defined in book.\n+        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);\n+    }\n+\n+    /**\n+     * Constructs with an epoch of 1969-12-19.\n+     */\n+    public TestJulianChronology() {\n+        super(1969, 12, 19);\n+    }\n+\n+    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {\n+        super(epochYear, epochMonth, epochDay);\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return new TestJulianDayOfMonthField(this); \n+    }\n+\n+    public DateTimeField weekyear() {\n+        return new TestJulianWeekyearField(this);\n+    }\n+\n+    public DateTimeField monthOfYear() {\n+        return new TestJulianMonthOfYearField(this);\n+    }\n+\n+    public DateTimeField year() {\n+        return new TestJulianYearField(this);\n+    }\n+\n+    public String toString() {\n+        return \"TestJulianChronology\";\n+    }\n+\n+    long millisPerYear() {\n+        return (long)(365.25 * MILLIS_PER_DAY);\n+    }\n+\n+    long millisPerMonth() {\n+        return (long)(365.25 * MILLIS_PER_DAY / 12);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        if (year == 0) {\n+            throw new IllegalArgumentException(\"Illegal year: \" + year);\n+        }\n+        return mod(year, 4) == (year > 0 ? 0 : 3);\n+    }\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        if (year == 0) {\n+            throw new IllegalArgumentException(\"Illegal year: \" + year);\n+        }\n+        int y = (year < 0) ? year + 1 : year;\n+        long y_m1 = y - 1;\n+        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)\n+            + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n+        if (monthOfYear > 2) {\n+            f += isLeapYear(year) ? -1 : -2;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    int gjYearFromFixed(long date) {\n+        return gjFromFixed(date)[0];\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromFixed(long date) {\n+        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);\n+        long year = (approx <= 0) ? approx - 1 : approx;\n+        int year_i = (int)year;\n+        if (year_i != year) {\n+            throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n+        }\n+        long priorDays = date - fixedFromGJ(year_i, 1, 1);\n+        long correction;\n+        if (date < fixedFromGJ(year_i, 3, 1)) {\n+            correction = 0;\n+        } else if (isLeapYear(year_i)) {\n+            correction = 1;\n+        } else {\n+            correction = 2;\n+        }\n+        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n+        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);\n+\n+        return new int[]{year_i, monthOfYear, day};\n+    }\n+\n+    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        if (weekyear == 0) {\n+            throw new IllegalArgumentException(\"Illegal weekyear: \" + weekyear);\n+        }\n+        if (weekyear == 1) {\n+            weekyear = -1;\n+        } else {\n+            weekyear--;\n+        }\n+        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromFixed(long date) {\n+        int weekyear = gjYearFromFixed(date - 3);\n+        int nextWeekyear;\n+        if (weekyear == -1) {\n+            nextWeekyear = 1;\n+        } else {\n+            nextWeekyear = weekyear + 1;\n+        }\n+        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {\n+            weekyear = nextWeekyear;\n+        }\n+        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n+        int dayOfWeek = (int)amod(date, 7);\n+        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianDayOfMonthField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianDayOfMonthField extends TestGJDayOfMonthField {\n+    public TestJulianDayOfMonthField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.millisPerMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianMonthOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianMonthOfYearField extends TestGJMonthOfYearField {\n+    public TestJulianMonthOfYearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[1];\n+    }\n+\n+    public long add(long millis, long value) {\n+        int year = iChronology.year().get(millis);\n+        int newYear = year + (int)iChronology.div(value, 12);\n+        if (year < 0) {\n+            if (newYear >= 0) {\n+                newYear++;\n+            }\n+        } else {\n+            if (newYear <= 0) {\n+                newYear--;\n+            }\n+        }\n+        int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n+        if (newMonth > 12) {\n+            if (newYear == -1) {\n+                newYear = 1;\n+            } else {\n+                newYear++;\n+            }\n+            newMonth -= 12;\n+        }\n+        int newDay = iChronology.dayOfMonth().get(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis) \n+            + iChronology.millisFromGJ(newYear, newMonth, newDay);\n+        while (get(millis) != newMonth) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianWeekyearField extends TestGJWeekyearField {\n+    public TestJulianWeekyearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long addWrapped(long millis, int value) {\n+        int weekyear = get(millis);\n+        int wrapped = FieldUtils.getWrappedValue\n+            (weekyear, value, getMinimumValue(), getMaximumValue());\n+        return add(millis, (long) wrapped - weekyear);\n+    }\n+\n+    public long add(long millis, long value) {\n+        int weekyear = get(millis);\n+        int newWeekyear = weekyear + FieldUtils.safeToInt(value);\n+        if (weekyear < 0) {\n+            if (newWeekyear >= 0) {\n+                newWeekyear++;\n+            }\n+        } else {\n+            if (newWeekyear <= 0) {\n+                newWeekyear--;\n+            }\n+        }\n+        return set(millis, newWeekyear);\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestJulianYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianYearField extends TestGJYearField {\n+    public TestJulianYearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long addWrapped(long millis, int value) {\n+        int year = get(millis);\n+        int wrapped = FieldUtils.getWrappedValue\n+            (year, value, getMinimumValue(), getMaximumValue());\n+        return add(millis, (long) wrapped - year);\n+    }\n+\n+    public long add(long millis, long value) {\n+        int year = get(millis);\n+        int newYear = year + FieldUtils.safeToInt(value);\n+        if (year < 0) {\n+            if (newYear >= 0) {\n+                newYear++;\n+            }\n+        } else {\n+            if (newYear <= 0) {\n+                newYear--;\n+            }\n+        }\n+        return set(millis, newYear);\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/partial/MockPartialInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * A basic mock testing class for a PartialInstant that doesn't extend AbstractPartialInstant.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MockPartialInstant implements PartialInstant {\n+    \n+    public static final PartialInstant EMPTY_INSTANCE = new MockPartialInstant();\n+    \n+    public Chronology getChronology() {\n+        return ISOChronology.getInstance();\n+    }\n+    public int getFieldSize() {\n+        return 0;\n+    }\n+    public DateTimeField getField(int index) {\n+        return null;\n+    }\n+    public int getValue(int index) {\n+        return 0;\n+    }\n+    public int get(DateTimeField field) {\n+        return 0;\n+    }\n+    public boolean isSupported(DateTimeField field) {\n+        return false;\n+    }\n+    public long resolve(long baseMillis, DateTimeZone tz) {\n+        return 0L;\n+    }\n+    public DateTime resolveDateTime(ReadableInstant base) {\n+        return null;\n+    }\n+    public DateTimeField[] getFields() {\n+        return new DateTimeField[0];\n+    }\n+    public int[] getValues() {\n+        return new int[0];\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/partial/TestAll.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for all tests in this package.\n+ * \n+ * @version $Revision$ $Date$\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAll extends TestCase {\n+\n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(TestTimeOfDay.suite());\n+        return suite;\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = {\n+            TestAll.class.getName()\n+        };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay.class);\n+    }\n+\n+    public TestTimeOfDay(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(5, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(5, test.getHourOfDay());\n+        assertEquals(6, test.getMinuteOfHour());\n+        assertEquals(7, test.getSecondOfMinute());\n+        assertEquals(8, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0));\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        TimeOfDay test = new TimeOfDay(date, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay((Object) null, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0, test.getHourOfDay());\n+            assertEquals(0, test.getMinuteOfHour());\n+            assertEquals(0, test.getSecondOfMinute());\n+            assertEquals(0, test.getMillisOfSecond());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int)\n+     */\n+    public void testConstructor_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int)\n+     */\n+    public void testConstructor_int_int_int_int() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_int_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        try {\n+            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance().dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance(PARIS).hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n+//        try {\n+//            test.get(JulianChronology.getInstance().hourOfDay());\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFieldSize() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(4, test.getFieldSize());\n+    }\n+\n+    public void testGetField() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));\n+        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));\n+        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));\n+        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));\n+        try {\n+            test.getField(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getField(5);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetFields() {\n+        TimeOfDay test = new TimeOfDay();\n+        DateTimeField[] fields = test.getFields();\n+        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);\n+        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);\n+        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);\n+        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);\n+    }\n+\n+    public void testGetValue() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10, test.getValue(0));\n+        assertEquals(20, test.getValue(1));\n+        assertEquals(30, test.getValue(2));\n+        assertEquals(40, test.getValue(3));\n+        try {\n+            test.getValue(-1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.getValue(5);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetValues() {\n+        TimeOfDay test = new TimeOfDay();\n+        int[] values = test.getValues();\n+        assertEquals(10, values[0]);\n+        assertEquals(20, values[1]);\n+        assertEquals(30, values[2]);\n+        assertEquals(40, values[3]);\n+    }\n+\n+    public void testIsSupported() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));\n+    }\n+    \n+    class MockInstant extends MockPartialInstant {\n+        public DateTimeField[] getFields() {\n+            return new DateTimeField[] {\n+                ISOChronology.getInstance().hourOfDay(),\n+                ISOChronology.getInstance().minuteOfHour(),\n+                ISOChronology.getInstance().secondOfMinute(),\n+                ISOChronology.getInstance().millisOfSecond(),\n+            };\n+        }\n+        public int[] getValues() {\n+            return new int[] {10, 20, 30, 40};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testResolve_long() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_RI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = test.resolveDateTime(dt);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+    public void testResolveDateTime_nullRI() {\n+        TimeOfDay test = new TimeOfDay(1, 2, 3, 4);\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);\n+        \n+        DateTime result = test.resolveDateTime(null);\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-02T01:02:03.004Z\", result.toString());\n+    }\n+\n+    public void testResolveInto_RWI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        MutableDateTime mdt = new MutableDateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", mdt.toString());\n+        \n+        test.resolveInto(mdt);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", mdt.toString());\n+    }\n+\n+    public void testResolveInto_nullRWI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        \n+        try {\n+            test.resolveInto(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        TimeOfDay result = (TimeOfDay) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+        assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n+        assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n+        assertEquals(test.getChronology(), result.getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        // TODO\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n+        assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n+        assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n+        assertSame(test, test.hourOfDay().getPartialInstant());\n+        assertSame(test, test.hourOfDay().getTimeOfDay());\n+        assertEquals(10, test.hourOfDay().get());\n+        assertEquals(\"10\", test.hourOfDay().getAsText());\n+        assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText());\n+        assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n+        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n+        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n+        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.hourOfDay().getMinimumValue());\n+        assertEquals(0, test.hourOfDay().getMinimumValueOverall());\n+        assertEquals(23, test.hourOfDay().getMaximumValue());\n+        assertEquals(23, test.hourOfDay().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddInFieldHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);\n+        assertEquals(19, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+        updated = updated.hourOfDay().addInFieldCopy(9);\n+        assertEquals(4, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.hourOfDay().setCopy(12);\n+        assertEquals(12, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetTextHour() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.hourOfDay().setCopy(\"12\");\n+        assertEquals(12, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertyCompareToHour() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((PartialInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);\n+        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);\n+        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);\n+        try {\n+            test1.hourOfDay().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n+        assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n+        assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n+        assertSame(test, test.minuteOfHour().getPartialInstant());\n+        assertSame(test, test.minuteOfHour().getTimeOfDay());\n+        assertEquals(20, test.minuteOfHour().get());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n+        assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n+        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n+        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n+        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.minuteOfHour().getMinimumValue());\n+        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());\n+        assertEquals(59, test.minuteOfHour().getMaximumValue());\n+        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddInFieldMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay updated = test.minuteOfHour().addInFieldCopy(9);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(29, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+        updated = updated.minuteOfHour().addInFieldCopy(49);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(18, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.minuteOfHour().setCopy(12);\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(12, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetTextMinute() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.minuteOfHour().setCopy(\"12\");\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(12, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertyCompareToMinute() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((PartialInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);\n+        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);\n+        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);\n+        try {\n+            test1.minuteOfHour().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n+        assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n+        assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n+        assertSame(test, test.secondOfMinute().getPartialInstant());\n+        assertSame(test, test.secondOfMinute().getTimeOfDay());\n+        assertEquals(30, test.secondOfMinute().get());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n+        assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n+        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n+        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n+        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.secondOfMinute().getMinimumValue());\n+        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());\n+        assertEquals(59, test.secondOfMinute().getMaximumValue());\n+        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddInFieldSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay updated = test.secondOfMinute().addInFieldCopy(9);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(39, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+        updated = updated.secondOfMinute().addInFieldCopy(49);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(28, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.secondOfMinute().setCopy(12);\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(12, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetTextSecond() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.secondOfMinute().setCopy(\"12\");\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(12, set.getSecondOfMinute());\n+        assertEquals(40, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertyCompareToSecond() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((PartialInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);\n+        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);\n+        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);\n+        try {\n+            test1.secondOfMinute().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n+        assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n+        assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n+        assertSame(test, test.millisOfSecond().getPartialInstant());\n+        assertSame(test, test.millisOfSecond().getTimeOfDay());\n+        assertEquals(40, test.millisOfSecond().get());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n+        assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n+        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n+        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n+        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(0, test.millisOfSecond().getMinimumValue());\n+        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());\n+        assertEquals(999, test.millisOfSecond().getMaximumValue());\n+        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddInFieldMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay updated = test.millisOfSecond().addInFieldCopy(9);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(49, updated.getMillisOfSecond());\n+        updated = updated.millisOfSecond().addInFieldCopy(990);\n+        assertEquals(10, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(39, updated.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.millisOfSecond().setCopy(12);\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(12, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertySetTextMilli() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay set = test.millisOfSecond().setCopy(\"12\");\n+        assertEquals(10, set.getHourOfDay());\n+        assertEquals(20, set.getMinuteOfHour());\n+        assertEquals(30, set.getSecondOfMinute());\n+        assertEquals(12, set.getMillisOfSecond());\n+    }\n+\n+    public void testPropertyCompareToMilli() {\n+        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);\n+        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((PartialInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        DateTime dt1 = new DateTime(TEST_TIME1);\n+        DateTime dt2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);\n+        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);\n+        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);\n+        try {\n+            test1.millisOfSecond().compareTo((ReadableInstant) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}", "timestamp": 1088262194, "metainfo": ""}