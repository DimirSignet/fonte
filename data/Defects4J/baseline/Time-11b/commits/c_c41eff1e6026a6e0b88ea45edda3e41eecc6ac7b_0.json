{"sha": "c41eff1e6026a6e0b88ea45edda3e41eecc6ac7b", "log": "Fix DateTimeZone to better handle spring DST cutover bugs 1710316, 1747219, 1755158  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import org.joda.time.chrono.BaseChronology;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n import org.joda.time.format.DateTimeFormatterBuilder;\n import org.joda.time.format.FormatUtils;\n      * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n      * </pre>\n      *\n-     * Note: After calculating millisLocal, some error may be introduced. At\n+     * NOTE: After calculating millisLocal, some error may be introduced. At\n      * offset transitions (due to DST or other historical changes), ranges of\n      * local times may map to different UTC times.\n+     * <p>\n+     * This method will return an offset suitable for calculating an instant\n+     * after any DST gap. For example, consider a zone with a cutover\n+     * from 01:00 to 01:59:<br />\n+     * Input: 00:00  Output: 00:00<br />\n+     * Input: 00:30  Output: 00:30<br />\n+     * Input: 01:00  Output: 02:00<br />\n+     * Input: 01:30  Output: 02:30<br />\n+     * Input: 02:00  Output: 02:00<br />\n+     * Input: 02:30  Output: 02:30<br />\n+     * <p>\n+     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n+     * on returning a consistent result later along the time-line (shown above).\n      *\n      * @param instantLocal  the millisecond instant, relative to this time zone, to\n      * get the offset for\n      * @return the millisecond offset to subtract from local time to get UTC time\n      */\n     public int getOffsetFromLocal(long instantLocal) {\n-        return getOffset(instantLocal - getOffset(instantLocal));\n+        // get the offset at instantLocal (first estimate)\n+        int offsetLocal = getOffset(instantLocal);\n+        // adjust instantLocal using the estimate and recalc the offset\n+        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n+        // if the offsets differ, we must be near a DST boundary\n+        if (offsetLocal != offsetAdjusted) {\n+            // we need to ensure that time is always after the DST gap\n+            // this happens naturally for positive offsets, but not for negative\n+            if (offsetLocal < 0) {\n+                // if we just return offsetAdjusted then the time is pushed\n+                // back before the transition, whereas it should be\n+                // on or after the transition\n+                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+                if (nextLocal != nextAdjusted) {\n+                    return offsetLocal;\n+                }\n+            }\n+        }\n+        return offsetAdjusted;\n+    }\n+\n+    /**\n+     * Converts a standard UTC instant to a local instant with the same\n+     * local time. This conversion is used before performing a calculation\n+     * so that the calculation can be done using a simple local zone.\n+     *\n+     * @param instantUTC  the UTC instant to convert to local\n+     * @return the local instant with the same local time\n+     * @throws ArithmeticException if the result overflows a long\n+     */\n+    public long convertUTCToLocal(long instantUTC) {\n+        int offset = getOffset(instantUTC);\n+        long instantLocal = instantUTC + offset;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n+            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n+        }\n+        return instantLocal;\n+    }\n+\n+    /**\n+     * Converts a local instant to a standard UTC instant with the same\n+     * local time. This conversion is used after performing a calculation\n+     * where the calculation was done using a simple local zone.\n+     *\n+     * @param instantLocal  the local instant to convert to UTC\n+     * @param strict  whether the conversion should reject non-existent local times\n+     * @return the UTC instant with the same local time, \n+     * @throws ArithmeticException if the result overflows a long\n+     * @throws IllegalArgumentException if the zone has no eqivalent local time\n+     */\n+    public long convertLocalToUTC(long instantLocal, boolean strict) {\n+        // get the offset at instantLocal (first estimate)\n+        int offsetLocal = getOffset(instantLocal);\n+        // adjust instantLocal using the estimate and recalc the offset\n+        int offset = getOffset(instantLocal - offsetLocal);\n+        // if the offsets differ, we must be near a DST boundary\n+        if (offsetLocal != offset) {\n+            // if strict then always check if in DST gap\n+            // otherwise only check if zone in Western hemisphere (as the\n+            // value of offset is already correct for Eastern hemisphere)\n+            if (strict || offsetLocal < 0) {\n+                // determine if we are in the DST gap\n+                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                long nextAdjusted = nextTransition(instantLocal - offset);\n+                if (nextLocal != nextAdjusted) {\n+                    // yes we are in the DST gap\n+                    if (strict) {\n+                        // DST gap is not acceptable\n+                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n+                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n+                                \" (\" + getID() + \")\");\n+                    } else {\n+                        // DST gap is acceptable, but for the Western hemisphere\n+                        // the offset is wrong and will result in local times\n+                        // before the cutover so use the offsetLocal instead\n+                        offset = offsetLocal;\n+                    }\n+                }\n+            }\n+        }\n+        // check for overflow\n+        long instantUTC = instantLocal - offset;\n+        // If there is a sign change, but the two values have different signs...\n+        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n+            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n+        }\n+        return instantUTC;\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/IllegalFieldValueException.java\n+++ b/JodaTime/src/java/org/joda/time/IllegalFieldValueException.java\n      * @param value  the value rejected\n      * @param lowerBound  the lower bound allowed\n      * @param upperBound  the uppe bound allowed\n+     * @param explain  an explanation\n      * @return the message\n      */\n     private static String createMessage(String fieldName, Number value,\n-                                        Number lowerBound, Number upperBound) {\n+                                        Number lowerBound, Number upperBound, String explain) {\n         StringBuffer buf = new StringBuffer()\n             .append(\"Value \").append(value).append(\" for \").append(fieldName).append(' ');\n \n                 .append(upperBound)\n                 .append(']');\n         }\n+        if (explain != null) {\n+            buf.append(\": \").append(explain);\n+        }\n \n         return buf.toString();\n     }\n      */\n     public IllegalFieldValueException(DateTimeFieldType fieldType,\n                                       Number value, Number lowerBound, Number upperBound) {\n-        super(createMessage(fieldType.getName(), value, lowerBound, upperBound));\n+        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));\n         iDateTimeFieldType = fieldType;\n         iDurationFieldType = null;\n         iFieldName = fieldType.getName();\n      * \n      * @param fieldType  type of field being set\n      * @param value  illegal value being set\n+     * @param explain  an explanation\n+     */\n+    public IllegalFieldValueException(DateTimeFieldType fieldType,\n+                                      Number value, String explain) {\n+        super(createMessage(fieldType.getName(), value, null, null, explain));\n+        iDateTimeFieldType = fieldType;\n+        iDurationFieldType = null;\n+        iFieldName = fieldType.getName();\n+        iNumberValue = value;\n+        iStringValue = null;\n+        iLowerBound = null;\n+        iUpperBound = null;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n      * @param lowerBound  lower legal field value, or null if not applicable\n      * @param upperBound  upper legal field value, or null if not applicable\n      */\n     public IllegalFieldValueException(DurationFieldType fieldType,\n                                       Number value, Number lowerBound, Number upperBound) {\n-        super(createMessage(fieldType.getName(), value, lowerBound, upperBound));\n+        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));\n         iDateTimeFieldType = null;\n         iDurationFieldType = fieldType;\n         iFieldName = fieldType.getName();\n      */\n     public IllegalFieldValueException(String fieldName,\n                                       Number value, Number lowerBound, Number upperBound) {\n-        super(createMessage(fieldName, value, lowerBound, upperBound));\n+        super(createMessage(fieldName, value, lowerBound, upperBound, null));\n         iDateTimeFieldType = null;\n         iDurationFieldType = null;\n         iFieldName = fieldName;\n--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n         fields.halfdayOfDay = convertField(fields.halfdayOfDay);\n     }\n \n-    private static final DateTimeField convertField(DateTimeField field) {\n-        return LenientDateTimeField.getInstance(field);\n+    private final DateTimeField convertField(DateTimeField field) {\n+        return LenientDateTimeField.getInstance(field, getBase());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n         }\n \n         private long addOffset(long instant) {\n-            int offset = this.iZone.getOffset(instant);\n-            long sum = instant + offset;\n-            // If there is a sign change, but the two values have the same sign...\n-            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n-                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n-            }\n-            return sum;\n+            return iZone.convertUTCToLocal(instant);\n         }\n     }\n \n         }\n \n         public int get(long instant) {\n-            return iField.get(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.get(localInstant);\n         }\n \n         public String getAsText(long instant, Locale locale) {\n-            return iField.getAsText(addOffset(instant), locale);\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getAsText(localInstant, locale);\n         }\n \n         public String getAsShortText(long instant, Locale locale) {\n-            return iField.getAsShortText(addOffset(instant), locale);\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getAsShortText(localInstant, locale);\n         }\n \n         public String getAsText(int fieldValue, Locale locale) {\n         }\n \n         public long add(long instant, int value) {\n-            int offset = getOffsetToAdd(instant);\n-            instant = iField.add(instant + offset, value);\n-            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.add(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+               long localInstant = iZone.convertUTCToLocal(instant);\n+               localInstant = iField.add(localInstant, value);\n+               return iZone.convertLocalToUTC(localInstant, false);\n+            }\n         }\n \n         public long add(long instant, long value) {\n-            int offset = getOffsetToAdd(instant);\n-            instant = iField.add(instant + offset, value);\n-            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.add(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+               long localInstant = iZone.convertUTCToLocal(instant);\n+               localInstant = iField.add(localInstant, value);\n+               return iZone.convertLocalToUTC(localInstant, false);\n+            }\n         }\n \n         public long addWrapField(long instant, int value) {\n-            int offset = getOffsetToAdd(instant);\n-            instant = iField.addWrapField(instant + offset, value);\n-            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.addWrapField(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+                long localInstant = iZone.convertUTCToLocal(instant);\n+                localInstant = iField.addWrapField(localInstant, value);\n+                return iZone.convertLocalToUTC(localInstant, false);\n+            }\n         }\n \n         public long set(long instant, int value) {\n-            long offset = getOffsetToAdd(instant);\n-\n-            instant = iField.set(instant + offset, value);\n-            long offsetFromLocal = getOffsetFromLocalToSubtract(instant);\n-            instant -= offsetFromLocal;\n-\n-            if (offset != offsetFromLocal) {\n-                if (get(instant) != value) {\n-                    throw new IllegalFieldValueException\n-                        (iField.getType(), new Integer(value), null, null);\n-                }\n-            }\n-\n-            return instant;\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.set(localInstant, value);\n+            long result = iZone.convertLocalToUTC(localInstant, false);\n+            if (get(result) != value) {\n+                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n+                    \"Illegal instant due to time zone offset transition: \" +\n+                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n+                    \" (\" + iZone.getID() + \")\");\n+            }\n+            return result;\n         }\n \n         public long set(long instant, String text, Locale locale) {\n-            instant = iField.set(addOffset(instant), text, locale);\n-            // Cannot verify that new value stuck because set may be lenient.\n-            return instant - getOffsetFromLocalToSubtract(instant);\n+            // cannot verify that new value stuck because set may be lenient\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.set(localInstant, text, locale);\n+            return iZone.convertLocalToUTC(localInstant, false);\n         }\n \n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n         }\n \n         public boolean isLeap(long instant) {\n-            return iField.isLeap(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.isLeap(localInstant);\n         }\n \n         public int getLeapAmount(long instant) {\n-            return iField.getLeapAmount(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getLeapAmount(localInstant);\n         }\n \n         public final DurationField getLeapDurationField() {\n         }\n \n         public long roundFloor(long instant) {\n-            int offset = getOffsetToAdd(instant);\n-            instant = iField.roundFloor(instant + offset);\n-            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.roundFloor(localInstant);\n+            return iZone.convertLocalToUTC(localInstant, false);\n         }\n \n         public long roundCeiling(long instant) {\n-            int offset = getOffsetToAdd(instant);\n-            instant = iField.roundCeiling(instant + offset);\n-            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.roundCeiling(localInstant);\n+            return iZone.convertLocalToUTC(localInstant, false);\n         }\n \n         public long remainder(long instant) {\n-            return iField.remainder(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.remainder(localInstant);\n         }\n \n         public int getMinimumValue() {\n         }\n \n         public int getMinimumValue(long instant) {\n-            return iField.getMinimumValue(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getMinimumValue(localInstant);\n         }\n \n         public int getMinimumValue(ReadablePartial instant) {\n         }\n \n         public int getMaximumValue(long instant) {\n-            return iField.getMaximumValue(addOffset(instant));\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getMaximumValue(localInstant);\n         }\n \n         public int getMaximumValue(ReadablePartial instant) {\n             }\n             return offset;\n         }\n-\n-        private int getOffsetFromLocalToSubtract(long instant) {\n-            int offset = this.iZone.getOffsetFromLocal(instant);\n-            long diff = instant - offset;\n-            // If there is a sign change, but the two values have different signs...\n-            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n-                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n-            }\n-            return offset;\n-        }\n-\n-        private long addOffset(long instant) {\n-            int offset = this.iZone.getOffset(instant);\n-            long sum = instant + offset;\n-            // If there is a sign change, but the two values have the same sign...\n-            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n-                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n-            }\n-            return sum;\n-        }\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java\n  */\n package org.joda.time.field;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeField;\n \n /**\n \n     private static final long serialVersionUID = 8714085824173290599L;\n \n+    private final Chronology iBase;\n+\n     /**\n      * Returns a lenient version of the given field. If it is already lenient,\n      * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n      * returned.\n      */\n-    public static DateTimeField getInstance(DateTimeField field) {\n+    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n         if (field == null) {\n             return null;\n         }\n         if (field.isLenient()) {\n             return field;\n         }\n-        return new LenientDateTimeField(field);\n+        return new LenientDateTimeField(field, base);\n     }\n \n-    protected LenientDateTimeField(DateTimeField field) {\n+    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n         super(field);\n+        iBase = base;\n     }\n \n     public final boolean isLenient() {\n      * the new value and the current value.\n      */\n     public long set(long instant, int value) {\n+        // lenient needs to handle time zone chronologies\n+        // so we do the calculation using local milliseconds\n+        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n         long difference = FieldUtils.safeSubtract(value, get(instant));\n-        return add(instant, difference);\n+        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n+        return iBase.getZone().convertLocalToUTC(localInstant, false);\n     }\n }\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateTimeConstants.suite());\n         suite.addTest(TestDateTimeUtils.suite());\n         suite.addTest(TestDateTimeZone.suite());\n+        suite.addTest(TestDateTimeZoneCutover.suite());\n         suite.addTest(TestPeriodType.suite());\n //        suite.addTest(TestParseISO.suite());\n         suite.addTest(TestDurationField.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZoneCutover.java\n+/*\n+ *  Copyright 2001-2007 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.chrono.StrictChronology;\n+\n+/**\n+ * This class is a JUnit test for DateTimeZone.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTimeZoneCutover extends TestCase {\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTimeZoneCutover.class);\n+    }\n+\n+    public TestDateTimeZoneCutover(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //------------------------ Bug [1710316] --------------------------------\n+    //-----------------------------------------------------------------------\n+    // The behaviour of getOffsetFromLocal is defined in its javadoc\n+    // However, this definition doesn't work for all DateTimeField operations\n+    \n+    /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */\n+    private static long CUTOVER_GAZA = 1175378400000L;\n+    private static int OFFSET_GAZA = 7200000;  // +02:00\n+    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA);\n+\n+    //-----------------------------------------------------------------------\n+    public void test_MockGazaIsCorrect() {\n+        DateTime pre = new DateTime(CUTOVER_GAZA - 1L, MOCK_GAZA);\n+        assertEquals(\"2007-03-31T23:59:59.999+02:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_GAZA, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_GAZA + 1L, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T01:00:00.001+03:00\", post.toString());\n+    }\n+\n+    public void test_getOffsetFromLocal_Gaza() {\n+        doTest_getOffsetFromLocal_Gaza(-1, 23, 0, \"2007-03-31T23:00:00.000+02:00\");\n+        doTest_getOffsetFromLocal_Gaza(-1, 23, 30, \"2007-03-31T23:30:00.000+02:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 0, 0, \"2007-04-01T01:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 0, 30, \"2007-04-01T01:30:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 1, 0, \"2007-04-01T01:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 1, 30, \"2007-04-01T01:30:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 2, 0, \"2007-04-01T02:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 3, 0, \"2007-04-01T03:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 4, 0, \"2007-04-01T04:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 5, 0, \"2007-04-01T05:00:00.000+03:00\");\n+        doTest_getOffsetFromLocal_Gaza(0, 6, 0, \"2007-04-01T06:00:00.000+03:00\");\n+    }\n+\n+    private void doTest_getOffsetFromLocal_Gaza(int days, int hour, int min, String expected) {\n+        DateTime dt = new DateTime(2007, 4, 1, hour, min, 0, 0, DateTimeZone.UTC).plusDays(days);\n+        int offset = MOCK_GAZA.getOffsetFromLocal(dt.getMillis());\n+        DateTime res = new DateTime(dt.getMillis() - offset, MOCK_GAZA);\n+        assertEquals(res.toString(), expected, res.toString());\n+    }\n+\n+    public void test_DateTime_roundFloor_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T08:00:00.000+03:00\", dt.toString());\n+        DateTime rounded = dt.dayOfMonth().roundFloorCopy();\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", rounded.toString());\n+    }\n+\n+    public void test_DateTime_roundCeiling_Gaza() {\n+        DateTime dt = new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-03-31T20:00:00.000+02:00\", dt.toString());\n+        DateTime rounded = dt.dayOfMonth().roundCeilingCopy();\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", rounded.toString());\n+    }\n+\n+    public void test_DateTime_setHourZero_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T08:00:00.000+03:00\", dt.toString());\n+        try {\n+            dt.hourOfDay().setCopy(0);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_withHourZero_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T08:00:00.000+03:00\", dt.toString());\n+        try {\n+            dt.withHourOfDay(0);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_withDay_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-02T00:00:00.000+03:00\", dt.toString());\n+        DateTime res = dt.withDayOfMonth(1);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", res.toString());\n+    }\n+\n+    public void test_DateTime_minusHour_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-01T08:00:00.000+03:00\", dt.toString());\n+        \n+        DateTime minus7 = dt.minusHours(7);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", minus7.toString());\n+        DateTime minus8 = dt.minusHours(8);\n+        assertEquals(\"2007-03-31T23:00:00.000+02:00\", minus8.toString());\n+        DateTime minus9 = dt.minusHours(9);\n+        assertEquals(\"2007-03-31T22:00:00.000+02:00\", minus9.toString());\n+    }\n+\n+    public void test_DateTime_plusHour_Gaza() {\n+        DateTime dt = new DateTime(2007, 3, 31, 16, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-03-31T16:00:00.000+02:00\", dt.toString());\n+        \n+        DateTime plus7 = dt.plusHours(7);\n+        assertEquals(\"2007-03-31T23:00:00.000+02:00\", plus7.toString());\n+        DateTime plus8 = dt.plusHours(8);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", plus8.toString());\n+        DateTime plus9 = dt.plusHours(9);\n+        assertEquals(\"2007-04-01T02:00:00.000+03:00\", plus9.toString());\n+    }\n+\n+    public void test_DateTime_minusDay_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-02T00:00:00.000+03:00\", dt.toString());\n+        \n+        DateTime minus1 = dt.minusDays(1);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", minus1.toString());\n+        DateTime minus2 = dt.minusDays(2);\n+        assertEquals(\"2007-03-31T00:00:00.000+02:00\", minus2.toString());\n+    }\n+\n+    public void test_DateTime_plusDay_Gaza() {\n+        DateTime dt = new DateTime(2007, 3, 31, 0, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-03-31T00:00:00.000+02:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.plusDays(1);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", plus1.toString());\n+        DateTime plus2 = dt.plusDays(2);\n+        assertEquals(\"2007-04-02T00:00:00.000+03:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_plusDayMidGap_Gaza() {\n+        DateTime dt = new DateTime(2007, 3, 31, 0, 30, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-03-31T00:30:00.000+02:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.plusDays(1);\n+        assertEquals(\"2007-04-01T01:30:00.000+03:00\", plus1.toString());\n+        DateTime plus2 = dt.plusDays(2);\n+        assertEquals(\"2007-04-02T00:30:00.000+03:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_addWrapFieldDay_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 30, 0, 0, 0, 0, MOCK_GAZA);\n+        assertEquals(\"2007-04-30T00:00:00.000+03:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.dayOfMonth().addWrapFieldToCopy(1);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", plus1.toString());\n+        DateTime plus2 = dt.dayOfMonth().addWrapFieldToCopy(2);\n+        assertEquals(\"2007-04-02T00:00:00.000+03:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_withZoneRetainFields_Gaza() {\n+        DateTime dt = new DateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(\"2007-04-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime res = dt.withZoneRetainFields(MOCK_GAZA);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", res.toString());\n+    }\n+\n+    public void test_MutableDateTime_withZoneRetainFields_Gaza() {\n+        MutableDateTime dt = new MutableDateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(\"2007-04-01T00:00:00.000Z\", dt.toString());\n+        \n+        dt.setZoneRetainFields(MOCK_GAZA);\n+        assertEquals(\"2007-04-01T01:00:00.000+03:00\", dt.toString());\n+    }\n+\n+    public void test_LocalDate_new_Gaza() {\n+        LocalDate date1 = new LocalDate(CUTOVER_GAZA, MOCK_GAZA);\n+        assertEquals(\"2007-04-01\", date1.toString());\n+        \n+        LocalDate date2 = new LocalDate(CUTOVER_GAZA - 1, MOCK_GAZA);\n+        assertEquals(\"2007-03-31\", date2.toString());\n+    }\n+\n+    public void test_LocalDate_toDateTimeAtMidnight_Gaza() {\n+        LocalDate date = new LocalDate(2007, 4, 1);\n+        try {\n+            date.toDateTimeAtMidnight(MOCK_GAZA);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n+        }\n+    }\n+\n+    public void test_LocalDate_toDateMidnight_Gaza() {\n+        LocalDate date = new LocalDate(2007, 4, 1);\n+        try {\n+            date.toDateMidnight(MOCK_GAZA);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n+        }\n+    }\n+\n+    public void test_DateTime_new_Gaza() {\n+        try {\n+            new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_GAZA);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n+        }\n+    }\n+\n+    public void test_DateTime_newValid_Gaza() {\n+        new DateTime(2007, 3, 31, 19, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 3, 31, 21, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 3, 31, 22, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 3, 31, 23, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 4, 1, 2, 0, 0, 0, MOCK_GAZA);\n+        new DateTime(2007, 4, 1, 3, 0, 0, 0, MOCK_GAZA);\n+    }\n+\n+    public void test_DateTime_parse_Gaza() {\n+        try {\n+            new DateTime(\"2007-04-01T00:00\", MOCK_GAZA);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //------------------------ Bug [1710316] --------------------------------\n+    //-----------------------------------------------------------------------\n+    /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */\n+    private static long CUTOVER_TURK = 1175403600000L;\n+    private static int OFFSET_TURK = -18000000;  // -05:00\n+    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK);\n+\n+    //-----------------------------------------------------------------------\n+    public void test_MockTurkIsCorrect() {\n+        DateTime pre = new DateTime(CUTOVER_TURK - 1L, MOCK_TURK);\n+        assertEquals(\"2007-03-31T23:59:59.999-05:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_TURK, MOCK_TURK);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_TURK + 1L, MOCK_TURK);\n+        assertEquals(\"2007-04-01T01:00:00.001-04:00\", post.toString());\n+    }\n+\n+    public void test_getOffsetFromLocal_Turk() {\n+        doTest_getOffsetFromLocal_Turk(-1, 23, 0, \"2007-03-31T23:00:00.000-05:00\");\n+        doTest_getOffsetFromLocal_Turk(-1, 23, 30, \"2007-03-31T23:30:00.000-05:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 0, 0, \"2007-04-01T01:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 0, 30, \"2007-04-01T01:30:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 1, 0, \"2007-04-01T01:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 1, 30, \"2007-04-01T01:30:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 2, 0, \"2007-04-01T02:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 3, 0, \"2007-04-01T03:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 4, 0, \"2007-04-01T04:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 5, 0, \"2007-04-01T05:00:00.000-04:00\");\n+        doTest_getOffsetFromLocal_Turk(0, 6, 0, \"2007-04-01T06:00:00.000-04:00\");\n+    }\n+\n+    private void doTest_getOffsetFromLocal_Turk(int days, int hour, int min, String expected) {\n+        DateTime dt = new DateTime(2007, 4, 1, hour, min, 0, 0, DateTimeZone.UTC).plusDays(days);\n+        int offset = MOCK_TURK.getOffsetFromLocal(dt.getMillis());\n+        DateTime res = new DateTime(dt.getMillis() - offset, MOCK_TURK);\n+        assertEquals(res.toString(), expected, res.toString());\n+    }\n+\n+    public void test_DateTime_roundFloor_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-01T08:00:00.000-04:00\", dt.toString());\n+        DateTime rounded = dt.dayOfMonth().roundFloorCopy();\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", rounded.toString());\n+    }\n+\n+    public void test_DateTime_roundFloorNotDST_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 2, 8, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-02T08:00:00.000-04:00\", dt.toString());\n+        DateTime rounded = dt.dayOfMonth().roundFloorCopy();\n+        assertEquals(\"2007-04-02T00:00:00.000-04:00\", rounded.toString());\n+    }\n+\n+    public void test_DateTime_roundCeiling_Turk() {\n+        DateTime dt = new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-03-31T20:00:00.000-05:00\", dt.toString());\n+        DateTime rounded = dt.dayOfMonth().roundCeilingCopy();\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", rounded.toString());\n+    }\n+\n+    public void test_DateTime_setHourZero_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-01T08:00:00.000-04:00\", dt.toString());\n+        try {\n+            dt.hourOfDay().setCopy(0);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_withHourZero_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-01T08:00:00.000-04:00\", dt.toString());\n+        try {\n+            dt.withHourOfDay(0);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_withDay_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-02T00:00:00.000-04:00\", dt.toString());\n+        DateTime res = dt.withDayOfMonth(1);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", res.toString());\n+    }\n+\n+    public void test_DateTime_minusHour_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-01T08:00:00.000-04:00\", dt.toString());\n+        \n+        DateTime minus7 = dt.minusHours(7);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", minus7.toString());\n+        DateTime minus8 = dt.minusHours(8);\n+        assertEquals(\"2007-03-31T23:00:00.000-05:00\", minus8.toString());\n+        DateTime minus9 = dt.minusHours(9);\n+        assertEquals(\"2007-03-31T22:00:00.000-05:00\", minus9.toString());\n+    }\n+\n+    public void test_DateTime_plusHour_Turk() {\n+        DateTime dt = new DateTime(2007, 3, 31, 16, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-03-31T16:00:00.000-05:00\", dt.toString());\n+        \n+        DateTime plus7 = dt.plusHours(7);\n+        assertEquals(\"2007-03-31T23:00:00.000-05:00\", plus7.toString());\n+        DateTime plus8 = dt.plusHours(8);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", plus8.toString());\n+        DateTime plus9 = dt.plusHours(9);\n+        assertEquals(\"2007-04-01T02:00:00.000-04:00\", plus9.toString());\n+    }\n+\n+    public void test_DateTime_minusDay_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-02T00:00:00.000-04:00\", dt.toString());\n+        \n+        DateTime minus1 = dt.minusDays(1);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", minus1.toString());\n+        DateTime minus2 = dt.minusDays(2);\n+        assertEquals(\"2007-03-31T00:00:00.000-05:00\", minus2.toString());\n+    }\n+\n+    public void test_DateTime_plusDay_Turk() {\n+        DateTime dt = new DateTime(2007, 3, 31, 0, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-03-31T00:00:00.000-05:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.plusDays(1);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", plus1.toString());\n+        DateTime plus2 = dt.plusDays(2);\n+        assertEquals(\"2007-04-02T00:00:00.000-04:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_plusDayMidGap_Turk() {\n+        DateTime dt = new DateTime(2007, 3, 31, 0, 30, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-03-31T00:30:00.000-05:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.plusDays(1);\n+        assertEquals(\"2007-04-01T01:30:00.000-04:00\", plus1.toString());\n+        DateTime plus2 = dt.plusDays(2);\n+        assertEquals(\"2007-04-02T00:30:00.000-04:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_addWrapFieldDay_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 30, 0, 0, 0, 0, MOCK_TURK);\n+        assertEquals(\"2007-04-30T00:00:00.000-04:00\", dt.toString());\n+        \n+        DateTime plus1 = dt.dayOfMonth().addWrapFieldToCopy(1);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", plus1.toString());\n+        DateTime plus2 = dt.dayOfMonth().addWrapFieldToCopy(2);\n+        assertEquals(\"2007-04-02T00:00:00.000-04:00\", plus2.toString());\n+    }\n+\n+    public void test_DateTime_withZoneRetainFields_Turk() {\n+        DateTime dt = new DateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(\"2007-04-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime res = dt.withZoneRetainFields(MOCK_TURK);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", res.toString());\n+    }\n+\n+    public void test_MutableDateTime_setZoneRetainFields_Turk() {\n+        MutableDateTime dt = new MutableDateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(\"2007-04-01T00:00:00.000Z\", dt.toString());\n+        \n+        dt.setZoneRetainFields(MOCK_TURK);\n+        assertEquals(\"2007-04-01T01:00:00.000-04:00\", dt.toString());\n+    }\n+\n+    public void test_LocalDate_new_Turk() {\n+        LocalDate date1 = new LocalDate(CUTOVER_TURK, MOCK_TURK);\n+        assertEquals(\"2007-04-01\", date1.toString());\n+        \n+        LocalDate date2 = new LocalDate(CUTOVER_TURK - 1, MOCK_TURK);\n+        assertEquals(\"2007-03-31\", date2.toString());\n+    }\n+\n+    public void test_LocalDate_toDateTimeAtMidnight_Turk() {\n+        LocalDate date = new LocalDate(2007, 4, 1);\n+        try {\n+            date.toDateTimeAtMidnight(MOCK_TURK);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n+        }\n+    }\n+\n+    public void test_LocalDate_toDateMidnight_Turk() {\n+        LocalDate date = new LocalDate(2007, 4, 1);\n+        try {\n+            date.toDateMidnight(MOCK_TURK);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n+        }\n+    }\n+\n+    public void test_DateTime_new_Turk() {\n+        try {\n+            new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_TURK);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n+        }\n+    }\n+\n+    public void test_DateTime_newValid_Turk() {\n+        new DateTime(2007, 3, 31, 23, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 2, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 3, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 4, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 5, 0, 0, 0, MOCK_TURK);\n+        new DateTime(2007, 4, 1, 6, 0, 0, 0, MOCK_TURK);\n+    }\n+\n+    public void test_DateTime_parse_Turk() {\n+        try {\n+            new DateTime(\"2007-04-01T00:00\", MOCK_TURK);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    /** America/New_York cutover from 01:59 to 03:00 on 2007-03-11 */\n+    private static long CUTOVER_NEW_YORK_SPRING = 1173596400000L;  // 2007-03-11T03:00:00.000-04:00\n+    private static final DateTimeZone ZONE_NEW_YORK = DateTimeZone.forID(\"America/New_York\");\n+//  DateTime x = new DateTime(2007, 1, 1, 0, 0, 0, 0, ZONE_NEW_YORK);\n+//  System.out.println(ZONE_NEW_YORK.nextTransition(x.getMillis()));\n+//  DateTime y = new DateTime(ZONE_NEW_YORK.nextTransition(x.getMillis()), ZONE_NEW_YORK);\n+//  System.out.println(y);\n+\n+    //-----------------------------------------------------------------------\n+    public void test_NewYorkIsCorrect_Spring() {\n+        DateTime pre = new DateTime(CUTOVER_NEW_YORK_SPRING - 1L, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T01:59:59.999-05:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_NEW_YORK_SPRING, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T03:00:00.000-04:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_NEW_YORK_SPRING + 1L, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T03:00:00.001-04:00\", post.toString());\n+    }\n+\n+    public void test_getOffsetFromLocal_NewYork_Spring() {\n+        doTest_getOffsetFromLocal(3, 11, 1, 0, \"2007-03-11T01:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 1,30, \"2007-03-11T01:30:00.000-05:00\", ZONE_NEW_YORK);\n+        \n+        doTest_getOffsetFromLocal(3, 11, 2, 0, \"2007-03-11T03:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 2,30, \"2007-03-11T03:30:00.000-04:00\", ZONE_NEW_YORK);\n+        \n+        doTest_getOffsetFromLocal(3, 11, 3, 0, \"2007-03-11T03:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 3,30, \"2007-03-11T03:30:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 4, 0, \"2007-03-11T04:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 5, 0, \"2007-03-11T05:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 6, 0, \"2007-03-11T06:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 7, 0, \"2007-03-11T07:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(3, 11, 8, 0, \"2007-03-11T08:00:00.000-04:00\", ZONE_NEW_YORK);\n+    }\n+\n+    public void test_DateTime_setHourAcross_NewYork_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 11, 0, 0, 0, 0, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T00:00:00.000-05:00\", dt.toString());\n+        DateTime res = dt.hourOfDay().setCopy(4);\n+        assertEquals(\"2007-03-11T04:00:00.000-04:00\", res.toString());\n+    }\n+\n+    public void test_DateTime_setHourForward_NewYork_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 11, 0, 0, 0, 0, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T00:00:00.000-05:00\", dt.toString());\n+        \n+        try {\n+            dt.hourOfDay().setCopy(2);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_setHourBack_NewYork_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 11, 8, 0, 0, 0, ZONE_NEW_YORK);\n+        assertEquals(\"2007-03-11T08:00:00.000-04:00\", dt.toString());\n+        \n+        try {\n+            dt.hourOfDay().setCopy(2);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** America/New_York cutover from 01:59 to 01:00 on 2007-11-04 */\n+    private static long CUTOVER_NEW_YORK_AUTUMN = 1194156000000L;  // 2007-11-04T01:00:00.000-05:00\n+\n+    //-----------------------------------------------------------------------\n+    public void test_NewYorkIsCorrect_Autumn() {\n+        DateTime pre = new DateTime(CUTOVER_NEW_YORK_AUTUMN - 1L, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:59:59.999-04:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_NEW_YORK_AUTUMN, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:00:00.000-05:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_NEW_YORK_AUTUMN + 1L, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:00:00.001-05:00\", post.toString());\n+    }\n+\n+    public void test_getOffsetFromLocal_NewYork_Autumn() {\n+        doTest_getOffsetFromLocal(11, 4, 0, 0, \"2007-11-04T00:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 0,30, \"2007-11-04T00:30:00.000-04:00\", ZONE_NEW_YORK);\n+        \n+        doTest_getOffsetFromLocal(11, 4, 1, 0, \"2007-11-04T01:00:00.000-04:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 1,30, \"2007-11-04T01:30:00.000-04:00\", ZONE_NEW_YORK);\n+        \n+        doTest_getOffsetFromLocal(11, 4, 2, 0, \"2007-11-04T02:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 2,30, \"2007-11-04T02:30:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 3, 0, \"2007-11-04T03:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 3,30, \"2007-11-04T03:30:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 4, 0, \"2007-11-04T04:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 5, 0, \"2007-11-04T05:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 6, 0, \"2007-11-04T06:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 7, 0, \"2007-11-04T07:00:00.000-05:00\", ZONE_NEW_YORK);\n+        doTest_getOffsetFromLocal(11, 4, 8, 0, \"2007-11-04T08:00:00.000-05:00\", ZONE_NEW_YORK);\n+    }\n+\n+    public void test_DateTime_plusHour_NewYork_Autumm() {\n+        DateTime dt = new DateTime(2007, 11, 3, 18, 0, 0, 0, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-03T18:00:00.000-04:00\", dt.toString());\n+        \n+        DateTime plus6 = dt.plusHours(6);\n+        assertEquals(\"2007-11-04T00:00:00.000-04:00\", plus6.toString());\n+        DateTime plus7 = dt.plusHours(7);\n+        assertEquals(\"2007-11-04T01:00:00.000-04:00\", plus7.toString());\n+        DateTime plus8 = dt.plusHours(8);\n+        assertEquals(\"2007-11-04T01:00:00.000-05:00\", plus8.toString());\n+        DateTime plus9 = dt.plusHours(9);\n+        assertEquals(\"2007-11-04T02:00:00.000-05:00\", plus9.toString());\n+    }\n+\n+    public void test_DateTime_minusHour_NewYork_Autumm() {\n+        DateTime dt = new DateTime(2007, 11, 4, 8, 0, 0, 0, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T08:00:00.000-05:00\", dt.toString());\n+        \n+        DateTime minus6 = dt.minusHours(6);\n+        assertEquals(\"2007-11-04T02:00:00.000-05:00\", minus6.toString());\n+        DateTime minus7 = dt.minusHours(7);\n+        assertEquals(\"2007-11-04T01:00:00.000-05:00\", minus7.toString());\n+        DateTime minus8 = dt.minusHours(8);\n+        assertEquals(\"2007-11-04T01:00:00.000-04:00\", minus8.toString());\n+        DateTime minus9 = dt.minusHours(9);\n+        assertEquals(\"2007-11-04T00:00:00.000-04:00\", minus9.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** Europe/Moscow cutover from 01:59 to 03:00 on 2007-03-25 */\n+    private static long CUTOVER_MOSCOW_SPRING = 1174777200000L;  // 2007-03-25T03:00:00.000+04:00\n+    private static final DateTimeZone ZONE_MOSCOW = DateTimeZone.forID(\"Europe/Moscow\");\n+\n+    //-----------------------------------------------------------------------\n+    public void test_MoscowIsCorrect_Spring() {\n+//      DateTime x = new DateTime(2007, 7, 1, 0, 0, 0, 0, ZONE_MOSCOW);\n+//      System.out.println(ZONE_MOSCOW.nextTransition(x.getMillis()));\n+//      DateTime y = new DateTime(ZONE_MOSCOW.nextTransition(x.getMillis()), ZONE_MOSCOW);\n+//      System.out.println(y);\n+        DateTime pre = new DateTime(CUTOVER_MOSCOW_SPRING - 1L, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T01:59:59.999+03:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_MOSCOW_SPRING, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T03:00:00.000+04:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_MOSCOW_SPRING + 1L, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T03:00:00.001+04:00\", post.toString());\n+    }\n+\n+    public void test_getOffsetFromLocal_Moscow_Spring() {\n+        doTest_getOffsetFromLocal(3, 25, 1, 0, \"2007-03-25T01:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 1,30, \"2007-03-25T01:30:00.000+03:00\", ZONE_MOSCOW);\n+        \n+        doTest_getOffsetFromLocal(3, 25, 2, 0, \"2007-03-25T03:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 2,30, \"2007-03-25T03:30:00.000+04:00\", ZONE_MOSCOW);\n+        \n+        doTest_getOffsetFromLocal(3, 25, 3, 0, \"2007-03-25T03:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 3,30, \"2007-03-25T03:30:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 4, 0, \"2007-03-25T04:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 5, 0, \"2007-03-25T05:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 6, 0, \"2007-03-25T06:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 7, 0, \"2007-03-25T07:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(3, 25, 8, 0, \"2007-03-25T08:00:00.000+04:00\", ZONE_MOSCOW);\n+    }\n+\n+    public void test_DateTime_setHourAcross_Moscow_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 25, 0, 0, 0, 0, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T00:00:00.000+03:00\", dt.toString());\n+        DateTime res = dt.hourOfDay().setCopy(4);\n+        assertEquals(\"2007-03-25T04:00:00.000+04:00\", res.toString());\n+    }\n+\n+    public void test_DateTime_setHourForward_Moscow_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 25, 0, 0, 0, 0, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T00:00:00.000+03:00\", dt.toString());\n+        \n+        try {\n+            dt.hourOfDay().setCopy(2);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void test_DateTime_setHourBack_Moscow_Spring() {\n+        DateTime dt = new DateTime(2007, 3, 25, 8, 0, 0, 0, ZONE_MOSCOW);\n+        assertEquals(\"2007-03-25T08:00:00.000+04:00\", dt.toString());\n+        \n+        try {\n+            dt.hourOfDay().setCopy(2);\n+            fail();\n+        } catch (IllegalFieldValueException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** America/New_York cutover from 02:59 to 02:00 on 2007-10-28 */\n+    private static long CUTOVER_MOSCOW_AUTUMN = 1193526000000L;  // 2007-10-28T02:00:00.000+03:00\n+\n+    //-----------------------------------------------------------------------\n+    public void test_MoscowIsCorrect_Autumn() {\n+        DateTime pre = new DateTime(CUTOVER_MOSCOW_AUTUMN - 1L, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-28T02:59:59.999+04:00\", pre.toString());\n+        DateTime at = new DateTime(CUTOVER_MOSCOW_AUTUMN, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-28T02:00:00.000+03:00\", at.toString());\n+        DateTime post = new DateTime(CUTOVER_MOSCOW_AUTUMN + 1L, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-28T02:00:00.001+03:00\", post.toString());\n+    }\n+\n+    // broken, and getOffsetFromLocal has no obvious way to determine which is correct\n+//    public void test_getOffsetFromLocal_Moscow_Autumn() {\n+//        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n+//        \n+//        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n+//        \n+//        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n+//        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n+//    }\n+\n+    public void test_DateTime_plusHour_Moscow_Autumm() {\n+        DateTime dt = new DateTime(2007, 10, 27, 19, 0, 0, 0, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-27T19:00:00.000+04:00\", dt.toString());\n+        \n+        DateTime plus6 = dt.plusHours(6);\n+        assertEquals(\"2007-10-28T01:00:00.000+04:00\", plus6.toString());\n+        DateTime plus7 = dt.plusHours(7);\n+        assertEquals(\"2007-10-28T02:00:00.000+04:00\", plus7.toString());\n+        DateTime plus8 = dt.plusHours(8);\n+        assertEquals(\"2007-10-28T02:00:00.000+03:00\", plus8.toString());\n+        DateTime plus9 = dt.plusHours(9);\n+        assertEquals(\"2007-10-28T03:00:00.000+03:00\", plus9.toString());\n+    }\n+\n+    public void test_DateTime_minusHour_Moscow_Autumm() {\n+        DateTime dt = new DateTime(2007, 10, 28, 9, 0, 0, 0, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-28T09:00:00.000+03:00\", dt.toString());\n+        \n+        DateTime minus6 = dt.minusHours(6);\n+        assertEquals(\"2007-10-28T03:00:00.000+03:00\", minus6.toString());\n+        DateTime minus7 = dt.minusHours(7);\n+        assertEquals(\"2007-10-28T02:00:00.000+03:00\", minus7.toString());\n+        DateTime minus8 = dt.minusHours(8);\n+        assertEquals(\"2007-10-28T02:00:00.000+04:00\", minus8.toString());\n+        DateTime minus9 = dt.minusHours(9);\n+        assertEquals(\"2007-10-28T01:00:00.000+04:00\", minus9.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+//    public void test_toDateMidnight_SaoPaolo() {\n+//        // RFE: 1684259\n+//        DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n+//        LocalDate baseDate = new LocalDate(2006, 11, 5);\n+//        DateMidnight dm = baseDate.toDateMidnight(zone);\n+//        assertEquals(\"2006-11-05T00:00:00.000-03:00\", dm.toString());\n+//        DateTime dt = baseDate.toDateTimeAtMidnight(zone);\n+//        assertEquals(\"2006-11-05T00:00:00.000-03:00\", dt.toString());\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {\n+        DateTime dt = new DateTime(2007, month, day, hour, min, 0, 0, DateTimeZone.UTC);\n+        int offset = zone.getOffsetFromLocal(dt.getMillis());\n+        DateTime res = new DateTime(dt.getMillis() - offset, zone);\n+        assertEquals(res.toString(), expected, res.toString());\n+    }\n+\n+}", "timestamp": 1186248202, "metainfo": ""}