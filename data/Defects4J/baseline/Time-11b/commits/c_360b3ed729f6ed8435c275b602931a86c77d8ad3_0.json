{"sha": "360b3ed729f6ed8435c275b602931a86c77d8ad3", "log": "Update javadoc and implementation, including defining null input as now   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n  * <li>Calendar\n  * <li>Date\n  * <li>Long (milliseconds)\n+ * <li>null (now)\n  * </ul>\n  *\n  * <p>\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a DateTimeComparator the compares the entire date time value.\n+     * \n+     * @return a comparator over all fields\n      */\n     public static DateTimeComparator getInstance() {\n         return INSTANCE;\n      * Returns a DateTimeComparator with a lower limit only. Fields of a\n      * magnitude less than the lower limit are excluded from comparisons.\n      *\n-     * @param lowerLimit inclusive lower limit for fields to be compared\n+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n+     * @return a comparator over all fields above the lower limit\n      */\n     public static DateTimeComparator getInstance(DateTimeField lowerLimit) {\n         return getInstance(lowerLimit, null);\n      * excluded from comparisons. Either limit may be specified as null, which\n      * indicates an unbounded limit.\n      *\n-     * @param lowerLimit optional, inclusive lower limit for fields to be compared\n-     * @param upperLimit optional, exclusive upper limit for fields to be compared\n+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n+     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n+     * @return a comparator over all fields between the limits\n      */\n     public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n         if (lowerLimit == null && upperLimit == null) {\n     }\n \n     /**\n-     * Returns a comparator that only considers date fields. Time of day is\n-     * ignored.\n+     * Returns a comparator that only considers date fields.\n+     * Time of day is ignored.\n+     * \n+     * @param chrono  the chronology to use\n+     * @return a comparator over all date fields\n      */\n     public static DateTimeComparator getDateOnlyInstance(Chronology chrono) {\n         return getInstance(chrono.dayOfYear(), null);\n     }\n \n     /**\n-     * Returns a comparator that only considers time fields. Date is ignored.\n+     * Returns a comparator that only considers time fields.\n+     * Date is ignored.\n+     * \n+     * @param chrono  the chronology to use\n+     * @return a comparator over all time fields\n      */\n     public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {\n         return getInstance(null, chrono.dayOfYear());\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n      * Restricted constructor.\n+     * \n+     * @param lowerLimit  the lower field limit, null means no limit\n+     * @param upperLimit  the upper field limit, null means no limit\n      */\n     private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n         super();\n         iUpperLimit = upperLimit;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the field that represents the lower limit of comparison.\n      * \n      * Compare two objects against only the range of date time fields as\n      * specified in the constructor.\n      * \n-     * @param lhsObj The first object, logically on the left of a &lt; comparison\n-     * @param rhsObj The second object, logically on the right of a &lt; comparison\n-     * @return zero if order does not matter, negative value if lhsObj &lt;\n-     *  rhsObj, positive value otherwise.\n+     * @param lhsObj  the first object,\n+     *      logically on the left of a &lt; comparison, null means now\n+     * @param rhsObj  the second object,\n+     *      logically on the right of a &lt; comparison, null means now\n+     * @return zero if order does not matter,\n+     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.\n      * @throws IllegalArgumentException if either argument is not supported\n      */\n     public int compare(Object lhsObj, Object rhsObj) {\n-        long lhsMillis, rhsMillis;\n-\n-        if (lhsObj instanceof ReadableInstant) {\n-            lhsMillis = ((ReadableInstant) lhsObj).getMillis();\n-        } else {\n-            lhsMillis = getMillisFromObject(lhsObj);\n-        }\n-\n-        if (rhsObj instanceof ReadableInstant) {\n-            rhsMillis = ((ReadableInstant) rhsObj).getMillis();\n-        } else {\n-            rhsMillis = getMillisFromObject(rhsObj);\n-        }\n+        long lhsMillis = getMillisFromObject(lhsObj);\n+        long rhsMillis = getMillisFromObject(rhsObj);\n \n         DateTimeField field;\n         if ((field = iLowerLimit) != null) {", "timestamp": 1089412126, "metainfo": ""}