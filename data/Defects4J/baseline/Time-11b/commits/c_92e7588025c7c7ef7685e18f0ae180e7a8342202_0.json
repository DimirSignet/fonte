{"sha": "92e7588025c7c7ef7685e18f0ae180e7a8342202", "log": "Initial version of refactored PartialInstant   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n \n import java.util.Locale;\n \n+import org.joda.time.partial.PartialInstant;\n+\n /**\n  * Defines the calculation engine for date and time fields.\n  * The interface defines a set of methods that manipulate a millisecond datetime\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public interface DateTimeField {\n+public abstract class DateTimeField {\n \n     /**\n      * Get the name of the field, intended for debugging purposes only. By\n      * \n      * @return field name\n      */\n-    String getName();\n+    public abstract String getName();\n \n     /**\n      * Returns true if this field is supported.\n      * \n      * @return true if this field is supported\n      */\n-    boolean isSupported();\n+    public abstract boolean isSupported();\n \n     /**\n      * Returns true if the set method is lenient. If so, it accepts values that\n      * \n      * @return true if this field is lenient\n      */\n-    boolean isLenient();\n+    public abstract boolean isLenient();\n \n     // Main access API\n     //------------------------------------------------------------------------\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the value of the field, in the units of the field\n      */\n-    int get(long instant);\n+    public abstract int get(long instant);\n \n     /**\n      * Get the human-readable, text value of this field from the milliseconds.\n      * @param locale the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    String getAsText(long instant, Locale locale);\n+    public abstract String getAsText(long instant, Locale locale);\n \n     /**\n      * Get the human-readable, text value of this field from the milliseconds.\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the text value of the field\n      */\n-    String getAsText(long instant);\n+    public String getAsText(long instant) {\n+        return getAsText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(PartialInstant partial, int fieldValue, Locale locale);\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(PartialInstant partial, Locale locale) {\n+        return getAsText(partial, partial.get(this), locale);\n+    }\n \n     /**\n      * Get the human-readable, short text value of this field from the\n      * @param locale the locale to use for selecting a text symbol, null for default\n      * @return the short text value of the field\n      */\n-    String getAsShortText(long instant, Locale locale);\n+    public abstract String getAsShortText(long instant, Locale locale);\n \n     /**\n      * Get the human-readable, short text value of this field from the\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the short text value of the field\n      */\n-    String getAsShortText(long instant);\n+    public String getAsShortText(long instant) {\n+        return getAsShortText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsShortText(PartialInstant partial, int fieldValue, Locale locale);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(PartialInstant partial, Locale locale) {\n+        return getAsShortText(partial, partial.get(this), locale);\n+    }\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * @param value  the value to add, in the units of the field\n      * @return the updated milliseconds\n      */\n-    long add(long instant, int value);\n+    public abstract long add(long instant, int value);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * @throws IllegalArgumentException if value is too large\n      * @see #add(long,int)\n      */\n-    long add(long instant, long value);\n+    public abstract long add(long instant, long value);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * @param value  the value to add, in the units of the field\n      * @return the updated milliseconds\n      */\n-    long addWrapped(long instant, int value) ;\n+    public abstract long addWrapped(long instant, int value) ;\n \n     /**\n      * Computes the difference between two instants, as measured in the units\n      * subtract off the minuend\n      * @return the difference in the units of this field\n      */\n-    int getDifference(long minuendInstant, long subtrahendInstant);\n+    public abstract int getDifference(long minuendInstant, long subtrahendInstant);\n \n     /**\n      * Computes the difference between two instants, as measured in the units\n      * subtract off the minuend\n      * @return the difference in the units of this field\n      */\n-    long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n+    public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n \n     /**\n      * Sets a value in the milliseconds supplied.\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    long set(long instant, int value);\n+    public abstract long set(long instant, int value);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    long set(long instant, String text, Locale locale);\n+    public abstract long set(long instant, String text, Locale locale);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text\n      * @return the updated milliseconds\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    long set(long instant, String text);\n+    public long set(long instant, String text) {\n+        return set(instant, text, null);\n+    }\n \n     // Extra information API\n     //------------------------------------------------------------------------\n      * @return the duration of this field, or UnsupportedDurationField if field\n      * has no duration\n      */\n-    DurationField getDurationField();\n+    public abstract DurationField getDurationField();\n \n     /**\n      * Returns the range duration of this field. For example, if this field\n      *\n      * @return the range duration of this field, or null if field has no range\n      */\n-    DurationField getRangeDurationField();\n+    public abstract DurationField getRangeDurationField();\n \n     /**\n      * Returns whether this field is 'leap' for the specified instant.\n      * \n      * @return true if the field is 'leap'\n      */\n-    boolean isLeap(long instant);\n+    public abstract boolean isLeap(long instant);\n \n     /**\n      * Gets the amount by which this field is 'leap' for the specified instant.\n      * For example, a leap year would return one, a non leap year would return\n      * zero.\n      */\n-    int getLeapAmount(long instant);\n+    public abstract int getLeapAmount(long instant);\n \n     /**\n      * If this field were to leap, then it would be in units described by the\n      * returned duration. If this field doesn't ever leap, null is returned.\n      */\n-    DurationField getLeapDurationField();\n+    public abstract DurationField getLeapDurationField();\n \n     /**\n      * Get the minimum allowable value for this field.\n      * @return the minimum valid value for this field, in the units of the\n      * field\n      */\n-    int getMinimumValue();\n+    public abstract int getMinimumValue();\n \n     /**\n      * Get the minimum value for this field evaluated at the specified time.\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the minimum value for this field, in the units of the field\n      */\n-    int getMinimumValue(long instant);\n+    public abstract int getMinimumValue(long instant);\n \n     /**\n      * Get the maximum allowable value for this field.\n      * @return the maximum valid value for this field, in the units of the\n      * field\n      */\n-    int getMaximumValue();\n+    public abstract int getMaximumValue();\n \n     /**\n      * Get the maximum value for this field evaluated at the specified time.\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @return the maximum value for this field, in the units of the field\n      */\n-    int getMaximumValue(long instant);\n+    public abstract int getMaximumValue(long instant);\n \n     /**\n      * Get the maximum text value for this field.\n      * @param locale  the locale to use for selecting a text symbol\n      * @return the maximum text length\n      */\n-    int getMaximumTextLength(Locale locale);\n+    public abstract int getMaximumTextLength(Locale locale);\n \n     /**\n      * Get the maximum short text value for this field.\n      * @param locale  the locale to use for selecting a text symbol\n      * @return the maximum short text length\n      */\n-    int getMaximumShortTextLength(Locale locale);\n+    public abstract int getMaximumShortTextLength(Locale locale);\n \n     // Calculation API\n     //------------------------------------------------------------------------\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    long roundFloor(long instant);\n+    public abstract long roundFloor(long instant);\n \n     /**\n      * Round to the highest whole unit of this field. The value of this field\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    long roundCeiling(long instant);\n+    public abstract long roundCeiling(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    long roundHalfFloor(long instant);\n+    public abstract long roundHalfFloor(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    long roundHalfCeiling(long instant);\n+    public abstract long roundHalfCeiling(long instant);\n \n     /**\n      * Round to the nearest whole unit of this field. If the given millisecond\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n      * @return rounded milliseconds\n      */\n-    long roundHalfEven(long instant);\n+    public abstract long roundHalfEven(long instant);\n \n     /**\n      * Returns the fractional duration milliseconds of this field. In other\n      * remainder\n      * @return remainder duration, in milliseconds\n      */\n-    long remainder(long instant);\n+    public abstract long remainder(long instant);\n \n     /**\n      * Get a suitable debug string.\n      * \n      * @return debug string\n      */\n-    String toString();\n+    public abstract String toString();\n     \n }\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n             super(\"halfdayOfDay\", cHalfdaysField, cDaysField);\n         }\n \n-        public String getAsText(long millis, Locale locale) {\n-            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));\n+        protected String getAsText(int fieldValue, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);\n         }\n \n         public long set(long millis, String text, Locale locale) {\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n  */\n final class BuddhistEraDateTimeField extends AbstractDateTimeField {\n     \n-    static final long serialVersionUID = -9175876774456816364L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = -9175876774456816364L;\n \n     /**\n      * Singleton instance\n     public int getMaximumValue() {\n         return BuddhistChronology.BE;\n     }\n-    \n-    /**\n-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n-     */\n-    public String getAsShortText(long instant, Locale locale) {\n-        return \"BE\";\n-    }\n-    \n-    /**\n-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n-     */\n-    public int getMaximumShortTextLength(Locale locale) {\n-        return 2;\n-    }\n \n-    /**\n-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n-     */\n-    public String getAsText(long instant, Locale locale) {\n+    protected String getAsText(int fieldValue, Locale locale) {\n         return \"BE\";\n     }\n \n-    /**\n-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n-     */\n     public int getMaximumTextLength(Locale locale) {\n         return 2;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n  */\n final class CopticEraDateTimeField extends AbstractDateTimeField {\n     \n-    static final long serialVersionUID = 4090856468123006167L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4090856468123006167L;\n \n     /**\n      * Singleton instance\n         return CopticChronology.AM;\n     }\n     \n-    /**\n-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n-     */\n-    public String getAsShortText(long instant, Locale locale) {\n-        return \"AM\";\n-    }\n-    \n-    /**\n-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n-     */\n-    public int getMaximumShortTextLength(Locale locale) {\n-        return 2;\n-    }\n-\n-    /**\n-     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n-     */\n-    public String getAsText(long instant, Locale locale) {\n+    protected String getAsText(int fieldValue, Locale locale) {\n         return \"AM\";\n     }\n \n-    /**\n-     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n-     */\n     public int getMaximumTextLength(Locale locale) {\n         return 2;\n     }\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n  */\n final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {\n     \n-    static final long serialVersionUID = -3857947176719041436L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3857947176719041436L;\n \n     private final AbstractGJChronology iChronology;\n \n     /**\n      * Get the textual value of the specified time instant.\n      * \n-     * @param instant  the time instant in millis to query\n+     * @param fieldValue  the field value to query\n      * @param locale  the locale to use\n      * @return the day of the week, such as 'Monday'\n      */\n-    public String getAsText(long instant, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n+    protected String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);\n     }\n \n     /**\n      * @param locale  the locale to use\n      * @return the day of the week, such as 'Mon'\n      */\n-    public String getAsShortText(long instant, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));\n+    protected String getAsShortText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n  */\n final class GJEraDateTimeField extends AbstractDateTimeField {\n     \n-    static final long serialVersionUID = 4240986525305515528L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4240986525305515528L;\n \n     private final AbstractGJChronology iChronology;\n \n         }\n     }\n \n-    public String getAsText(long instant, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));\n+    protected String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  * Provides time calculations for the month of the year component of time.\n  */\n final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n \n-    static final long serialVersionUID = -4748157875845286249L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4748157875845286249L;\n \n     private static final int MIN = DateTimeConstants.JANUARY;\n     private static final int MAX = DateTimeConstants.DECEMBER;\n         return iChronology.getMonthOfYear(instant);\n     }\n \n-    public String getAsText(long instant, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));\n-    }\n-\n-    public String getAsShortText(long instant, Locale locale) {\n-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));\n+    protected String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue);\n+    }\n+\n+    protected String getAsShortText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java\n \n import java.io.Serializable;\n import java.util.Locale;\n+\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.partial.PartialInstant;\n \n /**\n  * AbstractDateTimeField provides the common behaviour for DateTimeField\n  * @since 1.0\n  * @see DecoratedDateTimeField\n  */\n-public abstract class AbstractDateTimeField implements DateTimeField, Serializable {\n-\n-    static final long serialVersionUID = -4388055220581798589L;\n+public abstract class AbstractDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4388055220581798589L;\n \n     /** A desriptive name for the field */\n     private final String iName;\n      */\n     public abstract int get(long instant);\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Get the human-readable, text value of this field from the milliseconds.\n      * If the specified locale is null, the default locale is used.\n      * <p>\n-     * The default implementation returns Integer.toString(get(instant)).\n-     * <p>\n-     * Note: subclasses that override this method should also override\n-     * getMaximumTextLength.\n+     * The default implementation returns getAsText(get(instant)).\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n      * @param locale the locale to use for selecting a text symbol, null for\n      * @return the text value of the field\n      */\n     public String getAsText(long instant, Locale locale) {\n-        return Integer.toString(get(instant));\n-    }\n-\n-    /**\n-     * Get the human-readable, text value of this field from the milliseconds.\n-     * This implementation returns getAsText(instant, null).\n-     * \n+        return getAsText(get(instant));\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return getAsText(fieldValue);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public final String getAsText(long instant) {\n-        return getAsText(instant, null);\n-    }\n-\n-    /**\n-     * Get the human-readable, short text value of this field from the\n-     * milliseconds.  If the specified locale is null, the default locale is\n-     * used.\n-     * <p>\n-     * The default implementation returns getAsText(instant, locale).\n+    protected String getAsText(int fieldValue, Locale locale) {\n+        return Integer.toString(fieldValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the human-readable, short text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(get(instant)).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return getAsShortText(get(instant));\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(fieldValue).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return getAsShortText(fieldValue);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue, locale).\n      * <p>\n      * Note: subclasses that override this method should also override\n      * getMaximumShortTextLength.\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n-     * @param locale the locale to use for selecting a text symbol, null for\n-     * default\n-     * @return the short text value of the field\n-     */\n-    public String getAsShortText(long instant, Locale locale) {\n-        return getAsText(instant, locale);\n-    }\n-\n-    /**\n-     * Get the human-readable, short text value of this field from the\n-     * milliseconds.  This implementation returns getAsShortText(instant, null).\n-     * \n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n-     * @return the short text value of the field\n-     */\n-    public final String getAsShortText(long instant) {\n-        return getAsShortText(instant, null);\n-    }\n-\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    protected String getAsShortText(int fieldValue, Locale locale) {\n+        return getAsText(fieldValue, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Adds a value (which may be negative) to the instant value,\n      * overflowing into larger fields if necessary.\n         return set(instant, wrapped);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Computes the difference between two instants, as measured in the units\n      * of this field. Any fractional units are dropped from the result. Calling\n         } catch (NumberFormatException ex) {\n             throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n         }\n-    }\n-\n-    /**\n-     * Sets a value in the milliseconds supplied from a human-readable, text\n-     * value. This implementation returns set(instant, text, null).\n-     * \n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n-     * @param text  the text value to set\n-     * @return the updated milliseconds\n-     * @throws IllegalArgumentException if the text value is invalid\n-     */\n-    public final long set(long instant, String text) {\n-        return set(instant, text, null);\n     }\n \n     // Extra information API\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.partial.PartialInstant;\n \n /**\n  * <code>DelegatedDateTimeField</code> delegates each method call to the\n  * @since 1.0\n  * @see DecoratedDateTimeField\n  */\n-public class DelegatedDateTimeField implements DateTimeField, Serializable {\n-\n-    static final long serialVersionUID = -4730164440214502503L;\n+public class DelegatedDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4730164440214502503L;\n \n     /** The DateTimeField being wrapped */\n     private final DateTimeField iField;\n         return iField.getAsText(instant);\n     }\n \n+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return iField.getAsText(partial, fieldValue, locale);\n+    }\n+\n+    public String getAsText(PartialInstant partial, Locale locale) {\n+        return iField.getAsText(partial, locale);\n+    }\n+\n     public String getAsShortText(long instant, Locale locale) {\n         return iField.getAsShortText(instant, locale);\n     }\n \n     public String getAsShortText(long instant) {\n         return iField.getAsShortText(instant);\n+    }\n+\n+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return iField.getAsShortText(partial, fieldValue, locale);\n+    }\n+\n+    public String getAsShortText(PartialInstant partial, Locale locale) {\n+        return iField.getAsShortText(partial, locale);\n     }\n \n     public long add(long instant, int value) {\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n+import org.joda.time.partial.PartialInstant;\n \n /**\n  * A placeholder implementation to use when a datetime field is not supported.\n  *\n  * @author Brian S O'Neill\n  */\n-public final class UnsupportedDateTimeField implements DateTimeField, Serializable {\n-\n-    static final long serialVersionUID = -1934618396111902255L;\n+public final class UnsupportedDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialilzation version */\n+    private static final long serialVersionUID = -1934618396111902255L;\n \n     /**\n      * Instance with the name \"unsupported\".\n      *\n      * @throws UnsupportedOperationException\n      */\n-    public String getAsText(long instant) {\n+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public String getAsShortText(long instant) {\n+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n         throw unsupported();\n     }\n \n      * @throws UnsupportedOperationException\n      */\n     public long set(long instant, String text, Locale locale) {\n-        throw unsupported();\n-    }\n-\n-    /**\n-     * Always throws UnsupportedOperationException\n-     *\n-     * @throws UnsupportedOperationException\n-     */\n-    public long set(long instant, String text) {\n         throw unsupported();\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * AbstractPartialFieldProperty is a base class for binding a\n+ * PartialInstant to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartialFieldProperty {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPartialFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the partial instant being used.\n+     * \n+     * @return the partial instant\n+     */\n+    public abstract PartialInstant getPartialInstant();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the partial instant.\n+     * \n+     * @return the current value\n+     */\n+    public abstract int get();\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getPartialInstant(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public final String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getPartialInstant(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the partial instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public final String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+// TODO\n+//    /**\n+//     * Gets whether this field is leap.\n+//     * \n+//     * @return true if a leap field\n+//     * @see DateTimeField#isLeap\n+//     */\n+//    public boolean isLeap() {\n+//        return getField().isLeap(getPartialInstant(), get());\n+//    }\n+//\n+//    /**\n+//     * Gets the amount by which this field is leap.\n+//     * \n+//     * @return the amount by which the field is leap\n+//     * @see DateTimeField#getLeapAmount\n+//     */\n+//    public int getLeapAmount() {\n+//        return getField().getLeapAmount(getPartialInstant(), get());\n+//    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return getField().getLeapDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+// TODO\n+//    /**\n+//     * Gets the minimum value for the field ignoring the current time.\n+//     * \n+//     * @return the minimum value\n+//     * @see DateTimeField#getMinimumValue\n+//     */\n+//    public int getMinimumValueOverall() {\n+//        return getField().getMinimumValue();\n+//    }\n+//\n+//    /**\n+//     * Gets the minimum value for the field.\n+//     * \n+//     * @return the minimum value\n+//     * @see DateTimeField#getMinimumValue\n+//     */\n+//    public int getMinimumValue() {\n+//        return getField().getMinimumValue(getPartialInstant(), get());\n+//    }\n+//\n+//    /**\n+//     * Gets the maximum value for the field ignoring the current time.\n+//     * \n+//     * @return the maximum value\n+//     * @see DateTimeField#getMaximumValue\n+//     */\n+//    public int getMaximumValueOverall() {\n+//        return getField().getMaximumValue();\n+//    }\n+//\n+//    /**\n+//     * Gets the maximum value for the field.\n+//     * \n+//     * @return the maximum value\n+//     * @see DateTimeField#getMaximumValue\n+//     */\n+//    public int getMaximumValue() {\n+//        return getField().getMaximumValue(getPartialInstant(), get());\n+//    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link PartialInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the field of this property cannot be queried\n+     *  on the specified instant\n+     */\n+    public int compareTo(PartialInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getField());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * Defines an instant that does not support every datetime field.\n+ * <p>\n+ * A PartialInstant supports a set of fields and cannot be compared to a\n+ * full complete instant. Methods are provided to resolve the partial instant\n+ * into a full instant by 'filling in the gaps'.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface PartialInstant {\n+\n+    /**\n+     * Gets an array of the fields that this partial instant supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported, largest to smallest\n+     */\n+    DateTimeField[] getSupportedFields();\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial instant.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    int get(DateTimeField field);\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial instant.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DateTimeField field);\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this method\n+     * will be the date from the specified base plus the time from this instant.\n+     *\n+     * @param baseMillis  source of missing fields\n+     * @return the combined instant in milliseconds\n+     */\n+    long resolve(long baseMillis);\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this method\n+     * will be the date from the specified base plus the time from this instant.\n+     *\n+     * @param base  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    DateTime resolveDateTime(ReadableInstant base);\n+\n+//    /**\n+//     * Compares this object with the specified object for equality based\n+//     * on the millisecond instant, the Chronology, and the limiting fields.\n+//     * <p>\n+//     * To compare two instants for absolute time (ie. UTC milliseconds ignoring\n+//     * the chronology), use {@link #isEqual(ReadableInstant)} or\n+//     * {@link #compareTo(Object)}.\n+//     *\n+//     * @param readableInstant  a readable instant to check against\n+//     * @return true if millisecond and chronology are equal, false if\n+//     *  not or the instant is null or of an incorrect type\n+//     */\n+//    boolean equals(Object readableInstant);\n+//\n+//    /**\n+//     * Gets a hash code for the instant that is compatable with the \n+//     * equals method.\n+//     *\n+//     * @return a suitable hash code\n+//     */\n+//    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import java.util.Arrays;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * TimeOfDay is an immutable partial instant supporting the hour, minute, second\n+ * and millisecond fields.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum value\n+ * <li>minimum value\n+ * </ul>\n+ * <p>\n+ * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class TimeOfDay implements PartialInstant {\n+\n+    /** The index of the hourOfDay field in the field array */\n+    private static final int HOUR_OF_DAY = 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    private static final int MINUTE_OF_HOUR = 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    private static final int SECOND_OF_MINUTE = 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    private static final int MILLIS_OF_SECOND = 3;\n+\n+    // TODO: Is chronology needed here?\n+    /** The chronology in use */\n+    private final Chronology iChronology;\n+    /** The fields supported by this partial instant */\n+    private final DateTimeField[] iFields;\n+    /** The values of each field in this partial instant */\n+    private final int[] iValues;\n+\n+    // TODO serialize\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     */\n+    public TimeOfDay() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public TimeOfDay(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(long instant, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology;\n+        iFields = initFields(chronology);\n+        iValues = initValues(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public TimeOfDay(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chronology = converter.getChronology(instant);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology;\n+        iFields = initFields(chronology);\n+        iValues = initValues(converter.getInstantMillis(instant));\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public TimeOfDay(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology original = converter.getChronology(instant, chronology);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology;\n+        iFields = initFields(chronology);\n+        iValues = initValues(converter.getInstantMillis(instant, chronology));\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values using\n+     * <code>ISOChronology</code> in the default zone.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and chronology.\n+     * \n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour,\n+            int secondOfMinute, int millisOfSecond, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology;\n+        iFields = initFields(chronology);\n+        // TODO: Validate\n+        iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified fields, values and chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    TimeOfDay(TimeOfDay partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iFields = partial.iFields;\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Initialize the array of fields.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    private DateTimeField[] initFields(Chronology chrono) {\n+        return new DateTimeField[] {\n+            chrono.hourOfDay(),\n+            chrono.minuteOfHour(),\n+            chrono.secondOfMinute(),\n+            chrono.millisOfSecond(),\n+        };\n+    }\n+\n+    /**\n+     * Initialize the array of values.\n+     * \n+     * @param instant  the instant to use\n+     */\n+    private int[] initValues(long instant) {\n+        return new int[] {\n+            iFields[0].get(instant),\n+            iFields[1].get(instant),\n+            iFields[2].get(instant),\n+            iFields[3].get(instant),\n+        };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index) {\n+        return iFields[index];\n+    }\n+    \n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     */\n+    protected int getValue(int index) {\n+        return iValues[index];\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the fields that this partial instant supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported, largest to smallest\n+     */\n+    public DateTimeField[] getSupportedFields() {\n+        return (DateTimeField[]) iFields.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial instant.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public int get(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return iValues[i];\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported by TimeOfDay\");\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial instant.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this method\n+     * will be the date from the specified base plus the time from this instant.\n+     *\n+     * @param baseMillis  source of missing fields\n+     * @return the combined instant in milliseconds\n+     */\n+    public long resolve(long baseMillis) {\n+        long millis = baseMillis;\n+        for (int i = 0; i < iFields.length; i++) {\n+            millis = iFields[i].set(millis, iValues[i]);\n+        }\n+        return millis;\n+    }\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this method\n+     * will be the date from the specified base plus the time from this instant.\n+     *\n+     * @param base  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    public DateTime resolveDateTime(ReadableInstant base) {\n+        if (base == null) {\n+            base = new DateTime();\n+        }\n+        Chronology chrono = base.getChronology();\n+        long millis = base.getMillis();\n+        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));\n+        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));\n+        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));\n+        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));\n+        return new DateTime(millis, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getValue(HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getValue(MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getValue(SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getValue(MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this TimeOfDay with another returning true if the fields and\n+     * values are equal.\n+     *\n+     * @param timeOfDay  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object timeOfDay) {\n+        if (timeOfDay instanceof TimeOfDay == false) {\n+            return false;\n+        }\n+        TimeOfDay other = (TimeOfDay) timeOfDay;\n+        return Arrays.equals(iValues, other.iValues) &&\n+               Arrays.equals(iFields, other.iFields);\n+    }\n+\n+    /**\n+     * Gets a hash code for the TimeOfDay that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int total = 157;\n+        for (int i = 0; i < iValues.length; i++) {\n+            total = 23 * total + getValue(i);\n+            total += getField(i).hashCode();\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Output the time in ISO8601 time only format (hh:mm:ss.SSS).\n+     * \n+     * @return ISO8601 time formatted string\n+     */\n+    public String toString() {\n+        // TODO\n+        return \"\";\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for TimeOfDay.\n+     */\n+    public static class Property extends AbstractPartialFieldProperty {\n+\n+        /** The instant */\n+        private final TimeOfDay iInstant;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param instant  the partial instant\n+         * @param field  the field\n+         * @param fieldIndex  the index in the instant\n+         */\n+        Property(TimeOfDay instant, int fieldIndex) {\n+            super();\n+            iInstant = instant;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iInstant.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the instant that this property belongs to.\n+         * \n+         * @return the partial instant\n+         */\n+        public PartialInstant getPartialInstant() {\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Gets the instant that this property belongs to.\n+         * \n+         * @return the partial instant\n+         */\n+        public TimeOfDay getTimeOfDay() {\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Gets the value of the field that the partial instant is set to.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iInstant.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+// TODO\n+//        /**\n+//         * Adds to this field in a copy of this TimeOfDay.\n+//         * <p>\n+//         * The TimeOnly attached to this property is unchanged by this call.\n+//         * \n+//         * @param value  the value to add to the field in the copy\n+//         * @return a copy of the TimeOnly with the field value changed\n+//         * @throws IllegalArgumentException if the value isn't valid\n+//         */\n+//        public TimeOfDay addToCopy(int value) {\n+//            int[] newValues = getField().add(getInstant(), value);\n+//            return new TimeOfDay(getInstant(), newValues);\n+//        }\n+//\n+//        /**\n+//         * Adds to this field, possibly wrapped, in a copy of this TimeOfDay.\n+//         * A wrapped operation only changes this field.\n+//         * Thus 12:59:00 addWrapped one minute goes to 12:00:00.\n+//         * <p>\n+//         * The TimeOfDay attached to this property is unchanged by this call.\n+//         * \n+//         * @param value  the value to add to the field in the copy\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         * @throws IllegalArgumentException if the value isn't valid\n+//         */\n+//        public TimeOfDay addWrappedToCopy(int value) {\n+//            int[] newValues = getField().addWrapped(getInstant(), value);\n+//            return new TimeOfDay(getInstant(), newValues);\n+//        }\n+//\n+//        //-----------------------------------------------------------------------\n+//        /**\n+//         * Sets this field in a copy of the TimeOfDay.\n+//         * <p>\n+//         * The TimeOfDay attached to this property is unchanged by this call.\n+//         * \n+//         * @param value  the value to set the field in the copy to\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         * @throws IllegalArgumentException if the value isn't valid\n+//         */\n+//        public TimeOfDay setCopy(int value) {\n+//            int[] newValues = getField().set(getInstant(), value);\n+//            return new TimeOfDay(getInstant(), newValues);\n+//        }\n+//    \n+//        /**\n+//         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+//         * <p>\n+//         * The TimeOfDay attached to this property is unchanged by this call.\n+//         * \n+//         * @param text  the text value to set\n+//         * @param locale  optional locale to use for selecting a text symbol\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         * @throws IllegalArgumentException if the text value isn't valid\n+//         */\n+//        public TimeOfDay setCopy(String text, Locale locale) {\n+//            int[] newValues = getField().set(getInstant(), text, locale);\n+//            return new TimeOfDay(getInstant(), newValues);\n+//        }\n+//\n+//        /**\n+//         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+//         * <p>\n+//         * The TimeOfDay attached to this property is unchanged by this call.\n+//         * This operation is faster than converting a TimeOfDay to a MutableTimeOfDay\n+//         * and back again when setting one field. When setting multiple fields,\n+//         * it is generally quicker to make the conversion to MutableTimeOfDay.\n+//         * \n+//         * @param text  the text value to set\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         * @throws IllegalArgumentException if the text value isn't valid\n+//         */\n+//        public final TimeOfDay setCopy(String text) {\n+//            return setCopy(text, null);\n+//        }\n+\n+//        //-----------------------------------------------------------------------\n+//        /**\n+//         * Rounds to the lowest whole unit of this field on a copy of this TimeOfDay.\n+//         *\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         */\n+//        public TimeOfDay roundFloorCopy() {\n+//            TimeOfDay instant = iInstant;\n+//            return (TimeOfDay) instant.withMillis(iField.roundFloor(instant.getMillis()));\n+//        }\n+//\n+//        /**\n+//         * Rounds to the highest whole unit of this field on a copy of this TimeOfDay.\n+//         *\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         */\n+//        public TimeOfDay roundCeilingCopy() {\n+//            TimeOfDay instant = iInstant;\n+//            return (TimeOfDay) instant.withMillis(iField.roundCeiling(instant.getMillis()));\n+//        }\n+//\n+//        /**\n+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,\n+//         * favoring the floor if halfway.\n+//         *\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         */\n+//        public TimeOfDay roundHalfFloorCopy() {\n+//            TimeOfDay instant = iInstant;\n+//            return (TimeOfDay) instant.withMillis(iField.roundHalfFloor(instant.getMillis()));\n+//        }\n+//\n+//        /**\n+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,\n+//         * favoring the ceiling if halfway.\n+//         *\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         */\n+//        public TimeOfDay roundHalfCeilingCopy() {\n+//            TimeOfDay instant = iInstant;\n+//            return (TimeOfDay) instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));\n+//        }\n+//\n+//        /**\n+//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay.\n+//         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n+//         *\n+//         * @return a copy of the TimeOfDay with the field value changed\n+//         */\n+//        public TimeOfDay roundHalfEvenCopy() {\n+//            TimeOfDay instant = iInstant;\n+//            return (TimeOfDay) instant.withMillis(iField.roundHalfEven(instant.getMillis()));\n+//        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.partial;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+import org.joda.time.partial.TimeOfDay;\n+\n+/**\n+ * This class is a Junit unit test for TimeOfDay.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTimeOfDay extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    \n+    private long TEST_TIME =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestTimeOfDay.class);\n+    }\n+\n+    public TestTimeOfDay(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(DateTimeZone.UTC);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_longChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(TEST_TIME, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        // TODO\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_ObjectChronology() throws Throwable {\n+        // TODO\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int)\n+     */\n+    public void testConstructor_intintintint() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, int, Chronology)\n+     */\n+    public void testConstructor_intintintintChronology() throws Throwable {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n+        assertEquals(JulianChronology.getInstance(), test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testGetField() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance().dayOfMonth());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            test.get(ISOChronology.getInstance(PARIS).hourOfDay());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        // TODO: Should this fail or suceed - by succeeding it exposes out implementation\n+//        try {\n+//            test.get(JulianChronology.getInstance().hourOfDay());\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetSupportedFields() {\n+        TimeOfDay test = new TimeOfDay();\n+        DateTimeField[] fields = test.getSupportedFields();\n+        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);\n+        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);\n+        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);\n+        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);\n+    }\n+\n+    public void testIsSupported() {\n+        TimeOfDay test = new TimeOfDay();\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(test1.hashCode(), test2.hashCode());\n+        assertEquals(test1.hashCode(), test1.hashCode());\n+        assertEquals(test2.hashCode(), test2.hashCode());\n+        \n+        TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertTrue(test1.hashCode() != test3.hashCode());\n+        assertTrue(test2.hashCode() != test3.hashCode());\n+    }\n+\n+    public void testResolve_long() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = new DateTime(test.resolve(dt.getMillis()));\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+    public void testResolve_RI() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        DateTime dt = new DateTime(0L);\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        \n+        DateTime result = test.resolveDateTime(dt);\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+        assertEquals(\"1970-01-01T00:00:00.000Z\", dt.toString());\n+        assertEquals(\"1970-01-01T10:20:30.040Z\", result.toString());\n+    }\n+\n+}", "timestamp": 1083519604, "metainfo": ""}