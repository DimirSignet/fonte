{"sha": "067983f2684fa9e9ca4af4ef73b09e2be2f70001", "log": "Ensure immutable classes by using final instance variables", "commit": "\n--- a/src/main/java/org/joda/time/base/AbstractPeriod.java\n+++ b/src/main/java/org/joda/time/base/AbstractPeriod.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the number of fields that this period supports.\n+     *\n+     * @return the number of fields supported\n+     * @since 2.0 (previously on BasePeriod)\n+     */\n+    public int size() {\n+        return getPeriodType().size();\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since 2.0 (previously on BasePeriod)\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        return getPeriodType().getFieldType(index);\n+    }\n+\n+    /**\n      * Gets an array of the field types that this period supports.\n      * <p>\n      * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n--- a/src/main/java/org/joda/time/base/BaseDateTime.java\n+++ b/src/main/java/org/joda/time/base/BaseDateTime.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = -6728882245981L;\n \n     /** The millis from 1970-01-01T00:00:00Z */\n-    private long iMillis;\n+    private final long iMillis;\n     /** The chronology to use */\n-    private Chronology iChronology;\n+    private final Chronology iChronology;\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>\n      * All changes to the millisecond field occurs via this method.\n      * Override and block this method to make a subclass immutable.\n+     * <p>\n+     * In version 2.0 and later, this method uses reflection. This is because the\n+     * instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      *\n      * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to\n      */\n     protected void setMillis(long instant) {\n-        iMillis = checkInstant(instant, iChronology);\n+        instant = checkInstant(instant, iChronology);\n+        MutableHelper.setDateTimeMillis(this, instant);\n     }\n \n     /**\n      * <p>\n      * All changes to the chronology field occurs via this method.\n      * Override and block this method to make a subclass immutable.\n+     * <p>\n+     * In version 2.0 and later, this method uses reflection. This is because the\n+     * instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      *\n      * @param chronology  the chronology to set\n      */\n     protected void setChronology(Chronology chronology) {\n-        iChronology = checkChronology(chronology);\n+        chronology = checkChronology(chronology);\n+        MutableHelper.setDateTimeChrono(this, chronology);\n     }\n \n }\n--- a/src/main/java/org/joda/time/base/BaseDuration.java\n+++ b/src/main/java/org/joda/time/base/BaseDuration.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = 2581698638990L;\n \n     /** The duration length */\n-    private long iMillis;\n+    private final long iMillis;\n \n     /**\n      * Creates a duration from the given millisecond duration.\n     //-----------------------------------------------------------------------\n     /**\n      * Sets the length of this duration in milliseconds.\n+     * <p>\n+     * In version 2.0 and later, this method uses reflection. This is because the\n+     * instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      * \n      * @param duration  the new length of the duration\n      */\n     protected void setMillis(long duration) {\n-        iMillis = duration;\n+        MutableHelper.setDurationMillis(this, duration);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/main/java/org/joda/time/base/BaseInterval.java\n+++ b/src/main/java/org/joda/time/base/BaseInterval.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.MutableInterval;\n-import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableDuration;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadableInterval;\n     private static final long serialVersionUID = 576586928732749278L;\n \n     /** The chronology of the interval */\n-    private Chronology iChronology;\n+    private final Chronology iChronology;\n     /** The start of the interval */\n-    private long iStartMillis;\n+    private final long iStartMillis;\n     /** The end of the interval */\n-    private long iEndMillis;\n+    private final long iEndMillis;\n \n     /**\n      * Constructs an interval from a start and end instant.\n             iChronology = (chrono != null ? chrono : input.getChronology());\n             iStartMillis = input.getStartMillis();\n             iEndMillis = input.getEndMillis();\n-        } else if (this instanceof ReadWritableInterval) {\n-            converter.setInto((ReadWritableInterval) this, interval, chrono);\n         } else {\n             MutableInterval mi = new MutableInterval();\n             converter.setInto(mi, interval, chrono);\n     //-----------------------------------------------------------------------\n     /**\n      * Sets this interval from two millisecond instants and a chronology.\n+     * <p>\n+     * In version 2.0 and later, this method uses reflection. This is because the\n+     * instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      *\n      * @param startInstant  the start of the time interval\n      * @param endInstant  the start of the time interval\n      */\n     protected void setInterval(long startInstant, long endInstant, Chronology chrono) {\n         checkInterval(startInstant, endInstant);\n-        iStartMillis = startInstant;\n-        iEndMillis = endInstant;\n-        iChronology = DateTimeUtils.getChronology(chrono);\n+        MutableHelper.setInterval(this, startInstant, endInstant, DateTimeUtils.getChronology(chrono));\n     }\n \n }\n--- a/src/main/java/org/joda/time/base/BasePartial.java\n+++ b/src/main/java/org/joda/time/base/BasePartial.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = 2353678632973660L;\n \n     /** The chronology in use */\n-    private Chronology iChronology;\n+    private final Chronology iChronology;\n     /** The values of each field in this partial */\n-    private int[] iValues;\n+    private final int[] iValues;\n \n     //-----------------------------------------------------------------------\n     /**\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Sets the value of the field at the specifed index.\n+     * Sets the value of the field at the specified index.\n+     * <p>\n+     * In version 2.0 and later, this method copies the array into the original.\n+     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      * \n      * @param index  the index\n      * @param value  the value to set\n      */\n     protected void setValue(int index, int value) {\n         DateTimeField field = getField(index);\n-        iValues = field.set(this, index, iValues, value);\n+        int[] values = field.set(this, index, iValues, value);\n+        System.arraycopy(values, 0, iValues, 0, iValues.length);\n     }\n \n     /**\n      * Sets the values of all fields.\n+     * <p>\n+     * In version 2.0 and later, this method copies the array into the original.\n+     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      * \n      * @param values  the array of values\n      */\n     protected void setValues(int[] values) {\n         getChronology().validate(this, values);\n-        iValues = values;\n+        System.arraycopy(values, 0, iValues, 0, iValues.length);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/main/java/org/joda/time/base/BasePeriod.java\n+++ b/src/main/java/org/joda/time/base/BasePeriod.java\n /*\n- *  Copyright 2001-2007 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     /** Serialization version */\n     private static final long serialVersionUID = -2110953284060001145L;\n+    /** Serialization version */\n+    private static final ReadablePeriod DUMMY_PERIOD = new AbstractPeriod() {\n+        @Override\n+        public int getValue(int index) {\n+            return 0;\n+        }\n+        @Override\n+        public PeriodType getPeriodType() {\n+            return PeriodType.time();\n+        }\n+    };\n \n     /** The type of period */\n-    private PeriodType iType;\n+    private final PeriodType iType;\n     /** The values */\n-    private int[] iValues;\n+    private final int[] iValues;\n \n     //-----------------------------------------------------------------------\n     /**\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n-        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n+        iValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n     }\n \n     /**\n     protected BasePeriod(long duration) {\n         super();\n         // bug [3264409]\n-        iType = PeriodType.time();\n-        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n+        // calculation uses period type from a period object (bad design)\n+        // thus we use a dummy period object with the time type\n         iType = PeriodType.standard();\n+        int[] values = ISOChronology.getInstanceUTC().get(DUMMY_PERIOD, duration);\n         iValues = new int[8];\n         System.arraycopy(values, 0, iValues, 4, 4);\n     }\n         return iType;\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the number of fields that this period supports.\n-     *\n-     * @return the number of fields supported\n-     */\n-    public int size() {\n-        return iType.size();\n-    }\n-\n-    /**\n-     * Gets the field type at the specified index.\n-     *\n-     * @param index  the index to retrieve\n-     * @return the field at the specified index\n-     * @throws IndexOutOfBoundsException if the index is invalid\n-     */\n-    public DurationFieldType getFieldType(int index) {\n-        return iType.getFieldType(index);\n-    }\n-\n     /**\n      * Gets the value at the specified index.\n      *\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether a field type is supported, and if so adds the new value\n-     * to the relevent index in the specified array.\n+     * to the relevant index in the specified array.\n      * \n      * @param type  the field type\n      * @param values  the array to update\n             int value = period.getValue(i);\n             checkAndUpdate(type, newValues, value);\n         }\n-        iValues = newValues;\n+        setValues(newValues);\n     }\n \n     /**\n      */\n     protected void setPeriod(int years, int months, int weeks, int days,\n                              int hours, int minutes, int seconds, int millis) {\n-        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n+        int[] newValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n+        setValues(newValues);\n     }\n \n     /**\n      * Private method called from constructor.\n      */\n-    private void setPeriodInternal(int years, int months, int weeks, int days,\n+    private int[] setPeriodInternal(int years, int months, int weeks, int days,\n                                    int hours, int minutes, int seconds, int millis) {\n         int[] newValues = new int[size()];\n         checkAndUpdate(DurationFieldType.years(), newValues, years);\n         checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n         checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n         checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n-        iValues = newValues;\n+        return newValues;\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     protected void mergePeriod(ReadablePeriod period) {\n         if (period != null) {\n-            iValues = mergePeriodInto(getValues(), period);\n+            setValues(mergePeriodInto(getValues(), period));\n         }\n     }\n \n      */\n     protected void addPeriod(ReadablePeriod period) {\n         if (period != null) {\n-            iValues = addPeriodInto(getValues(), period);\n+            setValues(addPeriodInto(getValues(), period));\n         }\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Sets the value of the field at the specifed index.\n+     * Sets the value of the field at the specified index.\n      * \n      * @param index  the index\n      * @param value  the value to set\n \n     /**\n      * Sets the values of all fields.\n+     * <p>\n+     * In version 2.0 and later, this method copies the array into the original.\n+     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      * \n      * @param values  the array of values\n      */\n     protected void setValues(int[] values) {\n-        iValues = values;\n+        System.arraycopy(values, 0, iValues, 0, iValues.length);\n     }\n \n }\n--- a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+++ b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n     private static final long serialVersionUID = 9386874258972L;\n \n     /** The period in the units of this period. */\n-    private int iPeriod;\n+    private final int iPeriod;\n \n     //-----------------------------------------------------------------------\n     /**\n     /**\n      * Sets the amount of this period.\n      * To make a subclass immutable you must declare it final, or block this method.\n+     * <p>\n+     * In version 2.0 and later, this method uses reflection. This is because the\n+     * instance variable has been changed to be final to satisfy the Java Memory Model.\n+     * This only impacts subclasses that are mutable.\n      *\n      * @param value  the period value\n      */\n     protected void setValue(int value) {\n-        iPeriod = value;\n+        MutableHelper.setSingleFieldPeriodValue(this, value);\n     }\n \n     //-----------------------------------------------------------------------\n--- /dev/null\n+++ b/src/main/java/org/joda/time/base/MutableHelper.java\n+/*\n+ *  Copyright 2001-2011 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.lang.reflect.Field;\n+\n+import org.joda.time.Chronology;\n+\n+/**\n+ * Helper to handle mutable classes that are hard to deal with now there is\n+ * the Java Memory Model.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ */\n+final class MutableHelper {\n+\n+    private static final Field DATE_TIME_MILLIS;\n+    private static final Field DATE_TIME_CHRONO;\n+    private static final Field DURATION_MILLIS;\n+    private static final Field SINGLE_FIELD_PERIOD;\n+    private static final Field INTERVAL_START;\n+    private static final Field INTERVAL_END;\n+    private static final Field INTERVAL_CHRONO;\n+    static {\n+        try {\n+            DATE_TIME_MILLIS = BaseDateTime.class.getDeclaredField(\"iMillis\");\n+            DATE_TIME_MILLIS.setAccessible(true);\n+            DATE_TIME_CHRONO = BaseDateTime.class.getDeclaredField(\"iChronology\");\n+            DATE_TIME_CHRONO.setAccessible(true);\n+            DURATION_MILLIS = BaseDuration.class.getDeclaredField(\"iMillis\");\n+            DURATION_MILLIS.setAccessible(true);\n+            SINGLE_FIELD_PERIOD = BaseSingleFieldPeriod.class.getDeclaredField(\"iPeriod\");\n+            SINGLE_FIELD_PERIOD.setAccessible(true);\n+            INTERVAL_START = BaseInterval.class.getDeclaredField(\"iStartMillis\");\n+            INTERVAL_START.setAccessible(true);\n+            INTERVAL_END = BaseInterval.class.getDeclaredField(\"iEndMillis\");\n+            INTERVAL_END.setAccessible(true);\n+            INTERVAL_CHRONO = BaseInterval.class.getDeclaredField(\"iChronology\");\n+            INTERVAL_CHRONO.setAccessible(true);\n+            \n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+    private MutableHelper() {\n+    }\n+\n+    static void setDateTimeMillis(BaseDateTime target, long instant) {\n+        try {\n+            DATE_TIME_MILLIS.set(target, instant);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+    static void setDateTimeChrono(BaseDateTime target, Chronology chrono) {\n+        try {\n+            DATE_TIME_CHRONO.set(target, chrono);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+    static void setDurationMillis(BaseDuration target, long duration) {\n+        try {\n+            DURATION_MILLIS.set(target, duration);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+    static void setSingleFieldPeriodValue(BaseSingleFieldPeriod target, int value) {\n+        try {\n+            SINGLE_FIELD_PERIOD.set(target, value);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+    static void setInterval(BaseInterval target, long startMillis, long endMillis, Chronology chrono) {\n+        try {\n+            INTERVAL_START.set(target, startMillis);\n+            INTERVAL_END.set(target, endMillis);\n+            INTERVAL_CHRONO.set(target, chrono);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Joda-Time mutable classes require reflection\", ex);\n+        }\n+    }\n+\n+}", "timestamp": 1308579304, "metainfo": ""}