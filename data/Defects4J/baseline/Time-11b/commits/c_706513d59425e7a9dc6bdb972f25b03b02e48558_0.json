{"sha": "706513d59425e7a9dc6bdb972f25b03b02e48558", "log": "Fix DateTimeFormatter.parseInto() [3522138]  Revert behaviour back to v1.x when parseInto month/day only", "commit": "\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.LocalDate;\n      * modified. To determine the position where the parse failed, apply the\n      * one's complement operator (~) on the return value.\n      * <p>\n+     * This parse method ignores the {@link #getDefaultYear() default year} and\n+     * parses using the year from the supplied instant as the default.\n+     * <p>\n      * The parse will use the chronology of the instant.\n      *\n      * @param instant  an instant that will be modified, not null\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n--- a/src/test/java/org/joda/time/format/TestDateTimeFormatter.java\n+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatter.java\n         assertEquals(expect, result);\n     }\n \n+    public void testParseInto_monthOnly() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n+        assertEquals(1, f.parseInto(result, \"5\", 0));\n+        assertEquals(new MutableDateTime(2004, 5, 9, 12, 20, 30, 0, LONDON), result);\n+    }\n+\n+    public void testParseInto_monthOnly_baseStartYear() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);\n+        assertEquals(1, f.parseInto(result, \"5\", 0));\n+        assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result);\n+    }\n+\n+    public void testParseInto_monthOnly_parseStartYear() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO);\n+        assertEquals(1, f.parseInto(result, \"1\", 0));\n+        assertEquals(new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO), result);\n+    }\n+\n+    public void testParseInto_monthOnly_baseEndYear() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO);\n+        assertEquals(1, f.parseInto(result, \"5\", 0));\n+        assertEquals(new MutableDateTime(2004, 5, 31, 12, 20, 30, 0, TOKYO), result);\n+   }\n+\n+    public void testParseInto_monthOnly_parseEndYear() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO);\n+        assertEquals(2, f.parseInto(result, \"12\", 0));\n+        assertEquals(new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO), result);\n+    }\n+\n+    public void testParseInto_monthDay_feb29() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n+        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n+        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n+        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n+    }\n+\n+    public void testParseInto_monthDay_withDefaultYear_feb29() {\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withDefaultYear(2012);\n+        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n+        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n+        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n+    }\n+\n     public void testParseMillis_fractionOfSecondLong() {\n         DateTimeFormatter f = new DateTimeFormatterBuilder()\n             .appendSecondOfDay(2).appendLiteral('.').appendFractionOfSecond(1, 9)", "timestamp": 1335784477, "metainfo": ""}