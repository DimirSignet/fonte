{"sha": "2492718480a58f036fd676b7fe0a150ddb8ea7ea", "log": "First version of LocalTime   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalTime is an immutable time class representing a time\n+ * without a time zone.\n+ * <p>\n+ * LocalTime implements the {@link ReadablePartial} interface.\n+ * To do this, the interface methods focus on the key fields -\n+ * HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.\n+ * However, <b>all</b> time fields may in fact be queried.\n+ * <p>\n+ * Calculations on LocalTime are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class LocalTime\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -12873158713873L;\n+\n+    /** The index of the hourOfDay field in the field array */\n+    private static final int HOUR_OF_DAY = 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    private static final int MINUTE_OF_HOUR = 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    private static final int SECOND_OF_MINUTE = 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    private static final int MILLIS_OF_SECOND = 3;\n+    /** Set of known duration types. */\n+    private static final Set TIME_DURATION_TYPES = new HashSet();\n+    static {\n+        TIME_DURATION_TYPES.add(DurationFieldType.millis());\n+        TIME_DURATION_TYPES.add(DurationFieldType.seconds());\n+        TIME_DURATION_TYPES.add(DurationFieldType.minutes());\n+        TIME_DURATION_TYPES.add(DurationFieldType.hours());\n+    }\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use in UTC */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public static LocalTime nowDefaultZone() {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalTime now(DateTimeZone zone) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology and zone.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalTime now(Chronology chronology) {\n+        return forInstant(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalTime from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalTime.\n+     * This is useful if you have been using the Calendar as a local time,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalTime with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalTime forFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalTime(\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalTime from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalTime.\n+     * This is useful if you have been using the Date as a local time,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method always creates a LocalTime with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalTime forFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalTime(\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (int) (date.getTime() % 1000)\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public static LocalTime forInstantDefaultZone(long instant) {\n+        return forInstant(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public static LocalTime forInstant(long instant, DateTimeZone zone) {\n+        return forInstant(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public static LocalTime forInstant(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        return new LocalTime(localMillis, chronology.withUTC());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object contains no time zone, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalTime forInstant(Object instant) {\n+        return forInstant(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalTime forInstant(Object instant, DateTimeZone zone) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = converter.getChronology(instant, zone);\n+        long millis = converter.getInstantMillis(instant, chrono);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public static LocalTime forInstant(Object instant, Chronology chronology) {\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = DateTimeUtils.getChronology(converter.getChronology(instant, chronology));\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        return forInstant(millis, chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified local (UTC) chronology.\n+     *\n+     * @param localMillis  the local milliseconds from 1970-01-01T00:00:00\n+     * @param chronology  the UTC chronology, not null\n+     */\n+    LocalTime(long localMillis, Chronology chronology) {\n+        super();\n+        chronology.millisOfDay().get(localMillis);\n+        iLocalMillis = localMillis;\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour) {\n+        this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute,\n+                millisOfSecond, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is four.\n+     * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute\n+     * and MillisOfSecond.\n+     *\n+     * @return the field count, four\n+     */\n+    public int size() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return chrono.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return chrono.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return chrono.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return chrono.millisOfSecond();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are HourOfDay, MinuteOfHour,\n+     * SecondOfMinute and MillisOfSecond.\n+     *\n+     * @param index  the index, zero to two\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return getChronology().hourOfDay().get(getLocalMillis());\n+            case MINUTE_OF_HOUR:\n+                return getChronology().minuteOfHour().get(getLocalMillis());\n+            case SECOND_OF_MINUTE:\n+                return getChronology().secondOfMinute().get(getLocalMillis());\n+            case MILLIS_OF_SECOND:\n+                return getChronology().millisOfSecond().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of time.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * DateTime dt = new DateTime();\n+     * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());\n+     * </pre>\n+     *\n+     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return fieldType.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local time and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        return isSupported(type.getDurationType());\n+    }\n+\n+    /**\n+     * Checks if the duration type specified is supported by this\n+     * local time and chronology.\n+     *\n+     * @param type  a duration type, usually obtained from DurationFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DurationField field = type.getField(getChronology());\n+        if (TIME_DURATION_TYPES.contains(type) ||\n+            field.getUnitMillis() < getChronology().days().getUnitMillis()) {\n+            return field.isSupported();\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the local milliseconds from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     */\n+    long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the time.\n+     * \n+     * @return the Chronology that the time is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalTime with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this time with different millis\n+     */\n+    LocalTime withLocalMillis(long newMillis) {\n+        return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalTime with the partial set of fields replacing\n+     * those from this instance.\n+     * <p>\n+     * For example, if the partial contains an hour and minute then those two\n+     * fields will be changed in the returned instance.\n+     * Unsupported fields are ignored.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this time, null ignored\n+     * @return a copy of this time with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalTime withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Gets a copy of this LocalTime with the specified field set\n+     * to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These lines are equivalent:\n+     * <pre>\n+     * LocalTime updated = dt.withHourOfDay(6);\n+     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this time with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public LocalTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this LocalTime with the value of the specified\n+     * field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code>\n+     * is returned.\n+     * <p>\n+     * If the addition causes the maximum value of the field to be exceeded,\n+     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.\n+     * <p>\n+     * These lines are equivalent:\n+     * <pre>\n+     * LocalTime added = dt.plusHours(6);\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this time with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalTime with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusHours(int)}.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this time with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalTime with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @return a copy of this time with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new LocalTime plus the specified number of hours.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusHours(6);\n+     * LocalTime added = dt.plus(Period.hours(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new LocalTime plus the increased hours\n+     */\n+    public LocalTime plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().add(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime plus the specified number of minutes.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusMinutes(6);\n+     * LocalTime added = dt.plus(Period.minutes(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new LocalTime plus the increased minutes\n+     */\n+    public LocalTime plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime plus the specified number of seconds.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusSeconds(6);\n+     * LocalTime added = dt.plus(Period.seconds(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new LocalTime plus the increased seconds\n+     */\n+    public LocalTime plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime plus the specified number of millis.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusMillis(6);\n+     * LocalTime added = dt.plus(Period.millis(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new LocalTime plus the increased millis\n+     */\n+    public LocalTime plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().add(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this LocalTime with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this time with the period taken away\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new LocalTime minus the specified number of hours.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusHours(6);\n+     * LocalTime subtracted = dt.minus(Period.hours(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new LocalTime minus the increased hours\n+     */\n+    public LocalTime minusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime minus the specified number of minutes.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusMinutes(6);\n+     * LocalTime subtracted = dt.minus(Period.minutes(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new LocalTime minus the increased minutes\n+     */\n+    public LocalTime minusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime minus the specified number of seconds.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusSeconds(6);\n+     * LocalTime subtracted = dt.minus(Period.seconds(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new LocalTime minus the increased seconds\n+     */\n+    public LocalTime minusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a new LocalTime minus the specified number of millis.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusMillis(6);\n+     * LocalTime subtracted = dt.minus(Period.millis(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new LocalTime minus the increased millis\n+     */\n+    public LocalTime minusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param fieldType  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return new Property(this, fieldType.getField(getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @param hour  the hour of day\n+     */\n+    public void withHourOfDay(int hour) {\n+        getChronology().hourOfDay().set(getLocalMillis(), hour);\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @param minute  the minute of hour\n+     */\n+    public void withMinuteOfHour(int minute) {\n+        getChronology().minuteOfHour().set(getLocalMillis(), minute);\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @param second  the second of minute\n+     */\n+    public void withSecondOfMinute(int second) {\n+        getChronology().secondOfMinute().set(getLocalMillis(), second);\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @param millis  the millis of second\n+     */\n+    public void withMillisOfSecond(int millis) {\n+        getChronology().millisOfSecond().set(getLocalMillis(), millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in ISO8601 format (HH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.time().print(this);\n+    }\n+\n+    /**\n+     * Output the time using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the time using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalTime.Property binds a LocalTime to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * LocalTime dt = new LocalTime(1972, 12, 3, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateTime - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * DateTime dt1920 = dt.year().setCopy(1920);\n+     * <p>\n+     * LocalTime.Propery itself is thread-safe and immutable, as well as the\n+     * LocalTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.2\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -325842547277223L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalTime iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+        \n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the time that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the LocalTime object linked to this property.\n+         * \n+         * @return the linked LocalTime\n+         */\n+        public LocalTime getLocalTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalTime.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime plus(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this LocalTime.\n+         * If the addition exceeds the maximum value (eg. 23:59) it will\n+         * wrap to the minimum value (eg. 00:00).\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime plus(long value) {\n+            // TODO\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalTime.\n+         * A field wrapped operation only changes this field.\n+         * Thus 10:59 plusWrapField one minute goes to 10:00.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime plusWrapField(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalTime.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime withValue(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalTime to a parsed text value.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalTime withValue(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalTime to a parsed text value.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalTime withValue(String text) {\n+            return withValue(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalTime with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalTime with this field set to its maximum\n+         */\n+        public LocalTime withMaximumValue() {\n+            return withValue(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalTime with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalTime with this field set to its minimum\n+         */\n+        public LocalTime withMinimumValue() {\n+            return withValue(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalTime\n+         * where the time is 10:30 would result in new LocalTime with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime withRoundedFloor() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalTime\n+         * where the time is 10:30 would result in new LocalTime with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime withRoundedCeiling() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime withRoundedHalfFloor() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime withRoundedHalfCeiling() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime withRoundedHalfEven() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}", "timestamp": 1137541717, "metainfo": ""}