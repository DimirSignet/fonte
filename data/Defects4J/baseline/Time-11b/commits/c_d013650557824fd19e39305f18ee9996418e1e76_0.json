{"sha": "d013650557824fd19e39305f18ee9996418e1e76", "log": "Create base subpackage   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.*;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.DurationConverter;\n import org.joda.time.field.FieldUtils;\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.*;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.IntervalConverter;\n import org.joda.time.field.FieldUtils;\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.*;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.IntervalConverter;\n import org.joda.time.field.FieldUtils;\n--- a/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n \n import java.io.Serializable;\n \n+import org.joda.time.base.*;\n+\n /**\n  * Standard mutable time period implementation.\n  * <p>\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n package org.joda.time;\n \n import java.io.Serializable;\n+\n+import org.joda.time.base.*;\n \n /**\n  * An immutable time period specifying a set of duration field values.\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n import java.io.Serializable;\n import java.util.Locale;\n \n+import org.joda.time.base.*;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.AbstractPartialFieldProperty;\n \n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n import java.io.Serializable;\n import java.util.Locale;\n \n+import org.joda.time.base.*;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.AbstractPartialFieldProperty;\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.Duration;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractDuration implements ReadableDuration {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDuration() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this duration as an immutable <code>Duration</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Duration</code>.\n+     * \n+     * @return a Duration created using the millisecond duration from this instance\n+     */\n+    public final Duration toDuration() {\n+        if (this instanceof Duration) {\n+            return (Duration) this;\n+        }\n+        return new Duration(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a Period instance using the All type.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * For AllType, this is the time fields only.\n+     * The year, month, week and day fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n+     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n+     * \n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public final Period toPeriod() {\n+        return new Period(getMillis());\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance specifying a period type\n+     * to control how the duration is split into fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * The period constructed will always be precise.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     * \n+     * @param type  the period type determining how to split the duration into fields, null means All type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public final Period toPeriod(PeriodType type) {\n+        return new Period(getMillis(), type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration based on length.\n+     *\n+     * @param obj  a duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     */\n+    public final int compareTo(Object obj) {\n+        // Comparable contract means we cannot handle null or other types gracefully\n+        ReadableDuration thisDuration = (ReadableDuration) this;\n+        ReadableDuration otherDuration = (ReadableDuration) obj;\n+        \n+        long thisMillis = thisDuration.getMillis();\n+        long otherMillis = otherDuration.getMillis();\n+        \n+        // cannot do (thisMillis - otherMillis) as it can overflow\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        }\n+        if (thisMillis > otherMillis) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public final boolean isEqual(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) == 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public final boolean isLongerThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) > 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public final boolean isShorterThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) < 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond length. All ReadableDuration instances are accepted.\n+     *\n+     * @param duration  a readable duration to check against\n+     * @return true if the length of the duration is equal\n+     */\n+    public final boolean equals(Object duration) {\n+        if (this == duration) {\n+            return true;\n+        }\n+        if (duration instanceof ReadableDuration == false) {\n+            return false;\n+        }\n+        ReadableDuration other = (ReadableDuration) duration;\n+        return (getMillis() == other.getMillis());\n+    }\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public final int hashCode() {\n+        long len = getMillis();\n+        return (int) (len ^ (len >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     * The field values are determined using {@link #toPeriod()}.\n+     * <p>\n+     * For more control over the output, see\n+     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public final String toString() {\n+        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.joda.time.Interval;\n+import org.joda.time.MutableInterval;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimePrinter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractInterval provides the common behaviour for time intervals.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInterval} interface should be used when different \n+ * kinds of intervals are to be referenced.\n+ * <p>\n+ * AbstractInterval subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractInterval implements ReadableInterval {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractInterval() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates an interval.\n+     * \n+     * @param start  the start instant in milliseconds\n+     * @param end  the end instant in milliseconds\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    protected void checkInterval(long start, long end) {\n+        if (end < start) {\n+            throw new IllegalArgumentException(\"The end instant must be greater or equal to the start\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this time interval, which is inclusive, as an Instant.\n+     *\n+     * @return the start of the time interval\n+     */\n+    public final Instant getStartInstant() {\n+        return new Instant(getStartMillis());\n+    }\n+\n+    /** \n+     * Gets the end of this time interval, which is exclusive, as an Instant.\n+     *\n+     * @return the end of the time interval\n+     */\n+    public final Instant getEndInstant() {\n+        return new Instant(getEndMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration of this time interval in milliseconds.\n+     * <p>\n+     * The duration is equal to the end millis minus the start millis.\n+     *\n+     * @return the duration of the time interval in milliseconds\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public final long getDurationMillis() {\n+        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n+    }\n+\n+    /**\n+     * Gets a <code>Duration</code> holding the millisecond duration of this time interval.\n+     *\n+     * @return the duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public final Duration getDuration() {\n+        long durMillis = getDurationMillis();\n+        if (durMillis == 0) {\n+            return Duration.ZERO;\n+        } else {\n+            return new Duration(durMillis);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified millisecond instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval contains the millisecond\n+     */\n+    public final boolean contains(long millisInstant) {\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        return (millisInstant >= thisStart && millisInstant < thisEnd);\n+    }\n+\n+    /**\n+     * Does this time interval contain the current instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @return true if this time interval contains the current instant\n+     */\n+    public final boolean containsNow() {\n+        return contains(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant, null means now\n+     * @return true if this time interval contains the instant\n+     */\n+    public final boolean contains(ReadableInstant instant) {\n+        if (instant == null) {\n+            return contains(DateTimeUtils.currentTimeMillis());\n+        }\n+        return contains(instant.getMillis());\n+    }\n+\n+    /**\n+     * Does this time interval contain the specified time interval completely.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if this time interval contains the time interval\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public final boolean contains(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"The time interval must not be null\");\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        return (otherStart >= thisStart && otherStart < thisEnd && otherEnd <= thisEnd);\n+    }\n+\n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * The intervals overlap if at least some of the time interval is in common.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the time interval to compare to\n+     * @return true if the time intervals overlap\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public final boolean overlaps(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"The time interval must not be null\");\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        return (thisStart < otherEnd && otherStart < thisEnd);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval before the specified millisecond instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is before the instant\n+     */\n+    public final boolean isBefore(long millisInstant) {\n+        return (getEndMillis() <= millisInstant);\n+    }\n+\n+    /**\n+     * Is this time interval before the current instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @return true if this time interval is before the current instant\n+     */\n+    public final boolean isBeforeNow() {\n+        return isBefore(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this time interval before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is before the instant\n+     */\n+    public final boolean isBefore(ReadableInstant instant) {\n+        if (instant == null) {\n+            return isBefore(DateTimeUtils.currentTimeMillis());\n+        }\n+        return isBefore(instant.getMillis());\n+    }\n+\n+    /**\n+     * Is this time interval after the specified millisecond instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is after the instant\n+     */\n+    public final boolean isAfter(long millisInstant) {\n+        return (getStartMillis() > millisInstant);\n+    }\n+\n+    /**\n+     * Is this time interval after the current instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @return true if this time interval is after the current instant\n+     */\n+    public final boolean isAfterNow() {\n+        return isAfter(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this time interval after the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is after the instant\n+     */\n+    public final boolean isAfter(ReadableInstant instant) {\n+        if (instant == null) {\n+            return isAfter(DateTimeUtils.currentTimeMillis());\n+        }\n+        return isAfter(instant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this interval as an immutable <code>Interval</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Interval</code>.\n+     *\n+     * @return the interval as an Interval object\n+     */\n+    public final Interval toInterval() {\n+        if (this instanceof Interval) {\n+            return (Interval) this;\n+        }\n+        return new Interval(getStartMillis(), getEndMillis());\n+    }\n+\n+    /**\n+     * Get this time interval as a <code>MutableInterval</code>.\n+     * <p>\n+     * This will always return a new <code>MutableInterval</code> with the same interval.\n+     *\n+     * @return the time interval as a MutableInterval object\n+     */\n+    public final MutableInterval toMutableInterval() {\n+        return new MutableInterval(getStartMillis(), getEndMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts the duration of the interval to a <code>Period</code> using the\n+     * All period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @return a time period derived from the interval\n+     */\n+    public final Period toPeriod() {\n+        return new Period(getStartMillis(), getEndMillis());\n+    }\n+\n+    /**\n+     * Converts the duration of the interval to a <code>Period</code> using the\n+     * specified period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     * The time period may not be precise - if you want the millisecond duration\n+     * then you should use {@link #getDuration()}.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    public final Period toPeriod(PeriodType type) {\n+        return new Period(getStartMillis(), getEndMillis(), type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on start and end millis. All ReadableInterval instances are accepted.\n+     * <p>\n+     * To compare the duration of two time intervals, use {@link #getDuration()}\n+     * to get the durations and compare those.\n+     *\n+     * @param readableInterval  a readable interval to check against\n+     * @return true if the start and end millis are equal\n+     */\n+    public final boolean equals(Object readableInterval) {\n+        if (this == readableInterval) {\n+            return true;\n+        }\n+        if (readableInterval instanceof ReadableInterval == false) {\n+            return false;\n+        }\n+        ReadableInterval other = (ReadableInterval) readableInterval;\n+        return (getStartMillis() == other.getStartMillis() &&\n+                getEndMillis() == other.getEndMillis());\n+    }\n+\n+    /**\n+     * Hashcode compatible with equals method.\n+     *\n+     * @return suitable hashcode\n+     */\n+    public final int hashCode() {\n+        long start = getStartMillis();\n+        long end = getEndMillis();\n+        int result = 97;\n+        result = 31 * result + ((int) (start ^ (start >>> 32)));\n+        result = 31 * result + ((int) (end ^ (end >>> 32)));\n+        return result;\n+    }\n+\n+    /**\n+     * Output a string in ISO8601 interval format.\n+     *\n+     * @return re-parsable string\n+     */\n+    public final String toString() {\n+        DateTimePrinter printer =\n+            ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())\n+            .dateHourMinuteSecondFraction();\n+        StringBuffer buf = new StringBuffer(48);\n+        printer.printTo(buf, getStartMillis());\n+        buf.append('/');\n+        printer.printTo(buf, getEndMillis());\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * AbstractPartial provides a standard base implementation of most methods\n+ * in the ReadablePartial interface.\n+ * <p>\n+ * Calculations on are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * AbstractPartial allows subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartial implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2353678632973660L;\n+\n+    /** The chronology in use */\n+    protected Chronology iChronology;\n+    /** The values of each field in this partial */\n+    protected int[] iValues;\n+    /** The values of each field in this partial */\n+    protected transient DateTimeField[] iFields;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a AbstractPartial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    protected AbstractPartial() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected AbstractPartial(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    protected AbstractPartial(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected AbstractPartial(long instant, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    protected AbstractPartial(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant);\n+        Chronology chronology = converter.getChronology(instant);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    protected AbstractPartial(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        chronology = converter.getChronology(instant, chronology);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param values  the new set of values\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected AbstractPartial(int[] values, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = values;\n+        chronology.validate(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Recreates the state of this object after deserialization.\n+     * \n+     * @param in  the input stream\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        iFields = initFields(iChronology);\n+    }\n+\n+    /**\n+     * Initialize the array of fields.\n+     * The field and value arrays must match.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract DateTimeField[] initFields(Chronology chrono);\n+\n+    /**\n+     * Initialize the array of values.\n+     * The field and value arrays must match.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract int[] initValues(long instant, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return iFields.length;\n+    }\n+\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        if (index < 0 || index >= iFields.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iFields[index];\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        if (index < 0 || index >= iValues.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        return (DateTimeField[]) iFields.clone();\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public int get(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return iValues[i];\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial set using the time zone specified.\n+     *\n+     * @param baseInstant  source of missing fields\n+     * @param zone  the time zone to use, null means default\n+     * @return the combined instant in milliseconds\n+     */\n+    public long resolve(long baseInstant, DateTimeZone zone) {\n+        Chronology chrono = iChronology.withZone(zone);\n+        return resolve(baseInstant, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    public DateTime resolveDateTime(ReadableInstant baseInstant) {\n+        long resolved;\n+        Chronology chrono;\n+        if (baseInstant == null) {\n+            chrono = ISOChronology.getInstance();\n+            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);\n+        } else {\n+            chrono = baseInstant.getChronology();\n+            resolved = resolve(baseInstant.getMillis(), chrono);\n+        }\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial into another complete instant setting the relevant\n+     * fields on the writable instant. The combination is performed using the\n+     * chronology of the specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the input writable\n+     * instant will be updated with the time from this partial.\n+     *\n+     * @param baseInstant  the instant to set into, must not be null\n+     * @throws IllegalArgumentException if the base instant is null\n+     */\n+    public void resolveInto(ReadWritableInstant baseInstant) {\n+        if (baseInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        Chronology chrono = baseInstant.getChronology();\n+        long resolved = resolve(baseInstant.getMillis(), chrono);\n+        baseInstant.setMillis(resolved);\n+    }\n+\n+    /**\n+     * Resolve this partial into the base millis using the specified chronology.\n+     * \n+     * @param baseInstant  the base millisecond instant\n+     * @param chrono  the chronology\n+     * @return the new resolved millis\n+     */\n+    protected long resolve(long baseInstant, Chronology chrono) {\n+        long millis = baseInstant;\n+        for (int i = 0; i < iFields.length; i++) {\n+            millis = iFields[i].set(millis, iValues[i]);\n+        }\n+        return millis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * fields and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        if (partial instanceof AbstractPartial) {\n+            AbstractPartial other = (AbstractPartial) partial;\n+            return Arrays.equals(iValues, other.iValues) &&\n+                   Arrays.equals(iFields, other.iFields) &&\n+                   iChronology == other.iChronology;\n+        } else if (partial instanceof ReadablePartial) {\n+            ReadablePartial other = (ReadablePartial) partial;\n+            return Arrays.equals(iValues, other.getValues()) &&\n+                   Arrays.equals(iFields, other.getFields()) &&\n+                   iChronology == other.getChronology();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the ReadablePartial that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int total = 157;\n+        for (int i = 0; i < iFields.length; i++) {\n+            total = 23 * total + iValues[i];\n+            total = 23 * total + iFields[i].hashCode();\n+        }\n+        total += iChronology.hashCode();\n+        return total;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.DurationField;\n+import org.joda.time.Instant;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PeriodConverter;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+    /** Millis cache is currently unknown */\n+    private static final int STATE_UNKNOWN = 0;\n+    /** Millis cache is not calculable */\n+    private static final int STATE_NOT_CALCULABLE = 1;\n+    /** Millis cache has been calculated and is valid */\n+    private static final int STATE_CALCULATED = 2;\n+\n+    /** The period type that allocates the duration to fields */\n+    private final PeriodType iType;\n+    /** The object state */\n+    private transient int iState;\n+    /** The duration, if known */\n+    private transient long iDuration;\n+    /** Value for years */\n+    private int iYears;\n+    /** Value for months */\n+    private int iMonths;\n+    /** Value for weeks */\n+    private int iWeeks;\n+    /** Value for days */\n+    private int iDays;\n+    /** Value for hours */\n+    private int iHours;\n+    /** Value for minutes */\n+    private int iMinutes;\n+    /** Value for seconds */\n+    private int iSeconds;\n+    /** Value for millis */\n+    private int iMillis;\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * The millisecond duration will be split to fields using a UTC version of\n+     * the period type.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected AbstractPeriod(long duration, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, duration);\n+    }\n+\n+    /**\n+     * Creates a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected AbstractPeriod(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected AbstractPeriod(long startInstant, long endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        // Only call a private method\n+        setPeriod(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected AbstractPeriod(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n+            // Only call a private method\n+            setPeriod(type, start, end);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new period based on another using the {@link ConverterManager}.\n+     *\n+     * @param period  the period to convert\n+     * @param type  which set of fields this period supports, null means use type from object\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected AbstractPeriod(Object period, PeriodType type) {\n+        super();\n+        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n+        type = (type == null ? converter.getPeriodType(period, false) : type);\n+        type = checkPeriodType(type);\n+        iType = type;\n+        if (this instanceof ReadWritablePeriod) {\n+            converter.setInto((ReadWritablePeriod) this, period);\n+        } else {\n+            // Only call a private method\n+            setPeriod(type, new MutablePeriod(period, type));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is invalid\n+     */\n+    protected abstract PeriodType checkPeriodType(PeriodType type);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the object which defines which fields this period supports.\n+     */\n+    public final PeriodType getPeriodType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Is this period a precise length of time, or descriptive.\n+     * <p>\n+     * A typical precise period could include millis, seconds, minutes or hours,\n+     * but days, weeks, months and years usually vary in length, resulting in\n+     * an imprecise period.\n+     * <p>\n+     * An imprecise period can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the period is precise\n+     */\n+    public final boolean isPrecise() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        return (state == STATE_CALCULATED);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this period to the given instant using the chronology of the period\n+     * which typically ignores time zones.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar) {\n+        return addTo(instant, scalar, null);\n+    }\n+\n+    /**\n+     * Adds this period to the given instant using a specific chronology.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * period to\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @param chrono  override the period's chronology, unless null is passed in\n+     * @return milliseconds value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar, Chronology chrono) {\n+        if (isPrecise()) {\n+            return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n+        }\n+        \n+        PeriodType type = iType;\n+        if (chrono != null) {\n+            type = type.withChronology(chrono);\n+        }\n+        \n+        long value; // used to lock fields against threading issues\n+        value = scaleValue(iYears, scalar);\n+        if (value != 0) {\n+            instant = type.years().add(instant, value);\n+        }\n+        value = scaleValue(iMonths, scalar);\n+        if (value != 0) {\n+            instant = type.months().add(instant, value);\n+        }\n+        value = scaleValue(iWeeks, scalar);\n+        if (value != 0) {\n+            instant = type.weeks().add(instant, value);\n+        }\n+        value = scaleValue(iDays, scalar);\n+        if (value != 0) {\n+            instant = type.days().add(instant, value);\n+        }\n+        value = scaleValue(iHours, scalar);\n+        if (value != 0) {\n+            instant = type.hours().add(instant, value);\n+        }\n+        value = scaleValue(iMinutes, scalar);\n+        if (value != 0) {\n+            instant = type.minutes().add(instant, value);\n+        }\n+        value = scaleValue(iSeconds, scalar);\n+        if (value != 0) {\n+            instant = type.seconds().add(instant, value);\n+        }\n+        value = scaleValue(iMillis, scalar);\n+        if (value != 0) {\n+            instant = type.millis().add(instant, value);\n+        }\n+\n+        return instant;\n+    }\n+\n+    /**\n+     * Convert the scalar to a multiple efficiently.\n+     * \n+     * @param value  the value\n+     * @param scalar  the scalar\n+     * @return the converted value\n+     */\n+    private static long scaleValue(int value, int scalar) {\n+        long val = value;  // use long to avoid truncation\n+        switch (scalar) {\n+        case -1:\n+            return -val;\n+        case 0:\n+            return 0;\n+        case 1:\n+            return val;\n+        default:\n+            return val * scalar;\n+        }\n+    }\n+\n+    /**\n+     * Adds this period to the given instant using the chronology of the specified\n+     * instant (if present), returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to add the period to, null means now\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @return instant with the original value plus this period times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final Instant addTo(ReadableInstant instant, int scalar) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant, null);\n+        return new Instant(addTo(instantMillis, scalar, chrono));\n+    }\n+\n+    /**\n+     * Adds this period into the given mutable instant using the chronology of\n+     * the specified mutable instant (if present).\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scalar of minus one.\n+     *\n+     * @param instant  the instant to update with the added period, must not be null\n+     * @param scalar  the number of times to add the period, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final void addInto(ReadWritableInstant instant, int scalar) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        instant.setMillis(addTo(instant.getMillis(), scalar, instant.getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public final int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public final int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public final int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public final int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public final int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public final int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public final int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public final int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Period</code>.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    public final Period toPeriod() {\n+        if (this instanceof Period) {\n+            return (Period) this;\n+        }\n+        return new Period(this);\n+    }\n+\n+    /**\n+     * Get this object as a <code>MutablePeriod</code>.\n+     * <p>\n+     * This will always return a new <code>MutablePeriod</code> with the same fields.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    public final MutablePeriod toMutablePeriod() {\n+        return new MutablePeriod(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final long toDurationMillis() {\n+        int state = iState;\n+        if (state == STATE_UNKNOWN) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != STATE_CALCULATED) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iDuration;\n+    }\n+\n+    /**\n+     * Gets the total millisecond duration of this period,\n+     * failing if the period is imprecise.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     * @throws IllegalStateException if the period is imprecise\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public final Duration toDuration() {\n+        return new Duration(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadablePeriod instances are accepted.\n+     * <p>\n+     * To compare two periods for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     *\n+     * @param readablePeriod  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public final boolean equals(Object readablePeriod) {\n+        if (this == readablePeriod) {\n+            return true;\n+        }\n+        if (readablePeriod instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) readablePeriod;\n+        PeriodType type = getPeriodType();\n+        if (type.equals(other.getPeriodType()) == false) {\n+            return false;\n+        }\n+        return getYears() == other.getYears()\n+            && getMonths() == other.getMonths()\n+            && getWeeks() == other.getWeeks()\n+            && getDays() == other.getDays()\n+            && getHours() == other.getHours()\n+            && getMinutes() == other.getMinutes()\n+            && getSeconds() == other.getSeconds()\n+            && getMillis() == other.getMillis();\n+    }\n+\n+    /**\n+     * Gets a hash code for the period that is compatible with the \n+     * equals method. The hashcode is the period type hashcode plus\n+     * each period value from largest to smallest calculated as follows:\n+     *\n+     * @return a hash code\n+     */\n+    public final int hashCode() {\n+        int hash = getPeriodType().hashCode();\n+        hash = 53 * hash + getYears();\n+        hash = 53 * hash + getMonths();\n+        hash = 53 * hash + getWeeks();\n+        hash = 53 * hash + getDays();\n+        hash = 53 * hash + getHours();\n+        hash = 53 * hash + getMinutes();\n+        hash = 53 * hash + getSeconds();\n+        hash = 53 * hash + getMillis();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     * <p>\n+     * For more control over the output, see\n+     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return ISOPeriodFormat.getInstance().standard().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkSupport(DurationField field) {\n+        if (!field.isSupported()) {\n+            throw new UnsupportedOperationException\n+                (\"Time period does not support field '\" + field.getName() + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(ReadablePeriod period) {\n+        if (period == null) {\n+            setPeriod(iType, 0L);\n+        } else {\n+            setPeriod(iType, period);\n+        }\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type, ReadablePeriod period) {\n+        setPeriod(type,\n+            period.getYears(), period.getMonths(),\n+            period.getWeeks(), period.getDays(),\n+            period.getHours(), period.getMinutes(),\n+            period.getSeconds(), period.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(int years, int months, int weeks, int days,\n+                               int hours, int minutes, int seconds, int millis) {\n+        setPeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setPeriod(PeriodType type,\n+                             int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+        if (years != 0) {\n+            checkArgument(type.years());\n+        }\n+        if (months != 0) {\n+            checkArgument(type.months());\n+        }\n+        if (weeks != 0) {\n+            checkArgument(type.weeks());\n+        }\n+        if (days != 0) {\n+            checkArgument(type.days());\n+        }\n+        if (hours != 0) {\n+            checkArgument(type.hours());\n+        }\n+        if (minutes != 0) {\n+            checkArgument(type.minutes());\n+        }\n+        if (seconds != 0) {\n+            checkArgument(type.seconds());\n+        }\n+        if (millis != 0) {\n+            checkArgument(type.millis());\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    protected void setPeriod(long startInstant, long endInstant) {\n+        setPeriod(iType, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long startInstant, long endInstant) {\n+        long baseTotalMillis = (endInstant - startInstant);\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        field = type.years();\n+        if (field.isSupported()) {\n+            years = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported()) {\n+            months = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported()) {\n+            weeks = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported()) {\n+            days = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported()) {\n+            hours = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported()) {\n+            minutes = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported()) {\n+            seconds = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported()) {\n+            millis = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    protected void setPeriod(long duration) {\n+        setPeriod(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    private void setPeriod(PeriodType type, long duration) {\n+        if (duration == 0) {\n+            iDuration = duration;\n+            iYears = 0;\n+            iMonths = 0;\n+            iWeeks = 0;\n+            iDays = 0;\n+            iHours = 0;\n+            iMinutes = 0;\n+            iSeconds = 0;\n+            iMillis = 0;\n+            iState = STATE_CALCULATED;\n+            return;\n+        }\n+        \n+        long startInstant = 0;\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n+        DurationField field;\n+        \n+        field = type.years();\n+        if (field.isSupported() && field.isPrecise()) {\n+            years = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported() && field.isPrecise()) {\n+            months = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported() && field.isPrecise()) {\n+            weeks = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported() && field.isPrecise()) {\n+            days = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported() && field.isPrecise()) {\n+            hours = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported() && field.isPrecise()) {\n+            minutes = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported() && field.isPrecise()) {\n+            seconds = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported() && field.isPrecise()) {\n+            millis = field.getDifference(duration, startInstant);\n+            startInstant = field.add(startInstant, millis);\n+        }\n+        \n+        // assign fields in one block to reduce threading issues\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n+        iState = STATE_UNKNOWN;\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    protected void setPeriod(ReadableInterval interval) {\n+        if (interval != null) {\n+            setPeriod(interval.getStartMillis(), interval.getEndMillis());\n+        } else {\n+            setPeriod(0L);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     */\n+    protected void setPeriod(ReadableDuration duration) {\n+        if (duration != null) {\n+            setPeriod(duration.getMillis());\n+        } else {\n+            setPeriod(0L);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this period is precise.\n+     *\n+     * @return new state\n+     * @throws ArithmeticException if the millis exceeds the capacity of the period\n+     */\n+    private int updateTotalMillis() {\n+        final PeriodType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n+        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n+        if (years != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            }\n+        }\n+        if (months != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            }\n+        }\n+        if (weeks != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n+            }\n+        }\n+        if (days != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n+            }\n+        }\n+        if (hours != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n+            }\n+        }\n+        if (minutes != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n+            }\n+        }\n+        if (seconds != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n+            }\n+        }\n+        if (millis != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n+            }\n+        }\n+        \n+        iDuration = totalMillis;\n+        if (isPrecise) {\n+            return iState = STATE_CALCULATED;\n+        } else {\n+            return iState = STATE_NOT_CALCULABLE;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadablePeriod period) {\n+        if (period != null) {\n+            setPeriod(\n+                FieldUtils.safeAdd(getYears(), period.getYears()),\n+                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n+                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n+                FieldUtils.safeAdd(getDays(), period.getDays()),\n+                FieldUtils.safeAdd(getHours(), period.getHours()),\n+                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n+                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n+                FieldUtils.safeAdd(getMillis(), period.getMillis())\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis) {\n+        setPeriod(\n+            FieldUtils.safeAdd(getYears(), years),\n+            FieldUtils.safeAdd(getMonths(), months),\n+            FieldUtils.safeAdd(getWeeks(), weeks),\n+            FieldUtils.safeAdd(getDays(), days),\n+            FieldUtils.safeAdd(getHours(), hours),\n+            FieldUtils.safeAdd(getMinutes(), minutes),\n+            FieldUtils.safeAdd(getSeconds(), seconds),\n+            FieldUtils.safeAdd(getMillis(), millis)\n+        );\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableInterval interval) {\n+        if (interval != null) {\n+            add(interval.toPeriod(getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(ReadableDuration duration) {\n+        if (duration != null) {\n+            add(new Period(duration.getMillis(), getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void add(long duration) {\n+        add(new Period(duration, getPeriodType()));\n+    }\n+\n+    /**\n+     * Normalizes all the field values in this period.\n+     * <p>\n+     * This method converts to a milliecond duration and back again.\n+     *\n+     * @throws IllegalStateException if this period is imprecise\n+     */\n+    protected void normalize() {\n+        setPeriod(toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setYears(int years) {\n+        if (years != iYears) {\n+            if (years != 0) {\n+                checkSupport(iType.years());\n+            }\n+            iYears = years;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addYears(int years) {\n+        if (years != 0) {\n+            setYears(FieldUtils.safeAdd(getYears(), years));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMonths(int months) {\n+        if (months != iMonths) {\n+            if (months != 0) {\n+                checkSupport(iType.months());\n+            }\n+            iMonths = months;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMonths(int months) {\n+        if (months != 0) {\n+            setMonths(FieldUtils.safeAdd(getMonths(), months));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setWeeks(int weeks) {\n+        if (weeks != iWeeks) {\n+            if (weeks != 0) {\n+                checkSupport(iType.weeks());\n+            }\n+            iWeeks = weeks;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addWeeks(int weeks) {\n+        if (weeks != 0) {\n+            setWeeks(FieldUtils.safeAdd(getWeeks(), weeks));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setDays(int days) {\n+        if (days != iDays) {\n+            if (days != 0) {\n+                checkSupport(iType.days());\n+            }\n+            iDays = days;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addDays(int days) {\n+        if (days != 0) {\n+            setDays(FieldUtils.safeAdd(getDays(), days));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setHours(int hours) {\n+        if (hours != iHours) {\n+            if (hours != 0) {\n+                checkSupport(iType.hours());\n+            }\n+            iHours = hours;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addHours(int hours) {\n+        if (hours != 0) {\n+            setHours(FieldUtils.safeAdd(getHours(), hours));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMinutes(int minutes) {\n+        if (minutes != iMinutes) {\n+            if (minutes != 0) {\n+                checkSupport(iType.minutes());\n+            }\n+            iMinutes = minutes;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMinutes(int minutes) {\n+        if (minutes != 0) {\n+            setMinutes(FieldUtils.safeAdd(getMinutes(), minutes));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setSeconds(int seconds) {\n+        if (seconds != iSeconds) {\n+            if (seconds != 0) {\n+                checkSupport(iType.seconds());\n+            }\n+            iSeconds = seconds;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addSeconds(int seconds) {\n+        if (seconds != 0) {\n+            setSeconds(FieldUtils.safeAdd(getSeconds(), seconds));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     */\n+    protected void setMillis(int millis) {\n+        if (millis != iMillis) {\n+            if (millis != 0) {\n+                checkSupport(iType.millis());\n+            }\n+            iMillis = millis;\n+            iState = STATE_UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws UnsupportedOperationException if field is not supported\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    protected void addMillis(int millis) {\n+        if (millis != 0) {\n+            setMillis(FieldUtils.safeAdd(getMillis(), millis));\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractDuration;\n \n /**\n  * This class is a Junit unit test for Duration.\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractInterval;\n \n /**\n  * This class is a Junit unit test for Instant.\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractInterval;\n \n /**\n  * This class is a Junit unit test for Instant.\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Updates.java\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractInterval;\n \n /**\n  * This class is a Junit unit test for Instant.\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n import java.util.Locale;\n import java.util.TimeZone;\n \n-import org.joda.time.chrono.ISOChronology;\n-\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractPeriod;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for MutableDuration.\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n import java.util.Locale;\n import java.util.TimeZone;\n \n-import org.joda.time.chrono.ISOChronology;\n-\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import org.joda.time.base.AbstractPeriod;\n+import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a Junit unit test for Duration.", "timestamp": 1093041091, "metainfo": ""}