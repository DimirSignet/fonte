{"sha": "b9978566282eb4278d4c4018e2030c14372965d9", "log": "Bug fix setting default zone if DST is off.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import java.util.Map;\n import java.util.Set;\n \n+import org.joda.time.chrono.BaseChronology;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeFormatter;\n         setProvider0(null);\n         setNameProvider0(null);\n \n-        // Because of the cyclic initializer dependencies between many of the\n-        // main classes, and because cOffsetFormatter is built from those main\n-        // classes, a user time zone with an explicit offset fails. Rather than\n-        // duplicate all the code used by DateTimeFormatterBuilder's offset\n-        // formatter, DateTimeFormatterBuilder's constructor tests if\n-        // DateTimeZone.getDefault() is null, in which case it allows the\n-        // chronology to be null. This breaks the dependency cycle and allows\n-        // cOffsetFormatter to be defined. In order for this inelegant solution\n-        // to work propery, cDefault must be left as null until after an\n-        // attempt has been made to set the user time zone.\n-\n         try {\n             try {\n                 cDefault = getInstance(System.getProperty(\"user.timezone\"));\n             return zone;\n         }\n         if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n-            // Pass in explicit chronology since default time zone may not yet be initialized.\n-            int offset = -(int) offsetFormatter().parseMillis(id, ISOChronology.getInstance(UTC));\n+            int offset = parseOffset(id);\n             if (offset == 0L) {\n                 return DateTimeZone.UTC;\n             } else {\n                 StringBuffer buf = new StringBuffer();\n-                id = printTimeZone(offset);\n+                id = printOffset(offset);\n                 return fixedOffsetZone(id, offset);\n             }\n         }\n         } catch (ArithmeticException ex) {\n             throw new IllegalArgumentException(\"Offset is too large\");\n         }\n-        String id = printTimeZone(offset);\n+        String id = printOffset(offset);\n         return fixedOffsetZone(id, offset);\n     }\n \n             convId = zone.getDisplayName();\n             if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                 convId = convId.substring(3);\n-                // Pass in explicit chronology since default time zone may not yet be initialized.\n-                int offset = -(int) offsetFormatter().parseMillis\n-                    (convId, ISOChronology.getInstance(UTC));\n+                int offset = parseOffset(convId);\n                 if (offset == 0L) {\n                     return DateTimeZone.UTC;\n                 } else {\n-                    convId = printTimeZone(offset);\n+                    convId = printOffset(offset);\n                     return fixedOffsetZone(convId, offset);\n                 }\n             }\n         return (String) map.get(id);\n     }\n \n-    /**\n-     * Gets a printer/parser for managing the offset id formatting.\n-     * \n-     * @return the formatter\n-     */\n-    private static synchronized DateTimeFormatter offsetFormatter() {\n-        if (cOffsetFormatter == null) {\n-            cOffsetFormatter = new DateTimeFormatterBuilder()\n-                .appendTimeZoneOffset(null, true, 2, 4)\n-                .toFormatter();\n-        }\n-        return cOffsetFormatter;\n+    private static int parseOffset(String str) {\n+        Chronology chrono;\n+        if (cDefault != null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        } else {\n+            // Can't use a real chronology if called during class\n+            // initialization. Offset parser doesn't need it anyhow.\n+            chrono = new BaseChronology() {\n+                public DateTimeZone getZone() {\n+                    return null;\n+                }\n+                public Chronology withUTC() {\n+                    return this;\n+                }\n+                public Chronology withZone(DateTimeZone zone) {\n+                    return this;\n+                }\n+                public String toString() {\n+                    return getClass().getName();\n+                }\n+            };\n+        }\n+\n+        return -(int) offsetFormatter().parseMillis(str, chrono);\n     }\n \n     /**\n      * Formats a timezone offset string.\n      * <p>\n-     * This method is kept separate from the formatting classe to speed and\n+     * This method is kept separate from the formatting classes to speed and\n      * simplify startup and classloading.\n      * \n      * @param offset  the offset in milliseconds\n      * @return the time zone string\n      */\n-    private static String printTimeZone(int offset) {\n+    private static String printOffset(int offset) {\n         StringBuffer buf = new StringBuffer();\n         if (offset >= 0) {\n             buf.append('+');\n         return buf.toString();\n     }\n \n+    /**\n+     * Gets a printer/parser for managing the offset id formatting.\n+     * \n+     * @return the formatter\n+     */\n+    private static synchronized DateTimeFormatter offsetFormatter() {\n+        if (cOffsetFormatter == null) {\n+            cOffsetFormatter = new DateTimeFormatterBuilder()\n+                .appendTimeZoneOffset(null, true, 2, 4)\n+                .toFormatter();\n+        }\n+        return cOffsetFormatter;\n+    }\n+\n     // Instance fields and methods\n     //--------------------------------------------------------------------\n \n         if (name != null) {\n             return name;\n         }\n-        return printTimeZone(getOffset(instant));\n+        return printOffset(getOffset(instant));\n     }\n \n     /**\n         if (name != null) {\n             return name;\n         }\n-        return printTimeZone(getOffset(instant));\n+        return printOffset(getOffset(instant));\n     }\n \n     /**", "timestamp": 1102802006, "metainfo": ""}