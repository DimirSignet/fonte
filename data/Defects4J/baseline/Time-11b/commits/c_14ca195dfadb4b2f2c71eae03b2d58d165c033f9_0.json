{"sha": "14ca195dfadb4b2f2c71eae03b2d58d165c033f9", "log": "Move code from BasePeriod to chrono   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param startInstant  the start instant of an interval to query\n+     * @param endInstant  the start instant of an interval to query\n+     * @return the values of the period extracted from the interval\n+     */\n+    public abstract int[] get(ReadablePeriod period, long startInstant, long endInstant);\n+\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param duration  the duration to query\n+     * @return the values of the period extracted from the duration\n+     */\n+    public abstract int[] get(ReadablePeriod period, long duration);\n+\n+    /**\n      * Adds the period to the instant, specifying the number of times to add.\n      *\n+     * @param period  the period to add, null means add nothing\n      * @param instant  the instant to add to\n-     * @param period  the period to add, null means add nothing\n      * @param scalar  the number of times to add\n      * @return the updated instant\n      */\n-    public abstract long add(long instant, ReadablePeriod period, int scalar);\n+    public abstract long add(ReadablePeriod period, long instant, int scalar);\n \n     // Millis\n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n         if (period == null || scalar == 0) {\n             return this;\n         }\n-        long instant = getChronology().add(getMillis(), period, scalar);\n+        long instant = getChronology().add(period, getMillis(), scalar);\n         return withMillis(instant);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the chronology from the specified instant based interval handling null.\n+     * <p>\n+     * The chronology is obtained from the start if that is not null, or from the\n+     * end if the start is null. The result is additionally checked, and if still\n+     * null then {@link ISOChronology#getInstance()} will be returned.\n+     * \n+     * @param start  the instant to examine and use as the primary source of the chronology\n+     * @param end  the instant to examine and use as the secondary source of the chronology\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {\n+        Chronology chrono = null;\n+        if (start != null) {\n+            chrono = start.getChronology();\n+        } else if (end != null) {\n+            chrono = end.getChronology();\n+        }\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology from the specified interval object handling null.\n+     * <p>\n+     * If the interval object is <code>null</code>, or the interval's chronology is\n+     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n+     * Otherwise, the chronology from the object is returned.\n+     * \n+     * @param interval  the interval to examine, null means ISO in the default zone\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getIntervalChronology(ReadableInterval interval) {\n+        if (interval == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        Chronology chrono = interval.getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets the chronology handling null.\n      * <p>\n      * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      */\n     public void add(ReadablePeriod period, int scalar) {\n         if (period != null) {\n-            setMillis(getChronology().add(getMillis(), period, scalar));  // set via this class not super\n+            setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n         if (period == null) {\n             setEndMillis(getStartMillis());\n         } else {\n-            setEndMillis(getChronology().add(getStartMillis(), period, 1));\n+            setEndMillis(getChronology().add(period, getStartMillis(), 1));\n         }\n     }\n \n         if (period == null) {\n             setStartMillis(getEndMillis());\n         } else {\n-            setStartMillis(getChronology().add(getEndMillis(), period, -1));\n+            setStartMillis(getChronology().add(period, getEndMillis(), -1));\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n     /**\n      * Creates a period from the given interval endpoints using the standard\n      * set of fields.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n \n     /**\n      * Creates a period from the given interval endpoints.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of one of the fields by index.\n+     *\n+     * @param index  the field index\n+     * @param value  the new value for the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public void setValue(int index, int value) {\n+        super.setValue(index, value);\n+    }\n+\n     /**\n      * Sets the value of one of the fields.\n      * <p>\n      * and dividing the fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(ReadableInterval interval) {\n-        setPeriod(interval, null);\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from an interval dividing the\n-     * fields using the period type.\n-     * \n-     * @param interval  the interval to set, null means zero length\n-     * @param chrono  the chronology to use, null means ISO default\n-     */\n-    public void setPeriod(ReadableInterval interval, Chronology chrono) {\n         if (interval == null) {\n             setPeriod(0L);\n         } else {\n+            Chronology chrono = DateTimeUtils.getChronology(interval.getChronology());\n             setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);\n         }\n     }\n \n     /**\n-     * Sets all the fields in one go from two instants using\n-     * the ISO chronology and dividing the fields using the period type.\n+     * Sets all the fields in one go from two instants representing an interval.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n      * \n      * @param start  the start instant, null means now\n      * @param end  the end instant, null means now\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(ReadableInstant start, ReadableInstant end) {\n-        setPeriod(start, end, null);\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from two instants using\n-     * the specified chronology and dividing the fields using the period type.\n-     * \n-     * @param start  the start instant, null means now\n-     * @param end  the end instant, null means now\n-     * @param chrono  the chronology to use, null means ISO default\n-     */\n-    public void setPeriod(ReadableInstant start, ReadableInstant end, Chronology chrono) {\n         if (start == end) {\n             setPeriod(0L);\n         } else {\n             long startMillis = DateTimeUtils.getInstantMillis(start);\n             long endMillis = DateTimeUtils.getInstantMillis(end);\n-            setPeriod(start, end, chrono);\n+            Chronology chrono = DateTimeUtils.getIntervalChronology(start, end);\n+            setPeriod(startMillis, endMillis, chrono);\n         }\n     }\n \n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(long startInstant, long endInstant) {\n         setPeriod(startInstant, endInstant, null);\n     }\n \n     /**\n-     * Sets all the fields in one go from a millisecond interval dividing the\n-     * fields using the period type.\n+     * Sets all the fields in one go from a millisecond interval.\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param chrono  the chronology to use, null means ISO default\n+     * @param chrono  the chronology to use, not null\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n-        super.setPeriod(startInstant, endInstant, chrono);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        setValues(chrono.get(this, startInstant, endInstant));\n     }\n \n     /**\n      * available precise field.\n      * \n      * @param duration  the duration to set, null means zero length\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(ReadableDuration duration) {\n         setPeriod(duration, null);\n      * \n      * @param duration  the duration to set, null means zero length\n      * @param chrono  the chronology to use, null means ISO default\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(ReadableDuration duration, Chronology chrono) {\n         long durationMillis = DateTimeUtils.getDurationMillis(duration);\n      * available precise field.\n      * \n      * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(long duration) {\n         setPeriod(duration, null);\n     }\n \n     /**\n-     * Sets all the fields in one go from a millisecond duration dividing the\n-     * fields using the period type.\n+     * Sets all the fields in one go from a millisecond duration.\n      * <p>\n      * When dividing the duration, only precise fields in the period type will be used.\n      * For large durations, all the remaining duration will be stored in the largest\n      * available precise field.\n      * \n      * @param duration  the duration, in milliseconds\n-     * @param chrono  the chronology to use, null means ISO default\n+     * @param chrono  the chronology to use, not null\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n      */\n     public void setPeriod(long duration, Chronology chrono) {\n-        super.setPeriod(duration, chrono);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        setValues(chrono.get(this, duration));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n public interface ReadWritablePeriod extends ReadablePeriod {\n \n     /**\n+     * Sets the value of one of the fields by index.\n+     *\n+     * @param index  the field index\n+     * @param value  the new value for the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    void setValue(int index, int value);\n+\n+    /**\n      * Sets the value of one of the fields.\n      * <p>\n      * The field type specified must be one of those that is supported by the period.\n      * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n-     * @param chrono  the chronology to use, null means ISO default\n-     */\n-    void setPeriod(ReadableInterval interval, Chronology chrono);\n-\n-    /**\n-     * Sets all the fields in one go from a duration dividing the\n-     * fields using the period type.\n-     * <p>\n-     * When dividing the duration, only precise fields in the period type will be used.\n-     * For large durations, all the remaining duration will be stored in the largest\n-     * available precise field.\n-     * \n-     * @param duration  the duration to set, null means zero length\n-     * @param chrono  the chronology to use, null means ISO default\n-     */\n-    void setPeriod(ReadableDuration duration, Chronology chrono);\n+     */\n+    void setPeriod(ReadableInterval interval);\n \n     //-----------------------------------------------------------------------\n     /**\n      */\n     void add(ReadableInterval interval);\n \n-    /**\n-     * Adds a duration to this one by dividing the duration into\n-     * fields and then adding each field in turn.\n-     * <p>\n-     * When dividing the duration, only precise fields in the period type will be used.\n-     * For large durations, all the remaining duration will be added to the largest\n-     * available precise field.\n-     * \n-     * @param duration  the duration to add, null means add nothing\n-     * @throws ArithmeticException if the addition exceeds the capacity of the period\n-     */\n-    void add(ReadableDuration duration);\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Sets the number of years of the period.\n--- a/JodaTime/src/java/org/joda/time/base/BaseInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/BaseInterval.java\n         if (period == null) {\n             iEndMillis = iStartMillis;\n         } else {\n-            iEndMillis = chrono.add(iStartMillis, period, 1);\n+            iEndMillis = chrono.add(period, iStartMillis, 1);\n         }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n         if (period == null) {\n             iStartMillis = iEndMillis;\n         } else {\n-            iStartMillis = chrono.add(iEndMillis, period, -1);\n+            iStartMillis = chrono.add(period, iEndMillis, -1);\n         }\n         checkInterval(iStartMillis, iEndMillis);\n     }\n--- a/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.Duration;\n-import org.joda.time.DurationField;\n import org.joda.time.DurationFieldType;\n import org.joda.time.MutablePeriod;\n import org.joda.time.PeriodType;\n     protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n         super();\n         type = checkPeriodType(type);\n+        chrono = DateTimeUtils.getChronology(chrono);\n         iType = type;\n-        setPeriodInternal(startInstant, endInstant, chrono); // internal method\n+        iValues = chrono.get(this, startInstant, endInstant);\n     }\n \n     /**\n      * @param type  which set of fields this period supports, null means standard\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    protected BasePeriod(ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n+    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n         super();\n         type = checkPeriodType(type);\n         if (startInstant == null && endInstant == null) {\n             iType = type;\n             iValues = new int[size()];\n         } else {\n-            long start = DateTimeUtils.getInstantMillis(startInstant);\n-            long end = DateTimeUtils.getInstantMillis(endInstant);\n-            Chronology chrono = (startInstant != null ? startInstant.getChronology() : endInstant.getChronology());\n+            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n+            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n+            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n+            chrono = DateTimeUtils.getChronology(chrono);\n             iType = type;\n-            setPeriodInternal(start, end, chrono); // internal method\n+            iValues = chrono.get(this, startMillis, endMillis);\n         }\n     }\n \n         long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n         Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n         iType = type;\n-        setPeriodInternal(startMillis, endMillis, chrono); // internal method\n+        iValues = chrono.get(this, startMillis, endMillis);\n     }\n \n     /**\n     protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n         super();\n         type = checkPeriodType(type);\n+        chrono = DateTimeUtils.getChronology(chrono);\n         iType = type;\n-        setPeriodInternal(duration, chrono); // internal method\n+        iValues = chrono.get(this, duration);\n     }\n \n     /**\n             chrono = DateTimeUtils.getChronology(chrono);\n             converter.setInto((ReadWritablePeriod) this, period, chrono);\n         } else {\n-            setPeriodInternal(new MutablePeriod(period, type, chrono));\n+            iValues = new MutablePeriod(period, type, chrono).getValues();\n         }\n     }\n \n     public Duration toDurationFrom(ReadableInstant startInstant) {\n         long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n-        long endMillis = chrono.add(startMillis, this, 1);\n+        long endMillis = chrono.add(this, startMillis, 1);\n         return new Duration(startMillis, endMillis);\n     }\n \n      */\n     protected void setPeriod(ReadablePeriod period) {\n         if (period == null) {\n-            setPeriodInternal(0L, null);\n+            setValues(new int[size()]);\n         } else {\n             setPeriodInternal(period);\n         }\n         checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n         checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n         iValues = newValues;\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond interval.\n-     * \n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     * @param chrono  the chronology to use, not null\n-     */\n-    protected void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n-        setPeriodInternal(startInstant, endInstant, chrono);\n-    }\n-\n-    /**\n-     * Private method called from constructor.\n-     */\n-    private void setPeriodInternal(long startInstant, long endInstant, Chronology chrono) {\n-        int[] newValues = new int[size()];\n-        if (startInstant == endInstant) {\n-            iValues = newValues;\n-        } else {\n-            for (int i = 0, isize = size(); i < isize; i++) {\n-                DurationField field = getFieldType(i).getField(chrono);\n-                int value = field.getDifference(endInstant, startInstant);\n-                startInstant = field.add(startInstant, value);\n-                newValues[i] = value;\n-            }\n-            iValues = newValues;\n-        }\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond duration.\n-     * <p>\n-     * This calculates the period relative to 1970-01-01 but only sets those\n-     * fields which are precise.\n-     * \n-     * @param duration  the duration, in milliseconds\n-     * @throws ArithmeticException if the set exceeds the capacity of the period\n-     * @param chrono  the chronology to use, not null\n-     */\n-    protected void setPeriod(long duration, Chronology chrono) {\n-        setPeriodInternal(duration, chrono);\n-    }\n-\n-    /**\n-     * Private method called from constructor.\n-     */\n-    private void setPeriodInternal(long duration, Chronology chrono) {\n-        int[] newValues = new int[size()];\n-        if (duration == 0) {\n-            iValues = newValues;\n-        } else {\n-            long current = 0;\n-            for (int i = 0, isize = size(); i < isize; i++) {\n-                DurationField field = getFieldType(i).getField(chrono);\n-                if (field.isPrecise()) {\n-                    int value = field.getDifference(duration, current);\n-                    current = field.add(current, value);\n-                    newValues[i] = value;\n-                }\n-            }\n-            iValues = newValues;\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     protected void setValue(int index, int value) {\n-        if (value != getValue(index)) {\n-            iValues[index] = value;\n-        }\n+        iValues[index] = value;\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n      *\n      * @param partial  the partial instant to use\n      * @param instant  the instant to query\n-     * @return the values of this partial extracted from the instant\n+     * @return the values of the partial extracted from the instant\n      */\n     public int[] get(ReadablePartial partial, long instant) {\n         int size = partial.size();\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param startInstant  the start instant of an interval to query\n+     * @param endInstant  the start instant of an interval to query\n+     * @return the values of the period extracted from the interval\n+     */\n+    public int[] get(ReadablePeriod period, long startInstant, long endInstant) {\n+        int size = period.size();\n+        int[] values = new int[size];\n+        if (startInstant != endInstant) {\n+            for (int i = 0; i < size; i++) {\n+                DurationField field = period.getFieldType(i).getField(this);\n+                int value = field.getDifference(endInstant, startInstant);\n+                startInstant = field.add(startInstant, value);\n+                values[i] = value;\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param duration  the duration to query\n+     * @return the values of the period extracted from the duration\n+     */\n+    public int[] get(ReadablePeriod period, long duration) {\n+        int size = period.size();\n+        int[] values = new int[size];\n+        if (duration != 0) {\n+            long current = 0;\n+            for (int i = 0; i < size; i++) {\n+                DurationField field = period.getFieldType(i).getField(this);\n+                if (field.isPrecise()) {\n+                    int value = field.getDifference(duration, current);\n+                    current = field.add(current, value);\n+                    values[i] = value;\n+                }\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n      * Adds the period to the instant, specifying the number of times to add.\n      *\n+     * @param period  the period to add, null means add nothing\n      * @param instant  the instant to add to\n-     * @param period  the period to add, null means add nothing\n      * @param scalar  the number of times to add\n      * @return the updated instant\n      */\n-    public long add(long instant, ReadablePeriod period, int scalar) {\n+    public long add(ReadablePeriod period, long instant, int scalar) {\n         if (scalar != 0 && period != null) {\n             for (int i = 0, isize = period.size(); i < isize; i++) {\n                 long value = period.getValue(i); // use long to allow for multiplication (fits OK)\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadableDuration;\n \n      * Extracts duration values from an object of this converter's type, and\n      * sets them into the given ReadWritableDuration.\n      *\n-     * @param duration duration to get modified\n+     * @param writablePeriod  period to get modified\n      * @param object  the object to convert, must not be null\n      * @param chrono  the chronology to use, must not be null\n      * @throws NullPointerException if the duration or object is null\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n-        duration.setPeriod((ReadableDuration) object, chrono);\n+    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n+        ReadableDuration dur = (ReadableDuration) object;\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        long duration = dur.getMillis();\n+        int[] values = chrono.get(writablePeriod, duration);\n+        for (int i = 0; i < values.length; i++) {\n+            writablePeriod.setValue(i, values[i]);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n package org.joda.time.convert;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadableInterval;\n      */\n     public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n         ReadableInterval interval = (ReadableInterval) object;\n-        writablePeriod.setPeriod(interval, chrono);\n+        chrono = (chrono != null ? chrono : DateTimeUtils.getIntervalChronology(interval));\n+        long start = interval.getStartMillis();\n+        long end = interval.getEndMillis();\n+        int[] values = chrono.get(writablePeriod, start, end);\n+        for (int i = 0; i < values.length; i++) {\n+            writablePeriod.setValue(i, values[i]);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n             }\n             period = periodParser.parsePeriod(getPeriodType(rightStr), rightStr);\n             chrono = (chrono != null ? chrono : parsedChrono);\n-            endInstant = chrono.add(startInstant, period, 1);\n+            endInstant = chrono.add(period, startInstant, 1);\n         } else {\n             DateTime end = dateTimeParser.parseDateTime(rightStr);\n             endInstant = end.getMillis();\n             parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n             chrono = (chrono != null ? chrono : parsedChrono);\n             if (period != null) {\n-                startInstant = chrono.add(endInstant, period, -1);\n+                startInstant = chrono.add(period, endInstant, -1);\n             }\n         }\n         ", "timestamp": 1094683944, "metainfo": ""}