{"sha": "2fcc704a0e7d863f19b5b14fb412c14f3c063dd4", "log": "Add IllegalInstantException  Better handle DST gaps", "commit": "\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n /*\n- *  Copyright 2001-2012 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n      * @param strict  whether the conversion should reject non-existent local times\n      * @return the UTC instant with the same local time, \n      * @throws ArithmeticException if the result overflows a long\n-     * @throws IllegalArgumentException if the zone has no equivalent local time\n+     * @throws IllegalInstantException if the zone has no equivalent local time\n      * @since 1.5\n      */\n     public long convertLocalToUTC(long instantLocal, boolean strict) {\n                     // yes we are in the DST gap\n                     if (strict) {\n                         // DST gap is not acceptable\n-                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n-                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n-                                \" (\" + getID() + \")\");\n+                        throw new IllegalInstantException(instantLocal, getID());\n                     } else {\n                         // DST gap is acceptable, but for the Western hemisphere\n                         // the offset is wrong and will result in local times\n         try {\n             localDateTime.toDateTime(this);\n             return false;\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             return true;\n         }\n     }\n--- /dev/null\n+++ b/src/main/java/org/joda/time/IllegalInstantException.java\n+/*\n+ *  Copyright 2001-2013 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.format.DateTimeFormat;\n+\n+/**\n+ * Exception thrown when attempting to create an instant or date-time that cannot exist.\n+ * <p>\n+ * Classes like {@code DateTime} only store valid date-times.\n+ * One of the cases where validity is important is handling daylight savings time (DST).\n+ * In many places DST is used, where the local clock moves forward by an hour in spring and back by an hour in autumn/fall.\n+ * This means that in spring, there is a \"gap\" where a local time does not exist.\n+ * <p>\n+ * This exception refers to this gap, and it means that your application tried to create\n+ * a date-time inside the gap - a time that did not exist.\n+ * Since Joda-Time objects must be valid, this is not allowed.\n+ * <p>\n+ * Possible solutions may be as follows:<br />\n+ * Use <code>LocalDateTime</code>, as all local date-times are valid.<br />\n+ * When converting a <code>LocalDate</code> to a <code>DateTime</code>, then use <code>toDateTimeAsStartOfDay()</code>\n+ * as this handles and manages any gaps.<br />\n+ * When parsing, use <code>parseLocalDateTime()</code> if the string being parsed has no time-zone.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ */\n+public class IllegalInstantException extends IllegalArgumentException {\n+    \n+    /** Serialization lock. */\n+    private static final long serialVersionUID = 2858712538216L;\n+\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param message  the message\n+     */\n+    public IllegalInstantException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param instantLocal  the local instant\n+     * @param zoneId  the time-zone ID, may be null\n+     */\n+    public IllegalInstantException(long instantLocal, String zoneId) {\n+        super(createMessage(instantLocal, zoneId));\n+    }\n+\n+    private static String createMessage(long instantLocal, String zoneId) {\n+        String localDateTime = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal));\n+        String zone = (zoneId != null ? \" (\" + zoneId + \")\" : \"\");\n+        return \"Illegal instant due to time zone offset transition (daylight savings time 'gap'): \" + localDateTime + zone;\n+    }\n+\n+}\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n import org.joda.time.IllegalFieldValueException;\n-import org.joda.time.Instant;\n+import org.joda.time.IllegalInstantException;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.BaseDurationField;\n-import org.joda.time.format.DateTimeFormat;\n \n /**\n  * Wraps another Chronology to add support for time zones.\n     }\n \n     /**\n-     * @param instant instant from 1970-01-01T00:00:00 local time\n-     * @return instant from 1970-01-01T00:00:00Z\n-     */\n-    private long localToUTC(long instant) {\n+     * @param localInstant  the instant from 1970-01-01T00:00:00 local time\n+     * @return the instant from 1970-01-01T00:00:00Z\n+     */\n+    private long localToUTC(long localInstant) {\n         DateTimeZone zone = getZone();\n-        int offset = zone.getOffsetFromLocal(instant);\n-        instant -= offset;\n-        if (offset != zone.getOffset(instant)) {\n-            throw new IllegalArgumentException\n-                (\"Illegal instant due to time zone offset transition: \" +\n-                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n-        }\n-        return instant;\n+        int offset = zone.getOffsetFromLocal(localInstant);\n+        localInstant -= offset;\n+        if (offset != zone.getOffset(localInstant)) {\n+            throw new IllegalInstantException(localInstant, zone.getID());\n+        }\n+        return localInstant;\n     }\n \n     protected void assemble(Fields fields) {\n             localInstant = iField.set(localInstant, value);\n             long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n-                throw new IllegalFieldValueException(iField.getType(), Integer.valueOf(value),\n-                    \"Illegal instant due to time zone offset transition: \" +\n-                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n-                    \" (\" + iZone.getID() + \")\");\n+                IllegalInstantException cause = new IllegalInstantException(localInstant,  iZone.getID());\n+                IllegalFieldValueException ex = new IllegalFieldValueException(iField.getType(), Integer.valueOf(value), cause.getMessage());\n+                ex.initCause(cause);\n+                throw ex;\n             }\n             return result;\n         }\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n /*\n- *  Copyright 2001-2011 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.joda.time.DurationField;\n import org.joda.time.DurationFieldType;\n import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.IllegalInstantException;\n \n /**\n  * DateTimeParserBucket is an advanced class, intended mainly for parser\n             int offset = iZone.getOffsetFromLocal(millis);\n             millis -= offset;\n             if (offset != iZone.getOffset(millis)) {\n-                String message =\n-                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n+                String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                 if (text != null) {\n                     message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                 }\n-                throw new IllegalArgumentException(message);\n+                throw new IllegalInstantException(message);\n             }\n         }\n         \n--- a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n+++ b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n /*\n- *  Copyright 2001-2012 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         try {\n             date.toDateMidnight(MOCK_GAZA);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n         }\n     }\n         try {\n             new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_GAZA);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n         }\n     }\n         try {\n             new DateTime(\"2007-04-01T00:00\", MOCK_GAZA);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n         }\n     }\n         try {\n             date.toDateMidnight(MOCK_TURK);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().startsWith(\"Illegal instant due to time zone offset transition\"));\n         }\n     }\n         try {\n             new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_TURK);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n         }\n     }\n         try {\n             new DateTime(\"2007-04-01T00:00\", MOCK_TURK);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (IllegalInstantException ex) {\n             assertEquals(true, ex.getMessage().indexOf(\"Illegal instant due to time zone offset transition\") >= 0);\n         }\n     }", "timestamp": 1357563878, "metainfo": ""}