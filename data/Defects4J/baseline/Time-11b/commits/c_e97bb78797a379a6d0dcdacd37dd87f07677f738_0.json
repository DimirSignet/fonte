{"sha": "e97bb78797a379a6d0dcdacd37dd87f07677f738", "log": "Add DateTimeFormatter.withPivotYear to handle pattern pivot control from Fredrik Borgh   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n  * \n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n+ * @author Fredrik Borgh\n  * @since 1.0\n  */\n public class DateTimeFormatter {\n     private final Chronology iChrono;\n     /** The zone to use as an override. */\n     private final DateTimeZone iZone;\n+    /* The pivot year to use for two-digit year parsing. */\n+    private final Integer iPivotYear;\n \n     /**\n      * Creates a new formatter, however you will normally use the factory\n         iOffsetParsed = false;\n         iChrono = null;\n         iZone = null;\n+        iPivotYear = null;\n     }\n \n     /**\n     private DateTimeFormatter(\n             DateTimePrinter printer, DateTimeParser parser,\n             Locale locale, boolean offsetParsed,\n-            Chronology chrono, DateTimeZone zone) {\n+            Chronology chrono, DateTimeZone zone,\n+            Integer pivotYear) {\n         super();\n         iPrinter = printer;\n         iParser = parser;\n         iOffsetParsed = offsetParsed;\n         iChrono = chrono;\n         iZone = zone;\n+        iPivotYear = pivotYear;\n     }\n \n     //-----------------------------------------------------------------------\n         if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n             return this;\n         }\n-        return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone);\n+        return new DateTimeFormatter(iPrinter, iParser, locale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear);\n     }\n \n     /**\n         if (iOffsetParsed == true) {\n             return this;\n         }\n-        return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null);\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                true, iChrono, null, iPivotYear);\n     }\n \n     /**\n         if (iChrono == chrono) {\n             return this;\n         }\n-        return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone);\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, chrono, iZone, iPivotYear);\n     }\n \n     /**\n         if (iZone == zone) {\n             return this;\n         }\n-        return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone);\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                false, iChrono, zone, iPivotYear);\n     }\n \n     /**\n      */\n     public DateTimeZone getZone() {\n         return iZone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified pivot year for two\n+     * digit year parsing in preference to that stored in the parser.\n+     * <p>\n+     * This setting is useful for changing the pivot year of formats built\n+     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n+     * <p>\n+     * When parsing, this pivot year is used. Null means no-override.\n+     * There is no effect when printing.\n+     * <p>\n+     * The pivot year enables a two digit year to be converted to a four\n+     * digit year. The pivot represents the year in the middle of the\n+     * supported range of years. Thus the full range of years that will\n+     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivotYear  the pivot year to use as an override when parsing\n+     * @return the new formatter\n+     * @since 1.1\n+     */\n+    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n+        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, pivotYear);\n+    }\n+\n+    /**\n+     * Gets the pivot year to use as an override.\n+     *\n+     * @return the pivot year to use as an override\n+     * @since 1.1\n+     */\n+    public Integer getPivotYear() {\n+      return iPivotYear;\n     }\n \n     //-----------------------------------------------------------------------\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n-        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n         int newPos = iParser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis());\n         if (iOffsetParsed && bucket.getZone() == null) {\n         checkParser();\n         \n         Chronology chrono = selectChronology(iChrono);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n         int newPos = iParser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n         checkParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n         int newPos = iParser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n         checkParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n         int newPos = iParser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n  *\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n+ * @author Fredrik Borgh\n  * @since 1.0\n  * @see DateTimeFormat\n  * @see ISODateTimeFormat\n     static class TwoDigitYear\n             implements DateTimePrinter, DateTimeParser {\n \n+        /** The field to print/parse. */\n         private final DateTimeFieldType iType;\n+        /** The pivot year. */\n         private final int iPivot;\n \n         TwoDigitYear(DateTimeFieldType type, int pivot) {\n         }\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int pivot = iPivot;\n+            // If the bucket pivot year is non-null, use that when parsing\n+            if (bucket.getPivotYear() != null) {\n+                pivot = bucket.getPivotYear().intValue();\n+            }\n+\n             int limit = Math.min(2, text.length() - position);\n             if (limit < 2) {\n                 return ~position;\n             }\n             year = ((year << 3) + (year << 1)) + c - '0';\n \n-            int low = iPivot - 50;\n+            int low = pivot - 50;\n \n             int t;\n             if (low >= 0) {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n  * DateTimeParserBucket is mutable and not thread-safe.\n  *\n  * @author Brian S O'Neill\n+ * @author Fredrik Borgh\n  * @since 1.0\n  */\n public class DateTimeParserBucket {\n     private int iOffset;\n     /** The locale to use for parsing. */\n     private Locale iLocale;\n-    \n-    SavedField[] iSavedFields = new SavedField[8];\n-    int iSavedFieldsCount;\n-    boolean iSavedFieldsShared;\n+    /** Used for parsing two-digit years. */\n+    private Integer iPivotYear;\n+\n+    private SavedField[] iSavedFields = new SavedField[8];\n+    private int iSavedFieldsCount;\n+    private boolean iSavedFieldsShared;\n     \n     private Object iSavedState;\n-    \n+\n     /**\n      * Constucts a bucket.\n      * \n-     * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time\n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n      * @param chrono  the chronology to use\n      * @param locale  the locale to use\n      */\n     public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n+        this(instantLocal, chrono, locale, null);\n+    }\n+\n+    /**\n+     * Constucts a bucket, with the option of specifying the pivot year for\n+     * two-digit year parsing.\n+     *\n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     * @param locale  the locale to use\n+     * @param pivotYear  the pivot year to use when parsing two-digit years\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n         super();\n         chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n         iChrono = chrono.withUTC();\n         iLocale = (locale == null ? Locale.getDefault() : locale);\n         setZone(chrono.getZone());\n+        iPivotYear = pivotYear;\n     }\n \n     //-----------------------------------------------------------------------\n         iSavedState = null;\n         iOffset = offset;\n         iZone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the pivot year used for parsing two-digit years.\n+     * <p>\n+     * If null is returned, this indicates default behaviour\n+     *\n+     * @return Integer value of the pivot year, null if not set\n+     * @since 1.1\n+     */\n+    public Integer getPivotYear() {\n+        return iPivotYear;\n+    }\n+\n+    /**\n+     * Sets the pivot year to use when parsing two digit years.\n+     * <p>\n+     * If the value is set to null, this will indicate that default\n+     * behaviour should be used.\n+     *\n+     * @param pivotYear  the pivot year to use\n+     * @since 1.1\n+     */\n+    public void setPivotYear(Integer pivotYear) {\n+        iPivotYear = pivotYear;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n  * This class is a Junit unit test for DateTime Formating.\n  *\n  * @author Stephen Colebourne\n+ * @author Fredrik Borgh\n  */\n public class TestDateTimeFormat extends TestCase {\n \n         \n         expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n+\n+        /* Added tests for pivot year setting */\n+        f = f.withPivotYear(new Integer(2050));\n+        expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"00\"));\n+\n+        expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"99\"));\n+\n     }\n \n     //-----------------------------------------------------------------------\n         \n         expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n+\n+        /* Added tests for pivot year setting */\n+        f = f.withPivotYear(new Integer(2050));\n+        expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"00\"));\n+\n+        expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"99\"));\n     }\n \n     public void testFormat_year_long() {\n         \n         expect = new DateTime(2021, 1, 4, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n+\n+        /* Added tests for pivot year setting */\n+        f = f.withPivotYear(new Integer(2050));\n+        expect = new DateTime(2000, 1, 3, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(expect, f.parseDateTime(\"00\"));\n+\n+        expect = new DateTime(2098, 12, 29, 0, 0, 0, 0, DateTimeZone.UTC);\n+        assertEquals(expect, f.parseDateTime(\"99\"));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1110047220, "metainfo": ""}