{"sha": "aebca72a977c23bf2fa7901eb70e52d0702fddf8", "log": "Fix the case where typedefs are defined before the objects they're defined on.  R=acleung DELTA=47  (21 added, 15 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1678   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n   static final DiagnosticType NAME_DEFINED_LATE_WARNING =\n       DiagnosticType.warning(\n           \"JSC_NAME_DEFINED_LATE\",\n-          \"{0} is not defined yet, so properties cannot be defined on it\");\n+          \"{0} is not defined yet, so properties cannot be referenced on it\");\n \n   static final DiagnosticType STRICT_MODULE_DEP_QNAME =\n       DiagnosticType.disabled(\n     // we're looking through each reference, check all the module dependencies.\n     Ref declaration = name.declaration;\n     Name parent = name.parent;\n-    if (isDefined &&\n-        declaration != null &&\n+    boolean singleGlobalParentDecl =\n         parent != null &&\n         parent.declaration != null &&\n-        parent.localSets == 0 &&\n-        parent.declaration.preOrderIndex > declaration.preOrderIndex) {\n-      compiler.report(\n-          JSError.make(declaration.source.getName(), declaration.node,\n-              NAME_DEFINED_LATE_WARNING, parent.fullName()));\n-    }\n+        parent.localSets == 0;\n \n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n     for (Ref ref : name.getRefs()) {\n-      if (!isDefined) {\n+      if (!isDefined && !isTypedef(ref)) {\n         reportRefToUndefinedName(name, ref);\n-      } else {\n-        if (declaration != null &&\n-            ref.getModule() != declaration.getModule() &&\n-            !moduleGraph.dependsOn(\n-                ref.getModule(), declaration.getModule())) {\n-          reportBadModuleReference(name, ref);\n-        }\n+      } else if (declaration != null &&\n+          ref.getModule() != declaration.getModule() &&\n+          !moduleGraph.dependsOn(\n+              ref.getModule(), declaration.getModule())) {\n+        reportBadModuleReference(name, ref);\n+      } else if (ref.scope.isGlobal() &&\n+          singleGlobalParentDecl &&\n+          parent.declaration.preOrderIndex > ref.preOrderIndex) {\n+        compiler.report(\n+            JSError.make(ref.source.getName(), ref.node,\n+                NAME_DEFINED_LATE_WARNING, parent.fullName()));\n       }\n     }\n+  }\n+\n+  private boolean isTypedef(Ref ref) {\n+    // If this is an annotated EXPR-GET, don't do anything.\n+    Node parent = ref.node.getParent();\n+    if (parent.getType() == Token.EXPR_RESULT) {\n+      JSDocInfo info = ref.node.getJSDocInfo();\n+      if (info != null && info.hasTypedefType()) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   private void reportBadModuleReference(Name name, Ref ref) {\n     while (name.parent != null &&\n            name.parent.globalSets + name.parent.localSets == 0) {\n       name = name.parent;\n-    }\n-\n-    // If this is an annotated EXPR-GET, don't do anything.\n-    Node parent = ref.node.getParent();\n-    if (parent.getType() == Token.EXPR_RESULT) {\n-      JSDocInfo info = ref.node.getJSDocInfo();\n-      if (info != null && info.hasTypedefType()) {\n-        return;\n-      }\n     }\n \n     compiler.report(\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n         NAME_DEFINED_LATE_WARNING);\n   }\n \n+  public void testLateDefinedName5() {\n+    testSame(\"var x = {}; /** @typedef {number} */ x.y.z; x.y = {};\",\n+        NAME_DEFINED_LATE_WARNING);\n+  }\n+\n   public void testOkLateDefinedName1() {\n     testSame(\"function f() { x.y = {}; } var x = {};\");\n   }", "timestamp": 1304094824, "metainfo": ""}