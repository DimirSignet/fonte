{"sha": "a4a3b0ec39dcb5ff6a05c00477235deba672d281", "log": "Rename InlineGetters as it is confusing in the presence of \"get\" and \"set\".  R=nicksantos DELTA=1221  (607 added, 607 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=138   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   private List<PassFactory> getMainOptimizationLoop() {\n     List<PassFactory> passes = Lists.newArrayList();\n     if (options.inlineGetters) {\n-      passes.add(inlineGetters);\n+      passes.add(inlineSimpleMethods);\n     }\n \n     passes.addAll(getCodeRemovingPasses());\n   };\n \n   /** Inlines simple methods, like getters */\n-  private PassFactory inlineGetters =\n-      new PassFactory(\"inlineGetters\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new InlineGetters(compiler);\n+  private PassFactory inlineSimpleMethods =\n+      new PassFactory(\"inlineSimpleMethods\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new InlineSimpleMethods(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Inlines methods that take no arguments and have only a return statement\n+ * returning a property. Because it works on method names rather than type\n+ * inference, a method with multiple definitions will be inlined if each\n+ * definition is identical.\n+ *\n+ * <pre>\n+ * A.prototype.foo = function() { return this.b; }\n+ * B.prototype.foo = function() { return this.b; }\n+ * </pre>\n+ *\n+ * will inline foo, but\n+ *\n+ * <pre>\n+ * A.prototype.foo = function() { return this.b; }\n+ * B.prototype.foo = function() { return this.c; }\n+ * </pre>\n+ *\n+ * will not.\n+ *\n+ * Declarations are not removed because we do not find all possible\n+ * call sites. For examples, calls of the form foo[\"bar\"] are not\n+ * detected.\n+ *\n+ */\n+class InlineSimpleMethods extends MethodCompilerPass {\n+\n+  private static final Logger logger =\n+      Logger.getLogger(InlineSimpleMethods.class.getName());\n+\n+  InlineSimpleMethods(AbstractCompiler compiler) {\n+    super(compiler);\n+  }\n+\n+  /**\n+   * For each method call, see if it is a candidate for inlining.\n+   * TODO(kushal): Cache the results of the checks\n+   */\n+  private class InlineTrivialAccessors extends InvocationsCallback {\n+\n+    @Override\n+    void visit(NodeTraversal t, Node callNode, Node parent, String callName) {\n+      if (externMethods.contains(callName) ||\n+          nonMethodProperties.contains(callName)) {\n+        return;\n+      }\n+\n+      Collection<Node> definitions = methodDefinitions.get(callName);\n+      if (definitions == null || definitions.size() == 0) {\n+        return;\n+      }\n+\n+      // Do check of arity, complexity, and consistency in what we think is\n+      // the order from least to most complex\n+      Node firstDefinition = definitions.iterator().next();\n+\n+      // Check any multiple definitions\n+      if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {\n+\n+        if (!argsMayHaveSideEffects(callNode)) {\n+          // Verify this is a trivial return\n+          Node returned = returnedExpression(firstDefinition);\n+          if (returned != null) {\n+            if (isPropertyTree(returned)) {\n+              logger.fine(\"Inlining property accessor: \" + callName);\n+              inlinePropertyReturn(parent, callNode, returned);\n+            } else if (NodeUtil.isLiteralValue(returned, false) &&\n+              !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {\n+              logger.fine(\"Inlining constant accessor: \" + callName);\n+              inlineConstReturn(parent, callNode, returned);\n+            }\n+          } else if (isEmptyMethod(firstDefinition) &&\n+              !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {\n+            logger.fine(\"Inlining empty method: \" + callName);\n+            inlineEmptyMethod(t, parent, callNode);\n+          }\n+        }\n+      } else {\n+        logger.fine(\"Method '\" + callName + \"' has conflicting definitions.\");\n+      }\n+    }\n+  }\n+\n+  @Override\n+  Callback getActingCallback() {\n+    return new InlineTrivialAccessors();\n+  }\n+\n+  /**\n+   * Returns true if the provided node is a getprop for\n+   * which the left child is this or a valid property tree\n+   * and for which the right side is a string.\n+   */\n+  private static boolean isPropertyTree(Node expectedGetprop) {\n+    if (expectedGetprop.getType() != Token.GETPROP) {\n+      return false;\n+    }\n+\n+    Node leftChild = expectedGetprop.getFirstChild();\n+    if (leftChild.getType() != Token.THIS &&\n+        !isPropertyTree(leftChild)) {\n+      return false;\n+    }\n+\n+    Node retVal = leftChild.getNext();\n+    if (NodeUtil.getStringValue(retVal) == null) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Finds the occurence of \"this\" in the provided property tree and replaces\n+   * it with replacement\n+   */\n+  private static void replaceThis(Node expectedGetprop, Node replacement) {\n+    Node leftChild = expectedGetprop.getFirstChild();\n+    if (leftChild.getType() == Token.THIS) {\n+      expectedGetprop.replaceChild(leftChild, replacement);\n+    } else {\n+      replaceThis(leftChild, replacement);\n+    }\n+  }\n+\n+  /**\n+   * Return the node that represents the expression returned\n+   * by the method, given a FUNCTION node.\n+   */\n+  private static Node returnedExpression(Node fn) {\n+    Node expectedBlock = getMethodBlock(fn);\n+    if (!expectedBlock.hasOneChild()) {\n+      return null;\n+    }\n+\n+    Node expectedReturn = expectedBlock.getFirstChild();\n+    if (expectedReturn.getType() != Token.RETURN) {\n+      return null;\n+    }\n+\n+    if (!expectedReturn.hasOneChild()) {\n+      return null;\n+    }\n+\n+    return expectedReturn.getLastChild();\n+  }\n+\n+\n+  /**\n+   * Return whether the given FUNCTION node is an empty method definition.\n+   *\n+   * Must be private, or moved to NodeUtil.\n+   */\n+  private static boolean isEmptyMethod(Node fn) {\n+    Node expectedBlock = getMethodBlock(fn);\n+    return expectedBlock == null ?\n+        false : NodeUtil.isEmptyBlock(expectedBlock);\n+  }\n+\n+  /**\n+   * Return a BLOCK node if the given FUNCTION node is a valid method\n+   * definition, null otherwise.\n+   *\n+   * Must be private, or moved to NodeUtil.\n+   */\n+  private static Node getMethodBlock(Node fn) {\n+    if (fn.getChildCount() != 3) {\n+      return null;\n+    }\n+\n+    Node expectedBlock = fn.getLastChild();\n+    return  expectedBlock.getType() == Token.BLOCK ?\n+        expectedBlock : null;\n+  }\n+\n+  /**\n+   * Given a set of method definitions, verify they are the same.\n+   */\n+  private boolean allDefinitionsEquivalent(\n+      Collection<Node> definitions) {\n+    List<Node> list = Lists.newArrayList();\n+    list.addAll(definitions);\n+    Node node0 = list.get(0);\n+    for (int i = 1; i < list.size(); i++) {\n+      if (!compiler.areNodesEqualForInlining(list.get(i), node0)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the provided method call with the tree specified in returnedValue\n+   *\n+   * Parse tree of a call is\n+   * name\n+   *   call\n+   *     getprop\n+   *       obj\n+   *       string\n+   */\n+  private void inlinePropertyReturn(Node parent, Node call,\n+      Node returnedValue) {\n+    Node getProp = returnedValue.cloneTree();\n+    replaceThis(getProp, call.getFirstChild().removeFirstChild());\n+    parent.replaceChild(call, getProp);\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Replace the provided object and its method call with the tree specified\n+   * in returnedValue. Should be called only if the object reference has\n+   * no side effects.\n+   */\n+  private void inlineConstReturn(Node parent, Node call,\n+      Node returnedValue) {\n+    Node retValue = returnedValue.cloneTree();\n+    parent.replaceChild(call, retValue);\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Remove the provided object and its method call.\n+   */\n+  private void inlineEmptyMethod(NodeTraversal t, Node parent, Node call) {\n+    // If the return value of the method call is read,\n+    // replace it with \"void 0\". Otherwise, remove the call entirely.\n+    if (NodeUtil.isExprCall(parent)) {\n+      parent.getParent().replaceChild(parent, new Node(Token.EMPTY));\n+    } else {\n+      Node srcLocation = call;\n+      parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));\n+    }\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Check whether the given method call's arguments have side effects.\n+   * @param call The call node of a method invocation.\n+   */\n+  private boolean argsMayHaveSideEffects(Node call) {\n+    for (Node currentChild = call.getFirstChild().getNext();\n+         currentChild != null;\n+         currentChild = currentChild.getNext()) {\n+      if (NodeUtil.mayHaveSideEffects(currentChild)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * A do-nothing signature store.\n+   */\n+  static final MethodCompilerPass.SignatureStore DUMMY_SIGNATURE_STORE =\n+      new MethodCompilerPass.SignatureStore() {\n+        @Override\n+        public void addSignature(\n+            String functionName, Node functionNode, String sourceFile) {\n+        }\n+\n+        @Override\n+        public void removeSignature(String functionName) {\n+        }\n+\n+        @Override\n+        public void reset() {\n+        }\n+      };\n+\n+  @Override\n+  SignatureStore getSignatureStore() {\n+    return DUMMY_SIGNATURE_STORE;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+public class InlineSimpleMethodsTest extends CompilerTestCase {\n+\n+  public InlineSimpleMethodsTest() {\n+    super(\"\", false);\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new InlineSimpleMethods(compiler);\n+  }\n+\n+  /**\n+   * Helper for tests that expects definitions to remain unchanged, such\n+   * that {@code definitions+js} is coverted to {@code definitions+expected}.\n+   */\n+  private void testWithPrefix(String definitions, String js, String expected) {\n+    test(definitions + js, definitions + expected);\n+  }\n+\n+  public void testSimpleInline1() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\",\n+        \"var x=(new Foo).bar();var y=(new Foo).bar();\",\n+        \"var x=(new Foo).baz;var y=(new Foo).baz\");\n+  }\n+\n+  public void testSimpleInline2() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype={bar:function(){return this.baz}};\",\n+        \"var x=(new Foo).bar();var y=(new Foo).bar();\",\n+        \"var x=(new Foo).baz;var y=(new Foo).baz\");\n+  }\n+\n+  public void testSimpleGetterInline1() {\n+    // TODO(johnlenz): Support this case.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={get bar(){return this.baz}};\" +\n+      \"var x=(new Foo).bar;var y=(new Foo).bar\");\n+    // Verify we are not confusing calling the result of an ES5 getter\n+    // with call the getter.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={get bar(){return this.baz}};\" +\n+      \"var x=(new Foo).bar();var y=(new Foo).bar()\");\n+  }\n+\n+  public void testSimpleSetterInline1() {\n+    // Verify 'get' and 'set' are not confused.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={set bar(a){return this.baz}};\" +\n+      \"var x=(new Foo).bar;var y=(new Foo).bar\");\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={set bar(a){return this.baz}};\" +\n+      \"var x=(new Foo).bar();var y=(new Foo).bar()\");\n+  }\n+\n+  public void testSelfInline() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\",\n+        \"Foo.prototype.meth=function(){this.bar();}\",\n+        \"Foo.prototype.meth=function(){this.baz}\");\n+  }\n+\n+  public void testCallWithArgs() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\",\n+        \"var x=(new Foo).bar(3,new Foo)\",\n+        \"var x=(new Foo).bar(3,new Foo)\");\n+  }\n+\n+  public void testCallWithConstArgs() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(a){return this.baz};\",\n+        \"var x=(new Foo).bar(3, 4)\",\n+        \"var x=(new Foo).baz\");\n+  }\n+\n+  public void testNestedProperties() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz.ooka};\",\n+        \"(new Foo).bar()\",\n+        \"(new Foo).baz.ooka\");\n+  }\n+\n+  public void testSkipComplexMethods() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\" +\n+        \"Foo.prototype.condy=function(){return this.baz?this.baz:1};\",\n+        \"var x=(new Foo).argy()\",\n+        \"var x=(new Foo).argy()\");\n+  }\n+\n+  public void testSkipConflictingMethods() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\" +\n+        \"Foo.prototype.bar=function(){return this.bazz};\",\n+        \"var x=(new Foo).bar()\",\n+        \"var x=(new Foo).bar()\");\n+  }\n+\n+  public void testSameNamesDifferentDefinitions() {\n+    testWithPrefix(\"function A(){}\" +\n+        \"A.prototype.g=function(){return this.a};\" +\n+        \"function B(){}\" +\n+        \"B.prototype.g=function(){return this.b};\",\n+        \"var x=(new A).g();\" +\n+        \"var y=(new B).g();\" +\n+        \"var a=new A;\" +\n+        \"var ag=a.g();\",\n+        \"var x=(new A).g();\" +\n+        \"var y=(new B).g();\" +\n+        \"var a=new A;\" +\n+        \"var ag=a.g()\");\n+  }\n+\n+  public void testSameNamesSameDefinitions() {\n+    testWithPrefix(\"function A(){}\" +\n+        \"A.prototype.g=function(){return this.a};\" +\n+        \"function B(){}\" +\n+        \"B.prototype.g=function(){return this.a};\",\n+        \"var x=(new A).g();\" +\n+        \"var y=(new B).g();\" +\n+        \"var a=new A;\" +\n+        \"var ag=a.g();\",\n+        \"var x=(new A).a;\" +\n+        \"var y=(new B).a;\" +\n+        \"var a=new A;\" +\n+        \"var ag=a.a\");\n+  }\n+\n+  public void testConfusingNames() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return this.baz};\",\n+        \"function bar(){var bar=function(){};bar()}\",\n+        \"function bar(){var bar=function(){};bar()}\");\n+  }\n+\n+  public void testConstantInline() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return 3};\",\n+        \"var f=new Foo;var x=f.bar()\",\n+        \"var f=new Foo;var x=3\");\n+  }\n+\n+  public void testConstantArrayInline() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return[3,4]};\",\n+        \"var f=new Foo;var x=f.bar()\",\n+        \"var f=new Foo;var x=[3,4]\");\n+  }\n+\n+  public void testConstantInlineWithSideEffects() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){return 3};\",\n+        \"var x=(new Foo).bar()\",\n+        \"var x=(new Foo).bar()\");\n+  }\n+\n+  public void testEmptyMethodInline() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(a){};\",\n+        \"var x=new Foo; x.bar();\",\n+        \"var x=new Foo\");\n+  }\n+\n+  public void testEmptyMethodInlineWithSideEffects() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){};\",\n+        \"(new Foo).bar();var y=new Foo;y.bar(new Foo)\",\n+        \"(new Foo).bar();var y=new Foo;y.bar(new Foo)\");\n+  }\n+\n+  public void testEmptyMethodInlineInAssign1() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){};\",\n+        \"var x=new Foo;var y=x.bar()\",\n+        \"var x=new Foo;var y=void 0\");\n+  }\n+\n+  public void testEmptyMethodInlineInAssign2() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){};\",\n+        \"var x=new Foo;var y=x.bar().toString()\",\n+        \"var x=new Foo;var y=(void 0).toString()\");\n+  }\n+\n+  public void testNormalMethod() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(){var x=1};\",\n+        \"var x=new Foo;x.bar()\",\n+        \"var x=new Foo;x.bar()\");\n+  }\n+\n+  public void testNoInlineOfExternMethods1() {\n+    testSame(\"var external={};external.charAt;\",\n+        \"external.charAt()\", (DiagnosticType) null);\n+  }\n+\n+  public void testNoInlineOfExternMethods2() {\n+    testSame(\"var external={};external.charAt=function(){};\",\n+        \"external.charAt()\", (DiagnosticType) null);\n+  }\n+\n+  public void testNoInlineOfExternMethods3() {\n+    testSame(\"var external={};external.bar=function(){};\",\n+        \"function Foo(){}Foo.prototype.bar=function(){};(new Foo).bar()\",\n+             (DiagnosticType) null);\n+  }\n+\n+  public void testNoInlineOfDangerousProperty() {\n+    testSame(\"function Foo(){this.bar=3}\" +\n+        \"Foo.prototype.bar=function(){};\" +\n+        \"var x=new Foo;var y=x.bar()\");\n+  }\n+\n+  // Don't warn about argument naming conventions (this is done in another pass)\n+  //   opt_ parameters must not be followed by non-optional parameters.\n+  //   var_args must be last\n+  public void testNoWarn() {\n+    testSame(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(opt_a,b){var x=1};\" +\n+        \"var x=new Foo;x.bar()\");\n+\n+    testSame(\"function Foo(){}\" +\n+        \"Foo.prototype.bar=function(var_args,b){var x=1};\" +\n+        \"var x=new Foo;x.bar()\");\n+  }\n+\n+  public void testObjectLit() {\n+    testSame(\"Foo.prototype.bar=function(){return this.baz_};\" +\n+             \"var blah={bar:function(){}};\" +\n+             \"(new Foo).bar()\");\n+  }\n+\n+  public void testObjectLit2() {\n+    testSame(\"var blah={bar:function(){}};\" +\n+             \"(new Foo).bar()\");\n+  }\n+\n+  public void testObjectLitExtern() {\n+    String externs = \"window.bridge={_sip:function(){}};\";\n+    testSame(externs, \"window.bridge._sip()\", null);\n+  }\n+\n+  public void testExternFunction() {\n+    String externs = \"function emptyFunction() {}\";\n+    testSame(externs,\n+        \"function Foo(){this.empty=emptyFunction}\" +\n+        \"(new Foo).empty()\", null);\n+  }\n+\n+  public void testIssue2508576_1() {\n+    // Method defined by an extern should be left alone.\n+    String externs = \"function alert(a) {}\";\n+    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n+  }\n+\n+  public void testIssue2508576_2() {\n+    // Anonymous object definition with a side-effect should be left alone.\n+    testSame(\"({a:function(){},b:x()}).a(\\\"a\\\")\");\n+  }\n+\n+  public void testIssue2508576_3() {\n+    // Anonymous object definition without side-effect should be removed.\n+    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n+  }\n+\n+  public void testAnonymousGet() {\n+    // Anonymous object definition without side-effect should be removed.\n+    testSame(\"({get a(){return function(){}},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({get a(){},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({get a(){},b:alert}).a\");\n+  }\n+\n+  public void testAnonymousSet() {\n+    // Anonymous object definition without side-effect should be removed.\n+    testSame(\"({set a(b){return function(){}},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({set a(b){},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({set a(b){},b:alert}).a\");\n+  }\n+}", "timestamp": 1292377918, "metainfo": ""}