{"sha": "a4c526dae1537f027f429145656ffb849699c1fc", "log": "sort dependencies by default  R=acleung DELTA=86  (44 added, 16 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4348   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     options.setTweakProcessing(config.tweakProcessing);\n     createDefineOrTweakReplacements(config.tweak, options, true);\n \n+    // Dependency options\n     options.setManageClosureDependencies(config.manageClosureDependencies);\n     if (config.closureEntryPoints.size() > 0) {\n       options.setManageClosureDependencies(config.closureEntryPoints);\n     }\n+\n     options.devMode = config.jscompDevMode;\n     options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n \n     // Does not call applyBasicCompilationOptions(options) because the call to\n     // skipAllCompilerPasses() cannot be easily undone.\n+    options.dependencyOptions.setDependencySorting(true);\n     options.closurePass = true;\n     options.setRenamingPolicy(\n         VariableRenamingPolicy.LOCAL, PropertyRenamingPolicy.OFF);\n     // create possible conflicts between multiple diagnostic groups.\n \n     // All the safe optimizations.\n+    options.dependencyOptions.setDependencySorting(true);\n     options.closurePass = true;\n     options.foldConstants = true;\n     options.coalesceVariableNames = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     inputsById = new HashMap<InputId, CompilerInput>();\n     for (CompilerInput input : externs) {\n       InputId id = input.getInputId();\n-      CompilerInput previous = inputsById.put(id, input);\n+      CompilerInput previous = putCompilerInput(id, input);\n       if (previous != null) {\n         report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n       }\n     }\n     for (CompilerInput input : inputs) {\n       InputId id = input.getInputId();\n-      CompilerInput previous = inputsById.put(id, input);\n+      CompilerInput previous = putCompilerInput(id, input);\n       if (previous != null) {\n         report(JSError.make(DUPLICATE_INPUT, input.getName()));\n       }\n       throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n     }\n     CompilerInput input = new CompilerInput(ast, true);\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     externsRoot.addChildToFront(ast.getAstRoot(this));\n     externs.add(0, input);\n     return input;\n+  }\n+\n+  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n+    input.setCompiler(this);\n+    return inputsById.put(id, input);\n   }\n \n   /** Add a source input dynamically. Intended for incremental compilation. */\n   void addIncrementalSourceAst(JsAst ast) {\n     InputId id = ast.getInputId();\n     Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n-    inputsById.put(id, new CompilerInput(ast));\n+    putCompilerInput(id, new CompilerInput(ast));\n   }\n \n   /**\n     }\n \n     CompilerInput newInput = new CompilerInput(ast);\n-    inputsById.put(ast.getInputId(), newInput);\n+    putCompilerInput(ast.getInputId(), newInput);\n \n     JSModule module = oldInput.getModule();\n     if (module != null) {\n       modules.get(0).add(newInput);\n     }\n \n-    inputsById.put(ast.getInputId(), newInput);\n+    putCompilerInput(ast.getInputId(), newInput);\n \n     return true;\n   }\n         processAMDAndCommonJSModules();\n       }\n \n+      // Check if inputs need to be rebuilt from modules.\n+      boolean staleInputs = false;\n+\n       // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement()) {\n+      if (options.dependencyOptions.needsManagement() &&\n+          !options.skipAllPasses &&\n+          options.closurePass) {\n         for (CompilerInput input : inputs) {\n-          input.setCompiler(this);\n-\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n           inputs =\n               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n               .manageDependencies(options.dependencyOptions, inputs);\n+          staleInputs = true;\n         } catch (CircularDependencyException e) {\n           report(JSError.make(\n               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n         }\n       }\n \n-      // Check if inputs need to be rebuilt from modules.\n-      boolean staleInputs = false;\n       for (CompilerInput input : inputs) {\n         Node n = input.getAstRoot(this);\n \n   Node parseSyntheticCode(String js) {\n     CompilerInput input = new CompilerInput(\n         SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n     if (inputsById == null) {\n       inputsById = Maps.newHashMap();\n     }\n-    inputsById.put(input.getInputId(), input);\n+    putCompilerInput(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n   private final Set<String> requires = Sets.newHashSet();\n   private boolean generatedDependencyInfoFromSource = false;\n \n-  // An error manager for handling problems when dealing with\n-  // provides/requires.\n-  private ErrorManager errorManager;\n-\n   // An AbstractCompiler for doing parsing.\n-  private AbstractCompiler compiler;\n+  // We do not want to persist this across serialized state.\n+  private transient AbstractCompiler compiler;\n \n   public CompilerInput(SourceAst ast) {\n     this(ast, ast.getSourceFile().getName(), false);\n     return ast;\n   }\n \n-  /** Sets an error manager for routing error messages. */\n-  public void setErrorManager(ErrorManager errorManager) {\n-    this.errorManager = errorManager;\n-  }\n-\n   /** Sets an abstract compiler for doing parsing. */\n   public void setCompiler(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-    setErrorManager(compiler.getErrorManager());\n+  }\n+\n+  private void checkErrorManager() {\n+    Preconditions.checkNotNull(compiler,\n+        \"Expected setCompiler to be called first: \" + this);\n+    Preconditions.checkNotNull(compiler.getErrorManager(),\n+        \"Expected compiler to call an error manager: \" + this);\n   }\n \n   /** Gets a list of types depended on by this input. */\n   @Override\n   public Collection<String> getRequires() {\n-    Preconditions.checkNotNull(errorManager,\n-        \"Expected setErrorManager to be called first\");\n+    checkErrorManager();\n     try {\n       regenerateDependencyInfoIfNecessary();\n       return Collections.<String>unmodifiableSet(requires);\n     } catch (IOException e) {\n-      errorManager.report(CheckLevel.ERROR,\n+      compiler.getErrorManager().report(CheckLevel.ERROR,\n           JSError.make(AbstractCompiler.READ_ERROR, getName()));\n       return ImmutableList.<String>of();\n     }\n   /** Gets a list of types provided by this input. */\n   @Override\n   public Collection<String> getProvides() {\n-    Preconditions.checkNotNull(errorManager,\n-        \"Expected setErrorManager to be called first\");\n+    checkErrorManager();\n     try {\n       regenerateDependencyInfoIfNecessary();\n       return Collections.<String>unmodifiableSet(provides);\n     } catch (IOException e) {\n-      errorManager.report(CheckLevel.ERROR,\n+      compiler.getErrorManager().report(CheckLevel.ERROR,\n           JSError.make(AbstractCompiler.READ_ERROR, getName()));\n       return ImmutableList.<String>of();\n     }\n         // getPathRelativeToClosureBase() here because we're not using\n         // this to generate deps files. (We're only using it for\n         // symbol dependencies.)\n-        DependencyInfo info = (new JsFileParser(errorManager)).parseFile(\n-            getName(), getName(), getCode());\n+        DependencyInfo info =\n+            (new JsFileParser(compiler.getErrorManager())).parseFile(\n+                getName(), getName(), getCode());\n \n         provides.addAll(info.getProvides());\n         requires.addAll(info.getRequires());\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * whose symbols are not required.\n    */\n   public void setManageClosureDependencies(boolean newVal) {\n-    dependencyOptions.setDependencySorting(newVal);\n-    dependencyOptions.setDependencyPruning(newVal);\n+    dependencyOptions.setDependencySorting(\n+        newVal || dependencyOptions.shouldSortDependencies());\n+    dependencyOptions.setDependencyPruning(\n+        newVal || dependencyOptions.shouldPruneDependencies());\n     dependencyOptions.setMoocherDropping(false);\n     manageClosureDependencies = newVal;\n   }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   }\n \n   public void testSourceSortingOff() {\n-    test(new String[] {\n+    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n+    testSame(\n+        new String[] {\n           \"goog.require('beer');\",\n           \"goog.provide('beer');\"\n-         }, ProcessClosurePrimitives.LATE_PROVIDE_ERROR);\n+        });\n   }\n \n   public void testSourceSortingOn() {\n-    args.add(\"--manage_closure_dependencies=true\");\n     test(new String[] {\n           \"goog.require('beer');\",\n           \"goog.provide('beer');\"\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n     assertEquals(graph.getModuleCount(), 3);\n     List<CompilerInput> result = graph.manageDependencies(entryPoints,\n         compiler.getInputsForTesting());\n-    assertEquals(\"tonic.js\", result.get(0).getName());\n-    assertEquals(\"gin.js\", result.get(1).getName());\n-    assertEquals(\"mix.js\", result.get(2).getName());\n+    assertEquals(\"[module$tonic]\", result.get(0).getName());\n+    assertEquals(\"[module$gin]\", result.get(1).getName());\n+    assertEquals(\"tonic.js\", result.get(2).getName());\n+    assertEquals(\"gin.js\", result.get(3).getName());\n+    assertEquals(\"mix.js\", result.get(4).getName());\n   }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     );\n   }\n \n+  public void testSortingOff() {\n+    CompilerOptions options = new CompilerOptions();\n+    options.closurePass = true;\n+    options.setCodingConvention(new ClosureCodingConvention());\n+    test(options,\n+         new String[] {\n+           \"goog.require('goog.beer');\",\n+           \"goog.provide('goog.beer');\"\n+         },\n+         ProcessClosurePrimitives.LATE_PROVIDE_ERROR);\n+  }\n+\n   public void testProvideRequireSameFile() throws Exception {\n     CompilerOptions options = createCompilerOptions();\n     options.setDependencyOptions(", "timestamp": 1331334359, "metainfo": ""}