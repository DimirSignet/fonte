{"sha": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42", "log": "Change the OBJECTLIT AST structure from:  OBJECTLIT   KEY1   VALUE1  to  OBJECTLIT   KEY1     VALUE1  Fixes issue 241  R=acleung,johnlenz,stevey DELTA=268  (101 added, 51 deleted, 116 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=356416   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n         case Token.OBJECTLIT:\n           for (Node child = n.getFirstChild();\n                child != null;\n-               child = child.getNext().getNext()) {\n+               child = child.getNext()) {\n             if (child.getType() == Token.STRING) {\n               externedNames.add(child.getString());\n             }\n           // The children of an OBJECTLIT node are alternating key/value pairs.\n           // We skip the values.\n           for (Node key = n.getFirstChild(); key != null;\n-               key = key.getNext().getNext()) {\n+               key = key.getNext()) {\n             // We only want keys that are strings (not numbers), and only keys\n             // that were unquoted.\n             if (key.getType() == Token.STRING) {\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n         // var x = {a: 1, b: 2}\n         // should count as a use of property a and b.\n         for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n-             propNameNode = propNameNode.getNext().getNext()) {\n+             propNameNode = propNameNode.getNext()) {\n           if (propNameNode.getType() == Token.STRING &&\n               !propNameNode.isQuotedString()) {\n             addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n             // assumes the object literal is well formed\n             // (has an even number of children)\n             for (Node key = map.getFirstChild();\n-                 key != null; key = key.getNext().getNext()) {\n+                 key != null; key = key.getNext()) {\n               if (key.getType() == Token.STRING) {\n                 String name = key.getString();\n                 Property prop = new LiteralProperty(\n-                    key, key.getNext(), map, n, t.getModule());\n+                    key, key.getFirstChild(), map, n, t.getModule());\n                 getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n               }\n             }\n     @Override\n     public void remove() {\n       map.removeChild(key);\n-      map.removeChild(value);\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   }\n \n   private void nameObjectLiteralMethods(Node objectLiteral, String context) {\n-    // Object literals are a list of key-value pairs.  All object\n-    // literals produced by the parser have an even number of\n-    // children.\n-    Preconditions.checkState(objectLiteral.getChildCount() % 2 == 0);\n-\n     for (Node keyNode = objectLiteral.getFirstChild();\n          keyNode != null;\n-         keyNode = keyNode.getNext().getNext()) {  // skip 2 for next key\n-\n-      Node valueNode = keyNode.getNext();\n+         keyNode = keyNode.getNext()) {\n+      Node valueNode = keyNode.getFirstChild();\n \n       // Object literal keys may be strings or numbers.  Numbers are\n       // skipped because name tokens may not start with a number.\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n             pType == Token.SCRIPT ||\n             pType == Token.NAME ||\n             pType == Token.ASSIGN ||\n-            pType == Token.OBJECTLIT)) {\n+\n+            // object literal keys\n+            pType == Token.STRING ||\n+            pType == Token.NUMBER)) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         break;\n \n       case Token.NUMBER:\n-        Preconditions.checkState(childCount == 0);\n+        Preconditions.checkState(\n+            childCount ==\n+            ((n.getParent() != null &&\n+              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n         cc.addNumber(n.getDouble());\n         break;\n \n         break;\n \n       case Token.STRING:\n-        Preconditions.checkState(childCount == 0);\n+        Preconditions.checkState(\n+            childCount ==\n+            ((n.getParent() != null &&\n+              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0),\n+            n.getParent().toStringTree());\n         add(jsString(n.getString(), outputCharsetEncoder));\n         break;\n \n         break;\n \n       case Token.OBJECTLIT: {\n-        Preconditions.checkState(childCount % 2 == 0);\n         boolean needsParens = (context == Context.START_OF_EXPR);\n         if (needsParens) {\n           add(\"(\");\n         }\n         add(\"{\");\n-        for (Node c = first; c != null; c = c.getNext().getNext()) {\n+        for (Node c = first; c != null; c = c.getNext()) {\n           if (c != first) {\n             cc.listSeparator();\n           }\n             addExpr(c, 1);\n           }\n           add(\":\");\n-          addExpr(c.getNext(), 1);\n+          addExpr(c.getFirstChild(), 1);\n         }\n         add(\"}\");\n         if (needsParens) {\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     // This method has to work for both GETPROP chains and, in rare cases,\n     // OBJLIT keys, possibly nested. That's why we check for children before\n     // proceeding. In the OBJLIT case, we don't need to do anything.\n-    for (int i = 1; i < depth && n.hasChildren(); i++) {\n-      n = n.getFirstChild();\n-    }\n-    if (n.hasChildren()) {\n-      flattenNameRef(alias, n.getFirstChild(), n, originalName);\n+    int nType = n.getType();\n+    boolean isQName = nType == Token.NAME || nType == Token.GETPROP;\n+    boolean isObjKey = nType == Token.STRING || nType == Token.NUMBER;\n+    Preconditions.checkState(isObjKey || isQName);\n+    if (isQName) {\n+      for (int i = 1; i < depth && n.hasChildren(); i++) {\n+        n = n.getFirstChild();\n+      }\n+      if (n.hasChildren()) {\n+        flattenNameRef(alias, n.getFirstChild(), n, originalName);\n+      }\n     }\n   }\n \n \n     for (Node key = objlit.getFirstChild(), nextKey; key != null;\n          key = nextKey) {\n-      Node value = key.getNext();\n-      nextKey = value.getNext();\n+      Node value = key.getFirstChild();\n+      nextKey = key.getNext();\n \n       // We generate arbitrary names for keys that aren't valid JavaScript\n       // identifiers, since those keys are never referenced. (If they were,\n       Node refNode = null;\n       if (discardKeys) {\n         objlit.removeChild(key);\n-        objlit.removeChild(value);\n+        value.detachFromParent();\n       } else {\n         // Substitute a reference for the value.\n         refNode = Node.newString(Token.NAME, propAlias);\n         if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n           refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         }\n-        objlit.replaceChildAfter(key, refNode);\n+\n+        key.replaceChild(value, refNode);\n       }\n \n       // Declare the collapsed name as a variable with the original value.\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n               CrossModuleMethodMotion.UNSTUB_METHOD_NAME));\n     } else if (n.getType() == Token.ARRAYLIT ||\n         n.getType() == Token.OBJECTLIT) {\n+      boolean isObjectLit = n.getType() == Token.OBJECTLIT;\n       for (Node child = n.getFirstChild(); child != null;\n            child = child.getNext()) {\n-        if (!canMoveValue(child)) {\n+        if (!canMoveValue(isObjectLit ? child.getFirstChild() : child)) {\n           return false;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n       return new AssignmentDefinition(parent, isExtern);\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n-      return new ObjectLiteralPropertyDefinition(parent, n, n.getNext(),\n+      return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n           isExtern);\n     } else if (parent.getType() == Token.LP) {\n       Node function = parent.getParent();\n     @Override\n     public void performRemove() {\n       literal.removeChild(name);\n-      literal.removeChild(value);\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n           }\n         }\n \n-        child = child.getNext().getNext();\n+        child = child.getNext();\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n             parent = replacement;\n           }\n         }\n+      } else if (parentType == Token.OBJECTLIT) {\n+        decomposeObjectLiteralKeys(\n+            parent.getFirstChild(), child, state);\n       } else {\n         decomposeSubExpressions(\n             parent.getFirstChild(), child, state);\n   }\n \n   /**\n+   * Decompose an object literal.\n+   * @param key The object literal key.\n+   * @param stopNode A node after which to stop iterating.\n+   */\n+  private void decomposeObjectLiteralKeys(\n+      Node key, Node stopNode, DecompositionState state) {\n+    if (key == null || key == stopNode) {\n+      return;\n+    }\n+    decomposeObjectLiteralKeys(key.getNext(), stopNode, state);\n+    decomposeSubExpressions(key.getFirstChild(), stopNode, state);\n+  }\n+\n+  /**\n    * @param n The node with which to start iterating.\n    * @param stopNode A node after which to stop iterating.\n    */\n   private void decomposeSubExpressions(\n       Node n, Node stopNode, DecompositionState state) {\n-\n     if (n == null || n == stopNode) {\n       return;\n     }\n+\n+    // Never try to decompose anobject literal key.\n+    Preconditions.checkState(!NodeUtil.isObjectLitKey(n, n.getParent()));\n \n     // Decompose the children in reverse evaluation order.  This simplifies\n     // determining if the any of the children following have side-effects.\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n           }\n           if (name == null) return;\n           isSet = true;\n-          type = getValueType(n.getNext());\n+          type = getValueType(n.getFirstChild());\n           break;\n         case Token.NAME:\n           // This may be a variable get or set.\n      *   key of an object literal that can be named\n      */\n     String getNameForObjLitKey(Node n) {\n-      // Verify that this node is a key in the object literal (odd numbered).\n       Node parent = n.getParent();\n-      for (Node walker = parent.getFirstChild(); walker != n;\n-           walker = walker.getNext().getNext()) {\n-        if (walker == null) {\n-          return null;\n-        }\n-      }\n+      Preconditions.checkState(parent.getType() == Token.OBJECTLIT);\n+\n       Node gramps = parent.getParent();\n       if (gramps == null) {\n         return null;\n       }\n \n+      Node greatGramps = gramps.getParent();\n       String name;\n       switch (gramps.getType()) {\n         case Token.NAME:\n           //   NAME (gramps)\n           //     OBJLIT (parent)\n           //       STRING (n)\n-          Node greatGramps = gramps.getParent();\n           if (greatGramps == null ||\n               greatGramps.getType() != Token.VAR) {\n             return null;\n           Node lvalue = gramps.getFirstChild();\n           name = lvalue.getQualifiedName();\n           break;\n-        case Token.OBJECTLIT:\n-          // OBJLIT (gramps)\n-          //   STRING\n-          //   OBJLIT (parent)\n-          //     STRING (n)\n-          Node key = gramps.getChildBefore(parent);\n-          if (key.getType() == Token.STRING) {\n-            name = getNameForObjLitKey(key);\n+        case Token.STRING:\n+          // OBJLIT\n+          //   STRING (gramps)\n+          //     OBJLIT (parent)\n+          //       STRING (n)\n+          if (greatGramps != null &&\n+              greatGramps.getType() == Token.OBJECTLIT) {\n+            name = getNameForObjLitKey(gramps);\n           } else {\n             return null;\n           }\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n         throw new MalformedException(\"OBJLIT node expected\", objLitNode);\n       }\n       for (Node aNode = objLitNode.getFirstChild(); aNode != null;\n-          aNode = aNode.getNext().getNext()) {\n+           aNode = aNode.getNext()) {\n         if (aNode.getType() != Token.STRING) {\n           throw new MalformedException(\"STRING node expected as OBJLIT key\",\n               aNode);\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n           // assumes the object literal is well formed\n           // (has an even number of children)\n           for (Node key = n.getFirstChild();\n-               key != null; key = key.getNext().getNext()) {\n+               key != null; key = key.getNext()) {\n             if (key.getType() == Token.STRING) {\n-              Node value = key.getNext();\n+              Node value = key.getFirstChild();\n               String name = key.getString();\n               if (value.getType() == Token.FUNCTION) {\n                 addSignature(name, value, t.getSourceName());\n           // assumes the object literal is well formed\n           // (has an even number of children)\n           for (Node key = n.getFirstChild();\n-               key != null; key = key.getNext().getNext()) {\n+               key != null; key = key.getNext()) {\n             if (key.getType() == Token.STRING) {\n-              Node value = key.getNext();\n+              Node value = key.getFirstChild();\n               addPossibleSignature(key.getString(), value, t);\n             }\n           }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     // Check for the form { 'x' : function() { } }\n     Node parent = n.getParent();\n     switch (parent.getType()) {\n-      case Token.OBJECTLIT:\n+      case Token.STRING:\n         // Return the name of the literal's key.\n-        return getStringValue(parent.getFirstChild());\n+        return getStringValue(parent);\n     }\n \n     return null;\n   static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n       case Token.ARRAYLIT:\n-      case Token.OBJECTLIT:\n       case Token.REGEXP:\n         // Return true only if all children are const.\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n           if (!isLiteralValue(child, includeFunctions)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+\n+      case Token.OBJECTLIT:\n+        // Return true only if all values are const.\n+        for (Node child = n.getFirstChild(); child != null;\n+             child = child.getNext()) {\n+          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n             return false;\n           }\n         }\n         return true;\n \n       case Token.OBJECTLIT:\n+        if (checkForNewObjects) {\n+          return true;\n+        }\n+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+          if (checkForStateChangeHelper(\n+                  c.getFirstChild(), checkForNewObjects, compiler)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+\n       case Token.ARRAYLIT:\n       case Token.REGEXP:\n         if (checkForNewObjects) {\n    * @param parent The node's parent\n    */\n   static boolean isObjectLitKey(Node node, Node parent) {\n-    if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) {\n-      int index = 0;\n-      for (Node current = parent.getFirstChild();\n-           current != null;\n-           current = current.getNext()) {\n-        if (current == node) {\n-          return index % 2 == 0;\n-        }\n-        index++;\n-      }\n-    }\n-    return false;\n+    // TODO(nicksantos): What about NUMBER?\n+    return node.getType() == Token.STRING &&\n+        parent.getType() == Token.OBJECTLIT;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n    */\n   private void endPass(Node externs, Node root) {\n     Preconditions.checkState(currentTracer != null && currentPassName != null);\n-    stopTracer(currentTracer, currentPassName);\n+\n     String passToCheck = currentPassName;\n-    currentPassName = null;\n-    currentTracer = null;\n-\n     try {\n+      stopTracer(currentTracer, currentPassName);\n+      currentPassName = null;\n+      currentTracer = null;\n+\n       maybeSanityCheck(externs, root);\n     } catch (Exception e) {\n       // TODO(johnlenz): Remove this once the normalization checks report\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n     private void visitObjectLiteral(Node objlit) {\n       Preconditions.checkState(objlit.getType() == Token.OBJECTLIT);\n       for (Node key = objlit.getFirstChild();\n-           key != null; key = key.getNext().getNext()) {\n-        Node value = key.getNext();\n+           key != null; key = key.getNext()) {\n+        Node value = key.getFirstChild();\n         visitObjectLiteralKey(objlit, key, value);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       final Map<String, String> cssNames = Maps.newHashMap();\n       JSError error = null;\n       for (Node key = arg.getFirstChild(); key != null;\n-          key = key.getNext().getNext()) {\n-        Node value = key.getNext();\n+          key = key.getNext()) {\n+        Node value = key.getFirstChild();\n         if (key.getType() != Token.STRING\n             || value == null\n             || value.getType() != Token.STRING) {\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n         case Token.OBJECTLIT:\n           for (Node child = n.getFirstChild();\n                child != null;\n-               child = child.getNext().getNext()) {\n+               child = child.getNext()) {\n             if (child.getType() == Token.STRING) {\n               externedNames.add(child.getString());\n             }\n           // The children of an OBJECTLIT node are alternating key/value pairs.\n           // We skip the values.\n           for (Node key = n.getFirstChild(); key != null;\n-               key = key.getNext().getNext()) {\n+               key = key.getNext()) {\n             // We only want keys that are strings (not numbers), and only keys\n             // that were unquoted.\n             if (key.getType() == Token.STRING) {\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n             // only the property names.\n             for (Node child = n.getFirstChild();\n                  child != null;\n-                 child = child.getNext().getNext()) {\n+                 child = child.getNext()) {\n \n               if (child.getType() == Token.STRING) {\n                 markObjLitPropertyCandidate(child, t.getInput());\n             // assumes the object literal is well formed\n             // (has an even number of children)\n             for (Node key = map.getFirstChild();\n-                 key != null; key = key.getNext().getNext()) {\n+                 key != null; key = key.getNext()) {\n               if (key.getType() == Token.STRING) {\n                 markPrototypePropertyCandidate(key, input);\n               }\n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n       JsMessage.PlaceholderReference phRef =\n           (JsMessage.PlaceholderReference) part;\n \n-      for (Node n = objLitNode.getFirstChild(); n != null;\n-          n = n.getNext().getNext()) {\n-        if (n.getString().equals(phRef.getName())) {\n-          Node valueNode = n.getNext();\n+      for (Node key = objLitNode.getFirstChild(); key != null;\n+           key = key.getNext()) {\n+        if (key.getString().equals(phRef.getName())) {\n+          Node valueNode = key.getFirstChild();\n           partNode = valueNode.cloneTree();\n         }\n       }\n--- a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n+++ b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\n \n       case Token.OBJECTLIT:\n         for (Node key = n.getFirstChild(); key != null;\n-             key = key.getNext().getNext()) {\n+             key = key.getNext()) {\n            // We only want keys that are strings (not numbers), and only keys\n            // that were unquoted.\n            if (key.getType() == Token.STRING) {\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n \n import com.google.common.base.Predicate;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n \n import java.io.IOException;\n \n             || NodeUtil.isFunction(node)\n             || NodeUtil.isName(node)\n             || NodeUtil.isGet(node)\n-            || (NodeUtil.isString(node) && NodeUtil.isGet(node.getParent()));\n+            || (NodeUtil.isString(node) &&\n+                (node.getParent().getType() == Token.OBJECTLIT ||\n+                 NodeUtil.isGet(node.getParent())));\n       }\n     };\n   }\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n     if (!noCajaChecks) {\n       for (Node key = n.getFirstChild();\n            key != null;\n-           key = key.getNext().getNext()) {\n+           key = key.getNext()) {\n         if (key.getString().endsWith(\"__\")) {\n           t.report(key, ILLEGAL_NAME);\n         }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       while (key != null) {\n         if (key.getType() == Token.STRING &&\n             isStripName(key.getString())) {\n-          Node value = key.getNext();\n-          Node next = value.getNext();\n+          Node value = key.getFirstChild();\n+          Node next = key.getNext();\n           n.removeChild(key);\n-          n.removeChild(value);\n           key = next;\n           compiler.reportCodeChange();\n         } else {\n-          key = key.getNext().getNext();\n+          key = key.getNext();\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n+++ b/src/com/google/javascript/jscomp/SuspiciousPropertiesCheck.java\n           }\n           break;\n         case Token.OBJECTLIT:\n-          // Object literals have their property name/value pairs as a flat\n-          // list as their children. We want every other node in order to get\n-          // only the property names.\n-          boolean isKey = true;\n           for (Node child = n.getFirstChild();\n                child != null;\n                child = child.getNext()) {\n-            if (isKey && child.getType() == Token.STRING) {\n+            if (child.getType() == Token.STRING) {\n               addWrite(child, t, true);\n             }\n-            isKey = !isKey;\n           }\n           break;\n         case Token.CALL:\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   private void checkEnumInitializer(\n       NodeTraversal t, Node value, JSType primitiveType) {\n     if (value.getType() == Token.OBJECTLIT) {\n-      // re-using value as the value of the object literal and advancing twice\n-      value = value.getFirstChild();\n-      value = (value == null) ? null : value.getNext();\n-      while (value != null) {\n+      for (Node key = value.getFirstChild();\n+           key != null; key = key.getNext()) {\n+        Node propValue = key.getFirstChild();\n+\n         // the value's type must be assignable to the enum's primitive type\n-        validator.expectCanAssignTo(t, value, getJSType(value), primitiveType,\n+        validator.expectCanAssignTo(\n+            t, propValue, getJSType(propValue), primitiveType,\n             \"element type must match enum's type\");\n-\n-        // advancing twice\n-        value = value.getNext();\n-        value = (value == null) ? null : value.getNext();\n       }\n     } else if (value.getJSType() instanceof EnumType) {\n       // TODO(user): Remove the instanceof check in favor\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     }\n \n     for (Node name = n.getFirstChild(); name != null;\n-         name = name.getNext().getNext()) {\n-      Node value = name.getNext();\n-      scope = traverse(name, scope);\n+         name = name.getNext()) {\n+      Node value = name.getFirstChild();\n       scope = traverse(value, scope);\n       String memberName = NodeUtil.getStringValue(name);\n       if (memberName != null) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n               enumType.defineElement(keyName);\n             }\n             key = key.getNext();\n-            key = (key == null) ? null : key.getNext();\n           }\n         } else if (value.isQualifiedName()) {\n           Var var = scope.getVar(value.getQualifiedName());\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         } else if (el.isSetter()) {\n           reportSetter(el);\n         } else {\n-          node.addChildToBack(transformAsString(el.getLeft()));\n-          node.addChildToBack(transform(el.getRight()));\n+          Node key = transformAsString(el.getLeft());\n+          key.addChildToFront(transform(el.getRight()));\n+          node.addChildToBack(key);\n         }\n       }\n       return node;\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n         \"  JSCompiler_inline_result$$0 = 3;\" +\n         \"}\" +\n         \"var x = {y: 1, z: JSCompiler_inline_result$$0};\");\n+  }\n+\n+  public void testInlineFunctions28() {\n+    test(\"var window = {}; function foo(){window.bar++; return 3;}\" +\n+        \"var x = {y: alert(), z: foo(2)};\",\n+        \"var window = {};\" +\n+        \"var JSCompiler_temp_const$$0 = alert();\" +\n+        \"{\" +\n+        \" var JSCompiler_inline_result$$1;\" +\n+        \" window.bar++;\" +\n+        \" JSCompiler_inline_result$$1 = 3;}\" +\n+        \"var x = {\" +\n+        \"  y: JSCompiler_temp_const$$0,\" +\n+        \"  z: JSCompiler_inline_result$$1\" +\n+        \"};\");\n+  }\n+\n+  public void testInlineFunctions29() {\n+    test(\"var window = {}; function foo(){window.bar++; return 3;}\" +\n+        \"var x = {a: alert(), b: alert2(), c: foo(2)};\",\n+        \"var window = {};\" +\n+        \"var JSCompiler_temp_const$$1 = alert();\" +\n+        \"var JSCompiler_temp_const$$0 = alert2();\" +\n+        \"{\" +\n+        \" var JSCompiler_inline_result$$2;\" +\n+        \" window.bar++;\" +\n+        \" JSCompiler_inline_result$$2 = 3;}\" +\n+        \"var x = {\" +\n+        \"  a: JSCompiler_temp_const$$1,\" +\n+        \"  b: JSCompiler_temp_const$$0,\" +\n+        \"  c: JSCompiler_inline_result$$2\" +\n+        \"};\");\n   }\n \n   public void testMixedModeInlining1() {\n--- a/test/com/google/javascript/jscomp/PrepareAstTest.java\n+++ b/test/com/google/javascript/jscomp/PrepareAstTest.java\n     assertEquals(Token.OBJECTLIT, objlit.getType());\n \n     Node firstKey = objlit.getFirstChild();\n-    Node firstVal = firstKey.getNext();\n+    Node firstVal = firstKey.getFirstChild();\n \n-    Node secondKey = firstVal.getNext();\n-    Node secondVal = secondKey.getNext();\n+    Node secondKey = firstKey.getNext();\n+    Node secondVal = secondKey.getFirstChild();\n     assertNotNull(firstKey.getJSDocInfo());\n     assertNotNull(firstVal.getJSDocInfo());\n     assertNull(secondKey.getJSDocInfo());\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   }\n \n   public void testObjectLiteral() {\n-    parse(\"var o = {}\");\n+    newParse(\"var o = {}\");\n   }\n \n   public void testObjectLiteral2() {\n-    parse(\"var o = {a: 1}\");\n+    newParse(\"var o = {a: 1}\");\n   }\n \n   public void testObjectLiteral3() {\n-    parse(\"var o = {a: 1, b: 2}\");\n+    newParse(\"var o = {a: 1, b: 2}\");\n   }\n \n   public void testObjectLiteral4() {\n-    parse(\"var o = {1: 'a'}\");\n+    newParse(\"var o = {1: 'a'}\");\n   }\n \n   public void testObjectLiteral5() {\n-    parse(\"var o = {'a': 'a'}\");\n+    newParse(\"var o = {'a': 'a'}\");\n   }\n \n   public void testKeywordLiteral() {\n     Node firstVar = firstVarDecl.getFirstChild();\n     Node firstObjectLit = firstVar.getFirstChild();\n     Node firstKey = firstObjectLit.getFirstChild();\n-    Node firstValue = firstKey.getNext();\n-\n-    Node secondKey = firstValue.getNext();\n-    Node secondValue = secondKey.getNext();\n-\n-    Node thirdKey = secondValue.getNext();\n-    Node thirdValue = thirdKey.getNext();\n+    Node firstValue = firstKey.getFirstChild();\n+\n+    Node secondKey = firstKey.getNext();\n+    Node secondValue = secondKey.getFirstChild();\n+\n+    Node thirdKey = secondKey.getNext();\n+    Node thirdValue = thirdKey.getFirstChild();\n \n     assertNodePosition(1, 4, firstVar);\n     assertNodePosition(2, 0, firstObjectLit);\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     assertEquals(3, n.getLineno());\n     assertEquals(9, n.getCharno());\n \n-    n = n.getFirstChild();\n-\n-    assertEquals(Token.STRING, n.getType());\n-    assertEquals(3, n.getLineno());\n-    assertEquals(10, n.getCharno());\n-\n-    n = n.getNext();\n-\n-    assertEquals(Token.NUMBER, n.getType());\n-    assertEquals(3, n.getLineno());\n-    assertEquals(12, n.getCharno());\n-\n-    n = n.getNext();\n-\n-    assertEquals(Token.STRING, n.getType());\n-    assertEquals(4, n.getLineno());\n-    assertEquals(1, n.getCharno());\n-\n-    n = n.getNext();\n-\n-    assertEquals(Token.NUMBER, n.getType());\n-    assertEquals(4, n.getLineno());\n-    assertEquals(4, n.getCharno());\n+    Node key = n.getFirstChild();\n+\n+    assertEquals(Token.STRING, key.getType());\n+    assertEquals(3, key.getLineno());\n+    assertEquals(10, key.getCharno());\n+\n+    Node value = key.getFirstChild();\n+\n+    assertEquals(Token.NUMBER, value.getType());\n+    assertEquals(3, value.getLineno());\n+    assertEquals(12, value.getCharno());\n+\n+    key = key.getNext();\n+\n+    assertEquals(Token.STRING, key.getType());\n+    assertEquals(4, key.getLineno());\n+    assertEquals(1, key.getCharno());\n+\n+    value = key.getFirstChild();\n+\n+    assertEquals(Token.NUMBER, value.getType());\n+    assertEquals(4, value.getLineno());\n+    assertEquals(4, value.getCharno());\n   }\n \n   public void testLinenoCharnoAdd() throws Exception {", "timestamp": 1287438901, "metainfo": ""}