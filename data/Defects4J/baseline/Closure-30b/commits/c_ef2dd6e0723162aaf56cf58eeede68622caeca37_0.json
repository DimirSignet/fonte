{"sha": "ef2dd6e0723162aaf56cf58eeede68622caeca37", "log": "Introduce a V3 source map.  Experimental.  R=jschorr DELTA=3054  (2176 added, 853 deleted, 25 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1509   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/Base64.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A utility class for working with Base64 values.\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+final class Base64 {\n+\n+  // This is a utility class\n+  private Base64() {}\n+\n+  /**\n+   *  A map used to convert integer values in the range 0-63 to their base64\n+   *  values.\n+   */\n+  private static final String BASE64_MAP =\n+      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n+      \"abcdefghijklmnopqrstuvwxyz\" +\n+      \"0123456789+/\";\n+\n+  /**\n+   * A map used to convert base64 character into integer values.\n+   */\n+  private static final int[] BASE64_DECODE_MAP = new int[256];\n+  static {\n+      Arrays.fill(BASE64_DECODE_MAP, -1);\n+      for (int i = 0; i < BASE64_MAP.length(); i++)\n+        BASE64_DECODE_MAP[BASE64_MAP.charAt(i)] = i;\n+  }\n+\n+  /**\n+   * @param value A value in the range of 0-63.\n+   * @return a base64 digit.\n+   */\n+  public static char toBase64(int value) {\n+    assert (value <= 63 && value >= 0) : \"value out of range:\" + value;\n+    return BASE64_MAP.charAt(value);\n+  }\n+\n+  /**\n+   * @param c A base64 digit.\n+   * @return A value in the range of 0-63.\n+   */\n+  public static int fromBase64(char c) {\n+    int result = BASE64_DECODE_MAP[c];\n+    assert (result != -1) : \"invalid char\";\n+    return BASE64_DECODE_MAP[c];\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/Base64VLQ.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import java.io.IOException;\n+\n+/**\n+ * We encode our variable length numbers as base64 encoded strings with\n+ * the least significant digit coming first.  Each base64 digit encodes\n+ * a 5-bit value (0-31) and a continuation bit.  Signed values can be\n+ * represented by using the least significant bit of the value as the\n+ * sign bit.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+final class Base64VLQ {\n+  // Utility class.\n+  private Base64VLQ() {}\n+\n+  // A Base64 VLQ digit can represent 5 bits, so it is base-32.\n+  private static final int VLQ_BASE_SHIFT = 5;\n+  private static final int VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n+\n+  // A mask of bits for a VLQ digit (11111), 31 decimal.\n+  private static final int VLQ_BASE_MASK = VLQ_BASE-1;\n+\n+  // The continuation bit is the 6th bit.\n+  private static final int VLQ_CONTINUATION_BIT = VLQ_BASE;\n+\n+  /**\n+   * Converts from a two-complement value to a value where the sign bit is\n+   * is placed in the least significant bit.  For example, as decimals:\n+   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n+   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n+   */\n+  private static int toVLQSigned(int value) {\n+    if (value < 0) {\n+      return ((-value) << 1) + 1;\n+    } else {\n+      return (value << 1) + 0;\n+    }\n+  }\n+\n+  /**\n+   * Converts to a two-complement value from a value where the sign bit is\n+   * is placed in the least significant bit.  For example, as decimals:\n+   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n+   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n+   */\n+  private static int fromVLQSigned(int value) {\n+    boolean negate = (value & 1) == 1;\n+    value = value >> 1;\n+    return negate ? -value : value;\n+  }\n+\n+  /**\n+   * Writes a VLQ encoded value to the provide appendable.\n+   * @throws IOException\n+   */\n+  public static void encode(Appendable out, int value)\n+      throws IOException {\n+    value = toVLQSigned(value);\n+    do {\n+      int digit = value & VLQ_BASE_MASK;\n+      value >>>= VLQ_BASE_SHIFT;\n+      if (value > 0) {\n+        digit |= VLQ_CONTINUATION_BIT;\n+      }\n+      out.append(Base64.toBase64(digit));\n+    } while (value > 0);\n+  }\n+\n+  /**\n+   * A simple interface for advancing through a sequence of characters, that\n+   * communicates that advance back to the source.\n+   */\n+  interface CharIterator {\n+    boolean hasNext();\n+    char next();\n+  }\n+\n+  /**\n+   * Decodes the next VLQValue from the provided CharIterator.\n+   */\n+  public static int decode(CharIterator in) {\n+    int result = 0;\n+    boolean continuation;\n+    int shift = 0;\n+    do {\n+      char c = in.next();\n+      int digit = Base64.fromBase64(c);\n+      continuation = (digit & VLQ_CONTINUATION_BIT) != 0;\n+      digit &= VLQ_BASE_MASK;\n+      result = result + (digit << shift);\n+      shift = shift + VLQ_BASE_SHIFT;\n+    } while (continuation);\n+\n+    return fromVLQSigned(result);\n+  }\n+}\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerFactory.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerFactory.java\n \n package com.google.debugging.sourcemap;\n \n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n /**\n  * Detect and parse the provided source map.\n  * @author johnlenz@google.com (John Lenz)\n    */\n   public static SourceMapping parse(String contents)\n       throws SourceMapParseException {\n-    SourceMapConsumer consumer = null;\n-    SourceMapFormat format = detectVersion(contents);\n-    consumer = createForVerion(detectVersion(contents));\n-    consumer.parse(contents);\n-    return consumer;\n-  }\n+    // Version 1, starts with a magic string\n+    if (contents.startsWith(\"/** Begin line maps. **/\")) {\n+      SourceMapConsumerV1 consumer =  new SourceMapConsumerV1();\n+      consumer.parse(contents);\n+      return consumer;\n+    } else if (contents.startsWith(\"{\")){\n+      try {\n+        // Revision 2 and 3, are JSON Objects\n+        JSONObject sourceMapRoot = new JSONObject(contents);\n+        // Check basic assertions about the format.\n+        int version = sourceMapRoot.getInt(\"version\");\n+        switch (version) {\n+          case 2: {\n+            SourceMapConsumerV2 consumer =  new SourceMapConsumerV2();\n+            consumer.parse(sourceMapRoot);\n+            return consumer;\n+          }\n+          case 3: {\n+            SourceMapConsumerV3 consumer =  new SourceMapConsumerV3();\n+            consumer.parse(sourceMapRoot);\n+            return consumer;\n+          }\n+          default:\n+            throw new SourceMapParseException(\n+                \"Unknown source map version:\" + version);\n+        }\n+      } catch (JSONException ex) {\n+        throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n+      }\n+    }\n \n-  /**\n-   * @param contents\n-   * @return The best guess of the source map version.\n-   * @throws SourceMapParseException\n-   */\n-  private static SourceMapFormat detectVersion(String contents)\n-      throws SourceMapParseException {\n-    if (contents.startsWith(\"/** Begin line maps. **/\")) {\n-      return SourceMapFormat.V1;\n-    } else if (contents.startsWith(\"{\")){\n-      return SourceMapFormat.V2;\n-    } else {\n-      throw new SourceMapParseException(\"unable to detect source map format\");\n-    }\n-  }\n-\n-  /**\n-   * @return The appropriate source map object for the given source map format.\n-   * @throws SourceMapParseException\n-   */\n-  private static SourceMapConsumer createForVerion(\n-      SourceMapFormat format)\n-      throws SourceMapParseException {\n-    switch (format) {\n-      case V1:\n-        return new SourceMapConsumerV1();\n-      case V2:\n-        return new SourceMapConsumerV2();\n-      default:\n-        throw new SourceMapParseException(\"unsupported source map format\");\n-    }\n+    throw new SourceMapParseException(\"unable to detect source map format\");\n   }\n }\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.debugging.sourcemap.Base64VLQ.CharIterator;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.Builder;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Class for parsing version 3 of the SourceMap format, as produced by the\n+ * Closure Compiler, etc.\n+ * http://goto.google.com/sourcemapv3\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapConsumerV3 implements SourceMapConsumer {\n+  static final int UNMAPPED = -1;\n+\n+  private String[] sources;\n+  private String[] names;\n+  private int lineCount;\n+  // Slots in the lines list will be null if the line does not have any entries.\n+  private List<ArrayList<Entry>> lines = null;\n+\n+  public SourceMapConsumerV3() {\n+\n+  }\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(String contents) throws SourceMapParseException {\n+    try {\n+      JSONObject sourceMapRoot = new JSONObject(contents);\n+      parse(sourceMapRoot);\n+    } catch (JSONException ex) {\n+      throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n+    }\n+  }\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(JSONObject sourceMapRoot) throws SourceMapParseException {\n+    try {\n+      // Check basic assertions about the format.\n+      int version = sourceMapRoot.getInt(\"version\");\n+      if (version != 3) {\n+        throw new SourceMapParseException(\"Unknown version: \" + version);\n+      }\n+\n+      String file = sourceMapRoot.getString(\"file\");\n+      if (file.isEmpty()) {\n+        throw new SourceMapParseException(\"File entry is missing or empty\");\n+      }\n+\n+      lineCount = sourceMapRoot.getInt(\"lineCount\");\n+      String lineMap = sourceMapRoot.getString(\"mappings\");\n+\n+      sources = getJavaStringArray(sourceMapRoot.getJSONArray(\"sources\"));\n+      names = getJavaStringArray(sourceMapRoot.getJSONArray(\"names\"));\n+\n+      lines = Lists.newArrayListWithCapacity(lineCount);\n+\n+      new MappingBuilder(lineMap).build();\n+    } catch (JSONException ex) {\n+      throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n+    }\n+  }\n+\n+  @Override\n+  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n+    // Normalize the line and column numbers to 0.\n+    lineNumber--;\n+    column--;\n+\n+    if (lineNumber < 0 || lineNumber >= lines.size()) {\n+      return null;\n+    }\n+\n+    Preconditions.checkState(lineNumber >= 0);\n+    Preconditions.checkState(column >= 0);\n+\n+\n+    // If the line is empty return the previous mapping.\n+    if (lines.get(lineNumber) == null) {\n+      return getPreviousMapping(lineNumber);\n+    }\n+\n+    ArrayList<Entry> entries = lines.get(lineNumber);\n+    // No empty lists.\n+    Preconditions.checkState(entries.size() > 0);\n+    if (entries.get(0).getGeneratedColumn() > column) {\n+      return getPreviousMapping(lineNumber);\n+    }\n+\n+    int index = search(entries, column, 0, entries.size() -1);\n+    Preconditions.checkState(index >= 0, \"unexpected:\"+index);\n+    return getOriginalMappingForEntry(entries.get(index));\n+  }\n+\n+  private String[] getJavaStringArray(JSONArray array) throws JSONException {\n+    int len = array.length();\n+    String[] result = new String[len];\n+    for(int i = 0; i< len; i++) {\n+      result[i] = array.getString(i);\n+    }\n+    return result;\n+  }\n+\n+  private class MappingBuilder {\n+    private final static int MAX_ENTRY_VALUES = 5;\n+    private final StringCharIterator content;\n+    private int line = 0;\n+    private int previousCol = 0;\n+    private int previousSrcId = 0;\n+    private int previousSrcLine = 0;\n+    private int previousSrcColumn = 0;\n+    private int previousNameId = 0;\n+\n+    MappingBuilder(String lineMap) {\n+      this.content = new StringCharIterator(lineMap);\n+    }\n+\n+    void build() {\n+      int [] temp = new int[MAX_ENTRY_VALUES];\n+      ArrayList<Entry> entries = new ArrayList<Entry>();\n+      while (content.hasNext()) {\n+        // ';' denotes a new line.\n+        if (tryConsumeToken(';')) {\n+          // The line is complete, store the result for the line,\n+          // null if the line is empty.\n+          ArrayList<Entry> result;\n+          if (entries.size() > 0) {\n+            result = entries;\n+            // A new array list for the next line.\n+            entries = new ArrayList<Entry>();\n+          } else {\n+            result = null;\n+          }\n+          lines.add(result);\n+          entries.clear();\n+          line++;\n+          previousCol = 0;\n+        } else {\n+          // grab the next entry for the current line.\n+          int entryValues = 0;\n+          while (!entryComplete()) {\n+            temp[entryValues] = nextValue();\n+            entryValues++;\n+          }\n+          Entry entry = decodeEntry(temp, entryValues);\n+\n+          validateEntry(entry);\n+          entries.add(entry);\n+\n+          // Consume the separating token, if there is one.\n+          tryConsumeToken(',');\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Sanity check the entry.\n+     */\n+    private void validateEntry(Entry entry) {\n+      Preconditions.checkState(line < lineCount);\n+      Preconditions.checkState(entry.getSourceFileId() == UNMAPPED\n+          || entry.getSourceFileId() < sources.length);\n+      Preconditions.checkState(entry.getNameId() == UNMAPPED\n+          || entry.getNameId() < names.length);\n+    }\n+\n+    /**\n+     * Decodes the next entry, using the previous encountered values to\n+     * decode the relative values.\n+     *\n+     * @param vals An array of integers that represent values in the entry.\n+     * @param entryValues The number of entries in the array.\n+     * @return The entry object.\n+     */\n+    private Entry decodeEntry(int[] vals, int entryValues) {\n+      Entry entry;\n+      switch (entryValues) {\n+        // The first values, if present are in the following order:\n+        //   0: the starting column in the current line of the generated file\n+        //   1: the id of the original source file\n+        //   2: the starting line in the original source\n+        //   3: the starting column in the original source\n+        //   4: the id of the original symbol name\n+        // The values are relative to the last encountered value for that field.\n+        // Note: the previously column value for the generated file is reset\n+        // to '0' when a new line is encountered.  This is done in the 'build'\n+        // method.\n+\n+        case 1:\n+          // An unmapped section of the generated file.\n+          entry = new UnmappedEntry(\n+              vals[0] + previousCol);\n+          // Set the values see for the next entry.\n+          previousCol = entry.getGeneratedColumn();\n+          return entry;\n+\n+        case 4:\n+          // A mapped section of the generated file.\n+          entry = new UnnamedEntry(\n+              vals[0] + previousCol,\n+              vals[1] + previousSrcId,\n+              vals[2] + previousSrcLine,\n+              vals[3] + previousSrcColumn);\n+          // Set the values see for the next entry.\n+          previousCol = entry.getGeneratedColumn();\n+          previousSrcId = entry.getSourceFileId();\n+          previousSrcLine = entry.getSourceLine();\n+          previousSrcColumn = entry.getSourceColumn();\n+          return entry;\n+\n+        case 5:\n+          // A mapped section of the generated file, that has an associated\n+          // name.\n+          entry = new NamedEntry(\n+              vals[0] + previousCol,\n+              vals[1] + previousSrcId,\n+              vals[2] + previousSrcLine,\n+              vals[3] + previousSrcColumn,\n+              vals[4] + previousNameId);\n+          // Set the values see for the next entry.\n+          previousCol = entry.getGeneratedColumn();\n+          previousSrcId = entry.getSourceFileId();\n+          previousSrcLine = entry.getSourceLine();\n+          previousSrcColumn = entry.getSourceColumn();\n+          previousNameId = entry.getNameId();\n+          return entry;\n+\n+        default:\n+          throw new IllegalStateException(\n+              \"Unexpected number of values for entry:\" + entryValues);\n+      }\n+    }\n+\n+    private boolean tryConsumeToken(char token) {\n+      if (content.hasNext() && content.peek() == token) {\n+        // consume the comma\n+        content.next();\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean entryComplete() {\n+      if (!content.hasNext()) {\n+        return true;\n+      }\n+\n+      char c = content.peek();\n+      return (c == ';' || c == ',');\n+    }\n+\n+    private int nextValue() {\n+      return Base64VLQ.decode(content);\n+    }\n+  }\n+\n+  /**\n+   * Perform a binary search on the array to find a section that covers\n+   * the target column.\n+   */\n+  private int search(ArrayList<Entry> entries, int target, int start, int end) {\n+    while (true) {\n+      int mid = ((end - start) / 2) + start;\n+      int compare = compareEntry(entries, mid, target);\n+      if (compare == 0) {\n+        return mid;\n+      } else if (compare < 0) {\n+        // it is in the upper half\n+        start = mid + 1;\n+        if (start > end) {\n+          return end;\n+        }\n+      } else {\n+        // it is in the lower half\n+        end = mid - 1;\n+        if (end < start) {\n+          return end;\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Compare an array entry's column value to the taget column value.\n+   */\n+  private int compareEntry(ArrayList<Entry> entries, int entry, int target) {\n+    return entries.get(entry).getGeneratedColumn() - target;\n+  }\n+\n+  /**\n+   * Returns the mapping entry that proceeds the supplied line or null if no\n+   * such entry exists.\n+   */\n+  private OriginalMapping getPreviousMapping(int lineNumber) {\n+    do {\n+      if (lineNumber == 0) {\n+        return null;\n+      }\n+      lineNumber--;\n+    } while (lines.get(lineNumber) == null);\n+    ArrayList<Entry> entries = lines.get(lineNumber);\n+    return getOriginalMappingForEntry(entries.get(entries.size() -1));\n+  }\n+\n+  /**\n+   * Creates an \"OriginalMapping\" object for the given entry object.\n+   */\n+  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n+    if (entry.getSourceFileId() == UNMAPPED) {\n+      return null;\n+    } else {\n+      Builder x = OriginalMapping.newBuilder()\n+        .setOriginalFile(sources[entry.getSourceFileId()])\n+        .setLineNumber(entry.getSourceLine())\n+        .setColumnPosition(entry.getSourceColumn());\n+      if (entry.getNameId() != UNMAPPED) {\n+        x.setIdentifier(names[entry.getNameId()]);\n+      }\n+      return x.build();\n+    }\n+  }\n+\n+  /**\n+   * A implementation of the Base64VLQ CharIterator used for decoding the\n+   * mappings encoded in the JSON string.\n+   */\n+  private static class StringCharIterator implements CharIterator {\n+    final String content;\n+    final int length;\n+    int current = 0;\n+\n+    StringCharIterator(String content) {\n+      this.content = content;\n+      this.length = content.length();\n+    }\n+\n+    public char next() {\n+      return content.charAt(current++);\n+    }\n+\n+    char peek() {\n+      return content.charAt(current);\n+    }\n+\n+    public boolean hasNext() {\n+      return  current < length;\n+    }\n+  }\n+\n+  /**\n+   * Represents a mapping entry in the source map.\n+   */\n+  private interface Entry {\n+    int getGeneratedColumn();\n+    int getSourceFileId();\n+    int getSourceLine();\n+    int getSourceColumn();\n+    int getNameId();\n+  }\n+\n+  /**\n+   * This class represents a portion of the generated file, that is not mapped\n+   * to a section in the original source.\n+   */\n+  private static class UnmappedEntry implements Entry {\n+    private final int column;\n+\n+    UnmappedEntry(int column) {\n+      this.column = column;\n+    }\n+\n+    @Override\n+    public int getGeneratedColumn() {\n+      return column;\n+    }\n+\n+    @Override\n+    public int getSourceFileId() {\n+      return UNMAPPED;\n+    }\n+\n+    @Override\n+    public int getSourceLine() {\n+      return UNMAPPED;\n+    }\n+\n+    @Override\n+    public int getSourceColumn() {\n+      return UNMAPPED;\n+    }\n+\n+    @Override\n+    public int getNameId() {\n+      return UNMAPPED;\n+    }\n+  }\n+\n+  /**\n+   * This class represents a portion of the generated file, that is mapped\n+   * to a section in the original source.\n+   */\n+  private static class UnnamedEntry extends UnmappedEntry {\n+    private final int srcFile;\n+    private final int srcLine;\n+    private final int srcColumn;\n+\n+    UnnamedEntry(int column, int srcFile, int srcLine, int srcColumn) {\n+      super(column);\n+      this.srcFile = srcFile;\n+      this.srcLine = srcLine;\n+      this.srcColumn = srcColumn;\n+    }\n+\n+    @Override\n+    public int getSourceFileId() {\n+      return srcFile;\n+    }\n+\n+    @Override\n+    public int getSourceLine() {\n+      return srcLine;\n+    }\n+\n+    @Override\n+    public int getSourceColumn() {\n+      return srcColumn;\n+    }\n+\n+    @Override\n+    public int getNameId() {\n+      return UNMAPPED;\n+    }\n+  }\n+\n+  /**\n+   * This class represents a portion of the generated file, that is mapped\n+   * to a section in the original source, and is associated with a name.\n+   */\n+  private static class NamedEntry extends UnnamedEntry {\n+    private final int name;\n+\n+    NamedEntry(int column, int srcFile, int srcLine, int srcColumn, int name) {\n+      super(column, srcFile, srcLine, srcColumn);\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public int getNameId() {\n+      return name;\n+    }\n+  }\n+}\n--- a/src/com/google/debugging/sourcemap/SourceMapFormat.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapFormat.java\n    V1,\n \n    /** V2: A more compact format */\n-   V2;\n+   V2,\n+\n+   /** V3: An even more compact format */\n+   V3;\n }\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorFactory.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorFactory.java\n       case DEFAULT:\n       case V2:\n         return new SourceMapGeneratorV2();\n+      case V3:\n+        return new SourceMapGeneratorV3();\n       default:\n         throw new IllegalStateException(\"unsupported source map format\");\n     }\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n   private boolean validate = false;\n \n   private final static int UNMAPPED = -1;\n-\n-  /**\n-   *  A map used to convert integer values in the range 0-63 to their base64\n-   *  values.\n-   */\n-  private static final String BASE64_MAP =\n-      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n-      \"abcdefghijklmnopqrstuvwxyz\" +\n-      \"0123456789+/\";\n \n   /**\n    * A pre-order traversal ordered list of mappings stored in this map.\n       do {\n         int charValue = value & 63; // base64 chars\n         value = value >>> 6; // get the next value;\n-        chars[size++] = BASE64_MAP.charAt(charValue);\n+        chars[size++] = Base64.toBase64(charValue);\n       } while (value > 0);\n \n       StringBuilder sb = new StringBuilder(size);\n \n       while (minimumSize > size) {\n-        sb.append(BASE64_MAP.charAt(0));\n+        sb.append(Base64.toBase64(0));\n         minimumSize--;\n       }\n       while (size > 0) {\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapGeneratorV3 implements SourceMapGenerator {\n+\n+  private final static int UNMAPPED = -1;\n+\n+\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n+   */\n+  private List<Mapping> mappings = Lists.newArrayList();\n+\n+  /**\n+   * A map of source names to source name index\n+   */\n+  private LinkedHashMap<String, Integer> sourceFileMap =\n+      Maps.newLinkedHashMap();\n+\n+  /**\n+   * A map of source names to source name index\n+   */\n+  private LinkedHashMap<String, Integer> originalNameMap =\n+      Maps.newLinkedHashMap();\n+\n+  /**\n+   * Cache of the last mappings source name.\n+   */\n+  private String lastSourceFile = null;\n+\n+  /**\n+   * Cache of the last mappings source name index.\n+   */\n+  private int lastSourceFileIndex = -1;\n+\n+  /**\n+   * For validation store the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * buffer being used to generated the compiled source file.\n+   */\n+  private FilePosition offsetPosition = new FilePosition(0, 0);\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * generated the compiled source file by the addition of a\n+   * an output wrapper prefix.\n+   */\n+  private FilePosition prefixPosition = new FilePosition(0, 0);\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  public void reset() {\n+    mappings.clear();\n+    lastMapping = null;\n+    sourceFileMap.clear();\n+    originalNameMap.clear();\n+    lastSourceFile = null;\n+    lastSourceFileIndex = -1;\n+    offsetPosition = new FilePosition(0, 0);\n+    prefixPosition = new FilePosition(0, 0);\n+  }\n+\n+  /**\n+   * @param validate Whether to perform (potentially costly) validation on the\n+   * generated source map.\n+   */\n+  public void validate(boolean validate) {\n+    // Nothing currently.\n+  }\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is written. This ensures that the source map is adjusted for the\n+   * change in character offsets.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  public void setWrapperPrefix(String prefix) {\n+    // Determine the current line and character position.\n+    int prefixLine = 0;\n+    int prefixIndex = 0;\n+\n+    for (int i = 0; i < prefix.length(); ++i) {\n+      if (prefix.charAt(i) == '\\n') {\n+        prefixLine++;\n+        prefixIndex = 0;\n+      } else {\n+        prefixIndex++;\n+      }\n+    }\n+\n+    prefixPosition = new FilePosition(prefixLine, prefixIndex);\n+  }\n+\n+  /**\n+   * Sets the source code that exists in the buffer for which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  public void setStartingPosition(int offsetLine, int offsetIndex) {\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n+    offsetPosition = new FilePosition(offsetLine, offsetIndex);\n+  }\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   * @param startPosition The position on the starting line\n+   * @param endPosition The position on the ending line.\n+   */\n+  public void addMapping(\n+      String sourceName, @Nullable String symbolName,\n+      FilePosition sourceStartPosition,\n+      FilePosition startPosition, FilePosition endPosition) {\n+\n+    // Don't bother if there is not sufficient information to be useful.\n+    if (sourceName == null || sourceStartPosition.getLine() < 0) {\n+      return;\n+    }\n+\n+    FilePosition adjustedStart = startPosition;\n+    FilePosition adjustedEnd = endPosition;\n+\n+    if (offsetPosition.getLine() != 0\n+        || offsetPosition.getColumn() != 0) {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLine();\n+      int startOffsetPosition = offsetPosition.getColumn();\n+      int endOffsetPosition = offsetPosition.getColumn();\n+\n+      if (startPosition.getLine() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLine() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      adjustedStart = new FilePosition(\n+          startPosition.getLine() + offsetLine,\n+          startPosition.getColumn() + startOffsetPosition);\n+\n+      adjustedEnd = new FilePosition(\n+          endPosition.getLine() + offsetLine,\n+          endPosition.getColumn() + endOffsetPosition);\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = sourceName;\n+    mapping.originalPosition = sourceStartPosition;\n+    mapping.originalName = symbolName;\n+    mapping.startPosition = adjustedStart;\n+    mapping.endPosition = adjustedEnd;\n+\n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLine();\n+      int lastColumn = lastMapping.startPosition.getColumn();\n+      int nextLine = mapping.startPosition.getLine();\n+      int nextColumn = mapping.startPosition.getColumn();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn);\n+    }\n+\n+    lastMapping = mapping;\n+    mappings.add(mapping);\n+  }\n+\n+  /**\n+   * Writes out the source map in the following format (line numbers are for\n+   * reference only and are not part of the format):\n+   *\n+   * 1.  {\n+   * 2.    version: 3,\n+   * 3.    file: \"out.js\"\n+   * 4.    lineCount: 2\n+   * 5.    lineMaps: [\n+   * 6.        \"ABAAA\",\n+   * 7.        \"ABAA\"\n+   * 8.     ],\n+   * 9.    sourceRoot: \"\",\n+   * 10.   sources: [\"foo.js\", \"bar.js\"],\n+   * 11.   names: [\"src\", \"maps\", \"are\", \"fun\"],\n+   * 12.   mappings: \"a;;abcde,abcd,a;\"\n+   * 16.  }\n+   *\n+   * Line 1: The entire file is a single JSON object\n+   * Line 2: File revision (always the first entry in the object)\n+   * Line 3: The name of the file that this source map is associated with.\n+   * Line 4: The number of lines represented in the sourcemap.\n+   * Line 5: \"lineMaps\" field is a JSON array, where each entry represents a\n+   *     line in the generated text.\n+   * Line 6: A line entry, representing a series of line segments, where each\n+   *     segment encodes an mappings-id and repetition count.\n+   * Line 9: An optional source root, useful for relocating source files on a\n+   *     server or removing repeated prefix values in the \"sources\" entry.\n+   * Line 10: A list of sources used by the \"mappings\" entry relative to the\n+   *     sourceRoot.\n+   * Line 11: A list of symbol names used by the \"mapping\" entry.  This list\n+   *     may be incomplete.\n+   * Line 12: The mappings field.\n+   */\n+  public void appendTo(Appendable out, String name) throws IOException {\n+    int maxLine = prepMappings();\n+\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"3\");\n+    appendField(out, \"file\", escapeString(name));\n+    appendField(out, \"lineCount\", String.valueOf(maxLine + 1));\n+\n+    // Add the mappings themselves.\n+    appendFieldStart(out, \"mappings\");\n+    // out.append(\"[\");\n+    (new LineMapper(out)).appendLineMappings();\n+    // out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Files names\n+    appendFieldStart(out, \"sources\");\n+    out.append(\"[\");\n+    addSourceNameMap(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Files names\n+    appendFieldStart(out, \"names\");\n+    out.append(\"[\");\n+    addSymbolNameMap(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n+\n+  /**\n+   * Writes the source name map to 'out'.\n+   */\n+  private void addSourceNameMap(Appendable out) throws IOException {\n+    addNameMap(out, sourceFileMap);\n+  }\n+\n+  /**\n+   * Writes the source name map to 'out'.\n+   */\n+  private void addSymbolNameMap(Appendable out) throws IOException {\n+    addNameMap(out, originalNameMap);\n+  }\n+\n+  private void addNameMap(Appendable out, Map<String, Integer> map)\n+      throws IOException {\n+    int i = 0;\n+    for (Entry<String, Integer> entry : map.entrySet()) {\n+      String key = entry.getKey();\n+      if (i != 0) {\n+        out.append(\",\");\n+      }\n+      out.append(escapeString(key));\n+      i++;\n+    }\n+  }\n+\n+  /**\n+   * Escapes the given string for JSON.\n+   */\n+  private static String escapeString(String value) {\n+    return Util.escapeString(value);\n+  }\n+\n+  // Source map field helpers.\n+\n+  private static void appendFirstField(\n+      Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private static void appendField(Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\",\\n\");\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private static void appendFieldStart(Appendable out, String name)\n+      throws IOException {\n+    appendField(out, name, \"\");\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  private static void appendFieldEnd(Appendable out)\n+     throws IOException {\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    int sourceId = 0;\n+    int nameId = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLine();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLine();\n+  }\n+\n+  /**\n+   * A mapping from a given position in an input source file to a given position\n+   * in the generated code.\n+   */\n+  static class Mapping {\n+    /**\n+     * A unique ID for this mapping for record keeping purposes.\n+     */\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The source file index.\n+     */\n+    String sourceFile;\n+\n+    /**\n+     * The position of the code in the input source file. Both\n+     * the line number and the character index are indexed by\n+     * 1 for legacy reasons via the Rhino Node class.\n+     */\n+    FilePosition originalPosition;\n+\n+    /**\n+     * The starting position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition startPosition;\n+\n+    /**\n+     * The ending position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition endPosition;\n+\n+    /**\n+     * The original name of the token found at the position\n+     * represented by this mapping (if any).\n+     */\n+    String originalName;\n+\n+    /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+\n+    MappingTraversal() {\n+    }\n+\n+    // Append the line mapping entries.\n+    void traverse(MappingVisitor v) throws IOException {\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          maybeVisit(v, previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        maybeVisitParent(v, parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        maybeVisit(v, m);\n+      }\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(FilePosition p) {\n+      return p.getLine() + prefixPosition.getLine();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(FilePosition p) {\n+      int rawLine = p.getLine();\n+      int rawCol = p.getColumn();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getColumn();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLine();\n+      int l2 = m2.startPosition.getLine();\n+      int c1 = m1.endPosition.getColumn();\n+      int c2 = m2.startPosition.getColumn();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, m, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        Preconditions.checkState(false);\n+        return;\n+      }\n+\n+      v.visit(m, line, col, nextLine, nextCol);\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n+\n+  /**\n+   * To facilitate incremental compiles, create a source map that is built\n+   * piecemeal from other source maps.\n+   * @throws IOException\n+   */\n+  @Override\n+  public void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections)\n+      throws IOException {\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"3\");\n+    appendField(out, \"file\", escapeString(name));\n+\n+    // Add the line character maps.\n+    appendFieldStart(out, \"sections\");\n+    out.append(\"[\\n\");\n+    boolean first = true;\n+    Long offset = new Long(0);\n+    for (SourceMapSection section : appSections) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        out.append(\",\\n\");\n+      }\n+      out.append(\"{\\n\");\n+      appendFirstField(out, \"offset\", offset.toString());\n+      appendField(out, \"url\", escapeString(section.getSectionUrl()));\n+      out.append(\"\\n}\");\n+\n+      offset += section.getLength();\n+    }\n+\n+    out.append(\"\\n]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n+\n+  private int getSourceId(String sourceName) {\n+    if (sourceName != lastSourceFile) {\n+      lastSourceFile = sourceName;\n+      Integer index = sourceFileMap.get(sourceName);\n+      if (index != null) {\n+        lastSourceFileIndex = index;\n+      } else {\n+        lastSourceFileIndex = sourceFileMap.size();\n+        sourceFileMap.put(sourceName, lastSourceFileIndex);\n+      }\n+    }\n+    return lastSourceFileIndex;\n+  }\n+\n+  private int getNameId(String symbolName) {\n+    int originalNameIndex;\n+    Integer index = originalNameMap.get(symbolName);\n+    if (index != null) {\n+      originalNameIndex = index;\n+    } else {\n+      originalNameIndex = originalNameMap.size();\n+      originalNameMap.put(symbolName, originalNameIndex);\n+    }\n+    return originalNameIndex;\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n+    // The destination.\n+    private final Appendable out;\n+\n+    private int previousLine = -1;\n+    private int previousColumn = 0;\n+\n+    // Previous values used for storing relative ids.\n+    private int previousSourceFileId;\n+    private int previousSourceLine;\n+    private int previousSourceColumn;\n+    private int previousNameId;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+\n+      if (previousLine != line) {\n+        previousColumn = 0;\n+      }\n+\n+      if (line != nextLine || col != nextCol) {\n+        if (previousLine == line) { // not the first entry for the line\n+          out.append(',');\n+        }\n+        writeEntry(m, col);\n+        previousLine = line;\n+        previousColumn = col;\n+      }\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          break;\n+        }\n+\n+        closeLine(false);\n+        openLine(false);\n+      }\n+    }\n+\n+    /**\n+     * Writes an entry for the given column (of the generated text) and\n+     * associated mapping.\n+     * The values are stored as relative to the last seen values for each\n+     * field and encoded as Base64VLQs.\n+     */\n+    void writeEntry(Mapping m, int column) throws IOException {\n+      // The relative generated column number\n+      Base64VLQ.encode(out, column - previousColumn);\n+      previousColumn = column;\n+      if (m != null) {\n+        // The relative source file id\n+        int sourceId = getSourceId(m.sourceFile);\n+        Base64VLQ.encode(out, sourceId - previousSourceFileId);\n+        previousSourceFileId = sourceId;\n+\n+        // The relative source file line and column\n+        int srcline = m.originalPosition.getLine();\n+        int srcColumn = m.originalPosition.getColumn();\n+        Base64VLQ.encode(out, srcline - previousSourceLine);\n+        previousSourceLine = srcline;\n+\n+        Base64VLQ.encode(out, srcColumn - previousSourceColumn);\n+        previousSourceColumn = srcColumn;\n+\n+        if (m.originalName != null) {\n+          // The relative id for the associated symbol name\n+          int nameId = getNameId(m.originalName);\n+          Base64VLQ.encode(out, (nameId - previousNameId));\n+          previousNameId = nameId;\n+        }\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      // Start the first line.\n+      openLine(true);\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine(true);\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine(boolean firstEntry) throws IOException {\n+      if (firstEntry) {\n+        out.append('\\\"');\n+      }\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine(boolean finalEntry) throws IOException {\n+      out.append(';');\n+      if (finalEntry) {\n+        out.append('\\\"');\n+      }\n+    }\n+  }\n+\n+}\n--- a/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n  * @author jschorr@google.com (Joseph Schorr)\n  */\n class SourceMapLineDecoder {\n-  /**\n-   *  A map used to convert integer values in the range 0-63 to their base64\n-   *  values.\n-   */\n-  private static final String BASE64_MAP =\n-      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n-      \"abcdefghijklmnopqrstuvwxyz\" +\n-      \"0123456789+/\";\n \n   /**\n    * Decodes a line in a character map into a list of mapping IDs.\n    * Build base64 number a digit at a time, most significant digit first.\n    */\n   private static int addBase64Digit(char digit, int previousValue) {\n-    return (previousValue * 64) + BASE64_MAP.indexOf(digit);\n+    return (previousValue * 64) + Base64.fromBase64(digit);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n        @Override SourceMap getInstance() {\n          return new SourceMap(\n            SourceMapGeneratorFactory.getInstance(SourceMapFormat.V2));\n-       }\n+        }\n+     },\n+     V3 {\n+       @Override SourceMap getInstance() {\n+         return new SourceMap(\n+           SourceMapGeneratorFactory.getInstance(SourceMapFormat.V3));\n+        }\n      };\n      abstract SourceMap getInstance();\n   }\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/Base64Test.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class Base64Test extends TestCase {\n+  public void testBase64() {\n+    for (int i = 0; i < 64; i++) {\n+      testValue(i);\n+    }\n+  }\n+\n+  private void testValue(int value) {\n+    assertEquals(value, Base64.fromBase64(Base64.toBase64(value)));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/Base64VLQTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class Base64VLQTest extends TestCase {\n+  public void testBase64VLQSelectedValues1() {\n+    for (int i = 0; i < 63; i++) {\n+      testValue(i);\n+    }\n+  }\n+\n+  public void testBase64VLQSelectedValues2() {\n+    int base = 1;\n+    for (int i = 0; i < 30; i++) {\n+      testValue(base-1);\n+      testValue(base);\n+      base *= 2;\n+    }\n+  }\n+\n+  public void testBase64VLQSelectedSignedValues1() {\n+    for (int i = -(64*64-1); i < (64*64-1); i++) {\n+      testValue(i);\n+    }\n+  }\n+\n+  public void testBase64VLQSelectedSignedValues2() {\n+    int base = 1;\n+    for (int i = 0; i < 30; i++) {\n+      testValue(base-1);\n+      testValue(base);\n+      base *= 2;\n+    }\n+    base = -1;\n+    for (int i = 0; i < 30; i++) {\n+      testValue(base-1);\n+      testValue(base);\n+      base *= 2;\n+    }\n+  }\n+\n+  static class CharIteratorImpl implements Base64VLQ.CharIterator {\n+    private int current;\n+    private int length;\n+    private CharSequence cs;\n+\n+    void set(CharSequence sb) {\n+      this.current = 0;\n+      this.length = sb.length();\n+      this.cs = sb;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      return current < length;\n+    }\n+\n+    @Override\n+    public char next() {\n+      return cs.charAt(current++);\n+    }\n+  }\n+\n+  // Disable this test if it is flaky.\n+  public void testSpeed() {\n+    long start = System.currentTimeMillis();\n+    CharIteratorImpl ci = new CharIteratorImpl();\n+    try {\n+      StringBuilder sb = new StringBuilder();\n+      for (int i = 0; i < 1000000; i++) {\n+        Base64VLQ.encode(sb, i);\n+        ci.set(sb);\n+        int result = Base64VLQ.decode(ci);\n+        assertEquals(i, result);\n+        sb.setLength(0);\n+      }\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"failed.\", e);\n+    }\n+    long end = System.currentTimeMillis();\n+    // Was 200ms or less, use a larger number to prevent flakiness\n+    assertTrue(\"too slow\", end-start < 1000);\n+  }\n+\n+  private void testValue(int value) {\n+    try {\n+      StringBuilder sb = new StringBuilder();\n+      Base64VLQ.encode(sb, value);\n+      CharIteratorImpl ci = new CharIteratorImpl();\n+      ci.set(sb);\n+      int result = Base64VLQ.decode(ci);\n+      assertEquals(value, result);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"failed for value \" + value, e);\n+    }\n+  }\n+\n+\n+}\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV1Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV1Test.java\n \n package com.google.debugging.sourcemap;\n \n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.LinkedListMultimap;\n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Multimap;\n-import com.google.javascript.jscomp.Compiler;\n-import com.google.javascript.jscomp.CompilerOptions;\n-import com.google.javascript.jscomp.JSSourceFile;\n-import com.google.javascript.jscomp.Result;\n import com.google.javascript.jscomp.SourceMap;\n-import com.google.javascript.jscomp.SourceMap.DetailLevel;\n import com.google.javascript.jscomp.SourceMap.Format;\n-\n-import junit.framework.TestCase;\n-\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.util.Collection;\n-import java.util.Map;\n \n /**\n  * Tests for {@link SourceMap}.\n  *\n  */\n-public class SourceMapGeneratorV1Test extends TestCase {\n-  private static final JSSourceFile[] EXTERNS = {\n-      JSSourceFile.fromCode(\"externs\", \"\")\n-  };\n-\n-  private DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+public class SourceMapGeneratorV1Test extends SourceMapTestCase {\n+\n+  @Override\n+  SourceMapConsumer getSourceMapConsumer() {\n+    return new SourceMapConsumerV1();\n+  }\n+\n+  @Override\n+  Format getSourceMapFormat() {\n+    return SourceMap.Format.V1;\n+  }\n \n   @Override\n   public void setUp() {\n \n     assertEquals(files1, files2);\n   }\n-\n-  /**\n-   * Creates a source map for the given JS code and asserts it is\n-   * equal to the expected golden map.\n-   */\n-  private void checkSourceMap(String js, String expectedMap)\n-      throws IOException {\n-    checkSourceMap(\"testcode\", js, expectedMap);\n-  }\n-\n-  private String getSourceMap(RunResult result) throws IOException {\n-    StringBuilder sb = new StringBuilder();\n-    result.sourceMap.appendTo(sb, \"testcode\");\n-    return sb.toString();\n-  }\n-\n-  private void checkSourceMap(String fileName, String js, String expectedMap)\n-      throws IOException {\n-    RunResult result = compile(js, fileName);\n-    assertEquals(expectedMap, result.sourceMapFileContent);\n-    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n-  }\n-\n-  private static class RunResult {\n-    String generatedSource;\n-    SourceMap sourceMap;\n-    public String sourceMapFileContent;\n-  }\n-\n-  private static class Token {\n-    String tokenName;\n-    FilePosition position;\n-  }\n-\n-  /**\n-   * Finds the all the __XX__ tokens in the given Javascript\n-   * string.\n-   */\n-  private Map<String, Token> findTokens(String js) {\n-    Map<String, Token> tokens = Maps.newLinkedHashMap();\n-\n-    int currentLine = 0;\n-    int positionOffset = 0;\n-\n-    for (int i = 0; i < js.length(); ++i) {\n-      char current = js.charAt(i);\n-\n-      if (current == '\\n') {\n-        positionOffset = i + 1;\n-        currentLine++;\n-        continue;\n-      }\n-\n-      if (current == '_' && (i < js.length() - 5)) {\n-        // Check for the _ token.\n-        if (js.charAt(i + 1) != '_') {\n-          continue;\n-        }\n-\n-        // Loop until we have another _ token.\n-        String tokenName = \"\";\n-\n-        int j = i + 2;\n-        for (; j < js.length(); ++j) {\n-          if (js.charAt(j) == '_') {\n-            break;\n-          }\n-\n-          tokenName += js.charAt(j);\n-        }\n-\n-        if (tokenName.length() > 0) {\n-          Token token = new Token();\n-          token.tokenName = tokenName;\n-          int currentPosition = i - positionOffset;\n-          token.position = new FilePosition(currentLine, currentPosition);\n-          tokens.put(tokenName, token);\n-        }\n-\n-        i = j;\n-      }\n-    }\n-\n-    return tokens;\n-  }\n-\n-  private void compileAndCheck(String js) {\n-    RunResult result = compile(js);\n-\n-    // Find all instances of the __XXX__ pattern in the original\n-    // source code.\n-    Map<String, Token> originalTokens = findTokens(js);\n-\n-    // Find all instances of the __XXX__ pattern in the generated\n-    // source code.\n-    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n-\n-    // Ensure that the generated instances match via the source map\n-    // to the original source code.\n-\n-    // Ensure the token counts match.\n-    assertEquals(originalTokens.size(), resultTokens.size());\n-\n-    SourceMapReader reader = new SourceMapReader();\n-    try {\n-      reader.parse(result.sourceMapFileContent);\n-    } catch (SourceMapParseException e) {\n-      throw new RuntimeException(\"unexpected exception\", e);\n-    }\n-\n-    // Map the tokens from the generated source back to the\n-    // input source and ensure that the map is correct.\n-    for (Token token : resultTokens.values()) {\n-      OriginalMapping mapping = reader.getMappingForLine(\n-          token.position.getLine() + 1,\n-          token.position.getColumn() + 1);\n-\n-      assertNotNull(mapping);\n-\n-      // Find the associated token in the input source.\n-      Token inputToken = originalTokens.get(token.tokenName);\n-      assertNotNull(inputToken);\n-\n-      // Ensure that the map correctly points to the token (we add 1\n-      // to normalize versus the Rhino line number indexing scheme).\n-      assertEquals(mapping.position.getLine(),\n-                   inputToken.position.getLine() + 1);\n-\n-      // Ensure that if the token name does not being with an 'STR' (meaning a\n-      // string) it has an original name.\n-      if (!inputToken.tokenName.startsWith(\"STR\")) {\n-        assertTrue(!mapping.originalName.isEmpty());\n-      }\n-\n-      // Ensure that if the mapping has a name, it matches the token.\n-      if (!mapping.originalName.isEmpty()) {\n-        assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n-      }\n-    }\n-  }\n-\n-  private RunResult compile(String js) {\n-    return compile(js, \"testcode\");\n-  }\n-\n-  private RunResult compile(String js, String fileName) {\n-    return compile(js, fileName, null, null);\n-  }\n-\n-  private RunResult compile(String js1, String fileName1, String js2,\n-      String fileName2) {\n-    Compiler compiler = new Compiler();\n-    CompilerOptions options = new CompilerOptions();\n-    options.sourceMapFormat = Format.V1;\n-    options.sourceMapOutputPath = \"testcode_source_map.out\";\n-    options.sourceMapDetailLevel = detailLevel;\n-\n-    // Turn on IDE mode to get rid of optimizations.\n-    options.ideMode = true;\n-\n-    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n-\n-    if (js2 != null && fileName2 != null) {\n-      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n-                                   JSSourceFile.fromCode(fileName2, js2) };\n-      inputs = multiple;\n-    }\n-\n-    Result result = compiler.compile(EXTERNS, inputs, options);\n-\n-    assertTrue(result.success);\n-    String source = compiler.toSource();\n-\n-    StringBuilder sb = new StringBuilder();\n-    try {\n-      result.sourceMap.appendTo(sb, \"testcode\");\n-    } catch (IOException e) {\n-      throw new RuntimeException(\"unexpected exception\", e);\n-    }\n-\n-    RunResult rr = new RunResult();\n-    rr.generatedSource = source;\n-    rr.sourceMap = result.sourceMap;\n-    rr.sourceMapFileContent = sb.toString();\n-    return rr;\n-  }\n-\n-  public static class SourceMapParseException extends IOException {\n-    private static final long serialVersionUID = 1L;\n-\n-    public SourceMapParseException(String message) {\n-      super(message);\n-    }\n-  }\n-\n-  public static class OriginalMapping {\n-    public final String srcfile;\n-    public final FilePosition position;\n-    public final String originalName;\n-\n-    OriginalMapping(String srcfile, int line, int column, String name) {\n-      this.srcfile = srcfile;\n-      this.position = new FilePosition(line, column);\n-      this.originalName = name;\n-    }\n-  }\n-\n-  /**\n-   * Class for parsing and representing a SourceMap\n-   * TODO(johnlenz): This would be best as a separate open-source component.\n-   *     Remove this when it is.\n-   */\n-  public class SourceMapReader {\n-    private static final String LINEMAP_HEADER = \"/** Begin line maps. **/\";\n-    private static final String FILEINFO_HEADER =\n-        \"/** Begin file information. **/\";\n-\n-    private static final String DEFINITION_HEADER =\n-        \"/** Begin mapping definitions. **/\";\n-\n-    /**\n-     * Internal class for parsing the SourceMap. Used to maintain parser\n-     * state in an easy to use instance.\n-     */\n-    private class ParseState {\n-      private Reader reader = null;\n-      private int currentPosition = 0;\n-\n-      public ParseState(String contents) {\n-        this.reader = new StringReader(contents);\n-      }\n-\n-      /**\n-       * Consumes a single character. If we have already reached the end\n-       * of the string, returns  -1.\n-       */\n-      private int consumeCharacter() {\n-        try {\n-          currentPosition++;\n-          return reader.read();\n-        } catch (IOException iox) {\n-          // Should never happen. Local reader.\n-          throw new IllegalStateException(\"IOException raised by reader\");\n-        }\n-      }\n-\n-      /**\n-       * Consumes the specified value found in the contents string. If the value\n-       * is not found, throws a parse exception.\n-       */\n-      public void consume(String value) throws SourceMapParseException {\n-         for (int i = 0; i < value.length(); ++i) {\n-          int ch = consumeCharacter();\n-\n-          if (ch == -1 || ch != value.charAt(i)) {\n-            fail(\"At character \" + currentPosition + \" expected: \" + value);\n-          }\n-        }\n-      }\n-\n-      /**\n-       * Consumes characters until the newline character is found or the string\n-       * has been entirely consumed. Returns the string consumed (without the\n-       * newline).\n-       */\n-      public String consumeUntilEOL() {\n-        StringBuilder sb = new StringBuilder();\n-\n-        int ch = -1;\n-\n-        while ((ch = consumeCharacter()) != '\\n') {\n-          if (ch == -1) {\n-            return sb.toString();\n-          }\n-\n-          sb.append((char) ch);\n-        }\n-\n-        return sb.toString();\n-      }\n-\n-      /**\n-       * Indicates that parsing has failed by throwing a parse exception.\n-       */\n-      public void fail(String message) throws SourceMapParseException {\n-        throw new SourceMapParseException(message);\n-      }\n-    }\n-\n-    /**\n-     * Mapping from a line number (0-indexed), to a list of mapping IDs, one for\n-     * each character on the line. For example, if the array for line 2 is\n-     * [4,,,,5,6,,,7], then there will be the entry:\n-     *\n-     * 1 => {4, 4, 4, 4, 5, 6, 6, 6, 7}\n-     *\n-     */\n-    private Multimap<Integer, Integer> characterMap = null;\n-\n-    /**\n-     * Map of Mapping IDs to the actual mapping object.\n-     */\n-    private Map<Integer, OriginalMapping> mappings = null;\n-\n-    public SourceMapReader() {\n-    }\n-\n-    /**\n-     * Parses the given contents containing a source map.\n-     */\n-    public void parse(String contents) throws SourceMapParseException {\n-      ParseState parser = new ParseState(contents);\n-\n-      characterMap = LinkedListMultimap.create();\n-      mappings = Maps.newHashMap();\n-\n-      try {\n-        // /** Begin line maps. **/{ count: 2 }\n-        parser.consume(LINEMAP_HEADER);\n-        String countJSON = parser.consumeUntilEOL();\n-\n-        JSONObject countObject = new JSONObject(countJSON);\n-\n-        if (!countObject.has(\"count\")) {\n-          parser.fail(\"Missing 'count'\");\n-        }\n-\n-        int lineCount = countObject.getInt(\"count\");\n-\n-        if (lineCount <= 0) {\n-          parser.fail(\"Count must be >= 1\");\n-        }\n-\n-        // [0,,,,,,1,2]\n-        for (int i = 0; i < lineCount; ++i) {\n-          String currentLine = parser.consumeUntilEOL();\n-\n-          // Blank lines are allowed in the spec to indicate no mapping\n-          // information for the line.\n-          if (currentLine.isEmpty()) {\n-            continue;\n-          }\n-\n-          JSONArray charArray = new JSONArray(currentLine);\n-\n-          int lastID = -1;\n-\n-          for (int j = 0; j < charArray.length(); ++j) {\n-            int mappingID = lastID;\n-\n-            if (!charArray.isNull(j)) {\n-              mappingID = charArray.optInt(j);\n-            }\n-\n-            // Save the current character's mapping.\n-            characterMap.put(i, mappingID);\n-\n-            lastID = mappingID;\n-          }\n-        }\n-\n-        // /** Begin file information. **/\n-        parser.consume(FILEINFO_HEADER);\n-\n-        if (parser.consumeUntilEOL().length() > 0) {\n-          parser.fail(\"Unexpected token after file information header\");\n-        }\n-\n-        // File information. Not used, so we just consume it.\n-        for (int i = 0; i < lineCount; ++i) {\n-          parser.consumeUntilEOL();\n-        }\n-\n-        // /** Begin mapping definitions. **/\n-        parser.consume(DEFINITION_HEADER);\n-\n-        if (parser.consumeUntilEOL().length() > 0) {\n-          parser.fail(\"Unexpected token after definition header\");\n-        }\n-\n-        String currentLine = null;\n-\n-        // ['d.js', 3, 78, 'foo']\n-        for (int mappingID = 0;\n-             (currentLine = parser.consumeUntilEOL()).length() > 0;\n-             ++mappingID) {\n-\n-          JSONArray mapArray = new JSONArray(currentLine);\n-\n-          if (mapArray.length() < 3) {\n-            parser.fail(\"Invalid mapping array\");\n-          }\n-\n-          OriginalMapping mapping = new OriginalMapping(\n-              mapArray.getString(0), // srcfile\n-              mapArray.getInt(1),    // line\n-              mapArray.getInt(2),    // column\n-              mapArray.optString(3, \"\")); // identifier\n-\n-          mappings.put(mappingID, mapping);\n-        }\n-      } catch (JSONException ex) {\n-        parser.fail(\"JSON parse exception: \" + ex);\n-      }\n-    }\n-\n-    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n-      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n-\n-      if (!characterMap.containsKey(lineNumber - 1)) {\n-        return null;\n-      }\n-\n-      Collection<Integer> mapIds = characterMap.get(lineNumber - 1);\n-\n-      int columnPosition = columnIndex - 1;\n-      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n-        return null;\n-      }\n-\n-      // TODO(user): Find a way to make this faster.\n-      Integer[] mapIdsAsArray = new Integer[mapIds.size()];\n-      mapIds.<Integer>toArray(mapIdsAsArray);\n-\n-      int mapId = mapIdsAsArray[columnPosition];\n-\n-      if (mapId < 0) {\n-        return null;\n-      }\n-\n-      return mappings.get(mapId);\n-    }\n-  }\n }\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n \n package com.google.debugging.sourcemap;\n \n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapEncoder;\n-import com.google.javascript.jscomp.Compiler;\n-import com.google.javascript.jscomp.CompilerOptions;\n-import com.google.javascript.jscomp.JSSourceFile;\n-import com.google.javascript.jscomp.Result;\n import com.google.javascript.jscomp.SourceMap;\n-import com.google.javascript.jscomp.SourceMap.DetailLevel;\n-\n-import junit.framework.TestCase;\n-\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n+import com.google.javascript.jscomp.SourceMap.Format;\n \n import java.io.IOException;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n \n /**\n  * Tests for {@link SourceMap}.\n  *\n  */\n-public class SourceMapGeneratorV2Test extends TestCase {\n-  private static final JSSourceFile[] EXTERNS = {\n-      JSSourceFile.fromCode(\"externs\", \"\")\n-  };\n-\n-  private DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+public class SourceMapGeneratorV2Test extends SourceMapTestCase {\n+\n+  @Override\n+  SourceMapConsumer getSourceMapConsumer() {\n+    return new SourceMapConsumerV2();\n+  }\n+\n+  @Override\n+  Format getSourceMapFormat() {\n+    return SourceMap.Format.V2;\n+  }\n \n   @Override\n   public void setUp() {\n     assertEquals(\"!A/B\", getEntry(32, 31, 64));\n     assertEquals(\"!!ABAB\", getEntry(32, 31, 65));\n   }\n-\n-  /**\n-   * Creates a source map for the given JS code and asserts it is\n-   * equal to the expected golden map.\n-   */\n-  private void checkSourceMap(String js, String expectedMap)\n-      throws IOException {\n-    checkSourceMap(\"testcode\", js, expectedMap);\n-  }\n-\n-  private String getSourceMap(RunResult result) throws IOException {\n-    StringBuilder sb = new StringBuilder();\n-    result.sourceMap.appendTo(sb, \"testcode\");\n-    return sb.toString();\n-  }\n-\n-  private void checkSourceMap(String fileName, String js, String expectedMap)\n-      throws IOException {\n-    RunResult result = compile(js, fileName);\n-    assertEquals(expectedMap, result.sourceMapFileContent);\n-    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n-  }\n-\n-  private static class RunResult {\n-    String generatedSource;\n-    SourceMap sourceMap;\n-    public String sourceMapFileContent;\n-  }\n-\n-  private static class Token {\n-    String tokenName;\n-    FilePosition position;\n-  }\n-\n-  /**\n-   * Finds the all the __XX__ tokens in the given Javascript\n-   * string.\n-   */\n-  private Map<String, Token> findTokens(String js) {\n-    Map<String, Token> tokens = Maps.newLinkedHashMap();\n-\n-    int currentLine = 0;\n-    int positionOffset = 0;\n-\n-    for (int i = 0; i < js.length(); ++i) {\n-      char current = js.charAt(i);\n-\n-      if (current == '\\n') {\n-        positionOffset = i + 1;\n-        currentLine++;\n-        continue;\n-      }\n-\n-      if (current == '_' && (i < js.length() - 5)) {\n-        // Check for the _ token.\n-        if (js.charAt(i + 1) != '_') {\n-          continue;\n-        }\n-\n-        // Loop until we have another _ token.\n-        String tokenName = \"\";\n-\n-        int j = i + 2;\n-        for (; j < js.length(); ++j) {\n-          if (js.charAt(j) == '_') {\n-            break;\n-          }\n-\n-          tokenName += js.charAt(j);\n-        }\n-\n-        if (tokenName.length() > 0) {\n-          Token token = new Token();\n-          token.tokenName = tokenName;\n-          int currentPosition = i - positionOffset;\n-          token.position = new FilePosition(currentLine, currentPosition);\n-          tokens.put(tokenName, token);\n-        }\n-\n-        i = j;\n-      }\n-    }\n-\n-    return tokens;\n-  }\n-\n-  private void compileAndCheck(String js) {\n-    RunResult result = compile(js);\n-\n-    // Find all instances of the __XXX__ pattern in the original\n-    // source code.\n-    Map<String, Token> originalTokens = findTokens(js);\n-\n-    // Find all instances of the __XXX__ pattern in the generated\n-    // source code.\n-    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n-\n-    // Ensure that the generated instances match via the source map\n-    // to the original source code.\n-\n-    // Ensure the token counts match.\n-    assertEquals(originalTokens.size(), resultTokens.size());\n-\n-    SourceMapReader reader = new SourceMapReader();\n-    try {\n-      reader.parse(result.sourceMapFileContent);\n-    } catch (SourceMapParseException e) {\n-      throw new RuntimeException(\"unexpected exception\", e);\n-    } catch (IOException e) {\n-      throw new RuntimeException(\"unexpected exception\", e);\n-    }\n-\n-    // Map the tokens from the generated source back to the\n-    // input source and ensure that the map is correct.\n-    for (Token token : resultTokens.values()) {\n-      OriginalMapping mapping = reader.getMappingForLine(\n-          token.position.getLine() + 1,\n-          token.position.getColumn() + 1);\n-\n-      assertNotNull(mapping);\n-\n-      // Find the associated token in the input source.\n-      Token inputToken = originalTokens.get(token.tokenName);\n-      assertNotNull(inputToken);\n-\n-      // Ensure that the map correctly points to the token (we add 1\n-      // to normalize versus the Rhino line number indexing scheme).\n-      assertEquals(mapping.position.getLine(),\n-                   inputToken.position.getLine() + 1);\n-\n-      // Ensure that if the token name does not being with an 'STR' (meaning a\n-      // string) it has an original name.\n-      if (!inputToken.tokenName.startsWith(\"STR\")) {\n-        assertTrue(!mapping.originalName.isEmpty());\n-      }\n-\n-      // Ensure that if the mapping has a name, it matches the token.\n-      if (!mapping.originalName.isEmpty()) {\n-        assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n-      }\n-    }\n-  }\n-\n-  private RunResult compile(String js) {\n-    return compile(js, \"testcode\");\n-  }\n-\n-  private RunResult compile(String js, String fileName) {\n-    return compile(js, fileName, null, null);\n-  }\n-\n-  private RunResult compile(String js1, String fileName1, String js2,\n-      String fileName2) {\n-    Compiler compiler = new Compiler();\n-    CompilerOptions options = new CompilerOptions();\n-    options.sourceMapOutputPath = \"testcode_source_map.out\";\n-    options.sourceMapFormat = SourceMap.Format.V2;\n-    options.sourceMapDetailLevel = detailLevel;\n-\n-    // Turn on IDE mode to get rid of optimizations.\n-    options.ideMode = true;\n-\n-    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n-\n-    if (js2 != null && fileName2 != null) {\n-      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n-                                   JSSourceFile.fromCode(fileName2, js2) };\n-      inputs = multiple;\n-    }\n-\n-    Result result = compiler.compile(EXTERNS, inputs, options);\n-\n-    assertTrue(result.success);\n-    String source = compiler.toSource();\n-\n-    StringBuilder sb = new StringBuilder();\n-    try {\n-      result.sourceMap.validate(true);\n-      result.sourceMap.appendTo(sb, \"testcode\");\n-    } catch (IOException e) {\n-      throw new RuntimeException(\"unexpected exception\", e);\n-    }\n-\n-    RunResult rr = new RunResult();\n-    rr.generatedSource = source;\n-    rr.sourceMap = result.sourceMap;\n-    rr.sourceMapFileContent = sb.toString();\n-    return rr;\n-  }\n-\n-  public static class SourceMapParseException extends IOException {\n-    private static final long serialVersionUID = 1L;\n-\n-    public SourceMapParseException(String message) {\n-      super(message);\n-    }\n-\n-    public SourceMapParseException(String message, Exception ex) {\n-      super(message, ex);\n-    }\n-  }\n-\n-  public static class OriginalMapping {\n-    public final String srcfile;\n-    public final FilePosition position;\n-    public final String originalName;\n-\n-    OriginalMapping(String srcfile, int line, int column, String name) {\n-      this.srcfile = srcfile;\n-      this.position = new FilePosition(line, column);\n-      this.originalName = name;\n-    }\n-  }\n-\n-  /**\n-   * Class for parsing and representing a SourceMap\n-   * TODO(johnlenz): This would be best as a seperate open-source component.\n-   *     Remove this when it is.\n-   */\n-  public class SourceMapReader {\n-    private List<List<Integer>> characterMap = null;\n-\n-    /**\n-     * Map of Mapping IDs to the actual mapping object.\n-     */\n-    private List<OriginalMapping> mappings;\n-    private List<String> sources;\n-    private List<String> names;\n-\n-    public SourceMapReader() {\n-    }\n-\n-    /**\n-     * Parses the given contents containing a source map.\n-     * @throws IOException\n-     */\n-    public void parse(String contents) throws IOException {\n-      characterMap = null;\n-      mappings = null;\n-      sources = null;\n-      names = null;\n-\n-      try {\n-        JSONObject sourceMapRoot = new JSONObject(contents);\n-\n-        int version = sourceMapRoot.getInt(\"version\");\n-        if (version != 2) {\n-          throw new SourceMapParseException(\"unknown version\");\n-        }\n-\n-        String file = sourceMapRoot.getString(\"file\");\n-        if (file.isEmpty()) {\n-          throw new SourceMapParseException(\"file entry is missing or empty\");\n-        }\n-\n-        int lineCount = sourceMapRoot.getInt(\"lineCount\");\n-        JSONArray lineMaps = sourceMapRoot.getJSONArray(\"lineMaps\");\n-        if (lineCount != lineMaps.length()) {\n-          throw new SourceMapParseException(\n-              \"lineMaps lenght does not match lineCount\");\n-        }\n-\n-        characterMap = Lists.newArrayListWithCapacity(lineCount);\n-\n-        for (int i=0; i< lineMaps.length(); i++) {\n-          String lineEntry = lineMaps.getString(i);\n-          List<Integer> entries =\n-              SourceMapLineDecoder.decodeLine(lineEntry);\n-          String msg = \"line: \" + entries;\n-          System.err.println(msg);\n-          characterMap.add(entries);\n-        }\n-\n-        sources = jsonArrayToJavaArray(\n-            sourceMapRoot.getJSONArray(\"sources\"));\n-\n-        if (sourceMapRoot.has(\"names\")) {\n-          names = jsonArrayToJavaArray(\n-              sourceMapRoot.getJSONArray(\"names\"));\n-        } else {\n-          names = Collections.emptyList();\n-        }\n-\n-        JSONArray jsonMappings = sourceMapRoot.getJSONArray(\"mappings\");\n-        mappings = Lists.newArrayListWithCapacity(lineCount);\n-        for (int i = 0; i < jsonMappings.length(); i++) {\n-          JSONArray entry = jsonMappings.getJSONArray(i);\n-\n-          String name;\n-          try {\n-            int nameIndex = entry.getInt(3);\n-            name = names.get(nameIndex);\n-          } catch (JSONException e) {\n-            name = entry.optString(3, \"\");\n-          }\n-\n-          OriginalMapping mapping = new OriginalMapping(\n-            sources.get(entry.getInt(0)), // srcfile\n-            entry.getInt(1),    // line\n-            entry.getInt(2),    // column\n-            name); // identifier\n-          mappings.add(mapping);\n-        }\n-      } catch (JSONException ex) {\n-        throw new SourceMapParseException(\"JSON parse exception\", ex);\n-      }\n-    }\n-\n-    private List<String> jsonArrayToJavaArray(JSONArray jsonArray)\n-        throws JSONException {\n-      List<String> result = Lists.newArrayListWithCapacity(jsonArray.length());\n-      for (int i=0; i< jsonArray.length(); i++) {\n-        String source = jsonArray.getString(i);\n-        result.add(source);\n-      }\n-      return result;\n-    }\n-\n-    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n-      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n-\n-      List<Integer> mapIds = characterMap.get(lineNumber - 1);\n-      if (mapIds == null) {\n-        return null;\n-      }\n-\n-      int columnPosition = columnIndex - 1;\n-      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n-        return null;\n-      }\n-\n-      int mapId = mapIds.get(columnPosition);\n-\n-      return mappings.get(mapId);\n-    }\n-  }\n }\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.jscomp.SourceMap.Format;\n+\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapGeneratorV3Test extends SourceMapTestCase {\n+\n+  @Override\n+  SourceMapConsumer getSourceMapConsumer() {\n+    return new SourceMapConsumerV3();\n+  }\n+\n+  @Override\n+  Format getSourceMapFormat() {\n+    return SourceMap.Format.V3;\n+  }\n+\n+  public void testBasicMapping1() throws Exception {\n+    compileAndCheck(\"function __BASIC__() { }\");\n+  }\n+\n+  public void testBasicMappingGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__() { }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACSA,QAAAA,UAAS,EAAG;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"__BASIC__\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testBasicMapping2() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__) {}\");\n+  }\n+\n+  public void testLiteralMappings() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                    \"var __VAR__ = '__STR__'; }\");\n+  }\n+\n+  public void testLiteralMappingsGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                   \"var __VAR__ = '__STR__'; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACSA,QAAAA,UAAS,CAACC,UAAD,CAAaC,UAAb,\" +\n+                       \"CAAyB,CAAE,IAAIC,QAAU,SAAhB;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"__BASIC__\\\",\\\"__PARAM1__\\\",\\\"__PARAM2__\\\",\" +\n+                       \"\\\"__VAR__\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testMultilineMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\");\n+  }\n+\n+  public void testMultilineMapping2() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = 1;\\n\" +\n+                    \"var __ANO__ = 2;\\n\" +\n+                    \"}\");\n+  }\n+\n+  public void testMultiFunctionMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\\n\" +\n+\n+                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n+                    \"var __VAR2__ = '__STR2__';\\n\" +\n+                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n+                    \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput0() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\";\\\",\\n\" +\n+                   \"\\\"sources\\\":[],\\n\" +\n+                   \"\\\"names\\\":[]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput1() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACSA,QAAAA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n+                       \"CAAW,CAAED,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkB,CAAG,\" +\n+                       \"OAAOD,IAA9B;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n+                   \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACSA,QAAAA,EAAAA,CAAEC,GAAFD,CAAOE,\" +\n+                       \"GAAPF,EAAcC,GAAdD,CAAoBC,GAApBD,CAA0BE,GAA1BF,\" +\n+                       \"SAA0CC,IAA1CD;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput2() throws Exception {\n+    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n+                   \"\\nreturn foo;\\n}\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACSA,QAAAA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n+                       \"CAAW,CAIrBD,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkBD,\" +\n+                       \"GAClB,OAAOA,IALc;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput3() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACAA;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"foo\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput4() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;   boo;   goo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":3,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"mappings\\\":\\\"AACAA,GAAOC,IAAOC;\\\",\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"names\\\":[\\\"foo\\\",\\\"boo\\\",\\\"goo\\\"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput5() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\n+        \"c:\\\\myfile.js\",\n+        \"/** @preserve\\n\" +\n+        \" * this is a test.\\n\" +\n+        \" */\\n\" +\n+        \"var foo=a + 'this is a really long line that will force the\"\n+        + \" mapping to span multiple lines 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \"' + c + d + e;\",\n+\n+        \"{\\n\" +\n+        \"\\\"version\\\":3,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":6,\\n\" +\n+        \"\\\"mappings\\\":\\\"A;;;;AAIA,IAAIA,IAAIC,CAAJD,CAAQ,mxCAARA;AAA8xCE,\" +\n+            \"CAA9xCF,CAAkyCG,CAAlyCH,CAAsyCI;\\\",\\n\" +\n+        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n+        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n+        \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+        \"/** @preserve\\n\" +\n+        \" * this is a test.\\n\" +\n+        \" */\\n\" +\n+        \"var foo=a + 'this is a really long line that will force the\"\n+        + \" mapping to span multiple lines 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \"' + c + d + e;\",\n+\n+        \"{\\n\" +\n+        \"\\\"version\\\":3,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":6,\\n\" +\n+        \"\\\"mappings\\\":\\\"A;;;;IAIIA,IAAIC,CAAJD;AAA8xCE,CAA9xCF,CAAkyCG,\" +\n+            \"CAAlyCH,CAAsyCI;\\\",\\n\" +\n+        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n+        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testBasicDeterminism() throws Exception {\n+    RunResult result1 = compile(\"file1\", \"foo;\", \"file2\", \"bar;\");\n+    RunResult result2 = compile(\"file2\", \"foo;\", \"file1\", \"bar;\");\n+\n+    String map1 = getSourceMap(result1);\n+    String map2 = getSourceMap(result2);\n+\n+    // Assert that the files section of the maps are the same. The actual\n+    // entries will differ, so we cannot do a simple full comparison.\n+\n+    // Line 5 has the file information.\n+    String files1 = map1.split(\"\\n\")[4];\n+    String files2 = map2.split(\"\\n\")[4];\n+\n+    assertEquals(files1, files2);\n+  }\n+\n+\n+}\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.collect.Maps;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.jscomp.SourceMap.DetailLevel;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public abstract class SourceMapTestCase extends TestCase {\n+\n+  public SourceMapTestCase() {}\n+\n+  static final JSSourceFile[] EXTERNS = {\n+      JSSourceFile.fromCode(\"externs\", \"\")\n+  };\n+\n+  protected DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+\n+  protected static class RunResult {\n+      String generatedSource;\n+      SourceMap sourceMap;\n+      public String sourceMapFileContent;\n+    }\n+\n+  protected static class Token {\n+      String tokenName;\n+      FilePosition position;\n+    }\n+\n+  @Override\n+  public void setUp() {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+  }\n+\n+  /**\n+   * Creates a source map for the given JS code and asserts it is\n+   * equal to the expected golden map.\n+   */\n+  protected void checkSourceMap(String js, String expectedMap)\n+      throws IOException {\n+    checkSourceMap(\"testcode\", js, expectedMap);\n+  }\n+\n+  protected String getSourceMap(RunResult result) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    result.sourceMap.appendTo(sb, \"testcode\");\n+    return sb.toString();\n+  }\n+\n+  protected void checkSourceMap(String fileName, String js, String expectedMap)\n+      throws IOException {\n+    RunResult result = compile(js, fileName);\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(String js) {\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    int currentLine = 0;\n+    int positionOffset = 0;\n+\n+    for (int i = 0; i < js.length(); ++i) {\n+      char current = js.charAt(i);\n+\n+      if (current == '\\n') {\n+        positionOffset = i + 1;\n+        currentLine++;\n+        continue;\n+      }\n+\n+      if (current == '_' && (i < js.length() - 5)) {\n+        // Check for the _ token.\n+        if (js.charAt(i + 1) != '_') {\n+          continue;\n+        }\n+\n+        // Loop until we have another _ token.\n+        String tokenName = \"\";\n+\n+        int j = i + 2;\n+        for (; j < js.length(); ++j) {\n+          if (js.charAt(j) == '_') {\n+            break;\n+          }\n+\n+          tokenName += js.charAt(j);\n+        }\n+\n+        if (tokenName.length() > 0) {\n+          Token token = new Token();\n+          token.tokenName = tokenName;\n+          int currentPosition = i - positionOffset;\n+          token.position = new FilePosition(currentLine, currentPosition);\n+          tokens.put(tokenName, token);\n+        }\n+\n+        i = j;\n+      }\n+    }\n+\n+    return tokens;\n+  }\n+\n+  abstract SourceMap.Format getSourceMapFormat();\n+\n+  abstract SourceMapConsumer getSourceMapConsumer();\n+\n+  protected void compileAndCheck(String js) {\n+    RunResult result = compile(js);\n+\n+    // Find all instances of the __XXX__ pattern in the original\n+    // source code.\n+    Map<String, Token> originalTokens = findTokens(js);\n+\n+    // Find all instances of the __XXX__ pattern in the generated\n+    // source code.\n+    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n+\n+    // Ensure that the generated instances match via the source map\n+    // to the original source code.\n+\n+    // Ensure the token counts match.\n+    assertEquals(originalTokens.size(), resultTokens.size());\n+\n+    SourceMapConsumer reader = getSourceMapConsumer();\n+    try {\n+      reader.parse(result.sourceMapFileContent);\n+    } catch (SourceMapParseException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    // Map the tokens from the generated source back to the\n+    // input source and ensure that the map is correct.\n+    for (Token token : resultTokens.values()) {\n+      OriginalMapping mapping = reader.getMappingForLine(\n+          token.position.getLine() + 1,\n+          token.position.getColumn() + 1);\n+\n+      assertNotNull(mapping);\n+\n+      // Find the associated token in the input source.\n+      Token inputToken = originalTokens.get(token.tokenName);\n+      assertNotNull(inputToken);\n+\n+      // Ensure that the map correctly points to the token (we add 1\n+      // to normalize versus the Rhino line number indexing scheme).\n+      assertEquals(mapping.getLineNumber(),\n+                   inputToken.position.getLine() + 1);\n+\n+      // Ensure that if the token name does not being with an 'STR' (meaning a\n+      // string) it has an original name.\n+      if (!inputToken.tokenName.startsWith(\"STR\")) {\n+        assertTrue(\"missing name for \" + inputToken.tokenName,\n+            !mapping.getIdentifier().isEmpty());\n+      }\n+\n+      // Ensure that if the mapping has a name, it matches the token.\n+      if (!mapping.getIdentifier().isEmpty()) {\n+        assertEquals(mapping.getIdentifier(),\n+            \"__\" + inputToken.tokenName + \"__\");\n+      }\n+    }\n+  }\n+\n+  private RunResult compile(String js) {\n+    return compile(js, \"testcode\");\n+  }\n+\n+  private RunResult compile(String js, String fileName) {\n+    return compile(js, fileName, null, null);\n+  }\n+\n+  protected RunResult compile(\n+      String js1, String fileName1, String js2, String fileName2) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.sourceMapOutputPath = \"testcode_source_map.out\";\n+    options.sourceMapFormat = getSourceMapFormat();\n+    options.sourceMapDetailLevel = detailLevel;\n+\n+    // Turn on IDE mode to get rid of optimizations.\n+    options.ideMode = true;\n+\n+    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n+\n+    if (js2 != null && fileName2 != null) {\n+      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n+                                   JSSourceFile.fromCode(fileName2, js2) };\n+      inputs = multiple;\n+    }\n+\n+    Result result = compiler.compile(EXTERNS, inputs, options);\n+\n+    assertTrue(\"compilation failed\", result.success);\n+    String source = compiler.toSource();\n+\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      result.sourceMap.validate(true);\n+      result.sourceMap.appendTo(sb, \"testcode\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    RunResult rr = new RunResult();\n+    rr.generatedSource = source;\n+    rr.sourceMap = result.sourceMap;\n+    rr.sourceMapFileContent = sb.toString();\n+    return rr;\n+  }\n+\n+}", "timestamp": 1303325590, "metainfo": ""}