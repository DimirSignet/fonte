{"sha": "091577d5000b2260452cdc79eacf54925de894a3", "log": "Making CheckAccessControls hot-swappable. This needed changes in defining properties on PrototypeObjectType to keep previously inferred jsdoc info.  R=nicksantos DELTA=57  (45 added, 2 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1806   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-class CheckAccessControls implements ScopedCallback, CompilerPass {\n+class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n \n   static final DiagnosticType DEPRECATED_NAME = DiagnosticType.disabled(\n       \"JSC_DEPRECATED_VAR\",\n     this.initializedConstantProperties = HashMultimap.create();\n   }\n \n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+    NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n   public void enterScope(NodeTraversal t) {\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n    */\n   protected void initialize() {\n     // TODO(user): Calling clear doesn't deallocate the memory in a\n-    // LinkedHashSet. Consider creating a new work set if we plan to repeatly\n+    // LinkedHashSet. Consider creating a new work set if we plan to repeatedly\n     // call analyze.\n     orderedWorkSet.clear();\n     for (DiGraphNode<N, Branch> node : cfg.getDirectedGraphNodes()) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Checks access controls. Depends on type-inference. */\n-  private final PassFactory checkAccessControls =\n-      new PassFactory(\"checkAccessControls\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkAccessControls =\n+      new HotSwapPassFactory(\"checkAccessControls\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new CheckAccessControls(compiler);\n     }\n   };\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     if (hasOwnDeclaredProperty(name)) {\n       return false;\n     }\n-    properties.put(name, new Property(type, inferred, inExterns, propertyNode));\n+    Property newProp = new Property(type, inferred, inExterns, propertyNode);\n+    Property oldProp = properties.get(name);\n+    if (oldProp != null) {\n+      // This is to keep previously inferred jsdoc info, e.g., in a\n+      // replaceScript scenario.\n+      newProp.docInfo = oldProp.docInfo;\n+    }\n+    properties.put(name, newProp);\n     return true;\n   }\n ", "timestamp": 1305041682, "metainfo": ""}