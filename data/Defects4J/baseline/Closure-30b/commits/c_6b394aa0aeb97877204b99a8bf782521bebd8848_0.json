{"sha": "6b394aa0aeb97877204b99a8bf782521bebd8848", "log": "fix a bug in type inference  R=acleung DELTA=50  (31 added, 18 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3458   ", "commit": "\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n     Scope functionScope = getFunctionScope();\n     if (functionScope.isLocal()) {\n       if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {\n-        // When we enter a local scope, many qualified names are\n-        // already defined even if they haven't been declared in the Scope\n-        // object. If the name has not yet been defined in this scope, we\n-        // need to define it now before we refine it.\n-        int firstDot = symbol.indexOf(\".\");\n-        Preconditions.checkState(firstDot != -1);\n-        Var owner = functionScope.getVar(symbol.substring(0, firstDot));\n-        Scope ownerScope = owner == null ? functionScope : owner.getScope();\n-        ownerScope.declare(symbol, node, bottomType, null);\n+        functionScope.declare(symbol, node, bottomType, null);\n       }\n \n       inferSlotType(symbol, inferredType);\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n         refs.get(0).getNode().getSourceFileName());\n   }\n \n-  public void testGlobalQualifiedNamesInLocalScopes() {\n-    SymbolTable table = createSymbolTable(\n-        \"/** @const */ var x = {}; function f() { x.number = 3; }\");\n-    Symbol xNumber = getLocalVar(table, \"x.number\");\n-    assertNotNull(xNumber);\n-    assertTrue(table.getScope(xNumber).isGlobalScope());\n-\n-    assertEquals(\"?\", xNumber.getType().toString());\n-  }\n-\n   public void testLocalQualifiedNamesInLocalScopes() {\n     SymbolTable table = createSymbolTable(\n         \"function f() { var x = {}; x.number = 3; }\");\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"var f = function(x) {\\n\" +\n         \"if (x instanceof T) { return ''; } else { return x; }\\n\" +\n         \"};\");\n+  }\n+\n+  public void testUndeclaredGlobalProperty1() throws Exception {\n+    testTypes(\"/** @const */ var x = {}; x.y = null;\" +\n+        \"function f(a) { x.y = a; }\" +\n+        \"/** @param {string} a */ function g(a) { }\" +\n+        \"function h() { g(x.y); }\");\n+  }\n+\n+  public void testUndeclaredGlobalProperty2() throws Exception {\n+    testTypes(\"/** @const */ var x = {}; x.y = null;\" +\n+        \"function f() { x.y = 3; }\" +\n+        \"/** @param {string} a */ function g(a) { }\" +\n+        \"function h() { g(x.y); }\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : (null|number)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testLocallyInferredGlobalProperty1() throws Exception {\n+    // We used to have a bug where x.y.z leaked from f into h.\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @type {number} */ F.prototype.z;\" +\n+        \"/** @const */ var x = {}; /** @type {F} */ x.y;\" +\n+        \"function f() { x.y.z = 'abc'; }\" +\n+        \"/** @param {number} x */ function g(x) {}\" +\n+        \"function h() { g(x.y.z); }\",\n+        \"assignment to property z of F\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n   }\n \n   public void testPropertyInferredPropagation() throws Exception {", "timestamp": 1318473638, "metainfo": ""}