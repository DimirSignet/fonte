{"sha": "0a40e6661cd197e1cd0d3a3bccaa4c5313df8514", "log": "fix a weird integration issue. some processes run the provide/require processor after scope creation.  That means that TypedScopeCreator can't assign types to the new namespaces.  Normal closure compiler is moving towards a model where TypedScopeCreator declares namespaces in the global scope. It's not clear how we should resolve this inconsistency, but for now this shim will make things better.  R=moedinger DELTA=25  (15 added, 5 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=214752   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n      */\n     private Node makeVarDeclNode(String namespace, Node sourceNode) {\n       Node name = Node.newString(Token.NAME, namespace);\n-      name.addChildToFront(new Node(Token.OBJECTLIT));\n+      name.addChildToFront(createNamespaceLiteral());\n \n       Node decl = new Node(Token.VAR, name);\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n       Preconditions.checkState(isNamespacePlaceholder(decl));\n       decl.copyInformationFromForTree(sourceNode);\n       return decl;\n+    }\n+\n+    /**\n+     * There are some special cases where clients of the compiler\n+     * do not run TypedScopeCreator after running this pass.\n+     * So always give the namespace literal a type.\n+     */\n+    private Node createNamespaceLiteral() {\n+      Node objlit = new Node(Token.OBJECTLIT);\n+      objlit.setJSType(\n+          compiler.getTypeRegistry().createAnonymousObjectType());\n+      return objlit;\n     }\n \n     /**\n     private Node makeAssignmentExprNode(String namespace, Node node) {\n       Node decl = new Node(Token.EXPR_RESULT,\n           new Node(Token.ASSIGN,\n-            NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n-              new Node(Token.OBJECTLIT)));\n+              NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n+              createNamespaceLiteral()));\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n       Preconditions.checkState(isNamespacePlaceholder(decl));\n       decl.copyInformationFromForTree(node);\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n   private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     ObjectType objectType = (ObjectType) n.getJSType();\n-\n-    if (objectType == null) {\n-      // This will only happen if someone didn't run typed scope creation\n-      // properly.\n-      return scope;\n-    }\n+    Preconditions.checkNotNull(objectType);\n \n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         break;\n \n       case Token.OBJECTLIT:\n-        n.setJSType(typeRegistry.createAnonymousObjectType());\n+        if (n.getJSType() == null) {\n+          n.setJSType(typeRegistry.createAnonymousObjectType());\n+        }\n         break;\n \n       // NOTE(nicksantos): If we ever support Array tuples,", "timestamp": 1284388160, "metainfo": ""}