{"sha": "78995bf9e88599055a8c4165d89c09dc92a44b30", "log": "Fix synthesis of vars in DEFAULT mode. Better variable inlining Better function inlining Assorted bug fixes    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n           pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar\n               ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(\n                   pathPrefix).getParent();\n-      new File(dirName).mkdirs();\n+      if (dirName != null) {\n+        new File(dirName).mkdirs();\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n \n       ReferenceCollection aliasRefs =\n           collector.getReferenceCollection(aliasVar);\n-      if (aliasRefs.isWellDefined() && aliasRefs.isNeverReassigned()) {\n+      if (aliasRefs.isWellDefined()\n+          && aliasRefs.firstReferenceIsAssigningDeclaration()\n+          && aliasRefs.isAssignedOnce()) {\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n import com.google.common.base.Supplier;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     this.knownConstants = constNames;\n   }\n \n+  private static final int MAX_INTERATIONS = 100;\n+\n   /**\n    * If required, rewrite the statement containing the expression.\n    * @param expression The expression to be exposed.\n    */\n   void maybeDecomposeExpression(Node expression) {\n     // If the expression needs to exposed.\n+    int i = 0;\n     while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n       exposeExpression(expression);\n+      if (i > MAX_INTERATIONS) {\n+        throw new IllegalStateException(\n+            \"DecomposeExpression depth exceeded on :\\n\" + \n+            expression.toStringTree());\n+      }\n     }\n   }\n \n       Preconditions.checkState(\n           !isConditionalOp(parent) || child == parent.getFirstChild());\n       if (parentType == Token.ASSIGN) {\n-          if (parent.getFirstChild().getType() == Token.NAME) {\n+          if (isSafeAssign(parent, state.sideEffects)) {\n             // It is always safe to inline \"foo()\" for expressions such as\n             // \"a = b = c = foo();\"\n             // As the assignment is unaffected by side effect of \"foo()\"\n           }\n       } else if (parentType == Token.CALL\n           && NodeUtil.isGet(parent.getFirstChild())) {\n-        Node functionExpression = parent.getFirstChild();\n-        decomposeSubExpressions(\n-            functionExpression.getNext(), child, state);\n-        // Now handle the call expression\n-        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n-          // Either there were preexisting side-effects, or this node has\n-          // side-effects.\n-          state.sideEffects = true;\n-\n-          // Rewrite the call so \"this\" is preserved.\n-          Node replacement = rewriteCallExpression(parent, state);\n-          // Continue from here.\n-          parent = replacement;\n+        // TODO(johnlenz): In Internet Explorer, non-javascript objects such\n+        // as DOM objects can not be decomposed.\n+        if (!maybeExternMethod(parent.getFirstChild())) {\n+          throw new IllegalStateException(\n+              \"External object method calls can not be decomposed.\");\n+        } else {\n+          Node functionExpression = parent.getFirstChild();\n+          decomposeSubExpressions(\n+              functionExpression.getNext(), child, state);\n+          // Now handle the call expression\n+          if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n+            // Either there were preexisting side-effects, or this node has\n+            // side-effects.\n+            state.sideEffects = true;\n+  \n+            // Rewrite the call so \"this\" is preserved.\n+            Node replacement = rewriteCallExpression(parent, state);\n+            // Continue from here.\n+            parent = replacement;\n+          }\n         }\n       } else {\n         decomposeSubExpressions(\n       Node extractedConditional = extractConditional(\n           nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n+  }\n+\n+  /**\n+   * @return Whether the node may represent an external method.\n+   */\n+  private boolean maybeExternMethod(Node node) {\n+    // TODO(johnlenz): Provide some mechanism for determining this.\n+    return true;\n   }\n \n   /**\n   DecompositionType canExposeExpression(Node subExpression) {\n     Node expressionRoot = findExpressionRoot(subExpression);\n     if (expressionRoot != null) {\n-      if (isSubexpressionMovable(expressionRoot, subExpression)) {\n-        return DecompositionType.MOVABLE;\n-      } else {\n-        return DecompositionType.DECOMPOSABLE;\n-      }\n+      return isSubexpressionMovable(expressionRoot, subExpression);\n     }\n     return DecompositionType.UNDECOMPOSABLE;\n   }\n    * by x().  Note: this is true even if b is a local variable; the object that\n    * b refers to may have a global alias.\n    *\n-   * @return Whether the call can be moved before the expression.\n-   */\n-  private boolean isSubexpressionMovable(\n+   * @return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\n+   * decomposition is required before the expression can be moved, otherwise\n+   * MOVABLE.\n+   */\n+  private DecompositionType isSubexpressionMovable(\n       Node expressionRoot, Node subExpression) {\n-\n-    boolean callExpressionHasSideEffects = NodeUtil.mayHaveSideEffects(\n-        subExpression);\n+    boolean requiresDecomposition = false;\n+    boolean seenSideEffects = NodeUtil.mayHaveSideEffects(subExpression);\n \n     Node child = subExpression;\n     for (Node parent : child.getAncestors()) {\n       if (parent == expressionRoot) {\n         // Done. The walk back to the root of the expression is complete, and\n         // nothing was encountered that blocks the call from being moved.\n-        return true;\n+        return requiresDecomposition\n+            ? DecompositionType.DECOMPOSABLE\n+            : DecompositionType.MOVABLE;\n       }\n \n       int parentType = parent.getType();\n         // Only the first child is always executed, otherwise it must be\n         // decomposed.\n         if (child != parent.getFirstChild()) {\n-          return false;\n+          requiresDecomposition = true;\n         }\n       } else {\n         // Only inline the call if none of the preceding siblings in the\n         // are evaluated.\n \n         // SPECIAL CASE: Assignment to a simple name\n-        if (parentType == Token.ASSIGN\n-            && parent.getFirstChild().getType() == Token.NAME) {\n+        if (isSafeAssign(parent, seenSideEffects)) {\n           // It is always safe to inline \"foo()\" for expressions such as\n           //   \"a = b = c = foo();\"\n           // As the assignment is unaffected by side effect of \"foo()\"\n             }\n \n             if (isExpressionTreeUnsafe(\n-                n, callExpressionHasSideEffects)) {\n-              return false;\n+                n, seenSideEffects)) {\n+              seenSideEffects = true;\n+              requiresDecomposition = true;\n+            }\n+          }\n+\n+          // In Internet Explorer, DOM objects and other external objects\n+          // methods can not be called indirectly, as is required when the \n+          // object or its property can be side-effected.  For example,\n+          // when exposing expression f() (with side-effects) in: x.m(f())\n+          // either the value of x or its property m might have changed, so\n+          // both the 'this' value ('x') and the function to be called ('x.m') \n+          // need to be preserved. Like so:\n+          //   var t1 = x, t2 = x.m, t3 = f();\n+          //   t2.call(t1, t3);\n+          // As IE doesn't support the call to these non-javascript objects \n+          // methods in this way. We can't do this.\n+          // We don't currently distinguish between these types of objects\n+          // in the extern definitions and if we did we would need accurate\n+          // type information.\n+          //\n+          Node first = parent.getFirstChild();\n+          if (requiresDecomposition \n+              && parent.getType() == Token.CALL \n+              && NodeUtil.isGet(first)) {\n+            if (maybeExternMethod(first)) {\n+              return DecompositionType.UNDECOMPOSABLE;\n+            } else {\n+              return DecompositionType.DECOMPOSABLE;\n             }\n           }\n         }\n   }\n \n   /**\n-   * @return Whether the tree can be affect by side-effects occuring elsewhere.\n-   */\n-  private boolean canBeSideEffected(Node n) {\n-    return NodeUtil.has(\n-        n, new SideEffected(this.knownConstants),\n-        Predicates.<Node>alwaysTrue());\n-  }\n-\n-  /**\n-   * Predicate for detecting logic that may be affect by side-effects.\n-   */\n-  private static class SideEffected implements Predicate<Node> {\n-    final Set<String> additionalConsts;\n-\n-    SideEffected(Set<String> additionalConsts) {\n-      this.additionalConsts = additionalConsts;\n-    }\n-\n-    /**\n-     * @return Whether the node can be affect by side-effects.\n-     */\n-    public boolean apply(Node n) {\n-      switch (n.getType()) {\n-        case Token.CALL:\n-        case Token.NEW:\n-          // Function calls or constructor can reference changed values.\n-          // TODO(johnlenz): Add some mechanism for determining that functions\n-          // are unaffected by side effects.\n+   * It is always safe to inline \"foo()\" for expressions such as\n+   *    \"a = b = c = foo();\"\n+   * As the assignment is unaffected by side effect of \"foo()\"\n+   * and the names assigned-to can not influence the state before\n+   * the call to foo.\n+   * \n+   * It is also safe in cases like where the object is constant:\n+   *    CONST_NAME.a = foo()\n+   *    CONST_NAME[CONST_VALUE] = foo(); \n+   * \n+   * This is not true of more complex LHS values, such as\n+   *     a.x = foo();\n+   *     next().x = foo();\n+   * in these cases the checks below are necessary.\n+   * \n+   * @param seenSideEffects If true, check to see if node-tree maybe affected by\n+   * side-effects, otherwise if the tree has side-effects. @see \n+   * isExpressionTreeUnsafe\n+   * @return Whether the assignment is safe from side-effects.\n+   */\n+  private boolean isSafeAssign(Node n, boolean seenSideEffects) {\n+    if (n.getType() == Token.ASSIGN) {\n+      Node lhs = n.getFirstChild();\n+      switch (lhs.getType()) {\n+        case Token.NAME:\n           return true;\n-        case Token.NAME:\n-          // Non-constant names values may have been changed.\n-          // TODO(johnlenz): A constant Named object may still have\n-          // properties that are non-constant.\n-          return !NodeUtil.isConstantName(n)\n-              && !additionalConsts.contains(n.getString());\n-        default:\n-          return false;\n+        case Token.GETPROP:\n+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects);\n+        case Token.GETELEM:\n+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects) \n+              && !isExpressionTreeUnsafe(lhs.getLastChild(), seenSideEffects);\n       }\n     }\n+    return false;\n   }\n \n   /**\n       // expression tree can be affected by any side-effects.\n \n       // This is a superset of \"NodeUtil.mayHaveSideEffects\".\n-      return canBeSideEffected(n);\n+      return NodeUtil.canBeSideEffected(n, this.knownConstants);\n     } else {\n       // The function called doesn't have side-effects but check to see if there\n       // are side-effects that that may affect it.\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n         // Even if there are no references, we still need to evaluate the\n         // expression if it has side-effects.\n         safe = false;\n-      } else if (canBeSideEffected(cArg)\n+      } else if (NodeUtil.canBeSideEffected(cArg)\n           && namesAfterSideEffects.contains(argName)) {\n         safe = false;\n       } else if (references > 1) {\n     }\n   }\n \n-  // TODO(johnlenz): Move this function to a better location.\n-  /**\n-   * @return Whether the tree can be affect by side-effects occuring elsewhere.\n-   */\n-  private static boolean canBeSideEffected(Node n) {\n-    switch (n.getType()) {\n-      case Token.CALL:\n-        if (!n.isNoSideEffectsCall()) {\n-          return true;\n-        }\n-        // The function itself is a pure function, check the parameters.\n-        break;\n-      case Token.NEW:\n-        // TODO(johnlenz): Add some mechanism for determining that constructors\n-        // are unaffected by side effects.\n-        return true;\n-      case Token.NAME:\n-        // Non-constant names values may have been changed.\n-        if (!NodeUtil.isConstantName(n)) {\n-          return true;\n-        }\n-        break;\n-    }\n-\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (canBeSideEffected(c)) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n   /**\n    * Get a set of function parameter names.\n    */\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n   // Inlines all strings, even if they increase the size of the gzipped binary.\n   private final boolean inlineAllStrings;\n \n-  // All declared constant variables with immutable values.\n-  // These should be inlined even if we can't prove that they're written before\n-  // first use.\n-  private final Set<Var> declaredConstants = Sets.newHashSet();\n-\n   private final IdentifyConstants identifyConstants = new IdentifyConstants();\n \n   InlineVariables(AbstractCompiler compiler, boolean onlyConstants,\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n         compiler, new InliningBehavior(),\n         onlyConstants ?\n-            // Filter all constants, and put them in the declaredConstants map.\n             identifyConstants :\n-            // Put all the constants in declaredConstants, but accept\n-            // all variables.\n-            Predicates.<Var>or(\n-                identifyConstants, Predicates.<Var>alwaysTrue()));\n+            Predicates.<Var>alwaysTrue());\n     callback.process(externs, root);\n   }\n \n   private class IdentifyConstants implements Predicate<Var> {\n     @Override\n     public boolean apply(Var var) {\n-      if (declaredConstants.contains(var)) {\n-        return true;\n-      }\n-\n-      if (!var.isConst()) {\n-        return false;\n-      }\n-\n-      if (var.getInitialValue() == null) {\n-        // This constant is either externally defined or initialized shortly\n-        // after being declared (e.g. in an anonymous function used to hide\n-        // temporary variables), so the constant is ineligible for inlining.\n-        return false;\n-      }\n-\n-      // Is the constant's value immutable?\n-      if (!NodeUtil.isImmutableValue(var.getInitialValue())) {\n-        return false;\n-      }\n-\n-      declaredConstants.add(var);\n-      return true;\n+      return var.isConst();\n     }\n   }\n \n           // another pass that handles unused variables much more elegantly.\n           if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n               referenceInfo.isWellDefined() &&\n-              referenceInfo.isNeverReassigned()) {\n-            Reference declaration = referenceInfo.references.get(0);\n-            Node value = declaration.getNameNode().getFirstChild();\n-            if (declaration.getParent().getType() == Token.VAR &&\n-                value != null && value.getType() == Token.NAME) {\n+              referenceInfo.isAssignedOnce()) {\n+            Reference init = referenceInfo.getInitializingReference();\n+            Node value = init.getAssignedValue();\n+            if (value != null && value.getType() == Token.NAME) {\n               aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n             }\n           }\n           // Never try to inline exported variables or variables that\n           // were not collected or variables that have already been inlined.\n           continue;\n-        } else if (isInlineableDeclaredConstant(v, referenceInfo.references)) {\n-          inlineDeclaredConstant(v, referenceInfo.references);\n+        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n+          Reference init = referenceInfo.getInitializingReferenceForConstants();\n+          Node value = init.getAssignedValue();\n+          inlineDeclaredConstant(v, value, referenceInfo.references);\n           staleVars.add(v);\n         } else if (onlyConstants) {\n           // If we're in constants-only mode, don't run more aggressive\n           // inlining heuristics. See InlineConstantsTest.\n           continue;\n         } else {\n-          inlineNonConstants(t.getScope(), v, referenceInfo);\n-        }\n-      }\n-    }\n-\n-    private void inlineNonConstants(Scope scope,\n+          inlineNonConstants(v, referenceInfo);\n+        }\n+      }\n+    }\n+\n+    private void inlineNonConstants(\n         Var v, ReferenceCollection referenceInfo) {\n-      if (referenceInfo.references.size() >= 2 &&\n+      int refCount = referenceInfo.references.size();\n+      Reference declaration = referenceInfo.references.get(0);\n+      Reference init = referenceInfo.getInitializingReference();\n+      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n+\n+      if (refCount > 1 &&\n           isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n-        // if the variable is defined more than twice, we can only\n+        // if the variable is referenced more than once, we can only\n         // inline it if it's immutable and never defined before referenced.\n-        inlineWellDefinedVariable(v, referenceInfo.references);\n+        Node value = init.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n-      } else if (referenceInfo.references.size() == 2) {\n-        // if the variable is only referenced once, we can try some more\n+      } else if (refCount == firstRefAfterInit) {\n+        // The variable likely only read once, try some more\n         // complex inlining heuristics.\n-        Reference declaration = referenceInfo.references.get(0);\n-        Reference reference = referenceInfo.references.get(1);\n-\n-        if (canInline(declaration, reference)) {\n-          // If the value being inlined contains references to variables\n-          // that have not yet been considered for inlining, we won't\n-          // be able to inline them later because the reference collection\n-          // will be wrong. So blacklist those variables from inlining.\n-          // We'll pick them up on the next pass.\n-          blacklistVarReferencesInTree(\n-              declaration.getNameNode().getFirstChild(), scope);\n-\n-          inline(v, declaration, reference);\n+        Reference reference = referenceInfo.references.get(\n+            firstRefAfterInit - 1);\n+        if (canInline(declaration, init, reference)) {\n+          inline(v, declaration, init, reference);\n+          staleVars.add(v);\n+        }\n+      } else if (declaration != init && refCount == 2) {\n+        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n+          // The only reference is the initialization, remove the assignment and\n+          // the variable declaration.\n+          Node value = init.getAssignedValue();\n+          Preconditions.checkNotNull(value);\n+          inlineWellDefinedVariable(v, value, referenceInfo.references);\n           staleVars.add(v);\n         }\n       }\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&\n-          referenceInfo.isNeverReassigned()) {\n+          referenceInfo.isAssignedOnce()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNameNode();\n           if (aliasCandidates.containsKey(nameNode)) {\n             AliasCandidate candidate = aliasCandidates.get(nameNode);\n             if (!staleVars.contains(candidate.alias)) {\n-              inlineWellDefinedVariable(\n-                  candidate.alias, candidate.refInfo.references);\n+              Reference aliasInit;\n+              aliasInit = candidate.refInfo.getInitializingReference();\n+              Node value = aliasInit.getAssignedValue();\n+              Preconditions.checkNotNull(value);\n+              inlineWellDefinedVariable(candidate.alias,\n+                  value,\n+                  candidate.refInfo.references);\n               staleVars.add(candidate.alias);\n             }\n           }\n      * Do the actual work of inlining a single declaration into a single\n      * reference.\n      */\n-    private void inline(Var v, Reference declaration, Reference reference) {\n-      Node name = declaration.getNameNode();\n-      Preconditions.checkState(name.getFirstChild() != null);\n-      Node value = name.removeFirstChild();\n-      inlineValue(v, reference, value);\n+    private void inline(Var v, Reference declaration,\n+                        Reference init, Reference reference) {\n+      Node value = init.getAssignedValue();\n+      Preconditions.checkState(value != null);\n+\n+      inlineValue(v, reference, value.detachFromParent());\n+      if (declaration != init) {\n+        Node expressRoot = init.getGrandparent();\n+        Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);\n+        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n+      }\n       removeDeclaration(declaration);\n     }\n \n     /**\n      * Inline an immutable variable into all of its references.\n      */\n-    private void inlineWellDefinedVariable(Var v,\n+    private void inlineWellDefinedVariable(Var v, Node value,\n         List<Reference> refSet) {\n       Reference decl = refSet.get(0);\n-\n       for (int i = 1; i < refSet.size(); i++) {\n-        inlineValue(v, refSet.get(i),\n-            decl.getNameNode().getFirstChild().cloneTree());\n+        inlineValue(v, refSet.get(i), value.cloneTree());\n       }\n       removeDeclaration(decl);\n     }\n     /**\n      * Inline a declared constant.\n      */\n-    private void inlineDeclaredConstant(Var v, List<Reference> refSet) {\n+    private void inlineDeclaredConstant(Var v, Node value,\n+        List<Reference> refSet) {\n       // Replace the references with the constant value\n       Reference decl = null;\n \n         if (r.getNameNode() == v.getNameNode()) {\n           decl = r;\n         } else {\n-          inlineValue(v, r, v.getInitialValue().cloneTree());\n+          inlineValue(v, r, value.cloneTree());\n         }\n       }\n \n      *     to re-parent.\n      */\n     private void inlineValue(Var v, Reference ref, Node value) {\n-      ref.getParent().replaceChild(ref.getNameNode(), value);\n+      Node parent = ref.getParent();\n+      if (ref.isSimpleAssignmentToName()) {\n+        // This is the initial assignment.\n+        ref.getGrandparent().replaceChild(parent, value);\n+      } else {\n+        ref.getParent().replaceChild(ref.getNameNode(), value);\n+      }\n       blacklistVarReferencesInTree(value, v.scope);\n       compiler.reportCodeChange();\n     }\n      * and may be inlined.\n      */\n     private boolean isInlineableDeclaredConstant(Var var,\n-        List<Reference> refs) {\n+        ReferenceCollection refInfo) {\n       if (!identifyConstants.apply(var)) {\n         return false;\n       }\n \n+      if (!refInfo.isAssignedOnce()) {\n+        return false;\n+      }\n+\n+      Reference init = refInfo.getInitializingReferenceForConstants();\n+      if (init == null) {\n+        return false;\n+      }\n+\n+      Node value = init.getAssignedValue();\n+      if (value == null) {\n+        // This constant is either externally defined or initialized indirectly\n+        // (e.g. in an anonymous function used to hide\n+        // temporary variables), so the constant is ineligible for inlining.\n+        return false;\n+      }\n+\n+      // Is the constant's value immutable?\n+      if (!NodeUtil.isImmutableValue(value)) {\n+        return false;\n+      }\n+\n       // Determine if we should really inline a String or not.\n-      return var.getInitialValue().getType() != Token.STRING ||\n-          isStringWorthInlining(var, refs);\n+      return value.getType() != Token.STRING ||\n+          isStringWorthInlining(var, refInfo.references);\n     }\n \n     /**\n      * @return true if the provided reference and declaration can be safely\n      *         inlined according to our criteria\n      */\n-    private boolean canInline(Reference declaration, Reference reference) {\n-      if (!isValidDeclaration(declaration) || !isValidReference(reference)) {\n+    private boolean canInline(\n+        Reference declaration,\n+        Reference initialization,\n+        Reference reference) {\n+      if (!isValidDeclaration(declaration)\n+          || !isValidInitialization(initialization)\n+          || !isValidReference(reference)) {\n+        return false;\n+      }\n+\n+      // If the value is read more than once, skip it.\n+      // VAR declarations and EXPR_RESULT don't need the value, but other\n+      // ASSIGN expressions parents do.\n+      if (declaration != initialization &&\n+          initialization.getGrandparent().getType() != Token.EXPR_RESULT) {\n         return false;\n       }\n \n       // Be very conservative and do no cross control structures or\n       // scope boundaries\n-      if (declaration.getBasicBlock() != reference.getBasicBlock()) {\n+      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n+          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n         return false;\n       }\n \n       // Do not inline into a call node. This would change\n       // the context in which it was being called. For example,\n-      // var a = b.c;\n-      // a();\n+      //   var a = b.c;\n+      //   a();\n       // should not be inlined, because it calls a in the context of b\n       // rather than the context of the window.\n-      if (declaration.getNameNode().getFirstChild().getType() == Token.GETPROP\n-          && reference.getParent().getType() == Token.CALL) {\n-        return false;\n-      }\n-\n-      return canMoveAggressively(declaration) ||\n-          canMoveModerately(declaration, reference);\n+      //   var a = b.c;\n+      //   f(a)\n+      // is ok.\n+      Node value = initialization.getAssignedValue();\n+      Preconditions.checkState(value != null);\n+      if (value.getType() == Token.GETPROP\n+          && reference.getParent().getType() == Token.CALL\n+          && reference.getParent().getFirstChild() == reference.getNameNode()) {\n+        return false;\n+      }\n+\n+      return canMoveAggressively(value) ||\n+          canMoveModerately(initialization, reference);\n     }\n \n     /**\n      * If the value is a literal, we can cross more boundaries to inline it.\n      */\n-    private boolean canMoveAggressively(Reference declaration) {\n-      // Anonymous functions and other mutable objects can move within \n+    private boolean canMoveAggressively(Node value) {\n+      // Anonymous functions and other mutable objects can move within\n       // the same basic block.\n-      Node value = declaration.getNameNode().getFirstChild();\n       return NodeUtil.isLiteralValue(value)\n           || value.getType() == Token.FUNCTION;\n     }\n      * state. Therefore it cannot be moved past anything else that may modify\n      * the value being read or read values that are modified.\n      */\n-    private boolean canMoveModerately(Reference declaration,\n+    private boolean canMoveModerately(\n+        Reference initialization,\n         Reference reference) {\n       // Check if declaration can be inlined without passing\n       // any side-effect causing nodes.\n-      Iterator<Node> it = new NodeIterators.LocalVarMotion(\n-          declaration.getNameNode(),\n-          declaration.getParent(),\n-          declaration.getGrandparent());\n+      Iterator<Node> it;\n+      if (initialization.getParent().getType() == Token.VAR) {\n+        it = NodeIterators.LocalVarMotion.forVar(\n+            initialization.getNameNode(),     // NAME\n+            initialization.getParent(),       // VAR\n+            initialization.getGrandparent()); // VAR container\n+      } else if (initialization.getParent().getType() == Token.ASSIGN) {\n+        Preconditions.checkState(\n+            initialization.getGrandparent().getType() == Token.EXPR_RESULT);\n+        it = NodeIterators.LocalVarMotion.forAssign(\n+            initialization.getNameNode(),     // NAME\n+            initialization.getParent(),       // ASSIGN\n+            initialization.getGrandparent(),  // EXPR_RESULT\n+            initialization.getGrandparent().getParent()); // EXPR container\n+      } else {\n+        throw new IllegalStateException(\"Unexpected initialiation parent\");\n+      }\n       Node targetName = reference.getNameNode();\n       while (it.hasNext()) {\n         Node curNode = it.next();\n     }\n \n     /**\n-     * @return true if the reference is a normal VAR declaration with\n-     *    initial value. (Only normal VARs can be inlined.)\n+     * @return true if the reference is a normal VAR declaration (only normal\n+     * VARs can be inlined).\n      */\n     private boolean isValidDeclaration(Reference declaration) {\n-      return declaration.isDeclaration() &&\n-          declaration.getNameNode().getFirstChild() != null;\n+      return declaration.getParent().getType() == Token.VAR\n+          && declaration.getGrandparent().getType() != Token.FOR;\n+    }\n+\n+    /**\n+     * @return Whether\n+     */\n+    private boolean isValidInitialization(Reference initialization) {\n+      if (initialization == null) {\n+        return false;\n+      } else if (initialization.isDeclaration()) {\n+        // The reference is a normal VAR declaration with\n+        return initialization.getNameNode().getFirstChild() != null;\n+      } else {\n+        Node parent = initialization.getParent();\n+        Preconditions.checkState(\n+            parent.getType() == Token.ASSIGN\n+            && parent.getFirstChild() == initialization.getNameNode());\n+        return true;\n+      }\n     }\n \n     /**\n     private boolean isImmutableAndWellDefinedVariable(Var v,\n         ReferenceCollection refInfo) {\n       List<Reference> refSet = refInfo.references;\n-      if (!isValidDeclaration(refSet.get(0))) {\n-        return false;\n-      }\n-\n-      for (int i = 1; i < refSet.size(); i++) {\n+      int startingReadRef = 1;\n+      Reference refDecl = refSet.get(0);\n+      if (!isValidDeclaration(refDecl)) {\n+        return false;\n+      }\n+\n+      Reference refInit = refInfo.getInitializingReference();\n+      if (!isValidInitialization(refInit)) {\n+        return false;\n+      }\n+\n+      if (refDecl != refInit) {\n+        Preconditions.checkState(refInit == refSet.get(1));\n+        startingReadRef = 2;\n+      }\n+\n+      for (int i = startingReadRef; i < refSet.size(); i++) {\n         Reference ref = refSet.get(i);\n         if (!isValidReference(ref)) {\n           return false;\n         return false;\n       }\n \n-      Node value = refSet.get(0).getNameNode().getFirstChild();\n+      Node value = refInit.getAssignedValue();\n+      Preconditions.checkNotNull(value);\n       return NodeUtil.isImmutableValue(value) &&\n           (value.getType() != Token.STRING ||\n            isStringWorthInlining(v, refInfo.references));\n--- a/src/com/google/javascript/jscomp/NodeIterators.java\n+++ b/src/com/google/javascript/jscomp/NodeIterators.java\n     private Node lookAhead;\n \n     /**\n-     * @param ancestors The ancestors of the point where iteration will start,\n-     *     beginning with the deepest ancestor. The start node will not be\n-     *     exposed in the iteration.\n-     */\n-    LocalVarMotion(Node ... ancestors) {\n-      Preconditions.checkArgument(ancestors.length >= 2);\n-      Preconditions.checkArgument(ancestors[0].getType() == Token.NAME);\n-      Preconditions.checkArgument(ancestors[1].getType() == Token.VAR);\n-\n-      this.iterator = new FunctionlessLocalScope(ancestors);\n-\n-      Node nameNode = ancestors[0];\n-      Node valueNode = nameNode.getFirstChild();\n+     * @return Create a LocalVarMotion for use with moving a value assigned\n+     * at a variable declaration.\n+     */\n+    static LocalVarMotion forVar(\n+        Node name, Node var, Node block) {\n+      Preconditions.checkArgument(var.getType() == Token.VAR);\n+      Preconditions.checkArgument(NodeUtil.isStatement(var));\n+      // The FunctionlessLocalScope must start at \"name\" as this may be used\n+      // before the Normalize pass, and thus the VAR node may define multiple\n+      // names and the \"name\" node may have siblings.  The actual assigned\n+      // value is skipped as it is a child of name.\n+      return new LocalVarMotion(\n+          name, new FunctionlessLocalScope(name, var, block));\n+    }\n+\n+    /**\n+     * @return Create a LocalVarMotion for use with moving a value assigned\n+     * as part of a simple assignment expression (\"a = b;\").\n+     */\n+    static LocalVarMotion forAssign(\n+        Node name, Node assign, Node expr, Node block) {\n+      Preconditions.checkArgument(assign.getType() == Token.ASSIGN);\n+      Preconditions.checkArgument(expr.getType() == Token.EXPR_RESULT);\n+      // The FunctionlessLocalScope must start at \"assign\", to skip the value\n+      // assigned to \"name\" (which would be its sibling).\n+      return new LocalVarMotion(\n+          name, new FunctionlessLocalScope(assign, expr, block));\n+    }\n+\n+    /**\n+     * @param iterator The to use while inspecting the node\n+     *     beginning with the deepest ancestor.\n+     */\n+    private LocalVarMotion(Node nameNode, FunctionlessLocalScope iterator) {\n+      Preconditions.checkArgument(nameNode.getType() == Token.NAME);\n+      Node valueNode = NodeUtil.getAssignedValue(nameNode);\n       this.varName = nameNode.getString();\n       this.valueHasSideEffects = valueNode != null &&\n           NodeUtil.mayHaveSideEffects(valueNode);\n-\n+      this.iterator = iterator;\n       advanceLookAhead(true);\n     }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n       default:\n         return false;\n     }\n+  }\n+\n+  /**\n+   * @return Whether the tree can be affected by side-effects or\n+   * has side-effects.\n+   */\n+  static boolean canBeSideEffected(Node n) {\n+    Set<String> emptySet = Collections.emptySet();\n+    return canBeSideEffected(n, emptySet);\n+  }\n+\n+  /**\n+   * @param knownConstants A set of names known to be constant value at\n+   * node 'n' (such as locals that are last written before n can execute).\n+   * @return Whether the tree can be affected by side-effects or\n+   * has side-effects.\n+   */\n+  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n+    switch (n.getType()) {\n+      case Token.CALL:\n+      case Token.NEW:\n+        // Function calls or constructor can reference changed values.\n+        // TODO(johnlenz): Add some mechanism for determining that functions\n+        // are unaffected by side effects.\n+        return true;\n+      case Token.NAME:\n+        // Non-constant names values may have been changed.\n+        return !NodeUtil.isConstantName(n)\n+            && !knownConstants.contains(n.getString());\n+\n+      // Properties on constant NAMEs can still be side-effected.\n+      case Token.GETPROP:\n+      case Token.GETELEM:\n+        return true;\n+    }\n+\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      if (canBeSideEffected(c, knownConstants)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;    \n   }\n \n   /*\n   }\n \n   /**\n+   * For an assignment or variable declaration get the assigned value.\n+   * @return The value node representing the new value.\n+   */\n+  static Node getAssignedValue(Node n) {\n+    Preconditions.checkState(isName(n));\n+    Node parent = n.getParent();\n+    if (isVar(parent)) {\n+      return n.getFirstChild();\n+    } else if (isAssign(parent) && parent.getFirstChild() == n) {\n+      return n.getNext();\n+    } else {\n+      return null;\n+    }\n+  }\n+  \n+  /**\n    * Is this a STRING node?\n    */\n   static boolean isString(Node n) {\n       if (parent.hasMoreThanOneChild()) {\n         parent.removeChild(node);\n       } else {\n+        // Remove the node from the parent, so it can be reused.\n+        parent.removeChild(node);\n         // This would leave an empty VAR, remove the VAR itself.\n         removeChild(parent.getParent(), parent);\n       }\n       node.detachChildren();\n     } else if (parent.getType() == Token.LABEL\n         && node == parent.getLastChild()) {\n+      // Remove the node from the parent, so it can be reused.\n+      parent.removeChild(node);\n       // A LABEL without children can not be referred to, remove it.\n       removeChild(parent.getParent(), parent);\n     } else if (parent.getType() == Token.FOR\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   private final AbstractCompiler compiler;\n   private final boolean assertOnChange;\n   private static final boolean CONVERT_WHILE_TO_FOR = true;\n-  // TODO(johnlenz): Remove assignment splitting support.\n-  private static final boolean ALLOW_ASSIGNMENT_SPLITTING = false;\n   static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n \n   Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n     if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n       extractForInitializer(n, null, null);\n       splitVarDeclarations(n);\n-      if (ALLOW_ASSIGNMENT_SPLITTING) {\n-        splitAssignments(n);\n-      }\n     }\n   }\n \n         }\n       }\n     }\n-  }\n-\n-\n-  /**\n-   * Split a compound assignment into individual statements.  This does not\n-   * split assignments within conditions, such as \"while(a = b = foo()){ blah }\"\n-   * which would require moving the code into the code while block.\n-   *\n-   * @param n The assignment node to break down.\n-   */\n-  private void splitAssignments(Node n) {\n-    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n-      next = c.getNext();\n-      if (NodeUtil.isExpressionNode(c)) {\n-        Node expression = c;\n-        while (isCompoundAssignment(expression.getFirstChild())) {\n-          Node assign = expression.getFirstChild();\n-          Node rhs = assign.getLastChild();\n-          Node nameNode = rhs.getFirstChild();\n-\n-          // Verify this is something safe to split.\n-          if (NodeUtil.mayEffectMutableState(nameNode)) {\n-            break;\n-          }\n-\n-          // Split it. For example change \"a = b = c = foo();\"\n-          // into \"b = c = foo(); a = b;\"\n-          assign.removeChild(rhs);\n-          assign.addChildToBack(nameNode.cloneTree());\n-\n-          Node newChild = NodeUtil.newExpr(rhs);\n-          n.addChildBefore(newChild, expression);\n-          expression = newChild;  // next iteration.\n-          compiler.reportCodeChange();\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * @param n The node to check.\n-   * @return Whether n is an assignment and the RHS is also an\n-   *     assignment.\n-   */\n-  private static boolean isCompoundAssignment(Node n) {\n-    return (NodeUtil.isAssignmentOp(n)\n-        && NodeUtil.isAssignmentOp(n.getLastChild()));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n \n       // If this is a declaration that does not instantiate the variable,\n       // it's not well-defined.\n-      Reference decl = references.get(0);\n-      if (!decl.isInitializingDeclaration()) {\n+      Reference init = getInitializingReference();\n+      if (init == null) {\n         return false;\n       }\n \n-      BasicBlock declBlock = decl.getBasicBlock();\n+      Preconditions.checkState(references.get(0).isDeclaration());\n+      BasicBlock initBlock = init.getBasicBlock();\n       for (int i = 1; i < size; i++) {\n-        if (!declBlock.provablyExecutesBefore(\n+        if (!initBlock.provablyExecutesBefore(\n                 references.get(i).getBasicBlock())) {\n           return false;\n         }\n       return true;\n     }\n \n-    boolean isNeverReassigned() {\n+    /**\n+     * @param index The index into the references array to look for an \n+     * assigning declaration.\n+     *\n+     * This is either the declaration if a value is assigned (such as\n+     * \"var a = 2\", \"function a()...\", \"... catch (a)...\").\n+     */\n+    private boolean isInitializingDeclarationAt(int index) {\n+      Reference maybeInit = references.get(index);\n+      if (maybeInit.isInitializingDeclaration()) {\n+        // This is a declaration that represents the initial value. \n+        // Specifically, var declarations without assignments such as \"var a;\"\n+        // are not.\n+        return true;\n+      }\n+      return false;\n+    }\n+    \n+    /**\n+     * @param index The index into the references array to look for an \n+     * initialized assignment reference. That is, an assignment immediately\n+     * follow a variable declaration that itself does not initialize the\n+     * variable.\n+     */\n+    private boolean isInitializingAssignmentAt(int index) {\n+      if (index < references.size() && index > 0) {\n+        Reference maybeDecl = references.get(index-1);\n+        if (maybeDecl.isVarDeclaration()) {\n+          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n+          Reference maybeInit = references.get(index);\n+          if (maybeInit.isSimpleAssignmentToName()) {\n+            return true;\n+          }\n+        }\n+      }\n+      return false;\n+    }    \n+\n+    /**\n+     * @return The reference that provides the value for the variable at the\n+     * time of the first read, if known, otherwise null.\n+     *\n+     * This is either the variable declaration (\"var a = ...\") or first\n+     * reference following the declaration if it is an assignment.\n+     */\n+    Reference getInitializingReference() {\n+      if (isInitializingDeclarationAt(0)) {\n+        return references.get(0);\n+      } else if (isInitializingAssignmentAt(1)) {\n+        return references.get(1);\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Constants are allowed to be defined after their first use.\n+     */\n+    Reference getInitializingReferenceForConstants() {\n       int size = references.size();\n-      for (int i = 1; i < size; i++) {\n-        if (references.get(i).isLvalue()) {\n-          return false;\n+      for (int i = 0; i < size; i++) {\n+        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n+          return references.get(i);\n         }\n       }\n-\n-      return true;\n+      return null;\n+    }\n+\n+    /**\n+     * @return Whether the variable is only assigned a value once.\n+     */\n+    boolean isAssignedOnce() {\n+      boolean assigned = false;\n+      int size = references.size();\n+      for (int i = 0; i < size; i++) {\n+        Reference ref = references.get(i);\n+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n+          if (!assigned) {\n+            assigned = true;\n+          } else {\n+            return false;\n+          }\n+        }\n+      }\n+      return assigned;\n+    }\n+\n+    boolean firstReferenceIsAssigningDeclaration() {\n+      int size = references.size();\n+      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n+        return true;\n+      }\n+      return false;\n     }\n   }\n \n           grandparent.getType() == Token.FUNCTION;\n     }\n \n+    boolean isVarDeclaration() {\n+      return parent.getType() == Token.VAR;\n+    }\n+\n+    boolean isHoistedFunction() {\n+      return NodeUtil.isFunctionDeclaration(parent) &&\n+          (grandparent.getType() == Token.SCRIPT ||\n+           grandparent.getParent().getType() == Token.FUNCTION);\n+    }\n+\n     /**\n      * Determines whether the variable is initialized at the declaration.\n      */\n           (parent.getType() != Token.VAR || nameNode.getFirstChild() != null);\n     }\n \n+   /**\n+    * @return For an assignment or variable declaration return the assigned\n+    * value, otherwise null.\n+    */\n+    Node getAssignedValue() {\n+      return NodeUtil.getAssignedValue(getNameNode());\n+    }\n+\n     BasicBlock getBasicBlock() {\n       return basicBlock;\n     }\n     private static boolean isForIn(Node n) {\n       return n.getType() == Token.FOR && n.getChildCount() == 3;\n     }\n-    \n+\n     private static boolean isLhsOfForInExpression(Node n) {\n       Node parent = n.getParent();\n       if (parent.getType() == Token.VAR) {\n         return isLhsOfForInExpression(parent);\n-      } \n+      }\n       return isForIn(parent) && parent.getFirstChild() == n;\n     }\n-    \n+\n+    boolean isSimpleAssignmentToName() {\n+      return parent.getType() == Token.ASSIGN\n+          && parent.getFirstChild() == nameNode;\n+    }\n+\n     boolean isLvalue() {\n       int parentType = parent.getType();\n-      return parentType == Token.VAR \n+      return (parentType == Token.VAR && nameNode.getFirstChild() != null)\n           || parentType == Token.INC\n           || parentType == Token.DEC\n           || (NodeUtil.isAssignmentOp(parent)\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     return parent;\n   }\n \n+  Scope getGlobalScope() {\n+    Scope result = this;\n+    while (result.getParent() != null) {\n+      result = result.getParent();\n+    }\n+    return result;\n+  }\n+\n   @Override\n   public StaticScope<JSType> getParentScope() {\n     return parent;\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n           Node nameNode = Node.newString(Token.NAME, varName);\n           getSynthesizedExternsRoot().addChildToBack(\n               new Node(Token.VAR, nameNode));\n-          scope.declare(varName, nameNode,\n+          scope.getGlobalScope().declare(varName, nameNode,\n               null, getSynthesizedExternsInput());\n         }\n       }\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n     private void checkVar(NodeTraversal t, Var v, List<Reference> references) {\n       blocksWithDeclarations.clear();\n       boolean isDeclaredInScope = false;\n+      Reference hoistedFn = null;\n+\n+      // Look for hoisted functions.\n+      for (Reference reference : references) {\n+        if (reference.isHoistedFunction()) {\n+          blocksWithDeclarations.add(reference.getBasicBlock());\n+          isDeclaredInScope = true;\n+          hoistedFn = reference;\n+          break;\n+        }\n+      }\n \n       for (Reference reference : references) {\n+        if (reference == hoistedFn) {\n+          continue;\n+        }\n+\n         BasicBlock basicBlock = reference.getBasicBlock();\n         boolean isDeclaration = reference.isDeclaration();\n \n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n         \"function (){ return goo() && foo();}\", \"foo\");\n   }\n \n+  public void testCanExposeExpression4() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"if (goo.a(1, foo()));\", \"foo\");    \n+  }\n+\n+  public void testCanExposeExpression5() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"if (goo['a'](foo()));\", \"foo\");    \n+  }\n+\n+  public void testCanExposeExpression6() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"z:if (goo.a(1, foo()));\", \"foo\");    \n+  }\n+  \n \n   public void testMoveExpression1() {\n     // There isn't a reason to do this, but it works.\n         \"var temp_2;\" +\n         \"if (1) temp_2 = foo(); else temp_2 = 0;\" +\n         \"if (temp_const_1(1, temp_const_0, temp_2));\");\n-  }\n-\n-  public void testExposeExpression12() {\n-    // Verify that \"this\" is preserved...\n-    helperExposeExpression(\n-        \"if (goo.a(1, foo()));\",\n-        \"foo\",\n-        \"var temp_const_1 = goo;\" +\n-        \"var temp_const_0 = temp_const_1.a;\" +\n-        \"if (temp_const_0.call(temp_const_1, 1, foo()));\");\n-  }\n-\n-  public void testExposeExpression13() {\n-    // Verify that \"this\" is preserved...\n-    helperExposeExpression(\n-        \"if (goo['a'](foo()));\",\n-        \"foo\",\n-        \"var temp_const_1 = goo;\" +\n-        \"var temp_const_0 = temp_const_1['a'];\" +\n-        \"if (temp_const_0.call(temp_const_1, foo()));\");\n-  }\n-\n-  public void testExposeExpression14() {\n-    // Verify that \"this\" is preserved...\n-    helperExposeExpression(\n-        \"z:if (goo.a(1, foo()));\",\n-        \"foo\",\n-        \"var temp_const_1 = goo;\" +\n-        \"var temp_const_0 = temp_const_1.a;\" +\n-        \"z:if (temp_const_0.call(temp_const_1, 1, foo()));\");\n   }\n \n   /** Test case helpers. */\n     Node callSite = findCall(tree, fnName);\n     assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n \n+    DecompositionType result = decomposer.canExposeExpression(callSite);\n+    assertTrue(result == DecompositionType.DECOMPOSABLE);\n+\n     compiler.resetUniqueNameId();\n     decomposer.exposeExpression(callSite);\n     String explanation = expectedRoot.checkTreeEquals(tree);\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"foo\", INLINE_BLOCK, true);\n   }\n \n+  public void testInlineReferenceInExpression16() {\n+    helperInlineReferenceToFunction(\n+        \"var z = {};\" +\n+        \"function foo(a){z = {};return true;}; \" +\n+        \"function x() { z[bar()] = foo(1) }\",\n+\n+        \"var z = {};\" +\n+        \"function foo(a){z = {};return true;}; \" +\n+        \"function x() {\" +\n+            \"var JSCompiler_temp_const_1=z;\" +\n+            \"var JSCompiler_temp_const_0=bar();\" +\n+            \"{\" +\n+             \"var JSCompiler_inline_result_2;\" +\n+             \"z= {};\" +\n+             \"JSCompiler_inline_result_2 = true;\" +\n+            \"}\" +\n+            \"JSCompiler_temp_const_1[JSCompiler_temp_const_0] = \" +\n+                \"JSCompiler_inline_result_2;\" +\n+        \"}\",\n+        \"foo\", INLINE_BLOCK, true);\n+  }\n+\n+  public void testInlineReferenceInExpression17() {\n+    helperInlineReferenceToFunction(\n+        \"var z = {};\" +\n+        \"function foo(a){z = {};return true;}; \" +\n+        \"function x() { z.y.x.gack = foo(1) }\",\n+\n+        \"var z = {};\" +\n+        \"function foo(a){z = {};return true;}; \" +\n+        \"function x() {\" +\n+            \"var JSCompiler_temp_const_0=z.y.x;\" +\n+            \"{\" +\n+             \"var JSCompiler_inline_result_1;\" +\n+             \"z= {};\" +\n+             \"JSCompiler_inline_result_1 = true;\" +\n+            \"}\" +\n+            \"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;\" +\n+        \"}\",\n+        \"foo\", INLINE_BLOCK, true);\n+  }\n+\n \n   public void testInlineWithinCalls1() {\n     // Call in within a call\n--- a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n     test(\"var ABC=2; var x = ABC;\", \"var x=2\");\n     test(\"var AA = 'aa'; AA;\", \"'aa'\");\n     test(\"var A_A=10; A_A + A_A;\", \"10+10\");\n-    testSame(\"var AA; AA=1\");\n+    test(\"var AA=1\", \"\");\n+    test(\"var AA; AA=1\", \"1\");\n+    test(\"var AA; if (false) AA=1; AA;\", \"if (false) 1; 1;\");\n+    testSame(\"var AA; if (false) AA=1; else AA=2; AA;\");\n+\n+    test(\"var AA;(function () {AA=1})()\",\n+         \"(function () {1})()\");\n \n     // Make sure that nothing explodes if there are undeclared variables.\n     testSame(\"var x = AA;\");\n     test(\"/** @const */var abc=2; var x = abc;\", \"var x=2\");\n     test(\"/** @const */var aa = 'aa'; aa;\", \"'aa'\");\n     test(\"/** @const */var a_a=10; a_a + a_a;\", \"10+10\");\n-    testSame(\"/** @const */var aa; aa=1;\");\n+    test(\"/** @const */var aa=1;\", \"\");\n+    test(\"/** @const */var aa; aa=1;\", \"1\");\n+    test(\"/** @const */var aa;(function () {aa=1})()\", \"(function () {1})()\");\n+    test(\"/** @const */var aa;(function () {aa=1})(); var z=aa\",\n+         \"(function () {1})(); var z=1\");\n+    testSame(\"/** @const */var aa;(function () {var y; aa=y})(); var z=aa\");\n \n     // Don't inline if it will make the output larger.\n     testSame(\"/** @const */var aa = '1234567890'; foo(aa); foo(aa); foo(aa);\");\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n         new String[] { \"\", \"var b = 2;\" });\n   }\n \n-  public void testDoNotExitConditional() {\n+  public void testDoNotExitConditional1() {\n     testSame(\"if (true) { var x = 1; } var z = x;\");\n+  }\n+\n+  public void testDoNotExitConditional2() {\n     testSame(\"if (true) var x = 1; var z = x;\");\n+  }\n+\n+\n+  public void testDoNotExitConditional3() {\n+    testSame(\"var x; if (true) x=1; var z = x;\");\n   }\n \n   public void testDoNotExitLoop() {\n \n   public void testInsideIfConditional() {\n     test(\"var a = foo(); if (a) { alert(3); }\", \"if (foo()) { alert(3); }\");\n+    test(\"var a; a = foo(); if (a) { alert(3); }\", \"if (foo()) { alert(3); }\");\n+  }\n+\n+  public void testOnlyReadAtInitialization() {\n+    test(\"var a; a = foo();\", \"foo();\");\n+    test(\"var a; if (a = foo()) { alert(3); }\", \"if (foo()) { alert(3); }\");\n+    test(\"var a; switch (a = foo()) {}\", \"switch(foo()) {}\");\n+    test(\"var a; function f(){ return a = foo(); }\",\n+         \"function f(){ return foo(); }\");\n+    test(\"function f(){ var a; return a = foo(); }\",\n+         \"function f(){ return foo(); }\");\n+    test(\"var a; with (a = foo()) { alert(3); }\", \"with (foo()) { alert(3); }\");\n+\n+    test(\"var a; b = (a = foo());\", \"b = foo();\");\n+    test(\"var a; while(a = foo()) { alert(3); }\",\n+         \"while(foo()) { alert(3); }\");\n+    test(\"var a; for(;a = foo();) { alert(3); }\",\n+         \"for(;foo();) { alert(3); }\");\n+    test(\"var a; do {} while(a = foo()) { alert(3); }\",\n+         \"do {} while(foo()) { alert(3); }\");\n+  }\n+\n+  public void testImmutableWithSingleReferenceAfterInitialzation() {\n+    test(\"var a; a = 1;\", \"1;\");\n+    test(\"var a; if (a = 1) { alert(3); }\", \"if (1) { alert(3); }\");\n+    test(\"var a; switch (a = 1) {}\", \"switch(1) {}\");\n+    test(\"var a; function f(){ return a = 1; }\",\n+         \"function f(){ return 1; }\");\n+    test(\"function f(){ var a; return a = 1; }\",\n+         \"function f(){ return 1; }\");\n+    test(\"var a; with (a = 1) { alert(3); }\", \"with (1) { alert(3); }\");\n+\n+    test(\"var a; b = (a = 1);\", \"b = 1;\");\n+    test(\"var a; while(a = 1) { alert(3); }\",\n+         \"while(1) { alert(3); }\");\n+    test(\"var a; for(;a = 1;) { alert(3); }\",\n+         \"for(;1;) { alert(3); }\");\n+    test(\"var a; do {} while(a = 1) { alert(3); }\",\n+         \"do {} while(1) { alert(3); }\");\n+  }\n+\n+  public void testSingleReferenceAfterInitialzation() {\n+    test(\"var a; a = foo();a;\", \"foo();\");\n+    testSame(\"var a; if (a = foo()) { alert(3); } a;\");\n+    testSame(\"var a; switch (a = foo()) {} a;\");\n+    testSame(\"var a; function f(){ return a = foo(); } a;\");\n+    testSame(\"function f(){ var a; return a = foo(); a;}\");\n+    testSame(\"var a; with (a = foo()) { alert(3); } a;\");\n+    testSame(\"var a; b = (a = foo()); a;\");\n+    testSame(\"var a; while(a = foo()) { alert(3); } a;\");\n+    testSame(\"var a; for(;a = foo();) { alert(3); } a;\");\n+    testSame(\"var a; do {} while(a = foo()) { alert(3); } a;\");\n   }\n \n   public void testInsideIfBranch() {\n   // Test movement of values that are complex but lack side effects\n \n   public void testDoNotCrossAssignment() {\n-    testSame(\"var x = {};\\nvar y = x.a;\\nx.a = 1;\\nvar z = y;\");\n+    testSame(\"var x = {}; var y = x.a; x.a = 1; var z = y;\");\n     testSame(\"var a = this.id; foo(this.id = 3, a);\");\n   }\n \n \n   public void testNoInlineGetpropIntoCall() {\n     test(\"var a = b; a();\", \"b();\");\n+    test(\"var a = b.c; f(a);\", \"f(b.c);\");\n     testSame(\"var a = b.c; a();\");\n   }\n \n          \"var x = this.foo(); this.bar(); this.baz(x);\");\n   }\n \n+  public void testInlineAliases1b() {\n+    test(\"var x = this.foo(); this.bar(); var y; y = x; this.baz(y);\",\n+         \"var x = this.foo(); this.bar(); x; this.baz(x);\");\n+  }\n+\n+  public void testInlineAliases1c() {\n+    test(\"var x; x = this.foo(); this.bar(); var y = x; this.baz(y);\",\n+         \"var x; x = this.foo(); this.bar(); this.baz(x);\");\n+  }\n+\n+  public void testInlineAliases1d() {\n+    test(\"var x; x = this.foo(); this.bar(); var y; y = x; this.baz(y);\",\n+         \"var x; x = this.foo(); this.bar(); x; this.baz(x);\");\n+  }\n+\n   public void testInlineAliases2() {\n     test(\"var x = this.foo(); this.bar(); \" +\n          \"function f() { var y = x; this.baz(y); }\",\n          \"var x = this.foo(); this.bar(); function f() { this.baz(x); }\");\n   }\n \n+  public void testInlineAliases2b() {\n+    test(\"var x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; this.baz(y); }\",\n+         \"var x = this.foo(); this.bar(); function f() { this.baz(x); }\");\n+  }\n+\n+  public void testInlineAliases2c() {\n+    test(\"var x; x = this.foo(); this.bar(); \" +\n+         \"function f() { var y = x; this.baz(y); }\",\n+         \"var x; x = this.foo(); this.bar(); function f() { this.baz(x); }\");\n+  }\n+\n+  public void testInlineAliases2d() {\n+    test(\"var x; x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; this.baz(y); }\",\n+         \"var x; x = this.foo(); this.bar(); function f() { this.baz(x); }\");\n+  }\n+\n   public void testNoInlineAliases1() {\n     testSame(\n         \"var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);\");\n   }\n \n+  public void testNoInlineAliases1b() {\n+    testSame(\n+        \"var x = this.foo(); this.bar(); var y; y = x; x = 3; this.baz(y);\");\n+  }\n+\n   public void testNoInlineAliases2() {\n     testSame(\n         \"var x = this.foo(); this.bar(); var y = x; y = 3; this.baz(y); \");\n+  }\n+\n+  public void testNoInlineAliases2b() {\n+    testSame(\n+        \"var x = this.foo(); this.bar(); var y; y = x; y = 3; this.baz(y); \");\n   }\n \n   public void testNoInlineAliases3() {\n          \"function g() { x = 3; }\");\n   }\n \n+  public void testNoInlineAliases3b() {\n+    testSame(\n+         \"var x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; g(); this.baz(y); } \" +\n+         \"function g() { x = 3; }\");\n+  }\n+\n   public void testNoInlineAliases4() {\n     testSame(\n          \"var x = this.foo(); this.bar(); \" +\n          \"function f() { var y = x; y = 3; this.baz(y); }\");\n   }\n \n+  public void testNoInlineAliases4b() {\n+    testSame(\n+         \"var x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; y = 3; this.baz(y); }\");\n+  }\n+\n   public void testNoInlineAliases5() {\n     testSame(\n         \"var x = this.foo(); this.bar(); var y = x; this.bing();\" +\n         \"this.baz(y); x = 3;\");\n   }\n \n+  public void testNoInlineAliases5b() {\n+    testSame(\n+        \"var x = this.foo(); this.bar(); var y; y = x; this.bing();\" +\n+        \"this.baz(y); x = 3;\");\n+  }\n+\n   public void testNoInlineAliases6() {\n     testSame(\n         \"var x = this.foo(); this.bar(); var y = x; this.bing();\" +\n         \"this.baz(y); y = 3;\");\n   }\n \n+  public void testNoInlineAliases6b() {\n+    testSame(\n+        \"var x = this.foo(); this.bar(); var y; y = x; this.bing();\" +\n+        \"this.baz(y); y = 3;\");\n+  }\n+\n   public void testNoInlineAliases7() {\n     testSame(\n          \"var x = this.foo(); this.bar(); \" +\n          \"function f() { var y = x; this.bing(); this.baz(y); x = 3; }\");\n   }\n \n+  public void testNoInlineAliases7b() {\n+    testSame(\n+         \"var x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; this.bing(); this.baz(y); x = 3; }\");\n+  }\n+\n   public void testNoInlineAliases8() {\n     testSame(\n          \"var x = this.foo(); this.bar(); \" +\n          \"function f() { var y = x; this.baz(y); y = 3; }\");\n   }\n+\n+  public void testNoInlineAliases8b() {\n+    testSame(\n+         \"var x = this.foo(); this.bar(); \" +\n+         \"function f() { var y; y = x; this.baz(y); y = 3; }\");\n+  }\n+\n+  public void testSideEffectOrder() {\n+    // z can not be changed by the call to y, so x can be inlined.\n+    String EXTERNS = \"var z; function f(){}\";\n+    test(EXTERNS,\n+         \"var x = f(y.a, y); z = x;\",\n+         \"z = f(y.a, y);\", null, null);\n+    // z.b can be changed by the call to y, so x can not be inlined.\n+    testSame(EXTERNS, \"var x = f(y.a, y); z.b = x;\", null, null);\n+  }\n+\n+  public void testInlineParameterAlias1() {\n+    test(\n+      \"function f(x) {\" +\n+      \"  var y = x;\" +\n+      \"  g();\" +\n+      \"  y;y;\" +\n+      \"}\",\n+      \"function f(x) {\" +\n+      \"  g();\" +\n+      \"  x;x;\" +\n+      \"}\"\n+      );\n+  }\n+\n+  public void testInlineParameterAlias2() {\n+    test(\n+      \"function f(x) {\" +\n+      \"  var y; y = x;\" +\n+      \"  g();\" +\n+      \"  y;y;\" +\n+      \"}\",\n+      \"function f(x) {\" +\n+      \"  x;\" +\n+      \"  g();\" +\n+      \"  x;x;\" +\n+      \"}\"\n+      );\n+  }\n+\n+  public void testInlineFunctionAlias1() {\n+    test(\n+      \"function f(x) {};\" +\n+      \"var y = f;\" +\n+      \"g();\" +\n+      \"y();y();\",\n+      \"function f(x) {};\" +\n+      \"g();\" +\n+      \"f();f();\"\n+      );\n+  }\n+\n+  public void testInlineFunctionAlias2() {\n+    test(\n+      \"function f(x) {};\" +\n+      \"var y; y = f;\" +\n+      \"g();\" +\n+      \"y();y();\",\n+      \"function f(x) {};\" +\n+      \"f;\" +\n+      \"g();\" +\n+      \"f();f();\"\n+      );\n+  }\n+\n+  public void testInlineCatchAlias1() {\n+    test(\n+      \"try {\" +\n+      \"} catch (e) {\" +\n+      \"  var y = e;\" +\n+      \"  g();\" +\n+      \"  y;y;\" +\n+      \"}\",\n+      \"try {\" +\n+      \"} catch (e) {\" +\n+      \"  g();\" +\n+      \"  e;e;\" +\n+      \"}\"\n+      );\n+  }\n+\n+  public void testInlineCatchAlias2() {\n+    test(\n+      \"try {\" +\n+      \"} catch (e) {\" +\n+      \"  var y; y = e;\" +\n+      \"  g();\" +\n+      \"  y;y;\" +\n+      \"}\",\n+      \"try {\" +\n+      \"} catch (e) {\" +\n+      \"  e;\" +\n+      \"  g();\" +\n+      \"  e;e;\" +\n+      \"}\"\n+      );\n+  }\n }\n--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n     assertTrue(\"Variable X not found! \" + root.toStringTree(), found);\n \n     List<Node> currentAncestors = searchIt.currentAncestors();\n-    Iterator<Node> moveIt = new LocalVarMotion(\n-        currentAncestors.toArray(new Node[currentAncestors.size()]));\n+    assert(currentAncestors.size() >= 3);\n+    Iterator<Node> moveIt = LocalVarMotion.forVar(\n+        currentAncestors.get(0),\n+        currentAncestors.get(1),\n+        currentAncestors.get(2));\n     List<Integer> actualTokens = Lists.newArrayList();\n     while (moveIt.hasNext()) {\n       actualTokens.add(moveIt.next().getType());\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"do{var a = foo(1); var b} while(false);\");\n   }\n \n-  public void disable_testSplitAssign() {\n-    testSame(\"a = 0\");\n-    test(\"a = b = 0\",\n-         \"b = 0; a = b\");\n-    test(\"a = b = c = foo()\",\n-         \"c = foo(); b = c; a = b\");\n-    test(\"a.a = a.b = 0\",\n-         \"a.b = 0; a.a = a.b\");\n-    test(\"a[0] = a[1] = 0\",\n-         \"a[1] = 0; a[0] = a[1]\");\n-    testSame(\"a[x++] = a[x++] = 0\");\n-    testSame(\"a[getNext()] = a[getNext()] = 0\");\n-\n-    testSame(\"for(;a=b=0;c=d=0);\");\n-\n-    // Verify any assign op is split.\n-    test(\"a *= b -= c += foo()\",\n-         \"c += foo(); b -= c; a *= b\");\n-  }\n-\n   public void testUnhandled() {\n     testSame(\"var x = y = 1\");\n   }\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   }\n \n   public void testParameter() {\n-    checkSynthesizedExtern(\"function(x){}\", \"\");\n+    checkSynthesizedExtern(\"function f(x){}\", \"\");\n   }\n \n   public void testLocalVar() {\n-    checkSynthesizedExtern(\"function(){x}\", \"var x\");\n+    checkSynthesizedExtern(\"function f(){x}\", \"var x\");\n+  }\n+\n+  public void testTwoLocalVars() {\n+    checkSynthesizedExtern(\"function f(){x}function g() {x}\", \"var x\");\n   }\n \n   public void testInnerFunctionLocalVar() {\n-    checkSynthesizedExtern(\"function(){function() {x}}\", \"var x\");\n+    checkSynthesizedExtern(\"function f(){function g() {x}}\", \"var x\");\n   }\n \n   public void testNoCreateVarsForLabels() {\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n     assertRedeclare(\"function x() { var y; if (true) { var y; } }\");\n   }\n \n+  public void testHoistedFunction1() {\n+    assertNoWarning(\"f(); function f() {}\");\n+  }\n+\n+  public void testHoistedFunction2() {\n+    assertNoWarning(\"function g() { f(); function f() {} }\");\n+  }\n+\n+  public void testNonHoistedFunction() {\n+    assertUndeclared(\"if (true) { f(); function f() {} }\");\n+  }\n+\n   /**\n    * Expects the JS to generate one bad-read error.\n    */", "timestamp": 1257880563, "metainfo": ""}