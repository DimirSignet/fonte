{"sha": "e276b9f30132f9cc0a7a47d6181ca54e4214b5cc", "log": "Make OptimizeReturns safe for goog.editor.  R=nicksantos DELTA=69  (65 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=201   ", "commit": "\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n     }\n \n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+    \n+    // Don't modify unused definitions for two reasons:\n+    // 1) It causes unnecessary churn\n+    // 2) Other definitions might be used to reflect on this one using\n+    //    goog.reflect.object (the check for definitions with uses is below).\n+    if (useSites.isEmpty()) {\n+      return true;\n+    }    \n+    \n     for (UseSite site : useSites) {\n+      // This catches the case where an object literal in goog.reflect.object\n+      // and a prototype method have the same property name.\n+\n+      // TODO(johnlenz): The keys of one object can be used to reflect on\n+      // another using \"goog.reflect.object\" or similar.  It seems like this\n+      // should be prohibited but TrogEdit uses this.\n+\n+      Node nameNode = site.node;\n+      Collection<Definition> singleSiteDefinitions =\n+          defFinder.getDefinitionsReferencedAt(nameNode);\n+      if (singleSiteDefinitions.size() > 1) {\n+        return true;\n+      }\n+\n       // Assume indirect definitions references use the result\n       Node useNodeParent = site.node.getParent();\n       if (isCall(site)) {\n--- a/test/com/google/javascript/jscomp/OptimizeReturnsTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeReturnsTest.java\n     String source = newlineJoin(\n         \"var a = {b:function(){return 1;}}\",\n         \"for(c in a) (a[c])();\",\n-        \"a()\");\n+        \"a.b()\");\n     testSame(source);\n   }\n \n     String source = newlineJoin(\n         \"var a = {b:function fn(){return 1;}}\",\n         \"for(c in a) (a[c])();\",\n-        \"a()\");\n+        \"a.b()\");\n     testSame(source);\n   }\n \n   public void testNoRewriteArrLit() throws Exception {\n     String source = newlineJoin(\n         \"var a = [function(){return 1;}]\",\n-        \"(a[0])();\",\n-        \"a()\");\n-    testSame(source);\n-  }\n+        \"(a[0])();\");\n+    testSame(source);\n+  }\n+\n+  public void testPrototypeMethod1() throws Exception {\n+    String source = newlineJoin(\n+        \"function c(){}\",\n+        \"c.prototype.a = function(){return 1}\",\n+        \"var x = new c;\",\n+        \"x.a()\");\n+    String result = newlineJoin(\n+        \"function c(){}\",\n+        \"c.prototype.a = function(){return}\",\n+        \"var x = new c;\",\n+        \"x.a()\");\n+    test(source, result);\n+  }\n+  \n+  public void testPrototypeMethod2() throws Exception {\n+    String source = newlineJoin(\n+        \"function c(){}\",\n+        \"c.prototype.a = function(){return 1}\",\n+        \"goog.reflect.object({a: 'v'})\",\n+        \"var x = new c;\",\n+        \"x.a()\");    \n+    testSame(source);\n+  }  \n+  \n+  public void testPrototypeMethod3() throws Exception {\n+    String source = newlineJoin(\n+        \"function c(){}\",\n+        \"c.prototype.a = function(){return 1}\",\n+        \"var x = new c;\",\n+        \"for(var key in goog.reflect.object({a: 'v'})){ x[key](); }\",\n+        \"x.a()\");    \n+    testSame(source);\n+  } \n+  \n+  public void testPrototypeMethod4() throws Exception {\n+    String source = newlineJoin(\n+        \"function c(){}\",\n+        \"c.prototype.a = function(){return 1}\",\n+        \"var x = new c;\",\n+        \"for(var key in goog.reflect.object({a: 'v'})){ x[key](); }\");    \n+    testSame(source);\n+  }  \n \n   public void testCallOrApply() throws Exception {\n     // TODO(johnlenz): Add support for .call and .apply", "timestamp": 1294185853, "metainfo": ""}