{"sha": "c61dccaace9a74483f45d578121b8faee04b0f57", "log": "Optimize unused return values  R=acleung DELTA=574  (566 added, 0 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1169980   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Remove unused and constant parameters.\n    */\n   public boolean optimizeParameters;\n+\n+  /**\n+   * Remove unused return values.\n+   */\n+  public boolean optimizeReturns;\n \n   /**\n    * Provide formal names for elements of arguments array.\n     convertToDottedProperties = false;\n     rewriteFunctionExpressions = false;\n     optimizeParameters = false;\n+    optimizeReturns = false;\n \n     // Renaming\n     variableRenaming = VariableRenamingPolicy.OFF;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // and inline functions).  Smart Name Removal does better if run before\n     // this pass.\n     if (options.devirtualizePrototypeMethods) {\n-      passes.add(devirtualizePrototypeMethods);\n+      passes.add(optimizeCalls);\n     }\n \n     if (options.customPasses != null) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new DevirtualizePrototypeMethods(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Rewrite instance methods as static methods, to make them easier\n+   * to inline.\n+   */\n+  private final PassFactory optimizeCalls =\n+      new PassFactory(\"optimizeCalls\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      OptimizeCallGraph passes = new OptimizeCallGraph(compiler);\n+      if (options.optimizeReturns) {\n+        passes.addPass(new OptimizeReturns(compiler));\n+      }\n+      // Devirtualize must be last as it modifies the the values\n+      // represented by the simple definition finder.\n+      passes.addPass(new DevirtualizePrototypeMethods(compiler));\n+      return passes;\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n  * </pre>\n  *\n  */\n-class DevirtualizePrototypeMethods implements SpecializationAwareCompilerPass {\n+class DevirtualizePrototypeMethods\n+    implements OptimizeCallGraph.CallGraphCompilerPass,\n+               SpecializationAwareCompilerPass {\n   private final AbstractCompiler compiler;\n   private SpecializeModule.SpecializationState specializationState;\n \n   public void process(Node externs, Node root) {\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n-\n-    for (DefinitionSite defSite : defFinder.getDefinitionSites()) {\n-      rewriteDefinitionIfEligible(defSite, defFinder);\n+    process(defFinder);\n+  }\n+\n+  @Override\n+  public void process(SimpleDefinitionFinder definitions) {\n+    for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n+      rewriteDefinitionIfEligible(defSite, definitions);\n     }\n   }\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/OptimizeCalls.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * A root pass that container for other passes that should run on\n+ * with a single call graph (currently a SimpleDefinitionFinder).\n+ * Expected passes include:\n+ *   - optimize parameters\n+ *   - optimize returns\n+ *   - devirtualize prototype methods\n+ * \n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+class OptimizeCallGraph implements CompilerPass {\n+  List<CallGraphCompilerPass> passes = Lists.newArrayList();\n+  private AbstractCompiler compiler;\n+  \n+  OptimizeCallGraph(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+  \n+  OptimizeCallGraph addPass(CallGraphCompilerPass pass) {\n+    passes.add(pass);\n+    return this;\n+  }\n+  \n+  interface CallGraphCompilerPass {\n+    void process(SimpleDefinitionFinder definitions);\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    if (passes.size() > 0) {\n+      SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+      defFinder.process(externs, root);\n+      for (CallGraphCompilerPass pass : passes) {\n+        pass.process(defFinder);\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+\n+import java.util.Collection;\n+\n+/**\n+ * A compiler pass for optimize function return results.  Currently this\n+ * pass looks for results that are complete unused and rewrite then to be:\n+ *   \"return x()\" -->\"x(); return\"\n+ * , but it can easily be\n+ * expanded to look for use context to avoid unneed type coersion:\n+ *   - \"return x.toString()\" --> \"return x\"\n+ *   - \"return !!x\" --> \"return x\"\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class OptimizeReturns\n+    implements OptimizeCallGraph.CallGraphCompilerPass, CompilerPass {\n+\n+  private AbstractCompiler compiler;\n+\n+  OptimizeReturns(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  @VisibleForTesting\n+  public void process(Node externs, Node root) {\n+    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+    defFinder.process(externs, root);\n+    process(defFinder);\n+  }\n+\n+  @Override\n+  public void process(SimpleDefinitionFinder definitions) {\n+    for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n+      optimizeResultsIfEligible(defSite, definitions);\n+    }\n+  }\n+\n+  /**\n+   * Rewrites method results sites if the method results are never used.\n+   *\n+   * Definition and use site information is provided by the\n+   * {@link SimpleDefinitionFinder} passed in as an argument.\n+   *\n+   * @param defSite definition site to process.\n+   * @param defFinder structure that hold Node -> Definition and\n+   * Definition -> [UseSite] maps.\n+   */\n+  private void optimizeResultsIfEligible(\n+      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {\n+\n+    if (defSite.inExterns || callResultsMaybeUsed(defFinder, defSite)) {\n+      return;\n+    }\n+\n+    rewriteReturns(defSite.definition.getRValue());\n+  }\n+\n+  /**\n+   * Determines if a function result might be used.  A result might be use if:\n+   * - Function must is exported.\n+   * - The definition is never accessed outside a function call context.\n+   */\n+  private boolean callResultsMaybeUsed(\n+      SimpleDefinitionFinder defFinder, DefinitionSite definitionSite) {\n+\n+    Definition definition = definitionSite.definition;\n+\n+    // Assume non-function definitions results are used.\n+    Node rValue = definition.getRValue();\n+    if (rValue == null || !NodeUtil.isFunction(rValue)) {\n+      return true;\n+    }\n+\n+    // Be conservative, don't try to optimize any declaration that isn't as\n+    // simple function declaration or assignment.\n+    if (!isSimpleFunctionDeclaration(rValue)) {\n+      return true;\n+    }\n+\n+    // Assume an exported method result is used.\n+    if (maybeExported(compiler, definition)) {\n+      return true;\n+    }\n+\n+    Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+    for (UseSite site : useSites) {\n+      // Assume indirect definitions references use the result\n+      Node useNodeParent = site.node.getParent();\n+      if (isCall(site)) {\n+        Node callNode = useNodeParent;\n+        Preconditions.checkState(callNode.getType() == Token.CALL);\n+        if (isValueUsed(callNode)) {\n+          return true;\n+        }\n+      } else {\n+        // Allow a standalone name reference.\n+        //     var a;\n+        if (!NodeUtil.isVar(useNodeParent)) {\n+          return true;\n+        }\n+      }\n+\n+      // TODO(johnlenz): Add specialization support.\n+    }\n+\n+    // No possible use of the definition result\n+    return false;\n+  }\n+\n+  static boolean maybeExported(\n+      AbstractCompiler compiler, Definition definition) {\n+    // Assume an exported method result is used.\n+    Node lValue = definition.getLValue();\n+    if (lValue == null) {\n+      return true;\n+    }\n+\n+    String partialName;\n+    if (NodeUtil.isGetProp(lValue)) {\n+      partialName = lValue.getLastChild().getString();\n+    } else if (NodeUtil.isName(lValue)) {\n+      partialName = lValue.getString();\n+    } else {\n+      // GETELEM is assumed to be an export or other expression are unknown\n+      // uses.\n+      return true;\n+    }\n+\n+    CodingConvention codingConvention = compiler.getCodingConvention();\n+    if (codingConvention.isExported(partialName)) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  static boolean isSimpleFunctionDeclaration(Node fn) {\n+    Node parent = fn.getParent();\n+    Node gramps = parent.getParent();\n+\n+    // Simple definition finder doesn't provide useful results in some\n+    // cases, specifically:\n+    //  - functions with recursive definitions\n+    //  - functions defined in object literals\n+    //  - functions defined in array litersals\n+    // Here we defined a set of known function declaration that are 'ok'.\n+\n+    // example: function a(){};\n+    if (NodeUtil.isFunctionDeclaration(fn)) {\n+      return true;\n+    }\n+\n+    // example: a = function(){};\n+    // example: var a = function(){};\n+    if (fn.getFirstChild().getString().isEmpty()\n+        && (NodeUtil.isExprAssign(gramps) || NodeUtil.isName(parent))) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Determines if the name node acts as the function name in a call expression.\n+   */\n+  private static boolean isValueUsed(Node node) {\n+    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n+    Node parent = node.getParent();\n+    switch (parent.getType()) {\n+      case Token.EXPR_RESULT:\n+        return false;\n+      case Token.HOOK:\n+      case Token.AND:\n+      case Token.OR:\n+        return (node == parent.getFirstChild()) ? true : isValueUsed(parent);\n+      case Token.COMMA:\n+        return (node == parent.getFirstChild()) ? false : isValueUsed(parent);\n+      case Token.FOR:\n+        if (NodeUtil.isForIn(parent)) {\n+          return true;\n+        } else {\n+          // Only an expression whose result is in the condition part of the\n+          // expression is used.\n+          return (parent.getChildAtIndex(1) == node);\n+        }\n+      default:\n+        return true;\n+    }\n+  }\n+\n+  /**\n+   * For the supplied function node, rewrite all the return expressions so that:\n+   *    return foo();\n+   * becomes:\n+   *    foo(); return;\n+   * Useless return will be removed later by the peephole optimization passes.\n+   */\n+  private void rewriteReturns(Node fnNode) {\n+    Preconditions.checkState(NodeUtil.isFunction(fnNode));\n+    NodeUtil.visitPostOrder(\n+      fnNode.getLastChild(),\n+      new NodeUtil.Visitor() {\n+        @Override\n+        public void visit(Node node) {\n+          if (node.getType() == Token.RETURN && node.hasOneChild()) {\n+            Node result = node.removeFirstChild();\n+            if (NodeUtil.mayHaveSideEffects(result, compiler)) {\n+              node.getParent().addChildBefore(\n+                new Node(\n+                  Token.EXPR_RESULT, result).copyInformationFrom(result), node);\n+            }\n+            compiler.reportCodeChange();\n+          }\n+        }\n+      },\n+      new NodeUtil.MatchShallowStatement());\n+  }\n+\n+  /**\n+   * Determines if the name node acts as the function name in a call expression.\n+   */\n+  private static boolean isCall(UseSite site) {\n+    Node node = site.node;\n+    Node parent = node.getParent();\n+    return (parent.getFirstChild() == node) && NodeUtil.isCall(parent);\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n \n   public SimpleDefinitionFinder(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-    this.definitionSiteMap = Maps.newHashMap();\n+    this.definitionSiteMap = Maps.newLinkedHashMap();\n     this.nameDefinitionMultimap = HashMultimap.create();\n     this.nameUseSiteMultimap = HashMultimap.create();\n   }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/OptimizeReturnsTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+\n+/**\n+ * Tests OptimizeReturns\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class OptimizeReturnsTest extends CompilerTestCase {\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new OptimizeReturns(compiler);\n+  }\n+\n+  private static final String EXTERNAL_SYMBOLS =\n+    \"var extern;extern.externalMethod\";\n+\n+  public OptimizeReturnsTest() {\n+    super(EXTERNAL_SYMBOLS);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // run pass once.\n+    return 1;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    super.enableLineNumberCheck(true);\n+    disableTypeCheck();\n+  }\n+\n+  /**\n+   * Combine source strings using '\\n' as the separator.\n+   */\n+  private static String newlineJoin(String ... parts) {\n+    return Joiner.on(\"\\n\").join(parts);\n+  }\n+\n+  public void testNoRewriteUsedResult1() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){return 1}\",\n+        \"var x = a()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteUsedResult2() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = function(){return 1}\",\n+        \"a(); var b = a()\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteUnusedResult1() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){return 1}\",\n+        \"a()\");\n+    String expected = newlineJoin(\n+        \"function a(){return}\",\n+        \"a()\");\n+    test(source, expected);\n+  }\n+\n+  public void testRewriteUnusedResult2() throws Exception {\n+    String source = newlineJoin(\n+        \"var a; a = function(){return 1}\",\n+        \"a()\");\n+    String expected = newlineJoin(\n+        \"var a; a = function(){return}\",\n+        \"a()\");\n+    test(source, expected);\n+  }\n+\n+  public void testRewriteUnusedResult3() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = function(){return 1}\",\n+        \"a()\");\n+    String expected = newlineJoin(\n+        \"var a = function(){return}\",\n+        \"a()\");\n+    test(source, expected);\n+  }\n+\n+  public void testRewriteUnusedResult4a() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = function(){return a()}\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteUnusedResult4b() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = function b(){return b()}\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteUnusedResult4c() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){return a()}\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteUnusedResult5() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype.foo = function(args) {return args};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    String expected = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype.foo = function(args) {return};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    test(source, expected);\n+  }\n+\n+  public void testRewriteUnusedResult6() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){return (g = 1)}\",\n+        \"a()\");\n+    String expected = newlineJoin(\n+        \"function a(){g = 1;return}\",\n+        \"a()\");\n+    test(source, expected);\n+  }\n+\n+  public void testRewriteUnusedResult7a() throws Exception {\n+    String source = newlineJoin(\n+        \"function a() { return 1 }\",\n+        \"function b() { return a() }\",\n+        \"function c() { return b() }\",\n+        \"c();\");\n+\n+    // TODO(johnlenz): It would be better if we do some kind of fixed point.\n+    String expected = newlineJoin(\n+        \"function a() { return 1 }\",\n+        \"function b() { return a() }\",\n+        \"function c() { b(); return }\",\n+        \"c();\");\n+    test(source, expected);\n+  }\n+  \n+  public void testRewriteUnusedResult7b() throws Exception {\n+    String source = newlineJoin(\n+        \"c();\",\n+        \"function c() { return b() }\",\n+        \"function b() { return a() }\",\n+        \"function a() { return 1 }\");\n+\n+\n+    // TODO(johnlenz): It would be better if we do some kind of fixed point.\n+    String expected = newlineJoin(\n+        \"c();\",\n+        \"function c() { b(); return }\",\n+        \"function b() { a(); return }\",\n+        \"function a() { return }\");\n+    test(source, expected);\n+  }  \n+\n+  public void testRewriteUnusedResult8() throws Exception {\n+    String source = newlineJoin(\n+        \"function a() { return c() }\",\n+        \"function b() { return a() }\",\n+        \"function c() { return b() }\",\n+        \"c();\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteObjLit1() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = {b:function(){return 1;}}\",\n+        \"for(c in a) (a[c])();\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteObjLit2() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = {b:function fn(){return 1;}}\",\n+        \"for(c in a) (a[c])();\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteArrLit() throws Exception {\n+    String source = newlineJoin(\n+        \"var a = [function(){return 1;}]\",\n+        \"(a[0])();\",\n+        \"a()\");\n+    testSame(source);\n+  }\n+\n+}", "timestamp": 1289349514, "metainfo": ""}