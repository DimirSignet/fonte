{"sha": "9adfc8062e31dc6b9cd5614d4ba6f8ecd27d5c92", "log": "Don't redeclare vars that have been declared without initial values. Fixes issue 397.  R=acleung DELTA=46  (30 added, 0 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1225   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n    */\n   private class GatherCollapses extends AbstractPostOrderCallback {\n \n-    // TODO(user): This is purely a subtree peep hole optimization. We\n-    // can rewrite this so it no longer have a sperate gather and merge stage.\n+    // If a VAR is declared like\n+    // var x;\n+    // then we should not create new VAR nodes for it later in the tree.\n+    // This is a workaround for a bug in Firefox.\n+    private final Set<Var> blacklistedVars = Sets.newHashSet();\n \n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.VAR) {\n+        blacklistStubVars(t, n);\n+      }\n+\n       // Only care about var nodes\n       if (n.getType() != Token.VAR && !canBeRedeclared(n, t.getScope())) return;\n \n           (n.getType() == Token.VAR || canBeRedeclared(n, t.getScope()))) {\n \n         if (NodeUtil.isVar(n)) {\n+          blacklistStubVars(t, n);\n           hasVar = true;\n         }\n \n         collapses.add(new Collapse(varNode, n, parent));\n       }\n     }\n-  }\n-\n-  private boolean canBeRedeclared(Node n, Scope s) {\n-    if (!NodeUtil.isExprAssign(n)) {\n-      return false;\n-    }\n-    Node assign = n.getFirstChild();\n-    Node lhs = assign.getFirstChild();\n-\n-    if (!NodeUtil.isName(lhs)) {\n-      return false;\n-    }\n-\n-    return s.isDeclared(lhs.getString(), false);\n+\n+    private void blacklistStubVars(NodeTraversal t, Node varNode) {\n+      for (Node child = varNode.getFirstChild();\n+           child != null; child = child.getNext()) {\n+        if (child.getFirstChild() == null) {\n+          blacklistedVars.add(t.getScope().getVar(child.getString()));\n+        }\n+      }\n+    }\n+\n+    private boolean canBeRedeclared(Node n, Scope s) {\n+      if (!NodeUtil.isExprAssign(n)) {\n+        return false;\n+      }\n+      Node assign = n.getFirstChild();\n+      Node lhs = assign.getFirstChild();\n+\n+      if (!NodeUtil.isName(lhs)) {\n+        return false;\n+      }\n+\n+      Var var = s.getVar(lhs.getString());\n+      return var != null &&\n+          var.getScope() == s && !blacklistedVars.contains(var);\n+    }\n   }\n \n   private void applyCollapses() {\n--- a/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n     testSame(\"var x; for(x = 1; x = 2; z = 3) {x = 4}\");\n   }\n \n+  public void testIssue397() {\n+    test(\"var x; var y = 3; x = 5;\",\n+         \"var x, y = 3; x = 5;\");\n+    testSame(\"var x; x = 5; var z = 7;\");\n+    test(\"var x; var y = 3; x = 5; var z = 7;\",\n+         \"var x, y = 3; x = 5; var z = 7;\");\n+    test(\"var a = 1; var x; var y = 3; x = 5;\",\n+         \"var a = 1, x, y = 3; x = 5;\");\n+  }\n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new CollapseVariableDeclarations(compiler);", "timestamp": 1301622712, "metainfo": ""}