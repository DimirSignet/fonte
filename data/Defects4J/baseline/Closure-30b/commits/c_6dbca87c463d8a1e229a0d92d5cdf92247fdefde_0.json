{"sha": "6dbca87c463d8a1e229a0d92d5cdf92247fdefde", "log": "When we can't find a forward-declared type, that type should resolve to an empty type. This ensures that if someone tries to pass a param or return value to it, they get a type warning.  R=johnlenz DELTA=461  (385 added, 37 deleted, 39 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=301   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       ObjectType objectType = ObjectType.cast(type);\n       if (objectType == null) {\n         reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString());\n-      } else if (objectType.isUnknownType() &&\n-          // If this has a supertype that hasn't been resolved yet,\n-          // then we can assume this type will be ok once the super\n-          // type resolves.\n-          (objectType.getImplicitPrototype() == null ||\n-           objectType.getImplicitPrototype().isResolved())) {\n+      } else if (\n+          objectType.isEmptyType() ||\n+          (objectType.isUnknownType() &&\n+           // If this has a supertype that hasn't been resolved yet,\n+           // then we can assume this type will be ok once the super\n+           // type resolves.\n+           (objectType.getImplicitPrototype() == null ||\n+            objectType.getImplicitPrototype().isResolved()))) {\n         reportWarning(RESOLVED_TAG_EMPTY, \"@extends\", fnName);\n       } else {\n         return true;\n       ObjectType objectType = ObjectType.cast(type);\n       if (objectType == null) {\n         reportError(BAD_IMPLEMENTED_TYPE, fnName);\n-      } else if (objectType.isUnknownType() &&\n-          // If this has a supertype that hasn't been resolved yet,\n-          // then we can assume this type will be ok once the super\n-          // type resolves.\n-          (objectType.getImplicitPrototype() == null ||\n-           objectType.getImplicitPrototype().isResolved())) {\n+      } else if (\n+          objectType.isEmptyType() ||\n+          (objectType.isUnknownType() &&\n+           // If this has a supertype that hasn't been resolved yet,\n+           // then we can assume this type will be ok once the super\n+           // type resolves.\n+           (objectType.getImplicitPrototype() == null ||\n+            objectType.getImplicitPrototype().isResolved()))) {\n         reportWarning(RESOLVED_TAG_EMPTY, \"@implements\", fnName);\n       } else {\n         return true;\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   private void checkDeclaredPropertyInheritance(\n       NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n       JSDocInfo info, JSType propertyType) {\n-    // TODO(user): We're not 100% confident that type-checking works,\n-    // so we return quietly if the unknown type is a superclass of this type.\n-    // Remove this check as we become more confident. We should flag a warning\n-    // when the unknown type is on the inheritance chain, as it is likely\n-    // because of a programmer error.\n-    if (ctorType.hasUnknownSupertype()) {\n+    // If the supertype doesn't resolve correctly, we've warned about this\n+    // already.\n+    if (hasUnknownOrEmptySupertype(ctorType)) {\n       return;\n     }\n \n     boolean foundInterfaceProperty = false;\n     if (ctorType.isConstructor()) {\n       for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n-        if (implementedInterface.isUnknownType()) {\n+        if (implementedInterface.isUnknownType() ||\n+            implementedInterface.isEmptyType()) {\n           continue;\n         }\n         FunctionType interfaceType =\n             implementedInterface.toObjectType().getConstructor();\n+        Preconditions.checkNotNull(interfaceType);\n         boolean interfaceHasProperty =\n             interfaceType.getPrototype().hasProperty(propertyName);\n         foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n       compiler.report(\n           t.makeError(n, UNKNOWN_OVERRIDE,\n               propertyName, ctorType.getInstanceType().toString()));\n+    }\n+  }\n+\n+  /**\n+   * Given a constructor or an interface type, find out whether the unknown\n+   * type is a supertype of the current type.\n+   */\n+  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n+    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n+    Preconditions.checkArgument(!ctor.isUnknownType());\n+\n+    // The type system should notice inheritance cycles on its own\n+    // and break the cycle.\n+    while (true) {\n+      ObjectType maybeSuperInstanceType =\n+          ctor.getPrototype().getImplicitPrototype();\n+      if (maybeSuperInstanceType == null) {\n+        return false;\n+      }\n+      if (maybeSuperInstanceType.isUnknownType() ||\n+          maybeSuperInstanceType.isEmptyType()) {\n+        return true;\n+      }\n+      ctor = maybeSuperInstanceType.getConstructor();\n+      if (ctor == null) {\n+        return false;\n+      }\n+      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.UnionType;\n \n import java.text.MessageFormat;\n import java.util.Iterator;\n    */\n   void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {\n     JSType anyObjectType = getNativeType(NO_OBJECT_TYPE);\n-    if (!anyObjectType.isSubtype(type)) {\n+    if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {\n       mismatch(t, n, msg, type, anyObjectType);\n     }\n   }\n   boolean expectNotNullOrUndefined(\n       NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n     if (!type.isNoType() && !type.isUnknownType() &&\n-        type.isSubtype(nullOrUndefined)) {\n+        type.isSubtype(nullOrUndefined) &&\n+        !containsForwardDeclaredUnresolvedName(type)) {\n \n       // There's one edge case right now that we don't handle well, and\n       // that we don't want to warn about.\n       return false;\n     }\n     return true;\n+  }\n+\n+  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n+    if (type instanceof UnionType) {\n+      for (JSType alt : ((UnionType) type).getAlternates()) {\n+        if (containsForwardDeclaredUnresolvedName(alt)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return type.isNoResolvedType();\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   /**\n-   * Given a constructor or an interface type, find out whether the unknown\n-   * type is a supertype of the current type.\n-   */\n-  public boolean hasUnknownSupertype() {\n-    Preconditions.checkArgument(isConstructor() || isInterface());\n-    Preconditions.checkArgument(!this.isUnknownType());\n-    // Potential infinite loop if our type system messes up or someone defines\n-    // a bad type. Otherwise the loop should always end.\n-    FunctionType ctor = this;\n-    while (true) {\n-      ObjectType maybeSuperInstanceType =\n-          ctor.getPrototype().getImplicitPrototype();\n-      if (maybeSuperInstanceType == null) {\n-        return false;\n-      }\n-      if (maybeSuperInstanceType.isUnknownType()) {\n-        return true;\n-      }\n-      ctor = maybeSuperInstanceType.getConstructor();\n-      if (ctor == null) {\n-        return false;\n-      }\n-      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n-    }\n-  }\n-\n-  /**\n    * Given a constructor or an interface type and a property, finds the\n    * top-most superclass that has the property defined (including this\n    * constructor).\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     return false;\n   }\n \n+  public boolean isNoResolvedType() {\n+    return false;\n+  }\n+\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType();\n+    return isNoType() || isNoObjectType() || isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n   }\n \n   TernaryValue testForEqualityHelper(JSType aType, JSType bType) {\n-    if (bType.isAllType() || bType.isEmptyType() || bType.isUnknownType() ||\n-        aType.isAllType() || aType.isEmptyType() || aType.isUnknownType()) {\n+    if (bType.isAllType() || bType.isUnknownType() ||\n+        bType.isNoResolvedType() ||\n+        aType.isAllType() || aType.isUnknownType() ||\n+        aType.isNoResolvedType()) {\n       return UNKNOWN;\n     }\n+\n+    boolean aIsEmpty = aType.isEmptyType();\n+    boolean bIsEmpty = bType.isEmptyType();\n+    if (aIsEmpty || bIsEmpty) {\n+      if (aIsEmpty && bIsEmpty) {\n+        return TernaryValue.TRUE;\n+      } else {\n+        return UNKNOWN;\n+      }\n+    }\n+\n     if (aType.isFunctionType() || bType.isFunctionType()) {\n       JSType otherType = aType.isFunctionType() ? bType : aType;\n       // In theory, functions are comparable to anything except\n    * getLeastSupertype implementations.\n    */\n   static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n-    if (thatType.isEmptyType() || thatType.isAllType()) {\n-      // Defer to the implementations of the end lattice elements when\n-      // possible.\n+    if (thatType.isAllType() ||\n+        (thatType.isEmptyType() && !thatType.isNamedType())) {\n       return thatType.getLeastSupertype(thisType);\n     }\n-\n     return thisType.registry.createUnionType(thisType, thatType);\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSTypeNative.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeNative.java\n   ALL_TYPE,\n   NO_TYPE,\n   NO_OBJECT_TYPE,\n+  NO_RESOLVED_TYPE,\n   GLOBAL_THIS,\n   U2U_CONSTRUCTOR_TYPE,\n   U2U_FUNCTION_TYPE,\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n     registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n \n+    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n+    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n+\n     // Array\n     FunctionType ARRAY_FUNCTION_TYPE =\n       new FunctionType(this, \"Array\", null,\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n         t.warning(\"Unknown type \" + reference, sourceName, lineno, null,\n             charno);\n       } else {\n-        setReferencedType(\n-            registry.getNativeObjectType(\n-                JSTypeNative.CHECKED_UNKNOWN_TYPE));\n+        if (isForwardDeclared) {\n+          setReferencedType(\n+              registry.getNativeObjectType(\n+                  JSTypeNative.NO_RESOLVED_TYPE));\n+        } else {\n+          setReferencedType(\n+              registry.getNativeObjectType(\n+                  JSTypeNative.CHECKED_UNKNOWN_TYPE));\n+        }\n \n         if (registry.isLastGeneration() && validator != null) {\n           validator.apply(getReferencedType());\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public TernaryValue testForEquality(JSType that) {\n-    return that.isEmptyType() ? TernaryValue.TRUE : TernaryValue.UNKNOWN;\n-  }\n-\n-  @Override\n   public boolean isSubtype(JSType that) {\n     if (JSType.isSubtype(this, that)) {\n       return true;\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/NoResolvedType.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+\n+/**\n+ * An unresolved type that was forward declared. So we know it exists,\n+ * but that it wasn't pulled into this binary.\n+ *\n+ * In most cases, it behaves like a bottom type in the type lattice:\n+ * no real type should be assigned to a NoResolvedType, but the\n+ * NoResolvedType is a subtype of everything. In a few cases, it behaves\n+ * like the unknown type: properties of this type are also NoResolved types,\n+ * and comparisons to other types always have an unknown result.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+class NoResolvedType extends NoType {\n+  private static final long serialVersionUID = 1L;\n+\n+  NoResolvedType(JSTypeRegistry registry) {\n+    super(registry);\n+  }\n+\n+  @Override\n+  public boolean isNoResolvedType() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isNoType() {\n+    return false;\n+  }\n+\n+  @Override\n+  public JSType getLeastSupertype(JSType that) {\n+    return that.isNoType() ? this : super.getLeastSupertype(that);\n+  }\n+\n+  @Override\n+  public JSType getGreatestSubtype(JSType that) {\n+    return that.isNoType() ? that :\n+        that.isNoObjectType() ? getNativeType(JSTypeNative.NO_TYPE) :\n+        super.getGreatestSubtype(that);\n+  }\n+\n+  @Override\n+  public JSType getPropertyType(String propertyName) {\n+    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"NoResolvedType\";\n+  }\n+}\n--- a/src/com/google/javascript/rhino/jstype/NoType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoType.java\n  *\n  * @see <a href=\"http://en.wikipedia.org/wiki/Bottom_type\">Bottom types</a>\n  */\n-public final class NoType extends NoObjectType {\n+public class NoType extends NoObjectType {\n   private static final long serialVersionUID = 1L;\n \n   NoType(JSTypeRegistry registry) {\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n+  public boolean isNoType() {\n+    return referencedType.isNoType();\n+  }\n+\n+  @Override\n+  public boolean isNoObjectType() {\n+    return referencedType.isNoObjectType();\n+  }\n+\n+  @Override\n+  public boolean isNoResolvedType() {\n+    return referencedType.isNoResolvedType();\n+  }\n+\n+  @Override\n   public boolean isUnknownType() {\n     return referencedType.isUnknownType();\n   }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n     }\n     return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\";\n   }\n+\n+  @Override\n+  public boolean setValidator(Predicate<JSType> validator) {\n+    for (JSType a : alternates) {\n+      a.setValidator(validator);\n+    }\n+    return true;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n         while (it.hasNext()) {\n           JSType current = it.next();\n           if (alternate.isUnknownType() ||\n-              current.isUnknownType()) {\n+              current.isUnknownType() ||\n+              alternate.isNoResolvedType() ||\n+              current.isNoResolvedType()) {\n             if (alternate.isEquivalentTo(current)) {\n               // Alternate is unnecessary.\n               return this;\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n   protected JSType ALL_TYPE;\n   protected ObjectType NO_OBJECT_TYPE;\n   protected ObjectType NO_TYPE;\n+  protected ObjectType NO_RESOLVED_TYPE;\n   protected JSType ARRAY_FUNCTION_TYPE;\n   protected ObjectType ARRAY_TYPE;\n   protected JSType BOOLEAN_OBJECT_FUNCTION_TYPE;\n         registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n     NO_TYPE =\n         registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n+    NO_RESOLVED_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);\n     ARRAY_FUNCTION_TYPE =\n         registry.getNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE);\n     ARRAY_TYPE =\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   }\n \n   public void testForwardTypeDeclaration2() throws Exception {\n-    testClosureTypes(\n-        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n-        \"/** @param {MyType} x */ function f(x) { }\" +\n-        \"f(3);\", null);\n+    String f = \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */ function f(x) { }\";\n+    testClosureTypes(f, null);\n+    testClosureTypes(f + \"f(3);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (MyType|null|undefined)\");\n   }\n \n   public void testForwardTypeDeclaration3() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testForwardTypeDeclaration2() throws Exception {\n-    testClosureTypes(\n-        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n-        \"/** @param {MyType} x */ function f(x) { }\" +\n-        \"f(3);\", null);\n+    String f = \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */ function f(x) { }\";\n+    testClosureTypes(f, null);\n+    testClosureTypes(f + \"f(3);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (MyType|null)\");\n   }\n \n   public void testForwardTypeDeclaration3() throws Exception {\n         Lists.newArrayList(\n             \"Could not resolve type in @implements tag of YourType\",\n             \"property method not defined on any superclass of YourType\"));\n+  }\n+\n+  public void testForwardTypeDeclaration7() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType=} x */\" +\n+        \"function f(x) { return x == undefined; }\", null);\n+  }\n+\n+  public void testForwardTypeDeclaration8() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */\" +\n+        \"function f(x) { return x.name == undefined; }\", null);\n+  }\n+\n+  public void testForwardTypeDeclaration9() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */\" +\n+        \"function f(x) { x.name = 'Bob'; }\", null);\n+  }\n+\n+  public void testForwardTypeDeclaration10() throws Exception {\n+    String f = \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType|number} x */ function f(x) { }\";\n+    testClosureTypes(f, null);\n+    testClosureTypes(f + \"f(3);\", null);\n+    testClosureTypes(f + \"f('3');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: (MyType|null|number)\");\n   }\n \n   public void testMalformedOldTypeDef() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.SimpleErrorReporter;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.ArrowType;\n import com.google.javascript.rhino.jstype.JSType.TypePair;\n   private JSType recordType;\n   private EnumType enumType;\n   private EnumElementType elementsType;\n+  private NamedType forwardDeclaredNamedType;\n \n   private static final StaticScope<JSType> EMPTY_SCOPE = new EmptyScope();\n \n           public JSType getTypeOfThis() { return null; }\n         });\n     assertNotNull(namedGoogBar.getImplicitPrototype());\n+    forwardDeclaredNamedType =\n+        new NamedType(registry, \"forwardDeclared\", \"source\", 1, 0);\n+    registry.forwardDeclareType(\"typeA\");\n+    forwardDeclaredNamedType.resolve(\n+        new SimpleErrorReporter(), EMPTY_SCOPE);\n \n     types = ImmutableList.of(\n         NO_OBJECT_TYPE,\n+        NO_RESOLVED_TYPE,\n         NO_TYPE,\n         BOOLEAN_OBJECT_TYPE,\n         BOOLEAN_TYPE,\n         enumType,\n         elementsType,\n         googBar,\n-        googSubBar);\n+        googSubBar,\n+        forwardDeclaredNamedType);\n   }\n \n   /**\n         NO_TYPE.getPropertyType(\"anyProperty\"));\n \n     Asserts.assertResolvesToSame(NO_TYPE);\n+  }\n+\n+  /**\n+   * Tests the behavior of the unresolved Bottom type.\n+   */\n+  public void testNoResolvedType() throws Exception {\n+    // isXxx\n+    assertFalse(NO_RESOLVED_TYPE.isNoObjectType());\n+    assertFalse(NO_RESOLVED_TYPE.isNoType());\n+    assertTrue(NO_RESOLVED_TYPE.isNoResolvedType());\n+    assertFalse(NO_RESOLVED_TYPE.isArrayType());\n+    assertFalse(NO_RESOLVED_TYPE.isBooleanValueType());\n+    assertFalse(NO_RESOLVED_TYPE.isDateType());\n+    assertFalse(NO_RESOLVED_TYPE.isEnumElementType());\n+    assertFalse(NO_RESOLVED_TYPE.isNullType());\n+    assertFalse(NO_RESOLVED_TYPE.isNamedType());\n+    assertTrue(NO_RESOLVED_TYPE.isNumber());\n+    assertFalse(NO_RESOLVED_TYPE.isNumberObjectType());\n+    assertFalse(NO_RESOLVED_TYPE.isNumberValueType());\n+    assertTrue(NO_RESOLVED_TYPE.isObject());\n+    assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType());\n+    assertFalse(NO_RESOLVED_TYPE.isRegexpType());\n+    assertTrue(NO_RESOLVED_TYPE.isString());\n+    assertFalse(NO_RESOLVED_TYPE.isStringObjectType());\n+    assertFalse(NO_RESOLVED_TYPE.isStringValueType());\n+    assertFalse(NO_RESOLVED_TYPE.isEnumType());\n+    assertFalse(NO_RESOLVED_TYPE.isUnionType());\n+    assertFalse(NO_RESOLVED_TYPE.isAllType());\n+    assertFalse(NO_RESOLVED_TYPE.isVoidType());\n+    assertTrue(NO_RESOLVED_TYPE.isConstructor());\n+    assertFalse(NO_RESOLVED_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(NO_RESOLVED_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(functionType));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(ALL_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canTestForEqualityWith\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_OBJECT_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ARRAY_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_OBJECT_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, DATE_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, EVAL_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, functionType);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NULL_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_OBJECT_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, OBJECT_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, URI_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, RANGE_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REFERENCE_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REGEXP_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_OBJECT_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, SYNTAX_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, TYPE_ERROR_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ALL_TYPE);\n+    assertCanTestForEqualityWith(NO_RESOLVED_TYPE, VOID_TYPE);\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertTrue(NO_RESOLVED_TYPE.isNullable());\n+\n+    // isObject\n+    assertTrue(NO_RESOLVED_TYPE.isObject());\n+\n+    // matchesXxx\n+    assertTrue(NO_RESOLVED_TYPE.matchesInt32Context());\n+    assertTrue(NO_RESOLVED_TYPE.matchesNumberContext());\n+    assertTrue(NO_RESOLVED_TYPE.matchesObjectContext());\n+    assertTrue(NO_RESOLVED_TYPE.matchesStringContext());\n+    assertTrue(NO_RESOLVED_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"NoResolvedType\", NO_RESOLVED_TYPE.toString());\n+    assertEquals(null, NO_RESOLVED_TYPE.getDisplayName());\n+    assertFalse(NO_RESOLVED_TYPE.hasDisplayName());\n+\n+    // getPropertyType\n+    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n+        NO_RESOLVED_TYPE.getPropertyType(\"anyProperty\"));\n+\n+    Asserts.assertResolvesToSame(NO_RESOLVED_TYPE);\n   }\n \n   /**\n     compare(TRUE, NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n     compare(UNKNOWN, ALL_TYPE, ALL_TYPE);\n     compare(TRUE, NO_TYPE, NO_TYPE);\n+    compare(UNKNOWN, NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n     compare(UNKNOWN, NO_OBJECT_TYPE, NUMBER_TYPE);\n     compare(UNKNOWN, ALL_TYPE, NUMBER_TYPE);\n     compare(UNKNOWN, NO_TYPE, NUMBER_TYPE);\n \n     JSType functionAndNull = createUnionType(NULL_TYPE, dateMethod);\n     compare(UNKNOWN, functionAndNull, dateMethod);\n+\n+    compare(UNKNOWN, NULL_TYPE, NO_TYPE);\n+    compare(UNKNOWN, VOID_TYPE, NO_TYPE);\n+    compare(UNKNOWN, NULL_TYPE, unresolvedNamedType);\n+    compare(UNKNOWN, VOID_TYPE, unresolvedNamedType);\n+    compare(TRUE, NO_TYPE, NO_TYPE);\n   }\n \n   private void compare(TernaryValue r, JSType t1, JSType t2) {\n         ALL_TYPE,\n         NO_TYPE,\n         NO_OBJECT_TYPE,\n+        NO_RESOLVED_TYPE,\n         createUnionType(BOOLEAN_TYPE, STRING_TYPE),\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         createUnionType(NULL_TYPE, dateMethod),\n         namedGoogBar,\n         subclassOfUnresolvedNamedType,\n         subclassCtor,\n-        recordType\n-                              );\n+        recordType,\n+        forwardDeclaredNamedType);\n   }\n \n   public void testSymmetryOfTestForEquality() {\n \n     assertFalse(a.isEquivalentTo(UNKNOWN_TYPE));\n     assertFalse(b.isEquivalentTo(UNKNOWN_TYPE));\n+    assertTrue(a.isEmptyType());\n+    assertFalse(a.isNoType());\n+    assertTrue(a.isNoResolvedType());\n   }\n \n   public void testForwardDeclaredNamedType() {", "timestamp": 1295393314, "metainfo": ""}