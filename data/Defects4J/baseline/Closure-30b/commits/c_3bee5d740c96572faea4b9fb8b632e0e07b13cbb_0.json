{"sha": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb", "log": "Add a mechanism for inlining local vars, and turn it on by default. Warnings for \"ambiguous\" function definitions. Refactoring and renaming of some method names. Use \"=\" optionality annotation in externs.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n     }\n     return type == null || !(type instanceof ObjectType)\n         || invalidatingTypes.contains(type)\n-        || !((ObjectType) type).hasName()\n+        || !((ObjectType) type).hasReferenceName()\n         || (type.isNamedType() && type.isUnknownType())\n         || type.isEnumType() || type.autoboxesTo() != null;\n   }\n--- a/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n     Node child;\n     switch (n.getType()) {\n       case Token.IF:\n-      case Token.WHILE:\n         child = n.getFirstChild().getNext();  // skip the condition child\n         break;\n \n+      case Token.WHILE:\n       case Token.FOR:\n-        child = n.getFirstChild().getNext().getNext();\n-        if (child.getNext() != null) {\n-          // This is a for (A; B; C) loop rather than a for (A in B) loop.\n-          child = child.getNext();\n-        }\n+        child = NodeUtil.getLoopCodeBlock(n);\n         break;\n \n       default:\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n     Node parent = var.getParent();\n \n     // Special case when we are in FOR-IN loop.\n-    if (parent.getType() == Token.FOR && parent.getChildCount() == 3) {\n+    if (NodeUtil.isForIn(parent)) {\n       var.removeChild(name);\n       parent.replaceChild(var, name);\n     } else if (var.getChildCount() == 1) {\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     // skipAllCompilerPasses() cannot be easily undone.\n     options.closurePass = true;\n     options.variableRenaming = VariableRenamingPolicy.LOCAL;\n+    options.inlineLocalVariables = true;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeConstantExpressions = true;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Inlines variables */\n   public boolean inlineVariables;\n+\n+  /** Inlines variables */\n+  public boolean inlineLocalVariables;\n \n   // TODO(user): This is temporary. Once flow sensitive inlining is stable\n   // Remove this.\n     deadAssignmentElimination = false;\n     inlineConstantVars = false;\n     inlineFunctions = false;\n+    inlineLocalFunctions = false;\n     crossModuleCodeMotion = false;\n     crossModuleMethodMotion = false;\n     inlineGetters = false;\n     inlineVariables = false;\n+    inlineLocalVariables = false;\n     smartNameRemoval = false;\n     removeDeadCode = false;\n     extractPrototypeMemberDeclarations = false;\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n         }\n         break;\n       case Token.FOR:\n-        if (parent.getChildCount() == 4) {\n+        if (NodeUtil.isForIn(parent)) {\n+          return parent;\n+        } else {\n           return parent.getFirstChild().getNext().getNext();\n-        } else {\n-          return parent;\n         }\n       case Token.WHILE:\n       case Token.DO:\n       case Token.DO:\n         return computeFallThrough(n.getFirstChild());\n       case Token.FOR:\n-        if (n.getChildCount() == 4) {\n-          return computeFallThrough(n.getFirstChild());\n-        }\n-        return n;\n+        if (NodeUtil.isForIn(n)) {\n+          return n;\n+        }\n+        return computeFallThrough(n.getFirstChild());\n       case Token.LABEL:\n         return computeFallThrough(n.getLastChild());\n       default:\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n         // That way the following:\n         // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n         // var x = 0; while(x<10) {  x++; }\n-        if (parent.getChildCount() == 4) {\n+        if (NodeUtil.isForIn(parent)) {\n+          return n == parent.getLastChild(); \n+        } else {\n           return NodeUtil.getConditionExpression(parent) != n;\n-        } else {\n-          return n == parent.getLastChild();\n         }\n       case Token.SWITCH:\n       case Token.CASE:\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n           tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);\n           continue;\n         case Token.FOR:\n-          if (n.getChildCount() == 4) {\n+          if (!NodeUtil.isForIn(n)) {\n             tryRemoveAssignment(\n                 t, NodeUtil.getConditionExpression(n), state);\n           }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   private List<PassFactory> getCodeRemovingPasses(\n       boolean beforeSmartNameRemoval) {\n     List<PassFactory> passes = Lists.newArrayList();\n-    if (options.inlineVariables && !beforeSmartNameRemoval) {\n+    if ((options.inlineVariables || options.inlineLocalVariables)\n+        && !beforeSmartNameRemoval) {\n       passes.add(inlineVariables);\n     } else if (options.inlineConstantVars) {\n       passes.add(inlineConstants);\n         // schemes need to die.\n         return new ErrorPass(compiler, CANNOT_USE_PROTOTYPE_AND_VAR);\n       } else {\n-        return new InlineVariables(compiler, false, true);\n+        InlineVariables.Mode mode;\n+        if (options.inlineVariables) {\n+          mode = InlineVariables.Mode.ALL;\n+        } else if (options.inlineLocalVariables) {\n+          mode = InlineVariables.Mode.LOCALS_ONLY;\n+        } else {\n+          throw new IllegalStateException(\"No variable inlining option set.\");\n+        }\n+\n+        return new InlineVariables(compiler, mode, true);\n       }\n     }\n   };\n       new PassFactory(\"inlineConstants\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new InlineVariables(compiler, true, true);\n+      return new InlineVariables(\n+          compiler, InlineVariables.Mode.CONSTANTS_ONLY, true);\n     }\n   };\n \n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       boolean enableBlockInlining = !isInliningForbidden();\n       return new InlineFunctions(\n-          compiler, \n+          compiler,\n           compiler.getUniqueNameIdSupplier(),\n           options.inlineFunctions,\n-          options.inlineLocalFunctions, \n+          options.inlineLocalFunctions,\n           options.inlineAnonymousFunctionExpressions,\n           enableBlockInlining,\n           options.decomposeExpressions);\n       new PassFactory(\"removeUnusedVars\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      boolean preserveAnonymousFunctionNames =\n+        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n       return new RemoveUnusedVars(\n-          compiler, options.removeUnusedVarsInGlobalScope);\n+          compiler,\n+          options.removeUnusedVarsInGlobalScope,\n+          preserveAnonymousFunctionNames);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n     Node nextSibling = n.getNext();\n     if (nextSibling != null\n         && nextSibling.getType() == Token.FOR\n-        && nextSibling.getChildCount() == 4\n+        && !NodeUtil.isForIn(nextSibling)\n         && nextSibling.getFirstChild().getType() == Token.EMPTY) {\n \n       // Does the current node contain an in operator?  If so, embedding\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n     @Override public boolean isInvalidatingType(JSType type) {\n       return (type == null) || invalidatingTypes.contains(type)\n-          || (type instanceof ObjectType && !((ObjectType) type).hasName())\n+          || (type instanceof ObjectType &&\n+              !((ObjectType) type).hasReferenceName())\n           || (type.isNamedType() && type.isUnknownType());\n     }\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n \n   private final AbstractCompiler compiler;\n \n-  // Only inline things explicitly marked as constant.\n-  private final boolean onlyConstants;\n+  enum Mode {\n+    // Only inline things explicitly marked as constant.\n+    CONSTANTS_ONLY,\n+    // Locals only\n+    LOCALS_ONLY,\n+    ALL\n+  };\n+\n+  private final Mode mode;\n \n   // Inlines all strings, even if they increase the size of the gzipped binary.\n   private final boolean inlineAllStrings;\n \n   private final IdentifyConstants identifyConstants = new IdentifyConstants();\n \n-  InlineVariables(AbstractCompiler compiler, boolean onlyConstants,\n+  InlineVariables(\n+      AbstractCompiler compiler,\n+      Mode mode,\n       boolean inlineAllStrings) {\n     this.compiler = compiler;\n-    this.onlyConstants = onlyConstants;\n+    this.mode = mode;\n     this.inlineAllStrings = inlineAllStrings;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n-        compiler, new InliningBehavior(),\n-        onlyConstants ?\n-            identifyConstants :\n-            Predicates.<Var>alwaysTrue());\n+        compiler, new InliningBehavior(), getFilterForMode());\n     callback.process(externs, root);\n+  }\n+\n+  private Predicate<Var> getFilterForMode() {\n+    switch (mode) {\n+      case ALL:\n+        return Predicates.<Var>alwaysTrue();\n+      case LOCALS_ONLY:\n+        return new IdentifyLocals();\n+      case CONSTANTS_ONLY:\n+        return new IdentifyConstants();\n+      default:\n+        throw new IllegalStateException();\n+    }\n   }\n \n   /**\n     }\n   }\n \n+  /**\n+   * Filters non-global variables.\n+   */\n+  private class IdentifyLocals implements Predicate<Var> {\n+    @Override\n+    public boolean apply(Var var) {\n+      return var.scope.isLocal();\n+    }\n+  }\n+\n   private static class AliasCandidate {\n     private final Var alias;\n     private final ReferenceCollection refInfo;\n      */\n     private void collectAliasCandidates(NodeTraversal t,\n         Map<Var, ReferenceCollection> referenceMap) {\n-      if (!onlyConstants) {\n+      if (mode != Mode.CONSTANTS_ONLY) {\n         for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n           Var v = it.next();\n           ReferenceCollection referenceInfo = referenceMap.get(v);\n           Node value = init.getAssignedValue();\n           inlineDeclaredConstant(v, value, referenceInfo.references);\n           staleVars.add(v);\n-        } else if (onlyConstants) {\n+        } else if (mode == Mode.CONSTANTS_ONLY) {\n           // If we're in constants-only mode, don't run more aggressive\n           // inlining heuristics. See InlineConstantsTest.\n           continue;\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n         return;\n \n       case Token.FOR:\n-        if (n.getChildCount() == 4) {\n+        if (!NodeUtil.isForIn(n)) {\n           computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n               conditional);\n         } else {\n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n         return;\n \n       case Token.FOR:\n-        if (n.getChildCount() == 4) {\n+        if (!NodeUtil.isForIn(n)) {\n           computeMayUse(\n               NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n         } else {\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n         return;\n \n       case Token.FOR:\n-        if (n.getChildCount() == 4) {\n+        if (!NodeUtil.isForIn(n)) {\n           computeMustDef(\n               NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n         } else {\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n       // control structure predicates.  These names are always\n       // referenced when the enclosing function is called.\n       if (n.getType() == Token.FOR) {\n-        if (n.getChildCount() == 4) {\n+        if (!NodeUtil.isForIn(n)) {\n           Node decl = n.getFirstChild();\n           Node pred = decl.getNext();\n           Node step = pred.getNext();\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n       if (constructor instanceof FunctionType && constructor.isConstructor()) {\n         // Case where the class has been properly declared with @constructor\n         classType = (FunctionType) constructor;\n-        className = classType.getName();\n+        className = classType.getReferenceName();\n       } else {\n         // We'll guess it is a constructor even if it didn't have @constructor\n         classType = compiler.getTypeRegistry().getNativeFunctionType(\n         if (superClass.getPrototype().hasOwnProperty(prop)) {\n           graph.connect(getNamedContainingFunction(), ref,\n               graph.defineNameIfNotExists(\n-                 superClass.getName() + \".prototype.\" + prop, false));\n+                 superClass.getReferenceName() + \".prototype.\" + prop, false));\n           return;\n         } else {\n           superClass = superClass.getSuperClassConstructor();\n       if (classType.getPrototype().hasOwnProperty(prop)) {\n         graph.connect(getNamedContainingFunction(), ref,\n            graph.defineNameIfNotExists(\n-               classType.getName() + \".prototype.\" + prop, false));\n+               classType.getReferenceName() + \".prototype.\" + prop, false));\n       }\n       if (classType.getSubTypes() != null) {\n         for (FunctionType subclass : classType.getSubTypes()) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       }\n     }\n \n-    return false;    \n+    return false;\n   }\n \n   /*\n     }\n     return false;\n   }\n-  \n+\n   static int getOpFromAssignmentOp(Node n) {\n     switch (n.getType()){\n       case Token.ASSIGN_BITOR:\n       return null;\n     }\n   }\n-  \n+\n   /**\n    * Is this a STRING node?\n    */\n         && n.getFirstChild().getType() == Token.CALL;\n   }\n \n+  /**\n+   * @return Whether the node represents a FOR-IN loop.\n+   */\n+  static boolean isForIn(Node n) {\n+    return n.getType() == Token.FOR\n+        && n.getChildCount() == 3;\n+  }\n \n   /**\n    * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n       // Only Token.FOR can have an Token.EMPTY other control structure\n       // need something for the condition. Others need to be replaced\n       // or the structure removed.\n-      Preconditions.checkState(parent.getType() == Token.FOR\n-          && parent.getChildCount() == 4);\n       parent.replaceChild(node, new Node(Token.EMPTY));\n     } else {\n       throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n           extractForInitializer(c, insertBefore, insertBeforeParent);\n           break;\n         case Token.FOR:\n-          if (c.getChildCount() == 4\n+          if (!NodeUtil.isForIn(c)\n               && c.getFirstChild().getType() != Token.EMPTY) {\n             Node init = c.getFirstChild();\n             c.replaceChild(init, new Node(Token.EMPTY));\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n       return grandparent;\n     }\n \n-    private static boolean isForIn(Node n) {\n-      return n.getType() == Token.FOR && n.getChildCount() == 3;\n-    }\n-\n     private static boolean isLhsOfForInExpression(Node n) {\n       Node parent = n.getParent();\n       if (parent.getType() == Token.VAR) {\n         return isLhsOfForInExpression(parent);\n       }\n-      return isForIn(parent) && parent.getFirstChild() == n;\n+      return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;\n     }\n \n     boolean isSimpleAssignmentToName() {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n   private int numRemoved_ = 0;\n \n   private final boolean removeGlobals;\n-  \n+\n+  private boolean preserveAnonymousFunctionNames;\n+\n   /**\n    * Keeps track of what variables we've warned about, so that we don't do it\n    * on subsequent traversals.\n    */\n   private final Set<Scope.Var> warnedVars_ = Sets.newHashSet();\n \n-  RemoveUnusedVars(AbstractCompiler compiler) {\n-    this(compiler, true);\n-  }\n-\n-  RemoveUnusedVars(AbstractCompiler compiler, boolean removeGlobals) {\n+  RemoveUnusedVars(\n+      AbstractCompiler compiler,\n+      boolean removeGlobals,\n+      boolean preserveAnonymousFunctionNames) {\n     compiler_ = compiler;\n     this.removeGlobals = removeGlobals;\n-  }\n-  \n+    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n+  }\n+\n   /**\n    * Traverses the root, removing all unused variables. Multiple traversals\n    * may occur to ensure all unused variables are removed.\n           // that's taken care of in removeUnreferencedFunctionArgs.\n         } else if (toRemove.getType() == Token.FUNCTION &&\n             NodeUtil.isFunctionAnonymous(toRemove)) {\n+          if (!preserveAnonymousFunctionNames) {\n+            toRemove.getFirstChild().setString(\"\");\n+            compiler_.reportCodeChange();\n+          }\n           // Don't remove bleeding functions.\n         } else if (parent != null &&\n             parent.getType() == Token.FOR &&\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     if (type.isNamedType()) {\n       NamedType namedType = (NamedType) type;\n       if (!namedType.isResolved()) {\n-        return namedType.getName();\n+        return namedType.getReferenceName();\n       }\n     } else if (type.isUnionType()) {\n       for (JSType alt : ((UnionType) type).getAlternates()) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n       switch (branch) {\n         case ON_TRUE:\n-          if (source.getType() == Token.FOR &&\n-              source.getChildCount() == 3) {\n+          if (NodeUtil.isForIn(source)) {\n             // item is assigned a property name, so its type should be string.\n             Node item = source.getFirstChild();\n             if (item.getType() == Token.VAR) {\n                     // function.\n                     jArgument.setJSType(\n                         new FunctionType(\n-                            registry, jArgumentFnType.getName(),\n+                            registry, jArgumentFnType.getReferenceName(),\n                             jArgumentFnType.getSource(),\n                             jArgumentFnType.getParametersNode(),\n                             jArgumentFnType.getReturnType(),\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n   private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n     FunctionType t = typeRegistry.getNativeFunctionType(tId);\n-    declareNativeType(scope, t.getInstanceType().getName(), t);\n-    declareNativeType(scope, t.getPrototype().getName(), t.getPrototype());\n+    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n+    declareNativeType(\n+        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n   }\n \n   private void declareNativeValueType(Scope scope, String name,\n \n                 FunctionType delegateProxy =\n                     typeRegistry.createConstructorType(\n-                        delegateBaseObject.getName(), null, null,\n+                        delegateBaseObject.getReferenceName(), null, null,\n                         null);\n                 delegateProxy.setPrototypeBasedOn(delegateBaseCtor);\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     DiagnosticType.error(\"JSC_INVALID_FUNCTION_DECL\",\n         \"Syntax error: function declaration must have a name\");\n \n+  static final DiagnosticType AMBIGUOUS_FUNCTION_DECL =\n+    DiagnosticType.warning(\"AMBIGUIOUS_FUNCTION_DECL\",\n+        \"Conditional named functions have inconsistent behavior. Instead of\" +\n+        \" 'function f(){}' use 'var f = function(){}'.\");\n+\n   private CompilerInput synthesizedExternsInput = null;\n   private Node synthesizedExternsRoot = null;\n \n         t.report(n, INVALID_FUNCTION_DECL);\n       }\n       return;\n+    }\n+\n+    if (NodeUtil.isFunctionDeclaration(parent)) {\n+      // Warn about having conditional named function declarations as IE and\n+      // FireFox handle them differently.\n+      if (!isHoistedFunction(parent)) {\n+        t.report(n, AMBIGUOUS_FUNCTION_DECL);\n+      }\n     }\n \n     // Check that the var has been declared.\n     }\n     return synthesizedExternsRoot;\n   }\n+\n+  /**\n+   * @return Whether the name function will be hoisted in its scope.\n+   */\n+  boolean isHoistedFunction(Node fn) {\n+    Preconditions.checkArgument(NodeUtil.isFunctionDeclaration(fn));\n+    return fn.getParent().getType() == Token.SCRIPT\n+        || fn.getParent().getParent().getType() == Token.FUNCTION;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n \n   @Override\n   boolean isNominalType() {\n-    return hasName();\n+    return hasReferenceName();\n   }\n \n   @Override\n       return true;\n     } else if (this.isNominalType() && that instanceof JSType &&\n         ((JSType) that).isNominalType()) {\n-      return getName().equals(((ObjectType) that).getName());\n+      return getReferenceName().equals(((ObjectType) that).getReferenceName());\n     }\n     return false;\n   }\n    */\n   @Override\n   public int hashCode() {\n-    if (hasName()) {\n-      return getName().hashCode();\n+    if (hasReferenceName()) {\n+      return getReferenceName().hashCode();\n     } else {\n       return super.hashCode();\n     }\n \n   @Override\n   public String toString() {\n-    return getName() + \".<\" + primitiveType + \">\";\n-  }\n-\n-  @Override\n-  public String getName() {\n+    return getReferenceName() + \".<\" + primitiveType + \">\";\n+  }\n+\n+  @Override\n+  public String getReferenceName() {\n     return name;\n   }\n \n   @Override\n-  public boolean hasName() {\n+  public boolean hasReferenceName() {\n     return true;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n \n   @Override\n   public String toString() {\n-    return getName();\n+    return getReferenceName();\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     if (ownerFunction == null) {\n       return \"{...}.prototype\";\n     } else {\n-      return ownerFunction.getName() + \".prototype\";\n+      return ownerFunction.getReferenceName() + \".prototype\";\n     }\n   }\n \n   @Override\n-  public boolean hasName() {\n-    return ownerFunction != null && ownerFunction.hasName();\n+  public boolean hasReferenceName() {\n+    return ownerFunction != null && ownerFunction.hasReferenceName();\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     }\n     if (this.isInterface()) {\n       if (that.isInterface()) {\n-        return this.getName().equals(that.getName());\n+        return this.getReferenceName().equals(that.getReferenceName());\n       }\n       return false;\n     }\n \n   @Override\n   public int hashCode() {\n-    return isInterface() ? getName().hashCode() : call.hashCode();\n+    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n   }\n \n   public boolean hasEqualCallType(FunctionType otherType) {\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   }\n \n   @Override\n-  public String getName() {\n-    return getConstructor().getName();\n+  public String getReferenceName() {\n+    return getConstructor().getReferenceName();\n   }\n \n   @Override\n-  public boolean hasName() {\n-    return getConstructor().hasName();\n+  public boolean hasReferenceName() {\n+    return getConstructor().hasReferenceName();\n   }\n \n   @Override\n \n   @Override\n   public String toString() {\n-    return constructor.getName();\n+    return constructor.getReferenceName();\n   }\n \n   @Override\n   boolean isTheObjectType() {\n-    return getConstructor().isNative() && \"Object\".equals(getName());\n+    return getConstructor().isNative() && \"Object\".equals(getReferenceName());\n   }\n \n   @Override\n \n   @Override\n   public boolean isArrayType() {\n-    return getConstructor().isNative() && \"Array\".equals(getName());\n+    return getConstructor().isNative() && \"Array\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isStringObjectType() {\n-    return getConstructor().isNative() && \"String\".equals(getName());\n+    return getConstructor().isNative() && \"String\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isBooleanObjectType() {\n-    return getConstructor().isNative() && \"Boolean\".equals(getName());\n+    return getConstructor().isNative() && \"Boolean\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isNumberObjectType() {\n-    return getConstructor().isNative() && \"Number\".equals(getName());\n+    return getConstructor().isNative() && \"Number\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isDateType() {\n-    return getConstructor().isNative() && \"Date\".equals(getName());\n+    return getConstructor().isNative() && \"Date\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isRegexpType() {\n-    return getConstructor().isNative() && \"RegExp\".equals(getName());\n+    return getConstructor().isNative() && \"RegExp\".equals(getReferenceName());\n   }\n \n   @Override\n   boolean isNominalType() {\n-    return hasName();\n+    return hasReferenceName();\n   }\n \n   @Override\n       return true;\n     } else if (this.isNominalType() && that instanceof JSType &&\n         ((JSType) that).isNominalType()) {\n-      return getName().equals(((ObjectType) that).getName());\n+      return getReferenceName().equals(((ObjectType) that).getReferenceName());\n     }\n     return false;\n   }\n    */\n   @Override\n   public int hashCode() {\n-    if (hasName()) {\n-      return getName().hashCode();\n+    if (hasReferenceName()) {\n+      return getReferenceName().hashCode();\n     } else {\n       return super.hashCode();\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n    */\n   void registerTypeImplementingInterface(\n       FunctionType type, ObjectType interfaceInstance) {\n-    interfaceToImplementors.put(interfaceInstance.getName(), type);\n+    interfaceToImplementors.put(interfaceInstance.getReferenceName(), type);\n   }\n \n   /**\n    */\n   public Collection<FunctionType> getDirectImplementors(\n       ObjectType interfaceInstance) {\n-    return interfaceToImplementors.get(interfaceInstance.getName());\n+    return interfaceToImplementors.get(interfaceInstance.getReferenceName());\n   }\n \n   /**\n       FunctionType existingFunctionType, JSType returnType) {\n     return new FunctionType(\n         this,\n-        existingFunctionType.getName(),\n+        existingFunctionType.getReferenceName(),\n         /** source node */ null,\n         existingFunctionType.getParametersNode(),\n         returnType,\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     return reference;\n   }\n \n   }\n \n   @Override\n-  public boolean hasName() {\n+  public boolean hasReferenceName() {\n     return true;\n   }\n \n     } else if (that instanceof ObjectType) {\n       ObjectType objType = (ObjectType) that;\n       return objType.isNominalType() &&\n-          reference.equals(objType.getName());\n+          reference.equals(objType.getReferenceName());\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     return null;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   }\n \n   /**\n-   * Gets this object's name.\n+   * Gets the reference name for this object. This includes named types\n+   * like constructors, prototypes, and enums. It notably does not include\n+   * literal types like strings and booleans and structural types.\n    * @return the object's name or {@code null} if this is an anonymous\n    *         object\n    */\n-  public abstract String getName();\n+  public abstract String getReferenceName();\n \n   /**\n    * Returns true if the object is named.\n    * @return true if the object is named, false if it is anonymous\n    */\n-  public boolean hasName() {\n+  public boolean hasReferenceName() {\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n   @Override\n   public String toString() {\n-    return getName();\n+    return getReferenceName();\n   }\n \n   @Override\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     if (className != null) {\n       return className;\n     } else {\n   }\n \n   @Override\n-  public boolean hasName() {\n+  public boolean hasReferenceName() {\n     return className != null;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public String getName() {\n-    return referencedType.getName();\n-  }\n-\n-  @Override\n-  public boolean hasName() {\n-    return referencedType.hasName();\n+  public String getReferenceName() {\n+    return referencedType.getReferenceName();\n+  }\n+\n+  @Override\n+  public boolean hasReferenceName() {\n+    return referencedType.hasReferenceName();\n   }\n \n   @Override public boolean matchesNumberContext() {\n--- a/src/com/google/javascript/rhino/jstype/TemplateType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateType.java\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     return name;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n \n   @Override\n   public String toString() {\n-    return getName();\n+    return getReferenceName();\n   }\n \n   @Override\n   }\n \n   @Override\n-  public String getName() {\n+  public String getReferenceName() {\n     return isChecked ? \"??\" : \"?\";\n   }\n \n--- a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n-    return new InlineVariables(compiler, true, inlineAllStrings);\n+    return new InlineVariables(\n+        compiler, InlineVariables.Mode.CONSTANTS_ONLY, inlineAllStrings);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n public class InlineVariablesTest extends CompilerTestCase {\n \n   private boolean inlineAllStrings = false;\n+  private boolean inlineLocalsOnly = false;\n \n   public InlineVariablesTest() {\n     enableNormalize();\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n-    return new InlineVariables(compiler, false, inlineAllStrings);\n+    return new InlineVariables(\n+        compiler, \n+        (inlineLocalsOnly) \n+            ? InlineVariables.Mode.LOCALS_ONLY\n+            : InlineVariables.Mode.ALL,\n+        inlineAllStrings);\n   }\n \n   @Override\n   public void tearDown() {\n     inlineAllStrings = false;\n+    inlineLocalsOnly = false;\n   }\n \n   // Test respect for scopes and blocks\n       \"}\"\n       );\n   }\n+\n+  public void testLocalsOnly1() {\n+    inlineLocalsOnly = true;\n+    test(\n+        \"var x=1; x; function f() {var x = 1; x;}\",\n+        \"var x=1; x; function f() {1;}\");\n+  }\n+  \n+  public void testLocalsOnly2() {\n+    inlineLocalsOnly = true;\n+    test(\n+        \"/** @const */\\n\" +\n+        \"var X=1; X;\\n\" +\n+        \"function f() {\\n\" +\n+        \"  /** @const */\\n\" +\n+        \"  var X = 1; X;\\n\" +\n+        \"}\",\n+        \"var X$$constant=1; X$$constant; function f() {1;}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n public class RemoveUnusedVarsTest extends CompilerTestCase {\n \n   private boolean removeGlobal = true;\n+  private boolean preserveAnonymousFunctionNames = false;\n   \n   public RemoveUnusedVarsTest() {\n     super(\"\", false);\n   @Override\n   public void setUp() {\n     removeGlobal = true;\n+    preserveAnonymousFunctionNames = false;\n   }\n   \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n-    return new RemoveUnusedVars(compiler, removeGlobal);\n+    return new RemoveUnusedVars(\n+        compiler, removeGlobal, preserveAnonymousFunctionNames);\n   }\n \n   public void testRemoveUnusedVars() {\n     test(\"var a,b=foo()\", \"foo()\");\n     test(\"var b=foo(),a\", \"foo()\");\n     test(\"var a,b=foo(a)\", \"var a,b=foo(a)\");\n-\n-    // don't remove function objects\n-    test(\"foo(function bar() { })\",\n-         \"foo(function bar(){})\");\n   }\n \n   public void testFunctionArgRemoval() {\n          \"(function x(){return x()})()\");\n   }\n \n-  public void testFunctionWithName() {\n+  public void testFunctionWithName1() {\n+    test(\"var x=function f(){};x()\",\n+         \"var x=function(){};x()\");\n+\n+    preserveAnonymousFunctionNames = true;\n     testSame(\"var x=function f(){};x()\");\n+  }\n+\n+  public void testFunctionWithName2() {\n+    test(\"foo(function bar(){})\",\n+         \"foo(function(){})\");\n+\n+    preserveAnonymousFunctionNames = true;\n+    testSame(\"foo(function bar(){})\");    \n   }\n   \n \n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n     testSame(\"var a = 3; (function a() { return a(); })();\");\n   }\n \n+  public void testAmbiguousFunctionDeclarations() {\n+    testSame(\"if (1) { function f(){}; }\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n+    testSame(\"{ function f(){}; }\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n+    testSame(\"a:function f(){};\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n+\n+    testSame(\"function f(){}\");\n+    testSame(\"(function(){ function f(){} })\");\n+  }\n+\n   public void testLegalVarReferenceBetweenModules() {\n     testDependentModules(\"var x = 10;\", \"var y = x++;\", null);\n   }", "timestamp": 1259160785, "metainfo": ""}