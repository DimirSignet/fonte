{"sha": "8f8b3c307e05b9cb8071bd4cb4dad0036f9e4623", "log": "Move unit tests over from RemoveConstantExpressions.  R=avd DELTA=306  (300 added, 0 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=209767   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldExpr(Node subtree) {\n-    if (subtree.getParent().getType() != Token.LABEL) {\n-      Node result = trySimpilifyUnusedResult(subtree.getFirstChild());\n-      if (result == null) {\n-        // If the EXPR_RESULT no longer has any children, remove it as well.\n+    Node result = trySimpilifyUnusedResult(subtree.getFirstChild());\n+    if (result == null) {\n+      Node parent = subtree.getParent();\n+      // If the EXPR_RESULT no longer has any children, remove it as well.\n+      if (parent.getType() == Token.LABEL) {\n+        Node replacement = new Node(Token.BLOCK).copyInformationFrom(subtree);\n+        parent.replaceChild(subtree, replacement);\n+        subtree = replacement;\n+      } else {\n         subtree.detachFromParent();\n         subtree = null;\n       }\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n \n-    left = trySimpilifyUnusedResult(left, false);\n+    left = trySimpilifyUnusedResult(left);\n     if (left == null || !mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n       reportCodeChange();\n       return right;\n     } else {\n-      if (parent.getType() == Token.EXPR_RESULT) {\n+      if (parent.getType() == Token.EXPR_RESULT\n+          && parent.getParent().getType() != Token.LABEL) {\n         // split comma\n         n.detachChildren();\n         // Replace the original expression with the left operand.\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = foo() && false && bar()\", \"x = foo()&&false\");\n     fold(\"x = foo() && true && bar()\", \"x = foo()&&bar()\");\n     fold(\"x = foo() && false || bar()\", \"x = foo()&&false||bar()\");\n+\n+    fold(\"1 && b()\", \"b()\");\n+    fold(\"a() && (1 && b())\", \"a() && b()\");\n+    // TODO(johnlenz): Consider folding the following to:\n+    //   \"(a(),1) && b();\n+    fold(\"(a() && 1) && b()\", \"(a() && 1) && b()\");\n \n     // Really not foldable, because it would change the type of the\n     // expression if foo() returns something equivalent, but not\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n     foldSame(\"var x; foo:{x = 3;}\");\n     foldSame(\"var x; foo:x = 3;\");\n   }\n+\n+  public void testShortCircuit1() {\n+    test(\"1 && a()\", \"a()\");\n+  }\n+\n+  public void testShortCircuit2() {\n+    test(\"1 && a() && 2\", \"a()\");\n+  }\n+\n+  public void testShortCircuit3() {\n+    test(\"a() && 1 && 2\", \"a()\");\n+  }\n+\n+  public void testShortCircuit4() {\n+    test(\"a() && (1 && b())\", \"a() && b()\");\n+    test(\"a() && 1 && b()\", \"a() && b()\");\n+    testSame(\"(a() && 1) && b()\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n     foldSame(\"var a = (foo(), true);\");\n     foldSame(\"a = (foo(), true);\");\n \n+    // Don't try to split COMMA under LABELs.\n+    foldSame(\"a:a(),b()\");\n+\n     fold(\"(x=2), foo()\", \"x=2; foo()\");\n     fold(\"foo(), boo();\", \"foo(); boo()\");\n     fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n     foldSame(\"function f() {switch(a){case 1: return;}}\");\n     foldSame(\"x:switch(a){case 1: break x;}\");\n   }\n+\n+  public void testRemoveNumber() {\n+    test(\"3\", \"\");\n+  }\n+\n+  public void testRemoveVarGet1() {\n+    test(\"a\", \"\");\n+  }\n+\n+  public void testRemoveVarGet2() {\n+    test(\"var a = 1;a\", \"var a = 1\");\n+  }\n+\n+  public void testRemoveNamespaceGet1() {\n+    test(\"var a = {};a.b\", \"var a = {}\");\n+  }\n+\n+  public void testRemoveNamespaceGet2() {\n+    test(\"var a = {};a.b=1;a.b\", \"var a = {};a.b=1\");\n+  }\n+\n+  public void testRemovePrototypeGet1() {\n+    test(\"var a = {};a.prototype.b\", \"var a = {}\");\n+  }\n+\n+  public void testRemovePrototypeGet2() {\n+    test(\"var a = {};a.prototype.b = 1;a.prototype.b\",\n+         \"var a = {};a.prototype.b = 1\");\n+  }\n+\n+  public void testRemoveAdd1() {\n+    test(\"1 + 2\", \"\");\n+  }\n+\n+  public void testNoRemoveVar1() {\n+    testSame(\"var a = 1\");\n+  }\n+\n+  public void testNoRemoveVar2() {\n+    testSame(\"var a = 1, b = 2\");\n+  }\n+\n+  public void testNoRemoveAssign1() {\n+    testSame(\"a = 1\");\n+  }\n+\n+  public void testNoRemoveAssign2() {\n+    testSame(\"a = b = 1\");\n+  }\n+\n+  public void testNoRemoveAssign3() {\n+    test(\"1 + (a = 2)\", \"a = 2\");\n+  }\n+\n+  public void testNoRemoveAssign4() {\n+    testSame(\"x.a = 1\");\n+  }\n+\n+  public void testNoRemoveAssign5() {\n+    testSame(\"x.a = x.b = 1\");\n+  }\n+\n+  public void testNoRemoveAssign6() {\n+    test(\"1 + (x.a = 2)\", \"x.a = 2\");\n+  }\n+\n+  public void testNoRemoveCall1() {\n+    testSame(\"a()\");\n+  }\n+\n+  public void testNoRemoveCall2() {\n+    test(\"a()+b()\", \"a();b()\");\n+  }\n+\n+  public void testNoRemoveCall3() {\n+    testSame(\"a() && b()\");\n+  }\n+\n+  public void testNoRemoveCall4() {\n+    testSame(\"a() || b()\");\n+  }\n+\n+  public void testNoRemoveCall5() {\n+    test(\"a() || 1\", \"a()\");\n+  }\n+\n+  public void testNoRemoveCall6() {\n+    testSame(\"1 || a()\");\n+  }\n+\n+  public void testNoRemoveThrow1() {\n+    testSame(\"function f(){throw a()}\");\n+  }\n+\n+  public void testNoRemoveThrow2() {\n+    testSame(\"function f(){throw a}\");\n+  }\n+\n+  public void testNoRemoveThrow3() {\n+    testSame(\"function f(){throw 10}\");\n+  }\n+\n+  public void testRemoveInControlStructure1() {\n+    test(\"if(x()) 1\", \"x()\");\n+  }\n+\n+  public void testRemoveInControlStructure2() {\n+    test(\"while(2) 1\", \"while(2);\");\n+  }\n+\n+  public void testRemoveInControlStructure3() {\n+    test(\"for(1;2;3) 4\", \"for(;;);\");\n+  }\n+\n+  public void testHook1() {\n+    test(\"1 ? 2 : 3\", \"\");\n+  }\n+\n+  public void testHook2() {\n+    test(\"x ? a() : 3\", \"x && a()\");\n+  }\n+\n+  public void testHook3() {\n+    test(\"x ? 2 : a()\", \"x || a()\");\n+  }\n+\n+  public void testHook4() {\n+    testSame(\"x ? a() : b()\");\n+  }\n+\n+  public void testHook5() {\n+    test(\"a() ? 1 : 2\", \"a()\");\n+  }\n+\n+  public void testHook6() {\n+    test(\"a() ? b() : 2\", \"a() && b()\");\n+  }\n+\n+  // TODO(johnlenz): Consider adding a post optimization pass to\n+  // convert OR into HOOK to save parentheses when the operator\n+  // precedents would require them.\n+  public void testHook7() {\n+    test(\"a() ? 1 : b()\", \"a() || b()\");\n+  }\n+\n+  public void testHook8() {\n+    testSame(\"a() ? b() : c()\");\n+  }\n+\n+  public void testShortCircuit1() {\n+    testSame(\"1 && a()\");\n+  }\n+\n+  public void testShortCircuit2() {\n+    test(\"1 && a() && 2\", \"1 && a()\");\n+  }\n+\n+  public void testShortCircuit3() {\n+    test(\"a() && 1 && 2\", \"a()\");\n+  }\n+\n+  public void testShortCircuit4() {\n+    testSame(\"a() && 1 && b()\");\n+  }\n+\n+  public void testComma1() {\n+    test(\"1, 2\", \"\");\n+  }\n+\n+  public void testComma2() {\n+    test(\"1, a()\", \"a()\");\n+  }\n+\n+  public void testComma3() {\n+    test(\"1, a(), b()\", \"a();b()\");\n+  }\n+\n+  public void testComma4() {\n+    test(\"a(), b()\", \"a();b()\");\n+  }\n+\n+  public void testComma5() {\n+    test(\"a(), b(), 1\", \"a();b()\");\n+  }\n+\n+  public void testComplex1() {\n+    test(\"1 && a() + b() + c()\", \"1 && (a(), b(), c())\");\n+  }\n+\n+  public void testComplex2() {\n+    test(\"1 && (a() ? b() : 1)\", \"1 && a() && b()\");\n+  }\n+\n+  public void testComplex3() {\n+    test(\"1 && (a() ? b() : 1 + c())\", \"1 && (a() ? b() : c())\");\n+  }\n+\n+  public void testComplex4() {\n+    test(\"1 && (a() ? 1 : 1 + c())\", \"1 && (a() || c())\");\n+  }\n+\n+  public void testComplex5() {\n+    // can't simplify lhs of short circuit statements with side effects\n+    testSame(\"(a() ? 1 : 1 + c()) && foo()\");\n+  }\n+\n+  public void testNoRemoveFunctionDeclaration1() {\n+    testSame(\"function foo(){}\");\n+  }\n+\n+  public void testNoRemoveFunctionDeclaration2() {\n+    testSame(\"var foo = function (){}\");\n+  }\n+\n+  public void testNoSimplifyFunctionArgs1() {\n+    testSame(\"f(1 + 2, 3 + g())\");\n+  }\n+\n+  public void testNoSimplifyFunctionArgs2() {\n+    testSame(\"1 && f(1 + 2, 3 + g())\");\n+  }\n+\n+  public void testNoSimplifyFunctionArgs3() {\n+    testSame(\"1 && foo(a() ? b() : 1 + c())\");\n+  }\n+\n+  public void testNoRemoveInherits1() {\n+    testSame(\"var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a)\");\n+  }\n+\n+  public void testNoRemoveInherits2() {\n+    test(\"var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a) + 1\",\n+         \"var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a)\");\n+  }\n+\n+  public void testNoRemoveInherits3() {\n+    testSame(\"this.a = {}; var b = {}; b.inherits(a);\");\n+  }\n+\n+  public void testNoRemoveInherits4() {\n+    test(\"this.a = {}; var b = {}; b.inherits(a) + 1;\",\n+         \"this.a = {}; var b = {}; b.inherits(a)\");\n+  }\n+\n+  public void testRemoveFromLabel1() {\n+    test(\"LBL: void 0\", \"LBL: {}\");\n+  }\n+\n+  public void testRemoveFromLabel2() {\n+    test(\"LBL: foo() + 1 + bar()\", \"LBL: foo(),bar()\");\n+  }\n+\n+  public void testCall1() {\n+    test(\"Math.sin(0);\", \"\");\n+  }\n+\n+  public void testCall2() {\n+    test(\"1 + Math.sin(0);\", \"\");\n+  }\n+\n+  public void testNew1() {\n+    test(\"new Date;\", \"\");\n+  }\n+\n+  public void testNew2() {\n+    test(\"1 + new Date;\", \"\");\n+  }\n }", "timestamp": 1284051305, "metainfo": ""}