{"sha": "d700e3ee80e8c050211607c62d97f89c3e18b649", "log": "Making checkControlStructures, suspiciousCode, and checkControlFlow hot-swappable.  R=nicksantos DELTA=114  (85 added, 1 deleted, 28 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1866   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n  * passes are doing.</p>\n  *\n  */\n-final class CombinedCompilerPass implements CompilerPass, ScopedCallback {\n+final class CombinedCompilerPass implements HotSwapCompilerPass,\n+    ScopedCallback {\n \n   /** The callbacks that this pass combines. */\n   private final CallbackWrapper[] callbacks;\n   }\n \n   @Override\n+  public void hotSwapScript(Node scriptRoot) {\n+    NodeTraversal.traverse(compiler, scriptRoot, this);\n+  }\n+\n+  @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     for (CallbackWrapper callback : callbacks) {\n       callback.shouldTraverseIfActive(t, n, parent);\n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n import com.google.javascript.rhino.Token;\n \n /**\n- * Check for invalid breaks and continues in the program.\n+ * Check for usage of 'with'.\n  *\n  */\n-class ControlStructureCheck implements CompilerPass {\n+class ControlStructureCheck implements HotSwapCompilerPass {\n \n-  private AbstractCompiler compiler;\n+  private final AbstractCompiler compiler;\n \n   private String sourceName = null;\n \n   @Override\n   public void process(Node externs, Node root) {\n     check(root);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot) {\n+    check(scriptRoot);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n    * Checks for code that is probably wrong (such as stray expressions).\n    */\n   // TODO(bolinfest): Write a CompilerPass for this.\n-  final PassFactory suspiciousCode =\n-      new PassFactory(\"suspiciousCode\", true) {\n-\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final HotSwapPassFactory suspiciousCode =\n+      new HotSwapPassFactory(\"suspiciousCode\", true) {\n+\n+    @Override\n+    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n+        compiler) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n       if (options.checkSuspiciousCode) {\n         sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n   }\n \n   /** Checks for validity of the control structures. */\n-  private final PassFactory checkControlStructures =\n-      new PassFactory(\"checkControlStructures\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkControlStructures =\n+      new HotSwapPassFactory(\"checkControlStructures\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new ControlStructureCheck(compiler);\n     }\n   };\n    * Checks possible execution paths of the program for problems: missing return\n    * statements and dead code.\n    */\n-  private final PassFactory checkControlFlow =\n-      new PassFactory(\"checkControlFlow\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkControlFlow =\n+      new HotSwapPassFactory(\"checkControlFlow\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       List<Callback> callbacks = Lists.newArrayList();\n       if (options.checkUnreachableCode.isOn()) {\n         callbacks.add(\n   };\n \n   /** Executes the given callbacks with a {@link CombinedCompilerPass}. */\n-  private static CompilerPass combineChecks(AbstractCompiler compiler,\n+  private static HotSwapCompilerPass combineChecks(AbstractCompiler compiler,\n       List<Callback> callbacks) {\n     Preconditions.checkArgument(callbacks.size() > 0);\n     Callback[] array = callbacks.toArray(new Callback[callbacks.size()]);", "timestamp": 1305302741, "metainfo": ""}