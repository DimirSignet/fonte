{"sha": "90eaf33dc84e37ec1c85b736f13a47d77a193a07", "log": "Remove NodeUtil method that promote setting line/column without setting the source file.  R=mgoodman,nicksantos DELTA=154  (47 added, 61 deleted, 46 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3864   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n         pathDefinition = NodeUtil.newVarNode(path, initializer);\n       } else {\n         Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n-            compiler.getCodingConvention(), path, -1, -1);\n+            compiler.getCodingConvention(), path);\n         pathDefinition = NodeUtil.newExpr(\n             IR.assign(qualifiedPath, initializer));\n       }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n     return addingRoot;\n   }\n \n-  /** Creates function name(params_0, ..., params_n) { body }. */\n-  public static Node newFunctionNode(String name, List<Node> params,\n-      Node body, int lineno, int charno) {\n-    Node parameterParen = new Node(Token.PARAM_LIST, lineno, charno);\n-    for (Node param : params) {\n-      parameterParen.addChildToBack(param);\n-    }\n-    Node function = new Node(Token.FUNCTION, lineno, charno);\n-    function.addChildrenToBack(\n-        Node.newString(Token.NAME, name, lineno, charno));\n-    function.addChildToBack(parameterParen);\n-    function.addChildToBack(body);\n-    return function;\n-  }\n-\n   /**\n    * Creates a node representing a qualified name.\n    *\n    * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n-   * @param lineno The source line offset.\n-   * @param charno The source character offset from start of the line.\n    * @return A NAME or GETPROP node\n    */\n   public static Node newQualifiedNameNode(\n-      CodingConvention convention, String name, int lineno, int charno) {\n+      CodingConvention convention, String name) {\n     int endPos = name.indexOf('.');\n     if (endPos == -1) {\n-      return newName(convention, name, lineno, charno);\n-    }\n-    Node node = newName(\n-        convention, name.substring(0, endPos), lineno, charno);\n+      return newName(convention, name);\n+    }\n+    Node node = newName(convention, name.substring(0, endPos));\n     int startPos;\n     do {\n       startPos = endPos + 1;\n       String part = (endPos == -1\n                      ? name.substring(startPos)\n                      : name.substring(startPos, endPos));\n-      Node propNode = Node.newString(part, lineno, charno);\n+      Node propNode = IR.string(part);\n       if (convention.isConstantKey(part)) {\n         propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n       }\n-      node = new Node(Token.GETPROP, node, propNode, lineno, charno);\n+      node = IR.getprop(node, propNode);\n     } while (endPos != -1);\n \n     return node;\n   static Node newQualifiedNameNode(\n       CodingConvention convention, String name, Node basisNode,\n       String originalName) {\n-    Node node = newQualifiedNameNode(convention, name, -1, -1);\n+    Node node = newQualifiedNameNode(convention, name);\n     setDebugInformation(node, basisNode, originalName);\n     return node;\n   }\n   }\n \n   private static Node newName(\n-      CodingConvention convention, String name, int lineno, int charno) {\n-    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);\n+      CodingConvention convention, String name) {\n+    Node nameNode = IR.name(name);\n     if (convention.isConstant(name)) {\n       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n    * location information from the basis node.\n    *\n    * @param name The name for the new NAME node.\n-   * @param basisNode The node that represents the name as currently found in\n+   * @param srcref The node that represents the name as currently found in\n    *     the AST.\n    *\n    * @return The node created.\n    */\n-  static Node newName(\n-      CodingConvention convention, String name, Node basisNode) {\n-    Node nameNode = IR.name(name);\n-    if (convention.isConstantKey(name)) {\n-      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    }\n-    nameNode.copyInformationFrom(basisNode);\n-    return nameNode;\n+  static Node newName(CodingConvention convention, String name, Node srcref) {\n+    return newName(convention, name).srcref(srcref);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n \n       Node newFirstArgument = NodeUtil.newQualifiedNameNode(\n           compiler.getCodingConvention(),\n-          compiler.getCodingConvention().getGlobalObject(),\n-          firstArgument.getLineno(), firstArgument.getCharno());\n+          compiler.getCodingConvention().getGlobalObject())\n+              .srcrefTree(firstArgument);\n+\n       Node newSecondArgument = NodeUtil.newQualifiedNameNode(\n           compiler.getCodingConvention(),\n           firstArgument.getQualifiedName() + \".\" +\n-          firstArgument.getNext().getString(),\n-          secondArgument.getLineno(), secondArgument.getCharno());\n+          firstArgument.getNext().getString())\n+              .srcrefTree(secondArgument);\n+\n       n.replaceChild(firstArgument, newFirstArgument);\n       n.replaceChild(secondArgument, newSecondArgument);\n \n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n       }\n \n       Node classNode = NodeUtil.newQualifiedNameNode(\n-          compiler.getCodingConvention(), className, -1, -1);\n+          compiler.getCodingConvention(), className);\n \n       Node marker = IR.string(\n               interfaceType == null ?\n \n   private Node jsCode(String prop) {\n     return NodeUtil.newQualifiedNameNode(\n-        compiler.getCodingConvention(), \"jscomp.typecheck.\" + prop, -1, -1);\n+        compiler.getCodingConvention(), \"jscomp.typecheck.\" + prop);\n   }\n \n   @VisibleForTesting\n--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n \n import com.google.common.base.Preconditions;\n \n+import java.util.List;\n+\n /**\n  * An AST construction helper class\n  * @author johnlenz@google.com (John Lenz)\n   }\n \n   public static Node paramList(Node ... params) {\n-    Node paramList = new Node(Token.PARAM_LIST);\n+    Node paramList = paramList();\n+    for (Node param : params) {\n+      Preconditions.checkState(param.isName());\n+      paramList.addChildToBack(param);\n+    }\n+    return paramList;\n+  }\n+\n+  public static Node paramList(List<Node> params) {\n+    Node paramList = paramList();\n     for (Node param : params) {\n       Preconditions.checkState(param.isName());\n       paramList.addChildToBack(param);\n \n   public static Node number(double d) {\n     return Node.newNumber(d);\n+  }\n+\n+  public static Node thisNode() {\n+    return new Node(Token.THIS);\n   }\n \n   public static Node trueNode() {\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import junit.framework.TestCase;\n \n import java.util.Collection;\n-import java.util.List;\n import java.util.Set;\n \n public class NodeUtilTest extends TestCase {\n     assertContainsAnonFunc(false, \"with (x) function a(){}\");\n   }\n \n-  public void testNewFunctionNode() {\n-    Node expected = parse(\"function foo(p1, p2, p3) { throw 2; }\");\n-    Node body = new Node(Token.BLOCK, new Node(Token.THROW, Node.newNumber(2)));\n-    List<Node> params = Lists.newArrayList(Node.newString(Token.NAME, \"p1\"),\n-                                           Node.newString(Token.NAME, \"p2\"),\n-                                           Node.newString(Token.NAME, \"p3\"));\n-    Node function = NodeUtil.newFunctionNode(\n-        \"foo\", params, body, -1, -1);\n-    Node actual = new Node(Token.SCRIPT);\n-    actual.setIsSyntheticBlock(true);\n-    actual.addChildToFront(function);\n-    String difference = expected.checkTreeEquals(actual);\n-    if (difference != null) {\n-      assertTrue(\"Nodes do not match:\\n\" + difference, false);\n-    }\n-  }\n-\n   private void assertContainsAnonFunc(boolean expected, String js) {\n     Node funcParent = findParentOfFuncDescendant(parse(js));\n     assertNotNull(\"Expected function node in parse tree of: \" + js, funcParent);", "timestamp": 1322500157, "metainfo": ""}