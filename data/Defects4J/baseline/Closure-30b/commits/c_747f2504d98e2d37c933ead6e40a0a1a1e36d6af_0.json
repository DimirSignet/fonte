{"sha": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af", "log": "Change on 2010/08/04 13:06:31 by nicksantos  \tA new var-collection mechanism for RemoveUnusedVars.  In the \tnew mechanism, we only traverse a subtree for references if it \tmight have side-effects, or if its return value is used.  If \tits return value is stored in a variable, then we store a \tcontinuation, and execute the continuation iff that variable \tis referenced.  \tThis is a more general formulation of RemoveUnusedVars's current \tstrategy (\"traverse a function iff it's referenced\").  \tR=acleung \tDELTA=560  (326 added, 63 deleted, 171 changed)  Change on 2010/08/04 13:09:34 by rjfioravanti  \tCreating externs for CSSMatrix and WebKitCSSMatrix.  \tBased on documentation from the following locations: \thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface \thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue  \tR=nicksantos \tDELTA=193  (193 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=90012   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Token;\n \n import java.util.*;\n+import java.util.Map;\n import java.util.logging.Logger;\n \n /**\n  * a mark-and-sweep type algorithm over the javascript parse tree.\n  *\n  * For each scope:\n- * (1) Scan the variable/function declarations at that scope, but do not\n- *     recurse into the function definitions.\n- * (2) Mark all referenced variables and functions calls. Recurse into the\n- *     scopes of those function calls.\n- * (3) When leaving the scope, remove any variables in that scope that were\n- *     never referenced.\n- *\n- * Multiple passes are performed until no variables are removed, indicating a\n- * convergence.\n+ * (1) Scan the variable/function declarations at that scope.\n+ * (2) Traverse the scope for references, marking all referenced variables.\n+ *     Unlike other compiler passes, this is a pre-order traversal, not a\n+ *     post-order traversal.\n+ * (3) If the traversal encounters an assign without other side-effects,\n+ *     create a continuation. Continue the continuation iff the assigned\n+ *     variable is referenced.\n+ * (4) When the traversal completes, remove all unreferenced variables.\n+ *\n+ * If it makes it easier, you can think of the continuations of the traversal\n+ * as a reference graph. Each continuation represents a set of edges, where the\n+ * source node is a known variable, and the destination nodes are lazily\n+ * evaluated when the continuation is executed.\n+ *\n+ * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n+ * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n+ * between global symbols. However, {@code SmartNameRemoval} cannot handle\n+ * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n+ * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n+ * substantially more complicated because it tries to handle namespaces\n+ * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n+ *\n+ * This pass also uses a more complex analysis of assignments, where\n+ * an assignment to a variable or a property of that variable does not\n+ * necessarily count as a reference to that variable, unless we can prove\n+ * that it modifies external state. This is similar to\n+ * {@code FlowSensitiveInlineVariables}, except that it works for variables\n+ * used across scopes.\n  *\n *\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n class RemoveUnusedVars implements CompilerPass {\n   private static final Logger logger =\n   private final Set<Var> referenced = Sets.newHashSet();\n \n   /**\n+   * Keep track of variables that might be unreferenced.\n+   */\n+  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n+\n+  /**\n+   * Keep track of scopes that we've traversed.\n+   */\n+  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n+\n+  /**\n    * Keep track of assigns to variables that we haven't referenced.\n    */\n-  private final Multimap<Var, Assign> assigns = ArrayListMultimap.create();\n+  private final Multimap<Var, Assign> assignsByVar =\n+      ArrayListMultimap.create();\n+\n+  /**\n+   * The assigns, indexed by the NAME node that they assign to.\n+   */\n+  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n+\n+  /**\n+   * Keep track of continuations that are finished iff the variable they're\n+   * indexed by is referenced.\n+   */\n+  private final Multimap<Var, Continuation> continuations =\n+      ArrayListMultimap.create();\n \n   RemoveUnusedVars(\n       AbstractCompiler compiler,\n     traverseNode(root, null, scope);\n \n     if (removeGlobals) {\n-      interpretAssigns(scope);\n-      removeUnreferencedVars(scope);\n+      collectMaybeUnreferencedVars(scope);\n+    }\n+\n+    interpretAssigns();\n+    removeUnreferencedVars();\n+    for (Scope fnScope : allFunctionScopes) {\n+      removeUnreferencedFunctionArgs(fnScope);\n     }\n   }\n \n   /**\n    * Traverses everything in the current scope and marks variables that\n-   * are referenced. Functions create their own scope, so we don't\n-   * recurse into them unless they are called.\n+   * are referenced.\n+   *\n+   * During traversal, we identify subtrees that will only be\n+   * referenced if their enclosing variables are referenced. Instead of\n+   * traversing those subtrees, we create a continuation for them,\n+   * and traverse them lazily.\n    */\n   private void traverseNode(Node n, Node parent, Scope scope) {\n     int type = n.getType();\n+    Var var = null;\n     switch (type) {\n-      // We traverse a function only if the function definition is\n-      // immediately being referenced, e.g.\n-      // - return function() { ... };\n-      // - foo( function() { ... } )\n-      // - array[ function() { ... } ];\n-      //\n-      // Otherwise we traverse into the function only when we encounter\n-      // a reference to it (see markReferencedVar())\n       case Token.FUNCTION:\n-        // If it's an exported function, or an function expression, assume\n-        // that it'll be called.\n-        if (traverseFunctionWhenFirstSeen(n, scope)) {\n+        // If this function is a removable var, then create a continuation\n+        // for it instead of traversing immediately.\n+        if (NodeUtil.isFunctionDeclaration(n)) {\n+          var = scope.getVar(n.getFirstChild().getString());\n+        }\n+\n+        if (var != null && isRemovableVar(var)) {\n+          continuations.put(var, new Continuation(n, scope));\n+        } else {\n           traverseFunction(n, scope);\n         }\n         return;\n \n+      case Token.ASSIGN:\n+        Assign maybeAssign = Assign.maybeCreateAssign(n);\n+        if (maybeAssign != null) {\n+          // Put this in the assign map. It might count as a reference,\n+          // but we won't know that until we have an index of all assigns.\n+          var = scope.getVar(maybeAssign.nameNode.getString());\n+          if (var != null) {\n+            assignsByVar.put(var, maybeAssign);\n+            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n+\n+            if (isRemovableVar(var) &&\n+                !maybeAssign.mayHaveSecondarySideEffects) {\n+              // If the var is unreferenced and performing this assign has\n+              // no secondary side effects, then we can create a continuation\n+              // for it instead of traversing immediately.\n+              continuations.put(var, new Continuation(n, scope));\n+              return;\n+            }\n+          }\n+        }\n+        break;\n+\n       case Token.NAME:\n-        if (parent.getType() != Token.VAR) {\n+        var = scope.getVar(n.getString());\n+        if (parent.getType() == Token.VAR) {\n+          Node value = n.getFirstChild();\n+          if (value != null && var != null && isRemovableVar(var) &&\n+              !NodeUtil.mayHaveSideEffects(value)) {\n+            // If the var is unreferenced and creating its value has no side\n+            // effects, then we can create a continuation for it instead\n+            // of traversing immediately.\n+            continuations.put(var, new Continuation(n, scope));\n+            return;\n+          }\n+        } else {\n           // All name references that aren't declarations or assigns\n-          // are references to other vars. If that var hasn't already been\n-          // marked referenced, then start tracking it.\n-          Var var = scope.getVar(n.getString());\n-          if (var != null && !referenced.contains(var)) {\n-            Assign maybeAssign = Assign.maybeCreateAssign(n);\n-            if (maybeAssign == null) {\n+          // are references to other vars.\n+          if (var != null) {\n+            // If that var hasn't already been marked referenced, then\n+            // start tracking it.  If this is an assign, do nothing\n+            // for now.\n+            if (isRemovableVar(var)) {\n+              if (!assignsByNode.containsKey(n)) {\n+                markReferencedVar(var);\n+              }\n+            } else {\n               markReferencedVar(var);\n-            } else {\n-              // Put this in the assign map. It might count as a reference,\n-              // but we won't know that until we have an index of all assigns.\n-              assigns.put(var, maybeAssign);\n             }\n           }\n         }\n     }\n   }\n \n-  /**\n-   * @param n The function node.\n-   * @return Whether to traverse the function immediately.\n-   */\n-  private boolean traverseFunctionWhenFirstSeen(Node n, Scope scope) {\n-    return NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope);\n-  }\n-\n-  /**\n-   * @param n The function node.\n-   * @return Whether the function is exported.\n-   */\n-  private boolean isExportedFunction(Node n, Scope scope) {\n-    Preconditions.checkState(NodeUtil.isFunctionDeclaration(n));\n-    // If we aren't removing global names, assume that all global functions\n-    // are exported.\n-    return (!removeGlobals && scope.isGlobal()) ||\n-        compiler.getCodingConvention().isExported(\n-           n.getFirstChild().getString());\n+  private boolean isRemovableVar(Var var) {\n+    // Global variables are off-limits if the user might be using them.\n+    if (!removeGlobals && var.isGlobal()) {\n+      return false;\n+    }\n+\n+    // Referenced variables are off-limits.\n+    if (referenced.contains(var)) {\n+      return false;\n+    }\n+\n+    // Exported variables are off-limits.\n+    if (compiler.getCodingConvention().isExported(var.getName())) {\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n   /**\n    * enclosing scope. Because we don't remove catch variables, there's\n    * no need to treat CATCH blocks differently like we do functions.\n    */\n-  private void traverseFunction(Node n, Scope scope) {\n+  private void traverseFunction(Node n, Scope parentScope) {\n     Preconditions.checkState(n.getChildCount() == 3);\n     Preconditions.checkState(n.getType() == Token.FUNCTION);\n \n     Preconditions.checkState(body.getNext() == null &&\n             body.getType() == Token.BLOCK);\n \n-    Scope fnScope = new SyntacticScopeCreator(compiler).createScope(n, scope);\n+    Scope fnScope =\n+        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n     traverseNode(body, n, fnScope);\n \n-    interpretAssigns(fnScope);\n-    removeUnreferencedFunctionArgs(n, fnScope);\n-    removeUnreferencedVars(fnScope);\n+    collectMaybeUnreferencedVars(fnScope);\n+    allFunctionScopes.add(fnScope);\n+  }\n+\n+  /**\n+   * For each variable in this scope that we haven't found a reference\n+   * for yet, add it to the list of variables to check later.\n+   */\n+  private void collectMaybeUnreferencedVars(Scope scope) {\n+    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n+      Var var = it.next();\n+      if (isRemovableVar(var)) {\n+        maybeUnreferenced.add(var);\n+      }\n+    }\n   }\n \n   /**\n    * Removes unreferenced arguments from a function declaration.\n    *\n-   * @param function The FUNCTION node\n    * @param fnScope The scope inside the function\n    */\n-  private void removeUnreferencedFunctionArgs(Node function, Scope fnScope) {\n+  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n     // Strip unreferenced args off the end of the function declaration.\n+    Node function = fnScope.getRootNode();\n+    Preconditions.checkState(function.getType() == Token.FUNCTION);\n+\n     Node argList = function.getFirstChild().getNext();\n     Node lastArg;\n     while ((lastArg = argList.getLastChild()) != null) {\n               + lastArg.getString());\n         }\n         argList.removeChild(lastArg);\n-        fnScope.undeclare(var);\n-        finishRemove(var);\n+        compiler.reportCodeChange();\n       } else {\n         break;\n       }\n   }\n \n   /**\n-   * Look at all the property assigns to all variables in the given\n-   * scope. These may or may not count as references. For example,\n+   * Look at all the property assigns to all variables.\n+   * These may or may not count as references. For example,\n    *\n    * <code>\n    * var x = {};\n    * var y = foo();\n    * y.foo = 3; // is a reference.\n    * </code>\n-   */\n-  private void interpretAssigns(Scope scope) {\n-    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n+   *\n+   * Interpreting assigments could mark a variable as referenced that\n+   * wasn't referenced before, in order to keep it alive. Because we find\n+   * references by lazily traversing subtrees, marking a variable as\n+   * referenced could trigger new traversals of new subtrees, which could\n+   * find new references.\n+   *\n+   * Therefore, this interpretation needs to be run to a fixed point.\n+   */\n+  private void interpretAssigns() {\n+    boolean changes = false;\n+    do {\n+      changes = false;\n+\n+      // We can't use traditional iterators and iterables for this list,\n+      // because our lazily-evaluated continuations will modify it while\n+      // we traverse it.\n+      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n+        Var var = maybeUnreferenced.get(current);\n+        if (referenced.contains(var)) {\n+          maybeUnreferenced.remove(current);\n+          current--;\n+        } else {\n+          boolean assignedToUnknownValue = false;\n+          boolean hasPropertyAssign = false;\n+\n+          if (var.getParentNode().getType() == Token.VAR) {\n+            Node value = var.getInitialValue();\n+            assignedToUnknownValue = value != null &&\n+                !NodeUtil.isLiteralValue(value, true);\n+          } else {\n+            // This was initialized to a function arg or a catch param.\n+            assignedToUnknownValue = true;\n+          }\n+\n+          for (Assign assign : assignsByVar.get(var)) {\n+            if (assign.isPropertyAssign) {\n+              hasPropertyAssign = true;\n+            } else if (!NodeUtil.isLiteralValue(\n+                assign.assignNode.getLastChild(), true)) {\n+              assignedToUnknownValue = true;\n+            }\n+          }\n+\n+          if (assignedToUnknownValue && hasPropertyAssign) {\n+            changes = markReferencedVar(var) || changes;\n+            maybeUnreferenced.remove(current);\n+            current--;\n+          }\n+        }\n+      }\n+    } while (changes);\n+  }\n+\n+  /**\n+   * Remove all assigns to a var.\n+   */\n+  private void removeAllAssigns(Var var) {\n+    for (Assign assign : assignsByVar.get(var)) {\n+      assign.remove();\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Marks a var as referenced, recursing into any values of this var\n+   * that we skipped.\n+   * @return True if this variable had not been referenced before.\n+   */\n+  private boolean markReferencedVar(Var var) {\n+    if (referenced.add(var)) {\n+      for (Continuation c : continuations.get(var)) {\n+        c.apply();\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Removes any vars in the scope that were not referenced. Removes any\n+   * assigments to those variables as well.\n+   */\n+  private void removeUnreferencedVars() {\n+    CodingConvention convention = compiler.getCodingConvention();\n+\n+    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n       Var var = it.next();\n-      if (!referenced.contains(var)) {\n-        boolean assignedToUnknownValue = false;\n-        boolean hasPropertyAssign = false;\n-\n-        if (var.getParentNode().getType() == Token.VAR) {\n-          Node value = var.getInitialValue();\n-          assignedToUnknownValue = value != null &&\n-              !NodeUtil.isLiteralValue(value, true);\n-        } else {\n-          // This was initialized to a function arg or a catch param.\n-          assignedToUnknownValue = true;\n-        }\n-\n-        for (Assign assign : assigns.get(var)) {\n-          if (assign.isPropertyAssign) {\n-            hasPropertyAssign = true;\n-          } else if (!NodeUtil.isLiteralValue(\n-              assign.assignNode.getLastChild(), true)) {\n-            assignedToUnknownValue = true;\n-          }\n-        }\n-\n-        if (assignedToUnknownValue && hasPropertyAssign) {\n-          markReferencedVar(var);\n-        }\n-      }\n-    }\n-  }\n-\n-\n-  /**\n-   * Finishes removal of a var by removing all assigns to it and reporting\n-   * a code change.\n-   */\n-  private void finishRemove(Var var) {\n-    for (Assign assign : assigns.get(var)) {\n-      assign.remove();\n-    }\n-    compiler.reportCodeChange();\n-  }\n-\n-  /**\n-   * Marks a var as referenced, recursing into any functions.\n-   */\n-  private void markReferencedVar(Var var) {\n-    referenced.add(var);\n-\n-    Node parent = var.getParentNode();\n-    if (parent.getType() == Token.FUNCTION) {\n-      // Now that the function has been referenced traverse it if it won't be\n-      // traversed otherwise.\n-      if (!traverseFunctionWhenFirstSeen(parent, var.getScope())) {\n-        traverseFunction(parent, var.scope);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Removes any vars in the scope that were not referenced.\n-   */\n-  private void removeUnreferencedVars(Scope scope) {\n-    CodingConvention convention = compiler.getCodingConvention();\n-\n-    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n-      Var var = it.next();\n-\n-      if (!referenced.contains(var) &&\n-          (var.isLocal() || !convention.isExported(var.name))) {\n-\n-        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n-        Node nameNode = var.nameNode;\n-        Node toRemove = nameNode.getParent();\n-        Node parent = toRemove.getParent();\n-\n-        Preconditions.checkState(\n-            toRemove.getType() == Token.VAR ||\n-            toRemove.getType() == Token.FUNCTION ||\n-            toRemove.getType() == Token.LP &&\n-            parent.getType() == Token.FUNCTION,\n-            \"We should only declare vars and functions and function args\");\n-\n-        if (toRemove.getType() == Token.LP &&\n-            parent.getType() == Token.FUNCTION) {\n-          // Don't remove function arguments here. That's a special case\n-          // that's taken care of in removeUnreferencedFunctionArgs.\n-        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n-          if (!preserveFunctionExpressionNames) {\n-            toRemove.getFirstChild().setString(\"\");\n-            finishRemove(var);\n-          }\n-          // Don't remove bleeding functions.\n-        } else if (parent != null &&\n-            parent.getType() == Token.FOR &&\n-            parent.getChildCount() < 4) {\n-          // foreach iterations have 3 children. Leave them alone.\n-        } else if (toRemove.getType() == Token.VAR &&\n-                   nameNode.hasChildren() &&\n-                   NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-          // If this is a single var declaration, we can at least remove the\n-          // declaration itself and just leave the value, e.g.,\n-          // var a = foo(); => foo();\n-          if (toRemove.getChildCount() == 1) {\n-            parent.replaceChild(toRemove,\n-                new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-            finishRemove(var);\n-          }\n-        } else if (toRemove.getType() == Token.VAR &&\n-                   toRemove.getChildCount() > 1) {\n-          // For var declarations with multiple names (i.e. var a, b, c),\n-          // only remove the unreferenced name\n-          toRemove.removeChild(nameNode);\n-          finishRemove(var);\n-        } else if (parent != null) {\n-          NodeUtil.removeChild(parent, toRemove);\n-          finishRemove(var);\n+\n+      // Regardless of what happens to the original declaration,\n+      // we need to remove all assigns, because they may contain references\n+      // to other unreferenced variables.\n+      removeAllAssigns(var);\n+\n+      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n+      Node nameNode = var.nameNode;\n+      Node toRemove = nameNode.getParent();\n+      Node parent = toRemove.getParent();\n+\n+      Preconditions.checkState(\n+          toRemove.getType() == Token.VAR ||\n+          toRemove.getType() == Token.FUNCTION ||\n+          toRemove.getType() == Token.LP &&\n+          parent.getType() == Token.FUNCTION,\n+          \"We should only declare vars and functions and function args\");\n+\n+      if (toRemove.getType() == Token.LP &&\n+          parent.getType() == Token.FUNCTION) {\n+        // Don't remove function arguments here. That's a special case\n+        // that's taken care of in removeUnreferencedFunctionArgs.\n+      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+        if (!preserveFunctionExpressionNames) {\n+          toRemove.getFirstChild().setString(\"\");\n+          compiler.reportCodeChange();\n+        }\n+        // Don't remove bleeding functions.\n+      } else if (parent != null &&\n+          parent.getType() == Token.FOR &&\n+          parent.getChildCount() < 4) {\n+        // foreach iterations have 3 children. Leave them alone.\n+      } else if (toRemove.getType() == Token.VAR &&\n+          nameNode.hasChildren() &&\n+          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+        // If this is a single var declaration, we can at least remove the\n+        // declaration itself and just leave the value, e.g.,\n+        // var a = foo(); => foo();\n+        if (toRemove.getChildCount() == 1) {\n+          parent.replaceChild(toRemove,\n+              new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+          compiler.reportCodeChange();\n+        }\n+      } else if (toRemove.getType() == Token.VAR &&\n+          toRemove.getChildCount() > 1) {\n+        // For var declarations with multiple names (i.e. var a, b, c),\n+        // only remove the unreferenced name\n+        toRemove.removeChild(nameNode);\n+        compiler.reportCodeChange();\n+      } else if (parent != null) {\n+        NodeUtil.removeChild(parent, toRemove);\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Our progress in a traversal can be expressed completely as the\n+   * current node and scope. The continuation lets us save that\n+   * information so that we can continue the traversal later.\n+   */\n+  private class Continuation {\n+    private final Node node;\n+    private final Scope scope;\n+\n+    Continuation(Node node, Scope scope) {\n+      this.node = node;\n+      this.scope = scope;\n+    }\n+\n+    void apply() {\n+      if (NodeUtil.isFunctionDeclaration(node)) {\n+        traverseFunction(node, scope);\n+      } else {\n+        for (Node child = node.getFirstChild();\n+             child != null; child = child.getNext()) {\n+          traverseNode(child, node, scope);\n         }\n       }\n     }\n   private static class Assign {\n \n     final Node assignNode;\n+\n+    final Node nameNode;\n \n     // If false, then this is an assign to the normal variable. Otherwise,\n     // this is an assign to a property of that variable.\n     final boolean isPropertyAssign;\n \n-    Assign(Node assignNode, boolean isPropertyAssign) {\n+    // Secondary side effects are any side effects in this assign statement\n+    // that aren't caused by the assignment operation itself. For example,\n+    // a().b = 3;\n+    // a = b();\n+    // var foo = (a = b);\n+    // In the first two cases, the sides of the assignment have side-effects.\n+    // In the last one, the result of the assignment is used, so we\n+    // are conservative and assume that it may be used in a side-effecting\n+    // way.\n+    final boolean mayHaveSecondarySideEffects;\n+\n+    Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n       Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n       this.assignNode = assignNode;\n+      this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n+\n+      this.mayHaveSecondarySideEffects =\n+          assignNode.getParent().getType() != Token.EXPR_RESULT ||\n+          NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n+          NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n     }\n \n     /**\n-     * If this is an assign to the given name, return that name.\n+     * If this is an assign to a variable or its property, return it.\n      * Otherwise, return null.\n      */\n-    static Assign maybeCreateAssign(Node name) {\n-      Preconditions.checkState(name.getType() == Token.NAME);\n+    static Assign maybeCreateAssign(Node assignNode) {\n+      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n \n       // Skip any GETPROPs or GETELEMs\n       boolean isPropAssign = false;\n-      Node previous = name;\n-      Node current = name.getParent();\n-      while (previous == current.getFirstChild() &&\n-          NodeUtil.isGet(current)) {\n-        previous = current;\n-        current = current.getParent();\n+      Node current = assignNode.getFirstChild();\n+      while (NodeUtil.isGet(current)) {\n+        current = current.getFirstChild();\n         isPropAssign = true;\n       }\n \n-      if (previous == current.getFirstChild() &&\n-          NodeUtil.isAssignmentOp(current)) {\n-        return new Assign(current, isPropAssign);\n+      if (current.getType() == Token.NAME) {\n+        return new Assign(assignNode, current, isPropAssign);\n       }\n       return null;\n     }\n      * Replace the current assign with its right hand side.\n      */\n     void remove() {\n-      Node replacement = assignNode.getLastChild().detachFromParent();\n-\n-      // Aggregate any expressions in GETELEMs.\n-      for (Node current = assignNode.getFirstChild();\n-           current.getType() != Token.NAME;\n-           current = current.getFirstChild()) {\n-        if (current.getType() == Token.GETELEM) {\n-          replacement = new Node(Token.COMMA,\n-              current.getLastChild().detachFromParent(), replacement);\n-          replacement.copyInformationFrom(current);\n-        }\n-      }\n-\n-      assignNode.getParent().replaceChild(\n-          assignNode, replacement);\n+      Node parent = assignNode.getParent();\n+      if (mayHaveSecondarySideEffects) {\n+        Node replacement = assignNode.getLastChild().detachFromParent();\n+\n+        // Aggregate any expressions in GETELEMs.\n+        for (Node current = assignNode.getFirstChild();\n+             current.getType() != Token.NAME;\n+             current = current.getFirstChild()) {\n+          if (current.getType() == Token.GETELEM) {\n+            replacement = new Node(Token.COMMA,\n+                current.getLastChild().detachFromParent(), replacement);\n+            replacement.copyInformationFrom(current);\n+          }\n+        }\n+\n+        parent.replaceChild(assignNode, replacement);\n+      } else {\n+        Node gramps = parent.getParent();\n+        if (parent.getType() == Token.EXPR_RESULT) {\n+          gramps.removeChild(parent);\n+        } else {\n+          parent.replaceChild(assignNode,\n+              assignNode.getLastChild().detachFromParent());\n+        }\n+      }\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n   private boolean preserveFunctionExpressionNames = false;\n \n   public RemoveUnusedVarsTest() {\n-    super(\"\");\n+    super(\"function alert() {}\");\n     enableNormalize();\n   }\n \n \n     // Test multiple passes required\n     test(\"var a,b,c,d;var e=[b,c];var x=e[3];var f=[d];print(f[0])\",\n-         \"var b,c,d;var f=[d];print(f[0])\");\n+         \"var d;var f=[d];print(f[0])\");\n \n     // Test proper scoping (static vs dynamic)\n     test(\"var x;function A(){var x;B()}function B(){print(x)}A()\",\n          \"return function(){print(f)}}B()\",\n \n          \"function B(){\" +\n-         \"var d,e,f,h;\" +\n-         \"e=function(){print(e)};\" +\n+         \"var f,h;\" +\n          \"if(1);\" +\n          \"arr=[function(){print(h)}];\" +\n          \"return function(){print(f)}}B()\");\n   }\n \n   public void testUnusedAssign1() {\n-    test(\"var x = 3; x = 5;\", \"5\");\n+    test(\"var x = 3; x = 5;\", \"\");\n   }\n \n   public void testUnusedAssign2() {\n     test(\"function f(a) { a = 3; } this.x = f;\",\n-        \"function f(){3}this.x=f\");\n+        \"function f(){}this.x=f\");\n   }\n \n   public void testUnusedAssign3() {\n   }\n \n   public void testUnusedAssign4() {\n-    // b can't be removed, so a can't be removed either. We might be able\n-    // to improve on this case.\n     test(\"function f(a, b) { this.foo(b); a = 3; } this.x = f;\",\n-        \"function f(a,b){this.foo(b);a=3}this.x=f\");\n+        \"function f(a,b){this.foo(b);}this.x=f\");\n   }\n \n   public void testUnusedAssign5() {\n     test(\"var z = function f() { f = 3; }; z();\",\n-         \"var z=function(){3};z()\");\n+         \"var z=function(){};z()\");\n+  }\n+\n+  public void testUnusedAssign5b() {\n+    test(\"var z = function f() { f = alert(); }; z();\",\n+         \"var z=function(){alert()};z()\");\n   }\n \n   public void testUnusedAssign6() {\n-    test(\"var z; z = 3;\", \"3\");\n+    test(\"var z; z = 3;\", \"\");\n+  }\n+\n+  public void testUnusedAssign6b() {\n+    test(\"var z; z = alert();\", \"alert()\");\n+  }\n+\n+  public void testUnusedAssign7() {\n+    test(\"var a = 3; for (var i in {}) { i = a; }\",\n+         \"for (var i in {}) {}\");\n+  }\n+\n+  public void testUnusedAssign8() {\n+    test(\"var a = 3; for (var i in {}) { i = a; } alert(a);\",\n+         \"var a = 3; for (var i in {}) {} alert(a);\");\n   }\n \n   public void testUnusedPropAssign1() {\n-    test(\"var x = {}; x.foo = 3;\", \"3\");\n+    test(\"var x = {}; x.foo = 3;\", \"\");\n+  }\n+\n+  public void testUnusedPropAssign1b() {\n+    test(\"var x = {}; x.foo = alert();\", \"alert()\");\n   }\n \n   public void testUnusedPropAssign2() {\n-    test(\"var x = {}; x['foo'] = 3;\", \"\\\"foo\\\",3\");\n+    test(\"var x = {}; x['foo'] = 3;\", \"\");\n+  }\n+\n+  public void testUnusedPropAssign2b() {\n+    test(\"var x = {}; x[alert()] = alert();\", \"alert(),alert()\");\n   }\n \n   public void testUnusedPropAssign3() {\n-    test(\"var x = {}; x['foo'] = {}; x['foo'].baz['bar'] = 3\",\n-        \"\\\"foo\\\",{};\\\"foo\\\",(\\\"bar\\\",3)\");\n+    test(\"var x = {}; x['foo'] = {}; x['foo'].baz['bar'] = 3\", \"\");\n+  }\n+\n+  public void testUnusedPropAssign3b() {\n+    test(\"var x = {}; x[alert()] = alert(); x[alert()].baz[alert()] = alert()\",\n+         \"alert(),alert();alert(),(alert(),alert())\");\n   }\n \n   public void testUnusedPropAssign4() {\n-    test(\"var x = {foo: 3}; x['foo'] = 5;\", \"\\\"foo\\\",5\");\n+    test(\"var x = {foo: 3}; x['foo'] = 5;\", \"\");\n   }\n \n   public void testUnusedPropAssign5() {\n-    // Because bar() has a side-effect, the whole variable stays in. We might\n-    // be able to improve on this case.\n     test(\"var x = {foo: bar()}; x['foo'] = 5;\",\n          \"var x={foo:bar()};x[\\\"foo\\\"]=5\");\n   }\n \n   public void testUnusedPropAssign6() {\n-    test(\"var x = function() {}; x.prototype.bar = function() {};\",\n-         \"(function(){})\");\n+    test(\"var x = function() {}; x.prototype.bar = function() {};\", \"\");\n+  }\n+\n+  public void testUnusedPropAssign7() {\n+    test(\"var x = {}; x[x.foo] = x.bar;\", \"\");\n+  }\n+\n+  public void testUnusedPropAssign7b() {\n+    testSame(\"var x = {}; x[x.foo] = alert(x.bar);\");\n+  }\n+\n+  public void testUnusedPropAssign7c() {\n+    test(\"var x = {}; x[alert(x.foo)] = x.bar;\",\n+         \"var x={};x[alert(x.foo)]=x.bar\");\n   }\n \n   public void testUsedPropAssign1() {\n     test(\"var x = newNodeInDom(doc); x.innerHTML = 'new text';\",\n          \"var x=newNodeInDom(doc);x.innerHTML=\\\"new text\\\"\");\n   }\n+\n+  public void testDependencies1() {\n+    test(\"var a = 3; var b = function() { alert(a); };\", \"\");\n+  }\n+\n+  public void testDependencies1b() {\n+    test(\"var a = 3; var b = alert(function() { alert(a); });\",\n+         \"var a=3;alert(function(){alert(a)})\");\n+  }\n+\n+  public void testDependencies1c() {\n+    test(\"var a = 3; var _b = function() { alert(a); };\",\n+         \"var a=3;var _b=function(){alert(a)}\");\n+  }\n+\n+  public void testDependencies2() {\n+    test(\"var a = 3; var b = 3; b = function() { alert(a); };\", \"\");\n+  }\n+\n+  public void testDependencies2b() {\n+    test(\"var a = 3; var b = 3; b = alert(function() { alert(a); });\",\n+         \"var a=3;alert(function(){alert(a)})\");\n+  }\n+\n+  public void testDependencies2c() {\n+    testSame(\"var a=3;var _b=3;_b=function(){alert(a)}\");\n+  }\n+\n+  public void testGlobalVarReferencesLocalVar() {\n+    testSame(\"var a=3;function f(){var b=4;a=b}alert(a + f())\");\n+  }\n+\n+  public void testLocalVarReferencesGlobalVar1() {\n+    testSame(\"var a=3;function f(b, c){b=a; alert(b + c);} f();\");\n+  }\n+\n+  public void testLocalVarReferencesGlobalVar2() {\n+    test(\"var a=3;function f(b, c){b=a; alert(c);} f();\",\n+         \"function f(b, c) { alert(c); } f();\");\n+  }\n+\n+  public void testNestedAssign1() {\n+    test(\"var b = null; var a = (b = 3); alert(a);\",\n+         \"var a = 3; alert(a);\");\n+  }\n+\n+  public void testNestedAssign2() {\n+    test(\"var a = 1; var b = 2; var c = (b = a); alert(c);\",\n+         \"var a = 1; var c = a; alert(c);\");\n+  }\n+\n+  public void testNestedAssign3() {\n+    test(\"var b = 0; var z; z = z = b = 1; alert(b);\",\n+         \"var b = 0; b = 1; alert(b);\");\n+  }\n }", "timestamp": 1280969285, "metainfo": ""}