{"sha": "e414f154d5c4dae483f251ebeb2d9ef598aaa0f6", "log": "It doesn't make sense for a subclass method to require arguments that aren't required by the superclass method.  fixes issue 634  R=acleung DELTA=149  (93 added, 16 deleted, 40 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4184   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n \n import java.text.MessageFormat;\n import java.util.Iterator;\n     for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n       if (implemented.getImplicitPrototype() != null) {\n         for (String prop :\n-            implemented.getImplicitPrototype().getOwnPropertyNames()) {\n+             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n           expectInterfaceProperty(t, n, instance, implemented, prop);\n         }\n       }\n    */\n   private void expectInterfaceProperty(NodeTraversal t, Node n,\n       ObjectType instance, ObjectType implementedInterface, String prop) {\n-    if (!instance.hasProperty(prop)) {\n+    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n+    if (propSlot == null) {\n       // Not implemented\n       String sourceName = n.getSourceFileName();\n       sourceName = sourceName == null ? \"\" : sourceName;\n           INTERFACE_METHOD_NOT_IMPLEMENTED,\n           prop, implementedInterface.toString(), instance.toString())));\n     } else {\n-      JSType found = instance.getPropertyType(prop);\n+      Node propNode = propSlot.getDeclaration() == null ?\n+          null : propSlot.getDeclaration().getNode();\n+\n+      // Fall back on the constructor node if we can't find a node for the\n+      // property.\n+      propNode = propNode == null ? n : propNode;\n+\n+      JSType found = propSlot.getType();\n       JSType required\n-        = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n+          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n       found = found.restrictByNotNullOrUndefined();\n       required = required.restrictByNotNullOrUndefined();\n       if (!found.canAssignTo(required)) {\n         // Implemented, but not correctly typed\n-        FunctionType constructor\n-          = implementedInterface.toObjectType().getConstructor();\n-        registerMismatch(found, required, report(t.makeError(n,\n+        FunctionType constructor =\n+            implementedInterface.toObjectType().getConstructor();\n+        registerMismatch(found, required, report(t.makeError(propNode,\n             HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n             constructor.getTopMostDefiningType(prop).toString(),\n             required.toString(), found.toString())));\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n \n     ArrowType that = (ArrowType) other;\n \n+    // This is described in Draft 2 of the ES4 spec,\n+    // Section 3.4.7: Subtyping Function Types.\n+\n     // this.returnType <: that.returnType (covariant)\n     if (!this.returnType.isSubtype(that.returnType)) {\n       return false;\n     }\n+\n     // that.paramType[i] <: this.paramType[i] (contravariant)\n-    // TODO(nicksantos): This is incorrect. It should be invariant.\n-    // Follow up with closure team on how to fix this without everyone\n-    // hating on us.\n+    //\n+    // If this.paramType[i] is required,\n+    // then that.paramType[i] is required.\n+    //\n+    // In theory, the \"required-ness\" should work in the other direction as\n+    // well. In other words, if we have\n+    //\n+    // function f(number, number) {}\n+    // function g(number) {}\n+    //\n+    // Then f *should* not be a subtype of g, and g *should* not be\n+    // a subtype of f. But in practice, we do not implement it this way.\n+    // We want to support the use case where you can pass g where f is\n+    // expected, and pretend that g ignores the second argument.\n+    // That way, you can have a single \"no-op\" function, and you don't have\n+    // to create a new no-op function for every possible type signature.\n+    //\n+    // So, in this case, g < f, but f !< g\n     Node thisParam = parameters.getFirstChild();\n     Node thatParam = that.parameters.getFirstChild();\n     while (thisParam != null && thatParam != null) {\n       JSType thisParamType = thisParam.getJSType();\n+      JSType thatParamType = thatParam.getJSType();\n       if (thisParamType != null) {\n-        JSType thatParamType = thatParam.getJSType();\n         if (thatParamType == null ||\n             !thatParamType.isSubtype(thisParamType)) {\n           return false;\n         }\n       }\n+\n       boolean thisIsVarArgs = thisParam.isVarArgs();\n       boolean thatIsVarArgs = thatParam.isVarArgs();\n+      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n+      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n+\n+      // \"that\" can't be a supertype, because it's missing a required argument.\n+      if (!thisIsOptional && thatIsOptional) {\n+        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n+        // {function(...NoType)} to to indicate that arity should not be\n+        // checked. Strictly speaking, this is not a correct formulation,\n+        // because now a sub-function can required arguments that are var_args\n+        // in the super-function. So we special-case this.\n+        boolean isTopFunction =\n+            thatIsVarArgs &&\n+            (thatParamType == null ||\n+             thatParamType.isUnknownType() ||\n+             thatParamType.isNoType());\n+        if (!isTopFunction) {\n+          return false;\n+        }\n+      }\n+\n       // don't advance if we have variable arguments\n       if (!thisIsVarArgs) {\n         thisParam = thisParam.getNext();\n       if (!thatIsVarArgs) {\n         thatParam = thatParam.getNext();\n       }\n+\n       // both var_args indicates the end\n       if (thisIsVarArgs && thatIsVarArgs) {\n         thisParam = null;\n       }\n     }\n \n-    // Right now, the parser's type system doesn't have a good way\n-    // to model optional arguments.\n-    //\n-    // Suppose we have\n-    // function f(number, number) {}\n-    // function g(number) {}\n-    // If the second arg of f is optional, then f is a subtype of g,\n-    // but g is not a subtype of f.\n-    // If the second arg of f is required, then g is a subtype of f,\n-    // but f is not a subtype of g.\n-    //\n-    // Until we model optional params, let's just punt on this.\n-    // If one type has more arguments than the other, we won't check them.\n-    //\n-    // NOTE(nicksantos): This is described in Draft 2 of the ES4 spec,\n-    // Section 3.4.6: Subtyping Function Types. It seems really\n-    // strange but I haven't thought a lot about the implementation.\n+    // \"that\" can't be a supertype, because it's missing a required arguement.\n+    if (thisParam != null\n+        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n+        && thatParam == null) {\n+      return false;\n+    }\n+\n     return true;\n   }\n \n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"F.prototype.foo = function() { };\" +\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n-        \"/** @override */ G.prototype.foo = function(x, y) { };\" +\n-        \"(new G()).foo();\",\n-        \"Function G.prototype.foo: called with 0 argument(s). \" +\n-        \"Function requires at least 2 argument(s) \" +\n-        \"and no more than 2 argument(s).\");\n+        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n+        \"mismatch of the foo property type and the type of the property \" +\n+        \"it overrides from superclass F\\n\" +\n+        \"original: function (this:F): undefined\\n\" +\n+        \"override: function (this:G, ?, ?): undefined\");\n   }\n \n   public void testMethodInference8() throws Exception {\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n         \"/** @override */ \" +\n-        \"G.prototype.foo = function(a, opt_b, var_args) { };\" +\n-        \"(new G()).foo();\",\n-        \"Function G.prototype.foo: called with 0 argument(s). \" +\n-        \"Function requires at least 1 argument(s).\");\n+        \"G.prototype.foo = function(opt_b, var_args) { };\" +\n+        \"(new G()).foo(1, 2, 3);\");\n   }\n \n   public void testMethodInference9() throws Exception {\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n         \"/** @override */ \" +\n-        \"G.prototype.foo = function(a, var_args, opt_b) { };\",\n+        \"G.prototype.foo = function(var_args, opt_b) { };\",\n         \"variable length argument must be last\");\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"F.prototype.foo = function() { };\" +\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n-        \"/** @override */ G.prototype.foo = function(x, y) { };\" +\n-        \"(new G()).foo();\",\n-        \"Function G.prototype.foo: called with 0 argument(s). \" +\n-        \"Function requires at least 2 argument(s) \" +\n-        \"and no more than 2 argument(s).\");\n+        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n+        \"mismatch of the foo property type and the type of the property \" +\n+        \"it overrides from superclass F\\n\" +\n+        \"original: function (this:F): undefined\\n\" +\n+        \"override: function (this:G, ?, ?): undefined\");\n   }\n \n   public void testMethodInference8() throws Exception {\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n         \"/** @override */ \" +\n-        \"G.prototype.foo = function(a, opt_b, var_args) { };\" +\n-        \"(new G()).foo();\",\n-        \"Function G.prototype.foo: called with 0 argument(s). \" +\n-        \"Function requires at least 1 argument(s).\");\n+        \"G.prototype.foo = function(opt_b, var_args) { };\" +\n+        \"(new G()).foo(1, 2, 3);\");\n   }\n \n   public void testMethodInference9() throws Exception {\n         \"/** @constructor \\n * @extends {F} */ \" +\n         \"function G() {}\" +\n         \"/** @override */ \" +\n-        \"G.prototype.foo = function(a, var_args, opt_b) { };\",\n+        \"G.prototype.foo = function(var_args, opt_b) { };\",\n         \"variable length argument must be last\");\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n         .withReturnType(BOOLEAN_TYPE).build();\n \n     assertLeastSupertype(\n-        \"Function\", twoNumbers, oneNumber);\n-    assertGreatestSubtype(\n-        \"function (...[*]): None\", twoNumbers, oneNumber);\n+        \"function (number, number): boolean\", twoNumbers, oneNumber);\n+    assertGreatestSubtype(\n+        \"function (number): boolean\", twoNumbers, oneNumber);\n   }\n \n   public void testSubtypeWithInterfaceThisType() {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         .withParamsNode(registry.createParameters())\n         .withTypeOfThis(DATE_TYPE).build();\n     FunctionType dateMethodWithParam = new FunctionBuilder(registry)\n-        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withParamsNode(registry.createOptionalParameters(NUMBER_TYPE))\n         .withTypeOfThis(DATE_TYPE).build();\n     FunctionType dateMethodWithReturn = new FunctionBuilder(registry)\n         .withReturnType(NUMBER_TYPE)\n         .withParamsNode(registry.createParameters())\n         .withTypeOfThis(STRING_OBJECT_TYPE).build();\n     FunctionType stringMethodWithParam = new FunctionBuilder(registry)\n-        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withParamsNode(registry.createOptionalParameters(NUMBER_TYPE))\n         .withTypeOfThis(STRING_OBJECT_TYPE).build();\n     FunctionType stringMethodWithReturn = new FunctionBuilder(registry)\n         .withReturnType(NUMBER_TYPE)\n \n   public void testSubtypingFunctionFixedArgsNotMatching() throws Exception {\n     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n-        false, EVAL_ERROR_TYPE);\n+        false, EVAL_ERROR_TYPE, UNKNOWN_TYPE);\n     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n         false, ERROR_TYPE, ALL_TYPE);\n ", "timestamp": 1328639847, "metainfo": ""}