{"sha": "11e74627a0d7b25f96993f17b13c0c6b69c4da68", "log": "Add better \"bind\" inference. Fixes issue 621  R=johnlenz DELTA=168  (133 added, 33 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4043   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       if (functionType.isFunctionType()) {\n         FunctionType fnType = functionType.toMaybeFunctionType();\n         n.setJSType(fnType.getReturnType());\n-        updateTypeOfParameters(n, fnType);\n-        updateTypeOfThisOnClosure(n, fnType);\n+        backwardsInferenceFromCallSite(n, fnType);\n       } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n         n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n       }\n       redeclareSimpleVar(scope, node, narrowed);\n     }\n     return scope;\n+  }\n+\n+  /**\n+   * We only do forward type inference. We do not do full backwards\n+   * type inference.\n+   *\n+   * In other words, if we have,\n+   * <code>\n+   * var x = f();\n+   * g(x);\n+   * </code>\n+   * a forward type-inference engine would try to figure out the type\n+   * of \"x\" from the return type of \"f\". A backwards type-inference engine\n+   * would try to figure out the type of \"x\" from the parameter type of \"g\".\n+   *\n+   * However, there are a few special syntactic forms where we do some\n+   * some half-assed backwards type-inference, because programmers\n+   * expect it in this day and age. To take an example from java,\n+   * <code>\n+   * List<String> x = Lists.newArrayList();\n+   * </code>\n+   * The Java compiler will be able to infer the generic type of the List\n+   * returned by newArrayList().\n+   *\n+   * In much the same way, we do some special-case backwards inference for\n+   * JS. Those cases are enumerated here.\n+   */\n+  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n+    updateTypeOfParameters(n, fnType);\n+    updateTypeOfThisOnClosure(n, fnType);\n+    updateBind(n, fnType);\n+  }\n+\n+  /**\n+   * When \"bind\" is called on a function, we infer the type of the returned\n+   * \"bound\" function by looking at the number of parameters in the call site.\n+   */\n+  private void updateBind(Node n, FunctionType fnType) {\n+    // TODO(nicksantos): Use the coding convention, so that we get goog.bind\n+    // for free.\n+    Node calledFn = n.getFirstChild();\n+    boolean looksLikeBind = calledFn.isGetProp()\n+        && calledFn.getLastChild().getString().equals(\"bind\");\n+    if (!looksLikeBind) {\n+      return;\n+    }\n+\n+    Node callTarget = calledFn.getFirstChild();\n+    FunctionType callTargetFn = getJSType(callTarget)\n+        .restrictByNotNullOrUndefined().toMaybeFunctionType();\n+    if (callTargetFn == null) {\n+      return;\n+    }\n+\n+    n.setJSType(callTargetFn.getBindReturnType(n.getChildCount() - 1));\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n       boolean isCall = \"call\".equals(name);\n       boolean isBind = \"bind\".equals(name);\n       if (isCall || isBind) {\n-        // Notice that \"call\" and \"bind\" have the same argument signature,\n-        // except that all the arguments of \"bind\" (except the first)\n-        // are optional.\n-        FunctionBuilder builder = new FunctionBuilder(registry)\n-            .withReturnType(\n-                isCall ?\n-                getReturnType() :\n-                (new FunctionBuilder(registry)\n-                    .withReturnType(getReturnType()).build()));\n-\n-        Node origParams = getParametersNode();\n-        if (origParams != null) {\n-          Node params = origParams.cloneTree();\n-\n-          Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n-          thisTypeNode.setJSType(\n-              registry.createOptionalNullableType(getTypeOfThis()));\n-          params.addChildToFront(thisTypeNode);\n-          thisTypeNode.setOptionalArg(isCall);\n-\n-          if (isBind) {\n-            // The arguments of bind() are unique in that they are all\n-            // optional but not undefinable.\n-            for (Node current = thisTypeNode.getNext();\n-                 current != null; current = current.getNext()) {\n-              current.setOptionalArg(true);\n-            }\n-          }\n-\n-          builder.withParamsNode(params);\n-        }\n-\n-        defineDeclaredProperty(name, builder.build(), source);\n+        defineDeclaredProperty(name, getCallOrBindSignature(isCall), source);\n       } else if (\"apply\".equals(name)) {\n         // Define the \"apply\" function lazily.\n         FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n     }\n \n     return super.getPropertyType(name);\n+  }\n+\n+  /**\n+   * Get the return value of calling \"bind\" on this function\n+   * with the specified number of arguments.\n+   *\n+   * If -1 is passed, then we will return a result that accepts\n+   * any parameters.\n+   */\n+  public FunctionType getBindReturnType(int argsToBind) {\n+    FunctionBuilder builder = new FunctionBuilder(registry)\n+        .withReturnType(getReturnType());\n+    if (argsToBind >= 0) {\n+      Node origParams = getParametersNode();\n+      if (origParams != null) {\n+        Node params = origParams.cloneTree();\n+        for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) {\n+          params.removeFirstChild();\n+        }\n+        builder.withParamsNode(params);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Notice that \"call\" and \"bind\" have the same argument signature,\n+   * except that all the arguments of \"bind\" (except the first)\n+   * are optional.\n+   */\n+  private FunctionType getCallOrBindSignature(boolean isCall) {\n+    boolean isBind = !isCall;\n+    FunctionBuilder builder = new FunctionBuilder(registry)\n+        .withReturnType(isCall ? getReturnType() : getBindReturnType(-1));\n+\n+    Node origParams = getParametersNode();\n+    if (origParams != null) {\n+      Node params = origParams.cloneTree();\n+\n+      Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n+      thisTypeNode.setJSType(\n+          registry.createOptionalNullableType(getTypeOfThis()));\n+      params.addChildToFront(thisTypeNode);\n+      thisTypeNode.setOptionalArg(isCall);\n+\n+      if (isBind) {\n+        // The arguments of bind() are unique in that they are all\n+        // optional but not undefinable.\n+        for (Node current = thisTypeNode.getNext();\n+             current != null; current = current.getNext()) {\n+          current.setOptionalArg(true);\n+        }\n+      }\n+\n+      builder.withParamsNode(params);\n+    }\n+\n+    return builder.build();\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : boolean\\n\" +\n         \"required: number\");\n+  }\n+\n+  public void testFunctionBind3() throws Exception {\n+    testTypes(\n+        \"/** @type {function(number, string): boolean} */\" +\n+        \"function f(x, y) { return true; }\" +\n+        \"f.bind(null, 3)(true);\",\n+        \"actual parameter 1 of function does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGoogBind1() throws Exception {\n+    // We currently do not support goog.bind natively.\n+    testClosureTypes(\n+        \"var goog = {}; goog.bind = function(var_args) {};\" +\n+        \"/** @type {function(number): boolean} */\" +\n+        \"function f(x, y) { return true; }\" +\n+        \"f(goog.bind(f, null, 'x')());\",\n+        null);\n   }\n \n   public void testCast2() throws Exception {", "timestamp": 1325720387, "metainfo": ""}