{"sha": "abfa7124bf45ae1ad45a6aa65710e483132d4e59", "log": "Register \".constructor\" in the right place  R=acleung DELTA=117  (105 added, 3 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3592   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       FunctionType childCtor, SubclassType type) {\n     if (type == SubclassType.INHERITS) {\n       childCtor.defineDeclaredProperty(\"superClass_\",\n-          parentCtor.getPrototype(), parentCtor.getSource());\n+          parentCtor.getPrototype(), childCtor.getSource());\n       childCtor.getPrototype().defineDeclaredProperty(\"constructor\",\n-          childCtor, parentCtor.getSource());\n+          childCtor, childCtor.getSource());\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.logging.Logger;\n import java.util.TreeSet;\n \n import javax.annotation.Nullable;\n  */\n public final class SymbolTable\n     implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n+  private static final Logger logger =\n+      Logger.getLogger(SymbolTable.class.getName());\n+\n   /**\n    * The name we use for the JavaScript built-in Global object.  It's\n    * anonymous in JavaScript, so we have to give it an invalid identifier\n       String name, JSType type, boolean inferred, SymbolScope scope,\n       Node declNode) {\n     Symbol symbol = new Symbol(name, type, inferred, scope);\n-    symbols.put(declNode, name, symbol);\n-\n-    Symbol replacedSymbol = scope.ownSymbols.put(name, symbol);\n+    Symbol replacedSymbol = symbols.put(declNode, name, symbol);\n+    Preconditions.checkState(replacedSymbol == null);\n+\n+    replacedSymbol = scope.ownSymbols.put(name, symbol);\n     Preconditions.checkState(replacedSymbol == null);\n     return symbol;\n   }\n   void fillPropertyScopes() {\n     // Collect all object symbols.\n     List<Symbol> types = Lists.newArrayList();\n+\n+    // Create a property scope for each named type and each anonymous object,\n+    // and populate it with that object's properties.\n+    //\n+    // We notably don't want to create a property scope for 'x' in\n+    // var x = new Foo();\n+    // where x is just an instance of another type.\n     for (Symbol sym : getAllSymbols()) {\n-      JSType type = sym.getType();\n-      ObjectType dereferenced = type == null ? null : type.dereference();\n-      if (dereferenced != null) {\n+      ObjectType type = ObjectType.cast(sym.getType());\n+      if (type != null &&\n+          (type.getReferenceName() == null ||\n+           sym.getName().equals(type.getReferenceName()))) {\n         types.add(sym);\n       }\n     }\n \n-    // Create a property scope for each symbol, and populate\n-    // it with that symbol's properties.\n-    //\n     // The order of operations here is significant.\n     //\n     // When we add properties to Foo, we'll remove Foo.prototype from\n       // to build a complete index of all objects in the program. So we might\n       // already have symbols for things like \"Foo.bar\". If this happens,\n       // throw out the old symbol and use the type-based symbol.\n-      Symbol oldProp = getScope(s).getSlot(s.getName() + \".\" + propName);\n+      Symbol oldProp = symbols.get(newProp.getDeclaration().getNode(),\n+          s.getName() + \".\" + propName);\n       if (oldProp != null) {\n         removeSymbol(oldProp);\n+      }\n+\n+      // If we've already have an entry in the table for this symbol,\n+      // then skip it. This should only happen if we screwed up,\n+      // and declared multiple distinct properties with the same name\n+      // at the same node. We bail out here to be safe.\n+      if (symbols.get(newProp.getDeclaration().getNode(),\n+              newProp.getName()) != null) {\n+        logger.warning(\"Found duplicate symbol \" + newProp);\n+        continue;\n       }\n \n       Symbol newSym = copySymbolTo(newProp, s.propertyScope);\n \n     public int getScopeDepth() {\n       return scopeDepth;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      Node n = getRootNode();\n+      if (n != null) {\n+        return \"Scope@\" + n.getSourceFileName() + \":\" + n.getLineno();\n+      } else {\n+        return \"PropertyScope@\" + getSymbolForScope();\n+      }\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n+import com.google.javascript.jscomp.CodingConvention.SubclassType;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import junit.framework.TestCase;\n \n     assertNotRequire(\"foo()\");\n   }\n \n+  public void testApplySubclassRelationship() {\n+    JSTypeRegistry registry = new JSTypeRegistry(null);\n+\n+    Node nodeA = new Node(Token.FUNCTION);\n+    FunctionType ctorA = registry.createConstructorType(\"A\", nodeA,\n+        new Node(Token.LP), null);\n+\n+    Node nodeB = new Node(Token.FUNCTION);\n+    FunctionType ctorB = registry.createConstructorType(\"B\", nodeB,\n+        new Node(Token.LP), null);\n+\n+    conv.applySubclassRelationship(ctorA, ctorB, SubclassType.INHERITS);\n+\n+    assertTrue(ctorB.getPrototype().hasOwnProperty(\"constructor\"));\n+    assertEquals(nodeB, ctorB.getPrototype().getPropertyNode(\"constructor\"));\n+\n+    assertTrue(ctorB.hasOwnProperty(\"superClass_\"));\n+    assertEquals(nodeB, ctorB.getPropertyNode(\"superClass_\"));\n+  }\n+\n   private void assertFunctionBind(String code) {\n     Node n = parseTestCode(code);\n     assertNotNull(conv.describeFunctionBind(n.getFirstChild()));\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(5, refs.get(1).getNode().getLineno());\n   }\n \n+  public void testMultipleExtends() {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @const */ var goog = goog || {};\\n\" +\n+        \"goog.inherits = function(x, y) {};\\n\" +\n+        \"/** @constructor */\\n\" +\n+        \"goog.A = function() { this.fieldA = this.constructor; };\\n\" +\n+        \"/** @constructor */ goog.A.FooA = function() {};\\n\" +\n+        \"/** @return {void} */ goog.A.prototype.methodA = function() {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {goog.A}\\n\" +\n+        \" */\\n\" +\n+        \"goog.B = function() { this.fieldB = this.constructor; };\\n\" +\n+        \"goog.inherits(goog.B, goog.A);\\n\" +\n+        \"/** @return {void} */ goog.B.prototype.methodB = function() {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {goog.A}\\n\" +\n+        \" */\\n\" +\n+        \"goog.B2 = function() { this.fieldB = this.constructor; };\\n\" +\n+        \"goog.inherits(goog.B2, goog.A);\\n\" +\n+        \"/** @constructor */ goog.B2.FooB = function() {};\\n\" +\n+        \"/** @return {void} */ goog.B2.prototype.methodB = function() {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {goog.B}\\n\" +\n+        \" */\\n\" +\n+        \"goog.C = function() { this.fieldC = this.constructor; };\\n\" +\n+        \"goog.inherits(goog.C, goog.B);\\n\" +\n+        \"/** @constructor */ goog.C.FooC = function() {};\\n\" +\n+        \"/** @return {void} */ goog.C.prototype.methodC = function() {};\\n\");\n+\n+    Symbol bCtor = getGlobalVar(table, \"goog.B.prototype.constructor\");\n+    assertNotNull(bCtor);\n+\n+    List<Reference> bRefs = table.getReferenceList(bCtor);\n+    assertEquals(2, bRefs.size());\n+    assertEquals(11, bCtor.getDeclaration().getNode().getLineno());\n+\n+    Symbol cCtor = getGlobalVar(table, \"goog.C.prototype.constructor\");\n+    assertNotNull(cCtor);\n+\n+    List<Reference> cRefs = table.getReferenceList(cCtor);\n+    assertEquals(2, cRefs.size());\n+    assertEquals(26, cCtor.getDeclaration().getNode().getLineno());\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);\n     List<JSSourceFile> externs = Lists.newArrayList(\n         JSSourceFile.fromCode(\"externs1\", EXTERNS));\n     CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new ClosureCodingConvention());\n     CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n         options);\n     WarningLevel.VERBOSE.setOptionsForWarningLevel(options);", "timestamp": 1320099682, "metainfo": ""}