{"sha": "9dcaf037db4f82485a52421540f35565068c9766", "log": "Add an indexer for type references in jsdoc tags  R=jschorr DELTA=82  (75 added, 0 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3238   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     symbolTable.fillNamespaceReferences();\n     symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n     symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n+    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n \n     return symbolTable;\n   }\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.collect.Table;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n     (new PropertyRefCollector(compiler)).process(externs, root);\n   }\n \n+  /** Index JSDocInfo. */\n+  void fillJSDocInfo(\n+      AbstractCompiler compiler, Node externs, Node root) {\n+    NodeTraversal.traverseRoots(\n+        compiler, Lists.newArrayList(externs, root), new JSDocInfoCollector());\n+  }\n+\n   private void createPropertyScopeFor(Symbol s) {\n     // In order to build a property scope for s, we will need to build\n     // a property scope for all its implicit prototypes first. This means\n       }\n     }\n   }\n+\n+  /** Collects references to types in JSDocInfo. */\n+  private class JSDocInfoCollector\n+      extends NodeTraversal.AbstractPostOrderCallback {\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getJSDocInfo() != null) {\n+        // Find references in the JSDocInfo.\n+        JSDocInfo info = n.getJSDocInfo();\n+        for (Node typeAst : info.getTypeNodes()) {\n+          SymbolScope scope = scopes.get(t.getScopeRoot());\n+          visitTypeNode(scope == null ? globalScope : scope, typeAst);\n+        }\n+      }\n+    }\n+\n+    public void visitTypeNode(SymbolScope scope, Node n) {\n+      if (n.getType() == Token.STRING) {\n+        Symbol symbol = scope.getSlot(n.getString());\n+        if (symbol != null) {\n+          symbol.defineReferenceAt(n);\n+        }\n+      }\n+\n+      for (Node child = n.getFirstChild();\n+           child != null; child = child.getNext()) {\n+        visitTypeNode(scope, child);\n+      }\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n     }\n \n     String typeName = stream.getString();\n+    int lineno = stream.getLineno();\n+    int charno = stream.getCharno();\n     while (match(JsDocToken.EOL) &&\n         typeName.charAt(typeName.length() - 1) == '.') {\n       skipEOLs();\n       }\n     }\n \n-    Node typeNameNode = newStringNode(typeName);\n+    Node typeNameNode = newStringNode(typeName, lineno, charno);\n \n     if (match(JsDocToken.LT)) {\n       next();\n   }\n \n   private Node newStringNode(String s) {\n-    return Node.newString(s, stream.getLineno(),\n-        stream.getCharno()).clonePropsFrom(templateNode);\n+    return newStringNode(s, stream.getLineno(), stream.getCharno());\n+  }\n+\n+  private Node newStringNode(String s, int lineno, int charno) {\n+    return Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n   }\n \n   // This is similar to IRFactory.createTemplateNode to share common props\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(\"Foo.prototype\", refs.get(0).getNode().getQualifiedName());\n   }\n \n+  public void testReferencesInJSDoc() {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function Foo() {}\\n\" +\n+        \"/** @type {Foo} */ var x;\\n\" +\n+        \"/** @param {Foo} x */ function f(x) {}\\n\" +\n+        \"/** @return {function(): Foo} */ function g() {}\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function Sub() {}\");\n+    Symbol foo = getGlobalVar(table, \"Foo\");\n+    assertNotNull(foo);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(foo));\n+    assertEquals(5, refs.size());\n+\n+    assertEquals(1, refs.get(0).getNode().getLineno());\n+    assertEquals(29, refs.get(0).getNode().getCharno());\n+\n+    assertEquals(2, refs.get(1).getNode().getLineno());\n+    assertEquals(11, refs.get(1).getNode().getCharno());\n+\n+    assertEquals(3, refs.get(2).getNode().getLineno());\n+    assertEquals(12, refs.get(2).getNode().getCharno());\n+\n+    assertEquals(4, refs.get(3).getNode().getLineno());\n+    assertEquals(25, refs.get(3).getNode().getCharno());\n+\n+    assertEquals(7, refs.get(4).getNode().getLineno());\n+    assertEquals(13, refs.get(4).getNode().getCharno());\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     return table.getGlobalScope().getSlot(name);\n   }", "timestamp": 1315846903, "metainfo": ""}