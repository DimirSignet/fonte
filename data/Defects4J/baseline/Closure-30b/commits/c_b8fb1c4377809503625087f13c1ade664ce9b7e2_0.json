{"sha": "b8fb1c4377809503625087f13c1ade664ce9b7e2", "log": "Change on 2010/06/29 13:33:11 by nicksantos  \tBe more aggressive about pulling param/return types off the overridden \tmethod.  \tR=johnlenz \tDELTA=198  (149 added, 21 deleted, 28 changed)  Change on 2010/06/30 05:24:10 by nthomas  \tAdd ontouch{cancel,end,move,start} attribute declarations per the Safari Reference Library: \thttp://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html  \tR=acleung \tDELTA=28  (28 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=47001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    * Infer the parameter and return types of a function from\n    * the parameter and return types of the function it is overriding.\n    *\n-   * @param oldType The function being overridden.\n+   * @param oldType The function being overridden. Does nothing if this is null.\n    * @param paramsParent The LP node of the function that we're assigning to.\n    *     If null, that just means we're not initializing this to a function\n    *     literal.\n    */\n   FunctionTypeBuilder inferFromOverriddenFunction(\n-      FunctionType oldType, @Nullable Node paramsParent) {\n+      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n+    if (oldType == null) {\n+      return this;\n+    }\n+\n     returnType = oldType.getReturnType();\n+    returnTypeInferred = oldType.isReturnTypeInferred();\n     if (paramsParent == null) {\n       // Not a function literal.\n       parametersNode = oldType.getParametersNode();\n           new FunctionParamBuilder(typeRegistry);\n       Iterator<Node> oldParams = oldType.getParameters().iterator();\n       boolean warnedAboutArgList = false;\n+      boolean oldParamsNodeHasVarArgs = false;\n       for (Node currentParam = paramsParent.getFirstChild();\n            currentParam != null; currentParam = currentParam.getNext()) {\n         if (oldParams.hasNext()) {\n-          paramBuilder.newParameterFromNode(oldParams.next());\n+          Node oldParam = oldParams.next();\n+          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+\n+          // The subclass method might right its var_args as individual\n+          // arguments.\n+          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n+            newParam.setVarArgs(false);\n+            newParam.setOptionalArg(true);\n+            oldParamsNodeHasVarArgs = true;\n+          }\n         } else {\n           warnedAboutArgList |= addParameter(\n               paramBuilder,\n               typeRegistry.getNativeType(UNKNOWN_TYPE),\n               warnedAboutArgList,\n-              codingConvention.isOptionalParameter(currentParam),\n+              codingConvention.isOptionalParameter(currentParam) ||\n+                  oldParamsNodeHasVarArgs,\n               codingConvention.isVarArgsParameter(currentParam));\n         }\n       }\n    * Infer the return type from JSDocInfo.\n    */\n   FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n-    returnType = info != null && info.hasReturnType() ?\n-        info.getReturnType().evaluate(scope, typeRegistry) : null;\n+    if (info != null && info.hasReturnType()) {\n+      returnType = info.getReturnType().evaluate(scope, typeRegistry);\n+      returnTypeInferred = false;\n+    }\n+\n     if (templateTypeName != null &&\n         returnType != null &&\n         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n    * If we haven't found a return value yet, try to look at the \"return\"\n    * statements in the function.\n    */\n-  FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) {\n+  FunctionTypeBuilder inferReturnStatementsAsLastResort(\n+      @Nullable Node functionBlock) {\n     if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n       return this;\n     }\n     }\n \n     // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+      oldParameterType = parametersNode.getFirstChild();\n+    }\n+\n     FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n     boolean warnedAboutArgList = false;\n     Set<String> allJsDocParams = (info == null) ?\n       allJsDocParams.remove(argumentName);\n \n       // type from JSDocInfo\n-      JSType parameterType =\n-          info != null && info.hasParameterType(argumentName) ?\n-          info.getParameterType(argumentName).evaluate(scope, typeRegistry) :\n-          typeRegistry.getNativeType(UNKNOWN_TYPE);\n+      JSType parameterType = null;\n+      boolean isOptionalParam = isOptionalParameter(arg, info);\n+      boolean isVarArgs = isVarArgsParameter(arg, info);\n+      if (info != null && info.hasParameterType(argumentName)) {\n+        parameterType =\n+            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+      } else if (oldParameterType != null &&\n+          oldParameterType.getJSType() != null) {\n+        parameterType = oldParameterType.getJSType();\n+        isOptionalParam = oldParameterType.isOptionalArg();\n+        isVarArgs = oldParameterType.isVarArgs();\n+      } else {\n+        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+      }\n+\n       if (templateTypeName != null &&\n           parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n         if (foundTemplateType) {\n       }\n       warnedAboutArgList |= addParameter(\n           builder, parameterType, warnedAboutArgList,\n-          isOptionalParameter(arg, info),\n-          isVarArgsParameter(arg, info));\n+          isOptionalParam,\n+          isVarArgs);\n+\n+      if (oldParameterType != null) {\n+        oldParameterType = oldParameterType.getNext();\n+      }\n     }\n \n     if (templateTypeName != null && !foundTemplateType) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       }\n \n       if (functionType == null) {\n-        if (info == null ||\n-            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n-          // We don't really have any type information in the annotation.\n-          // Before we give up on this function, look at the object we're\n-          // assigning it to. For example, if the function looks like this:\n-          // SubFoo.prototype.bar = function() { ... };\n-          // We can use type information on Foo.prototype.bar and apply it\n-          // to this function.\n-          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n-              lvalueNode.isQualifiedName()) {\n-            Var var = scope.getVar(\n-                lvalueNode.getFirstChild().getQualifiedName());\n-            if (var != null) {\n-              ObjectType ownerType = ObjectType.cast(var.getType());\n-              FunctionType propType = null;\n-              if (ownerType != null) {\n-                String propName = lvalueNode.getLastChild().getString();\n-                propType = findOverriddenFunction(ownerType, propName);\n-              }\n-\n-              if (propType != null) {\n-                functionType =\n-                    new FunctionTypeBuilder(\n-                        name, compiler, errorRoot, sourceName, scope)\n-                    .setSourceNode(fnRoot)\n-                    .inferFromOverriddenFunction(propType, parametersNode)\n-                    .inferThisType(info, owner)\n-                    .inferReturnStatements(fnBlock)\n-                    .buildAndRegister();\n-              }\n+        // Find the type of any overridden function.\n+        FunctionType overriddenPropType = null;\n+        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n+            lvalueNode.isQualifiedName()) {\n+          Var var = scope.getVar(\n+              lvalueNode.getFirstChild().getQualifiedName());\n+          if (var != null) {\n+            ObjectType ownerType = ObjectType.cast(var.getType());\n+            if (ownerType != null) {\n+              String propName = lvalueNode.getLastChild().getString();\n+              overriddenPropType = findOverriddenFunction(ownerType, propName);\n             }\n           }\n         }\n-      } // end if (functionType == null)\n-\n-      if (functionType == null) {\n+\n         functionType =\n             new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                 scope)\n             .setSourceNode(fnRoot)\n+            .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n             .inferTemplateTypeName(info)\n             .inferReturnType(info)\n             .inferInheritance(info)\n             .inferThisType(info, owner)\n             .inferParameterTypes(parametersNode, info)\n-            .inferReturnStatements(fnBlock)\n+            .inferReturnStatementsAsLastResort(fnBlock)\n             .buildAndRegister();\n       }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n   /**\n    * Copies the parameter specification from the given node.\n    */\n-  public void newParameterFromNode(Node n) {\n+  public Node newParameterFromNode(Node n) {\n     Node newParam = newParameter(n.getJSType());\n     newParam.setVarArgs(n.isVarArgs());\n     newParam.setOptionalArg(n.isOptionalArg());\n+    return newParam;\n   }\n \n   // Add a parameter to the list with the given type.\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n *\n  */\n public class TypeCheckTest extends CompilerTypeTestCase {\n+\n+  private CheckLevel reportMissingOverrides = CheckLevel.WARNING;\n+\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    reportMissingOverrides = CheckLevel.WARNING;\n+  }\n+\n   public void testInitialTypingScope() {\n     Scope s = new TypedScopeCreator(compiler,\n         new DefaultCodingConvention()).createInitialScope(\n         \"required: undefined\");\n   }\n \n+  public void testInferredReturn8() throws Exception {\n+    reportMissingOverrides = CheckLevel.OFF;\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @param {number} x */ SubFoo.prototype.bar = \" +\n+        \"    function(x) { return 3; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: undefined\");\n+  }\n+\n   public void testInferredParam1() throws Exception {\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n+  }\n+\n+  public void testInferredParam2() throws Exception {\n+    reportMissingOverrides = CheckLevel.OFF;\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {void} */ SubFoo.prototype.bar = \" +\n+        \"    function(x) { f(x); }\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredParam3() throws Exception {\n+    reportMissingOverrides = CheckLevel.OFF;\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number=} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {void} */ SubFoo.prototype.bar = \" +\n+        \"    function(x) { f(x); }; (new SubFoo()).bar();\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredParam4() throws Exception {\n+    reportMissingOverrides = CheckLevel.OFF;\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {...number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {void} */ SubFoo.prototype.bar = \" +\n+        \"    function(x) { f(x); }; (new SubFoo()).bar();\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredParam5() throws Exception {\n+    reportMissingOverrides = CheckLevel.OFF;\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {...number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @param {number=} x \\n * @param {...number} y  */ \" +\n+        \"SubFoo.prototype.bar = \" +\n+        \"    function(x, y) { f(x); }; (new SubFoo()).bar();\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testOverriddenReturn1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @return {Object} */ Foo.prototype.bar = \" +\n+        \"    function() { return {}; };\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {SubFoo}\\n * @override */ SubFoo.prototype.bar = \" +\n+        \"    function() { return new Foo(); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : Foo\\n\" +\n+        \"required: (SubFoo|null)\");\n+  }\n+\n+  public void testOverriddenReturn2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @return {SubFoo} */ Foo.prototype.bar = \" +\n+        \"    function() { return new SubFoo(); };\" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {Foo} x\\n * @override */ SubFoo.prototype.bar = \" +\n+        \"    function() { return new SubFoo(); }\",\n+        \"mismatch of the bar property type and the type of the \" +\n+        \"property it overrides from superclass Foo\\n\" +\n+        \"original: function (this:Foo): (SubFoo|null)\\n\" +\n+        \"override: function (this:SubFoo): (Foo|null)\");\n   }\n \n   public void testThis1() throws Exception {\n         compiler,\n         new SemanticReverseAbstractInterpreter(\n             compiler.getCodingConvention(), registry),\n-        registry);\n+        registry,\n+        reportMissingOverrides,\n+        CheckLevel.OFF);\n   }\n \n   void testTypes(String js, String[] warnings) throws Exception {", "timestamp": 1277936921, "metainfo": ""}