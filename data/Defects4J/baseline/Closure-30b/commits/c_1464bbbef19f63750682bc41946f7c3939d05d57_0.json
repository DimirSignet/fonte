{"sha": "1464bbbef19f63750682bc41946f7c3939d05d57", "log": "New pattern for ExtractPrototypeMemberDeclarations  R=nicksantos DELTA=205  (164 added, 14 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3142   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n       new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new ExtractPrototypeMemberDeclarations(compiler);\n+      return new ExtractPrototypeMemberDeclarations(\n+          compiler, Pattern.USE_GLOBAL_TEMP);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n  * to be extracted must be in a single line. We call this a single\n  * {@link ExtractionInstance}.\n  *\n+ * <p>Alternatively, for users who do not want a global variable to be\n+ * introduced, we will create an anonymous function instead.\n+ * <pre>\n+ * function B() { ... }\n+ * (function (x) {\n+ *   x.foo = function() { ... }\n+ *   ...\n+ *   x.bar = function() { ... }\n+ * )(B.prototype)\n+ * </pre>\n+ *\n  * The RHS of the declarations can have side effects, however, one good way to\n  * break this is the following:\n  * <pre>\n  * </pre>\n  * Such logic is highly unlikely and we will assume that it never occurs.\n  *\n- *\n  */\n class ExtractPrototypeMemberDeclarations implements CompilerPass {\n-\n-  private static final int GLOBAL_VAR_DECL_OVERHEAD = \"var t;\".length();\n-\n-  // Every extraction instance must first use the temp variable to point to\n-  // the prototype object.\n-  private static final int PER_EXTRACTION_INSTANCE_OVERHEAD =\n-      \"t=y.prototype;\".length();\n-\n-  // The gain we get per prototype declaration. Assuming it can be aliased.\n-  private static final int PER_PROTOTYPE_MEMBER_DELTA =\n-      \"t.y=\".length() - \"x[p].y=\".length();\n \n   // The name of variable that will temporary hold the pointer to the prototype\n   // object. Of cause, we assume that it'll be renamed by RenameVars.\n \n   private final AbstractCompiler compiler;\n \n-  public ExtractPrototypeMemberDeclarations(AbstractCompiler compiler) {\n+  private final Pattern pattern;\n+\n+  enum Pattern {\n+    USE_GLOBAL_TEMP(\n+        // Global Overhead.\n+        // We need a temp variable to hold all the prototype.\n+        \"var t;\".length(),\n+        // Per Extract overhead:\n+        // Every extraction instance must first use the temp variable to point\n+        // to the prototype object.\n+        \"t=y.prototype;\".length(),\n+        // TODO(user): Check to to see if AliasExterns is on\n+        // The gain we get per prototype declaration. Assuming it can be\n+        // aliased.\n+        \"t.y=\".length() - \"x[p].y=\".length()),\n+\n+    USE_ANON_FUNCTION(\n+       // Global Overhead:\n+       0,\n+       // Per-extraction overhead:\n+       // This is the cost of a single anoynmous function.\n+       \"(function(t){})(y.prototype);\".length(),\n+       // Per-prototype member declaration overhead:\n+       // Here we assumes that they don't have AliasExterns on (in SIMPLE mode).\n+       \"t.y=\".length() - \"x.prototype.y=\".length());\n+\n+\n+    private final int globalOverhead;\n+    private final int perExtractionOverhead;\n+    private final int perMemberOverhead;\n+\n+    Pattern(int globalOverHead, int perExtractionOverhead, int perMemberOverhead) {\n+      this.globalOverhead = globalOverHead;\n+      this.perExtractionOverhead = perExtractionOverhead;\n+      this.perMemberOverhead = perMemberOverhead;\n+    }\n+  }\n+\n+  ExtractPrototypeMemberDeclarations(AbstractCompiler compiler, Pattern pattern) {\n     this.compiler = compiler;\n+    this.pattern = pattern;\n   }\n \n   @Override\n    * through all ExtractInstance and performs extraction there.\n    */\n   private void doExtraction(GatherExtractionInfo info) {\n-    // First declare the temp variable.\n-    Node injectionPoint = compiler.getNodeForCodeInsertion(null);\n-\n-    Node var = NodeUtil.newVarNode(prototypeAlias, null)\n-        .copyInformationFromForTree(injectionPoint);\n-\n-    injectionPoint.addChildrenToFront(var);\n-\n+\n+    // Insert a global temp if we are using the USE_GLOBAL_TEMP pattern.\n+    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n+      Node injectionPoint = compiler.getNodeForCodeInsertion(null);\n+\n+      Node var = NodeUtil.newVarNode(prototypeAlias, null)\n+          .copyInformationFromForTree(injectionPoint);\n+\n+      injectionPoint.addChildrenToFront(var);\n+    }\n     // Go through all extraction instances and extract each of them.\n     for (ExtractionInstance instance : info.instances) {\n       extractInstance(instance);\n    * instead.\n    */\n   private void extractInstance(ExtractionInstance instance) {\n-    // Use the temp variable to hold the prototype.\n     PrototypeMemberDeclaration first = instance.declarations.getFirst();\n     String className = first.qualifiedClassName;\n-    Node stmt = new Node(first.node.getType(),\n-        new Node(Token.ASSIGN,\n-            Node.newString(Token.NAME, prototypeAlias),\n-            NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), className + \".prototype\",\n-                instance.parent, className + \".prototype\")))\n-        .copyInformationFromForTree(first.node);\n-\n-    instance.parent.addChildBefore(stmt, first.node);\n-\n+    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n+      // Use the temp variable to hold the prototype.\n+      Node stmt = new Node(first.node.getType(),\n+          new Node(Token.ASSIGN,\n+              Node.newString(Token.NAME, prototypeAlias),\n+              NodeUtil.newQualifiedNameNode(\n+                  compiler.getCodingConvention(), className + \".prototype\",\n+                  instance.parent, className + \".prototype\")))\n+          .copyInformationFromForTree(first.node);\n+\n+      instance.parent.addChildBefore(stmt, first.node);\n+    } else if (pattern == Pattern.USE_ANON_FUNCTION){\n+      Node block = new Node(Token.BLOCK);\n+      Node func = new Node(Token.FUNCTION,\n+           Node.newString(Token.NAME, \"\"),\n+           new Node(Token.LP, Node.newString(Token.NAME, prototypeAlias)),\n+           block);\n+\n+      Node call = new Node(Token.CALL,func,\n+           NodeUtil.newQualifiedNameNode(\n+               compiler.getCodingConvention(), className + \".prototype\",\n+               instance.parent, className + \".prototype\"));\n+      call.putIntProp(Node.FREE_CALL, 1);\n+\n+      Node stmt = new Node(first.node.getType(), call);\n+      stmt.copyInformationFromForTree(first.node);\n+      instance.parent.addChildBefore(stmt, first.node);\n+      for (PrototypeMemberDeclaration declar : instance.declarations) {\n+        block.addChildToBack(declar.node.detachFromParent());\n+      }\n+    }\n     // Go thought each member declaration and replace it with an assignment\n     // to the prototype variable.\n     for (PrototypeMemberDeclaration declar : instance.declarations) {\n   private class GatherExtractionInfo extends AbstractShallowCallback {\n \n     private List<ExtractionInstance> instances = Lists.newLinkedList();\n-    private int totalDelta = GLOBAL_VAR_DECL_OVERHEAD;\n+    private int totalDelta = pattern.globalOverhead;\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n     }\n   }\n \n-  private static class ExtractionInstance {\n+  private class ExtractionInstance {\n     LinkedList<PrototypeMemberDeclaration> declarations = Lists.newLinkedList();\n     private int delta = 0;\n     private final Node parent;\n     private ExtractionInstance(PrototypeMemberDeclaration head, Node parent) {\n       this.parent = parent;\n       declarations.add(head);\n-      delta = PER_EXTRACTION_INSTANCE_OVERHEAD + PER_PROTOTYPE_MEMBER_DELTA;\n+      delta = pattern.perExtractionOverhead + pattern.perMemberOverhead;\n \n       for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {\n \n           break;\n         }\n         declarations.add(prototypeMember);\n-        delta += PER_PROTOTYPE_MEMBER_DELTA;\n+        delta += pattern.perMemberOverhead;\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;\n+\n /**\n  * Tests for {@link ExtractPrototypeMemberDeclarations}.\n  *\n  */\n public class ExtractPrototypeMemberDeclarationsTest extends CompilerTestCase {\n   private static final String TMP = \"JSCompiler_prototypeAlias\";\n+  private Pattern pattern = Pattern.USE_GLOBAL_TEMP;\n \n   @Override\n   protected void setUp() {\n     super.enableLineNumberCheck(true);\n     enableNormalize();\n+    pattern = Pattern.USE_GLOBAL_TEMP;\n   }\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new ExtractPrototypeMemberDeclarations(compiler);\n+    return new ExtractPrototypeMemberDeclarations(compiler, pattern);\n   }\n \n   public void testNotEnoughPrototypeToExtract() {\n         TMP + \".g = 1;\");\n   }\n \n+  public void testAnonSimple() {\n+    pattern = Pattern.USE_ANON_FUNCTION;\n+\n+    extract(\n+        generatePrototypeDeclarations(\"x\", 3),\n+        generateExtractedDeclarations(3) +\n+        loadPrototype(\"x\"));\n+\n+    testSame(generatePrototypeDeclarations(\"x\", 1));\n+    testSame(generatePrototypeDeclarations(\"x\", 2));\n+\n+    extract(\n+        generatePrototypeDeclarations(\"x\", 7),\n+        generateExtractedDeclarations(7) +\n+        loadPrototype(\"x\"));\n+\n+  }\n+\n+  public void testAnonWithDevirtualization() {\n+    pattern = Pattern.USE_ANON_FUNCTION;\n+\n+    extract(\n+        \"x.prototype.a = 1;\" +\n+        \"x.prototype.b = 1;\" +\n+        \"function devirtualize() { }\" +\n+        \"x.prototype.c = 1;\",\n+\n+        \"(function(\" + TMP + \"){\" +\n+        TMP + \".a = 1;\" +\n+        TMP + \".b = 1;\" +\n+        TMP + \".c = 1;\" +\n+        loadPrototype(\"x\") +\n+        \"function devirtualize() { }\");\n+\n+    extract(\n+        \"x.prototype.a = 1;\" +\n+        \"function devirtualize1() { }\" +\n+        \"x.prototype.b = 1;\" +\n+        \"function devirtualize2() { }\" +\n+        \"x.prototype.c = 1;\" +\n+        \"function devirtualize3() { }\",\n+\n+        \"(function(\" + TMP + \"){\" +\n+        TMP + \".a = 1;\" +\n+        TMP + \".b = 1;\" +\n+        TMP + \".c = 1;\" +\n+        loadPrototype(\"x\") +\n+        \"function devirtualize1() { }\" +\n+        \"function devirtualize2() { }\" +\n+        \"function devirtualize3() { }\");\n+  }\n+\n+  public void testAnonWithSideFx() {\n+    pattern = Pattern.USE_ANON_FUNCTION;\n+    testSame(\n+        \"function foo() {};\" +\n+        \"foo.prototype.a1 = 1;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a2 = 2;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a3 = 3;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a4 = 4;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a5 = 5;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a6 = 6;\" +\n+        \"bar();;\" +\n+        \"foo.prototype.a7 = 7;\" +\n+        \"bar();\");\n+  }\n+\n   public String loadPrototype(String qName) {\n-    return TMP + \" = \" + qName + \".prototype;\";\n+    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n+      return TMP + \" = \" + qName + \".prototype;\";\n+    } else {\n+      return \"})(\" + qName + \".prototype);\";\n+    }\n   }\n \n   public void extract(String src, String expected) {\n-    test(src, \"var \" + TMP + \";\" + expected);\n+    if (pattern == Pattern.USE_GLOBAL_TEMP) {\n+      test(src, \"var \" + TMP + \";\" + expected);\n+    } else {\n+      test(src, expected);\n+    }\n   }\n \n   public String generatePrototypeDeclarations(String className, int num) {\n \n   public String generateExtractedDeclarations(int num) {\n     StringBuilder builder = new StringBuilder();\n+\n+    if (pattern == Pattern.USE_ANON_FUNCTION) {\n+      builder.append(\"(function(\" + TMP + \"){\");\n+    }\n+\n     for (int i = 0; i < num; i++) {\n       char member = (char) ('a' + i);\n       builder.append(generateExtractedDeclaration(\"\" + member,  \"\" + member));", "timestamp": 1314315133, "metainfo": ""}