{"sha": "e8eafe7acfd53e5385e4f31692c4db67c3777185", "log": "Refactor typedscopecreator a bit to make it easier to see what's going on. basically, i removed a level of dynamic dispatch. there should be no functional changes in this cl.  R=johnlenz DELTA=228  (89 added, 62 deleted, 77 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=54005   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     }\n \n     /**\n-     * Defines variable(s) or modifies types based on the content of the node\n-     * {@code n}. A variable definition creates variables in the current scope,\n-     * a function definition creates a binding, and an assignment updates the\n-     * type of the namespaces on which the definition is made (e.g.\n-     * {@code goog.FOO = 6}).\n-     * @param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n-     *     {@link Token#ASSIGN} node\n-     * @param parent {@code n}'s parent\n-     */\n-    void define(Node n, Node parent) {\n+     * Asserts that it's ok to define this node's name.\n+     * The node should have a source name and be of the specified type.\n+     */\n+    void assertDefinitionNode(Node n, int type) {\n       Preconditions.checkState(sourceName != null);\n-\n+      Preconditions.checkState(n.getType() == type);\n+    }\n+\n+    /**\n+     * Defines a catch parameter.\n+     */\n+    void defineCatch(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.CATCH);\n+      Node catchName = n.getFirstChild();\n+      defineSlot(catchName, n, null);\n+    }\n+\n+    /**\n+     * Defines a VAR initialization.\n+     */\n+    void defineVar(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.VAR);\n       JSDocInfo info = n.getJSDocInfo();\n-      switch (n.getType()) {\n-        case Token.CATCH:\n-          Node catchName = n.getFirstChild();\n-          defineSlot(catchName, n, null);\n-          break;\n-\n-        case Token.VAR:\n-          if (n.hasMoreThanOneChild()) {\n-            if (info != null) {\n-              // multiple children\n-              compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n-            }\n-            for (Node name : n.children()) {\n-              defineName(name, n, parent, name.getJSDocInfo());\n-            }\n-          } else {\n-            Node name = n.getFirstChild();\n-            defineName(name, n, parent,\n-                (info != null) ? info : name.getJSDocInfo());\n-          }\n-          break;\n-\n-        case Token.FUNCTION:\n-          int parentType = parent.getType();\n-          Preconditions.checkState(\n-              (scope.isLocal() || parentType != Token.ASSIGN) &&\n-              parentType != Token.NAME,\n-              \"function defined as standalone function when it is being \" +\n-              \"assigned\");\n-          String functionName = n.getFirstChild().getString();\n-          FunctionType functionType = getFunctionType(functionName, n, info,\n-              null);\n-          if (NodeUtil.isFunctionDeclaration(n)) {\n-            defineSlot(n.getFirstChild(), n, functionType);\n-          }\n-          break;\n-\n-        case Token.ASSIGN:\n-          // TODO(nicksantos): We should support direct assignment to a\n-          // prototype, as in:\n-          // Foo.prototype = {\n-          //   a: function() { ... },\n-          //   b: function() { ... }\n-          // };\n-          // Right now (6/23/08), we understand most of this syntax, but we\n-          // don't tie the \"a\" and \"b\" methods to the context of Foo.\n-\n-          Node rvalue = n.getLastChild();\n-          Node lvalue = n.getFirstChild();\n-          info = (info != null) ? info : rvalue.getJSDocInfo();\n-          if (rvalue.getType() == Token.FUNCTION ||\n-              info != null && info.isConstructor()) {\n-            getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n-                lvalue);\n-          } else if (info != null && info.hasEnumParameterType()) {\n-            JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n-                info.getEnumParameterType().evaluate(scope, typeRegistry));\n-            if (type != null) {\n-              setDeferredType(lvalue, type);\n-            }\n-          }\n-          break;\n-\n-        default:\n-          throw new IllegalStateException(Integer.toString(n.getType()));\n+      if (n.hasMoreThanOneChild()) {\n+        if (info != null) {\n+          // multiple children\n+          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+        }\n+        for (Node name : n.children()) {\n+          defineName(name, n, parent, name.getJSDocInfo());\n+        }\n+      } else {\n+        Node name = n.getFirstChild();\n+        defineName(name, n, parent,\n+            (info != null) ? info : name.getJSDocInfo());\n+      }\n+    }\n+\n+    /**\n+     * Defines a declared function.\n+     */\n+    void defineDeclaredFunction(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.FUNCTION);\n+\n+      JSDocInfo info = n.getJSDocInfo();\n+      int parentType = parent.getType();\n+      Preconditions.checkState(\n+          (scope.isLocal() || parentType != Token.ASSIGN) &&\n+          parentType != Token.NAME,\n+          \"function defined as standalone function when it is being \" +\n+          \"assigned\");\n+      String functionName = n.getFirstChild().getString();\n+      FunctionType functionType = getFunctionType(functionName, n, info,\n+          null);\n+      if (NodeUtil.isFunctionDeclaration(n)) {\n+        defineSlot(n.getFirstChild(), n, functionType);\n+      }\n+    }\n+\n+    /**\n+     * Defines a qualified name assign to an enum or constructor.\n+     */\n+    void defineNamedTypeAssign(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.ASSIGN);\n+      JSDocInfo info = n.getJSDocInfo();\n+\n+      // TODO(nicksantos): We should support direct assignment to a\n+      // prototype, as in:\n+      // Foo.prototype = {\n+      //   a: function() { ... },\n+      //   b: function() { ... }\n+      // };\n+      // Right now (6/23/08), we understand most of this syntax, but we\n+      // don't tie the \"a\" and \"b\" methods to the context of Foo.\n+\n+      Node rvalue = n.getLastChild();\n+      Node lvalue = n.getFirstChild();\n+      info = (info != null) ? info : rvalue.getJSDocInfo();\n+      if (rvalue.getType() == Token.FUNCTION ||\n+          info != null && info.isConstructor()) {\n+        getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n+            lvalue);\n+      } else if (info != null && info.hasEnumParameterType()) {\n+        JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n+            info.getEnumParameterType().evaluate(scope, typeRegistry));\n+        if (type != null) {\n+          setDeferredType(lvalue, type);\n+        }\n       }\n     }\n \n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.CALL:\n-          SubclassRelationship relationship =\n-              codingConvention.getClassesDefinedByCall(n);\n-          if (relationship != null) {\n-            ObjectType superClass = ObjectType.cast(\n-                typeRegistry.getType(relationship.superclassName));\n-            ObjectType subClass = ObjectType.cast(\n-                typeRegistry.getType(relationship.subclassName));\n-            if (superClass != null && subClass != null) {\n-              FunctionType superCtor = superClass.getConstructor();\n-              FunctionType subCtor = subClass.getConstructor();\n-\n-              if (relationship.type == SubclassType.INHERITS) {\n-                validator.expectSuperType(t, n, superClass, subClass);\n-              }\n-\n-              if (superCtor != null && subCtor != null) {\n-                codingConvention.applySubclassRelationship(\n-                    superCtor, subCtor, relationship.type);\n-              }\n-            }\n-          }\n-\n-          String singletonGetterClassName =\n-              codingConvention.getSingletonGetterClassName(n);\n-          if (singletonGetterClassName != null) {\n-            ObjectType objectType = ObjectType.cast(\n-                typeRegistry.getType(singletonGetterClassName));\n-            if (objectType != null) {\n-              FunctionType functionType = objectType.getConstructor();\n-\n-              if (functionType != null) {\n-                FunctionType getterType =\n-                    typeRegistry.createFunctionType(objectType);\n-                codingConvention.applySingletonGetter(functionType, getterType,\n-                                                      objectType);\n-              }\n-            }\n-          }\n-\n-          DelegateRelationship delegateRelationship =\n-              codingConvention.getDelegateRelationship(n);\n-          if (delegateRelationship != null) {\n-            applyDelegateRelationship(delegateRelationship);\n-          }\n-\n-          ObjectLiteralCast objectLiteralCast =\n-              codingConvention.getObjectLiteralCast(t, n);\n-          if (objectLiteralCast != null) {\n-            ObjectType type = ObjectType.cast(\n-                typeRegistry.getType(objectLiteralCast.typeName));\n-            if (type != null && type.getConstructor() != null) {\n-              setDeferredType(objectLiteralCast.objectNode, type);\n-            } else {\n-              compiler.report(JSError.make(t.getSourceName(), n,\n-                                           CONSTRUCTOR_EXPECTED));\n-            }\n-          }\n+          checkForClassDefiningCalls(t, n, parent);\n           break;\n \n         case Token.FUNCTION:\n               parent.getType() == Token.NAME) {\n             return;\n           }\n-          define(n, parent);\n+\n+          defineDeclaredFunction(n, parent);\n           break;\n \n         case Token.ASSIGN:\n           // Handle constructor and enum definitions.\n-          define(n, parent);\n+          defineNamedTypeAssign(n, parent);\n \n           // Handle typedefs.\n           checkForOldStyleTypedef(t, n);\n           break;\n \n         case Token.CATCH:\n-          define(n, parent);\n+          defineCatch(n, parent);\n           break;\n \n         case Token.VAR:\n-          define(n, parent);\n+          defineVar(n, parent);\n \n           // Handle typedefs.\n           if (n.hasOneChild()) {\n       }\n     }\n \n+    /**\n+     * Look for class-defining calls.\n+     * Because JS has no 'native' syntax for defining classes,\n+     * this is often very coding-convention dependent and business-logic heavy.\n+     */\n+    private void checkForClassDefiningCalls(\n+        NodeTraversal t, Node n, Node parent) {\n+      SubclassRelationship relationship =\n+          codingConvention.getClassesDefinedByCall(n);\n+      if (relationship != null) {\n+        ObjectType superClass = ObjectType.cast(\n+            typeRegistry.getType(relationship.superclassName));\n+        ObjectType subClass = ObjectType.cast(\n+            typeRegistry.getType(relationship.subclassName));\n+        if (superClass != null && subClass != null) {\n+          FunctionType superCtor = superClass.getConstructor();\n+          FunctionType subCtor = subClass.getConstructor();\n+\n+          if (relationship.type == SubclassType.INHERITS) {\n+            validator.expectSuperType(t, n, superClass, subClass);\n+          }\n+\n+          if (superCtor != null && subCtor != null) {\n+            codingConvention.applySubclassRelationship(\n+                superCtor, subCtor, relationship.type);\n+          }\n+        }\n+      }\n+\n+      String singletonGetterClassName =\n+          codingConvention.getSingletonGetterClassName(n);\n+      if (singletonGetterClassName != null) {\n+        ObjectType objectType = ObjectType.cast(\n+            typeRegistry.getType(singletonGetterClassName));\n+        if (objectType != null) {\n+          FunctionType functionType = objectType.getConstructor();\n+\n+          if (functionType != null) {\n+            FunctionType getterType =\n+                typeRegistry.createFunctionType(objectType);\n+            codingConvention.applySingletonGetter(functionType, getterType,\n+                objectType);\n+          }\n+        }\n+      }\n+\n+      DelegateRelationship delegateRelationship =\n+          codingConvention.getDelegateRelationship(n);\n+      if (delegateRelationship != null) {\n+        applyDelegateRelationship(delegateRelationship);\n+      }\n+\n+      ObjectLiteralCast objectLiteralCast =\n+          codingConvention.getObjectLiteralCast(t, n);\n+      if (objectLiteralCast != null) {\n+        ObjectType type = ObjectType.cast(\n+            typeRegistry.getType(objectLiteralCast.typeName));\n+        if (type != null && type.getConstructor() != null) {\n+          setDeferredType(objectLiteralCast.objectNode, type);\n+        } else {\n+          compiler.report(JSError.make(t.getSourceName(), n,\n+                  CONSTRUCTOR_EXPECTED));\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Apply special properties that only apply to delegates.\n+     */\n     private void applyDelegateRelationship(\n         DelegateRelationship delegateRelationship) {\n       ObjectType delegatorObject = ObjectType.cast(\n           if (parent.getType() == Token.NAME) {\n             return;\n           }\n-          define(n, parent);\n+          defineDeclaredFunction(n, parent);\n           break;\n \n         case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+\n         case Token.VAR:\n-          define(n, parent);\n+          defineVar(n, parent);\n           break;\n       }\n     }", "timestamp": 1279585800, "metainfo": ""}