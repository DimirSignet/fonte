{"sha": "9614c7c0ffe2418359fe91be2a0e61400142237d", "log": "remove some special-case code for enums now that we handle object literals properly, we can just use the normal checks  R=acleung DELTA=137  (46 added, 26 deleted, 65 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3459   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         return;\n       }\n \n-      // /** @enum ... */object.name = ...;\n-      if (info != null && info.hasEnumParameterType()) {\n-        checkEnumInitializer(\n-            t, rvalue, info.getEnumParameterType().evaluate(\n-                t.getScope(), typeRegistry));\n-        return;\n-      }\n+      checkEnumAlias(t, info, rvalue);\n \n       // object.prototype = ...;\n       if (property.equals(\"prototype\")) {\n     // Validate value is assignable to the key type.\n \n     JSType keyType = getJSType(key);\n+\n+    JSType allowedValueType = keyType;\n+    if (allowedValueType.isEnumElementType()) {\n+      allowedValueType =\n+          allowedValueType.toMaybeEnumElementType().getPrimitiveType();\n+    }\n+\n     boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n-        rightType, keyType,\n+        rightType, allowedValueType,\n         owner, NodeUtil.getObjectLitKeyName(key));\n     if (valid) {\n       ensureTyped(t, key, rightType);\n         if (info == null) {\n           info = varInfo;\n         }\n-        if (info != null && info.hasEnumParameterType()) {\n-          // var.getType() can never be null, this would indicate a bug in the\n-          // scope creation logic.\n-          checkEnumInitializer(\n-              t, value,\n-              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n-        } else if (var.isTypeInferred()) {\n+\n+        checkEnumAlias(t, info, value);\n+        if (var.isTypeInferred()) {\n           ensureTyped(t, name, valueType);\n         } else {\n           validator.expectCanAssignTo(\n     ensureTyped(t, n);\n   }\n \n-  /**\n-   * <p>Checks the initializer of an enum. An enum can be initialized with an\n-   * object literal whose values must be subtypes of the declared enum element\n-   * type, or by copying another enum.</p>\n-   *\n-   * <p>In the case of an enum copy, we verify that the enum element type of the\n-   * enum used for initialization is a subtype of the enum element type of\n+\n+  /**\n+   * <p>Checks enum aliases.\n+   *\n+   * <p>We verify that the enum element type of the enum used\n+   * for initialization is a subtype of the enum element type of\n    * the enum the value is being copied in.</p>\n    *\n-   * <p>Examples:</p>\n-   * <pre>var myEnum = {FOO: ..., BAR: ...};\n-   * var myEnum = myOtherEnum;</pre>\n+   * <p>Example:</p>\n+   * <pre>var myEnum = myOtherEnum;</pre>\n+   *\n+   * <p>Enum aliases are irregular, so we need special code for this :(</p>\n    *\n    * @param value the value used for initialization of the enum\n    * @param primitiveType The type of each element of the enum.\n    */\n-  private void checkEnumInitializer(\n-      NodeTraversal t, Node value, JSType primitiveType) {\n-    if (value.getType() == Token.OBJECTLIT) {\n-      for (Node key = value.getFirstChild();\n-           key != null; key = key.getNext()) {\n-        Node propValue = key.getFirstChild();\n-\n-        // the value's type must be assignable to the enum's primitive type\n-        validator.expectCanAssignTo(\n-            t, propValue, getJSType(propValue), primitiveType,\n-            \"element type must match enum's type\");\n-      }\n-    } else if (value.getJSType() instanceof EnumType) {\n-      // TODO(user): Remove the instanceof check in favor\n-      // of a type.isEnumType() predicate. Currently, not all enum types are\n-      // implemented by the EnumClass, e.g. the unknown type and the any\n-      // type. The types need to be defined by interfaces such that an\n-      // implementation can implement multiple types interface.\n-      EnumType valueEnumType = (EnumType) value.getJSType();\n-      JSType valueEnumPrimitiveType =\n-          valueEnumType.getElementsType().getPrimitiveType();\n-      validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n-          primitiveType, \"incompatible enum element types\");\n-    } else {\n-      // The error condition is handled in TypedScopeCreator.\n-    }\n+  private void checkEnumAlias(\n+      NodeTraversal t, JSDocInfo declInfo, Node value) {\n+    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n+      return;\n+    }\n+\n+    JSType valueType = getJSType(value);\n+    if (!valueType.isEnumType()) {\n+      return;\n+    }\n+\n+    EnumType valueEnumType = valueType.toMaybeEnumType();\n+    JSType valueEnumPrimitiveType =\n+        valueEnumType.getElementsType().getPrimitiveType();\n+    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n+        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n+        \"incompatible enum element types\");\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n package com.google.javascript.jscomp;\n \n-import static com.google.javascript.jscomp.TypeCheck.ENUM_DUP;\n import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;\n import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;\n       setDeferredType(objectLit, type);\n \n       // If this is an enum, the properties were already taken care of above.\n-      if (!createdEnumType) {\n-        processObjectLitProperties(\n-            t, objectLit, ObjectType.cast(objectLit.getJSType()));\n-      }\n+      processObjectLitProperties(\n+          t, objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);\n     }\n \n     /**\n      * @param objLit The OBJECTLIT node.\n      * @param objLitType The type of the OBJECTLIT node. This might be a named\n      *     type, because of the lends annotation.\n+     * @param declareOnOwner If true, declare properties on the objLitType as\n+     *     well. If false, the caller should take crae of this.\n      */\n     void processObjectLitProperties(\n-        NodeTraversal t, Node objLit, ObjectType objLitType) {\n+        NodeTraversal t, Node objLit, ObjectType objLitType,\n+        boolean declareOnOwner) {\n       for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n            keyNode = keyNode.getNext()) {\n         Node value = keyNode.getFirstChild();\n         String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n         JSDocInfo info = keyNode.getJSDocInfo();\n-        JSType valueType = getDeclaredType(\n-            t.getSourceName(), info, keyNode, value);\n-        JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(\n-            keyNode, valueType);\n+        JSType valueType =\n+            getDeclaredType(t.getSourceName(), info, keyNode, value);\n+        JSType keyType =  objLitType.isEnumType() ?\n+            objLitType.toMaybeEnumType().getElementsType() :\n+            NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);\n         if (keyType != null) {\n           // Try to declare this property in the current scope if it\n           // has an authoritative name.\n             setDeferredType(keyNode, keyType);\n           }\n \n-          if (objLitType != null) {\n+          if (objLitType != null && declareOnOwner) {\n             // Declare this property on its object literal.\n             boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            objLitType.defineDeclaredProperty(\n-                memberName, keyType, keyNode);\n+            objLitType.defineDeclaredProperty(memberName, keyType, keyNode);\n           }\n         }\n       }\n               // GET and SET don't have a String value;\n               compiler.report(\n                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n-            } else if (enumType.hasOwnProperty(keyName)) {\n-              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n             } else if (!codingConvention.isValidEnumKey(keyName)) {\n               compiler.report(\n                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n   }\n \n   @Override\n-  public boolean isEnumType() {\n-    return true;\n+  public EnumType toMaybeEnumType() {\n+    return this;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   public boolean isEnumType() {\n-    return false;\n+    return toMaybeEnumType() != null;\n+  }\n+\n+  /**\n+   * Downcasts this to an EnumType, or returns null if this is not an EnumType.\n+   */\n+  public EnumType toMaybeEnumType() {\n+    return null;\n   }\n \n   boolean isNamedType() {\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean isEnumType() {\n-    return referencedType.isEnumType();\n+  public EnumType toMaybeEnumType() {\n+    return referencedType.toMaybeEnumType();\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testEnum3() throws Exception {\n     testTypes(\"/**@enum*/var a={BB:1,BB:2}\",\n-        \"enum element BB already defined\", true);\n+        \"variable a.BB redefined with type a.<number>, \" +\n+        \"original definition at [testcode]:1 with type a.<number>\");\n   }\n \n   public void testEnum4() throws Exception {\n     testTypes(\"/**@enum*/var a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: number\");\n   }\n \n   public void testEnum5() throws Exception {\n     testTypes(\"/**@enum {String}*/var a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: (String|null|undefined)\");\n   }\n   }\n \n   public void testEnum8() throws Exception {\n-    testTypes(\"/** @enum */var a=8;\",\n-        \"enum initializer must be an object literal or an enum\");\n+    testClosureTypesMultipleWarnings(\"/** @enum */var a=8;\",\n+        Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n+            \"initializing variable\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: enum{a}\"));\n   }\n \n   public void testEnum9() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = {};\" +\n         \"/** @enum */goog.a=8;\",\n-        \"enum initializer must be an object literal or an enum\");\n+        Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n+            \"assignment to property a of goog\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: enum{goog.a}\"));\n   }\n \n   public void testEnum10() throws Exception {\n \n   public void testEnum16() throws Exception {\n     testTypes(\"var goog = {};\" +\n-        \"/**@enum*/goog.a={BB:1,BB:2}\",\n-        \"enum element BB already defined\", true);\n+        \"/**@enum*/goog .a={BB:1,BB:2}\",\n+        \"variable goog.a.BB redefined with type goog.a.<number>, \" +\n+        \"original definition at [testcode]:1 with type goog.a.<number>\");\n   }\n \n   public void testEnum17() throws Exception {\n     testTypes(\"var goog = {};\" +\n         \"/**@enum*/goog.a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{goog.a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: number\");\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testEnum3() throws Exception {\n     testTypes(\"/**@enum*/var a={BB:1,BB:2}\",\n-        \"enum element BB already defined\", true);\n+        \"variable a.BB redefined with type a.<number>, \" +\n+        \"original definition at [testcode]:1 with type a.<number>\");\n   }\n \n   public void testEnum4() throws Exception {\n     testTypes(\"/**@enum*/var a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: number\");\n   }\n \n   public void testEnum5() throws Exception {\n     testTypes(\"/**@enum {String}*/var a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: (String|null)\");\n   }\n   }\n \n   public void testEnum8() throws Exception {\n-    testTypes(\"/** @enum */var a=8;\",\n-        \"enum initializer must be an object literal or an enum\");\n+    testClosureTypesMultipleWarnings(\"/** @enum */var a=8;\",\n+        Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n+            \"initializing variable\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: enum{a}\"));\n   }\n \n   public void testEnum9() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         \"var goog = {};\" +\n         \"/** @enum */goog.a=8;\",\n-        \"enum initializer must be an object literal or an enum\");\n+        Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n+            \"assignment to property a of goog\\n\" +\n+            \"found   : number\\n\" +\n+            \"required: enum{goog.a}\"));\n   }\n \n   public void testEnum10() throws Exception {\n \n   public void testEnum16() throws Exception {\n     testTypes(\"var goog = {};\" +\n-        \"/**@enum*/goog.a={BB:1,BB:2}\",\n-        \"enum element BB already defined\", true);\n+        \"/**@enum*/goog .a={BB:1,BB:2}\",\n+        \"variable goog.a.BB redefined with type goog.a.<number>, \" +\n+        \"original definition at [testcode]:1 with type goog.a.<number>\");\n   }\n \n   public void testEnum17() throws Exception {\n     testTypes(\"var goog = {};\" +\n         \"/**@enum*/goog.a={BB:'string'}\",\n-        \"element type must match enum's type\\n\" +\n+        \"assignment to property BB of enum{goog.a}\\n\" +\n         \"found   : string\\n\" +\n         \"required: number\");\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertTrue(f instanceof EnumType);\n   }\n \n+  public void testEnumElement() {\n+    testSame(\"/** @enum */ var Foo = {BAR: 1}; var f = Foo;\");\n+    Var bar = globalScope.getVar(\"Foo.BAR\");\n+    assertNotNull(bar);\n+    assertEquals(\"Foo.<number>\", bar.getType().toString());\n+  }\n+\n   public void testNamespacedEnum() {\n     testSame(\"var goog = {}; goog.ui = {};\" +\n         \"/** @constructor */goog.ui.Zippy = function() {};\" +", "timestamp": 1318475260, "metainfo": ""}