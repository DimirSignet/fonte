{"sha": "3937d82f6670e5a30b2809b13cb6d05a7e606037", "log": "Add PeriodType.forFields to get a PeriodType for any set of fields   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/PeriodType.java\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n package org.joda.time;\n \n import java.io.Serializable;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import org.joda.time.field.FieldUtils;\n \n     /** Serialization version */\n     private static final long serialVersionUID = 2274324892792009998L;\n \n+    /** Cache of all the known types. */\n+    private static final Map cTypes = new HashMap(32);\n+\n     static int YEAR_INDEX = 0;\n     static int MONTH_INDEX = 1;\n     static int WEEK_INDEX = 2;\n         return type;\n     }\n \n+    /**\n+     * Gets a period type that contains the duration types of the array.\n+     * <p>\n+     * Only the 8 standard duration field types are supported.\n+     *\n+     * @param types  the types to include in the array.\n+     * @return the period type\n+     */\n+    public static synchronized PeriodType forFields(DurationFieldType[] types) {\n+        if (types == null || types.length == 0) {\n+            throw new IllegalArgumentException(\"Types array must not be null or empty\");\n+        }\n+        for (int i = 0; i < types.length; i++) {\n+            if (types[i] == null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null\");\n+            }\n+        }\n+        Map cache = cTypes;\n+        if (cTypes.isEmpty()) {\n+            cache.put(standard(), standard());\n+            cache.put(yearMonthDayTime(), yearMonthDayTime());\n+            cache.put(yearMonthDay(), yearMonthDay());\n+            cache.put(yearWeekDayTime(), yearWeekDayTime());\n+            cache.put(yearWeekDay(), yearWeekDay());\n+            cache.put(yearDayTime(), yearDayTime());\n+            cache.put(yearDay(), yearDay());\n+            cache.put(dayTime(), dayTime());\n+            cache.put(time(), time());\n+            cache.put(years(), years());\n+            cache.put(months(), months());\n+            cache.put(weeks(), weeks());\n+            cache.put(days(), days());\n+            cache.put(hours(), hours());\n+            cache.put(minutes(), minutes());\n+            cache.put(seconds(), seconds());\n+            cache.put(millis(), millis());\n+        }\n+        PeriodType inPartType = new PeriodType(null, types, null);\n+        Object cached = cache.get(inPartType);\n+        if (cached instanceof PeriodType) {\n+            return (PeriodType) cached;\n+        }\n+        if (cached != null) {\n+            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\n+        }\n+        PeriodType type = standard();\n+        List list = new ArrayList(Arrays.asList(types));\n+        if (list.remove(DurationFieldType.years()) == false) {\n+            type = type.withYearsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.months()) == false) {\n+            type = type.withMonthsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.weeks()) == false) {\n+            type = type.withWeeksRemoved();\n+        }\n+        if (list.remove(DurationFieldType.days()) == false) {\n+            type = type.withDaysRemoved();\n+        }\n+        if (list.remove(DurationFieldType.hours()) == false) {\n+            type = type.withHoursRemoved();\n+        }\n+        if (list.remove(DurationFieldType.minutes()) == false) {\n+            type = type.withMinutesRemoved();\n+        }\n+        if (list.remove(DurationFieldType.seconds()) == false) {\n+            type = type.withSecondsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.millis()) == false) {\n+            type = type.withMillisRemoved();\n+        }\n+        if (list.size() > 0) {\n+            cache.put(inPartType, list);\n+            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\n+        }\n+        // recheck cache in case initial array order was wrong\n+        PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n+        PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n+        if (checkedType != null) {\n+            cache.put(inPartType, checkedType);\n+            return checkedType;\n+        }\n+        cache.put(inPartType, type);\n+        return type;\n+    }\n+\n     //-----------------------------------------------------------------------    \n     /** The name of the type */\n     private final String iName;\n--- a/JodaTime/src/test/org/joda/time/TestPeriodType.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriodType.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testForFields1() throws Exception {\n+        PeriodType type = PeriodType.forFields(new DurationFieldType[] {\n+            DurationFieldType.years(),\n+        });\n+        assertSame(PeriodType.years(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+            DurationFieldType.months(),\n+        });\n+        assertSame(PeriodType.months(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.weeks(),\n+        });\n+        assertSame(PeriodType.weeks(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.days(),\n+        });\n+        assertSame(PeriodType.days(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.hours(),\n+        });\n+        assertSame(PeriodType.hours(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.minutes(),\n+        });\n+        assertSame(PeriodType.minutes(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.seconds(),\n+        });\n+        assertSame(PeriodType.seconds(), type);\n+        type = PeriodType.forFields(new DurationFieldType[] {\n+                DurationFieldType.millis(),\n+        });\n+        assertSame(PeriodType.millis(), type);\n+    }\n+\n+    public void testForFields2() throws Exception {\n+        DurationFieldType[] types = new DurationFieldType[] {\n+            DurationFieldType.years(),\n+            DurationFieldType.hours(),\n+        };\n+        PeriodType type = PeriodType.forFields(types);\n+        assertEquals(2, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(1));\n+        assertEquals(\"StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.forFields(types));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    public void testForFields3() throws Exception {\n+        DurationFieldType[] types = new DurationFieldType[] {\n+            DurationFieldType.months(),\n+            DurationFieldType.weeks(),\n+        };\n+        PeriodType type = PeriodType.forFields(types);\n+        assertEquals(2, type.size());\n+        assertEquals(DurationFieldType.months(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n+        assertEquals(\"StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.forFields(types));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    public void testForFields4() throws Exception {\n+        DurationFieldType[] types = new DurationFieldType[] {\n+            DurationFieldType.weeks(),\n+            DurationFieldType.months(),\n+        };\n+        DurationFieldType[] types2 = new DurationFieldType[] {\n+            DurationFieldType.months(),\n+            DurationFieldType.weeks(),\n+        };\n+        PeriodType type = PeriodType.forFields(types);\n+        PeriodType type2 = PeriodType.forFields(types2);\n+        assertEquals(true, type == type2);\n+    }\n+\n+    public void testForFields5() throws Exception {\n+        DurationFieldType[] types = new DurationFieldType[] {\n+            DurationFieldType.centuries(),\n+            DurationFieldType.months(),\n+        };\n+        try {\n+            PeriodType.forFields(types);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            PeriodType.forFields(types);  // repeated for test coverage of cache\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testForFields6() throws Exception {\n+        DurationFieldType[] types = null;\n+        try {\n+            PeriodType.forFields(types);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        types = new DurationFieldType[0];\n+        try {\n+            PeriodType.forFields(types);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        types = new DurationFieldType[] {\n+            null,\n+            DurationFieldType.months(),\n+        };\n+        try {\n+            PeriodType.forFields(types);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        types = new DurationFieldType[] {\n+            DurationFieldType.months(),\n+            null,\n+        };\n+        try {\n+            PeriodType.forFields(types);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testMaskYears() throws Exception {\n         PeriodType type = PeriodType.standard().withYearsRemoved();\n         assertEquals(7, type.size());", "timestamp": 1120603654, "metainfo": ""}