{"sha": "05a0afda69655047df95847d378e46e6b99749cb", "log": "Merge pull request #84 from petedmarsh/add-millis-description  Add a seperate description for fraction of second presentation", "commit": "\n--- a/src/main/java/org/joda/time/format/DateTimeFormat.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java\n  * k       clockhour of day (1~24)      number        24\n  * m       minute of hour               number        30\n  * s       second of minute             number        55\n- * S       fraction of second           number        978\n+ * S       fraction of second           millis        978\n  *\n  * z       time zone                    text          Pacific Standard Time; PST\n  * Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles\n  * digits.\n  * <p>\n  * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n+ * <p>\n+ * <strong>Millis</strong>: The exact number of fractional digits. If more\n+ * millisecond digits are available then specified the number will be\n+ * truncated, if there are fewer than specified then the number will be\n+ * zero-padded to the right. When parsing, only the eact number of digits\n+ * are accepted.\n  * <p>\n  * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs\n  * the offset with a colon, 'ZZZ' or more outputs the zone id.\n--- a/src/example/org/joda/example/time/TimeZoneTable.java\n+++ b/src/example/org/joda/example/time/TimeZoneTable.java\n                     \"</tr>\");\n \n         ZoneData canonical = null;\n-        List aliases = new ArrayList();\n+        List<ZoneData> aliases = new ArrayList<ZoneData>();\n \n         for (int i=0; i<zones.length; i++) {\n             ZoneData zone = zones[i];\n--- a/src/main/java/org/joda/time/DateTimeComparator.java\n+++ b/src/main/java/org/joda/time/DateTimeComparator.java\n     /**\n      * Returns a DateTimeComparator with a lower limit only. Fields of a\n      * magnitude less than the lower limit are excluded from comparisons.\n+     * <p>\n+     * The time-zone is considered when using this comparator.\n+     * The input millis are truncated using the time-zone of that input value.\n+     * Thus, two inputs with different time-zones will typically not be equal\n      *\n      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n      * @return a comparator over all fields above the lower limit\n      * Fields of a magnitude greater than or equal to the upper limit are also\n      * excluded from comparisons. Either limit may be specified as null, which\n      * indicates an unbounded limit.\n+     * <p>\n+     * The time-zone is considered when using this comparator unless both limits are null.\n+     * The input millis are rounded/truncated using the time-zone of that input value.\n+     * Thus, two inputs with different time-zones will typically not be equal\n      *\n      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n      * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n     /**\n      * Returns a comparator that only considers date fields.\n      * Time of day is ignored.\n+     * <p>\n+     * The time-zone is considered when using this comparator.\n+     * The input millis are rounded down to the start of the day\n+     * in the time-zone of that input value. Thus, two inputs with\n+     * different time-zones will typically not be equal\n      * \n      * @return a comparator over all date fields\n      */\n     /**\n      * Returns a comparator that only considers time fields.\n      * Date is ignored.\n+     * <p>\n+     * The time-zone is considered when using this comparator.\n+     * The input millis are truncated to be within the day\n+     * in the time-zone of that input value. Thus, two inputs with\n+     * different time-zones will typically not be equal\n      * \n      * @return a comparator over all time fields\n      */\n--- a/src/main/java/org/joda/time/DateTimeUtils.java\n+++ b/src/main/java/org/joda/time/DateTimeUtils.java\n /**\n  * DateTimeUtils provide public utility methods for the date-time library.\n  * <p>\n- * DateTimeUtils is thread-safe although shared static variables are used.\n+ * DateTimeUtils uses shared static variables which are declared as volatile\n+ * for thread-safety. These can be changed during the lifetime of the application\n+ * however doing so is generally a bad idea.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n--- a/src/main/java/org/joda/time/Duration.java\n+++ b/src/main/java/org/joda/time/Duration.java\n         return withDurationAdded(amount.getMillis(), -1);\n     }\n \n+    /**\n+     * Returns a new duration with this length multiplied by the \n+     * specified multiplicand.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the multiplicand is one, this instance is returned.\n+     * \n+     * @param multiplicand  the multiplicand to multiply this one by\n+     * @return the new duration instance\n+     */\n+    public Duration multipliedBy(long multiplicand) {\n+        if (multiplicand == 1) {\n+            return this;\n+        }\n+        return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));\n+    }\n+\n+    /**\n+     * Returns a new duration with this length divided by the \n+     * specified divisor.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the divisor is one, this instance is returned.\n+     * \n+     * @param divisor  the divisor to divide this one by\n+     * @return the new duration instance\n+     */\n+    public Duration dividedBy(long divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return new Duration(FieldUtils.safeDivide(getMillis(), divisor));\n+    }\n+\n+    /**\n+     * Returns a new duration with this length negated.\n+     * This instance is immutable and is not altered.\n+     * \n+     * @return the new duration instance\n+     */\n+    public Duration negated() {\n+        if (getMillis() == Long.MIN_VALUE) {\n+            throw new ArithmeticException(\"Negation of this duration would overflow\");\n+        }\n+        return new Duration(-getMillis());\n+    }\n+\n }\n--- a/src/main/java/org/joda/time/LocalDate.java\n+++ b/src/main/java/org/joda/time/LocalDate.java\n     /** The chronology to use in UTC. */\n     private final Chronology iChronology;\n     /** The cached hash code. */\n-    private transient volatile int iHash;\n+    private transient int iHash;\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n      * @since 1.5\n      */\n     public Period normalizedStandard(PeriodType type) {\n+        type = DateTimeUtils.getPeriodType(type);\n         long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n         millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n         millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n         millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n         millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n-        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());\n+        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n+            long totalMonths = years * 12L + months;\n+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n+                result = result.withYears(normalizedYears);\n+                totalMonths = totalMonths - (normalizedYears * 12);\n             }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n+                result = result.withMonths(normalizedMonths);\n+                totalMonths = totalMonths - normalizedMonths;\n             }\n+            if (totalMonths != 0) {\n+                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n+            }\n         }\n         return result;\n     }\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n         }\n         return total;\n     }\n-    \n+\n+    /**\n+     * Divides the dividend by the divisor throwing an exception if \n+     * overflow occurs or the divisor is zero.\n+     * \n+     * @param dividend  the dividend\n+     * @param divisor  the divisor\n+     * @return the new total\n+     * @throws ArithmeticException if the operation overflows or the divisor is zero\n+     */\n+    public static long safeDivide(long dividend, long divisor) {\n+        if (dividend == Long.MIN_VALUE && divisor == -1L) {\n+            throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\n+        }\n+        return dividend / divisor;\n+    }\n+\n     /**\n      * Casts to an int throwing an exception if overflow occurs.\n      * \n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n  * // parse using the Paris zone\n  * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n  * </pre>\n+ * <p>\n+ * Parsing builds up the resultant instant by 'setting' the value of each parsed field\n+ * from largest to smallest onto an initial instant, typically 1970-01-01T00:00Z.\n+ * This design means that day-of-month is set before day-of-week.\n+ * As such, if both the day-of-month and day-of-week are parsed, and the day-of-week\n+ * is incorrect, then the day-of-week overrides the day-of-month.\n+ * \n+ * This has a side effect if the input is not consistent.\n+ * \n  * \n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n--- a/src/main/java/org/joda/time/tz/CachedDateTimeZone.java\n+++ b/src/main/java/org/joda/time/tz/CachedDateTimeZone.java\n \n     private final DateTimeZone iZone;\n \n-    private final Info[] iInfoCache = new Info[cInfoCacheMask + 1];\n+    private final transient Info[] iInfoCache = new Info[cInfoCacheMask + 1];\n \n     private CachedDateTimeZone(DateTimeZone zone) {\n         super(zone.getID());\n--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * Compiles Olson ZoneInfo database files into binary files for each time zone\n+ * Compiles IANA ZoneInfo database files into binary files for each time zone\n  * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n  * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n  * converts them back into {@link DateTimeZone} objects.\n  * <p>\n  * Although this tool is similar to zic, the binary formats are not\n- * compatible. The latest Olson database files may be obtained\n- * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n+ * compatible. The latest IANA time zone database files may be obtained\n+ * <a href=\"http://www.iana.org/time-zones\">here</a>.\n  * <p>\n  * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n  * may be safely invoked by multiple threads.\n--- a/src/test/java/org/joda/time/TestDuration_Basics.java\n+++ b/src/test/java/org/joda/time/TestDuration_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testMultipliedBy_long1() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.multipliedBy(2L);\n+        assertEquals(246L, result.getMillis());\n+    }\n+\n+    public void testMultipliedBy_long2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.multipliedBy(1L);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDividedBy_long1() {\n+        Duration test = new Duration(246L);\n+        Duration result = test.dividedBy(2L);\n+        assertEquals(123L, result.getMillis());\n+    }\n+\n+    public void testDividedBy_long2() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.dividedBy(1L);\n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNegated_long1() {\n+        Duration test = new Duration(246L);\n+        Duration result = test.negated();\n+        assertEquals(-246L, result.getMillis());\n+    }\n+\n+    public void testNegated_long2() {\n+        Duration test = new Duration(-246L);\n+        Duration result = test.negated();\n+        assertEquals(246L, result.getMillis());\n+    }\n+\n+    public void testNegated_long3() {\n+        Duration test = new Duration(Long.MIN_VALUE);\n+        try {\n+            test.negated();\n+            fail();\n+        } catch(ArithmeticException e) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testWithDurationAdded_RD_int1() {\n         Duration test = new Duration(123L);\n         Duration result = test.withDurationAdded(new Duration(8000L), 1);\n--- a/src/test/java/org/joda/time/TestPeriod_Basics.java\n+++ b/src/test/java/org/joda/time/TestPeriod_Basics.java\n     }\n     \n     class MockPeriod extends BasePeriod {\n+        private static final long serialVersionUID = 1L;\n         public MockPeriod(long value) {\n             super(value, null, null);\n         }\n         assertEquals(new Period(2, 3, 0, 37, 3, 0, 0, 0, PeriodType.yearMonthDayTime()), result);\n     }\n \n+    public void testNormalizedStandard_periodType_months1() {\n+        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n+        Period result = test.normalizedStandard(PeriodType.months());\n+        assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n+        assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n+    }\n+\n+    public void testNormalizedStandard_periodType_months2() {\n+        Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0);\n+        Period result = test.normalizedStandard(PeriodType.months());\n+        assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test);\n+        assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n+    }\n+\n+    public void testNormalizedStandard_periodType_months3() {\n+        Period test = new Period(0, 4, 0, 0, 0, 0, 0, 0);\n+        Period result = test.normalizedStandard(PeriodType.months());\n+        assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0), test);\n+        assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n+    }\n+\n+    public void testNormalizedStandard_periodType_years() {\n+        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n+        try {\n+            test.normalizedStandard(PeriodType.years());\n+            fail();\n+        } catch (UnsupportedOperationException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNormalizedStandard_periodType_monthsWeeks() {\n+        PeriodType type = PeriodType.forFields(new DurationFieldType[]{\n+                        DurationFieldType.months(),\n+                        DurationFieldType.weeks(),\n+                        DurationFieldType.days()});\n+        Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0);\n+        Period result = test.normalizedStandard(type);\n+        assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);\n+        assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result);\n+    }\n+\n }\n--- a/src/test/java/org/joda/time/field/TestFieldUtils.java\n+++ b/src/test/java/org/joda/time/field/TestFieldUtils.java\n         } catch (ArithmeticException e) {\n         }\n     }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSafeDivideLongLong() {\n+        assertEquals(1L, FieldUtils.safeDivide(1L, 1L));\n+        \n+        assertEquals(1L, FieldUtils.safeDivide(3L, 3L));\n+        assertEquals(0L, FieldUtils.safeDivide(1L, 3L));\n+        assertEquals(3L, FieldUtils.safeDivide(3L, 1L));\n+        \n+        assertEquals(1L, FieldUtils.safeDivide(5L, 3L));\n+        assertEquals(-1L, FieldUtils.safeDivide(5L, -3L));\n+        assertEquals(-1L, FieldUtils.safeDivide(-5L, 3L));\n+        assertEquals(1L, FieldUtils.safeDivide(-5L, -3L));\n+        \n+        assertEquals(2L, FieldUtils.safeDivide(6L, 3L));\n+        assertEquals(-2L, FieldUtils.safeDivide(6L, -3L));\n+        assertEquals(-2L, FieldUtils.safeDivide(-6L, 3L));\n+        assertEquals(2L, FieldUtils.safeDivide(-6L, -3L));\n+        \n+        assertEquals(2L, FieldUtils.safeDivide(7L, 3L));\n+        assertEquals(-2L, FieldUtils.safeDivide(7L, -3L));\n+        assertEquals(-2L, FieldUtils.safeDivide(-7L, 3L));\n+        assertEquals(2L, FieldUtils.safeDivide(-7L, -3L));\n+        \n+        assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L));\n+        assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L));\n+        assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L));\n+        \n+        try {\n+            FieldUtils.safeDivide(Long.MIN_VALUE, -1L);\n+            fail();\n+        } catch (ArithmeticException e) {\n+        }\n+        \n+        try {\n+            FieldUtils.safeDivide(1L, 0L);\n+            fail();\n+        } catch (ArithmeticException e) {\n+        }\n+    }\n+\n }\n-", "timestamp": 1383659259, "metainfo": ""}