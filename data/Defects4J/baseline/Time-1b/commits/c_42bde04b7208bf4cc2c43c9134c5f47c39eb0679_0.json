{"sha": "42bde04b7208bf4cc2c43c9134c5f47c39eb0679", "log": "Add Years/Months/Weeks/Days/Hours/Minutes/Seconds (single field period classes)   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Days.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of days.\n+ * <p>\n+ * <code>Days</code> is an immutable period that can only store days.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of days in an application.\n+ * <p>\n+ * The number of days is set in the constructor, and may be queried using\n+ * <code>getDays()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Days</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Days extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero days. */\n+    public static final Days ZERO = new Days(0);\n+    /** Constant representing one day. */\n+    public static final Days ONE = new Days(1);\n+    /** Constant representing two days. */\n+    public static final Days TWO = new Days(2);\n+    /** Constant representing three days. */\n+    public static final Days THREE = new Days(3);\n+    /** Constant representing four days. */\n+    public static final Days FOUR = new Days(4);\n+    /** Constant representing five days. */\n+    public static final Days FIVE = new Days(5);\n+    /** Constant representing six days. */\n+    public static final Days SIX = new Days(6);\n+    /** Constant representing seven days. */\n+    public static final Days SEVEN = new Days(7);\n+    /** Constant representing the maximum nuber of days that can be stored in this object. */\n+    public static final Days MAX_VALUE = new Days(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of days that can be stored in this object. */\n+    public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380865L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Days</code> that may be cached.\n+     * <code>Days</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param days  the number of days to obtain an instance for\n+     * @return the instance of Days\n+     */\n+    public static Days days(int days) {\n+        switch (days) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Days(days);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Days daysBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.days());\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int days = chrono.days().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Days.days(days);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract days from, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Days daysIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Days.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Days</code> representing the number of complete\n+     * standard length days in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Days standardDaysIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY);\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Days</code> by parsing a string in the ISO8601 format 'PnD'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * days component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Days parseDays(String periodStr) {\n+        if (periodStr == null) {\n+            return Days.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Days.days(p.getDays());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of days.\n+     * You should consider using the factory method {@link #days(int)}\n+     * instead of the constructor.\n+     *\n+     * @param days  the number of days to represent\n+     */\n+    private Days(int days) {\n+        super(days);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Days.days(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>days</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.days();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>days</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.days();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in days to a period in weeks assuming a\n+     * 7 day week.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of weeks for this number of days\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in hours assuming a\n+     * 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of days\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY));\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in minutes assuming a\n+     * 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of days\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY));\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in seconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of days\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in days to a duration in milliseconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes and all minutes are 60 seconds.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of days\n+     */\n+    public Duration toStandardDuration() {\n+        long days = getValue();  // assign to a long\n+        return new Duration(days * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of days that this period represents.\n+     *\n+     * @return the number of days in the period\n+     */\n+    public int getDays() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of days added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new period plus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days plus(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        return Days.days(FieldUtils.safeAdd(getValue(), days));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of days added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative, null means zero\n+     * @return the new period plus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days plus(Days days) {\n+        if (days == null) {\n+            return this;\n+        }\n+        return plus(days.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of days taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to take away, may be negative\n+     * @return the new period minus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days minus(int days) {\n+        return plus(FieldUtils.safeNegate(days));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of days taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days minus(Days days) {\n+        if (days == null) {\n+            return this;\n+        }\n+        return minus(days.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the days multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days multipliedBy(int scalar) {\n+        return Days.days(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the days divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Days dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Days.days(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of days in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days negate() {\n+        return Days.days(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4D\" represents 4 days.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"D\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Hours.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of hours.\n+ * <p>\n+ * <code>Hours</code> is an immutable period that can only store hours.\n+ * It does not store years, months or minutes for example. As such it is a\n+ * type-safe way of representing a number of hours in an application.\n+ * <p>\n+ * The number of hours is set in the constructor, and may be queried using\n+ * <code>getHours()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Hours</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Hours extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero hours. */\n+    public static final Hours ZERO = new Hours(0);\n+    /** Constant representing one hour. */\n+    public static final Hours ONE = new Hours(1);\n+    /** Constant representing two hours. */\n+    public static final Hours TWO = new Hours(2);\n+    /** Constant representing three hours. */\n+    public static final Hours THREE = new Hours(3);\n+    /** Constant representing four hours. */\n+    public static final Hours FOUR = new Hours(4);\n+    /** Constant representing five hours. */\n+    public static final Hours FIVE = new Hours(5);\n+    /** Constant representing six hours. */\n+    public static final Hours SIX = new Hours(6);\n+    /** Constant representing seven hours. */\n+    public static final Hours SEVEN = new Hours(7);\n+    /** Constant representing seven hours. */\n+    public static final Hours EIGHT = new Hours(8);\n+    /** Constant representing the maximum nuber of hours that can be stored in this object. */\n+    public static final Hours MAX_VALUE = new Hours(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of hours that can be stored in this object. */\n+    public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380864L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Hours</code> that may be cached.\n+     * <code>Hours</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param hours  the number of hours to obtain an instance for\n+     * @return the instance of Hours\n+     */\n+    public static Hours hours(int hours) {\n+        switch (hours) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case 8:\n+                return EIGHT;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Hours(hours);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Hours hoursBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.hours());\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int hours = chrono.hours().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Hours.hours(hours);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract hours from, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Hours hoursIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Hours.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Hours</code> representing the number of complete\n+     * standard length hours in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Hours standardHoursIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR);\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Hours</code> by parsing a string in the ISO8601 format 'PTnH'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * hours component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Hours parseHours(String periodStr) {\n+        if (periodStr == null) {\n+            return Hours.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Hours.hours(p.getHours());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of hours.\n+     * You should consider using the factory method {@link #hours(int)}\n+     * instead of the constructor.\n+     *\n+     * @param hours  the number of hours to represent\n+     */\n+    private Hours(int hours) {\n+        super(hours);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Hours.hours(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>hours</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.hours();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>hours</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.hours();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in hours to a period in weeks assuming a\n+     * 7 day week and 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are 7 days\n+     * long and all days are 24 hours long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of hours\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in days assuming a\n+     * 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole days for this number of hours\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in minutes assuming a\n+     * 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are 60 minutes long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of hours\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR));\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in seconds assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long and all minutes are 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of hours\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in hours to a duration in milliseconds assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes and all minutes are 60 seconds. This might not be true for an\n+     * unusual chronology, for example one that takes leap seconds into account.\n+     * However, the method is included as it is a useful operation for many\n+     * applications and business rules.\n+     *\n+     * @return a period representing the number of hours for this number of hours\n+     */\n+    public Duration toStandardDuration() {\n+        long hours = getValue();  // assign to a long\n+        return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of hours that this period represents.\n+     *\n+     * @return the number of hours in the period\n+     */\n+    public int getHours() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of hours added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new period plus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours plus(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        return Hours.hours(FieldUtils.safeAdd(getValue(), hours));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of hours added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative, null means zero\n+     * @return the new period plus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours plus(Hours hours) {\n+        if (hours == null) {\n+            return this;\n+        }\n+        return plus(hours.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of hours taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to take away, may be negative\n+     * @return the new period minus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours minus(int hours) {\n+        return plus(FieldUtils.safeNegate(hours));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of hours taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours minus(Hours hours) {\n+        if (hours == null) {\n+            return this;\n+        }\n+        return minus(hours.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the hours multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours multipliedBy(int scalar) {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the hours divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Hours dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Hours.hours(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of hours in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours negate() {\n+        return Hours.hours(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4H\" represents 4 hours.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"H\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Minutes.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of minutes.\n+ * <p>\n+ * <code>Minutes</code> is an immutable period that can only store minutes.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of minutes in an application.\n+ * <p>\n+ * The number of minutes is set in the constructor, and may be queried using\n+ * <code>getMinutes()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Minutes</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Minutes extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero minutes. */\n+    public static final Minutes ZERO = new Minutes(0);\n+    /** Constant representing one minute. */\n+    public static final Minutes ONE = new Minutes(1);\n+    /** Constant representing two minutes. */\n+    public static final Minutes TWO = new Minutes(2);\n+    /** Constant representing three minutes. */\n+    public static final Minutes THREE = new Minutes(3);\n+    /** Constant representing the maximum nuber of minutes that can be stored in this object. */\n+    public static final Minutes MAX_VALUE = new Minutes(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of minutes that can be stored in this object. */\n+    public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380863L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Minutes</code> that may be cached.\n+     * <code>Minutes</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param minutes  the number of minutes to obtain an instance for\n+     * @return the instance of Minutes\n+     */\n+    public static Minutes minutes(int minutes) {\n+        switch (minutes) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Minutes(minutes);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Minutes minutesBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.minutes());\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int minutes = chrono.minutes().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Minutes.minutes(minutes);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract minutes from, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Minutes minutesIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Minutes.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Minutes</code> representing the number of complete\n+     * standard length minutes in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to minutes using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of minutes from, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Minutes standardMinutesIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE);\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Minutes</code> by parsing a string in the ISO8601 format 'PTnM'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * minutes component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Minutes parseMinutes(String periodStr) {\n+        if (periodStr == null) {\n+            return Minutes.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Minutes.minutes(p.getMinutes());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of minutes.\n+     * You should consider using the factory method {@link #minutes(int)}\n+     * instead of the constructor.\n+     *\n+     * @param minutes  the number of minutes to represent\n+     */\n+    private Minutes(int minutes) {\n+        super(minutes);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Minutes.minutes(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>minutes</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.minutes();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>minutes</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.minutes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in minutes to a period in weeks assuming a\n+     * 7 days week, 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of minutes\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in days assuming a\n+     * 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are\n+     * 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole days for this number of minutes\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in hours assuming a\n+     * 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of minutes\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in seconds assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of minutes\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in minutes to a duration in milliseconds assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long. This might not be true for an unusual chronology,\n+     * for example one that takes leap seconds into account.\n+     * However, the method is included as it is a useful operation for many\n+     * applications and business rules.\n+     *\n+     * @return a period representing the number of minutes for this number of minutes\n+     */\n+    public Duration toStandardDuration() {\n+        long minutes = getValue();  // assign to a long\n+        return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of minutes that this period represents.\n+     *\n+     * @return the number of minutes in the period\n+     */\n+    public int getMinutes() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of minutes added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new period plus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes plus(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of minutes added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative, null means zero\n+     * @return the new period plus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes plus(Minutes minutes) {\n+        if (minutes == null) {\n+            return this;\n+        }\n+        return plus(minutes.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of minutes taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to take away, may be negative\n+     * @return the new period minus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes minus(int minutes) {\n+        return plus(FieldUtils.safeNegate(minutes));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of minutes taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes minus(Minutes minutes) {\n+        if (minutes == null) {\n+            return this;\n+        }\n+        return minus(minutes.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the minutes multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes multipliedBy(int scalar) {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the minutes divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Minutes dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Minutes.minutes(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of minutes in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes negate() {\n+        return Minutes.minutes(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4M\" represents 4 minutes.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"M\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Months.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of months.\n+ * <p>\n+ * <code>Months</code> is an immutable period that can only store months.\n+ * It does not store years, days or hours for example. As such it is a\n+ * type-safe way of representing a number of months in an application.\n+ * <p>\n+ * The number of months is set in the constructor, and may be queried using\n+ * <code>getMonths()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Months</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Months extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero months. */\n+    public static final Months ZERO = new Months(0);\n+    /** Constant representing one day. */\n+    public static final Months ONE = new Months(1);\n+    /** Constant representing two months. */\n+    public static final Months TWO = new Months(2);\n+    /** Constant representing three months. */\n+    public static final Months THREE = new Months(3);\n+    /** Constant representing four months. */\n+    public static final Months FOUR = new Months(4);\n+    /** Constant representing five months. */\n+    public static final Months FIVE = new Months(5);\n+    /** Constant representing six months. */\n+    public static final Months SIX = new Months(6);\n+    /** Constant representing seven months. */\n+    public static final Months SEVEN = new Months(7);\n+    /** Constant representing eight months. */\n+    public static final Months EIGHT = new Months(8);\n+    /** Constant representing nine months. */\n+    public static final Months NINE = new Months(9);\n+    /** Constant representing ten months. */\n+    public static final Months TEN = new Months(10);\n+    /** Constant representing eleven months. */\n+    public static final Months ELEVEN = new Months(11);\n+    /** Constant representing twelve months. */\n+    public static final Months TWELVE = new Months(12);\n+    /** Constant representing the maximum nuber of months that can be stored in this object. */\n+    public static final Months MAX_VALUE = new Months(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of months that can be stored in this object. */\n+    public static final Months MIN_VALUE = new Months(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.months());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380867L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Months</code> that may be cached.\n+     * <code>Months</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param months  the number of months to obtain an instance for\n+     * @return the instance of Months\n+     */\n+    public static Months months(int months) {\n+        switch (months) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case 8:\n+                return EIGHT;\n+            case 9:\n+                return NINE;\n+            case 10:\n+                return TEN;\n+            case 11:\n+                return ELEVEN;\n+            case 12:\n+                return TWELVE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Months(months);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Months monthsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.months());\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int months = chrono.months().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Months.months(months);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract months from, null returns zero\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Months monthsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Months.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Months</code> by parsing a string in the ISO8601 format 'PnM'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * months component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Months parseMonths(String periodStr) {\n+        if (periodStr == null) {\n+            return Months.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Months.months(p.getMonths());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of months.\n+     * You should consider using the factory method {@link #months(int)}\n+     * instead of the constructor.\n+     *\n+     * @param months  the number of months to represent\n+     */\n+    private Months(int months) {\n+        super(months);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Months.months(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>months</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.months();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>months</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.months();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of months that this period represents.\n+     *\n+     * @return the number of months in the period\n+     */\n+    public int getMonths() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of months added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new period plus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months plus(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        return Months.months(FieldUtils.safeAdd(getValue(), months));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of months added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative, null means zero\n+     * @return the new period plus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months plus(Months months) {\n+        if (months == null) {\n+            return this;\n+        }\n+        return plus(months.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of months taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to take away, may be negative\n+     * @return the new period minus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months minus(int months) {\n+        return plus(FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of months taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months minus(Months months) {\n+        if (months == null) {\n+            return this;\n+        }\n+        return minus(months.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the months multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months multipliedBy(int scalar) {\n+        return Months.months(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the months divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Months dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Months.months(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of months in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months negate() {\n+        return Months.months(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4M\" represents 4 months.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"M\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Seconds.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of seconds.\n+ * <p>\n+ * <code>Seconds</code> is an immutable period that can only store seconds.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of seconds in an application.\n+ * <p>\n+ * The number of seconds is set in the constructor, and may be queried using\n+ * <code>getSeconds()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Seconds</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Seconds extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero seconds. */\n+    public static final Seconds ZERO = new Seconds(0);\n+    /** Constant representing one second. */\n+    public static final Seconds ONE = new Seconds(1);\n+    /** Constant representing two seconds. */\n+    public static final Seconds TWO = new Seconds(2);\n+    /** Constant representing three seconds. */\n+    public static final Seconds THREE = new Seconds(3);\n+    /** Constant representing the maximum nuber of seconds that can be stored in this object. */\n+    public static final Seconds MAX_VALUE = new Seconds(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of seconds that can be stored in this object. */\n+    public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380862L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Seconds</code> that may be cached.\n+     * <code>Seconds</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param seconds  the number of seconds to obtain an instance for\n+     * @return the instance of Seconds\n+     */\n+    public static Seconds seconds(int seconds) {\n+        switch (seconds) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Seconds(seconds);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds());\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int seconds = chrono.seconds().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Seconds.seconds(seconds);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract seconds from, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Seconds secondsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Seconds.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Seconds</code> representing the number of complete\n+     * standard length seconds in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 seconds.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Seconds standardSecondsIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND);\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Seconds</code> by parsing a string in the ISO8601 format 'PTnS'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * seconds component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Seconds parseSeconds(String periodStr) {\n+        if (periodStr == null) {\n+            return Seconds.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Seconds.seconds(p.getSeconds());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of seconds.\n+     * You should consider using the factory method {@link #seconds(int)}\n+     * instead of the constructor.\n+     *\n+     * @param seconds  the number of seconds to represent\n+     */\n+    private Seconds(int seconds) {\n+        super(seconds);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Seconds.seconds(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>seconds</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.seconds();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>seconds</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.seconds();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in seconds to a period in weeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are 7 days\n+     * long, all days are 24 hours long, all hours are 60 minutes long and\n+     * all minutes are 60 seconds long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of seconds\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in days assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of days for this number of seconds\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in hours assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long and all minutes are 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of seconds\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in minutes assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of seconds\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in seconds to a duration in milliseconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all seconds are 24 hours\n+     * long, all hours are 60 minutes and all minutes are 60 seconds.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of seconds\n+     */\n+    public Duration toStandardDuration() {\n+        long seconds = getValue();  // assign to a long\n+        return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of seconds that this period represents.\n+     *\n+     * @return the number of seconds in the period\n+     */\n+    public int getSeconds() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of seconds added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new period plus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds plus(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of seconds added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative, null means zero\n+     * @return the new period plus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds plus(Seconds seconds) {\n+        if (seconds == null) {\n+            return this;\n+        }\n+        return plus(seconds.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of seconds taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to take away, may be negative\n+     * @return the new period minus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds minus(int seconds) {\n+        return plus(FieldUtils.safeNegate(seconds));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of seconds taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds minus(Seconds seconds) {\n+        if (seconds == null) {\n+            return this;\n+        }\n+        return minus(seconds.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the seconds multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds multipliedBy(int scalar) {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the seconds divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Seconds dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Seconds.seconds(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of seconds in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds negate() {\n+        return Seconds.seconds(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4S\" represents 4 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"S\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Weeks.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of weeks.\n+ * <p>\n+ * <code>Weeks</code> is an immutable period that can only store weeks.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of weeks in an application.\n+ * <p>\n+ * The number of weeks is set in the constructor, and may be queried using\n+ * <code>getWeeks()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Weeks</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Weeks extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero weeks. */\n+    public static final Weeks ZERO = new Weeks(0);\n+    /** Constant representing one week. */\n+    public static final Weeks ONE = new Weeks(1);\n+    /** Constant representing two weeks. */\n+    public static final Weeks TWO = new Weeks(2);\n+    /** Constant representing three weeks. */\n+    public static final Weeks THREE = new Weeks(3);\n+    /** Constant representing the maximum nuber of weeks that can be stored in this object. */\n+    public static final Weeks MAX_VALUE = new Weeks(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of weeks that can be stored in this object. */\n+    public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380866L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Weeks</code> that may be cached.\n+     * <code>Weeks</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param weeks  the number of weeks to obtain an instance for\n+     * @return the instance of Weeks\n+     */\n+    public static Weeks weeks(int weeks) {\n+        switch (weeks) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Weeks(weeks);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks());\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int weeks = chrono.weeks().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Weeks.weeks(weeks);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract weeks from, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Weeks weeksIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Weeks.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Weeks</code> representing the number of complete\n+     * standard length weeks in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 weeks.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Weeks standardWeeksIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK);\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Weeks</code> by parsing a string in the ISO8601 format 'PnW'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * weeks component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Weeks parseWeeks(String periodStr) {\n+        if (periodStr == null) {\n+            return Weeks.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Weeks.weeks(p.getWeeks());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of weeks.\n+     * You should consider using the factory method {@link #weeks(int)}\n+     * instead of the constructor.\n+     *\n+     * @param weeks  the number of weeks to represent\n+     */\n+    private Weeks(int weeks) {\n+        super(weeks);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Weeks.weeks(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>weeks</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.weeks();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>weeks</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.weeks();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in weeks to a period in days assuming a\n+     * 7 day week.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of days for this number of weeks\n+     * @throws ArithmeticException if the number of days is too large to be represented\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in hours assuming a\n+     * 7 day week and 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long and all days are 24 hours long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of weeks\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in minutes assuming a\n+     * 7 day week, 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of weeks\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in seconds assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n+     * and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of weeks\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in weeks to a duration in milliweeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n+     * and all minutes are 60 seconds long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of weeks\n+     */\n+    public Duration toStandardDuration() {\n+        long weeks = getValue();  // assign to a long\n+        return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of weeks that this period represents.\n+     *\n+     * @return the number of weeks in the period\n+     */\n+    public int getWeeks() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of weeks added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new period plus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks plus(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of weeks added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative, null means zero\n+     * @return the new period plus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks plus(Weeks weeks) {\n+        if (weeks == null) {\n+            return this;\n+        }\n+        return plus(weeks.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of weeks taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to take away, may be negative\n+     * @return the new period minus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks minus(int weeks) {\n+        return plus(FieldUtils.safeNegate(weeks));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of weeks taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks minus(Weeks weeks) {\n+        if (weeks == null) {\n+            return this;\n+        }\n+        return minus(weeks.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the weeks multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks multipliedBy(int scalar) {\n+        return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the weeks divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Weeks dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Weeks.weeks(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of weeks in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks negate() {\n+        return Weeks.weeks(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4W\" represents 4 weeks.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"W\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Years.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of years.\n+ * <p>\n+ * <code>Years</code> is an immutable period that can only store years.\n+ * It does not store years, days or hours for example. As such it is a\n+ * type-safe way of representing a number of years in an application.\n+ * <p>\n+ * The number of years is set in the constructor, and may be queried using\n+ * <code>getYears()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Years</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Years extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero years. */\n+    public static final Years ZERO = new Years(0);\n+    /** Constant representing one day. */\n+    public static final Years ONE = new Years(1);\n+    /** Constant representing two years. */\n+    public static final Years TWO = new Years(2);\n+    /** Constant representing three years. */\n+    public static final Years THREE = new Years(3);\n+    /** Constant representing the maximum nuber of years that can be stored in this object. */\n+    public static final Years MAX_VALUE = new Years(Integer.MAX_VALUE);\n+    /** Constant representing the minimum nuber of years that can be stored in this object. */\n+    public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380868L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Years</code> that may be cached.\n+     * <code>Years</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param years  the number of years to obtain an instance for\n+     * @return the instance of Years\n+     */\n+    public static Years years(int years) {\n+        switch (years) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Years(years);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Years yearsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years());\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int years = chrono.years().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Years.years(years);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract years from, null returns zero\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Years yearsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Years.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Years</code> by parsing a string in the ISO8601 format 'PnY'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * years component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Years parseYears(String periodStr) {\n+        if (periodStr == null) {\n+            return Years.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Years.years(p.getYears());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of years.\n+     * You should consider using the factory method {@link #years(int)}\n+     * instead of the constructor.\n+     *\n+     * @param years  the number of years to represent\n+     */\n+    private Years(int years) {\n+        super(years);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Years.years(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>years</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.years();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>years</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.years();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of years that this period represents.\n+     *\n+     * @return the number of years in the period\n+     */\n+    public int getYears() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of years added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new period plus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years plus(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        return Years.years(FieldUtils.safeAdd(getValue(), years));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of years added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative, null means zero\n+     * @return the new period plus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years plus(Years years) {\n+        if (years == null) {\n+            return this;\n+        }\n+        return plus(years.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of years taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to take away, may be negative\n+     * @return the new period minus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years minus(int years) {\n+        return plus(FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of years taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years minus(Years years) {\n+        if (years == null) {\n+            return this;\n+        }\n+        return minus(years.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the years multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years multipliedBy(int scalar) {\n+        return Years.years(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the years divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Years dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Years.years(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Negates the number of years in this period.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years negate() {\n+        return Years.years(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4Y\" represents 4 years.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"Y\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that\n+ * manages a single duration field, such as days or minutes.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadablePeriod} interface should be used when different \n+ * kinds of period objects are to be referenced.\n+ * <p>\n+ * BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public abstract class BaseSingleFieldPeriod\n+        implements ReadablePeriod, Comparable, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 9386874258972L;\n+\n+    /** The period in the units of this period. */\n+    private int iPeriod;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculates the number of whole units between the two specified datetimes.\n+     *\n+     * @param start  the start instant, validated to not be null\n+     * @param end  the end instant, validated to not be null\n+     * @param field  the field type to use, must not be null\n+     * @return the period\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n+        }\n+        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n+        return amount;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculates the number of whole units between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, validated to not be null\n+     * @param end  the end partial date, validated to not be null\n+     * @param zeroInstance  the zero instance constant, must not be null\n+     * @return the period\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n+        }\n+        if (start.size() != end.size()) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+        }\n+        for (int i = 0, isize = start.size(); i < isize; i++) {\n+            if (start.getFieldType(i) != end.getFieldType(i)) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+            }\n+        }\n+        if (DateTimeUtils.isContiguous(start) == false) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n+        }\n+        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n+        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n+        return values[0];\n+    }\n+\n+    /**\n+     * Creates a new instance representing the number of complete standard length units\n+     * in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, must not be null\n+     * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n+        if (period == null) {\n+            return 0;\n+        }\n+        Chronology iso = ISOChronology.getInstanceUTC();\n+        long duration = 0L;\n+        for (int i = 0; i < period.size(); i++) {\n+            int value = period.getValue(i);\n+            if (value != 0) {\n+                DurationField field = period.getFieldType(i).getField(iso);\n+                if (field.isPrecise() == false) {\n+                    throw new IllegalArgumentException(\n+                            \"Cannot convert period to duration as \" + field.getName() +\n+                            \" is not precise in the period \" + period);\n+                }\n+                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n+            }\n+        }\n+        return FieldUtils.safeToInt(duration / millisPerUnit);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing the specified period.\n+     *\n+     * @param period  the period to represent\n+     */\n+    protected BaseSingleFieldPeriod(int period) {\n+        super();\n+        iPeriod = period;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the amount of this period.\n+     *\n+     * @return the period value\n+     */\n+    protected int getValue() {\n+        return iPeriod;\n+    }\n+\n+    /**\n+     * Sets the amount of this period.\n+     * To make a subclass immutable you must declare it final, or block this method.\n+     *\n+     * @param vaue  the period value\n+     */\n+    protected void setValue(int value) {\n+        iPeriod = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the single duration field type.\n+     *\n+     * @return the duration field type, not null\n+     */\n+    public abstract DurationFieldType getFieldType();\n+\n+    /**\n+     * Gets the period type which matches the duration field type.\n+     *\n+     * @return the period type, not null\n+     */\n+    public abstract PeriodType getPeriodType();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields that this period supports, which is one.\n+     *\n+     * @return the number of fields supported, which is one\n+     */\n+    public int size() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     * <p>\n+     * The only index supported by this period is zero which returns the\n+     * field type of this class.\n+     *\n+     * @param index  the index to retrieve, which must be zero\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        if (index != 0) {\n+            throw new IndexOutOfBoundsException(String.valueOf(index));\n+        }\n+        return getFieldType();\n+    }\n+\n+    /**\n+     * Gets the value at the specified index.\n+     * <p>\n+     * The only index supported by this period is zero.\n+     *\n+     * @param index  the index to retrieve, which must be zero\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        if (index != 0) {\n+            throw new IndexOutOfBoundsException(String.valueOf(index));\n+        }\n+        return getValue();\n+    }\n+\n+    /**\n+     * Gets the value of a duration field represented by this period.\n+     * <p>\n+     * If the field type specified does not match the type used by this class\n+     * then zero is returned.\n+     *\n+     * @param type  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    public int get(DurationFieldType type) {\n+        if (type == getFieldType()) {\n+            return getValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Checks whether the duration field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return (type == getFieldType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object.\n+     * The period will use <code>PeriodType.standard()</code>.\n+     *\n+     * @return a <code>Period</code> representing the same number of days\n+     */\n+    public Period toPeriod() {\n+        return Period.ZERO.withFields(this);\n+    }\n+\n+    /**\n+     * Get this object as a <code>MutablePeriod</code>.\n+     * <p>\n+     * This will always return a new <code>MutablePeriod</code> with the same fields.\n+     * The period will use <code>PeriodType.standard()</code>.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    public MutablePeriod toMutablePeriod() {\n+        MutablePeriod period = new MutablePeriod();\n+        period.add(this);\n+        return period;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based on the\n+     * value of each field. All ReadablePeriod instances are accepted, but only\n+     * those with a matching <code>PeriodType</code> can return true.\n+     *\n+     * @param period  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public boolean equals(Object period) {\n+        if (this == period) {\n+            return true;\n+        }\n+        if (period instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) period;\n+        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n+    }\n+\n+    /**\n+     * Gets a hash code for the period as defined by ReadablePeriod.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        int total = 17;\n+        total = 27 * total + getValue();\n+        total = 27 * total + getFieldType().hashCode();\n+        return total;\n+    }\n+\n+    /**\n+     * Compares this period to another object of the same class.\n+     *\n+     * @param other  the other period, must not be null\n+     * @return zero if equal, positive if greater, negative if less\n+     */\n+    public int compareTo(Object other) {\n+        if (other.getClass() != getClass()) {\n+            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n+        }\n+        int otherValue = ((BaseSingleFieldPeriod) other).getValue();\n+        int thisValue = getValue();\n+        if (thisValue > otherValue) {\n+            return 1;\n+        }\n+        if (thisValue < otherValue) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestMutablePeriod_Basics.suite());\n         suite.addTest(TestMutablePeriod_Updates.suite());\n         \n+        suite.addTest(TestBaseSingleFieldPeriod.suite());\n+        suite.addTest(TestYears.suite());\n+        suite.addTest(TestMonths.suite());\n+        suite.addTest(TestWeeks.suite());\n+        suite.addTest(TestDays.suite());\n+        suite.addTest(TestHours.suite());\n+        suite.addTest(TestMinutes.suite());\n+        suite.addTest(TestSeconds.suite());\n+        \n         suite.addTest(TestTimeOfDay_Basics.suite());\n         suite.addTest(TestTimeOfDay_Constructors.suite());\n         suite.addTest(TestTimeOfDay_Properties.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestBaseSingleFieldPeriod.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+\n+/**\n+ * This class is a Junit unit test for BaseSingleFieldPeriod.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestBaseSingleFieldPeriod extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestBaseSingleFieldPeriod.class);\n+    }\n+\n+    public TestBaseSingleFieldPeriod(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_between_RInstant() {\n+        // test using Days\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Single.between(start, end1, DurationFieldType.days()));\n+        assertEquals(0, Single.between(start, start, DurationFieldType.days()));\n+        assertEquals(0, Single.between(end1, end1, DurationFieldType.days()));\n+        assertEquals(-3, Single.between(end1, start, DurationFieldType.days()));\n+        assertEquals(6, Single.between(start, end2, DurationFieldType.days()));\n+        try {\n+            Single.between(start, (ReadableInstant) null, DurationFieldType.days());\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between((ReadableInstant) null, end1, DurationFieldType.days());\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between((ReadableInstant) null, (ReadableInstant) null, DurationFieldType.days());\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testFactory_between_RPartial() {\n+        LocalDate start = new LocalDate(2006, 6, 9);\n+        LocalDate end1 = new LocalDate(2006, 6, 12);\n+        YearMonthDay end2 = new YearMonthDay(2006, 6, 15);\n+        \n+        Single zero = new Single(0);\n+        assertEquals(3, Single.between(start, end1, zero));\n+        assertEquals(0, Single.between(start, start, zero));\n+        assertEquals(0, Single.between(end1, end1, zero));\n+        assertEquals(-3, Single.between(end1, start, zero));\n+        assertEquals(6, Single.between(start, end2, zero));\n+        try {\n+            Single.between(start, (ReadablePartial) null, zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between((ReadablePartial) null, end1, zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between((ReadablePartial) null, (ReadablePartial) null, zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between(start, new TimeOfDay(), zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            Single.between(new Partial(DateTimeFieldType.dayOfWeek(), 2), new Partial(DateTimeFieldType.dayOfMonth(), 3), zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        Partial p = new Partial(\n+                new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.hourOfDay()},\n+                new int[] {1, 2});\n+        try {\n+            Single.between(p, p, zero);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testFactory_standardPeriodIn_RPeriod() {\n+        assertEquals(0, Single.standardPeriodIn((ReadablePeriod) null, DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(0, Single.standardPeriodIn(Period.ZERO, DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(1, Single.standardPeriodIn(new Period(0, 0, 0, 1, 0, 0, 0, 0), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(123, Single.standardPeriodIn(Period.days(123), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(-987, Single.standardPeriodIn(Period.days(-987), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(1, Single.standardPeriodIn(Period.hours(47), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(2, Single.standardPeriodIn(Period.hours(48), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(2, Single.standardPeriodIn(Period.hours(49), DateTimeConstants.MILLIS_PER_DAY));\n+        assertEquals(14, Single.standardPeriodIn(Period.weeks(2), DateTimeConstants.MILLIS_PER_DAY));\n+        try {\n+            Single.standardPeriodIn(Period.months(1), DateTimeConstants.MILLIS_PER_DAY);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testValueIndexMethods() {\n+        Single test = new Single(20);\n+        assertEquals(1, test.size());\n+        assertEquals(20, test.getValue(0));\n+        try {\n+            test.getValue(1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testFieldTypeIndexMethods() {\n+        Single test = new Single(20);\n+        assertEquals(1, test.size());\n+        assertEquals(DurationFieldType.days(), test.getFieldType(0));\n+        try {\n+            test.getFieldType(1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testIsSupported() {\n+        Single test = new Single(20);\n+        assertEquals(false, test.isSupported(DurationFieldType.years()));\n+        assertEquals(false, test.isSupported(DurationFieldType.months()));\n+        assertEquals(false, test.isSupported(DurationFieldType.weeks()));\n+        assertEquals(true, test.isSupported(DurationFieldType.days()));\n+        assertEquals(false, test.isSupported(DurationFieldType.hours()));\n+        assertEquals(false, test.isSupported(DurationFieldType.minutes()));\n+        assertEquals(false, test.isSupported(DurationFieldType.seconds()));\n+        assertEquals(false, test.isSupported(DurationFieldType.millis()));\n+    }        \n+\n+    public void testGet() {\n+        Single test = new Single(20);\n+        assertEquals(0, test.get(DurationFieldType.years()));\n+        assertEquals(0, test.get(DurationFieldType.months()));\n+        assertEquals(0, test.get(DurationFieldType.weeks()));\n+        assertEquals(20, test.get(DurationFieldType.days()));\n+        assertEquals(0, test.get(DurationFieldType.hours()));\n+        assertEquals(0, test.get(DurationFieldType.minutes()));\n+        assertEquals(0, test.get(DurationFieldType.seconds()));\n+        assertEquals(0, test.get(DurationFieldType.millis()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode() {\n+        Single testA = new Single(20);\n+        Single testB = new Single(20);\n+        assertEquals(true, testA.equals(testB));\n+        assertEquals(true, testB.equals(testA));\n+        assertEquals(true, testA.equals(testA));\n+        assertEquals(true, testB.equals(testB));\n+        assertEquals(true, testA.hashCode() == testB.hashCode());\n+        assertEquals(true, testA.hashCode() == testA.hashCode());\n+        assertEquals(true, testB.hashCode() == testB.hashCode());\n+        \n+        Single testC = new Single(30);\n+        assertEquals(false, testA.equals(testC));\n+        assertEquals(false, testB.equals(testC));\n+        assertEquals(false, testC.equals(testA));\n+        assertEquals(false, testC.equals(testB));\n+        assertEquals(false, testA.hashCode() == testC.hashCode());\n+        assertEquals(false, testB.hashCode() == testC.hashCode());\n+        \n+        assertEquals(true, testA.equals(Days.days(20)));\n+        assertEquals(true, testA.equals(new Period(0, 0, 0, 20, 0, 0, 0, 0, PeriodType.days())));\n+        assertEquals(false, testA.equals(Period.days(2)));\n+        assertEquals(false, testA.equals(\"Hello\"));\n+        assertEquals(false, testA.equals(Hours.hours(2)));\n+        assertEquals(false, testA.equals(null));\n+    }\n+\n+    public void testCompareTo() {\n+        Single test1 = new Single(21);\n+        Single test2 = new Single(22);\n+        Single test3 = new Single(23);\n+        assertEquals(true, test1.compareTo(test1) == 0);\n+        assertEquals(true, test1.compareTo(test2) < 0);\n+        assertEquals(true, test1.compareTo(test3) < 0);\n+        assertEquals(true, test2.compareTo(test1) > 0);\n+        assertEquals(true, test2.compareTo(test2) == 0);\n+        assertEquals(true, test2.compareTo(test3) < 0);\n+        assertEquals(true, test3.compareTo(test1) > 0);\n+        assertEquals(true, test3.compareTo(test2) > 0);\n+        assertEquals(true, test3.compareTo(test3) == 0);\n+        \n+        try {\n+            test1.compareTo(\"Hello\");\n+            fail();\n+        } catch (ClassCastException ex) {\n+            // expected\n+        }\n+        try {\n+            test1.compareTo(new Period(0, 0, 0, 21, 0, 0, 0, 0, PeriodType.days()));\n+            fail();\n+        } catch (ClassCastException ex) {\n+            // expected\n+        }\n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToPeriod() {\n+        Single test = new Single(20);\n+        Period expected = Period.days(20);\n+        assertEquals(expected, test.toPeriod());\n+    }\n+\n+    public void testToMutablePeriod() {\n+        Single test = new Single(20);\n+        MutablePeriod expected = new MutablePeriod(0, 0, 0, 20, 0, 0, 0, 0);\n+        assertEquals(expected, test.toMutablePeriod());\n+    }\n+\n+//    public void testToDurationFrom() {\n+//        Period test = new Period(123L);\n+//        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));\n+//    }\n+//\n+//    public void testToDurationTo() {\n+//        Period test = new Period(123L);\n+//        assertEquals(new Duration(123L), test.toDurationTo(new Instant(123L)));\n+//    }\n+//\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetSetValue() {\n+        Single test = new Single(20);\n+        assertEquals(20, test.getValue());\n+        test.setValue(10);\n+        assertEquals(10, test.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** Test class. */\n+    static class Single extends BaseSingleFieldPeriod {\n+\n+        public Single(int period) {\n+            super(period);\n+        }\n+        \n+        public static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n+            return BaseSingleFieldPeriod.between(start, end, field);\n+        }\n+        \n+        public static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n+            return BaseSingleFieldPeriod.between(start, end, zeroInstance);\n+        }\n+        \n+        public static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n+            return BaseSingleFieldPeriod.standardPeriodIn(period, millisPerUnit);\n+        }\n+        \n+        public DurationFieldType getFieldType() {\n+            return DurationFieldType.days();\n+        }\n+\n+        public PeriodType getPeriodType() {\n+            return PeriodType.days();\n+        }\n+        \n+        public int getValue() {\n+            return super.getValue();\n+        }\n+        \n+        public void setValue(int value) {\n+            super.setValue(value);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDays.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Days.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDays extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDays.class);\n+    }\n+\n+    public TestDays(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Days.ZERO.getDays());\n+        assertEquals(1, Days.ONE.getDays());\n+        assertEquals(2, Days.TWO.getDays());\n+        assertEquals(3, Days.THREE.getDays());\n+        assertEquals(4, Days.FOUR.getDays());\n+        assertEquals(5, Days.FIVE.getDays());\n+        assertEquals(6, Days.SIX.getDays());\n+        assertEquals(7, Days.SEVEN.getDays());\n+        assertEquals(Integer.MAX_VALUE, Days.MAX_VALUE.getDays());\n+        assertEquals(Integer.MIN_VALUE, Days.MIN_VALUE.getDays());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_days_int() {\n+        assertSame(Days.ZERO, Days.days(0));\n+        assertSame(Days.ONE, Days.days(1));\n+        assertSame(Days.TWO, Days.days(2));\n+        assertSame(Days.THREE, Days.days(3));\n+        assertSame(Days.FOUR, Days.days(4));\n+        assertSame(Days.FIVE, Days.days(5));\n+        assertSame(Days.SIX, Days.days(6));\n+        assertSame(Days.SEVEN, Days.days(7));\n+        assertSame(Days.MAX_VALUE, Days.days(Integer.MAX_VALUE));\n+        assertSame(Days.MIN_VALUE, Days.days(Integer.MIN_VALUE));\n+        assertEquals(-1, Days.days(-1).getDays());\n+        assertEquals(8, Days.days(8).getDays());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_daysBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Days.daysBetween(start, end1).getDays());\n+        assertEquals(0, Days.daysBetween(start, start).getDays());\n+        assertEquals(0, Days.daysBetween(end1, end1).getDays());\n+        assertEquals(-3, Days.daysBetween(end1, start).getDays());\n+        assertEquals(6, Days.daysBetween(start, end2).getDays());\n+    }\n+\n+    public void testFactory_daysBetween_RPartial() {\n+        LocalDate start = new LocalDate(2006, 6, 9);\n+        LocalDate end1 = new LocalDate(2006, 6, 12);\n+        YearMonthDay end2 = new YearMonthDay(2006, 6, 15);\n+        \n+        assertEquals(3, Days.daysBetween(start, end1).getDays());\n+        assertEquals(0, Days.daysBetween(start, start).getDays());\n+        assertEquals(0, Days.daysBetween(end1, end1).getDays());\n+        assertEquals(-3, Days.daysBetween(end1, start).getDays());\n+        assertEquals(6, Days.daysBetween(start, end2).getDays());\n+    }\n+\n+    public void testFactory_daysIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n+        \n+        assertEquals(0, Days.daysIn((ReadableInterval) null).getDays());\n+        assertEquals(3, Days.daysIn(new Interval(start, end1)).getDays());\n+        assertEquals(0, Days.daysIn(new Interval(start, start)).getDays());\n+        assertEquals(0, Days.daysIn(new Interval(end1, end1)).getDays());\n+        assertEquals(6, Days.daysIn(new Interval(start, end2)).getDays());\n+    }\n+\n+    public void testFactory_standardDaysIn_RPeriod() {\n+        assertEquals(0, Days.standardDaysIn((ReadablePeriod) null).getDays());\n+        assertEquals(0, Days.standardDaysIn(Period.ZERO).getDays());\n+        assertEquals(1, Days.standardDaysIn(new Period(0, 0, 0, 1, 0, 0, 0, 0)).getDays());\n+        assertEquals(123, Days.standardDaysIn(Period.days(123)).getDays());\n+        assertEquals(-987, Days.standardDaysIn(Period.days(-987)).getDays());\n+        assertEquals(1, Days.standardDaysIn(Period.hours(47)).getDays());\n+        assertEquals(2, Days.standardDaysIn(Period.hours(48)).getDays());\n+        assertEquals(2, Days.standardDaysIn(Period.hours(49)).getDays());\n+        assertEquals(14, Days.standardDaysIn(Period.weeks(2)).getDays());\n+        try {\n+            Days.standardDaysIn(Period.months(1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    public void testFactory_parseDays_String() {\n+        assertEquals(0, Days.parseDays((String) null).getDays());\n+        assertEquals(0, Days.parseDays(\"P0D\").getDays());\n+        assertEquals(1, Days.parseDays(\"P1D\").getDays());\n+        assertEquals(-3, Days.parseDays(\"P-3D\").getDays());\n+        assertEquals(2, Days.parseDays(\"P0Y0M2D\").getDays());\n+        assertEquals(2, Days.parseDays(\"P2DT0H0M\").getDays());\n+        try {\n+            Days.parseDays(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Days.parseDays(\"P1DT1H\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Days test = Days.days(20);\n+        assertEquals(20, test.getDays());\n+    }\n+\n+    public void testGetFieldType() {\n+        Days test = Days.days(20);\n+        assertEquals(DurationFieldType.days(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Days test = Days.days(20);\n+        assertEquals(PeriodType.days(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Days test = Days.days(20);\n+        assertEquals(\"P20D\", test.toString());\n+        \n+        test = Days.days(-20);\n+        assertEquals(\"P-20D\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Days test = Days.SEVEN;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Days result = (Days) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardWeeks() {\n+        Days test = Days.days(14);\n+        Weeks expected = Weeks.weeks(2);\n+        assertEquals(expected, test.toStandardWeeks());\n+    }\n+\n+    public void testToStandardHours() {\n+        Days test = Days.days(2);\n+        Hours expected = Hours.hours(2 * 24);\n+        assertEquals(expected, test.toStandardHours());\n+        \n+        try {\n+            Days.MAX_VALUE.toStandardHours();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardMinutes() {\n+        Days test = Days.days(2);\n+        Minutes expected = Minutes.minutes(2 * 24 * 60);\n+        assertEquals(expected, test.toStandardMinutes());\n+        \n+        try {\n+            Days.MAX_VALUE.toStandardMinutes();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardSeconds() {\n+        Days test = Days.days(2);\n+        Seconds expected = Seconds.seconds(2 * 24 * 60 * 60);\n+        assertEquals(expected, test.toStandardSeconds());\n+        \n+        try {\n+            Days.MAX_VALUE.toStandardSeconds();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardDuration() {\n+        Days test = Days.days(20);\n+        Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_DAY);\n+        assertEquals(expected, test.toStandardDuration());\n+        \n+        expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_DAY);\n+        assertEquals(expected, Days.MAX_VALUE.toStandardDuration());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Days test2 = Days.days(2);\n+        Days result = test2.plus(3);\n+        assertEquals(2, test2.getDays());\n+        assertEquals(5, result.getDays());\n+        \n+        assertEquals(1, Days.ONE.plus(0).getDays());\n+        \n+        try {\n+            Days.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Days() {\n+        Days test2 = Days.days(2);\n+        Days test3 = Days.days(3);\n+        Days result = test2.plus(test3);\n+        assertEquals(2, test2.getDays());\n+        assertEquals(3, test3.getDays());\n+        assertEquals(5, result.getDays());\n+        \n+        assertEquals(1, Days.ONE.plus(Days.ZERO).getDays());\n+        assertEquals(1, Days.ONE.plus((Days) null).getDays());\n+        \n+        try {\n+            Days.MAX_VALUE.plus(Days.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Days test2 = Days.days(2);\n+        Days result = test2.minus(3);\n+        assertEquals(2, test2.getDays());\n+        assertEquals(-1, result.getDays());\n+        \n+        assertEquals(1, Days.ONE.minus(0).getDays());\n+        \n+        try {\n+            Days.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Days() {\n+        Days test2 = Days.days(2);\n+        Days test3 = Days.days(3);\n+        Days result = test2.minus(test3);\n+        assertEquals(2, test2.getDays());\n+        assertEquals(3, test3.getDays());\n+        assertEquals(-1, result.getDays());\n+        \n+        assertEquals(1, Days.ONE.minus(Days.ZERO).getDays());\n+        assertEquals(1, Days.ONE.minus((Days) null).getDays());\n+        \n+        try {\n+            Days.MIN_VALUE.minus(Days.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Days test = Days.days(2);\n+        assertEquals(6, test.multipliedBy(3).getDays());\n+        assertEquals(2, test.getDays());\n+        assertEquals(-6, test.multipliedBy(-3).getDays());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Days halfMax = Days.days(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Days test = Days.days(12);\n+        assertEquals(6, test.dividedBy(2).getDays());\n+        assertEquals(12, test.getDays());\n+        assertEquals(4, test.dividedBy(3).getDays());\n+        assertEquals(3, test.dividedBy(4).getDays());\n+        assertEquals(2, test.dividedBy(5).getDays());\n+        assertEquals(2, test.dividedBy(6).getDays());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Days.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Days test = Days.days(12);\n+        assertEquals(-12, test.negate().getDays());\n+        assertEquals(12, test.getDays());\n+        \n+        try {\n+            Days.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Days test = Days.days(20);\n+        LocalDate date = new LocalDate(2006, 6, 1);\n+        LocalDate expected = new LocalDate(2006, 6, 21);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestHours.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Hours.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestHours extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestHours.class);\n+    }\n+\n+    public TestHours(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Hours.ZERO.getHours());\n+        assertEquals(1, Hours.ONE.getHours());\n+        assertEquals(2, Hours.TWO.getHours());\n+        assertEquals(3, Hours.THREE.getHours());\n+        assertEquals(4, Hours.FOUR.getHours());\n+        assertEquals(5, Hours.FIVE.getHours());\n+        assertEquals(6, Hours.SIX.getHours());\n+        assertEquals(7, Hours.SEVEN.getHours());\n+        assertEquals(8, Hours.EIGHT.getHours());\n+        assertEquals(Integer.MAX_VALUE, Hours.MAX_VALUE.getHours());\n+        assertEquals(Integer.MIN_VALUE, Hours.MIN_VALUE.getHours());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_hours_int() {\n+        assertSame(Hours.ZERO, Hours.hours(0));\n+        assertSame(Hours.ONE, Hours.hours(1));\n+        assertSame(Hours.TWO, Hours.hours(2));\n+        assertSame(Hours.THREE, Hours.hours(3));\n+        assertSame(Hours.FOUR, Hours.hours(4));\n+        assertSame(Hours.FIVE, Hours.hours(5));\n+        assertSame(Hours.SIX, Hours.hours(6));\n+        assertSame(Hours.SEVEN, Hours.hours(7));\n+        assertSame(Hours.EIGHT, Hours.hours(8));\n+        assertSame(Hours.MAX_VALUE, Hours.hours(Integer.MAX_VALUE));\n+        assertSame(Hours.MIN_VALUE, Hours.hours(Integer.MIN_VALUE));\n+        assertEquals(-1, Hours.hours(-1).getHours());\n+        assertEquals(9, Hours.hours(9).getHours());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_hoursBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 15, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 18, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Hours.hoursBetween(start, end1).getHours());\n+        assertEquals(0, Hours.hoursBetween(start, start).getHours());\n+        assertEquals(0, Hours.hoursBetween(end1, end1).getHours());\n+        assertEquals(-3, Hours.hoursBetween(end1, start).getHours());\n+        assertEquals(6, Hours.hoursBetween(start, end2).getHours());\n+    }\n+\n+    public void testFactory_hoursBetween_RPartial() {\n+        LocalTime start = new LocalTime(12, 0);\n+        LocalTime end1 = new LocalTime(15, 0);\n+        TimeOfDay end2 = new TimeOfDay(18, 0);\n+        \n+        assertEquals(3, Hours.hoursBetween(start, end1).getHours());\n+        assertEquals(0, Hours.hoursBetween(start, start).getHours());\n+        assertEquals(0, Hours.hoursBetween(end1, end1).getHours());\n+        assertEquals(-3, Hours.hoursBetween(end1, start).getHours());\n+        assertEquals(6, Hours.hoursBetween(start, end2).getHours());\n+    }\n+\n+    public void testFactory_hoursIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 15, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 18, 0, 0, 0, PARIS);\n+        \n+        assertEquals(0, Hours.hoursIn((ReadableInterval) null).getHours());\n+        assertEquals(3, Hours.hoursIn(new Interval(start, end1)).getHours());\n+        assertEquals(0, Hours.hoursIn(new Interval(start, start)).getHours());\n+        assertEquals(0, Hours.hoursIn(new Interval(end1, end1)).getHours());\n+        assertEquals(6, Hours.hoursIn(new Interval(start, end2)).getHours());\n+    }\n+\n+    public void testFactory_standardHoursIn_RPeriod() {\n+        assertEquals(0, Hours.standardHoursIn((ReadablePeriod) null).getHours());\n+        assertEquals(0, Hours.standardHoursIn(Period.ZERO).getHours());\n+        assertEquals(1, Hours.standardHoursIn(new Period(0, 0, 0, 0, 1, 0, 0, 0)).getHours());\n+        assertEquals(123, Hours.standardHoursIn(Period.hours(123)).getHours());\n+        assertEquals(-987, Hours.standardHoursIn(Period.hours(-987)).getHours());\n+        assertEquals(1, Hours.standardHoursIn(Period.minutes(119)).getHours());\n+        assertEquals(2, Hours.standardHoursIn(Period.minutes(120)).getHours());\n+        assertEquals(2, Hours.standardHoursIn(Period.minutes(121)).getHours());\n+        assertEquals(48, Hours.standardHoursIn(Period.days(2)).getHours());\n+        try {\n+            Hours.standardHoursIn(Period.months(1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    public void testFactory_parseHours_String() {\n+        assertEquals(0, Hours.parseHours((String) null).getHours());\n+        assertEquals(0, Hours.parseHours(\"PT0H\").getHours());\n+        assertEquals(1, Hours.parseHours(\"PT1H\").getHours());\n+        assertEquals(-3, Hours.parseHours(\"PT-3H\").getHours());\n+        assertEquals(2, Hours.parseHours(\"P0Y0M0DT2H\").getHours());\n+        assertEquals(2, Hours.parseHours(\"PT2H0M\").getHours());\n+        try {\n+            Hours.parseHours(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Hours.parseHours(\"P1DT1H\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Hours test = Hours.hours(20);\n+        assertEquals(20, test.getHours());\n+    }\n+\n+    public void testGetFieldType() {\n+        Hours test = Hours.hours(20);\n+        assertEquals(DurationFieldType.hours(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Hours test = Hours.hours(20);\n+        assertEquals(PeriodType.hours(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Hours test = Hours.hours(20);\n+        assertEquals(\"PT20H\", test.toString());\n+        \n+        test = Hours.hours(-20);\n+        assertEquals(\"PT-20H\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Hours test = Hours.SEVEN;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Hours result = (Hours) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardWeeks() {\n+        Hours test = Hours.hours(24 * 7 * 2);\n+        Weeks expected = Weeks.weeks(2);\n+        assertEquals(expected, test.toStandardWeeks());\n+    }\n+\n+    public void testToStandardDays() {\n+        Hours test = Hours.hours(24 * 2);\n+        Days expected = Days.days(2);\n+        assertEquals(expected, test.toStandardDays());\n+    }\n+\n+    public void testToStandardMinutes() {\n+        Hours test = Hours.hours(3);\n+        Minutes expected = Minutes.minutes(3 * 60);\n+        assertEquals(expected, test.toStandardMinutes());\n+        \n+        try {\n+            Hours.MAX_VALUE.toStandardMinutes();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardSeconds() {\n+        Hours test = Hours.hours(3);\n+        Seconds expected = Seconds.seconds(3 * 60 * 60);\n+        assertEquals(expected, test.toStandardSeconds());\n+        \n+        try {\n+            Hours.MAX_VALUE.toStandardSeconds();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardDuration() {\n+        Hours test = Hours.hours(20);\n+        Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_HOUR);\n+        assertEquals(expected, test.toStandardDuration());\n+        \n+        expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_HOUR);\n+        assertEquals(expected, Hours.MAX_VALUE.toStandardDuration());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Hours test2 = Hours.hours(2);\n+        Hours result = test2.plus(3);\n+        assertEquals(2, test2.getHours());\n+        assertEquals(5, result.getHours());\n+        \n+        assertEquals(1, Hours.ONE.plus(0).getHours());\n+        \n+        try {\n+            Hours.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Hours() {\n+        Hours test2 = Hours.hours(2);\n+        Hours test3 = Hours.hours(3);\n+        Hours result = test2.plus(test3);\n+        assertEquals(2, test2.getHours());\n+        assertEquals(3, test3.getHours());\n+        assertEquals(5, result.getHours());\n+        \n+        assertEquals(1, Hours.ONE.plus(Hours.ZERO).getHours());\n+        assertEquals(1, Hours.ONE.plus((Hours) null).getHours());\n+        \n+        try {\n+            Hours.MAX_VALUE.plus(Hours.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Hours test2 = Hours.hours(2);\n+        Hours result = test2.minus(3);\n+        assertEquals(2, test2.getHours());\n+        assertEquals(-1, result.getHours());\n+        \n+        assertEquals(1, Hours.ONE.minus(0).getHours());\n+        \n+        try {\n+            Hours.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Hours() {\n+        Hours test2 = Hours.hours(2);\n+        Hours test3 = Hours.hours(3);\n+        Hours result = test2.minus(test3);\n+        assertEquals(2, test2.getHours());\n+        assertEquals(3, test3.getHours());\n+        assertEquals(-1, result.getHours());\n+        \n+        assertEquals(1, Hours.ONE.minus(Hours.ZERO).getHours());\n+        assertEquals(1, Hours.ONE.minus((Hours) null).getHours());\n+        \n+        try {\n+            Hours.MIN_VALUE.minus(Hours.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Hours test = Hours.hours(2);\n+        assertEquals(6, test.multipliedBy(3).getHours());\n+        assertEquals(2, test.getHours());\n+        assertEquals(-6, test.multipliedBy(-3).getHours());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Hours halfMax = Hours.hours(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Hours test = Hours.hours(12);\n+        assertEquals(6, test.dividedBy(2).getHours());\n+        assertEquals(12, test.getHours());\n+        assertEquals(4, test.dividedBy(3).getHours());\n+        assertEquals(3, test.dividedBy(4).getHours());\n+        assertEquals(2, test.dividedBy(5).getHours());\n+        assertEquals(2, test.dividedBy(6).getHours());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Hours.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Hours test = Hours.hours(12);\n+        assertEquals(-12, test.negate().getHours());\n+        assertEquals(12, test.getHours());\n+        \n+        try {\n+            Hours.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Hours test = Hours.hours(26);\n+        LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n+        LocalDateTime expected = new LocalDateTime(2006, 6, 2, 2, 0, 0, 0);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestMinutes.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Minutes.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMinutes extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestMinutes.class);\n+    }\n+\n+    public TestMinutes(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Minutes.ZERO.getMinutes());\n+        assertEquals(1, Minutes.ONE.getMinutes());\n+        assertEquals(2, Minutes.TWO.getMinutes());\n+        assertEquals(3, Minutes.THREE.getMinutes());\n+        assertEquals(Integer.MAX_VALUE, Minutes.MAX_VALUE.getMinutes());\n+        assertEquals(Integer.MIN_VALUE, Minutes.MIN_VALUE.getMinutes());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_minutes_int() {\n+        assertSame(Minutes.ZERO, Minutes.minutes(0));\n+        assertSame(Minutes.ONE, Minutes.minutes(1));\n+        assertSame(Minutes.TWO, Minutes.minutes(2));\n+        assertSame(Minutes.THREE, Minutes.minutes(3));\n+        assertSame(Minutes.MAX_VALUE, Minutes.minutes(Integer.MAX_VALUE));\n+        assertSame(Minutes.MIN_VALUE, Minutes.minutes(Integer.MIN_VALUE));\n+        assertEquals(-1, Minutes.minutes(-1).getMinutes());\n+        assertEquals(4, Minutes.minutes(4).getMinutes());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_minutesBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 3, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 12, 6, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 12, 9, 0, 0, PARIS);\n+        \n+        assertEquals(3, Minutes.minutesBetween(start, end1).getMinutes());\n+        assertEquals(0, Minutes.minutesBetween(start, start).getMinutes());\n+        assertEquals(0, Minutes.minutesBetween(end1, end1).getMinutes());\n+        assertEquals(-3, Minutes.minutesBetween(end1, start).getMinutes());\n+        assertEquals(6, Minutes.minutesBetween(start, end2).getMinutes());\n+    }\n+\n+    public void testFactory_minutesBetween_RPartial() {\n+        LocalTime start = new LocalTime(12, 3);\n+        LocalTime end1 = new LocalTime(12, 6);\n+        TimeOfDay end2 = new TimeOfDay(12, 9);\n+        \n+        assertEquals(3, Minutes.minutesBetween(start, end1).getMinutes());\n+        assertEquals(0, Minutes.minutesBetween(start, start).getMinutes());\n+        assertEquals(0, Minutes.minutesBetween(end1, end1).getMinutes());\n+        assertEquals(-3, Minutes.minutesBetween(end1, start).getMinutes());\n+        assertEquals(6, Minutes.minutesBetween(start, end2).getMinutes());\n+    }\n+\n+    public void testFactory_minutesIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 3, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 12, 6, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 12, 9, 0, 0, PARIS);\n+        \n+        assertEquals(0, Minutes.minutesIn((ReadableInterval) null).getMinutes());\n+        assertEquals(3, Minutes.minutesIn(new Interval(start, end1)).getMinutes());\n+        assertEquals(0, Minutes.minutesIn(new Interval(start, start)).getMinutes());\n+        assertEquals(0, Minutes.minutesIn(new Interval(end1, end1)).getMinutes());\n+        assertEquals(6, Minutes.minutesIn(new Interval(start, end2)).getMinutes());\n+    }\n+\n+    public void testFactory_standardMinutesIn_RPeriod() {\n+        assertEquals(0, Minutes.standardMinutesIn((ReadablePeriod) null).getMinutes());\n+        assertEquals(0, Minutes.standardMinutesIn(Period.ZERO).getMinutes());\n+        assertEquals(1, Minutes.standardMinutesIn(new Period(0, 0, 0, 0, 0, 1, 0, 0)).getMinutes());\n+        assertEquals(123, Minutes.standardMinutesIn(Period.minutes(123)).getMinutes());\n+        assertEquals(-987, Minutes.standardMinutesIn(Period.minutes(-987)).getMinutes());\n+        assertEquals(1, Minutes.standardMinutesIn(Period.seconds(119)).getMinutes());\n+        assertEquals(2, Minutes.standardMinutesIn(Period.seconds(120)).getMinutes());\n+        assertEquals(2, Minutes.standardMinutesIn(Period.seconds(121)).getMinutes());\n+        assertEquals(120, Minutes.standardMinutesIn(Period.hours(2)).getMinutes());\n+        try {\n+            Minutes.standardMinutesIn(Period.months(1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    public void testFactory_parseMinutes_String() {\n+        assertEquals(0, Minutes.parseMinutes((String) null).getMinutes());\n+        assertEquals(0, Minutes.parseMinutes(\"PT0M\").getMinutes());\n+        assertEquals(1, Minutes.parseMinutes(\"PT1M\").getMinutes());\n+        assertEquals(-3, Minutes.parseMinutes(\"PT-3M\").getMinutes());\n+        assertEquals(2, Minutes.parseMinutes(\"P0Y0M0DT2M\").getMinutes());\n+        assertEquals(2, Minutes.parseMinutes(\"PT0H2M\").getMinutes());\n+        try {\n+            Minutes.parseMinutes(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Minutes.parseMinutes(\"P1DT1M\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Minutes test = Minutes.minutes(20);\n+        assertEquals(20, test.getMinutes());\n+    }\n+\n+    public void testGetFieldType() {\n+        Minutes test = Minutes.minutes(20);\n+        assertEquals(DurationFieldType.minutes(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Minutes test = Minutes.minutes(20);\n+        assertEquals(PeriodType.minutes(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Minutes test = Minutes.minutes(20);\n+        assertEquals(\"PT20M\", test.toString());\n+        \n+        test = Minutes.minutes(-20);\n+        assertEquals(\"PT-20M\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Minutes test = Minutes.THREE;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Minutes result = (Minutes) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardWeeks() {\n+        Minutes test = Minutes.minutes(60 * 24 * 7 * 2);\n+        Weeks expected = Weeks.weeks(2);\n+        assertEquals(expected, test.toStandardWeeks());\n+    }\n+\n+    public void testToStandardDays() {\n+        Minutes test = Minutes.minutes(60 * 24 * 2);\n+        Days expected = Days.days(2);\n+        assertEquals(expected, test.toStandardDays());\n+    }\n+\n+    public void testToStandardHours() {\n+        Minutes test = Minutes.minutes(3 * 60);\n+        Hours expected = Hours.hours(3);\n+        assertEquals(expected, test.toStandardHours());\n+    }\n+\n+    public void testToStandardSeconds() {\n+        Minutes test = Minutes.minutes(3);\n+        Seconds expected = Seconds.seconds(3 * 60);\n+        assertEquals(expected, test.toStandardSeconds());\n+        \n+        try {\n+            Minutes.MAX_VALUE.toStandardSeconds();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardDuration() {\n+        Minutes test = Minutes.minutes(20);\n+        Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_MINUTE);\n+        assertEquals(expected, test.toStandardDuration());\n+        \n+        expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_MINUTE);\n+        assertEquals(expected, Minutes.MAX_VALUE.toStandardDuration());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Minutes test2 = Minutes.minutes(2);\n+        Minutes result = test2.plus(3);\n+        assertEquals(2, test2.getMinutes());\n+        assertEquals(5, result.getMinutes());\n+        \n+        assertEquals(1, Minutes.ONE.plus(0).getMinutes());\n+        \n+        try {\n+            Minutes.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Minutes() {\n+        Minutes test2 = Minutes.minutes(2);\n+        Minutes test3 = Minutes.minutes(3);\n+        Minutes result = test2.plus(test3);\n+        assertEquals(2, test2.getMinutes());\n+        assertEquals(3, test3.getMinutes());\n+        assertEquals(5, result.getMinutes());\n+        \n+        assertEquals(1, Minutes.ONE.plus(Minutes.ZERO).getMinutes());\n+        assertEquals(1, Minutes.ONE.plus((Minutes) null).getMinutes());\n+        \n+        try {\n+            Minutes.MAX_VALUE.plus(Minutes.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Minutes test2 = Minutes.minutes(2);\n+        Minutes result = test2.minus(3);\n+        assertEquals(2, test2.getMinutes());\n+        assertEquals(-1, result.getMinutes());\n+        \n+        assertEquals(1, Minutes.ONE.minus(0).getMinutes());\n+        \n+        try {\n+            Minutes.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Minutes() {\n+        Minutes test2 = Minutes.minutes(2);\n+        Minutes test3 = Minutes.minutes(3);\n+        Minutes result = test2.minus(test3);\n+        assertEquals(2, test2.getMinutes());\n+        assertEquals(3, test3.getMinutes());\n+        assertEquals(-1, result.getMinutes());\n+        \n+        assertEquals(1, Minutes.ONE.minus(Minutes.ZERO).getMinutes());\n+        assertEquals(1, Minutes.ONE.minus((Minutes) null).getMinutes());\n+        \n+        try {\n+            Minutes.MIN_VALUE.minus(Minutes.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Minutes test = Minutes.minutes(2);\n+        assertEquals(6, test.multipliedBy(3).getMinutes());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(-6, test.multipliedBy(-3).getMinutes());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Minutes halfMax = Minutes.minutes(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Minutes test = Minutes.minutes(12);\n+        assertEquals(6, test.dividedBy(2).getMinutes());\n+        assertEquals(12, test.getMinutes());\n+        assertEquals(4, test.dividedBy(3).getMinutes());\n+        assertEquals(3, test.dividedBy(4).getMinutes());\n+        assertEquals(2, test.dividedBy(5).getMinutes());\n+        assertEquals(2, test.dividedBy(6).getMinutes());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Minutes.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Minutes test = Minutes.minutes(12);\n+        assertEquals(-12, test.negate().getMinutes());\n+        assertEquals(12, test.getMinutes());\n+        \n+        try {\n+            Minutes.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Minutes test = Minutes.minutes(26);\n+        LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n+        LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 26, 0, 0);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestMonths.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Months.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMonths extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestMonths.class);\n+    }\n+\n+    public TestMonths(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Months.ZERO.getMonths());\n+        assertEquals(1, Months.ONE.getMonths());\n+        assertEquals(2, Months.TWO.getMonths());\n+        assertEquals(3, Months.THREE.getMonths());\n+        assertEquals(4, Months.FOUR.getMonths());\n+        assertEquals(5, Months.FIVE.getMonths());\n+        assertEquals(6, Months.SIX.getMonths());\n+        assertEquals(7, Months.SEVEN.getMonths());\n+        assertEquals(8, Months.EIGHT.getMonths());\n+        assertEquals(9, Months.NINE.getMonths());\n+        assertEquals(10, Months.TEN.getMonths());\n+        assertEquals(11, Months.ELEVEN.getMonths());\n+        assertEquals(12, Months.TWELVE.getMonths());\n+        assertEquals(Integer.MAX_VALUE, Months.MAX_VALUE.getMonths());\n+        assertEquals(Integer.MIN_VALUE, Months.MIN_VALUE.getMonths());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_months_int() {\n+        assertSame(Months.ZERO, Months.months(0));\n+        assertSame(Months.ONE, Months.months(1));\n+        assertSame(Months.TWO, Months.months(2));\n+        assertSame(Months.THREE, Months.months(3));\n+        assertSame(Months.FOUR, Months.months(4));\n+        assertSame(Months.FIVE, Months.months(5));\n+        assertSame(Months.SIX, Months.months(6));\n+        assertSame(Months.SEVEN, Months.months(7));\n+        assertSame(Months.EIGHT, Months.months(8));\n+        assertSame(Months.NINE, Months.months(9));\n+        assertSame(Months.TEN, Months.months(10));\n+        assertSame(Months.ELEVEN, Months.months(11));\n+        assertSame(Months.TWELVE, Months.months(12));\n+        assertSame(Months.MAX_VALUE, Months.months(Integer.MAX_VALUE));\n+        assertSame(Months.MIN_VALUE, Months.months(Integer.MIN_VALUE));\n+        assertEquals(-1, Months.months(-1).getMonths());\n+        assertEquals(13, Months.months(13).getMonths());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_monthsBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Months.monthsBetween(start, end1).getMonths());\n+        assertEquals(0, Months.monthsBetween(start, start).getMonths());\n+        assertEquals(0, Months.monthsBetween(end1, end1).getMonths());\n+        assertEquals(-3, Months.monthsBetween(end1, start).getMonths());\n+        assertEquals(6, Months.monthsBetween(start, end2).getMonths());\n+    }\n+\n+    public void testFactory_monthsBetween_RPartial() {\n+        LocalDate start = new LocalDate(2006, 6, 9);\n+        LocalDate end1 = new LocalDate(2006, 9, 9);\n+        YearMonthDay end2 = new YearMonthDay(2006, 12, 9);\n+        \n+        assertEquals(3, Months.monthsBetween(start, end1).getMonths());\n+        assertEquals(0, Months.monthsBetween(start, start).getMonths());\n+        assertEquals(0, Months.monthsBetween(end1, end1).getMonths());\n+        assertEquals(-3, Months.monthsBetween(end1, start).getMonths());\n+        assertEquals(6, Months.monthsBetween(start, end2).getMonths());\n+    }\n+\n+    public void testFactory_monthsIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(0, Months.monthsIn((ReadableInterval) null).getMonths());\n+        assertEquals(3, Months.monthsIn(new Interval(start, end1)).getMonths());\n+        assertEquals(0, Months.monthsIn(new Interval(start, start)).getMonths());\n+        assertEquals(0, Months.monthsIn(new Interval(end1, end1)).getMonths());\n+        assertEquals(6, Months.monthsIn(new Interval(start, end2)).getMonths());\n+    }\n+\n+    public void testFactory_parseMonths_String() {\n+        assertEquals(0, Months.parseMonths((String) null).getMonths());\n+        assertEquals(0, Months.parseMonths(\"P0M\").getMonths());\n+        assertEquals(1, Months.parseMonths(\"P1M\").getMonths());\n+        assertEquals(-3, Months.parseMonths(\"P-3M\").getMonths());\n+        assertEquals(2, Months.parseMonths(\"P0Y2M\").getMonths());\n+        assertEquals(2, Months.parseMonths(\"P2MT0H0M\").getMonths());\n+        try {\n+            Months.parseMonths(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Months.parseMonths(\"P1MT1H\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Months test = Months.months(20);\n+        assertEquals(20, test.getMonths());\n+    }\n+\n+    public void testGetFieldType() {\n+        Months test = Months.months(20);\n+        assertEquals(DurationFieldType.months(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Months test = Months.months(20);\n+        assertEquals(PeriodType.months(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Months test = Months.months(20);\n+        assertEquals(\"P20M\", test.toString());\n+        \n+        test = Months.months(-20);\n+        assertEquals(\"P-20M\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Months test = Months.THREE;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Months result = (Months) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Months test2 = Months.months(2);\n+        Months result = test2.plus(3);\n+        assertEquals(2, test2.getMonths());\n+        assertEquals(5, result.getMonths());\n+        \n+        assertEquals(1, Months.ONE.plus(0).getMonths());\n+        \n+        try {\n+            Months.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Months() {\n+        Months test2 = Months.months(2);\n+        Months test3 = Months.months(3);\n+        Months result = test2.plus(test3);\n+        assertEquals(2, test2.getMonths());\n+        assertEquals(3, test3.getMonths());\n+        assertEquals(5, result.getMonths());\n+        \n+        assertEquals(1, Months.ONE.plus(Months.ZERO).getMonths());\n+        assertEquals(1, Months.ONE.plus((Months) null).getMonths());\n+        \n+        try {\n+            Months.MAX_VALUE.plus(Months.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Months test2 = Months.months(2);\n+        Months result = test2.minus(3);\n+        assertEquals(2, test2.getMonths());\n+        assertEquals(-1, result.getMonths());\n+        \n+        assertEquals(1, Months.ONE.minus(0).getMonths());\n+        \n+        try {\n+            Months.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Months() {\n+        Months test2 = Months.months(2);\n+        Months test3 = Months.months(3);\n+        Months result = test2.minus(test3);\n+        assertEquals(2, test2.getMonths());\n+        assertEquals(3, test3.getMonths());\n+        assertEquals(-1, result.getMonths());\n+        \n+        assertEquals(1, Months.ONE.minus(Months.ZERO).getMonths());\n+        assertEquals(1, Months.ONE.minus((Months) null).getMonths());\n+        \n+        try {\n+            Months.MIN_VALUE.minus(Months.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Months test = Months.months(2);\n+        assertEquals(6, test.multipliedBy(3).getMonths());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(-6, test.multipliedBy(-3).getMonths());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Months halfMax = Months.months(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Months test = Months.months(12);\n+        assertEquals(6, test.dividedBy(2).getMonths());\n+        assertEquals(12, test.getMonths());\n+        assertEquals(4, test.dividedBy(3).getMonths());\n+        assertEquals(3, test.dividedBy(4).getMonths());\n+        assertEquals(2, test.dividedBy(5).getMonths());\n+        assertEquals(2, test.dividedBy(6).getMonths());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Months.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Months test = Months.months(12);\n+        assertEquals(-12, test.negate().getMonths());\n+        assertEquals(12, test.getMonths());\n+        \n+        try {\n+            Months.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Months test = Months.months(3);\n+        LocalDate date = new LocalDate(2006, 6, 1);\n+        LocalDate expected = new LocalDate(2006, 9, 1);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestSeconds.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Seconds.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSeconds extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestSeconds.class);\n+    }\n+\n+    public TestSeconds(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Seconds.ZERO.getSeconds());\n+        assertEquals(1, Seconds.ONE.getSeconds());\n+        assertEquals(2, Seconds.TWO.getSeconds());\n+        assertEquals(3, Seconds.THREE.getSeconds());\n+        assertEquals(Integer.MAX_VALUE, Seconds.MAX_VALUE.getSeconds());\n+        assertEquals(Integer.MIN_VALUE, Seconds.MIN_VALUE.getSeconds());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_seconds_int() {\n+        assertSame(Seconds.ZERO, Seconds.seconds(0));\n+        assertSame(Seconds.ONE, Seconds.seconds(1));\n+        assertSame(Seconds.TWO, Seconds.seconds(2));\n+        assertSame(Seconds.THREE, Seconds.seconds(3));\n+        assertSame(Seconds.MAX_VALUE, Seconds.seconds(Integer.MAX_VALUE));\n+        assertSame(Seconds.MIN_VALUE, Seconds.seconds(Integer.MIN_VALUE));\n+        assertEquals(-1, Seconds.seconds(-1).getSeconds());\n+        assertEquals(4, Seconds.seconds(4).getSeconds());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_secondsBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 3, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 12, 0, 6, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 12, 0, 9, 0, PARIS);\n+        \n+        assertEquals(3, Seconds.secondsBetween(start, end1).getSeconds());\n+        assertEquals(0, Seconds.secondsBetween(start, start).getSeconds());\n+        assertEquals(0, Seconds.secondsBetween(end1, end1).getSeconds());\n+        assertEquals(-3, Seconds.secondsBetween(end1, start).getSeconds());\n+        assertEquals(6, Seconds.secondsBetween(start, end2).getSeconds());\n+    }\n+\n+    public void testFactory_secondsBetween_RPartial() {\n+        LocalTime start = new LocalTime(12, 0, 3);\n+        LocalTime end1 = new LocalTime(12, 0, 6);\n+        TimeOfDay end2 = new TimeOfDay(12, 0, 9);\n+        \n+        assertEquals(3, Seconds.secondsBetween(start, end1).getSeconds());\n+        assertEquals(0, Seconds.secondsBetween(start, start).getSeconds());\n+        assertEquals(0, Seconds.secondsBetween(end1, end1).getSeconds());\n+        assertEquals(-3, Seconds.secondsBetween(end1, start).getSeconds());\n+        assertEquals(6, Seconds.secondsBetween(start, end2).getSeconds());\n+    }\n+\n+    public void testFactory_secondsIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 3, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 9, 12, 0, 6, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 6, 9, 12, 0, 9, 0, PARIS);\n+        \n+        assertEquals(0, Seconds.secondsIn((ReadableInterval) null).getSeconds());\n+        assertEquals(3, Seconds.secondsIn(new Interval(start, end1)).getSeconds());\n+        assertEquals(0, Seconds.secondsIn(new Interval(start, start)).getSeconds());\n+        assertEquals(0, Seconds.secondsIn(new Interval(end1, end1)).getSeconds());\n+        assertEquals(6, Seconds.secondsIn(new Interval(start, end2)).getSeconds());\n+    }\n+\n+    public void testFactory_standardSecondsIn_RPeriod() {\n+        assertEquals(0, Seconds.standardSecondsIn((ReadablePeriod) null).getSeconds());\n+        assertEquals(0, Seconds.standardSecondsIn(Period.ZERO).getSeconds());\n+        assertEquals(1, Seconds.standardSecondsIn(new Period(0, 0, 0, 0, 0, 0, 1, 0)).getSeconds());\n+        assertEquals(123, Seconds.standardSecondsIn(Period.seconds(123)).getSeconds());\n+        assertEquals(-987, Seconds.standardSecondsIn(Period.seconds(-987)).getSeconds());\n+        assertEquals(2 * 24 * 60 * 60, Seconds.standardSecondsIn(Period.days(2)).getSeconds());\n+        try {\n+            Seconds.standardSecondsIn(Period.months(1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    public void testFactory_parseSeconds_String() {\n+        assertEquals(0, Seconds.parseSeconds((String) null).getSeconds());\n+        assertEquals(0, Seconds.parseSeconds(\"PT0S\").getSeconds());\n+        assertEquals(1, Seconds.parseSeconds(\"PT1S\").getSeconds());\n+        assertEquals(-3, Seconds.parseSeconds(\"PT-3S\").getSeconds());\n+        assertEquals(2, Seconds.parseSeconds(\"P0Y0M0DT2S\").getSeconds());\n+        assertEquals(2, Seconds.parseSeconds(\"PT0H2S\").getSeconds());\n+        try {\n+            Seconds.parseSeconds(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Seconds.parseSeconds(\"P1DT1S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Seconds test = Seconds.seconds(20);\n+        assertEquals(20, test.getSeconds());\n+    }\n+\n+    public void testGetFieldType() {\n+        Seconds test = Seconds.seconds(20);\n+        assertEquals(DurationFieldType.seconds(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Seconds test = Seconds.seconds(20);\n+        assertEquals(PeriodType.seconds(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Seconds test = Seconds.seconds(20);\n+        assertEquals(\"PT20S\", test.toString());\n+        \n+        test = Seconds.seconds(-20);\n+        assertEquals(\"PT-20S\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Seconds test = Seconds.THREE;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Seconds result = (Seconds) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardWeeks() {\n+        Seconds test = Seconds.seconds(60 * 60 * 24 * 7 * 2);\n+        Weeks expected = Weeks.weeks(2);\n+        assertEquals(expected, test.toStandardWeeks());\n+    }\n+\n+    public void testToStandardDays() {\n+        Seconds test = Seconds.seconds(60 * 60 * 24 * 2);\n+        Days expected = Days.days(2);\n+        assertEquals(expected, test.toStandardDays());\n+    }\n+\n+    public void testToStandardHours() {\n+        Seconds test = Seconds.seconds(60 * 60 * 2);\n+        Hours expected = Hours.hours(2);\n+        assertEquals(expected, test.toStandardHours());\n+    }\n+\n+    public void testToStandardMinutes() {\n+        Seconds test = Seconds.seconds(60 * 2);\n+        Minutes expected = Minutes.minutes(2);\n+        assertEquals(expected, test.toStandardMinutes());\n+    }\n+\n+    public void testToStandardDuration() {\n+        Seconds test = Seconds.seconds(20);\n+        Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_SECOND);\n+        assertEquals(expected, test.toStandardDuration());\n+        \n+        expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_SECOND);\n+        assertEquals(expected, Seconds.MAX_VALUE.toStandardDuration());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Seconds test2 = Seconds.seconds(2);\n+        Seconds result = test2.plus(3);\n+        assertEquals(2, test2.getSeconds());\n+        assertEquals(5, result.getSeconds());\n+        \n+        assertEquals(1, Seconds.ONE.plus(0).getSeconds());\n+        \n+        try {\n+            Seconds.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Seconds() {\n+        Seconds test2 = Seconds.seconds(2);\n+        Seconds test3 = Seconds.seconds(3);\n+        Seconds result = test2.plus(test3);\n+        assertEquals(2, test2.getSeconds());\n+        assertEquals(3, test3.getSeconds());\n+        assertEquals(5, result.getSeconds());\n+        \n+        assertEquals(1, Seconds.ONE.plus(Seconds.ZERO).getSeconds());\n+        assertEquals(1, Seconds.ONE.plus((Seconds) null).getSeconds());\n+        \n+        try {\n+            Seconds.MAX_VALUE.plus(Seconds.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Seconds test2 = Seconds.seconds(2);\n+        Seconds result = test2.minus(3);\n+        assertEquals(2, test2.getSeconds());\n+        assertEquals(-1, result.getSeconds());\n+        \n+        assertEquals(1, Seconds.ONE.minus(0).getSeconds());\n+        \n+        try {\n+            Seconds.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Seconds() {\n+        Seconds test2 = Seconds.seconds(2);\n+        Seconds test3 = Seconds.seconds(3);\n+        Seconds result = test2.minus(test3);\n+        assertEquals(2, test2.getSeconds());\n+        assertEquals(3, test3.getSeconds());\n+        assertEquals(-1, result.getSeconds());\n+        \n+        assertEquals(1, Seconds.ONE.minus(Seconds.ZERO).getSeconds());\n+        assertEquals(1, Seconds.ONE.minus((Seconds) null).getSeconds());\n+        \n+        try {\n+            Seconds.MIN_VALUE.minus(Seconds.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Seconds test = Seconds.seconds(2);\n+        assertEquals(6, test.multipliedBy(3).getSeconds());\n+        assertEquals(2, test.getSeconds());\n+        assertEquals(-6, test.multipliedBy(-3).getSeconds());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Seconds halfMax = Seconds.seconds(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Seconds test = Seconds.seconds(12);\n+        assertEquals(6, test.dividedBy(2).getSeconds());\n+        assertEquals(12, test.getSeconds());\n+        assertEquals(4, test.dividedBy(3).getSeconds());\n+        assertEquals(3, test.dividedBy(4).getSeconds());\n+        assertEquals(2, test.dividedBy(5).getSeconds());\n+        assertEquals(2, test.dividedBy(6).getSeconds());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Seconds.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Seconds test = Seconds.seconds(12);\n+        assertEquals(-12, test.negate().getSeconds());\n+        assertEquals(12, test.getSeconds());\n+        \n+        try {\n+            Seconds.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Seconds test = Seconds.seconds(26);\n+        LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n+        LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 0, 26, 0);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestWeeks.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Weeks.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestWeeks extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestWeeks.class);\n+    }\n+\n+    public TestWeeks(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Weeks.ZERO.getWeeks());\n+        assertEquals(1, Weeks.ONE.getWeeks());\n+        assertEquals(2, Weeks.TWO.getWeeks());\n+        assertEquals(3, Weeks.THREE.getWeeks());\n+        assertEquals(Integer.MAX_VALUE, Weeks.MAX_VALUE.getWeeks());\n+        assertEquals(Integer.MIN_VALUE, Weeks.MIN_VALUE.getWeeks());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_weeks_int() {\n+        assertSame(Weeks.ZERO, Weeks.weeks(0));\n+        assertSame(Weeks.ONE, Weeks.weeks(1));\n+        assertSame(Weeks.TWO, Weeks.weeks(2));\n+        assertSame(Weeks.THREE, Weeks.weeks(3));\n+        assertSame(Weeks.MAX_VALUE, Weeks.weeks(Integer.MAX_VALUE));\n+        assertSame(Weeks.MIN_VALUE, Weeks.weeks(Integer.MIN_VALUE));\n+        assertEquals(-1, Weeks.weeks(-1).getWeeks());\n+        assertEquals(4, Weeks.weeks(4).getWeeks());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_weeksBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 30, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 7, 21, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Weeks.weeksBetween(start, end1).getWeeks());\n+        assertEquals(0, Weeks.weeksBetween(start, start).getWeeks());\n+        assertEquals(0, Weeks.weeksBetween(end1, end1).getWeeks());\n+        assertEquals(-3, Weeks.weeksBetween(end1, start).getWeeks());\n+        assertEquals(6, Weeks.weeksBetween(start, end2).getWeeks());\n+    }\n+\n+    public void testFactory_weeksBetween_RPartial() {\n+        LocalDate start = new LocalDate(2006, 6, 9);\n+        LocalDate end1 = new LocalDate(2006, 6, 30);\n+        YearMonthDay end2 = new YearMonthDay(2006, 7, 21);\n+        \n+        assertEquals(3, Weeks.weeksBetween(start, end1).getWeeks());\n+        assertEquals(0, Weeks.weeksBetween(start, start).getWeeks());\n+        assertEquals(0, Weeks.weeksBetween(end1, end1).getWeeks());\n+        assertEquals(-3, Weeks.weeksBetween(end1, start).getWeeks());\n+        assertEquals(6, Weeks.weeksBetween(start, end2).getWeeks());\n+    }\n+\n+    public void testFactory_weeksIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2006, 6, 30, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2006, 7, 21, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(0, Weeks.weeksIn((ReadableInterval) null).getWeeks());\n+        assertEquals(3, Weeks.weeksIn(new Interval(start, end1)).getWeeks());\n+        assertEquals(0, Weeks.weeksIn(new Interval(start, start)).getWeeks());\n+        assertEquals(0, Weeks.weeksIn(new Interval(end1, end1)).getWeeks());\n+        assertEquals(6, Weeks.weeksIn(new Interval(start, end2)).getWeeks());\n+    }\n+\n+    public void testFactory_standardWeeksIn_RPeriod() {\n+        assertEquals(0, Weeks.standardWeeksIn((ReadablePeriod) null).getWeeks());\n+        assertEquals(0, Weeks.standardWeeksIn(Period.ZERO).getWeeks());\n+        assertEquals(1, Weeks.standardWeeksIn(new Period(0, 0, 1, 0, 0, 0, 0, 0)).getWeeks());\n+        assertEquals(123, Weeks.standardWeeksIn(Period.weeks(123)).getWeeks());\n+        assertEquals(-987, Weeks.standardWeeksIn(Period.weeks(-987)).getWeeks());\n+        assertEquals(1, Weeks.standardWeeksIn(Period.days(13)).getWeeks());\n+        assertEquals(2, Weeks.standardWeeksIn(Period.days(14)).getWeeks());\n+        assertEquals(2, Weeks.standardWeeksIn(Period.days(15)).getWeeks());\n+        try {\n+            Weeks.standardWeeksIn(Period.months(1));\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    public void testFactory_parseWeeks_String() {\n+        assertEquals(0, Weeks.parseWeeks((String) null).getWeeks());\n+        assertEquals(0, Weeks.parseWeeks(\"P0W\").getWeeks());\n+        assertEquals(1, Weeks.parseWeeks(\"P1W\").getWeeks());\n+        assertEquals(-3, Weeks.parseWeeks(\"P-3W\").getWeeks());\n+        assertEquals(2, Weeks.parseWeeks(\"P0Y0M2W\").getWeeks());\n+        assertEquals(2, Weeks.parseWeeks(\"P2WT0H0M\").getWeeks());\n+        try {\n+            Weeks.parseWeeks(\"P1Y1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Weeks.parseWeeks(\"P1WT1H\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Weeks test = Weeks.weeks(20);\n+        assertEquals(20, test.getWeeks());\n+    }\n+\n+    public void testGetFieldType() {\n+        Weeks test = Weeks.weeks(20);\n+        assertEquals(DurationFieldType.weeks(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Weeks test = Weeks.weeks(20);\n+        assertEquals(PeriodType.weeks(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Weeks test = Weeks.weeks(20);\n+        assertEquals(\"P20W\", test.toString());\n+        \n+        test = Weeks.weeks(-20);\n+        assertEquals(\"P-20W\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Weeks test = Weeks.THREE;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Weeks result = (Weeks) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStandardDays() {\n+        Weeks test = Weeks.weeks(2);\n+        Days expected = Days.days(14);\n+        assertEquals(expected, test.toStandardDays());\n+        \n+        try {\n+            Weeks.MAX_VALUE.toStandardDays();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardHours() {\n+        Weeks test = Weeks.weeks(2);\n+        Hours expected = Hours.hours(2 * 7 * 24);\n+        assertEquals(expected, test.toStandardHours());\n+        \n+        try {\n+            Weeks.MAX_VALUE.toStandardHours();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardMinutes() {\n+        Weeks test = Weeks.weeks(2);\n+        Minutes expected = Minutes.minutes(2 * 7 * 24 * 60);\n+        assertEquals(expected, test.toStandardMinutes());\n+        \n+        try {\n+            Weeks.MAX_VALUE.toStandardMinutes();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardSeconds() {\n+        Weeks test = Weeks.weeks(2);\n+        Seconds expected = Seconds.seconds(2 * 7 * 24 * 60 * 60);\n+        assertEquals(expected, test.toStandardSeconds());\n+        \n+        try {\n+            Weeks.MAX_VALUE.toStandardSeconds();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testToStandardDuration() {\n+        Weeks test = Weeks.weeks(20);\n+        Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_WEEK);\n+        assertEquals(expected, test.toStandardDuration());\n+        \n+        expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_WEEK);\n+        assertEquals(expected, Weeks.MAX_VALUE.toStandardDuration());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Weeks test2 = Weeks.weeks(2);\n+        Weeks result = test2.plus(3);\n+        assertEquals(2, test2.getWeeks());\n+        assertEquals(5, result.getWeeks());\n+        \n+        assertEquals(1, Weeks.ONE.plus(0).getWeeks());\n+        \n+        try {\n+            Weeks.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Weeks() {\n+        Weeks test2 = Weeks.weeks(2);\n+        Weeks test3 = Weeks.weeks(3);\n+        Weeks result = test2.plus(test3);\n+        assertEquals(2, test2.getWeeks());\n+        assertEquals(3, test3.getWeeks());\n+        assertEquals(5, result.getWeeks());\n+        \n+        assertEquals(1, Weeks.ONE.plus(Weeks.ZERO).getWeeks());\n+        assertEquals(1, Weeks.ONE.plus((Weeks) null).getWeeks());\n+        \n+        try {\n+            Weeks.MAX_VALUE.plus(Weeks.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Weeks test2 = Weeks.weeks(2);\n+        Weeks result = test2.minus(3);\n+        assertEquals(2, test2.getWeeks());\n+        assertEquals(-1, result.getWeeks());\n+        \n+        assertEquals(1, Weeks.ONE.minus(0).getWeeks());\n+        \n+        try {\n+            Weeks.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Weeks() {\n+        Weeks test2 = Weeks.weeks(2);\n+        Weeks test3 = Weeks.weeks(3);\n+        Weeks result = test2.minus(test3);\n+        assertEquals(2, test2.getWeeks());\n+        assertEquals(3, test3.getWeeks());\n+        assertEquals(-1, result.getWeeks());\n+        \n+        assertEquals(1, Weeks.ONE.minus(Weeks.ZERO).getWeeks());\n+        assertEquals(1, Weeks.ONE.minus((Weeks) null).getWeeks());\n+        \n+        try {\n+            Weeks.MIN_VALUE.minus(Weeks.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Weeks test = Weeks.weeks(2);\n+        assertEquals(6, test.multipliedBy(3).getWeeks());\n+        assertEquals(2, test.getWeeks());\n+        assertEquals(-6, test.multipliedBy(-3).getWeeks());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Weeks halfMax = Weeks.weeks(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Weeks test = Weeks.weeks(12);\n+        assertEquals(6, test.dividedBy(2).getWeeks());\n+        assertEquals(12, test.getWeeks());\n+        assertEquals(4, test.dividedBy(3).getWeeks());\n+        assertEquals(3, test.dividedBy(4).getWeeks());\n+        assertEquals(2, test.dividedBy(5).getWeeks());\n+        assertEquals(2, test.dividedBy(6).getWeeks());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Weeks.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Weeks test = Weeks.weeks(12);\n+        assertEquals(-12, test.negate().getWeeks());\n+        assertEquals(12, test.getWeeks());\n+        \n+        try {\n+            Weeks.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Weeks test = Weeks.weeks(3);\n+        LocalDate date = new LocalDate(2006, 6, 1);\n+        LocalDate expected = new LocalDate(2006, 6, 22);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestYears.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Years.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestYears extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestYears.class);\n+    }\n+\n+    public TestYears(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstants() {\n+        assertEquals(0, Years.ZERO.getYears());\n+        assertEquals(1, Years.ONE.getYears());\n+        assertEquals(2, Years.TWO.getYears());\n+        assertEquals(3, Years.THREE.getYears());\n+        assertEquals(Integer.MAX_VALUE, Years.MAX_VALUE.getYears());\n+        assertEquals(Integer.MIN_VALUE, Years.MIN_VALUE.getYears());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_years_int() {\n+        assertSame(Years.ZERO, Years.years(0));\n+        assertSame(Years.ONE, Years.years(1));\n+        assertSame(Years.TWO, Years.years(2));\n+        assertSame(Years.THREE, Years.years(3));\n+        assertSame(Years.MAX_VALUE, Years.years(Integer.MAX_VALUE));\n+        assertSame(Years.MIN_VALUE, Years.years(Integer.MIN_VALUE));\n+        assertEquals(-1, Years.years(-1).getYears());\n+        assertEquals(4, Years.years(4).getYears());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory_yearsBetween_RInstant() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2009, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2012, 6, 9, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(3, Years.yearsBetween(start, end1).getYears());\n+        assertEquals(0, Years.yearsBetween(start, start).getYears());\n+        assertEquals(0, Years.yearsBetween(end1, end1).getYears());\n+        assertEquals(-3, Years.yearsBetween(end1, start).getYears());\n+        assertEquals(6, Years.yearsBetween(start, end2).getYears());\n+    }\n+\n+    public void testFactory_yearsBetween_RPartial() {\n+        LocalDate start = new LocalDate(2006, 6, 9);\n+        LocalDate end1 = new LocalDate(2009, 6, 9);\n+        YearMonthDay end2 = new YearMonthDay(2012, 6, 9);\n+        \n+        assertEquals(3, Years.yearsBetween(start, end1).getYears());\n+        assertEquals(0, Years.yearsBetween(start, start).getYears());\n+        assertEquals(0, Years.yearsBetween(end1, end1).getYears());\n+        assertEquals(-3, Years.yearsBetween(end1, start).getYears());\n+        assertEquals(6, Years.yearsBetween(start, end2).getYears());\n+    }\n+\n+    public void testFactory_yearsIn_RInterval() {\n+        DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end1 = new DateTime(2009, 6, 9, 12, 0, 0, 0, PARIS);\n+        DateTime end2 = new DateTime(2012, 6, 9, 12, 0, 0, 0, PARIS);\n+        \n+        assertEquals(0, Years.yearsIn((ReadableInterval) null).getYears());\n+        assertEquals(3, Years.yearsIn(new Interval(start, end1)).getYears());\n+        assertEquals(0, Years.yearsIn(new Interval(start, start)).getYears());\n+        assertEquals(0, Years.yearsIn(new Interval(end1, end1)).getYears());\n+        assertEquals(6, Years.yearsIn(new Interval(start, end2)).getYears());\n+    }\n+\n+    public void testFactory_parseYears_String() {\n+        assertEquals(0, Years.parseYears((String) null).getYears());\n+        assertEquals(0, Years.parseYears(\"P0Y\").getYears());\n+        assertEquals(1, Years.parseYears(\"P1Y\").getYears());\n+        assertEquals(-3, Years.parseYears(\"P-3Y\").getYears());\n+        assertEquals(2, Years.parseYears(\"P2Y0M\").getYears());\n+        assertEquals(2, Years.parseYears(\"P2YT0H0M\").getYears());\n+        try {\n+            Years.parseYears(\"P1M1D\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+        try {\n+            Years.parseYears(\"P1YT1H\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expeceted\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetMethods() {\n+        Years test = Years.years(20);\n+        assertEquals(20, test.getYears());\n+    }\n+\n+    public void testGetFieldType() {\n+        Years test = Years.years(20);\n+        assertEquals(DurationFieldType.years(), test.getFieldType());\n+    }\n+\n+    public void testGetPeriodType() {\n+        Years test = Years.years(20);\n+        assertEquals(PeriodType.years(), test.getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Years test = Years.years(20);\n+        assertEquals(\"P20Y\", test.toString());\n+        \n+        test = Years.years(-20);\n+        assertEquals(\"P-20Y\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Years test = Years.THREE;\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Years result = (Years) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPlus_int() {\n+        Years test2 = Years.years(2);\n+        Years result = test2.plus(3);\n+        assertEquals(2, test2.getYears());\n+        assertEquals(5, result.getYears());\n+        \n+        assertEquals(1, Years.ONE.plus(0).getYears());\n+        \n+        try {\n+            Years.MAX_VALUE.plus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPlus_Years() {\n+        Years test2 = Years.years(2);\n+        Years test3 = Years.years(3);\n+        Years result = test2.plus(test3);\n+        assertEquals(2, test2.getYears());\n+        assertEquals(3, test3.getYears());\n+        assertEquals(5, result.getYears());\n+        \n+        assertEquals(1, Years.ONE.plus(Years.ZERO).getYears());\n+        assertEquals(1, Years.ONE.plus((Years) null).getYears());\n+        \n+        try {\n+            Years.MAX_VALUE.plus(Years.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_int() {\n+        Years test2 = Years.years(2);\n+        Years result = test2.minus(3);\n+        assertEquals(2, test2.getYears());\n+        assertEquals(-1, result.getYears());\n+        \n+        assertEquals(1, Years.ONE.minus(0).getYears());\n+        \n+        try {\n+            Years.MIN_VALUE.minus(1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMinus_Years() {\n+        Years test2 = Years.years(2);\n+        Years test3 = Years.years(3);\n+        Years result = test2.minus(test3);\n+        assertEquals(2, test2.getYears());\n+        assertEquals(3, test3.getYears());\n+        assertEquals(-1, result.getYears());\n+        \n+        assertEquals(1, Years.ONE.minus(Years.ZERO).getYears());\n+        assertEquals(1, Years.ONE.minus((Years) null).getYears());\n+        \n+        try {\n+            Years.MIN_VALUE.minus(Years.ONE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMultipliedBy_int() {\n+        Years test = Years.years(2);\n+        assertEquals(6, test.multipliedBy(3).getYears());\n+        assertEquals(2, test.getYears());\n+        assertEquals(-6, test.multipliedBy(-3).getYears());\n+        assertSame(test, test.multipliedBy(1));\n+        \n+        Years halfMax = Years.years(Integer.MAX_VALUE / 2 + 1);\n+        try {\n+            halfMax.multipliedBy(2);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testDividedBy_int() {\n+        Years test = Years.years(12);\n+        assertEquals(6, test.dividedBy(2).getYears());\n+        assertEquals(12, test.getYears());\n+        assertEquals(4, test.dividedBy(3).getYears());\n+        assertEquals(3, test.dividedBy(4).getYears());\n+        assertEquals(2, test.dividedBy(5).getYears());\n+        assertEquals(2, test.dividedBy(6).getYears());\n+        assertSame(test, test.dividedBy(1));\n+        \n+        try {\n+            Years.ONE.dividedBy(0);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testNegate() {\n+        Years test = Years.years(12);\n+        assertEquals(-12, test.negate().getYears());\n+        assertEquals(12, test.getYears());\n+        \n+        try {\n+            Years.MIN_VALUE.negate();\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddToLocalDate() {\n+        Years test = Years.years(3);\n+        LocalDate date = new LocalDate(2006, 6, 1);\n+        LocalDate expected = new LocalDate(2009, 6, 1);\n+        assertEquals(expected, date.plus(test));\n+    }\n+\n+}", "timestamp": 1160414031, "metainfo": ""}