{"sha": "58ebc40ac4ce4fba5c838968936d7f130dde2141", "log": "Rename PartialInstant to ReadablePartial   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n  */\n package org.joda.time;\n \n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Chronology provides access to the individual date time fields for a\n      * @param instant  the partial instant to validate\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    void validate(PartialInstant instant);\n+    void validate(ReadablePartial instant);\n \n     // Millis\n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n \n import java.util.Locale;\n \n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Defines the calculation engine for date and time fields.\n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public abstract String getAsText(PartialInstant partial, int fieldValue, Locale locale);\n+    public abstract String getAsText(ReadablePartial partial, int fieldValue, Locale locale);\n \n     /**\n      * Get the human-readable, text value of this field from a partial instant.\n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public String getAsText(PartialInstant partial, Locale locale) {\n+    public String getAsText(ReadablePartial partial, Locale locale) {\n         return getAsText(partial, partial.get(this), locale);\n     }\n \n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public abstract String getAsShortText(PartialInstant partial, int fieldValue, Locale locale);\n+    public abstract String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale);\n \n     /**\n      * Get the human-readable, short text value of this field from a partial instant.\n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public String getAsShortText(PartialInstant partial, Locale locale) {\n+    public String getAsShortText(ReadablePartial partial, Locale locale) {\n         return getAsShortText(partial, partial.get(this), locale);\n     }\n \n      * @return the passed in values\n      * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n      */\n-    public abstract int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);\n+    public abstract int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n \n     /**\n      * Adds a value (which may be negative) to the millis value,\n      * @return the passed in values\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public abstract int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);\n+    public abstract int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n \n     /**\n      * Computes the difference between two instants, as measured in the units\n      * @return the passed in values\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue);\n+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text value.\n      * @return the passed in values\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    public abstract int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale);\n+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale);\n \n     /**\n      * Sets a value in the milliseconds supplied from a human-readable, text value.\n      * @param instant  the partial instant to query\n      * @return the minimum value for this field, in the units of the field\n      */\n-    public abstract int getMinimumValue(PartialInstant instant);\n+    public abstract int getMinimumValue(ReadablePartial instant);\n \n     /**\n      * Get the minimum value for this field using the partial instant and\n      * @param values  the values to use\n      * @return the minimum value for this field, in the units of the field\n      */\n-    public abstract int getMinimumValue(PartialInstant instant, int[] values);\n+    public abstract int getMinimumValue(ReadablePartial instant, int[] values);\n \n     /**\n      * Get the maximum allowable value for this field.\n      * @param instant  the partial instant to query\n      * @return the maximum value for this field, in the units of the field\n      */\n-    public abstract int getMaximumValue(PartialInstant instant);\n+    public abstract int getMaximumValue(ReadablePartial instant);\n \n     /**\n      * Get the maximum value for this field using the partial instant and\n      * @param values  the values to use\n      * @return the maximum value for this field, in the units of the field\n      */\n-    public abstract int getMaximumValue(PartialInstant instant, int[] values);\n+    public abstract int getMaximumValue(ReadablePartial instant, int[] values);\n \n     /**\n      * Get the maximum text value for this field.\n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java\n import org.joda.time.DurationField;\n import org.joda.time.field.UnsupportedDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * AbstractChronology provides a skeleton implementation for chronology\n      * @param instant  the partial instant to validate\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    public void validate(PartialInstant instant) {\n+    public void validate(ReadablePartial instant) {\n         DateTimeField[] fields = instant.getFields();\n         int[] values = instant.getValues();\n         for (int i = 0; i < fields.length; i++) {\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the month component of time.\n \t\treturn iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;\n     }\n \n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         if (instant.isSupported(iChronology.monthOfYear())) {\n             int month = instant.get(iChronology.monthOfYear());\n             if (month <= 12) {\n         return 30;\n     }\n \n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         DateTimeField[] fields = instant.getFields();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] == iChronology.monthOfYear()) {\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the month component of time.\n         return iChronology.getDaysInYearMonth(thisYear, thisMonth);\n     }\n \n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         if (instant.isSupported(iChronology.monthOfYear())) {\n             int month = instant.get(iChronology.monthOfYear());\n             if (instant.isSupported(iChronology.year())) {\n         return 31;\n     }\n \n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         DateTimeField[] fields = instant.getFields();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] == iChronology.monthOfYear()) {\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the day of the year component of time.\n         return iChronology.getDaysInYear(year);\n     }\n \n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         if (instant.isSupported(iChronology.year())) {\n             int year = instant.get(iChronology.year());\n             return iChronology.getDaysInYear(year);\n         return 366;\n     }\n \n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         DateTimeField[] fields = instant.getFields();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] == iChronology.year()) {\n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the week of a week based year component of time.\n         return iChronology.getWeeksInYear(weekyear);\n     }\n \n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         if (instant.isSupported(iChronology.weekyear())) {\n             int weekyear = instant.get(iChronology.weekyear());\n             return iChronology.getWeeksInYear(weekyear);\n         return 53;\n     }\n \n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         DateTimeField[] fields = instant.getFields();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] == iChronology.weekyear()) {\n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Provides time calculations for the year of era component of time.\n         return getWrappedField().addWrapped(instant, years);\n     }\n \n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {\n         return getWrappedField().addInField(instant, fieldIndex, values, years);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * This field is not publicy exposed by ISOChronology, but rather it is used to\n         return getWrappedField().addWrapped(instant, years);\n     }\n \n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int years) {\n         return getWrappedField().addInField(instant, fieldIndex, values, years);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * BaseDateTimeField provides the common behaviour for DateTimeField\n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n         return getAsText(fieldValue, locale);\n     }\n \n      * @param locale  the locale to use for selecting a text symbol, null for default\n      * @return the text value of the field\n      */\n-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n         return getAsShortText(fieldValue, locale);\n     }\n \n      * @return the passed in values\n      * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n      */\n-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n      * @return the passed in values\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         int current = values[fieldIndex];\n         int wrapped = FieldUtils.getWrappedValue\n             (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n      * @return the updated values\n      * @throws IllegalArgumentException if the value is invalid\n      */\n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n         FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n         values[fieldIndex] = newValue;\n         \n      * @return the passed in values\n      * @throws IllegalArgumentException if the text value is invalid\n      */\n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n         int value = convertText(text, locale);\n         return set(instant, fieldIndex, values, value);\n     }\n      * @param instant  the partial instant to query\n      * @return the minimum value for this field, in the units of the field\n      */\n-    public int getMinimumValue(PartialInstant instant) {\n+    public int getMinimumValue(ReadablePartial instant) {\n         return getMinimumValue();\n     }\n \n      * @param values  the values to use\n      * @return the minimum value for this field, in the units of the field\n      */\n-    public int getMinimumValue(PartialInstant instant, int[] values) {\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n         return getMinimumValue(instant);\n     }\n \n      * @param instant  the partial instant to query\n      * @return the maximum value for this field, in the units of the field\n      */\n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         return getMaximumValue();\n     }\n \n      * @param values  the values to use\n      * @return the maximum value for this field, in the units of the field\n      */\n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         return getMaximumValue(instant);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * <code>DelegatedDateTimeField</code> delegates each method call to the\n         return iField.getAsText(instant);\n     }\n \n-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n         return iField.getAsText(partial, fieldValue, locale);\n     }\n \n-    public String getAsText(PartialInstant partial, Locale locale) {\n+    public String getAsText(ReadablePartial partial, Locale locale) {\n         return iField.getAsText(partial, locale);\n     }\n \n         return iField.getAsShortText(instant);\n     }\n \n-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n         return iField.getAsShortText(partial, fieldValue, locale);\n     }\n \n-    public String getAsShortText(PartialInstant partial, Locale locale) {\n+    public String getAsShortText(ReadablePartial partial, Locale locale) {\n         return iField.getAsShortText(partial, locale);\n     }\n \n         return iField.add(instant, value);\n     }\n \n-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         return iField.add(instant, fieldIndex, values, valueToAdd);\n     }\n \n         return iField.addWrapped(instant, value);\n     }\n \n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         return iField.addInField(instant, fieldIndex, values, valueToAdd);\n     }\n \n         return iField.set(instant, text);\n     }\n \n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n         return iField.set(instant, fieldIndex, values, newValue);\n     }\n \n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n         return iField.set(instant, fieldIndex, values, text, locale);\n     }\n \n         return iField.getMinimumValue(instant);\n     }\n \n-    public int getMinimumValue(PartialInstant instant) {\n+    public int getMinimumValue(ReadablePartial instant) {\n         return iField.getMinimumValue(instant);\n     }\n \n-    public int getMinimumValue(PartialInstant instant, int[] values) {\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n         return iField.getMinimumValue(instant, values);\n     }\n \n         return iField.getMaximumValue(instant);\n     }\n \n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         return iField.getMaximumValue(instant);\n     }\n \n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         return iField.getMaximumValue(instant, values);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * Wraps another field such that zero values are replaced with one more than\n         return getWrappedField().addWrapped(instant, value);\n     }\n \n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         return getWrappedField().addInField(instant, fieldIndex, values, valueToAdd);\n     }\n \n      * \n      * @return the minimum value of 1\n      */\n-    public int getMinimumValue(PartialInstant instant) {\n-        return 1;\n-    }\n-\n-    /**\n-     * Always returns 1.\n-     * \n-     * @return the minimum value of 1\n-     */\n-    public int getMinimumValue(PartialInstant instant, int[] values) {\n+    public int getMinimumValue(ReadablePartial instant) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n         return 1;\n     }\n \n      * \n      * @return the maximum value\n      */\n-    public int getMaximumValue(PartialInstant instant) {\n+    public int getMaximumValue(ReadablePartial instant) {\n         return getWrappedField().getMaximumValue(instant) + 1;\n     }\n \n      * \n      * @return the maximum value\n      */\n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         return getWrappedField().getMaximumValue(instant, values) + 1;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.partial.PartialInstant;\n+import org.joda.time.partial.ReadablePartial;\n \n /**\n  * A placeholder implementation to use when a datetime field is not supported.\n      *\n      * @throws UnsupportedOperationException\n      */\n-    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+    public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int getMinimumValue(PartialInstant instant) {\n-        throw unsupported();\n-    }\n-\n-    /**\n-     * Always throws UnsupportedOperationException\n-     *\n-     * @throws UnsupportedOperationException\n-     */\n-    public int getMinimumValue(PartialInstant instant, int[] values) {\n+    public int getMinimumValue(ReadablePartial instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n         throw unsupported();\n     }\n \n      *\n      * @throws UnsupportedOperationException\n      */\n-    public int getMaximumValue(PartialInstant instant) {\n-        throw unsupported();\n-    }\n-\n-    /**\n-     * Always throws UnsupportedOperationException\n-     *\n-     * @throws UnsupportedOperationException\n-     */\n-    public int getMaximumValue(PartialInstant instant, int[] values) {\n+    public int getMaximumValue(ReadablePartial instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n         throw unsupported();\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * AbstractPartial provides a standard base implementation of most methods\n+ * in the ReadablePartial interface.\n+ * <p>\n+ * Calculations on are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * AbstractPartial allows subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartial implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2353678632973660L;\n+\n+    /** The chronology in use */\n+    protected Chronology iChronology;\n+    /** The values of each field in this partial */\n+    protected int[] iValues;\n+    /** The values of each field in this partial */\n+    protected transient DateTimeField[] iFields;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a AbstractPartial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public AbstractPartial() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public AbstractPartial(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(long instant, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public AbstractPartial(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant);\n+        Chronology chronology = converter.getChronology(instant);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, null means ISOChronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public AbstractPartial(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        long millis = converter.getInstantMillis(instant, chronology);\n+        chronology = converter.getChronology(instant, chronology);\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = initValues(millis, chronology);\n+    }\n+\n+    /**\n+     * Constructs a AbstractPartial with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param values  the new set of values\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public AbstractPartial(int[] values, Chronology chronology) {\n+        super();\n+        if (chronology == null) {\n+            chronology = ISOChronology.getInstance();\n+        }\n+        iChronology = chronology.withUTC();\n+        iFields = initFields(iChronology);\n+        iValues = values;\n+        chronology.validate(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Recreates the state of this object after deserialization.\n+     * \n+     * @param in  the input stream\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        iFields = initFields(iChronology);\n+    }\n+\n+    /**\n+     * Initialize the array of fields.\n+     * The field and value arrays must match.\n+     * \n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract DateTimeField[] initFields(Chronology chrono);\n+\n+    /**\n+     * Initialize the array of values.\n+     * The field and value arrays must match.\n+     * \n+     * @param instant  the instant to use\n+     * @param chrono  the chronology to use\n+     */\n+    protected abstract int[] initValues(long instant, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return iFields.length;\n+    }\n+\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        if (index < 0 || index >= iFields.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iFields[index];\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        if (index < 0 || index >= iValues.length) {\n+            throw new IllegalArgumentException(Integer.toString(index));\n+        }\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        return (DateTimeField[]) iFields.clone();\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public int get(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return iValues[i];\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeField field) {\n+        for (int i = 0; i < iFields.length; i++) {\n+            if (iFields[i] == field) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial set using the time zone specified.\n+     *\n+     * @param baseInstant  source of missing fields\n+     * @param zone  the time zone to use, null means default\n+     * @return the combined instant in milliseconds\n+     */\n+    public long resolve(long baseInstant, DateTimeZone zone) {\n+        Chronology chrono = iChronology.withZone(zone);\n+        return resolve(baseInstant, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    public DateTime resolveDateTime(ReadableInstant baseInstant) {\n+        long resolved;\n+        Chronology chrono;\n+        if (baseInstant == null) {\n+            chrono = ISOChronology.getInstance();\n+            resolved = resolve(DateTimeUtils.currentTimeMillis(), chrono);\n+        } else {\n+            chrono = baseInstant.getChronology();\n+            resolved = resolve(baseInstant.getMillis(), chrono);\n+        }\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    /**\n+     * Resolves this partial into another complete instant setting the relevant\n+     * fields on the writable instant. The combination is performed using the\n+     * chronology of the specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the input writable\n+     * instant will be updated with the time from this partial.\n+     *\n+     * @param baseInstant  the instant to set into, must not be null\n+     * @throws IllegalArgumentException if the base instant is null\n+     */\n+    public void resolveInto(ReadWritableInstant baseInstant) {\n+        if (baseInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        Chronology chrono = baseInstant.getChronology();\n+        long resolved = resolve(baseInstant.getMillis(), chrono);\n+        baseInstant.setMillis(resolved);\n+    }\n+\n+    /**\n+     * Resolve this partial into the base millis using the specified chronology.\n+     * \n+     * @param baseInstant  the base millisecond instant\n+     * @param chrono  the chronology\n+     * @return the new resolved millis\n+     */\n+    protected long resolve(long baseInstant, Chronology chrono) {\n+        long millis = baseInstant;\n+        for (int i = 0; i < iFields.length; i++) {\n+            millis = iFields[i].set(millis, iValues[i]);\n+        }\n+        return millis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * fields and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        if (partial instanceof AbstractPartial) {\n+            AbstractPartial other = (AbstractPartial) partial;\n+            return Arrays.equals(iValues, other.iValues) &&\n+                   Arrays.equals(iFields, other.iFields) &&\n+                   iChronology == other.iChronology;\n+        } else if (partial instanceof ReadablePartial) {\n+            ReadablePartial other = (ReadablePartial) partial;\n+            return Arrays.equals(iValues, other.getValues()) &&\n+                   Arrays.equals(iFields, other.getFields()) &&\n+                   iChronology == other.getChronology();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the ReadablePartial that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int total = 157;\n+        for (int i = 0; i < iFields.length; i++) {\n+            total = 23 * total + iValues[i];\n+            total = 23 * total + iFields[i].hashCode();\n+        }\n+        total += iChronology.hashCode();\n+        return total;\n+    }\n+\n+    /**\n+     * Output the time in an ISO8601 format.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        // TODO\n+        return \"\";\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/partial/AbstractPartialFieldProperty.java\n \n /**\n  * AbstractPartialFieldProperty is a base class for binding a\n- * PartialInstant to a DateTimeField.\n+ * ReadablePartial to a DateTimeField.\n  * <p>\n  * It allows the date and time manipulation code to be field based yet\n  * still easy to use.\n      * \n      * @return the partial instant\n      */\n-    public abstract PartialInstant getPartialInstant();\n+    public abstract ReadablePartial getReadablePartial();\n \n     //-----------------------------------------------------------------------\n     /**\n      * @see DateTimeField#getAsText\n      */\n     public String getAsText(Locale locale) {\n-        return getField().getAsText(getPartialInstant(), get(), locale);\n+        return getField().getAsText(getReadablePartial(), get(), locale);\n     }\n \n     /**\n      * @see DateTimeField#getAsShortText\n      */\n     public String getAsShortText(Locale locale) {\n-        return getField().getAsShortText(getPartialInstant(), get(), locale);\n+        return getField().getAsShortText(getReadablePartial(), get(), locale);\n     }\n \n     /**\n      * @see DateTimeField#getMinimumValue\n      */\n     public int getMinimumValue() {\n-        return getField().getMinimumValue(getPartialInstant());\n+        return getField().getMinimumValue(getReadablePartial());\n     }\n \n     /**\n      * @see DateTimeField#getMaximumValue\n      */\n     public int getMaximumValue() {\n-        return getField().getMaximumValue(getPartialInstant());\n+        return getField().getMaximumValue(getReadablePartial());\n     }\n \n     //-----------------------------------------------------------------------\n      * Compare this field to the same field on another partial instant.\n      * <p>\n      * The {@link #get()} method is used to obtain the value to compare for\n-     * this instant and the {@link PartialInstant#get(DateTimeField)} method\n+     * this instant and the {@link ReadablePartial#get(DateTimeField)} method\n      * is used for the specified instant.\n      * \n      * @param instant  the instant to compare to\n      * @throws IllegalArgumentException if the field of this property cannot be queried\n      *  on the specified instant\n      */\n-    public int compareTo(PartialInstant instant) {\n+    public int compareTo(ReadablePartial instant) {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/partial/ReadablePartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * Defines an partial time that does not support every datetime field.\n+ * <p>\n+ * A <code>ReadablePartial</code> supports a set of fields which be be a\n+ * subset of those on the chronology.\n+ * A <code>ReadablePartial</code> cannot be compared to a <code>ReadableInstant</code>.\n+ * <p>\n+ * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>\n+ * using one of the <code>resolve</code> methods. These work by providing a full base\n+ * instant that can be used to 'fill in the gaps'.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface ReadablePartial {\n+\n+    /**\n+     * Gets the number of fields that this partial supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    int getFieldSize();\n+\n+    /**\n+     * Gets the field at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DateTimeField getField(int index);\n+\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported (cloned), largest to smallest\n+     */\n+    DateTimeField[] getFields();\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    int getValue(int index);\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    int[] getValues();\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeField instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    int get(DateTimeField field);\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DateTimeField field);\n+\n+    /**\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial set using the time zone specified.\n+     *\n+     * @param baseInstant  source of missing fields\n+     * @param zone  the time zone to use, null means default\n+     * @return the combined instant in milliseconds\n+     */\n+    long resolve(long baseInstant, DateTimeZone zone);\n+\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    DateTime resolveDateTime(ReadableInstant baseInstant);\n+\n+    /**\n+     * Resolves this partial into another complete instant setting the relevant\n+     * fields on the writable instant. The combination is performed using the\n+     * chronology of the specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the input writable\n+     * instant will be updated with the time from this partial.\n+     *\n+     * @param baseInstant  the instant to set into, must not be null\n+     * @throws IllegalArgumentException if the base instant is null\n+     */\n+    void resolveInto(ReadWritableInstant baseInstant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this partial with the specified object for equality based\n+     * on the supported fields, chronology and values.\n+     * <p>\n+     * Two instances of ReadablePartial are equal if they have the same\n+     * chronology, same fields in same order and same values.\n+     *\n+     * @param partial  the object to compare to\n+     * @return true if equal\n+     */\n+    boolean equals(Object partial);\n+\n+    /**\n+     * Gets a hash code for the partial that is compatible with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be:\n+     * <pre>\n+     *  int total = 157;\n+     *  for (int i = 0; i < fields.length; i++) {\n+     *      total = 23 * total + values[i];\n+     *      total = 23 * total + fields[i].hashCode();\n+     *  }\n+     *  total += chronology.hashCode();\n+     *  return total;\n+     * </pre>\n+     *\n+     * @return a suitable hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n import org.joda.time.DateTimeField;\n \n /**\n- * TimeOfDay is an immutable partial instant supporting the hour, minute, second\n+ * TimeOfDay is an immutable partial supporting the hour, minute, second\n  * and millisecond fields.\n  * <p>\n  * Calculations on TimeOfDay are performed using a {@link Chronology}.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class TimeOfDay extends AbstractPartialInstant implements PartialInstant, Serializable {\n+public final class TimeOfDay extends AbstractPartial implements ReadablePartial, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3633353405803318660L;\n      */\n     public static class Property extends AbstractPartialFieldProperty {\n \n-        /** The instant */\n-        private final TimeOfDay iInstant;\n+        /** The partial */\n+        private final TimeOfDay iTimeOfDay;\n         /** The field index */\n         private final int iFieldIndex;\n \n         /**\n          * Constructs a property.\n          * \n-         * @param instant  the partial instant\n+         * @param partial  the partial instance\n          * @param field  the field\n-         * @param fieldIndex  the index in the instant\n-         */\n-        Property(TimeOfDay instant, int fieldIndex) {\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(TimeOfDay partial, int fieldIndex) {\n             super();\n-            iInstant = instant;\n+            iTimeOfDay = partial;\n             iFieldIndex = fieldIndex;\n         }\n \n          * @return the field\n          */\n         public DateTimeField getField() {\n-            return iInstant.getField(iFieldIndex);\n-        }\n-\n-        /**\n-         * Gets the instant that this property belongs to.\n-         * \n-         * @return the partial instant\n-         */\n-        public PartialInstant getPartialInstant() {\n-            return iInstant;\n-        }\n-\n-        /**\n-         * Gets the instant that this property belongs to.\n-         * \n-         * @return the partial instant\n+            return iTimeOfDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public ReadablePartial getReadablePartial() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n          */\n         public TimeOfDay getTimeOfDay() {\n-            return iInstant;\n-        }\n-\n-        /**\n-         * Gets the value of the field that the partial instant is set to.\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n          * \n          * @return the field value\n          */\n         public int get() {\n-            return iInstant.getValue(iFieldIndex);\n+            return iTimeOfDay.getValue(iFieldIndex);\n         }\n \n         //-----------------------------------------------------------------------\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public TimeOfDay addCopy(int valueToAdd) {\n-            int[] newValues = iInstant.getValues();\n-            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);\n-            return new TimeOfDay(iInstant, newValues);\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n         }\n \n         /**\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public TimeOfDay addInFieldCopy(int valueToAdd) {\n-            int[] newValues = iInstant.getValues();\n-            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);\n-            return new TimeOfDay(iInstant, newValues);\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().addInField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n         }\n \n         //-----------------------------------------------------------------------\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public TimeOfDay setCopy(int value) {\n-            int[] newValues = iInstant.getValues();\n-            getField().set(iInstant, iFieldIndex, newValues, value);\n-            return new TimeOfDay(iInstant, newValues);\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n         }\n \n         /**\n          * @throws IllegalArgumentException if the text value isn't valid\n          */\n         public TimeOfDay setCopy(String text, Locale locale) {\n-            int[] newValues = iInstant.getValues();\n-            getField().set(iInstant, iFieldIndex, newValues, text, locale);\n-            return new TimeOfDay(iInstant, newValues);\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n         }\n \n         /**\n         public TimeOfDay setCopy(String text) {\n             return setCopy(text, null);\n         }\n-\n-// TODO\n-//        //-----------------------------------------------------------------------\n-//        /**\n-//         * Rounds to the lowest whole unit of this field on a copy of this TimeOfDay.\n-//         *\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         */\n-//        public TimeOfDay roundFloorCopy() {\n-//            TimeOfDay instant = iInstant;\n-//            return (TimeOfDay) instant.withMillis(iField.roundFloor(instant.getMillis()));\n-//        }\n-//\n-//        /**\n-//         * Rounds to the highest whole unit of this field on a copy of this TimeOfDay.\n-//         *\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         */\n-//        public TimeOfDay roundCeilingCopy() {\n-//            TimeOfDay instant = iInstant;\n-//            return (TimeOfDay) instant.withMillis(iField.roundCeiling(instant.getMillis()));\n-//        }\n-//\n-//        /**\n-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,\n-//         * favoring the floor if halfway.\n-//         *\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         */\n-//        public TimeOfDay roundHalfFloorCopy() {\n-//            TimeOfDay instant = iInstant;\n-//            return (TimeOfDay) instant.withMillis(iField.roundHalfFloor(instant.getMillis()));\n-//        }\n-//\n-//        /**\n-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay,\n-//         * favoring the ceiling if halfway.\n-//         *\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         */\n-//        public TimeOfDay roundHalfCeilingCopy() {\n-//            TimeOfDay instant = iInstant;\n-//            return (TimeOfDay) instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));\n-//        }\n-//\n-//        /**\n-//         * Rounds to the nearest whole unit of this field on a copy of this TimeOfDay.\n-//         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n-//         *\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         */\n-//        public TimeOfDay roundHalfEvenCopy() {\n-//            TimeOfDay instant = iInstant;\n-//            return (TimeOfDay) instant.withMillis(iField.roundHalfEven(instant.getMillis()));\n-//        }\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/YearMonthDay.java\n import org.joda.time.DateTimeField;\n \n /**\n- * YearMonthDay is an immutable partial instant supporting the year, monthOfYear\n+ * YearMonthDay is an immutable partial supporting the year, monthOfYear\n  * and dayOfMonth fields.\n  * <p>\n  * Calculations on YearMonthDay are performed using a {@link Chronology}.\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class YearMonthDay extends AbstractPartialInstant implements PartialInstant, Serializable {\n+public final class YearMonthDay extends AbstractPartial implements ReadablePartial, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 797544782896179L;\n      */\n     public static class Property extends AbstractPartialFieldProperty {\n \n-        /** The instant */\n-        private final YearMonthDay iInstant;\n+        /** The partial */\n+        private final YearMonthDay iYearMonthDay;\n         /** The field index */\n         private final int iFieldIndex;\n \n         /**\n          * Constructs a property.\n          * \n-         * @param instant  the partial instant\n+         * @param partial  the partial instance\n          * @param field  the field\n-         * @param fieldIndex  the index in the instant\n-         */\n-        Property(YearMonthDay instant, int fieldIndex) {\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonthDay partial, int fieldIndex) {\n             super();\n-            iInstant = instant;\n+            iYearMonthDay = partial;\n             iFieldIndex = fieldIndex;\n         }\n \n          * @return the field\n          */\n         public DateTimeField getField() {\n-            return iInstant.getField(iFieldIndex);\n-        }\n-\n-        /**\n-         * Gets the instant that this property belongs to.\n-         * \n-         * @return the partial instant\n-         */\n-        public PartialInstant getPartialInstant() {\n-            return iInstant;\n-        }\n-\n-        /**\n-         * Gets the instant that this property belongs to.\n-         * \n-         * @return the partial instant\n+            return iYearMonthDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public ReadablePartial getReadablePartial() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n          */\n         public YearMonthDay getYearMonthDay() {\n-            return iInstant;\n-        }\n-\n-        /**\n-         * Gets the value of the field that the partial instant is set to.\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n          * \n          * @return the field value\n          */\n         public int get() {\n-            return iInstant.getValue(iFieldIndex);\n+            return iYearMonthDay.getValue(iFieldIndex);\n         }\n \n         //-----------------------------------------------------------------------\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public YearMonthDay addCopy(int valueToAdd) {\n-            int[] newValues = iInstant.getValues();\n-            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);\n-            return new YearMonthDay(iInstant, newValues);\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n         }\n \n         /**\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public YearMonthDay addInFieldCopy(int valueToAdd) {\n-            int[] newValues = iInstant.getValues();\n-            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);\n-            return new YearMonthDay(iInstant, newValues);\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().addInField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n         }\n \n         //-----------------------------------------------------------------------\n          * @throws IllegalArgumentException if the value isn't valid\n          */\n         public YearMonthDay setCopy(int value) {\n-            int[] newValues = iInstant.getValues();\n-            getField().set(iInstant, iFieldIndex, newValues, value);\n-            return new YearMonthDay(iInstant, newValues);\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n         }\n \n         /**\n          * @throws IllegalArgumentException if the text value isn't valid\n          */\n         public YearMonthDay setCopy(String text, Locale locale) {\n-            int[] newValues = iInstant.getValues();\n-            getField().set(iInstant, iFieldIndex, newValues, text, locale);\n-            return new YearMonthDay(iInstant, newValues);\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n         }\n \n         /**\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/partial/MockPartial.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.partial;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * A basic mock testing class for a PartialInstant that doesn't extend AbstractPartialInstant.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MockPartial implements ReadablePartial {\n+    \n+    public static final ReadablePartial EMPTY_INSTANCE = new MockPartial();\n+    \n+    public Chronology getChronology() {\n+        return ISOChronology.getInstance();\n+    }\n+    public int getFieldSize() {\n+        return 0;\n+    }\n+    public DateTimeField getField(int index) {\n+        return null;\n+    }\n+    public int getValue(int index) {\n+        return 0;\n+    }\n+    public int get(DateTimeField field) {\n+        return 0;\n+    }\n+    public boolean isSupported(DateTimeField field) {\n+        return false;\n+    }\n+    public long resolve(long baseMillis, DateTimeZone tz) {\n+        return 0L;\n+    }\n+    public DateTime resolveDateTime(ReadableInstant base) {\n+        return null;\n+    }\n+    public void resolveInto(ReadWritableInstant base) {\n+    }\n+    public DateTimeField[] getFields() {\n+        return new DateTimeField[0];\n+    }\n+    public int[] getValues() {\n+        return new int[0];\n+    }\n+}\n--- a/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/time/partial/TestTimeOfDay.java\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockInstant()));\n-        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n     \n-    class MockInstant extends MockPartialInstant {\n+    class MockInstant extends MockPartial {\n         public DateTimeField[] getFields() {\n             return new DateTimeField[] {\n                 ISOChronology.getInstance().hourOfDay(),\n         assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n         assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n         assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n-        assertSame(test, test.hourOfDay().getPartialInstant());\n+        assertSame(test, test.hourOfDay().getReadablePartial());\n         assertSame(test, test.hourOfDay().getTimeOfDay());\n         assertEquals(10, test.hourOfDay().get());\n         assertEquals(\"10\", test.hourOfDay().getAsText());\n         assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);\n         assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);\n         try {\n-            test1.hourOfDay().compareTo((PartialInstant) null);\n+            test1.hourOfDay().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n         assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n         assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n-        assertSame(test, test.minuteOfHour().getPartialInstant());\n+        assertSame(test, test.minuteOfHour().getReadablePartial());\n         assertSame(test, test.minuteOfHour().getTimeOfDay());\n         assertEquals(20, test.minuteOfHour().get());\n         assertEquals(\"20\", test.minuteOfHour().getAsText());\n         assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);\n         assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);\n         try {\n-            test1.minuteOfHour().compareTo((PartialInstant) null);\n+            test1.minuteOfHour().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n         assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n         assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n-        assertSame(test, test.secondOfMinute().getPartialInstant());\n+        assertSame(test, test.secondOfMinute().getReadablePartial());\n         assertSame(test, test.secondOfMinute().getTimeOfDay());\n         assertEquals(30, test.secondOfMinute().get());\n         assertEquals(\"30\", test.secondOfMinute().getAsText());\n         assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);\n         assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);\n         try {\n-            test1.secondOfMinute().compareTo((PartialInstant) null);\n+            test1.secondOfMinute().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n         assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n         assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n-        assertSame(test, test.millisOfSecond().getPartialInstant());\n+        assertSame(test, test.millisOfSecond().getReadablePartial());\n         assertSame(test, test.millisOfSecond().getTimeOfDay());\n         assertEquals(40, test.millisOfSecond().get());\n         assertEquals(\"40\", test.millisOfSecond().getAsText());\n         assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);\n         assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);\n         try {\n-            test1.millisOfSecond().compareTo((PartialInstant) null);\n+            test1.millisOfSecond().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n--- a/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java\n+++ b/JodaTime/src/test/org/joda/time/partial/TestYearMonthDay.java\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockInstant()));\n-        assertEquals(false, test1.equals(MockPartialInstant.EMPTY_INSTANCE));\n+        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n     \n-    class MockInstant extends MockPartialInstant {\n+    class MockInstant extends MockPartial {\n         public DateTimeField[] getFields() {\n             return new DateTimeField[] {\n                 ISOChronology.getInstance().year(),\n         assertSame(test.getChronology().year(), test.year().getField());\n         assertEquals(\"year\", test.year().getName());\n         assertEquals(\"Property[year]\", test.year().toString());\n-        assertSame(test, test.year().getPartialInstant());\n+        assertSame(test, test.year().getReadablePartial());\n         assertSame(test, test.year().getYearMonthDay());\n         assertEquals(1972, test.year().get());\n         assertEquals(\"1972\", test.year().getAsText());\n         assertEquals(true, test2.year().compareTo(test1) > 0);\n         assertEquals(true, test1.year().compareTo(test1) == 0);\n         try {\n-            test1.year().compareTo((PartialInstant) null);\n+            test1.year().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n         assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n         assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n-        assertSame(test, test.monthOfYear().getPartialInstant());\n+        assertSame(test, test.monthOfYear().getReadablePartial());\n         assertSame(test, test.monthOfYear().getYearMonthDay());\n         assertEquals(6, test.monthOfYear().get());\n         assertEquals(\"June\", test.monthOfYear().getAsText());\n         assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n         assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n         try {\n-            test1.monthOfYear().compareTo((PartialInstant) null);\n+            test1.monthOfYear().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         \n         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n         assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n         assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n-        assertSame(test, test.dayOfMonth().getPartialInstant());\n+        assertSame(test, test.dayOfMonth().getReadablePartial());\n         assertSame(test, test.dayOfMonth().getYearMonthDay());\n         assertEquals(9, test.dayOfMonth().get());\n         assertEquals(\"9\", test.dayOfMonth().getAsText());\n         assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);\n         assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);\n         try {\n-            test1.dayOfMonth().compareTo((PartialInstant) null);\n+            test1.dayOfMonth().compareTo((ReadablePartial) null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         ", "timestamp": 1088366614, "metainfo": ""}