{"sha": "ee0a30f6db2d9d1b0b34294990f7f6a01e6352c1", "log": "Add methods to handle time zone differences   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n      * Converts the instant value to a <code>GregorianCalendar</code>\n      * adjusting to take into account the different time zone rules.\n      * <p>\n-     * Note that this method may not be reversible if the zone rules differ\n-     * around a daylight savings, or other, change.\n+     * This method is the equivalent of creating a calendar object and\n+     * calling set using each field in turn. The result is a calendar that\n+     * reflects the fields of the instant, rather than millisecond value.\n+     * <p>\n+     * This method can 'lose' data depending on the date and zone rules.\n+     * If a datetime exists in the specified instant that cannot be\n+     * represented in a calendar (due to differences in the time zone rules)\n+     * the JDK chooses to move the hour backwards. For example, 1972-03-26\n+     * 01:30  in Europe/London cannot be represented in <code>Calendar</code>\n+     * in JDK1.3 due to an incorrect time zone definition in the JDK.\n+     * Instead, the JDK sets the time to 00:30.\n      *\n      * @param instant  the instant to convert\n      * @return the offset to add to UTC\n         if (instant == null) {\n             throw new IllegalArgumentException(\"The zone must not be null\");\n         }\n+        Chronology chrono = instant.getChronology();\n         DateTimeZone zone = instant.getZone();\n+        long millis = instant.getMillis();\n         TimeZone jdkZone = zone.toTimeZone();\n         GregorianCalendar cal = new GregorianCalendar(jdkZone);\n-        long jdkMillis = zone.getMillisJDKKeepLocal(jdkZone, instant.getMillis());\n-        cal.setTime(new Date(jdkMillis));\n+        cal.clear();\n+        cal.set(Calendar.YEAR, chrono.year().get(millis));\n+        cal.set(Calendar.DAY_OF_YEAR, chrono.dayOfYear().get(millis));\n+        cal.set(Calendar.MILLISECOND, chrono.millisOfDay().get(millis));\n+        cal.get(Calendar.ERA);  // force calculation\n         return cal;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n         } catch (SecurityException ex) {\n             // ignore\n         } catch (NoSuchMethodException ex) {\n-            try {\n-                Method[] ms = TimeZone.class.getDeclaredMethods();\n-                m = TimeZone.class.getDeclaredMethod(\"getOffsets\", new Class[] {Long.TYPE, int[].class});\n-                m.setAccessible(true);\n-            } catch (SecurityException e) {\n-                // ignore\n-            } catch (NoSuchMethodException e) {\n-                // ignore\n-            }\n+            // ignore\n         }\n         OFFSET_METHOD = m;\n     }\n         if (OFFSET_METHOD == null) {\n             if (jdkZone instanceof SimpleTimeZone) {\n                 SimpleTimeZone zone = (SimpleTimeZone) jdkZone;\n-                long offset = zone.getRawOffset();\n-                if (zone.inDaylightTime(new Date(instant)))  {\n-                    offset += zone.getDSTSavings();\n-                }\n-                long millisLocal = instant - offset;\n-                return millisLocal + getOffsetFromLocal(millisLocal);\n+                long millisLocal = instant + getOffset(instant);\n+                long jdkOffset = getJDKOffset(zone, millisLocal - getJDKOffset(zone, millisLocal));\n+                return millisLocal - jdkOffset;\n             }\n             return instant;\n         } else {\n                 return instant;\n             }\n         }\n+        // TODO: this conversion is wrong\n         long millisLocal = instant - val.intValue();\n         return millisLocal + getOffsetFromLocal(millisLocal);\n+    }\n+\n+    /**\n+     * @param zone\n+     * @param instant\n+     * @return\n+     */\n+    private long getJDKOffset(SimpleTimeZone zone, long instant) {\n+        long offset = zone.getRawOffset();\n+        if (zone.inDaylightTime(new Date(instant)))  {\n+            offset += zone.getDSTSavings();\n+        }\n+        return offset;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n \n /**\n  * This class is a Junit unit test for Instant.\n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testToGregorianCalendar() {\n+        TimeZone jdkZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Paris\"));\n+            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);\n+            Calendar cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values\n+            \n+            assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n+            \n+            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);\n+            cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values\n+            \n+            assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n+            \n+            dt = new DateTime(1800, 1, 1, 0, 30, 0, 0, LONDON);\n+            int year = dt.getYear();\n+            while (year < 2000) {\n+                dt = dt.plusHours(1);\n+                int hourOfDay = dt.getHourOfDay();\n+                if (hourOfDay == 4) {\n+                    dt = dt.plusHours(18);  // speed up test\n+                } else {\n+                    year = dt.getYear();\n+                    cal.clear();\n+                    cal.set(year, dt.getMonthOfYear() - 1, dt.getDayOfMonth(),\n+                        hourOfDay, dt.getMinuteOfHour(), dt.getSecondOfMinute());\n+                    //cal.get(Calendar.ERA);\n+                    assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n+                }\n+            }\n+            \n+        } finally {\n+            TimeZone.setDefault(jdkZone);\n+        }\n+        try {\n+            DateTimeUtils.toGregorianCalendar(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTime_Calendar() {\n+        TimeZone jdkZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+            GregorianCalendar cal = new GregorianCalendar(1800, 0, 1, 0, 30, 0);\n+            int year = cal.get(Calendar.YEAR);\n+            while (year < 2000) {\n+                cal.add(Calendar.HOUR_OF_DAY, 1);\n+                int hourOfDay = cal.get(Calendar.HOUR_OF_DAY);\n+                if (hourOfDay == 4) {\n+                    cal.add(Calendar.HOUR_OF_DAY, 18);  // speed up test\n+                } else {\n+                    year = cal.get(Calendar.YEAR);\n+                    DateTime dt = new DateTime(\n+                        year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n+                        cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE),\n+                        cal.get(Calendar.SECOND), 0,\n+                        LenientChronology.getInstance(ISOChronology.getInstance(LONDON)))\n+                        .withChronology(ISOChronology.getInstance(LONDON));\n+                    assertEquals(dt, DateTimeUtils.toDateTime(cal));\n+                }\n+            }\n+            \n+        } finally {\n+            TimeZone.setDefault(jdkZone);\n+        }\n+        try {\n+            DateTimeUtils.toDateTime((Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n }", "timestamp": 1133733466, "metainfo": ""}