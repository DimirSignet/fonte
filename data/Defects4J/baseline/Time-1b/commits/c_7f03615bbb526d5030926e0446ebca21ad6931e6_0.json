{"sha": "7f03615bbb526d5030926e0446ebca21ad6931e6", "log": "Cache time zones looked up by fixed offset.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n  * Time (GMT).  This is similar, but not precisely identical, to Universal \n  * Coordinated Time, or UTC. This library only uses the term UTC.\n  * <p>\n- * Using this system, Pacific Time, USA is expressed as UTC-08:00, or UTC-07:00\n- * in the summer. The offset -08:00 indicates that Pacific Time is obtained \n- * from UTC by adding -08:00, that is, by subtracting 8 hours.\n+ * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n+ * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n+ * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n  * <p>\n  * The offset differs in the summer because of daylight saving time, or DST.\n  * The folowing definitions of time are generally used:\n \n     private static DateTimeFormatter cOffsetFormatter;\n \n-    /**\n-     * Cache of old zone IDs to new zone IDs\n-     */\n+    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n+    private static Map iFixedOffsetCache;\n+\n+    /** Cache of old zone IDs to new zone IDs */\n     private static Map cZoneIdConversion;\n \n     static {\n                 return DateTimeZone.UTC;\n             } else {\n                 id = offsetFormatter().print(0, UTC, offset);\n-                return new FixedDateTimeZone(id, null, offset, offset);\n+                return fixedOffsetZone(id, offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n                     return DateTimeZone.UTC;\n                 } else {\n                     convId = offsetFormatter().print(0, UTC, offset);\n-                    return new FixedDateTimeZone(convId, null, offset, offset);\n+                    return fixedOffsetZone(convId, offset);\n                 }\n             }\n         }\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n \n-    /**\n-     * Gets the available IDs according to the given millisecond time\n-     * zone offset.\n-     * <p>\n-     * For example, \"America/Phoenix\" and \"America/Denver\"\n-     * both have GMT-07:00, but differ in daylight saving behavior.\n-     * \n-     * @param rawOffset  the given millisecond time zone GMT offset\n-     * @return an unmodifiable Set of String IDs\n-     */\n-    /*\n-    public static Set getAvailableIDs(int rawOffset) {\n-        String[] ids = TimeZone.getAvailableIDs(rawOffset);\n-        Set set = new HashSet();\n-        for (int i = 0; i < ids.length; i++) {\n-            if (cZones.containsKey(ids[i])) {\n-                set.add(ids[i]);\n+    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n+        if (iFixedOffsetCache == null) {\n+            iFixedOffsetCache = new HashMap();\n+        }\n+        DateTimeZone zone;\n+        Reference ref = (Reference) iFixedOffsetCache.get(id);\n+        if (ref != null) {\n+            zone = (DateTimeZone) ref.get();\n+            if (zone != null) {\n+                return zone;\n             }\n         }\n-        return Collections.unmodifiableSet(set);\n-    }\n-    */\n+        zone = new FixedDateTimeZone(id, null, offset, offset);\n+        iFixedOffsetCache.put(id, new SoftReference(zone));\n+        return zone;\n+    }\n \n     /**\n      * Gets all the available IDs supported.", "timestamp": 1091394195, "metainfo": ""}