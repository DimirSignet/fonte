{"sha": "4ac994b573b8d051a36e00ebd98f0c8dc68eec6f", "log": "Refactor AbstractInterval   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n package org.joda.time;\n \n import org.joda.time.chrono.ISOChronology;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.IntervalConverter;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n  */\n public abstract class AbstractInterval implements ReadableInterval {\n \n-    /** The start of the period */\n-    private long iStartMillis;\n-    /** The end of the period */\n-    private long iEndMillis;\n-\n-    /** Cache the duration */\n-    private transient Duration iDuration;\n-    /** Cache the start instant */\n-    private transient Instant iStartInstant;\n-    /** Cache the end instant */\n-    private transient Instant iEndInstant;\n-\n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n-     * @param interval  the time interval to convert\n-     * @throws IllegalArgumentException if the interval is null or invalid\n-     */\n-    public AbstractInterval(Object interval) {\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractInterval() {\n         super();\n-        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n-        if (this instanceof ReadWritableInterval) {\n-            converter.setInto((ReadWritableInterval) this, interval);\n-        } else {\n-            long[] millis = converter.getIntervalMillis(interval);\n-            iStartMillis = millis[0];\n-            iEndMillis = millis[1];\n-        }\n-        if (interval instanceof AbstractInterval) {\n-            AbstractInterval ri = (AbstractInterval) interval;\n-            if (iStartMillis == ri.iStartMillis && iEndMillis == ri.iEndMillis) {\n-                // this double checks against weird converters\n-                iStartInstant = ri.iStartInstant;\n-                iEndInstant = ri.iEndInstant;\n-                iDuration = ri.iDuration;\n-            }\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start and end instant.\n-     * \n-     * @param startInstant  start of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     * @param endInstant  end of this interval, as milliseconds from\n-     *  1970-01-01T00:00:00Z.\n-     */\n-    public AbstractInterval(long startInstant, long endInstant) {\n-        super();\n-        checkInterval(startInstant, endInstant);\n-        iStartMillis = startInstant;\n-        iEndMillis = endInstant;\n-    }\n-\n-    /**\n-     * Constructs an interval from a start and end instant.\n-     * \n-     * @param start  start of this interval, null means now\n-     * @param end  end of this interval, null means now\n-     */\n-    public AbstractInterval(ReadableInstant start, ReadableInstant end) {\n-        super();\n-        if (start == null && end == null) {\n-            iStartMillis = DateTimeUtils.currentTimeMillis();\n-            iEndMillis = iStartMillis;\n-        } else {\n-            if (start == null) {\n-                iStartMillis = DateTimeUtils.currentTimeMillis();\n-            } else {\n-                iStartMillis = start.getMillis();\n-                if (start instanceof Instant) {\n-                    iStartInstant = (Instant) start;\n-                }\n-            }\n-            if (end == null) {\n-                iEndMillis = DateTimeUtils.currentTimeMillis();\n-            } else {\n-                iEndMillis = end.getMillis();\n-                if (end instanceof Instant) {\n-                    iEndInstant = (Instant) end;\n-                }\n-            }\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start instant and a millisecond duration.\n-     * \n-     * @param start  start of this interval, null means now\n-     * @param duration  the duration of this interval, null means zero length\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    public AbstractInterval(ReadableInstant start, ReadableDuration duration) {\n-        super();\n-        Chronology chrono = null;\n-        if (start == null) {\n-            iStartMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iStartMillis = start.getMillis();\n-            chrono = start.getChronology();\n-            if (start instanceof Instant) {\n-                iStartInstant = (Instant) start;\n-            }\n-        }\n-        if (duration == null) {\n-            iEndMillis = iStartMillis;\n-        } else {\n-            iEndMillis = FieldUtils.safeAdd(iStartMillis, duration.getMillis());\n-            if (duration instanceof Duration) {\n-                iDuration = (Duration) duration;\n-            }\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    /**\n-     * Constructs an interval from a millisecond duration and an end instant.\n-     * \n-     * @param duration  the duration of this interval, null means zero length\n-     * @param end  end of this interval, null means now\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    public AbstractInterval(ReadableDuration duration, ReadableInstant end) {\n-        super();\n-        Chronology chrono = null;\n-        if (end == null) {\n-            iEndMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iEndMillis = end.getMillis();\n-            chrono = end.getChronology();\n-            if (end instanceof Instant) {\n-                iEndInstant = (Instant) end;\n-            }\n-        }\n-        if (duration == null) {\n-            iStartMillis = iEndMillis;\n-        } else {\n-            iStartMillis = FieldUtils.safeAdd(iEndMillis, -duration.getMillis());\n-            if (duration instanceof Duration) {\n-                iDuration = (Duration) duration;\n-            }\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start instant and a period.\n-     * <p>\n-     * When forming the interval, the chronology from the instant is used\n-     * if present, otherwise the chronology of the period is used.\n-     * \n-     * @param start  start of this interval, null means now\n-     * @param period  the period of this interval, null means zero length\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    public AbstractInterval(ReadableInstant start, ReadablePeriod period) {\n-        super();\n-        Chronology chrono = null;\n-        if (start == null) {\n-            iStartMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iStartMillis = start.getMillis();\n-            chrono = start.getChronology();\n-            if (start instanceof Instant) {\n-                iStartInstant = (Instant) start;\n-            }\n-        }\n-        if (period == null) {\n-            iEndMillis = iStartMillis;\n-        } else {\n-            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n-    }\n-\n-    /**\n-     * Constructs an interval from a period and an end instant.\n-     * <p>\n-     * When forming the interval, the chronology from the instant is used\n-     * if present, otherwise the chronology of the period is used.\n-     * \n-     * @param period  the period of this interval, null means zero length\n-     * @param end  end of this interval, null means now\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    public AbstractInterval(ReadablePeriod period, ReadableInstant end) {\n-        super();\n-        Chronology chrono = null;\n-        if (end == null) {\n-            iEndMillis = DateTimeUtils.currentTimeMillis();\n-        } else {\n-            iEndMillis = end.getMillis();\n-            chrono = end.getChronology();\n-            if (end instanceof Instant) {\n-                iEndInstant = (Instant) end;\n-            }\n-        }\n-        if (period == null) {\n-            iStartMillis = iEndMillis;\n-        } else {\n-            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n-        }\n-        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param end  the end instant in milliseconds\n      * @throws IllegalArgumentException if the interval is invalid\n      */\n-    private void checkInterval(long start, long end) {\n+    protected void checkInterval(long start, long end) {\n         if (end < start) {\n             throw new IllegalArgumentException(\"The end instant must be greater or equal to the start\");\n         }\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the start of this time interval which is inclusive.\n-     *\n-     * @return the start of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public final long getStartMillis() {\n-        return iStartMillis;\n-    }\n-\n+    /**\n+     * Extracts the end millis from an instant ensuring that the millis matches the\n+     * start if both are null.\n+     * \n+     * @param end  the end instant\n+     * @param start  the start instant\n+     * @param startMillis  the start millis, which will be now if start is null\n+     * @return the end millis\n+     */\n+    protected long getEndInstantMillis(ReadableInstant end, ReadableInstant start, long startMillis) {\n+        if (end == null) {\n+            if (start == null) {\n+                return startMillis;\n+            } else {\n+                return DateTimeUtils.currentTimeMillis();\n+            }\n+        } else {\n+            return end.getMillis();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the start of this time interval, which is inclusive, as an Instant.\n      *\n      * @return the start of the time interval\n      */\n-    public final Instant getStartInstant() {\n-        if (iStartInstant == null) {\n-            iStartInstant = new Instant(getStartMillis());\n-        }\n-        return iStartInstant;\n-    }\n-\n-    /** \n-     * Gets the end of this time interval which is exclusive.\n-     *\n-     * @return the end of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public final long getEndMillis() {\n-        return iEndMillis;\n+    public Instant getStartInstant() {\n+        return new Instant(getStartMillis());\n     }\n \n     /** \n      *\n      * @return the end of the time interval\n      */\n-    public final Instant getEndInstant() {\n-        if (iEndInstant == null) {\n-            iEndInstant = new Instant(getEndMillis());\n-        }\n-        return iEndInstant;\n+    public Instant getEndInstant() {\n+        return new Instant(getEndMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the duration of the time interval in milliseconds\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public final long getDurationMillis() {\n+    public long getDurationMillis() {\n         return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n     }\n \n     /**\n-     * Gets the millisecond duration of this time interval.\n-     * <p>\n-     * If this interval was constructed using a Duration then that object will\n-     * be returned. Otherwise a new Duration instance is returned.\n-     *\n-     * @return the millisecond duration of the time interval\n+     * Gets a <code>Duration</code> holding the millisecond duration of this time interval.\n+     *\n+     * @return the duration of the time interval\n      * @throws ArithmeticException if the duration exceeds the capacity of a long\n      */\n-    public final Duration getDuration() {\n-        if (iDuration == null) {\n-            long durMillis = getDurationMillis();\n-            if (durMillis == 0) {\n-                iDuration = Duration.ZERO;\n-            } else {\n-                iDuration = new Duration(durMillis);\n-            }\n-        }\n-        return iDuration;\n+    public Duration getDuration() {\n+        long durMillis = getDurationMillis();\n+        if (durMillis == 0) {\n+            return Duration.ZERO;\n+        } else {\n+            return new Duration(durMillis);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval contains the millisecond\n      */\n-    public final boolean contains(long millisInstant) {\n+    public boolean contains(long millisInstant) {\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n         return (millisInstant >= thisStart && millisInstant < thisEnd);\n      * \n      * @return true if this time interval contains the current instant\n      */\n-    public final boolean containsNow() {\n+    public boolean containsNow() {\n         return contains(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n      */\n-    public final boolean contains(ReadableInstant instant) {\n+    public boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n             return contains(DateTimeUtils.currentTimeMillis());\n         }\n      * @return true if this time interval contains the time interval\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public final boolean contains(ReadableInterval interval) {\n+    public boolean contains(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      * @return true if the time intervals overlap\n      * @throws IllegalArgumentException if the interval is null\n      */\n-    public final boolean overlaps(ReadableInterval interval) {\n+    public boolean overlaps(ReadableInterval interval) {\n         if (interval == null) {\n             throw new IllegalArgumentException(\"The time interval must not be null\");\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is before the instant\n      */\n-    public final boolean isBefore(long millisInstant) {\n+    public boolean isBefore(long millisInstant) {\n         return (getEndMillis() <= millisInstant);\n     }\n \n      * \n      * @return true if this time interval is before the current instant\n      */\n-    public final boolean isBeforeNow() {\n+    public boolean isBeforeNow() {\n         return isBefore(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is before the instant\n      */\n-    public final boolean isBefore(ReadableInstant instant) {\n+    public boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n             return isBefore(DateTimeUtils.currentTimeMillis());\n         }\n      *  millisecond instant from 1970-01-01T00:00:00Z\n      * @return true if this time interval is after the instant\n      */\n-    public final boolean isAfter(long millisInstant) {\n+    public boolean isAfter(long millisInstant) {\n         return (getStartMillis() > millisInstant);\n     }\n \n      * \n      * @return true if this time interval is after the current instant\n      */\n-    public final boolean isAfterNow() {\n+    public boolean isAfterNow() {\n         return isAfter(DateTimeUtils.currentTimeMillis());\n     }\n \n      * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is after the instant\n      */\n-    public final boolean isAfter(ReadableInstant instant) {\n+    public boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n             return isAfter(DateTimeUtils.currentTimeMillis());\n         }\n      *\n      * @return the interval as an Interval object\n      */\n-    public final Interval toInterval() {\n+    public Interval toInterval() {\n         if (this instanceof Interval) {\n             return (Interval) this;\n         }\n-        return new Interval(this);\n+        return new Interval(getStartMillis(), getEndMillis());\n     }\n \n     /**\n      *\n      * @return the time interval as a MutableInterval object\n      */\n-    public final MutableInterval toMutableInterval() {\n-        return new MutableInterval(this);\n+    public MutableInterval toMutableInterval() {\n+        return new MutableInterval(getStartMillis(), getEndMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      *\n      * @return a time period derived from the interval\n      */\n-    public final Period toPeriod() {\n+    public Period toPeriod() {\n         return new Period(getStartMillis(), getEndMillis());\n     }\n \n      * @param type  the requested type of the duration, null means AllType\n      * @return a time period derived from the interval\n      */\n-    public final Period toPeriod(PeriodType type) {\n+    public Period toPeriod(PeriodType type) {\n         return new Period(getStartMillis(), getEndMillis(), type);\n     }\n \n      * @param readableInterval  a readable interval to check against\n      * @return true if the start and end millis are equal\n      */\n-    public final boolean equals(Object readableInterval) {\n+    public boolean equals(Object readableInterval) {\n         if (this == readableInterval) {\n             return true;\n         }\n      *\n      * @return suitable hashcode\n      */\n-    public final int hashCode() {\n+    public int hashCode() {\n         long start = getStartMillis();\n         long end = getEndMillis();\n         int result = 97;\n         return buf.toString();\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets this interval to be the same as another.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     *\n-     * @param interval  the interval to copy\n-     */\n-    protected void setInterval(ReadableInterval interval) {\n-        if (interval instanceof AbstractInterval) {\n-            AbstractInterval other = (AbstractInterval) interval;\n-            iStartMillis = other.iStartMillis;\n-            iStartInstant = other.iStartInstant;\n-            iEndMillis = other.iEndMillis;\n-            iEndInstant = other.iEndInstant;\n-            iDuration = other.iDuration;\n-        } else {\n-            iStartMillis = interval.getStartMillis();\n-            iEndMillis = interval.getEndMillis();\n-        }\n-    }\n-\n-    /**\n-     * Sets this interval from two millisecond instants.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     *\n-     * @param startInstant  the start of the time interval\n-     * @param endInstant  the start of the time interval\n-     */\n-    protected void setInterval(long startInstant, long endInstant) {\n-        if (startInstant != iStartMillis || endInstant != iEndMillis) {\n-            iStartMillis = startInstant;\n-            iStartInstant = null;\n-            iEndMillis = endInstant;\n-            iEndInstant = null;\n-            iDuration = null;\n-        }\n-    }\n-\n-    /**\n-     * Sets this interval from two instants.\n-     *\n-     * @param startInstant  the start of the time interval\n-     * @param endInstant  the start of the time interval\n-     */\n-    protected void setInterval(ReadableInstant startInstant, ReadableInstant endInstant) {\n-        if (startInstant == null && endInstant == null) {\n-            long now = DateTimeUtils.currentTimeMillis();\n-            setInterval(now, now);\n-        } else if (startInstant == null) {\n-            long now = DateTimeUtils.currentTimeMillis();\n-            setInterval(now, endInstant.getMillis());\n-        } else if (startInstant == null) {\n-            long now = DateTimeUtils.currentTimeMillis();\n-            setInterval(startInstant.getMillis(), now);\n-        } else {\n-            setInterval(startInstant.getMillis(), endInstant.getMillis());\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the start of this time interval.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     *\n-     * @param millisInstant  the start of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    protected void setStartMillis(long millisInstant) {\n-        if (millisInstant != iStartMillis) {\n-            iStartMillis = millisInstant;\n-            iStartInstant = null;\n-            iDuration = null;\n-        }\n-    }\n-\n-    /** \n-     * Sets the end of this time interval.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     *\n-     * @param millisInstant  the end of the time interval,\n-     *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    protected void setEndMillis(long millisInstant) {\n-        if (millisInstant != iEndMillis) {\n-            iEndMillis = millisInstant;\n-            iEndInstant = null;\n-            iDuration = null;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the duration of this time interval, preserving the start instant.\n-     *\n-     * @param duration  new duration for interval\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    protected void setDurationAfterStart(long duration) {\n-        setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));\n-    }\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the end instant.\n-     *\n-     * @param duration  new duration for interval\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    protected void setDurationBeforeEnd(long duration) {\n-        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));\n-    }\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the start instant.\n-     *\n-     * @param duration  new duration for interval, null means zero length\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    protected void setDurationAfterStart(ReadableDuration duration) {\n-        if (duration == null) {\n-            setEndMillis(getStartMillis());\n-        } else {\n-            setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration.getMillis()));\n-            if (duration instanceof Duration) {\n-                iDuration = (Duration) duration;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets the duration of this time interval, preserving the end instant.\n-     *\n-     * @param duration  new duration for interval, null means zero length\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    protected void setDurationBeforeEnd(ReadableDuration duration) {\n-        if (duration == null) {\n-            setStartMillis(getEndMillis());\n-        } else {\n-            setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration.getMillis()));\n-            if (duration instanceof Duration) {\n-                iDuration = (Duration) duration;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets the period of this time interval, preserving the start instant.\n-     *\n-     * @param period  new period for interval, null means zero length\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    protected void setPeriodAfterStart(ReadablePeriod period) {\n-        if (period == null) {\n-            setEndMillis(getStartMillis());\n-        } else {\n-            setEndMillis(period.addTo(getStartMillis(), 1));\n-        }\n-    }\n-\n-    /**\n-     * Sets the period of this time interval, preserving the end instant.\n-     *\n-     * @param period  new period for interval, null means zero length\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    protected void setPeriodBeforeEnd(ReadablePeriod period) {\n-        if (period == null) {\n-            setStartMillis(getEndMillis());\n-        } else {\n-            setStartMillis(period.addTo(getEndMillis(), -1));\n-        }\n-    }\n-\n }\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n package org.joda.time;\n \n import java.io.Serializable;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * Interval is the standard implementation of an immutable time interval.\n     /** Serialization version */\n     private static final long serialVersionUID = 4922451897541386752L;\n \n+    /** The start of the period */\n+    private final long iStartMillis;\n+    /** The end of the period */\n+    private final long iEndMillis;\n+\n+    /** The cached duration */\n+    private transient Duration iDuration;\n+\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n      */\n     public Interval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n-     * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null or invalid\n-     */\n-    public Interval(Object interval) {\n-        super(interval);\n+        super();\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n     }\n \n     /**\n      * \n      * @param start  start of this interval, null means now\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      */\n     public Interval(ReadableInstant start, ReadableInstant end) {\n-        super(start, end);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start instant and a millisecond duration.\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        iEndMillis = getEndInstantMillis(end, start, iStartMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n      * \n      * @param start  start of this interval, null means now\n      * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public Interval(ReadableInstant start, ReadableDuration duration) {\n-        super(start, duration);\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n+        if (duration instanceof Duration) {\n+            iDuration = (Duration) duration;\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param duration  the duration of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public Interval(ReadableDuration duration, ReadableInstant end) {\n-        super(duration, end);\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n+        if (duration instanceof Duration) {\n+            iDuration = (Duration) duration;\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param start  start of this interval, null means now\n      * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public Interval(ReadableInstant start, ReadablePeriod period) {\n-        super(start, period);\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        if (period == null) {\n+            iEndMillis = iStartMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(start, null);\n+            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param period  the period of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public Interval(ReadablePeriod period, ReadableInstant end) {\n-        super(period, end);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    public void setInterval(ReadableInterval interval) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    public void setInterval(long startInstant, long endInstant) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setStartMillis(long millisInstant) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected final void setEndMillis(long millisInstant) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected void setDurationAfterStart(ReadableDuration duration) {\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n-     */\n-    protected void setDurationBeforeEnd(ReadableDuration duration) {\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        if (period == null) {\n+            iStartMillis = iEndMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(end, null);\n+            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null or invalid\n+     */\n+    public Interval(Object interval) {\n+        super();\n+        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n+        long[] millis = converter.getIntervalMillis(interval);\n+        iStartMillis = millis[0];\n+        iEndMillis = millis[1];\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this time interval which is inclusive.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public final long getStartMillis() {\n+        return iStartMillis;\n+    }\n+\n+    /**\n+     * Gets the end of this time interval which is exclusive.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public final long getEndMillis() {\n+        return iEndMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration of this interval.\n+     * <p>\n+     * Where possible, this implementation reuses the same <code>Duration</code> object.\n+     *\n+     * @return the duration of the interval\n+     */\n+    public final Duration getDuration() {\n+        if (iDuration == null) {\n+            iDuration = super.getDuration();\n+        }\n+        return iDuration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Protect against malicious subclasses, ensuring this class is immutable\n+    //-----------------------------------------------------------------------\n+    protected final void checkInterval(long start, long end) {\n+        super.checkInterval(start, end);\n+    }\n+\n+    protected final long getEndInstantMillis(ReadableInstant end, ReadableInstant start, long startMillis) {\n+        return super.getEndInstantMillis(end, start, startMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final long getDurationMillis() {\n+        return super.getDurationMillis();\n+    }\n+\n+    public final Instant getStartInstant() {\n+        return super.getStartInstant();\n+    }\n+\n+    public final Instant getEndInstant() {\n+        return super.getEndInstant();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final boolean contains(long millisInstant) {\n+        return super.contains(millisInstant);\n+    }\n+\n+    public final boolean containsNow() {\n+        return super.containsNow();\n+    }\n+\n+    public final boolean contains(ReadableInstant instant) {\n+        return super.contains(instant);\n+    }\n+\n+    public final boolean contains(ReadableInterval interval) {\n+        return super.contains(interval);\n+    }\n+\n+    public final boolean overlaps(ReadableInterval interval) {\n+        return super.overlaps(interval);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final boolean equals(Object readableInterval) {\n+        return super.equals(readableInterval);\n+    }\n+\n+    public final int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final boolean isAfter(long millisInstant) {\n+        return super.isAfter(millisInstant);\n+    }\n+\n+    public final boolean isAfterNow() {\n+        return super.isAfterNow();\n+    }\n+\n+    public final boolean isAfter(ReadableInstant instant) {\n+        return super.isAfter(instant);\n+    }\n+\n+    public final boolean isBefore(long millisInstant) {\n+        return super.isBefore(millisInstant);\n+    }\n+\n+    public final boolean isBeforeNow() {\n+        return super.isBeforeNow();\n+    }\n+\n+    public final boolean isBefore(ReadableInstant instant) {\n+        return super.isBefore(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final Interval toInterval() {\n+        return super.toInterval();\n+    }\n+\n+    public final MutableInterval toMutableInterval() {\n+        return super.toMutableInterval();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final Period toPeriod() {\n+        return super.toPeriod();\n+    }\n+\n+    public final Period toPeriod(PeriodType type) {\n+        return super.toPeriod(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public final String toString() {\n+        return super.toString();\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n package org.joda.time;\n \n import java.io.Serializable;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.field.FieldUtils;\n \n /**\n  * MutableInterval is the standard implementation of a mutable time interval.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class MutableInterval\n+public class MutableInterval\n         extends AbstractInterval\n         implements ReadWritableInterval, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -5982824024992428470L;\n \n-    /**\n-     * Constructs a time interval from 1970-01-01 to 1970-01-01.\n+    /** The start of the period */\n+    private long iStartMillis;\n+    /** The end of the period */\n+    private long iEndMillis;\n+\n+    /**\n+     * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.\n      */\n     public MutableInterval() {\n-        super(0L, 0L);\n+        super();\n     }\n \n     /**\n      * \n      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n      * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n      */\n     public MutableInterval(long startInstant, long endInstant) {\n-        super(startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n-     * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null or invalid\n-     */\n-    public MutableInterval(Object interval) {\n-        super(interval);\n+        super();\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n     }\n \n     /**\n      * \n      * @param start  start of this interval, null means now\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      */\n     public MutableInterval(ReadableInstant start, ReadableInstant end) {\n-        super(start, end);\n-    }\n-\n-    /**\n-     * Constructs an interval from a start instant and a millisecond duration.\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        iEndMillis = getEndInstantMillis(end, start, iStartMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n      * \n      * @param start  start of this interval, null means now\n      * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n-        super(start, duration);\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param duration  the duration of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n-        super(duration, end);\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param start  start of this interval, null means now\n      * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n-        super(start, period);\n+        super();\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        if (period == null) {\n+            iEndMillis = iStartMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(start, null);\n+            iEndMillis = period.addTo(iStartMillis, 1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n     }\n \n     /**\n      * \n      * @param period  the period of this interval, null means zero length\n      * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n-        super(period, end);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets this interval to be the same as another.\n-     *\n-     * @param interval  the interval to copy\n-     */\n-    public void setInterval(ReadableInterval interval) {\n-        super.setInterval(interval);\n-    }\n-\n+        super();\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        if (period == null) {\n+            iStartMillis = iEndMillis;\n+        } else {\n+            Chronology chrono = DateTimeUtils.getInstantChronology(end, null);\n+            iStartMillis = period.addTo(iEndMillis, -1, chrono);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs a time interval as a copy of another.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is null or invalid\n+     */\n+    public MutableInterval(Object interval) {\n+        super();\n+        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n+        converter.setInto(this, interval);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this time interval which is inclusive.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getStartMillis() {\n+        return iStartMillis;\n+    }\n+\n+    /** \n+     * Gets the end of this time interval which is exclusive.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getEndMillis() {\n+        return iEndMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets this interval from two millisecond instants.\n+     * <p>\n+     * All updates ocurr via this method (exclusing the constructors).\n      *\n      * @param startInstant  the start of the time interval\n      * @param endInstant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n      */\n     public void setInterval(long startInstant, long endInstant) {\n-        super.setInterval(startInstant, endInstant);\n+        if (startInstant != iStartMillis || endInstant != iEndMillis) {\n+            checkInterval(startInstant, endInstant);\n+            iStartMillis = startInstant;\n+            iEndMillis = endInstant;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets this interval to be the same as another.\n+     *\n+     * @param interval  the interval to copy\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public void setInterval(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"Interval must not be null\");\n+        }\n+        long startMillis = interval.getStartMillis();\n+        long endMillis = interval.getEndMillis();\n+        setInterval(startMillis, endMillis);\n     }\n \n     /**\n      * Sets this interval from two instants.\n      *\n-     * @param startInstant  the start of the time interval\n-     * @param endInstant  the start of the time interval\n-     */\n-    public void setInterval(ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super.setInterval(startInstant, endInstant);\n+     * @param start  the start of the time interval\n+     * @param end  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setInterval(ReadableInstant start, ReadableInstant end) {\n+        long startMillis = DateTimeUtils.getInstantMillis(start);\n+        long endMillis = getEndInstantMillis(end, start, iStartMillis);\n+        setInterval(startMillis, endMillis);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Sets the start of this time interval.\n      *\n-     * @param millisInstant  the start of the time interval,\n+     * @param startInstant  the start of the time interval,\n      *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public void setStartMillis(long millisInstant) {\n-        super.setStartMillis(millisInstant);\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setStartMillis(long startInstant) {\n+        setInterval(startInstant, iEndMillis);\n     }\n \n     /**\n      * Sets the start of this time interval as an Instant.\n      *\n-     * @param instant  the start of the time interval\n-     */\n-    public void setStartInstant(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        super.setStartMillis(instant.getMillis());\n-    }\n-\n+     * @param start  the start of the time interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setStartInstant(ReadableInstant start) {\n+        long startMillis = DateTimeUtils.getInstantMillis(start);\n+        setInterval(startMillis, iEndMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /** \n      * Sets the end of this time interval.\n-     *\n-     * @param millisInstant  the end of the time interval,\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is public and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     *\n+     * @param endInstant  the end of the time interval,\n      *  millisecond instant from 1970-01-01T00:00:00Z\n-     */\n-    public void setEndMillis(long millisInstant) {\n-        super.setEndMillis(millisInstant);\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setEndMillis(long endInstant) {\n+        setInterval(iStartMillis, endInstant);\n     }\n \n     /** \n      * Sets the end of this time interval as an Instant.\n      *\n-     * @param instant  the end of the time interval\n-     */\n-    public void setEndInstant(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n-        }\n-        super.setEndMillis(instant.getMillis());\n+     * @param instant  the end of the time interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setEndInstant(ReadableInstant end) {\n+        long endMillis = DateTimeUtils.getInstantMillis(end);\n+        setInterval(iStartMillis, endMillis);\n     }\n \n     //-----------------------------------------------------------------------\n      * Sets the duration of this time interval, preserving the start instant.\n      *\n      * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public void setDurationAfterStart(long duration) {\n-        super.setDurationAfterStart(duration);\n+        setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));\n     }\n \n     /**\n      * Sets the duration of this time interval, preserving the end instant.\n      *\n      * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public void setDurationBeforeEnd(long duration) {\n-        super.setDurationBeforeEnd(duration);\n-    }\n-\n+        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the duration of this time interval, preserving the start instant.\n      *\n-     * @param duration  new duration for interval\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public void setDurationAfterStart(ReadableDuration duration) {\n-        super.setDurationAfterStart(duration);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis));\n     }\n \n     /**\n      * Sets the duration of this time interval, preserving the end instant.\n      *\n-     * @param duration  new duration for interval\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public void setDurationBeforeEnd(ReadableDuration duration) {\n-        super.setDurationBeforeEnd(duration);\n-    }\n-\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setStartMillis(FieldUtils.safeAdd(getStartMillis(), -durationMillis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets the period of this time interval, preserving the start instant.\n      *\n      * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n     public void setPeriodAfterStart(ReadablePeriod period) {\n-        super.setPeriodAfterStart(period);\n+        if (period == null) {\n+            setEndMillis(getStartMillis());\n+        } else {\n+            setEndMillis(period.addTo(getStartMillis(), 1));\n+        }\n     }\n \n     /**\n      * Sets the period of this time interval, preserving the end instant.\n      *\n      * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n     public void setPeriodBeforeEnd(ReadablePeriod period) {\n-        super.setPeriodBeforeEnd(period);\n+        if (period == null) {\n+            setStartMillis(getEndMillis());\n+        } else {\n+            setStartMillis(period.addTo(getEndMillis(), -1));\n+        }\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n  */\n package org.joda.time;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Locale;\n import java.util.TimeZone;\n \n     \n     class MockInterval extends AbstractInterval {\n         public MockInterval() {\n-            super(TEST_TIME1, TEST_TIME2);\n+            super();\n+        }\n+        public long getStartMillis() {\n+            return TEST_TIME1;\n+        }\n+        public long getEndMillis() {\n+            return TEST_TIME2;\n         }\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Interval result = (Interval) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testToString() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);\n         DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n         Interval test = new Interval(dt1, dt2);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dt1, test.getStartInstant());\n-        assertSame(dt2, test.getEndInstant());\n     }\n \n     public void testConstructor_RI_RI3() throws Throwable {\n         Interval test = new Interval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         assertEquals(result, test.getEndMillis());\n-        assertSame(dt, test.getStartInstant());\n     }\n \n     public void testConstructor_RI_RP3() throws Throwable {\n         Interval test = new Interval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         assertEquals(result, test.getEndMillis());\n-        assertSame(dt, test.getStartInstant());\n     }\n \n     public void testConstructor_RI_RP4() throws Throwable {\n         Interval test = new Interval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         assertEquals(dt.getMillis(), test.getEndMillis());\n-        assertSame(dt, test.getEndInstant());\n     }\n \n     public void testConstructor_RP_RI3() throws Throwable {\n         Interval test = new Interval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         assertEquals(dt.getMillis(), test.getEndMillis());\n-        assertSame(dt, test.getEndInstant());\n     }\n \n     public void testConstructor_RP_RI4() throws Throwable {\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Interval base = new Interval(dt1, dt2);\n         Duration dur = base.getDuration();\n-        Instant start = base.getStartInstant();\n-        Instant end = base.getEndInstant();\n         \n         Interval test = new Interval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dur, test.getDuration());\n-        assertSame(start, test.getStartInstant());\n-        assertSame(end, test.getEndInstant());\n+        assertNotSame(dur, test.getDuration());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableInterval base = new MutableInterval(dt1, dt2);\n         Duration dur = base.getDuration();\n-        Instant start = base.getStartInstant();\n-        Instant end = base.getEndInstant();\n         \n         Interval test = new Interval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dur, test.getDuration());\n-        assertSame(start, test.getStartInstant());\n-        assertSame(end, test.getEndInstant());\n+        assertNotSame(dur, test.getDuration());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n             ConverterManager.getInstance().addIntervalConverter(conv);\n             Interval base = new Interval(-1000L, 1000L);\n             Duration dur = base.getDuration();\n-            Instant start = base.getStartInstant();\n-            Instant end = base.getEndInstant();\n             Interval test = new Interval(base);\n             assertEquals(1234L, test.getStartMillis());\n             assertEquals(5678L, test.getEndMillis());\n             assertNotSame(dur, test.getDuration());\n-            assertNotSame(start, test.getStartInstant());\n-            assertNotSame(end, test.getEndInstant());\n         } finally {\n             ConverterManager.getInstance().addIntervalConverter(oldConv);\n         }\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n  */\n package org.joda.time;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.util.Locale;\n import java.util.TimeZone;\n \n     \n     class MockInterval extends AbstractInterval {\n         public MockInterval() {\n-            super(TEST_TIME1, TEST_TIME2);\n+            super();\n+        }\n+        public long getStartMillis() {\n+            return TEST_TIME1;\n+        }\n+        public long getEndMillis() {\n+            return TEST_TIME2;\n         }\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Interval result = (Interval) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testToString() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);\n         DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n         MutableInterval test = new MutableInterval(dt1, dt2);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dt1, test.getStartInstant());\n-        assertSame(dt2, test.getEndInstant());\n     }\n \n     public void testConstructor_RI_RI3() throws Throwable {\n         MutableInterval test = new MutableInterval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         assertEquals(result, test.getEndMillis());\n-        assertSame(dt, test.getStartInstant());\n     }\n \n     public void testConstructor_RI_RP3() throws Throwable {\n         MutableInterval test = new MutableInterval(dt, dur);\n         assertEquals(dt.getMillis(), test.getStartMillis());\n         assertEquals(result, test.getEndMillis());\n-        assertSame(dt, test.getStartInstant());\n     }\n \n     public void testConstructor_RI_RP4() throws Throwable {\n         MutableInterval test = new MutableInterval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         assertEquals(dt.getMillis(), test.getEndMillis());\n-        assertSame(dt, test.getEndInstant());\n     }\n \n     public void testConstructor_RP_RI3() throws Throwable {\n         MutableInterval test = new MutableInterval(dur, dt);\n         assertEquals(result, test.getStartMillis());\n         assertEquals(dt.getMillis(), test.getEndMillis());\n-        assertSame(dt, test.getEndInstant());\n     }\n \n     public void testConstructor_RP_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutableInterval base = new MutableInterval(dt1, dt2);\n-        Duration dur = base.getDuration();\n-        Instant start = base.getStartInstant();\n-        Instant end = base.getEndInstant();\n         \n         MutableInterval test = new MutableInterval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dur, test.getDuration());\n-        assertSame(start, test.getStartInstant());\n-        assertSame(end, test.getEndInstant());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Interval base = new Interval(dt1, dt2);\n-        Duration dur = base.getDuration();\n-        Instant start = base.getStartInstant();\n-        Instant end = base.getEndInstant();\n         \n         MutableInterval test = new MutableInterval(base);\n         assertEquals(dt1.getMillis(), test.getStartMillis());\n         assertEquals(dt2.getMillis(), test.getEndMillis());\n-        assertSame(dur, test.getDuration());\n-        assertSame(start, test.getStartInstant());\n-        assertSame(end, test.getEndInstant());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n         try {\n             ConverterManager.getInstance().addIntervalConverter(conv);\n             Interval base = new Interval(-1000L, 1000L);\n-            Duration dur = base.getDuration();\n-            Instant start = base.getStartInstant();\n-            Instant end = base.getEndInstant();\n             MutableInterval test = new MutableInterval(base);\n             assertEquals(1234L, test.getStartMillis());\n             assertEquals(5678L, test.getEndMillis());\n-            assertNotSame(dur, test.getDuration());\n-            assertNotSame(start, test.getStartInstant());\n-            assertNotSame(end, test.getEndInstant());\n         } finally {\n             ConverterManager.getInstance().addIntervalConverter(oldConv);\n         }", "timestamp": 1092505794, "metainfo": ""}