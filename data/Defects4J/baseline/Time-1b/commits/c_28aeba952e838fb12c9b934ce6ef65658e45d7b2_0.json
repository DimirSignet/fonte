{"sha": "28aeba952e838fb12c9b934ce6ef65658e45d7b2", "log": "Fix GJChronology.plus/minus across cutover and year zero  Fixes #28 When subtracting a number of years from a date in the GJChronology there are two considerations The cutover date might be crossed, and year zero might be crossed (there is no year zero in GJ) Previously, each were handled separately, but not together. Now it is fixed As part of this change, the minimum cutover instant was set to 0001-01-01 (Gregorian)", "commit": "\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n import org.joda.time.DurationField;\n import org.joda.time.IllegalFieldValueException;\n import org.joda.time.Instant;\n+import org.joda.time.LocalDate;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.BaseDateTimeField;\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n+            if (cutoverDate.getYear() <= 0) {\n+                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n+            }\n         }\n \n         GJChronology chrono;\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n+                        if (iConvertByWeekyear) {\n+                            int wyear = iGregorianChronology.weekyear().get(instant);\n+                            if (wyear <= 0) {\n+                                instant = iGregorianChronology.weekyear().add(instant, -1);\n+                            }\n+                        } else {\n+                            int year = iGregorianChronology.year().get(instant);\n+                            if (year <= 0) {\n+                                instant = iGregorianChronology.year().add(instant, -1);\n+                            }\n+                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n                 if (instant >= iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant - iGapDuration >= iCutover) {\n+                        // no special handling for year zero as cutover always after year zero\n                         instant = julianToGregorian(instant);\n                     }\n                 }\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n+                        if (iConvertByWeekyear) {\n+                            int wyear = iGregorianChronology.weekyear().get(instant);\n+                            if (wyear <= 0) {\n+                                instant = iGregorianChronology.weekyear().add(instant, -1);\n+                            }\n+                        } else {\n+                            int year = iGregorianChronology.year().get(instant);\n+                            if (year <= 0) {\n+                                instant = iGregorianChronology.year().add(instant, -1);\n+                            }\n+                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n                 if (instant >= iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant - iGapDuration >= iCutover) {\n+                        // no special handling for year zero as cutover always after year zero\n                         instant = julianToGregorian(instant);\n                     }\n                 }\n--- a/src/test/java/org/joda/time/chrono/TestAll.java\n+++ b/src/test/java/org/joda/time/chrono/TestAll.java\n         suite.addTest(TestJulianChronology.suite());\n         suite.addTest(TestISOChronology.suite());\n         suite.addTest(TestLenientChronology.suite());\n+        suite.addTest(TestGJDate.suite());\n         \n         return suite;\n     }\n--- /dev/null\n+++ b/src/test/java/org/joda/time/chrono/TestGJDate.java\n+/*\n+ *  Copyright 2001-2013 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDate;\n+\n+/**\n+ * Test.\n+ */\n+public class TestGJDate extends TestCase {\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJDate.class);\n+    }\n+\n+    public TestGJDate(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+    }\n+\n+    protected void tearDown() throws Exception {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static final Chronology GJ_CHRONOLOGY = GJChronology.getInstanceUTC();\n+\n+    //-----------------------------------------------------------------------\n+    public void test_plusYears_positiveToPositive() {\n+        LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(7, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(4));\n+    }\n+\n+    public void test_plusYears_positiveToZero() {\n+        LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(-3));\n+    }\n+\n+    public void test_plusYears_positiveToNegative() {\n+        LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(-4));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_plusYears_negativeToNegative() {\n+        LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(2));\n+    }\n+\n+    public void test_plusYears_negativeToZero() {\n+        LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(1, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(3));\n+    }\n+\n+    public void test_plusYears_negativeToPositive() {\n+        LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(2, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(4));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_plusYears_positiveToPositive_crossCutover() {\n+        LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(2007, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(2004));\n+    }\n+\n+    public void test_plusYears_positiveToZero_crossCutover() {\n+        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(-2003));\n+    }\n+\n+    public void test_plusYears_positiveToNegative_crossCutover() {\n+        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(-2004));\n+    }\n+\n+    public void test_plusYears_negativeToPositive_crossCutover() {\n+        LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(2002, 6, 30, GJ_CHRONOLOGY);\n+        assertEquals(expected, date.plusYears(2004));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_plusWeekyears_positiveToZero_crossCutover() {\n+        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n+        assertEquals(expected, date.weekyear().addToCopy(-2003));\n+    }\n+\n+    public void test_plusWeekyears_positiveToNegative_crossCutover() {\n+        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n+        LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n+        assertEquals(expected, date.weekyear().addToCopy(-2004));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_cutoverPreZero() {\n+        DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC);\n+        try {\n+            GJChronology.getInstance(DateTimeZone.UTC, cutover);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+}", "timestamp": 1376660478, "metainfo": ""}