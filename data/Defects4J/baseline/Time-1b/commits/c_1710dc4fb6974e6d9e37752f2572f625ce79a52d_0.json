{"sha": "1710dc4fb6974e6d9e37752f2572f625ce79a52d", "log": "Test and fix local string parsing  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/LocalDate.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDate.java\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n--- a/JodaTime/src/java/org/joda/time/LocalDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalDateTime.java\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n--- a/JodaTime/src/java/org/joda/time/LocalTime.java\n+++ b/JodaTime/src/java/org/joda/time/LocalTime.java\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @throws IllegalArgumentException if the instant is invalid\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param zone  the time zone\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n     /**\n      * Extracts the values of the partial from an object of this converter's type.\n-     * The chrono parameter is a hint to the converter, should it require a\n-     * chronology to aid in conversion.\n+     * This method checks if the parser has a zone, and uses it if present.\n+     * This is most useful for parsing local times with UTC.\n      * \n      * @param fieldSource  a partial that provides access to the fields.\n      *  This partial may be incomplete and only getFieldType(int) should be used\n      * @param object  the object to convert\n      * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser the parser to use, may be null\n      * @return the array of field values that match the fieldSource, must be non-null valid\n      * @throws ClassCastException if the object is invalid\n      * @throws IllegalArgumentException if the value if invalid\n      * @since 1.3\n      */\n     public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {\n+        if (parser.getZone() != null) {\n+            chrono = chrono.withZone(parser.getZone());\n+        }\n         long millis = parser.withChronology(chrono).parseMillis((String) object);\n         return chrono.get(fieldSource, millis);\n     }\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n import java.util.Collection;\n \n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n \n /**\n  * Factory that creates instances of DateTimeFormatter for the ISO8601 standard.\n         dpe, // date parser element\n         tpe, // time parser element\n         dp,  // date parser\n+        ldp, // local date parser\n         tp,  // time parser\n         ltp, // local time parser\n         dtp, // date time parser\n \n     /**\n      * Returns a generic ISO date parser for parsing local dates.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n      * It accepts formats described by the following syntax:\n      * <pre>\n      * date-element      = std-date-element | ord-date-element | week-date-element\n      * @since 1.3\n      */\n     public static DateTimeFormatter localDateParser() {\n-        return dateElementParser();\n+        if (ldp == null) {\n+            ldp = dateElementParser().withZone(DateTimeZone.UTC);\n+        }\n+        return ldp;\n     }\n \n     /**\n \n     /**\n      * Returns a generic ISO time parser for parsing local times.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n      * It accepts formats described by the following syntax:\n      * <pre>\n      * time           = ['T'] time-element\n             ltp = new DateTimeFormatterBuilder()\n                 .appendOptional(literalTElement().getParser())\n                 .append(timeElementParser())\n-                .toFormatter();\n+                .toFormatter().withZone(DateTimeZone.UTC);\n         }\n         return ltp;\n     }\n     /**\n      * Returns a generic ISO datetime parser where the date is mandatory and\n      * the time is optional. This parser only parses local datetimes.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n      * It accepts formats described by the following syntax:\n      * <pre>\n      * datetime          = date-element ['T' time-element]\n             ldotp = new DateTimeFormatterBuilder()\n                 .append(dateElementParser())\n                 .appendOptional(time)\n-                .toFormatter();\n+                .toFormatter().withZone(DateTimeZone.UTC);\n         }\n         return ldotp;\n     }\n--- a/JodaTime/src/test/org/joda/time/TestLocalDateTime_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalDateTime_Constructors.java\n     private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n     private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();\n     private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);\n+    private static final Chronology GREGORIAN_MOSCOW = GregorianChronology.getInstance(MOSCOW);\n     private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();\n     private static final int OFFSET_PARIS = PARIS.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n     private static final int OFFSET_MOSCOW = MOSCOW.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR;\n         assertEquals(0, test.getMillisOfSecond());\n     }\n \n+    public void testConstructor_Object_DateTimeZoneMoscow() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1970-04-06T12:24:00\", MOSCOW);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(12, test.getHourOfDay());\n+        assertEquals(24, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_Object_DateTimeZoneMoscowBadDateTime() throws Throwable {\n+        // 1981-03-31T23:59:59.999+03:00 followed by 1981-04-01T01:00:00.000+04:00\n+        // 1981-09-30T23:59:59.999+04:00 followed by 1981-09-30T23:00:00.000+03:00\n+        \n+        // when a DST non-existing time is passed in, it should still work (ie. zone ignored)\n+        LocalDateTime test = new LocalDateTime(\"1981-04-01T00:30:00\", MOSCOW);  // doesnt exist\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(1981, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(1, test.getDayOfMonth());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(30, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n     public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n         LocalDateTime test = new LocalDateTime((Object) null, PARIS);\n         assertEquals(ISO_UTC, test.getChronology());\n         assertEquals(0, test.getMillisOfSecond());\n     }\n \n+    public void testConstructor_Object_ChronologyMoscow() throws Throwable {\n+        LocalDateTime test = new LocalDateTime(\"1970-04-06T12:24:00\", GREGORIAN_MOSCOW);\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(6, test.getDayOfMonth());\n+        assertEquals(12, test.getHourOfDay());\n+        assertEquals(24, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_Object_ChronologyMoscowBadDateTime() throws Throwable {\n+        // 1981-03-31T23:59:59.999+03:00 followed by 1981-04-01T01:00:00.000+04:00\n+        // 1981-09-30T23:59:59.999+04:00 followed by 1981-09-30T23:00:00.000+03:00\n+        \n+        // when a DST non-existing time is passed in, it should still work (ie. zone ignored)\n+        LocalDateTime test = new LocalDateTime(\"1981-04-01T00:30:00\", GREGORIAN_MOSCOW);  // doesnt exist\n+        assertEquals(GREGORIAN_UTC, test.getChronology());\n+        assertEquals(1981, test.getYear());\n+        assertEquals(4, test.getMonthOfYear());\n+        assertEquals(1, test.getDayOfMonth());\n+        assertEquals(0, test.getHourOfDay());\n+        assertEquals(30, test.getMinuteOfHour());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(0, test.getMillisOfSecond());\n+    }\n+\n     public void testConstructor_nullObject_Chronology() throws Throwable {\n         LocalDateTime test = new LocalDateTime((Object) null, GREGORIAN_PARIS);\n         assertEquals(GREGORIAN_UTC, test.getChronology());\n--- a/JodaTime/src/test/org/joda/time/TestLocalTime_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestLocalTime_Constructors.java\n \n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final DateTimeZone NEW_YORK = DateTimeZone.forID(\"America/New_York\");\n     private static final ISOChronology ISO_UTC = ISOChronology.getInstanceUTC();\n     private static final JulianChronology JULIAN_LONDON = JulianChronology.getInstance(LONDON);\n     private static final JulianChronology JULIAN_PARIS = JulianChronology.getInstance(PARIS);\n         assertEquals(40, test.getMillisOfSecond());\n     }\n \n+    public void testConstructor_ObjectString1Tokyo() throws Throwable {\n+        DateTimeZone.setDefault(TOKYO);\n+        LocalTime test = new LocalTime(\"10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n+    public void testConstructor_ObjectString1NewYork() throws Throwable {\n+        DateTimeZone.setDefault(NEW_YORK);\n+        LocalTime test = new LocalTime(\"10:20:30.040\");\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(10, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+        assertEquals(30, test.getSecondOfMinute());\n+        assertEquals(40, test.getMillisOfSecond());\n+    }\n+\n     public void testConstructor_ObjectString2() throws Throwable {\n         LocalTime test = new LocalTime(\"T10:20:30.040\");\n         assertEquals(ISO_UTC, test.getChronology());\n         assertEquals(4, test.getMillisOfSecond());\n     }\n \n-    public void testConstructor_Object2_DateTimeZone() throws Throwable {\n-        LocalTime test = new LocalTime(\"T10:20\");\n-        assertEquals(10, test.getHourOfDay());\n-        assertEquals(20, test.getMinuteOfHour());\n-        assertEquals(0, test.getSecondOfMinute());\n-        assertEquals(0, test.getMillisOfSecond());\n-        \n-        try {\n-            new LocalTime(\"T1020\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n+    public void testConstructor_ObjectString_DateTimeZoneLondon() throws Throwable {\n+        LocalTime test = new LocalTime(\"04:20\", LONDON);\n+        assertEquals(4, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+    }\n+\n+    public void testConstructor_ObjectString_DateTimeZoneTokyo() throws Throwable {\n+        LocalTime test = new LocalTime(\"04:20\", TOKYO);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n+    }\n+\n+    public void testConstructor_ObjectString_DateTimeZoneNewYork() throws Throwable {\n+        LocalTime test = new LocalTime(\"04:20\", NEW_YORK);\n+        assertEquals(ISO_UTC, test.getChronology());\n+        assertEquals(4, test.getHourOfDay());\n+        assertEquals(20, test.getMinuteOfHour());\n     }\n \n     public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n--- a/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormatParsing.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormatParsing.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.Period;\n-import org.joda.time.PeriodType;\n \n /**\n  * This class is a Junit unit test for ISODateTimeFormat parsing.\n     //-----------------------------------------------------------------------\n     public void test_localDateParser() {\n         DateTimeFormatter parser = ISODateTimeFormat.localDateParser();\n+        assertEquals(DateTimeZone.UTC, parser.getZone());\n         assertParse(parser, true, \"2006-06-09\");\n         assertParse(parser, true, \"2006-W27-3\");\n         assertParse(parser, true, \"2006-123\");\n     //-----------------------------------------------------------------------\n     public void test_localTimeParser() {\n         DateTimeFormatter parser = ISODateTimeFormat.localTimeParser();\n+        assertEquals(DateTimeZone.UTC, parser.getZone());\n         assertParse(parser, false, \"2006-06-09\");\n         assertParse(parser, false, \"2006-W27-3\");\n         assertParse(parser, false, \"2006-123\");\n         assertParse(parser, true, \"10.5\");\n         assertParse(parser, false, \"10:20:30.040+02:00\");\n         assertParse(parser, false, \"10.5+02:00\");\n+        \n+        assertParse(parser, true, \"00:00:10.512345678\");\n+        assertEquals(10512, parser.parseMillis(\"00:00:10.512345678\"));\n     }\n \n     //-----------------------------------------------------------------------\n         assertParse(parser, true, \"10.5\");\n         assertParse(parser, false, \"10:20:30.040+02:00\");\n         assertParse(parser, false, \"10.5+02:00\");\n+        \n+        assertParse(parser, true, \"00:00:10.512345678\");\n+        // result is offset by London DST in 1970-01-01\n+        assertEquals(10512, parser.parseMillis(\"00:00:10.512345678\") + DateTimeZone.getDefault().getOffset(0L));\n     }\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     public void test_localDateOptionalTimeParser() {\n         DateTimeFormatter parser = ISODateTimeFormat.localDateOptionalTimeParser();\n+        assertEquals(DateTimeZone.UTC, parser.getZone());\n         assertParse(parser, true, \"2006-06-09\");\n         assertParse(parser, true, \"2006-W27-3\");\n         assertParse(parser, true, \"2006-123\");", "timestamp": 1154169916, "metainfo": ""}