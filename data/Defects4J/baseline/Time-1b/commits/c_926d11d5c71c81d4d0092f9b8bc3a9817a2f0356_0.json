{"sha": "926d11d5c71c81d4d0092f9b8bc3a9817a2f0356", "log": "Additional tests for DateTime and Instant   ", "commit": "\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        suite.addTest(TestDateTime_Constructors.suite());\n+        suite.addTest(TestDateTime_Basics.suite());\n+        suite.addTest(TestDateTime_Properties.suite());\n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n-        suite.addTest(TestParseISO.suite());\n+        suite.addTest(TestInstant_Constructors.suite());\n+        suite.addTest(TestInstant_Basics.suite());\n+//        suite.addTest(TestParseISO.suite());\n         return suite;\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for DateTime.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTime_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    // 1970-06-09\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 1970-04-05\n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 1971-05-06\n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTime_Basics.class);\n+    }\n+\n+    public TestDateTime_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        DateTime test = new DateTime();\n+        assertEquals(1, test.get(ISOChronology.getInstance().era()));\n+        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));\n+        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));\n+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));\n+        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));\n+        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));\n+        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetMethods() {\n+        DateTime test = new DateTime();\n+        \n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(LONDON, test.getZone());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        \n+        assertEquals(1, test.getEra());\n+        assertEquals(19, test.getCenturyOfEra());\n+        assertEquals(70, test.getYearOfCentury());\n+        assertEquals(1970, test.getYearOfEra());\n+        assertEquals(1970, test.getYear());\n+        assertEquals(6, test.getMonthOfYear());\n+        assertEquals(9, test.getDayOfMonth());\n+        assertEquals(1970, test.getWeekyear());\n+        assertEquals(24, test.getWeekOfWeekyear());\n+        assertEquals(2, test.getDayOfWeek());\n+        assertEquals(160, test.getDayOfYear());\n+        assertEquals(1, test.getHourOfDay());\n+        assertEquals(0, test.getMinuteOfHour());\n+        assertEquals(60, test.getMinuteOfDay());\n+        assertEquals(0, test.getSecondOfMinute());\n+        assertEquals(60 * 60, test.getSecondOfDay());\n+        assertEquals(0, test.getMillisOfSecond());\n+        assertEquals(60 * 60 * 1000, test.getMillisOfDay());\n+    }\n+\n+    public void testEqualsHashCode() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test2 = new DateTime(TEST_TIME1);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GregorianChronology.getInstance())));\n+    }\n+    \n+    class MockInstant extends AbstractInstant {\n+        public String toString() {\n+            return null;\n+        }\n+        public long getMillis() {\n+            return TEST_TIME1;\n+        }\n+        public Chronology getChronology() {\n+            return ISOChronology.getInstance();\n+        }\n+    }\n+\n+    public void testCompareTo() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test1a = new DateTime(TEST_TIME1);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        DateTime test2 = new DateTime(TEST_TIME2);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(+1, test2.compareTo(new MockInstant()));\n+        assertEquals(0, test1.compareTo(new MockInstant()));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    public void testIsEqual() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test1a = new DateTime(TEST_TIME1);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        DateTime test2 = new DateTime(TEST_TIME2);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        assertEquals(false, test2.isEqual(new MockInstant()));\n+        assertEquals(true, test1.isEqual(new MockInstant()));\n+        assertEquals(false, test1.isEqual(null));\n+    }\n+    \n+    public void testIsBefore() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test1a = new DateTime(TEST_TIME1);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        DateTime test2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        assertEquals(false, test2.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(null));\n+    }\n+    \n+    public void testIsAfter() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test1a = new DateTime(TEST_TIME1);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        DateTime test2 = new DateTime(TEST_TIME2);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        assertEquals(true, test2.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        DateTime test = new DateTime(TEST_TIME_NOW);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        DateTime result = (DateTime) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        DateTime test = new DateTime(TEST_TIME_NOW);\n+        assertEquals(\"1970-06-09T01:00:00.000+01:00\", test.toString());\n+        \n+        test = new DateTime(TEST_TIME_NOW, PARIS);\n+        assertEquals(\"1970-06-09T02:00:00.000+02:00\", test.toString());\n+    }\n+\n+    public void testToString_String() {\n+        DateTime test = new DateTime(TEST_TIME_NOW);\n+        assertEquals(\"1970 01\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"1970-06-09T01:00:00.000+01:00\", test.toString(null));\n+    }\n+\n+    public void testToString_String_String() {\n+        DateTime test = new DateTime(TEST_TIME_NOW);\n+        assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"mar. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"1970-06-09T01:00:00.000+01:00\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"1970-06-09T01:00:00.000+01:00\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInstant() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        Instant result = test.toInstant();\n+        assertEquals(TEST_TIME1, result.getMillis());\n+    }\n+\n+    public void testToDateTime() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.toDateTime();\n+        assertSame(test, result);\n+    }\n+\n+    public void testToDateTime_DateTimeZone() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.toDateTime(LONDON);\n+        assertSame(test, result);\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(PARIS, result.getZone());\n+\n+        test = new DateTime(TEST_TIME1, PARIS);\n+        result = test.toDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(LONDON, result.getZone());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toDateTime((DateTimeZone) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testToDateTime_Chronology() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.toDateTime(ISOChronology.getInstance());\n+        assertSame(test, result);\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.toDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toDateTime((Chronology) null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testToTrustedISODateTime() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.toTrustedISODateTime();\n+        assertSame(test, result);\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+\n+        test = new MockUntrustedDateTime(TEST_TIME1);\n+        result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1, new MockUntrustedZone(\"Europe/Paris\"));\n+        result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+    }\n+\n+    static class MockUntrustedDateTime extends DateTime {\n+        MockUntrustedDateTime(long millis) {\n+            super(millis);\n+        }\n+    }\n+\n+    static class MockUntrustedZone extends DateTimeZone {\n+        MockUntrustedZone(String id) {\n+            super(id);\n+        }\n+        public String getNameKey(long instant) {\n+            return null;\n+        }\n+        public int getOffset(long instant) {\n+            return 60 * 60 * 1000;\n+        }\n+        public int getStandardOffset(long instant) {\n+            return 60 * 60 * 1000;\n+        }\n+        public boolean isFixed() {\n+            return true;\n+        }\n+        public long nextTransition(long instant) {\n+            return 0;\n+        }\n+        public long previousTransition(long instant) {\n+            return 0;\n+        }\n+        public boolean equals(Object object) {\n+            return false;\n+        }\n+    }\n+\n+    public void testToMutableDateTime() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime();\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_DateTimeZone() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime(LONDON);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toMutableDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1, PARIS);\n+        result = test.toMutableDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toMutableDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_Chronology() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.toMutableDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new DateTime(TEST_TIME1);\n+        result = test.toMutableDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToDate() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        Date result = test.toDate();\n+        assertEquals(test.getMillis(), result.getTime());\n+    }\n+\n+    public void testToCalendar_Locale() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        Calendar result = test.toCalendar(null);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+\n+        test = new DateTime(TEST_TIME1, PARIS);\n+        result = test.toCalendar(null);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+\n+        test = new DateTime(TEST_TIME1, PARIS);\n+        result = test.toCalendar(Locale.UK);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+    }\n+\n+    public void testToGregorianCalendar() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        GregorianCalendar result = test.toGregorianCalendar();\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+\n+        test = new DateTime(TEST_TIME1, PARIS);\n+        result = test.toGregorianCalendar();\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/Paris\"), result.getTimeZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithMillis_long() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.withMillis(TEST_TIME2);\n+        assertEquals(TEST_TIME2, result.getMillis());\n+        assertEquals(test.getChronology(), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.withMillis(TEST_TIME2);\n+        assertEquals(TEST_TIME2, result.getMillis());\n+        assertEquals(test.getChronology(), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1);\n+        result = test.withMillis(TEST_TIME1);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithChronology_Chronology() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.withChronology(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.withChronology(null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1);\n+        result = test.withChronology(null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1);\n+        result = test.withChronology(ISOChronology.getInstance());\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithZone_DateTimeZone() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.withZone(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.withZone(null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1);\n+        result = test.withZone(null);\n+        assertSame(test, result);\n+    }\n+\n+    public void testWithZoneRetainFields_DateTimeZone() {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        DateTime result = test.withZoneRetainFields(PARIS);\n+        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+        \n+        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));\n+        result = test.withZoneRetainFields(null);\n+        assertEquals(test.getMillis() - 60 * 60 * 1000, result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(), result.getChronology());\n+    }\n+    \n+    public void testImmutable() {\n+        MockChangeDateTime test = new MockChangeDateTime(TEST_TIME_NOW);\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        test.testSetMillis();\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        \n+        test = new MockChangeDateTime(TEST_TIME_NOW);\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        test.testSetMillisObject();\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        \n+        test = new MockChangeDateTime(TEST_TIME_NOW);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetChronology();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        \n+        test = new MockChangeDateTime(TEST_TIME_NOW);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetZone();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        \n+        test = new MockChangeDateTime(TEST_TIME_NOW);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        test.testSetZoneRetainFields();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+    }\n+    \n+    static class MockChangeDateTime extends DateTime {\n+        MockChangeDateTime(long instant) {\n+            super(instant);\n+        }\n+        public void testSetMillis() {\n+            setMillis(0L);\n+        }\n+        public void testSetMillisObject() {\n+            setMillis(new Date(0L));\n+        }\n+        public void testSetChronology() {\n+            setChronology(GregorianChronology.getInstance(PARIS));\n+        }\n+        public void testSetZone() {\n+            setZone(PARIS);\n+        }\n+        public void testSetZoneRetainFields() {\n+            setZoneRetainFields(PARIS);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for DateTime.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTime_Constructors extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    // 1970-06-09\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 1970-04-05\n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 1971-05-06\n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTime_Constructors.class);\n+    }\n+\n+    public TestDateTime_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        DateTime test = new DateTime();\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone)\n+     */\n+    public void testConstructor_DateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (DateTimeZone=null)\n+     */\n+    public void testConstructor_nullDateTimeZone() throws Throwable {\n+        DateTime test = new DateTime((DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology)\n+     */\n+    public void testConstructor_Chronology() throws Throwable {\n+        DateTime test = new DateTime(GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Chronology=null)\n+     */\n+    public void testConstructor_nullChronology() throws Throwable {\n+        DateTime test = new DateTime((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME1);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME2);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME2, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone)\n+     */\n+    public void testConstructor_long1_DateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME1, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone)\n+     */\n+    public void testConstructor_long2_DateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME2, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME2, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, DateTimeZone=null)\n+     */\n+    public void testConstructor_long_nullDateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long1_Chronology() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology)\n+     */\n+    public void testConstructor_long2_Chronology() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME2, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long, Chronology=null)\n+     */\n+    public void testConstructor_long_nullChronology() throws Throwable {\n+        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        DateTime test = new DateTime(date);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_invalidObject() throws Throwable {\n+        try {\n+            new DateTime(new Object());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        DateTime test = new DateTime((Object) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateTime test = new DateTime(new Integer(0));\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_Object_DateTimeZone() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        DateTime test = new DateTime(date, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {\n+        try {\n+            new DateTime(new Object(), PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, DateTimeZone)\n+     */\n+    public void testConstructor_nullObject_DateTimeZone() throws Throwable {\n+        DateTime test = new DateTime((Object) null, PARIS);\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone=null)\n+     */\n+    public void testConstructor_Object_nullDateTimeZone() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        DateTime test = new DateTime(date, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, DateTimeZone=null)\n+     */\n+    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {\n+        DateTime test = new DateTime((Object) null, (DateTimeZone) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, DateTimeZone)\n+     */\n+    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_Object_Chronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        DateTime test = new DateTime(date, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_invalidObject_Chronology() throws Throwable {\n+        try {\n+            new DateTime(new Object(), GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology)\n+     */\n+    public void testConstructor_nullObject_Chronology() throws Throwable {\n+        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology=null)\n+     */\n+    public void testConstructor_Object_nullChronology() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        DateTime test = new DateTime(date, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null, Chronology=null)\n+     */\n+    public void testConstructor_nullObject_nullChronology() throws Throwable {\n+        DateTime test = new DateTime((Object) null, (Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object, Chronology)\n+     */\n+    public void testConstructor_badconverterObject_Chronology() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n+            assertEquals(ISOChronology.getInstance(), test.getChronology());\n+            assertEquals(0L, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (int, int, int)\n+     */\n+    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {\n+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0);  // +01:00\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(LONDON, test.getZone());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        try {\n+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 0, 9, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 13, 9, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 0, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 31, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateTime(1970, 7, 31, 0, 0, 0, 0);\n+        try {\n+            new DateTime(1970, 7, 32, 0, 0, 0, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, DateTimeZone)\n+     */\n+    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, PARIS);  // +01:00\n+        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        try {\n+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 0, 9, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 13, 9, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 0, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 31, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateTime(1970, 7, 31, 0, 0, 0, 0, PARIS);\n+        try {\n+            new DateTime(1970, 7, 32, 0, 0, 0, 0, PARIS);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, DateTimeZone=null)\n+     */\n+    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {\n+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology)\n+     */\n+    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {\n+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00\n+        assertEquals(GregorianChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+        try {\n+            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DateTime(1970, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        new DateTime(1970, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n+        try {\n+            new DateTime(1970, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (int, int, int, Chronology=null)\n+     */\n+    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {\n+        DateTime test = new DateTime(1970, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00\n+        assertEquals(ISOChronology.getInstance(), test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTime_Properties.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for DateTime.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTime_Properties extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    // 1970-06-09\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 1970-04-05\n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 1971-05-06\n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTime_Properties.class);\n+    }\n+\n+    public TestDateTime_Properties(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPropertyGetYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        assertSame(test.getChronology().year(), test.year().getField());\n+        assertEquals(\"year\", test.year().getName());\n+        assertEquals(\"Property[year]\", test.year().toString());\n+        assertSame(test, test.year().getInstant());\n+        assertSame(test, test.year().getDateTime());\n+        assertEquals(1972, test.year().get());\n+        assertEquals(\"1972\", test.year().getAsText());\n+        assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n+        assertEquals(\"1972\", test.year().getAsShortText());\n+        assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n+        assertEquals(test.getChronology().years(), test.year().getDurationField());\n+        assertEquals(null, test.year().getRangeDurationField());\n+        assertEquals(9, test.year().getMaximumTextLength(null));\n+        assertEquals(9, test.year().getMaximumShortTextLength(null));\n+    }\n+\n+    public void testPropertyGetMaxMinValuesYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        assertEquals(-292275054, test.year().getMinimumValue());\n+        assertEquals(-292275054, test.year().getMinimumValueOverall());\n+        assertEquals(292277023, test.year().getMaximumValue());\n+        assertEquals(292277023, test.year().getMaximumValueOverall());\n+    }\n+\n+    public void testPropertyAddYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        DateTime copy = test.year().addToCopy(9);\n+        assertEquals(\"1972-06-09T00:00:00.000+01:00\", test.toString());\n+        assertEquals(\"1981-06-09T00:00:00.000+01:00\", copy.toString());\n+        \n+        copy = test.year().addToCopy(0);\n+        assertEquals(\"1972-06-09T00:00:00.000+01:00\", copy.toString());\n+        \n+        copy = test.year().addToCopy(292277023 - 1972);\n+        assertEquals(292277023, copy.getYear());\n+        \n+        try {\n+            test.year().addToCopy(292277023 - 1972 + 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        copy = test.year().addToCopy(-1972);\n+        assertEquals(0, copy.getYear());\n+        \n+        copy = test.year().addToCopy(-1973);\n+        assertEquals(-1, copy.getYear());\n+        \n+        try {\n+            test.year().addToCopy(-292275054 - 1972 - 1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testPropertyAddInFieldYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        DateTime copy = test.year().addWrappedToCopy(9);\n+        assertEquals(\"1972-06-09T00:00:00.000+01:00\", test.toString());\n+        assertEquals(\"1981-06-09T00:00:00.000+01:00\", copy.toString());\n+        \n+        copy = test.year().addWrappedToCopy(0);\n+        assertEquals(1972, copy.getYear());\n+        \n+        copy = test.year().addWrappedToCopy(292277023 - 1972 + 1);\n+        assertEquals(-292275054, copy.getYear());\n+        \n+        copy = test.year().addWrappedToCopy(-292275054 - 1972 - 1);\n+        assertEquals(292277023, copy.getYear());\n+    }\n+\n+    public void testPropertySetYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        DateTime copy = test.year().setCopy(1960);\n+        assertEquals(\"1972-06-09T00:00:00.000+01:00\", test.toString());\n+        assertEquals(\"1960-06-09T00:00:00.000+01:00\", copy.toString());\n+    }\n+\n+    public void testPropertySetTextYear() {\n+        DateTime test = new DateTime(1972, 6, 9, 0, 0, 0, 0);\n+        DateTime copy = test.year().setCopy(\"1960\");\n+        assertEquals(\"1972-06-09T00:00:00.000+01:00\", test.toString());\n+        assertEquals(\"1960-06-09T00:00:00.000+01:00\", copy.toString());\n+    }\n+\n+    public void testPropertyCompareToYear() {\n+        DateTime test1 = new DateTime(TEST_TIME1);\n+        DateTime test2 = new DateTime(TEST_TIME2);\n+        assertEquals(true, test1.year().compareTo(test2) < 0);\n+        assertEquals(true, test2.year().compareTo(test1) > 0);\n+        assertEquals(true, test1.year().compareTo(test1) == 0);\n+        try {\n+            test1.year().compareTo(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+//    //-----------------------------------------------------------------------\n+//    public void testPropertyGetMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n+//        assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n+//        assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n+//        assertSame(test, test.monthOfYear().getReadablePartial());\n+//        assertSame(test, test.monthOfYear().getDateTime());\n+//        assertEquals(6, test.monthOfYear().get());\n+//        assertEquals(\"June\", test.monthOfYear().getAsText());\n+//        assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n+//        assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n+//        assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+//        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n+//        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n+//        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n+//        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n+//        test = new DateTime(1972, 7, 9);\n+//        assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n+//        assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n+//    }\n+//\n+//    public void testPropertyGetMaxMinValuesMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        assertEquals(1, test.monthOfYear().getMinimumValue());\n+//        assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n+//        assertEquals(12, test.monthOfYear().getMaximumValue());\n+//        assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n+//    }\n+//\n+//    public void testPropertyAddMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.monthOfYear().addCopy(6);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 12, 9);\n+//        \n+//        copy = test.monthOfYear().addCopy(7);\n+//        check(copy, 1973, 1, 9);\n+//        \n+//        copy = test.monthOfYear().addCopy(-5);\n+//        check(copy, 1972, 1, 9);\n+//        \n+//        copy = test.monthOfYear().addCopy(-6);\n+//        check(copy, 1971, 12, 9);\n+//        \n+//        test = new DateTime(1972, 1, 31);\n+//        copy = test.monthOfYear().addCopy(1);\n+//        check(copy, 1972, 2, 29);\n+//        \n+//        copy = test.monthOfYear().addCopy(2);\n+//        check(copy, 1972, 3, 31);\n+//        \n+//        copy = test.monthOfYear().addCopy(3);\n+//        check(copy, 1972, 4, 30);\n+//        \n+//        test = new DateTime(1971, 1, 31);\n+//        copy = test.monthOfYear().addCopy(1);\n+//        check(copy, 1971, 2, 28);\n+//    }\n+//\n+//    public void testPropertyAddInFieldMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.monthOfYear().addWrappedToCopy(4);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 10, 9);\n+//        \n+//        copy = test.monthOfYear().addWrappedToCopy(8);\n+//        check(copy, 1972, 2, 9);\n+//        \n+//        copy = test.monthOfYear().addWrappedToCopy(-8);\n+//        check(copy, 1972, 10, 9);\n+//        \n+//        test = new DateTime(1972, 1, 31);\n+//        copy = test.monthOfYear().addWrappedToCopy(1);\n+//        check(copy, 1972, 2, 29);\n+//        \n+//        copy = test.monthOfYear().addWrappedToCopy(2);\n+//        check(copy, 1972, 3, 31);\n+//        \n+//        copy = test.monthOfYear().addWrappedToCopy(3);\n+//        check(copy, 1972, 4, 30);\n+//        \n+//        test = new DateTime(1971, 1, 31);\n+//        copy = test.monthOfYear().addWrappedToCopy(1);\n+//        check(copy, 1971, 2, 28);\n+//    }\n+//\n+//    public void testPropertySetMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.monthOfYear().setCopy(12);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 12, 9);\n+//        \n+//        test = new DateTime(1972, 1, 31);\n+//        copy = test.monthOfYear().setCopy(2);\n+//        check(copy, 1972, 2, 29);\n+//        \n+//        try {\n+//            test.monthOfYear().setCopy(13);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//        try {\n+//            test.monthOfYear().setCopy(0);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//    }\n+//\n+//    public void testPropertySetTextMonth() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.monthOfYear().setCopy(\"12\");\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 12, 9);\n+//        \n+//        copy = test.monthOfYear().setCopy(\"December\");\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 12, 9);\n+//        \n+//        copy = test.monthOfYear().setCopy(\"Dec\");\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 12, 9);\n+//    }\n+//\n+//    public void testPropertyCompareToMonth() {\n+//        DateTime test1 = new DateTime(TEST_TIME1);\n+//        DateTime test2 = new DateTime(TEST_TIME2);\n+//        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);\n+//        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);\n+//        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);\n+//        try {\n+//            test1.monthOfYear().compareTo((ReadablePartial) null);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//        \n+//        DateTime dt1 = new DateTime(TEST_TIME1);\n+//        DateTime dt2 = new DateTime(TEST_TIME2);\n+//        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);\n+//        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);\n+//        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);\n+//        try {\n+//            test1.monthOfYear().compareTo((ReadableInstant) null);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    public void testPropertyGetDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n+//        assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n+//        assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n+//        assertSame(test, test.dayOfMonth().getReadablePartial());\n+//        assertSame(test, test.dayOfMonth().getDateTime());\n+//        assertEquals(9, test.dayOfMonth().get());\n+//        assertEquals(\"9\", test.dayOfMonth().getAsText());\n+//        assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n+//        assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n+//        assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n+//        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n+//        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n+//        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n+//        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n+//    }\n+//\n+//    public void testPropertyGetMaxMinValuesDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        assertEquals(1, test.dayOfMonth().getMinimumValue());\n+//        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n+//        assertEquals(30, test.dayOfMonth().getMaximumValue());\n+//        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n+//        test = new DateTime(1972, 7, 9);\n+//        assertEquals(31, test.dayOfMonth().getMaximumValue());\n+//        test = new DateTime(1972, 2, 9);\n+//        assertEquals(29, test.dayOfMonth().getMaximumValue());\n+//        test = new DateTime(1971, 2, 9);\n+//        assertEquals(28, test.dayOfMonth().getMaximumValue());\n+//    }\n+//\n+//    public void testPropertyAddDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.dayOfMonth().addCopy(9);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 6, 18);\n+//        \n+//        copy = test.dayOfMonth().addCopy(21);\n+//        check(copy, 1972, 6, 30);\n+//        \n+//        copy = test.dayOfMonth().addCopy(22);\n+//        check(copy, 1972, 7, 1);\n+//        \n+//        copy = test.dayOfMonth().addCopy(22 + 30);\n+//        check(copy, 1972, 7, 31);\n+//        \n+//        copy = test.dayOfMonth().addCopy(22 + 31);\n+//        check(copy, 1972, 8, 1);\n+//\n+//        copy = test.dayOfMonth().addCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);\n+//        check(copy, 1972, 12, 31);\n+//        \n+//        copy = test.dayOfMonth().addCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);\n+//        check(copy, 1973, 1, 1);\n+//        \n+//        copy = test.dayOfMonth().addCopy(-8);\n+//        check(copy, 1972, 6, 1);\n+//        \n+//        copy = test.dayOfMonth().addCopy(-9);\n+//        check(copy, 1972, 5, 31);\n+//        \n+//        copy = test.dayOfMonth().addCopy(-8 - 31 - 30 - 31 - 29 - 31);\n+//        check(copy, 1972, 1, 1);\n+//        \n+//        copy = test.dayOfMonth().addCopy(-9 - 31 - 30 - 31 - 29 - 31);\n+//        check(copy, 1971, 12, 31);\n+//    }\n+//\n+//    public void testPropertyAddInFieldDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.dayOfMonth().addWrappedToCopy(21);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 6, 30);\n+//        \n+//        copy = test.dayOfMonth().addWrappedToCopy(22);\n+//        check(copy, 1972, 6, 1);\n+//        \n+//        copy = test.dayOfMonth().addWrappedToCopy(-12);\n+//        check(copy, 1972, 6, 27);\n+//        \n+//        test = new DateTime(1972, 7, 9);\n+//        copy = test.dayOfMonth().addWrappedToCopy(21);\n+//        check(copy, 1972, 7, 30);\n+//    \n+//        copy = test.dayOfMonth().addWrappedToCopy(22);\n+//        check(copy, 1972, 7, 31);\n+//    \n+//        copy = test.dayOfMonth().addWrappedToCopy(23);\n+//        check(copy, 1972, 7, 1);\n+//    \n+//        copy = test.dayOfMonth().addWrappedToCopy(-12);\n+//        check(copy, 1972, 7, 28);\n+//    }\n+//\n+//    public void testPropertySetDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.dayOfMonth().setCopy(12);\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 6, 12);\n+//        \n+//        try {\n+//            test.dayOfMonth().setCopy(31);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//        try {\n+//            test.dayOfMonth().setCopy(0);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//    }\n+//\n+//    public void testPropertySetTextDay() {\n+//        DateTime test = new DateTime(1972, 6, 9);\n+//        DateTime copy = test.dayOfMonth().setCopy(\"12\");\n+//        check(test, 1972, 6, 9);\n+//        check(copy, 1972, 6, 12);\n+//    }\n+//\n+//    public void testPropertyCompareToDay() {\n+//        DateTime test1 = new DateTime(TEST_TIME1);\n+//        DateTime test2 = new DateTime(TEST_TIME2);\n+//        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);\n+//        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);\n+//        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);\n+//        try {\n+//            test1.dayOfMonth().compareTo((ReadablePartial) null);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//        \n+//        DateTime dt1 = new DateTime(TEST_TIME1);\n+//        DateTime dt2 = new DateTime(TEST_TIME2);\n+//        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);\n+//        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);\n+//        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);\n+//        try {\n+//            test1.dayOfMonth().compareTo((ReadableInstant) null);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//    }\n+//\n+//    //-----------------------------------------------------------------------\n+//    private void check(DateTime test, int hour, int min, int sec) {\n+//        assertEquals(hour, test.getYear());\n+//        assertEquals(min, test.getMonthOfYear());\n+//        assertEquals(sec, test.getDayOfMonth());\n+//    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for Instant.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestInstant_Basics extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    // 1970-06-09\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 1970-04-05\n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 1971-05-06\n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestInstant_Basics.class);\n+    }\n+\n+    public TestInstant_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        Instant test = new Instant();\n+        assertEquals(1, test.get(ISOChronology.getInstance().era()));\n+        assertEquals(19, test.get(ISOChronology.getInstance().centuryOfEra()));\n+        assertEquals(70, test.get(ISOChronology.getInstance().yearOfCentury()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().yearOfEra()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().year()));\n+        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n+        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n+        assertEquals(1970, test.get(ISOChronology.getInstance().weekyear()));\n+        assertEquals(24, test.get(ISOChronology.getInstance().weekOfWeekyear()));\n+        assertEquals(2, test.get(ISOChronology.getInstance().dayOfWeek()));\n+        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));\n+        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));\n+        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));\n+        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));\n+        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n+        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));\n+        try {\n+            test.get(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testGetMethods() {\n+        Instant test = new Instant();\n+        \n+        assertEquals(null, test.getChronology());\n+        assertEquals(null, test.getZone());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    public void testEqualsHashCode() {\n+        Instant test1 = new Instant(TEST_TIME1);\n+        Instant test2 = new Instant(TEST_TIME1);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        Instant test3 = new Instant(TEST_TIME2);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockInstant()));\n+        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));\n+    }\n+    \n+    class MockInstant extends AbstractInstant {\n+        public String toString() {\n+            return null;\n+        }\n+        public long getMillis() {\n+            return TEST_TIME1;\n+        }\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+    }\n+\n+    public void testCompareTo() {\n+        Instant test1 = new Instant(TEST_TIME1);\n+        Instant test1a = new Instant(TEST_TIME1);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        Instant test2 = new Instant(TEST_TIME2);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(+1, test2.compareTo(new MockInstant()));\n+        assertEquals(0, test1.compareTo(new MockInstant()));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Date());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    public void testIsEqual() {\n+        Instant test1 = new Instant(TEST_TIME1);\n+        Instant test1a = new Instant(TEST_TIME1);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        Instant test2 = new Instant(TEST_TIME2);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        assertEquals(false, test2.isEqual(new MockInstant()));\n+        assertEquals(true, test1.isEqual(new MockInstant()));\n+        assertEquals(false, test1.isEqual(null));\n+    }\n+    \n+    public void testIsBefore() {\n+        Instant test1 = new Instant(TEST_TIME1);\n+        Instant test1a = new Instant(TEST_TIME1);\n+        assertEquals(false, test1.isBefore(test1a));\n+        assertEquals(false, test1a.isBefore(test1));\n+        assertEquals(false, test1.isBefore(test1));\n+        assertEquals(false, test1a.isBefore(test1a));\n+        \n+        Instant test2 = new Instant(TEST_TIME2);\n+        assertEquals(true, test1.isBefore(test2));\n+        assertEquals(false, test2.isBefore(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(true, test1.isBefore(test3));\n+        assertEquals(false, test3.isBefore(test1));\n+        assertEquals(false, test3.isBefore(test2));\n+        \n+        assertEquals(false, test2.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(new MockInstant()));\n+        assertEquals(false, test1.isBefore(null));\n+    }\n+    \n+    public void testIsAfter() {\n+        Instant test1 = new Instant(TEST_TIME1);\n+        Instant test1a = new Instant(TEST_TIME1);\n+        assertEquals(false, test1.isAfter(test1a));\n+        assertEquals(false, test1a.isAfter(test1));\n+        assertEquals(false, test1.isAfter(test1));\n+        assertEquals(false, test1a.isAfter(test1a));\n+        \n+        Instant test2 = new Instant(TEST_TIME2);\n+        assertEquals(false, test1.isAfter(test2));\n+        assertEquals(true, test2.isAfter(test1));\n+        \n+        DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));\n+        assertEquals(false, test1.isAfter(test3));\n+        assertEquals(true, test3.isAfter(test1));\n+        assertEquals(false, test3.isAfter(test2));\n+        \n+        assertEquals(true, test2.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(new MockInstant()));\n+        assertEquals(false, test1.isAfter(null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Instant test = new Instant(TEST_TIME_NOW);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Instant result = (Instant) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Instant test = new Instant(TEST_TIME_NOW);\n+        assertEquals(\"1970-06-09T00:00:00.000Z\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToInstant() {\n+        Instant test = new Instant(TEST_TIME1);\n+        Instant result = test.toInstant();\n+        assertSame(test, result);\n+    }\n+\n+    public void testToDateTime() {\n+        Instant test = new Instant(TEST_TIME1);\n+        DateTime result = test.toDateTime();\n+        assertEquals(TEST_TIME1, result.getMillis());\n+    }\n+\n+    public void testToDateTime_DateTimeZone() {\n+        Instant test = new Instant(TEST_TIME1);\n+        DateTime result = test.toDateTime(LONDON);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToDateTime_Chronology() {\n+        Instant test = new Instant(TEST_TIME1);\n+        DateTime result = test.toDateTime(ISOChronology.getInstance());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toDateTime((Chronology) null);\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToTrustedISODateTime() {\n+        Instant test = new Instant(TEST_TIME1);\n+        DateTime result = test.toTrustedISODateTime();\n+        assertSame(DateTime.class, result.getClass());\n+        assertSame(ISOChronology.class, result.getChronology().getClass());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime() {\n+        Instant test = new Instant(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime();\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_DateTimeZone() {\n+        Instant test = new Instant(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime(LONDON);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toMutableDateTime(PARIS);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toMutableDateTime((DateTimeZone) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToMutableDateTime_Chronology() {\n+        Instant test = new Instant(TEST_TIME1);\n+        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toMutableDateTime((Chronology) null);\n+        assertEquals(test.getMillis(), result.getMillis());\n+        assertEquals(ISOChronology.getInstance(), result.getChronology());\n+    }\n+\n+    public void testToDate() {\n+        Instant test = new Instant(TEST_TIME1);\n+        Date result = test.toDate();\n+        assertEquals(test.getMillis(), result.getTime());\n+    }\n+\n+    public void testToCalendar_Locale() {\n+        Instant test = new Instant(TEST_TIME1);\n+        Calendar result = test.toCalendar(null);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+\n+        test = new Instant(TEST_TIME1);\n+        result = test.toCalendar(Locale.UK);\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+    }\n+\n+    public void testToGregorianCalendar() {\n+        Instant test = new Instant(TEST_TIME1);\n+        GregorianCalendar result = test.toGregorianCalendar();\n+        assertEquals(test.getMillis(), result.getTime().getTime());\n+        assertEquals(TimeZone.getTimeZone(\"Europe/London\"), result.getTimeZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithMillis_long() {\n+        Instant test = new Instant(TEST_TIME1);\n+        Instant result = test.withMillis(TEST_TIME2);\n+        assertEquals(TEST_TIME2, result.getMillis());\n+        assertEquals(test.getChronology(), result.getChronology());\n+        \n+        test = new Instant(TEST_TIME1);\n+        result = test.withMillis(TEST_TIME1);\n+        assertSame(test, result);\n+    }\n+\n+    public void testImmutable() {\n+        assertTrue(Modifier.isFinal(Instant.class.getModifiers()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestInstant_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.MockZeroNullIntegerConverter;\n+\n+/**\n+ * This class is a Junit unit test for Instant.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestInstant_Constructors extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    // 1970-06-09\n+    private long TEST_TIME_NOW =\n+            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 1970-04-05\n+    private long TEST_TIME1 =\n+        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 1971-05-06\n+    private long TEST_TIME2 =\n+        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+        + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    private DateTimeZone zone = null;\n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestInstant_Constructors.class);\n+    }\n+\n+    public TestInstant_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        locale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        Locale.setDefault(locale);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor() throws Throwable {\n+        Instant test = new Instant();\n+        assertEquals(null, test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long1() throws Throwable {\n+        Instant test = new Instant(TEST_TIME1);\n+        assertEquals(null, test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (long)\n+     */\n+    public void testConstructor_long2() throws Throwable {\n+        Instant test = new Instant(TEST_TIME2);\n+        assertEquals(null, test.getChronology());\n+        assertEquals(TEST_TIME2, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object() throws Throwable {\n+        Date date = new Date(TEST_TIME1);\n+        Instant test = new Instant(date);\n+        assertEquals(null, test.getChronology());\n+        assertEquals(TEST_TIME1, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_invalidObject() throws Throwable {\n+        try {\n+            new Instant(new Object());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_nullObject() throws Throwable {\n+        Instant test = new Instant((Object) null);\n+        assertEquals(null, test.getChronology());\n+        assertEquals(TEST_TIME_NOW, test.getMillis());\n+    }\n+\n+    /**\n+     * Test constructor (Object=null)\n+     */\n+    public void testConstructor_badconverterObject() throws Throwable {\n+        try {\n+            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+            Instant test = new Instant(new Integer(0));\n+            assertEquals(null, test.getChronology());\n+            assertEquals(0L, test.getMillis());\n+        } finally {\n+            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n+        }\n+    }\n+\n+}", "timestamp": 1088894363, "metainfo": ""}