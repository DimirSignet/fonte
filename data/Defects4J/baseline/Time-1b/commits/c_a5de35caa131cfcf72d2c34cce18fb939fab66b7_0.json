{"sha": "a5de35caa131cfcf72d2c34cce18fb939fab66b7", "log": "Support properties.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateOnly.java\n+++ b/JodaTime/src/java/org/joda/time/DateOnly.java\n // Import for @link support\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n-\n-/*\n+import org.joda.time.property.DateOnlyFieldProperty;\n+\n+/**\n+ * DateOnly is the basic implementation of a date only class supporting\n+ * chronologies. It holds the date as milliseconds from the Java epoch of\n+ * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n  * <p>Each individual field can be queried in two ways:\n  * <ul>\n  * <li><code>getYear()</code>\n  * <li>maximum value\n  * <li>minimum value\n  * </ul>\n- */\n-\n-/**\n- * DateOnly is the basic implementation of a date only class supporting\n- * chronologies. It holds the date as milliseconds from the Java epoch of\n- * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.\n  * <p>\n  * DateOnly is thread-safe and immutable, provided that the Chronology is as\n  * well. All standard Chronology classes supplied are thread-safe and\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n+ * @see MutableDateOnly\n  * @see TimeOnly\n  * @see DateTime\n  */\n     }\n \n     /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the millis will change, the chronology is kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public ReadableInstant toCopy(long newMillis) {\n+        newMillis = resetUnsupportedFields(newMillis);\n+        return newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology());\n+    }\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the chronology will change, the millis are kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public ReadableInstant toCopy(Chronology newChronology) {\n+        if (newChronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        newChronology = newChronology.withUTC();\n+        return newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology);\n+    }\n+\n+    /**\n      * Returns the lower limiting field, dayOfYear.\n      *\n      * @return dayOfYear field\n         return null;\n     }\n \n-    public final boolean isMatchingType(ReadableInstant instant) {\n-        return instant instanceof DateOnly;\n-    }\n-\n     // Date field access\n     //-----------------------------------------------------------------------\n     /**\n         return getChronology().dayOfWeek().get(getMillis());\n     }\n \n-    // TODO: DateTimeFieldProperty cannot be constructed with anything but\n-    // DateTime.\n \n     // Properties\n     //-----------------------------------------------------------------------\n      * The values for day of week are defined in {@link DateTimeConstants}.\n      * \n      * @return the day of week property\n-     * /\n-    public final DateTimeFieldProperty dayOfWeek() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());\n+     */\n+    public final DateOnlyFieldProperty dayOfWeek() {\n+        return new DateOnlyFieldProperty(this, getChronology().dayOfWeek());\n     }\n \n     /**\n      * Get the day of month property.\n      * \n      * @return the day of month property\n-     * /\n-    public final DateTimeFieldProperty dayOfMonth() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n+     */\n+    public final DateOnlyFieldProperty dayOfMonth() {\n+        return new DateOnlyFieldProperty(this, getChronology().dayOfMonth());\n     }\n \n     /**\n      * Get the day of year property.\n      * \n      * @return the day of year property\n-     * /\n-    public final DateTimeFieldProperty dayOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n+     */\n+    public final DateOnlyFieldProperty dayOfYear() {\n+        return new DateOnlyFieldProperty(this, getChronology().dayOfYear());\n     }\n \n     /**\n      * Get the week of a week based year property.\n      * \n      * @return the week of a week based year property\n-     * /\n-    public final DateTimeFieldProperty weekOfWeekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+     */\n+    public final DateOnlyFieldProperty weekOfWeekyear() {\n+        return new DateOnlyFieldProperty(this, getChronology().weekOfWeekyear());\n     }\n \n     /**\n      * Get the year of a week based year property.\n      * \n      * @return the year of a week based year property\n-     * /\n-    public final DateTimeFieldProperty weekyear() {\n-        return new DateTimeFieldProperty(this, getChronology().weekyear());\n+     */\n+    public final DateOnlyFieldProperty weekyear() {\n+        return new DateOnlyFieldProperty(this, getChronology().weekyear());\n     }\n \n     /**\n      * Get the month of year property.\n      * \n      * @return the month of year property\n-     * /\n-    public final DateTimeFieldProperty monthOfYear() {\n-        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n+     */\n+    public final DateOnlyFieldProperty monthOfYear() {\n+        return new DateOnlyFieldProperty(this, getChronology().monthOfYear());\n     }\n \n     /**\n      * Get the year property.\n      * \n      * @return the year property\n-     * /\n-    public final DateTimeFieldProperty year() {\n-        return new DateTimeFieldProperty(this, getChronology().year());\n+     */\n+    public final DateOnlyFieldProperty year() {\n+        return new DateOnlyFieldProperty(this, getChronology().year());\n     }\n \n     /**\n      * Get the year of era property.\n      * \n      * @return the year of era property\n-     * /\n-    public final DateTimeFieldProperty yearOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n+     */\n+    public final DateOnlyFieldProperty yearOfEra() {\n+        return new DateOnlyFieldProperty(this, getChronology().yearOfEra());\n     }\n \n     /**\n      * Get the year of century property.\n      * \n      * @return the year of era property\n-     * /\n-    public final DateTimeFieldProperty yearOfCentury() {\n-        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n+     */\n+    public final DateOnlyFieldProperty yearOfCentury() {\n+        return new DateOnlyFieldProperty(this, getChronology().yearOfCentury());\n     }\n \n     /**\n      * Get the century of era property.\n      * \n      * @return the year of era property\n-     * /\n-    public final DateTimeFieldProperty centuryOfEra() {\n-        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n+     */\n+    public final DateOnlyFieldProperty centuryOfEra() {\n+        return new DateOnlyFieldProperty(this, getChronology().centuryOfEra());\n     }\n \n     /**\n      * Get the era property.\n      * \n      * @return the era property\n-     * /\n-    public final DateTimeFieldProperty era() {\n-        return new DateTimeFieldProperty(this, getChronology().era());\n-    }\n-    */\n+     */\n+    public final DateOnlyFieldProperty era() {\n+        return new DateOnlyFieldProperty(this, getChronology().era());\n+    }\n \n     // Output\n     //-----------------------------------------------------------------------\n         return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());\n     }\n \n-    protected ReadableInstant create(long millis, Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        if (millis == getMillis() && chronology == getChronology()) {\n-            return this;\n-        }\n-        return new DateOnly(millis, chronology);\n-    }\n-\n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are\n      * immutable.\n--- a/JodaTime/src/java/org/joda/time/TimeOnly.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java\n // Import for @link support\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n-\n-/*\n+import org.joda.time.property.TimeOnlyFieldProperty;\n+\n+/**\n+ * TimeOnly is the basic implementation of a time only class supporting\n+ * chronologies. It holds the time as milliseconds from T00:00:00. The date\n+ * component and time zone is fixed at 1970-01-01TZ.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n  * <p>Each individual field can be queried in two ways:\n  * <ul>\n  * <li><code>getHourOfDay()</code>\n  * <li>maximum value\n  * <li>minimum value\n  * </ul>\n- */\n-\n-/**\n- * TimeOnly is the basic implementation of a time only class supporting\n- * chronologies. It holds the time as milliseconds from T00:00:00. The date\n- * component and time zone is fixed at 1970-01-01TZ.\n  * <p>\n  * TimeOnly is thread-safe and immutable, provided that the Chronology is as\n  * well. All standard Chronology classes supplied are thread-safe and\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n+ * @see MutableTimeOnly\n  * @see DateOnly\n  * @see DateTime\n  */\n     }\n \n     /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the millis will change, the chronology is kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public ReadableInstant toCopy(long newMillis) {\n+        newMillis = resetUnsupportedFields(newMillis);\n+        return newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology());\n+    }\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the chronology will change, the millis are kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public ReadableInstant toCopy(Chronology newChronology) {\n+        if (newChronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        newChronology = newChronology.withUTC();\n+        return newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology);\n+    }\n+\n+    /**\n      * Returns the lower limiting field, null.\n      *\n      * @return null.\n         return getChronology().dayOfYear();\n     }\n \n-    public final boolean isMatchingType(ReadableInstant instant) {\n-        return instant instanceof TimeOnly;\n-    }\n-\n     // Time field access\n     //-----------------------------------------------------------------------\n     /**\n-     * Get the hour of day field value.\n+     * Get the hour of day (0-23) field value.\n      *\n      * @return the hour of day\n      */\n     }\n \n     /**\n+     * Get the hour of day (offset to 1-24) field value.\n+     * \n+     * @return the clockhour of day\n+     */\n+    public final int getClockhourOfDay() {\n+        return getChronology().clockhourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field value.\n+     * \n+     * @return the hour of halfday\n+     */\n+    public final int getHourOfHalfday() {\n+        return getChronology().hourOfHalfday().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field value.\n+     * \n+     * @return the clockhour of halfday\n+     */\n+    public final int getClockhourOfHalfday() {\n+        return getChronology().clockhourOfHalfday().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field value.\n+     * \n+     * @return the halfday of day\n+     */\n+    public final int getHalfdayOfDay() {\n+        return getChronology().halfdayOfDay().get(getMillis());\n+    }\n+\n+    /**\n      * Get the minute of day field value.\n      *\n      * @return the minute of day\n         return getChronology().millisOfSecond().get(getMillis());\n     }\n \n-    // TODO: DateTimeFieldProperty cannot be constructed with anything but\n-    // DateTime.\n-\n     // Properties\n     //-----------------------------------------------------------------------\n     /**\n-     * Get the hour of day field property\n+     * Get the hour of day (0-23) field property\n      * \n      * @return the hour of day property\n-     * /\n-    public final DateTimeFieldProperty hourOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n+     */\n+    public final TimeOnlyFieldProperty hourOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field property\n+     * \n+     * @return the clockhour of day property\n+     */\n+    public final TimeOnlyFieldProperty clockhourOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field property\n+     * \n+     * @return the hour of halfday property\n+     */\n+    public final TimeOnlyFieldProperty hourOfHalfday() {\n+        return new TimeOnlyFieldProperty(this, getChronology().hourOfHalfday());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field property\n+     * \n+     * @return the clockhour of halfday property\n+     */\n+    public final TimeOnlyFieldProperty clockhourOfHalfday() {\n+        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfHalfday());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field property\n+     * \n+     * @return the halfday of day property\n+     */\n+    public final TimeOnlyFieldProperty halfdayOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().halfdayOfDay());\n     }\n \n     /**\n      * Get the minute of day property\n      * \n      * @return the minute of day property\n-     * /\n-    public final DateTimeFieldProperty minuteOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n+     */\n+    public final TimeOnlyFieldProperty minuteOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().minuteOfDay());\n     }\n \n     /**\n      * Get the minute of hour field property\n      * \n      * @return the minute of hour property\n-     * /\n-    public final DateTimeFieldProperty minuteOfHour() {\n-        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n+     */\n+    public final TimeOnlyFieldProperty minuteOfHour() {\n+        return new TimeOnlyFieldProperty(this, getChronology().minuteOfHour());\n     }\n \n     /**\n      * Get the second of day property\n      * \n      * @return the second of day property\n-     * /\n-    public final DateTimeFieldProperty secondOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n+     */\n+    public final TimeOnlyFieldProperty secondOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().secondOfDay());\n     }\n \n     /**\n      * Get the second of minute field property\n      * \n      * @return the second of minute property\n-     * /\n-    public final DateTimeFieldProperty secondOfMinute() {\n-        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n+     */\n+    public final TimeOnlyFieldProperty secondOfMinute() {\n+        return new TimeOnlyFieldProperty(this, getChronology().secondOfMinute());\n     }\n \n     /**\n      * Get the millis of day property\n      * \n      * @return the millis of day property\n-     * /\n-    public final DateTimeFieldProperty millisOfDay() {\n-        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n+     */\n+    public final TimeOnlyFieldProperty millisOfDay() {\n+        return new TimeOnlyFieldProperty(this, getChronology().millisOfDay());\n     }\n \n     /**\n      * Get the millis of second property\n      * \n      * @return the millis of second property\n-     * /\n-    public final DateTimeFieldProperty millisOfSecond() {\n-        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());\n-    }\n-    */\n+     */\n+    public final TimeOnlyFieldProperty millisOfSecond() {\n+        return new TimeOnlyFieldProperty(this, getChronology().millisOfSecond());\n+    }\n \n     // Output\n     //-----------------------------------------------------------------------\n             .hourMinuteSecondFraction().print(getMillis());\n     }\n \n-    protected ReadableInstant create(long millis, Chronology chronology) {\n-        if (chronology == null) {\n-            throw new IllegalArgumentException(\"The Chronology must not be null\");\n-        }\n-        if (millis == getMillis() && chronology == getChronology()) {\n-            return this;\n-        }\n-        return new TimeOnly(millis, chronology);\n-    }\n-    \n     /**\n      * Overridden to do nothing, ensuring this class and all subclasses are\n      * immutable.", "timestamp": 1073096733, "metainfo": ""}