{"sha": "2c4229d024d32e4d7bbd3f8efe8cdc6cff84b969", "log": "Support object conversion using automatic duration type selection.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n     /**\n      * Copies another duration to this one.\n      *\n+     * @param duration duration to copy\n+     * @throws IllegalArgumentException if duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     public AbstractDuration(ReadableDuration duration) {\n+        super();\n         // Only call a private method\n         setDuration(iType = duration.getDurationType(), duration);\n     }\n \n     /**\n+     * Copies another duration to this one.\n+     *\n+     * @param duration duration to convert\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public AbstractDuration(Object duration) {\n+        super();\n+        if (duration instanceof ReadableDuration) {\n+            // Only call a private method\n+            ReadableDuration rd = (ReadableDuration) duration;\n+            setDuration(iType = rd.getDurationType(), rd);\n+        } else {\n+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+            DurationType type = converter.getDurationType(duration);\n+            if (type.isPrecise() && converter.isPrecise(duration)) {\n+                // Only call a private method\n+                setTotalMillis(iType = type, converter.getDurationMillis(duration));\n+            } else if (this instanceof ReadWritableDuration) {\n+                iType = type;\n+                converter.setInto((ReadWritableDuration) this, duration);\n+            } else {\n+                // Only call a private method\n+                setDuration(iType = type, new MutableDuration(type, duration));\n+            }\n+        }\n+    }\n+\n+    /**\n      * Creates a zero length duration.\n      *\n      * @param type determines which set of fields this duration supports\n+     * @throws IllegalArgumentException if type is null\n      */\n     public AbstractDuration(DurationType type) {\n-        iType = type;\n+        super();\n+        // Only call a private method\n+        setTotalMillis(iType = type, 0);\n     }\n \n     /**\n      *\n      * @param type use a different DurationType\n      * @param duration duration to copy\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     public AbstractDuration(DurationType type, ReadableDuration duration) {\n+        super();\n         // Only call a private method\n         setDuration(iType = type, duration);\n     }\n      *\n      * @param type use a different DurationType\n      * @param duration duration to convert\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     public AbstractDuration(DurationType type, Object duration) {\n+        super();\n         if (duration instanceof ReadableDuration) {\n             // Only call a private method\n             setDuration(iType = type, (ReadableDuration) duration);\n             if (type.isPrecise() && converter.isPrecise(duration)) {\n                 // Only call a private method\n                 setTotalMillis(iType = type, converter.getDurationMillis(duration));\n+            } else if (this instanceof ReadWritableDuration) {\n+                iType = type;\n+                converter.setInto((ReadWritableDuration) this, duration);\n             } else {\n                 // Only call a private method\n                 setDuration(iType = type, new MutableDuration(type, duration));\n      * Create a duration from a set of field values.\n      *\n      * @param type determines which set of fields this duration supports\n+     * @param years amount of years in this duration, which must be zero if\n+     * unsupported.\n+     * @param months amount of months in this duration, which must be zero if\n+     * unsupported.\n+     * @param weeks amount of weeks in this duration, which must be zero if\n+     * unsupported.\n+     * @param days amount of days in this duration, which must be zero if\n+     * unsupported.\n+     * @param hours amount of hours in this duration, which must be zero if\n+     * unsupported.\n+     * @param minutes amount of minutes in this duration, which must be zero if\n+     * unsupported.\n+     * @param seconds amount of seconds in this duration, which must be zero if\n+     * unsupported.\n+     * @param millis amount of milliseconds in this duration, which must be\n+     * zero if unsupported.\n+     * @throws IllegalArgumentException if type is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public AbstractDuration(DurationType type,\n+                            int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis) {\n+        super();\n+        // Only call a private method\n+        setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start, in milliseconds\n+     * @param endInstant interval end, in milliseconds\n+     * @throws IllegalArgumentException if type is null\n+     */\n+    public AbstractDuration(DurationType type, long startInstant, long endInstant) {\n+        super();\n+        // Only call a private method\n+        setTotalMillis(iType = type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param startInstant interval start\n+     * @param endInstant interval end\n+     * @throws IllegalArgumentException if type is null\n+     */\n+    public AbstractDuration(DurationType type,\n+                            ReadableInstant startInstant, ReadableInstant  endInstant) {\n+        super();\n+        // Only call a private method\n+        setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration. If any supported\n+     * fields are imprecise, an UnsupportedOperationException is thrown. The\n+     * exception to this is when the specified duration is zero.\n+     *\n+     * @param type determines which set of fields this duration supports\n+     * @param duration  the duration, in milliseconds\n+     * @throws IllegalArgumentException if type is null\n+     * @throws UnsupportedOperationException if any fields are imprecise\n+     */\n+    public AbstractDuration(DurationType type, long duration) {\n+        super();\n+        // Only call a private method\n+        setTotalMillis(iType = type, duration);\n+    }\n+\n+    /**\n+     * Returns the object which defines which fields this duration supports.\n+     */\n+    public final DurationType getDurationType() {\n+        return iType;\n+    }\n+\n+    /**\n+     * Gets the total length of this duration in milliseconds, \n+     * failing if the duration is imprecise.\n+     *\n+     * @return the total length of the duration in milliseconds.\n+     * @throws IllegalStateException if the duration is imprecise\n+     */\n+    public final long getTotalMillis() {\n+        int state = iTotalMillisState;\n+        if (state == 0) {\n+            state = updateTotalMillis();\n+        }\n+        if (state != 2) {\n+            throw new IllegalStateException(\"Duration is imprecise\");\n+        }\n+        return iTotalMillis;\n+    }\n+\n+    /**\n+     * Is this duration a precise length of time, or descriptive.\n+     * <p>\n+     * A precise duration could include millis, seconds, minutes or hours.\n+     * However, days, weeks, months and years can vary in length, resulting in\n+     * an imprecise duration.\n+     * <p>\n+     * An imprecise duration can be made precise by pairing it with a\n+     * date in a {@link ReadableInterval}.\n+     *\n+     * @return true if the duration is precise\n+     */\n+    public final boolean isPrecise() {\n+        int state = iTotalMillisState;\n+        if (state == 0) {\n+            state = updateTotalMillis();\n+        }\n+        return state == 2;\n+    }\n+\n+    /**\n+     * Walks through the field values, determining total millis and whether\n+     * this duration is precise.\n+     *\n+     * @return new state\n+     */\n+    private int updateTotalMillis() {\n+        final DurationType type = iType;\n+\n+        boolean isPrecise = true;\n+        long totalMillis = 0;\n+\n+        DurationField field;\n+        int value;\n+\n+        if ((value = iYears) != 0) {\n+            field = type.years();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMonths) != 0) {\n+            field = type.months();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iWeeks) != 0) {\n+            field = type.weeks();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iDays) != 0) {\n+            field = type.days();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iHours) != 0) {\n+            field = type.hours();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMinutes) != 0) {\n+            field = type.minutes();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iSeconds) != 0) {\n+            field = type.seconds();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+        if ((value = iMillis) != 0) {\n+            field = type.millis();\n+            if (isPrecise &= field.isPrecise()) {\n+                totalMillis += field.getMillis(value);\n+            }\n+        }\n+\n+        if (isPrecise) {\n+            iTotalMillis = totalMillis;\n+            return iTotalMillisState = 2;\n+        } else {\n+            iTotalMillis = totalMillis;\n+            return iTotalMillisState = 1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar) {\n+        return addTo(instant, scalar, null);\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new value.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n+     * duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @param chrono  override the duration's chronology, unless null is passed in\n+     * @return milliseconds value plus this duration times scalar\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final long addTo(long instant, int scalar, Chronology chrono) {\n+        if (isPrecise()) {\n+            return instant += getTotalMillis() * scalar;\n+        }\n+\n+        DurationType type = iType;\n+        if (chrono != null) {\n+            type = type.withChronology(chrono);\n+        }\n+\n+        int value;\n+\n+        if ((value = scaleValue(iYears, scalar)) != 0) {\n+            instant = type.years().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMonths, scalar)) != 0) {\n+            instant = type.months().add(instant, value);\n+        }\n+        if ((value = scaleValue(iWeeks, scalar)) != 0) {\n+            instant = type.weeks().add(instant, value);\n+        }\n+        if ((value = scaleValue(iDays, scalar)) != 0) {\n+            instant = type.days().add(instant, value);\n+        }\n+        if ((value = scaleValue(iHours, scalar)) != 0) {\n+            instant = type.hours().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMinutes, scalar)) != 0) {\n+            instant = type.minutes().add(instant, value);\n+        }\n+        if ((value = scaleValue(iSeconds, scalar)) != 0) {\n+            instant = type.seconds().add(instant, value);\n+        }\n+        if ((value = scaleValue(iMillis, scalar)) != 0) {\n+            instant = type.millis().add(instant, value);\n+        }\n+\n+        return instant;\n+    }\n+\n+    private static int scaleValue(int value, int scalar) {\n+        switch (scalar) {\n+        case -1:\n+            return -value;\n+        case 0:\n+            return 0;\n+        case 1:\n+            return value;\n+        default:\n+            return value * scalar;\n+        }\n+    }\n+\n+    /**\n+     * Adds this duration to the given instant, returning a new Instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to add the duration to\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @return instant with the original value plus this duration times scalar\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {\n+        return instant.toCopy(addTo(instant.getMillis(), scalar));\n+    }\n+\n+    /**\n+     * Adds this duration into the given mutable instant.\n+     * <p>\n+     * To add just once, pass in a scalar of one. To subtract once, pass\n+     * in a scaler of minus one.\n+     *\n+     * @param instant  the instant to update with the added duration\n+     * @param scalar  the number of times to add the duration, negative to subtract\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws ArithmeticException if the result of the calculation is too large\n+     */\n+    public final void addInto(ReadWritableInstant instant, int scalar) {\n+        instant.setMillis(addTo(instant.getMillis(), scalar));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the duration.\n+     * \n+     * @return the number of years in the duration, zero if unsupported\n+     */\n+    public final int getYears() {\n+        return iYears;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the months field part of the duration.\n+     * \n+     * @return the number of months in the duration, zero if unsupported\n+     */\n+    public final int getMonths() {\n+        return iMonths;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the weeks field part of the duration.\n+     * \n+     * @return the number of weeks in the duration, zero if unsupported\n+     */\n+    public final int getWeeks() {\n+        return iWeeks;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the days field part of the duration.\n+     * \n+     * @return the number of days in the duration, zero if unsupported\n+     */\n+    public final int getDays() {\n+        return iDays;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the duration.\n+     * \n+     * @return the number of hours in the duration, zero if unsupported\n+     */\n+    public final int getHours() {\n+        return iHours;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minutes field part of the duration.\n+     * \n+     * @return the number of minutes in the duration, zero if unsupported\n+     */\n+    public final int getMinutes() {\n+        return iMinutes;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the seconds field part of the duration.\n+     * \n+     * @return the number of seconds in the duration, zero if unsupported\n+     */\n+    public final int getSeconds() {\n+        return iSeconds;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis field part of the duration.\n+     * \n+     * @return the number of millis in the duration, zero if unsupported\n+     */\n+    public final int getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an immutable Duration. This can be useful if you\n+     * don't trust the implementation of the interface to be well-behaved, or\n+     * to get a guaranteed immutable object.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    public final Duration toDuration() {\n+        if (this instanceof Duration) {\n+            return (Duration) this;\n+        }\n+        return new Duration(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDuration.\n+     * \n+     * @return a MutableDuration using the same field set and values\n+     */\n+    public final MutableDuration toMutableDuration() {\n+        return new MutableDuration(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration, which can only be\n+     * performed if both are precise.\n+     *\n+     * @param obj  a precise duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public int compareTo(Object obj) {\n+        ReadableDuration thisDuration = (ReadableDuration) this;\n+        ReadableDuration otherDuration = (ReadableDuration) obj;\n+\n+        long thisMillis = thisDuration.getTotalMillis();\n+        long otherMillis = otherDuration.getTotalMillis();\n+        \n+        // cannot do (thisMillis - otherMillis) as it can overflow\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        }\n+        if (thisMillis > otherMillis) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isEqual(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) == 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isLongerThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) > 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     * Both durations must be precise.\n+     *\n+     * @param duration  another duration to compare to\n+     * @return true if this duration is equal to than the duration passed in\n+     * @throws IllegalArgumentException if the duration is null\n+     * @throws IllegalStateException if either duration is imprecise\n+     */\n+    public boolean isShorterThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        return compareTo(duration) < 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadableDuration instances are accepted.\n+     * <p>\n+     * To compare two durations for absolute duration (ie. millisecond duration\n+     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the duration is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableDuration) {\n+        if (this == readableDuration) {\n+            return true;\n+        }\n+        if (readableDuration instanceof ReadableDuration == false) {\n+            return false;\n+        }\n+        ReadableDuration other = (ReadableDuration) readableDuration;\n+        DurationType type = getDurationType();\n+        if (type.equals(other.getDurationType()) == false) {\n+            return false;\n+        }\n+        return getYears() == other.getYears()\n+            && getMonths() == other.getMonths()\n+            && getWeeks() == other.getWeeks()\n+            && getDays() == other.getDays()\n+            && getHours() == other.getHours()\n+            && getMinutes() == other.getMinutes()\n+            && getSeconds() == other.getSeconds()\n+            && getMillis() == other.getMillis();\n+    }\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        int hash = getDurationType().hashCode();\n+        hash = 53 * hash + getYears();\n+        hash = 53 * hash + getMonths();\n+        hash = 53 * hash + getWeeks();\n+        hash = 53 * hash + getDays();\n+        hash = 53 * hash + getHours();\n+        hash = 53 * hash + getMinutes();\n+        hash = 53 * hash + getSeconds();\n+        hash = 53 * hash + getMillis();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return ISODurationFormat.getInstance().standard().print(this);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadableDuration.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n+     * @param duration  the duration to set\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    protected void setDuration(ReadableDuration duration) {\n+        setDuration(iType, duration);\n+    }\n+\n+    /**\n+     * This method is private to prevent subclasses from overriding.\n+     */\n+    private void setDuration(DurationType type, ReadableDuration duration) {\n+        if (duration == null) {\n+            throw new IllegalArgumentException(\"The duration must not be null\");\n+        }\n+        setDuration(type,\n+                    duration.getYears(), duration.getMonths(),\n+                    duration.getWeeks(), duration.getDays(),\n+                    duration.getHours(), duration.getMinutes(),\n+                    duration.getSeconds(), duration.getMillis());\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * <p>\n+     * Subclasses that wish to be immutable should override this method with an\n+     * empty implementation that is protected and final. This also ensures that\n+     * all lower subclasses are also immutable.\n+     * \n      * @param years amount of years in this duration, which must be zero if\n      * unsupported.\n      * @param months amount of months in this duration, which must be zero if\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n-    public AbstractDuration(DurationType type,\n-                            int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis) {\n-        // Only call a private method\n-        setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n-     */\n-    public AbstractDuration(DurationType type, long startInstant, long endInstant) {\n-        // Only call a private method\n-        setTotalMillis(iType = type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start\n-     * @param endInstant interval end\n-     */\n-    public AbstractDuration(DurationType type,\n-                            ReadableInstant startInstant, ReadableInstant  endInstant) {\n-        // Only call a private method\n-        setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration. If any supported\n-     * fields are imprecise, an UnsupportedOperationException is thrown. The\n-     * exception to this is when the specified duration is zero.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param duration  the duration, in milliseconds\n-     * @throws UnsupportedOperationException if any fields are imprecise\n-     */\n-    public AbstractDuration(DurationType type, long duration) {\n-        // Only call a private method\n-        setTotalMillis(iType = type, duration);\n-    }\n-\n-    /**\n-     * Returns the object which defines which fields this duration supports.\n-     */\n-    public final DurationType getDurationType() {\n-        return iType;\n-    }\n-\n-    /**\n-     * Gets the total length of this duration in milliseconds, \n-     * failing if the duration is imprecise.\n-     *\n-     * @return the total length of the duration in milliseconds.\n-     * @throws IllegalStateException if the duration is imprecise\n-     */\n-    public final long getTotalMillis() {\n-        int state = iTotalMillisState;\n-        if (state == 0) {\n-            state = updateTotalMillis();\n-        }\n-        if (state != 2) {\n-            throw new IllegalStateException(\"Duration is imprecise\");\n-        }\n-        return iTotalMillis;\n-    }\n-\n-    /**\n-     * Is this duration a precise length of time, or descriptive.\n-     * <p>\n-     * A precise duration could include millis, seconds, minutes or hours.\n-     * However, days, weeks, months and years can vary in length, resulting in\n-     * an imprecise duration.\n-     * <p>\n-     * An imprecise duration can be made precise by pairing it with a\n-     * date in a {@link ReadableInterval}.\n-     *\n-     * @return true if the duration is precise\n-     */\n-    public final boolean isPrecise() {\n-        int state = iTotalMillisState;\n-        if (state == 0) {\n-            state = updateTotalMillis();\n-        }\n-        return state == 2;\n-    }\n-\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this duration is precise.\n-     *\n-     * @return new state\n-     */\n-    private int updateTotalMillis() {\n-        final DurationType type = iType;\n-\n-        boolean isPrecise = true;\n-        long totalMillis = 0;\n-\n-        DurationField field;\n-        int value;\n-\n-        if ((value = iYears) != 0) {\n-            field = type.years();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iMonths) != 0) {\n-            field = type.months();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iWeeks) != 0) {\n-            field = type.weeks();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iDays) != 0) {\n-            field = type.days();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iHours) != 0) {\n-            field = type.hours();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iMinutes) != 0) {\n-            field = type.minutes();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iSeconds) != 0) {\n-            field = type.seconds();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-        if ((value = iMillis) != 0) {\n-            field = type.millis();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis += field.getMillis(value);\n-            }\n-        }\n-\n-        if (isPrecise) {\n-            iTotalMillis = totalMillis;\n-            return iTotalMillisState = 2;\n-        } else {\n-            iTotalMillis = totalMillis;\n-            return iTotalMillisState = 1;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds this duration to the given instant, returning a new value.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scaler of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final long addTo(long instant, int scalar) {\n-        return addTo(instant, scalar, null);\n-    }\n-\n-    /**\n-     * Adds this duration to the given instant, returning a new value.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scaler of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @param chrono  override the duration's chronology, unless null is passed in\n-     * @return milliseconds value plus this duration times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final long addTo(long instant, int scalar, Chronology chrono) {\n-        if (isPrecise()) {\n-            return instant += getTotalMillis() * scalar;\n-        }\n-\n-        DurationType type = iType;\n-        if (chrono != null) {\n-            type = type.withChronology(chrono);\n-        }\n-\n-        int value;\n-\n-        if ((value = scaleValue(iYears, scalar)) != 0) {\n-            instant = type.years().add(instant, value);\n-        }\n-        if ((value = scaleValue(iMonths, scalar)) != 0) {\n-            instant = type.months().add(instant, value);\n-        }\n-        if ((value = scaleValue(iWeeks, scalar)) != 0) {\n-            instant = type.weeks().add(instant, value);\n-        }\n-        if ((value = scaleValue(iDays, scalar)) != 0) {\n-            instant = type.days().add(instant, value);\n-        }\n-        if ((value = scaleValue(iHours, scalar)) != 0) {\n-            instant = type.hours().add(instant, value);\n-        }\n-        if ((value = scaleValue(iMinutes, scalar)) != 0) {\n-            instant = type.minutes().add(instant, value);\n-        }\n-        if ((value = scaleValue(iSeconds, scalar)) != 0) {\n-            instant = type.seconds().add(instant, value);\n-        }\n-        if ((value = scaleValue(iMillis, scalar)) != 0) {\n-            instant = type.millis().add(instant, value);\n-        }\n-\n-        return instant;\n-    }\n-\n-    private static int scaleValue(int value, int scalar) {\n-        switch (scalar) {\n-        case -1:\n-            return -value;\n-        case 0:\n-            return 0;\n-        case 1:\n-            return value;\n-        default:\n-            return value * scalar;\n-        }\n-    }\n-\n-    /**\n-     * Adds this duration to the given instant, returning a new Instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scaler of minus one.\n-     *\n-     * @param instant  the instant to add the duration to\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @return instant with the original value plus this duration times scalar\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {\n-        return instant.toCopy(addTo(instant.getMillis(), scalar));\n-    }\n-\n-    /**\n-     * Adds this duration into the given mutable instant.\n-     * <p>\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scaler of minus one.\n-     *\n-     * @param instant  the instant to update with the added duration\n-     * @param scalar  the number of times to add the duration, negative to subtract\n-     * @throws IllegalArgumentException if the instant is null\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    public final void addInto(ReadWritableInstant instant, int scalar) {\n-        instant.setMillis(addTo(instant.getMillis(), scalar));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the years field part of the duration.\n-     * \n-     * @return the number of years in the duration, zero if unsupported\n-     */\n-    public final int getYears() {\n-        return iYears;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the months field part of the duration.\n-     * \n-     * @return the number of months in the duration, zero if unsupported\n-     */\n-    public final int getMonths() {\n-        return iMonths;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the weeks field part of the duration.\n-     * \n-     * @return the number of weeks in the duration, zero if unsupported\n-     */\n-    public final int getWeeks() {\n-        return iWeeks;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the days field part of the duration.\n-     * \n-     * @return the number of days in the duration, zero if unsupported\n-     */\n-    public final int getDays() {\n-        return iDays;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the hours field part of the duration.\n-     * \n-     * @return the number of hours in the duration, zero if unsupported\n-     */\n-    public final int getHours() {\n-        return iHours;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the minutes field part of the duration.\n-     * \n-     * @return the number of minutes in the duration, zero if unsupported\n-     */\n-    public final int getMinutes() {\n-        return iMinutes;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the seconds field part of the duration.\n-     * \n-     * @return the number of seconds in the duration, zero if unsupported\n-     */\n-    public final int getSeconds() {\n-        return iSeconds;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the millis field part of the duration.\n-     * \n-     * @return the number of millis in the duration, zero if unsupported\n-     */\n-    public final int getMillis() {\n-        return iMillis;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Get this object as an immutable Duration. This can be useful if you\n-     * don't trust the implementation of the interface to be well-behaved, or\n-     * to get a guaranteed immutable object.\n-     * \n-     * @return a Duration using the same field set and values\n-     */\n-    public final Duration toDuration() {\n-        if (this instanceof Duration) {\n-            return (Duration) this;\n-        }\n-        return new Duration(this);\n-    }\n-\n-    /**\n-     * Get this object as a MutableDuration.\n-     * \n-     * @return a MutableDuration using the same field set and values\n-     */\n-    public final MutableDuration toMutableDuration() {\n-        return new MutableDuration(this);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares this duration with the specified duration, which can only be\n-     * performed if both are precise.\n-     *\n-     * @param obj  a precise duration to check against\n-     * @return negative value if this is less, 0 if equal, or positive value if greater\n-     * @throws NullPointerException if the object is null\n-     * @throws ClassCastException if the given object is not supported\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public int compareTo(Object obj) {\n-        ReadableDuration thisDuration = (ReadableDuration) this;\n-        ReadableDuration otherDuration = (ReadableDuration) obj;\n-\n-        long thisMillis = thisDuration.getTotalMillis();\n-        long otherMillis = otherDuration.getTotalMillis();\n-        \n-        // cannot do (thisMillis - otherMillis) as it can overflow\n-        if (thisMillis < otherMillis) {\n-            return -1;\n-        }\n-        if (thisMillis > otherMillis) {\n-            return 1;\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Is the length of this duration equal to the duration passed in.\n-     * Both durations must be precise.\n-     *\n-     * @param duration  another duration to compare to\n-     * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isEqual(ReadableDuration duration) {\n-        if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        return compareTo(duration) == 0;\n-    }\n-\n-    /**\n-     * Is the length of this duration longer than the duration passed in.\n-     * Both durations must be precise.\n-     *\n-     * @param duration  another duration to compare to\n-     * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isLongerThan(ReadableDuration duration) {\n-        if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        return compareTo(duration) > 0;\n-    }\n-\n-    /**\n-     * Is the length of this duration shorter than the duration passed in.\n-     * Both durations must be precise.\n-     *\n-     * @param duration  another duration to compare to\n-     * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n-     * @throws IllegalStateException if either duration is imprecise\n-     */\n-    public boolean isShorterThan(ReadableDuration duration) {\n-        if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        return compareTo(duration) < 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares this object with the specified object for equality based\n-     * on the value of each field. All ReadableDuration instances are accepted.\n-     * <p>\n-     * To compare two durations for absolute duration (ie. millisecond duration\n-     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or\n-     * {@link #compareTo(Object)}.\n-     *\n-     * @param readableDuration  a readable duration to check against\n-     * @return true if all the field values are equal, false if\n-     *  not or the duration is null or of an incorrect type\n-     */\n-    public boolean equals(Object readableDuration) {\n-        if (this == readableDuration) {\n-            return true;\n-        }\n-        if (readableDuration instanceof ReadableDuration == false) {\n-            return false;\n-        }\n-        ReadableDuration other = (ReadableDuration) readableDuration;\n-        DurationType type = getDurationType();\n-        if (type.equals(other.getDurationType()) == false) {\n-            return false;\n-        }\n-        return getYears() == other.getYears()\n-            && getMonths() == other.getMonths()\n-            && getWeeks() == other.getWeeks()\n-            && getDays() == other.getDays()\n-            && getHours() == other.getHours()\n-            && getMinutes() == other.getMinutes()\n-            && getSeconds() == other.getSeconds()\n-            && getMillis() == other.getMillis();\n-    }\n-\n-    /**\n-     * Gets a hash code for the duration that is compatable with the \n-     * equals method.\n-     *\n-     * @return a hash code\n-     */\n-    public int hashCode() {\n-        int hash = getDurationType().hashCode();\n-        hash = 53 * hash + getYears();\n-        hash = 53 * hash + getMonths();\n-        hash = 53 * hash + getWeeks();\n-        hash = 53 * hash + getDays();\n-        hash = 53 * hash + getHours();\n-        hash = 53 * hash + getMinutes();\n-        hash = 53 * hash + getSeconds();\n-        hash = 53 * hash + getMillis();\n-        return hash;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the value as a String in the ISO8601 duration format.\n-     * <p>\n-     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n-     *\n-     * @return the value as an ISO8601 string\n-     */\n-    public String toString() {\n-        return ISODurationFormat.getInstance().standard().print(this);\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from another ReadableDuration.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param duration  the duration to set\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    protected void setDuration(ReadableDuration duration) {\n-        setDuration(iType, duration);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setDuration(DurationType type, ReadableDuration duration) {\n-        if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        setDuration(type,\n-                    duration.getYears(), duration.getMonths(),\n-                    duration.getWeeks(), duration.getDays(),\n-                    duration.getHours(), duration.getMinutes(),\n-                    duration.getSeconds(), duration.getMillis());\n-    }\n-\n-    /**\n-     * Sets all the fields in one go.\n-     * <p>\n-     * Subclasses that wish to be immutable should override this method with an\n-     * empty implementation that is protected and final. This also ensures that\n-     * all lower subclasses are also immutable.\n-     * \n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n     protected void setDuration(int years, int months, int weeks, int days,\n                                int hours, int minutes, int seconds, int millis) {\n         setDuration(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n     private void setDuration(DurationType type,\n                              int years, int months, int weeks, int days,\n                              int hours, int minutes, int seconds, int millis) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n \n         if (years != 0) {\n             checkSupport(type.years(), \"years\");\n      * @param endInstant interval end, in milliseconds\n      */\n     private void setTotalMillis(DurationType type, long startInstant, long endInstant) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n+\n         iTotalMillis = endInstant - startInstant;\n \n         boolean isPrecise = true;\n      * @throws UnsupportedOperationException if any fields are imprecise\n      */\n     private void setTotalMillis(DurationType type, final long duration) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n+\n         if (duration == 0) {\n             iTotalMillis = duration;\n             iTotalMillisState = 2;\n     }\n \n }\n-\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n     /**\n      * Copies another duration to this one.\n      *\n+     * @param duration duration to copy\n+     * @throws IllegalArgumentException if duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     }\n \n     /**\n+     * Copies another duration to this one.\n+     *\n+     * @param duration duration to convert\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public Duration(Object duration) {\n+        super(duration);\n+    }\n+\n+    /**\n      * Creates a zero length duration.\n      *\n      * @param type determines which set of fields this duration supports\n+     * @throws IllegalArgumentException if type is null\n      */\n     public Duration(DurationType type) {\n         super(type);\n      *\n      * @param type use a different DurationType\n      * @param duration duration to copy\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n      *\n      * @param type use a different DurationType\n      * @param duration duration to convert\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n      * unsupported.\n      * @param millis amount of milliseconds in this duration, which must be\n      * zero if unsupported.\n+     * @throws IllegalArgumentException if type is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n      * @param type determines which set of fields this duration supports\n      * @param startInstant interval start, in milliseconds\n      * @param endInstant interval end, in milliseconds\n+     * @throws IllegalArgumentException if type is null\n      */\n     public Duration(DurationType type, long startInstant, long endInstant) {\n         super(type, startInstant, endInstant);\n      * @param type determines which set of fields this duration supports\n      * @param startInstant interval start\n      * @param endInstant interval end\n+     * @throws IllegalArgumentException if type is null\n      */\n     public Duration(DurationType type,\n                     ReadableInstant startInstant, ReadableInstant endInstant) {\n      *\n      * @param type determines which set of fields this duration supports\n      * @param duration  the duration, in milliseconds\n+     * @throws IllegalArgumentException if type is null\n      * @throws UnsupportedOperationException if any fields are imprecise\n      */\n     public Duration(DurationType type, long duration) {\n--- a/JodaTime/src/java/org/joda/time/MutableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java\n     /**\n      * Copies another duration to this one.\n      *\n+     * @param duration duration to copy\n+     * @throws IllegalArgumentException if duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     }\n \n     /**\n+     * Copies another duration to this one.\n+     *\n+     * @param duration duration to convert\n+     * @throws IllegalArgumentException if duration is null\n+     * @throws UnsupportedOperationException if an unsupported field's value is\n+     * non-zero\n+     */\n+    public MutableDuration(Object duration) {\n+        super(duration);\n+    }\n+\n+    /**\n      * Creates a zero length duration.\n      *\n      * @param type determines which set of fields this duration supports\n+     * @throws IllegalArgumentException if type is null\n      */\n     public MutableDuration(DurationType type) {\n         super(type);\n      *\n      * @param type use a different DurationType\n      * @param duration duration to copy\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n      *\n      * @param type use a different DurationType\n      * @param duration duration to convert\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n     public MutableDuration(DurationType type, Object duration) {\n-        super(type);\n-        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-        converter.setInto(this, duration);\n+        super(type, duration);\n     }\n \n     /**\n      * unsupported.\n      * @param millis amount of milliseconds in this duration, which must be\n      * zero if unsupported.\n+     * @throws IllegalArgumentException if type is null\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n      * @param type determines which set of fields this duration supports\n      * @param startInstant interval start, in milliseconds\n      * @param endInstant interval end, in milliseconds\n+     * @throws IllegalArgumentException if type is null\n      */\n     public MutableDuration(DurationType type, long startInstant, long endInstant) {\n         super(type, startInstant, endInstant);\n      * @param type determines which set of fields this duration supports\n      * @param startInstant interval start\n      * @param endInstant interval end\n+     * @throws IllegalArgumentException if type is null\n      */\n     public MutableDuration(DurationType type,\n                            ReadableInstant startInstant, ReadableInstant endInstant) {\n      *\n      * @param type determines which set of fields this duration supports\n      * @param duration  the duration, in milliseconds\n+     * @throws IllegalArgumentException if type or duration is null\n      * @throws UnsupportedOperationException if any fields are imprecise\n      */\n     public MutableDuration(DurationType type, long duration) {", "timestamp": 1072051209, "metainfo": ""}