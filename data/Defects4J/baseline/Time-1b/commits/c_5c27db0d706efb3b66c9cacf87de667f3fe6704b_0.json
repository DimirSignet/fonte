{"sha": "5c27db0d706efb3b66c9cacf87de667f3fe6704b", "log": "Revert change to handle time zones as it still has issues   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n  */\n package org.joda.time.base;\n \n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.util.Calendar;\n-import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n         extends AbstractInstant\n         implements ReadableDateTime {\n \n-    /** The method to call as TimeZone.getOffset is only from JDK 1.4. */\n-    private static final Method OFFSET_METHOD;\n-    static {\n-        Method m = null;\n-        try {\n-            m = TimeZone.class.getDeclaredMethod(\"getOffset\", new Class[] {Long.TYPE});\n-        } catch (SecurityException ex) {\n-            // ignore\n-        } catch (NoSuchMethodException ex) {\n-            try {\n-                m = TimeZone.class.getDeclaredMethod(\"getOffsets\", new Class[] {Long.TYPE, int[].class});\n-                m.setAccessible(true);\n-            } catch (SecurityException e) {\n-                // ignore\n-            } catch (NoSuchMethodException e) {\n-                // ignore\n-            }\n-        }\n-        OFFSET_METHOD = m;\n-    }\n-\n-    //-----------------------------------------------------------------------\n     /**\n      * Constructor.\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Get the date time as a <code>java.util.Date</code>.\n-     * <p>\n-     * Note that as from version 1.2, this method goes to extra effort to\n-     * maintain the field values on the created Date object.\n-     * This means that the differences in timezone data between Joda-Time\n-     * and each JDK version are now handled correctly.\n-     *\n-     * @return a Date initialised with this datetime\n-     */\n-    public Date toDate() {\n-        long millis = getMillis();\n-        millis = fixMillisForTimeZone(millis, TimeZone.getDefault());\n-        return new Date(millis);\n-    }\n-\n-    /**\n-     * Get the date time as a <code>java.util.Calendar</code>.\n+     * Get the date time as a <code>java.util.Calendar</code>, assigning\n+     * exactly the same millisecond instant.\n      * The locale is passed in, enabling Calendar to select the correct\n      * localized subclass.\n      * <p>\n-     * Note that as from version 1.2, this method goes to extra effort to\n-     * maintain the field values on the created Calendar object.\n-     * This means that the differences in timezone data between Joda-Time\n-     * and each JDK version are now handled correctly.\n-     * \n+     * The JDK and Joda-Time both have time zone implementations and these\n+     * differ in accuracy. Joda-Time's implementation is generally more up to\n+     * date and thus more accurate - for example JDK1.3 has no historical data.\n+     * The effect of this is that the field values of the <code>Calendar</code>\n+     * may differ from those of this object, even though the milliseond value\n+     * is the same. Most of the time this just means that the JDK field values\n+     * are wrong, as our time zone information is more up to date.\n+     *\n      * @param locale  the locale to get the Calendar for, or default if null\n      * @return a localized Calendar initialised with this datetime\n      */\n         }\n         DateTimeZone zone = getZone();\n         Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n-        cal.setTime(convertToDate(cal));\n+        cal.setTime(toDate());\n         return cal;\n     }\n \n     /**\n-     * Get the date time as a <code>java.util.GregorianCalendar</code>.\n-     * <p>\n-     * Note that as from version 1.2, this method goes to extra effort to\n-     * maintain the field values on the created Calendar object.\n-     * This means that the differences in timezone data between Joda-Time\n-     * and each JDK version are now handled correctly.\n+     * Get the date time as a <code>java.util.GregorianCalendar</code>,\n+     * assigning exactly the same millisecond instant.\n+     * <p>\n+     * The JDK and Joda-Time both have time zone implementations and these\n+     * differ in accuracy. Joda-Time's implementation is generally more up to\n+     * date and thus more accurate - for example JDK1.3 has no historical data.\n+     * The effect of this is that the field values of the <code>Calendar</code>\n+     * may differ from those of this object, even though the milliseond value\n+     * is the same. Most of the time this just means that the JDK field values\n+     * are wrong, as our time zone information is more up to date.\n      *\n      * @return a GregorianCalendar initialised with this datetime\n      */\n     public GregorianCalendar toGregorianCalendar() {\n         DateTimeZone zone = getZone();\n         GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());\n-        cal.setTime(convertToDate(cal));\n+        cal.setTime(toDate());\n         return cal;\n-    }\n-\n-    private Date convertToDate(Calendar cal) {\n-        long millis = getMillis();\n-        millis = fixMillisForTimeZone(millis, cal.getTimeZone());\n-        return new Date(millis);\n-    }\n-\n-    private long fixMillisForTimeZone(long millis, TimeZone zone) {\n-        if (OFFSET_METHOD == null) {\n-            return millis;\n-        }\n-        Integer val;\n-        try {\n-            if (\"getOffset\".equals(OFFSET_METHOD.getName())) {\n-                val = (Integer) OFFSET_METHOD.invoke(\n-                        zone, new Object[] {new Long(millis)});\n-            } else {\n-                val = (Integer) OFFSET_METHOD.invoke(\n-                        zone, new Object[] {new Long(millis), null});\n-            }\n-        } catch (IllegalAccessException ex) {\n-            return millis;\n-        } catch (InvocationTargetException ex) {\n-            return millis;\n-        }\n-        \n-        long millisLocal = millis - val.intValue();\n-        return millisLocal + getZone().getOffsetFromLocal(millisLocal);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInstant.java\n     //-----------------------------------------------------------------------\n     /**\n      * Get the date time as a <code>java.util.Date</code>.\n-     * \n+     * <p>\n+     * The <code>Date</code> object created has exactly the same millisecond\n+     * instant as this object.\n+     *\n      * @return a Date initialised with this datetime\n      */\n     public Date toDate() {\n--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java\n      */\n     public long getInstantMillis(Object object, Chronology chrono) {\n         Calendar calendar = (Calendar) object;\n-        long millisLocal = calendar.getTime().getTime() +\n-            calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n-        DateTimeZone tz = DateTimeZone.forTimeZone(calendar.getTimeZone());\n-        return millisLocal - tz.getOffsetFromLocal(millisLocal);\n+        return calendar.getTime().getTime();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java\n import java.util.Date;\n \n import org.joda.time.Chronology;\n-import org.joda.time.DateTimeZone;\n \n /**\n  * DateConverter converts a java util Date to an instant or partial.\n      */\n     public long getInstantMillis(Object object, Chronology chrono) {\n         Date date = (Date) object;\n-        long millisLocal = date.getTime() - date.getTimezoneOffset() * 60000;\n-        return millisLocal - DateTimeZone.getDefault().getOffsetFromLocal(millisLocal);\n+        return date.getTime();\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1133725660, "metainfo": ""}