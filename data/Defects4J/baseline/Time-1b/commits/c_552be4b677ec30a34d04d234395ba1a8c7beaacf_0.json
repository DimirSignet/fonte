{"sha": "552be4b677ec30a34d04d234395ba1a8c7beaacf", "log": "DateTimeZone.getOffsetFromLocal [2952991] The behaviour during DST overlaps is now defined to always return the earlier instant which is normally known as daylight or summer time. Previously, the result varied by hemisphere. This affects the constructor of DateTime and other methods  ", "commit": "\n--- a/JodaTime/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeZone.java\n      * Input: 02:00  Output: 02:00<br />\n      * Input: 02:30  Output: 02:30<br />\n      * <p>\n-     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n-     * on returning a consistent result later along the time-line (shown above).\n+     * During a DST overlap (where the local time is ambiguous) this method will return\n+     * the earlier instant. The combination of these two rules is to always favour\n+     * daylight (summer) time over standard (winter) time.\n+     * <p>\n+     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n+     * Prior to v1.5, the DST gap behaviour was also not defined.\n      *\n-     * @param instantLocal  the millisecond instant, relative to this time zone, to\n-     * get the offset for\n+     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n      * @return the millisecond offset to subtract from local time to get UTC time\n      */\n     public int getOffsetFromLocal(long instantLocal) {\n         // get the offset at instantLocal (first estimate)\n-        int offsetLocal = getOffset(instantLocal);\n+        final int offsetLocal = getOffset(instantLocal);\n         // adjust instantLocal using the estimate and recalc the offset\n-        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n+        final long instantAdjusted = instantLocal - offsetLocal;\n+        final int offsetAdjusted = getOffset(instantAdjusted);\n         // if the offsets differ, we must be near a DST boundary\n         if (offsetLocal != offsetAdjusted) {\n             // we need to ensure that time is always after the DST gap\n                 // if we just return offsetAdjusted then the time is pushed\n                 // back before the transition, whereas it should be\n                 // on or after the transition\n-                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                long nextLocal = nextTransition(instantAdjusted);\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n+                }\n+            }\n+        } else if (offsetLocal > 0) {\n+            long prev = previousTransition(instantAdjusted);\n+            if (prev < instantAdjusted) {\n+                int offsetPrev = getOffset(prev);\n+                int diff = offsetPrev - offsetLocal;\n+                if (instantAdjusted - prev <= diff) {\n+                    return offsetPrev;\n                 }\n             }\n         }\n--- a/JodaTime/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n+++ b/JodaTime/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n         doTest_getOffsetFromLocal(11, 4, 8, 0, \"2007-11-04T08:00:00.000-05:00\", ZONE_NEW_YORK);\n     }\n \n+    public void test_DateTime_constructor_NewYork_Autumn() {\n+        DateTime dt = new DateTime(2007, 11, 4, 1, 30, ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:30:00.000-04:00\", dt.toString());\n+    }\n+\n     public void test_DateTime_plusHour_NewYork_Autumn() {\n         DateTime dt = new DateTime(2007, 11, 3, 18, 0, 0, 0, ZONE_NEW_YORK);\n         assertEquals(\"2007-11-03T18:00:00.000-04:00\", dt.toString());\n         assertEquals(\"2007-10-28T02:00:00.001+03:00\", post.toString());\n     }\n \n-    // broken, and getOffsetFromLocal has no obvious way to determine which is correct\n-//    public void test_getOffsetFromLocal_Moscow_Autumn() {\n-//        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n-//        \n-//        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n-//        \n-//        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n-//        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n-//    }\n+    public void test_getOffsetFromLocal_Moscow_Autumn() {\n+        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n+        \n+        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n+        \n+        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n+        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n+    }\n+\n+    public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n+        for (int min = 0; min < 60; min++) {\n+            if (min < 10) {\n+                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n+            } else {\n+                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n+            }\n+        }\n+    }\n+\n+    public void test_DateTime_constructor_Moscow_Autumn() {\n+        DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n+        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n+    }\n \n     public void test_DateTime_plusHour_Moscow_Autumn() {\n         DateTime dt = new DateTime(2007, 10, 27, 19, 0, 0, 0, ZONE_MOSCOW);\n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n-    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min,\n-                                           String expected, DateTimeZone zone)\n-    {\n-        doTest_getOffsetFromLocal(2007, month, day, hour, min, expected, zone);\n-    }\n-\n-    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min,\n-                                           String expected, DateTimeZone zone)\n-    {\n-        DateTime dt = new DateTime(year, month, day, hour, min, 0, 0, DateTimeZone.UTC);\n+    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {\n+        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);\n+    }\n+\n+    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {\n+        doTest_getOffsetFromLocal(2007, month, day, hour, min, sec, milli, expected, zone);\n+    }\n+\n+    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, String expected, DateTimeZone zone) {\n+        doTest_getOffsetFromLocal(year, month, day, hour, min, 0, 0, expected, zone);\n+    }\n+\n+    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {\n+        DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC);\n         int offset = zone.getOffsetFromLocal(dt.getMillis());\n         DateTime res = new DateTime(dt.getMillis() - offset, zone);\n         assertEquals(res.toString(), expected, res.toString());", "timestamp": 1291592598, "metainfo": ""}