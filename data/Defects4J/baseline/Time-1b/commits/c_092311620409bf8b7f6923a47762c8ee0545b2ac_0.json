{"sha": "092311620409bf8b7f6923a47762c8ee0545b2ac", "log": "Reduce synchronization in LocalDateTime.toDate()  java.util.Date uses TimeZone.getDefaultRef() internally, mostly when using deprecated constructors or deprecated field accessors. TimeZone.getDefaultRef() is synchronized, concurrent calls to LocalDateTime.toDate() can thus come with a costly synchronization/blocking overhead.  This patch reduces the need to get the default time zone by adding a new LocalDateTime.toDate(TimeZone zone) method, as well as by using a java.util.Calendar in toDate()'s DST correction code.  These changes make it possible to convert LocalDateTime to java.util.Date without any synchronization overhead.", "commit": "\n--- a/src/main/java/org/joda/time/LocalDateTime.java\n+++ b/src/main/java/org/joda/time/LocalDateTime.java\n         Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                         getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n         date.setTime(date.getTime() + getMillisOfSecond());\n-        LocalDateTime check = LocalDateTime.fromDateFields(date);\n-        if (check.isBefore(this)) {\n-            // DST gap\n-            // move forward in units of one minute until equal/after\n-            while (check.isBefore(this)) {\n-                date.setTime(date.getTime() + 60000);\n-                check = LocalDateTime.fromDateFields(date);\n-            }\n-            // move back in units of one second until date wrong\n-            while (check.isBefore(this) == false) {\n-                date.setTime(date.getTime() - 1000);\n-                check = LocalDateTime.fromDateFields(date);\n-            }\n-            date.setTime(date.getTime() + 1000);\n-        } else if (check.equals(this)) {\n-            // check for DST overlap\n-            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n-            check = LocalDateTime.fromDateFields(earlier);\n-            if (check.equals(this)) {\n-                date = earlier;\n-            }\n-        }\n-        return date;\n+\n+        return correctDstTransition(date, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Date</code> using the specified time zone.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same fields as this\n+     * date-time, except when the time would be invalid due to a daylight savings\n+     * gap. In that case, the time will be set to the earliest valid time after the gap.\n+     * <p>\n+     * In the case of a daylight savings overlap, the earlier instant is selected.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting. This also handles the situation\n+     * where the JDK time zone data differs from the Joda-Time time zone data.\n+     * <p>\n+     * Unlike {@link #toDate()}, this implementation does not rely on Java's synchronized\n+     * time zone initialization logic, and should demonstrate better concurrent performance\n+     * characteristics.\n+     *\n+     * @return a Date initialised with this date-time, never null\n+     * @since 2.0\n+     */\n+    public Date toDate(final TimeZone timeZone) {\n+\tfinal Calendar calendar = Calendar.getInstance(timeZone);\n+\tcalendar.clear();\n+\tcalendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(),\n+\t\tgetHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n+\tDate date = calendar.getTime();\n+\tdate.setTime(date.getTime() + getMillisOfSecond());\n+\n+\treturn correctDstTransition(date, timeZone);\n+    }\n+\n+\n+    /**\n+     * Correct <code>date</code> in case of DST overlap.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same fields as this\n+     * date-time, except when the time would be invalid due to a daylight savings\n+     * gap. In that case, the time will be set to the earliest valid time after the gap.\n+     * <p>\n+     * In the case of a daylight savings overlap, the earlier instant is selected.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting. This also handles the situation\n+     * where the JDK time zone data differs from the Joda-Time time zone data.\n+     * @see #toDate()\n+     */\n+    private Date correctDstTransition(Date date, final TimeZone timeZone) {\n+\tCalendar calendar = Calendar.getInstance(timeZone);\n+\tcalendar.setTime(date);\n+\tLocalDateTime check = LocalDateTime.fromCalendarFields(calendar);\n+\tif (check.isBefore(this)) {\n+\t    // DST gap\n+\t    // move forward in units of one minute until equal/after\n+\t    while (check.isBefore(this)) {\n+\t\tcalendar.setTimeInMillis(calendar.getTimeInMillis() + 60000);\n+\t\tcheck = LocalDateTime.fromCalendarFields(calendar);\n+\t    }\n+\t    // move back in units of one second until date wrong\n+\t    while (check.isBefore(this) == false) {\n+\t\tcalendar.setTimeInMillis(calendar.getTimeInMillis() - 1000);\n+\t\tcheck = LocalDateTime.fromCalendarFields(calendar);\n+\t    }\n+\t    calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000);\n+\t} else if (check.equals(this)) {\n+\t    // check for DST overlap\n+\t    final Calendar earlier = Calendar.getInstance(timeZone);\n+\t    earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings());\n+\t    check = LocalDateTime.fromCalendarFields(earlier);\n+\t    if (check.equals(this)) {\n+\t\tcalendar = earlier;\n+\t    }\n+\t}\n+\treturn calendar.getTime();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/joda/time/TestLocalDateTime_Basics.java\n+++ b/src/test/java/org/joda/time/TestLocalDateTime_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testToDate_summer_Zone() {\n+        LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS);\n+        \n+        Date test = base.toDate(TimeZone.getDefault());\n+        check(base, 2005, 7, 9, 10, 20, 30, 40);\n+        \n+        GregorianCalendar gcal = new GregorianCalendar();\n+        gcal.clear();\n+        gcal.set(Calendar.YEAR, 2005);\n+        gcal.set(Calendar.MONTH, Calendar.JULY);\n+        gcal.set(Calendar.DAY_OF_MONTH, 9);\n+        gcal.set(Calendar.HOUR_OF_DAY, 10);\n+        gcal.set(Calendar.MINUTE, 20);\n+        gcal.set(Calendar.SECOND, 30);\n+        gcal.set(Calendar.MILLISECOND, 40);\n+        assertEquals(gcal.getTime(), test);\n+    }\n+\n+    public void testToDate_winter_Zone() {\n+        LocalDateTime base = new LocalDateTime(2005, 1, 9, 10, 20, 30, 40, COPTIC_PARIS);\n+        \n+        Date test = base.toDate(TimeZone.getDefault());\n+        check(base, 2005, 1, 9, 10, 20, 30, 40);\n+        \n+        GregorianCalendar gcal = new GregorianCalendar();\n+        gcal.clear();\n+        gcal.set(Calendar.YEAR, 2005);\n+        gcal.set(Calendar.MONTH, Calendar.JANUARY);\n+        gcal.set(Calendar.DAY_OF_MONTH, 9);\n+        gcal.set(Calendar.HOUR_OF_DAY, 10);\n+        gcal.set(Calendar.MINUTE, 20);\n+        gcal.set(Calendar.SECOND, 30);\n+        gcal.set(Calendar.MILLISECOND, 40);\n+        assertEquals(gcal.getTime(), test);\n+    }\n+\n+    public void testToDate_springDST_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 4, 2, 0, 20, 0, 0);\n+            assertEquals(\"Mon Apr 02 01:00:00 GMT+02:00 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+\n+    public void testToDate_springDST_2Hour40Savings_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000, (3600000 / 6) * 16);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 4, 2, 0, 20, 0, 0);\n+            assertEquals(\"Mon Apr 02 02:40:00 GMT+03:40 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+\n+    public void testToDate_autumnDST_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 10, 2, 0, 20, 30, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 10, 2, 0, 20, 30, 0);\n+            assertEquals(\"Tue Oct 02 00:20:30 GMT+02:00 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+    \n+    \n+    //-----------------------------------------------------------------------\n     public void testProperty() {\n         LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, GJ_UTC);\n         assertEquals(test.year(), test.property(DateTimeFieldType.year()));", "timestamp": 1374846098, "metainfo": ""}