{"sha": "fa7e966cd0162ac3c21d46c56448a47de251c6b9", "log": "Support converting intervals.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  * <p>\n  * This class enables additional conversion classes to be added via\n  * {@link #addInstantConverter(InstantConverter)}, which may replace an\n- * existing converter. Similar methods exist for duration converters.\n+ * existing converter. Similar methods exist for duration and interval\n+ * converters.\n  * <p>\n  * This class is threadsafe, so adding/removing converters can be done at any\n  * time. Updating the set of convertors is relatively expensive, and so should\n  * <li>Long\n  * </ul>\n  *\n+ * The default interval converters are:\n+ * <ul>\n+ * <li>ReadableInterval\n+ * <li>String\n+ * </ul>\n+ *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  * @since 1.0\n     \n     private ConverterSet iInstantConverters;\n     private ConverterSet iDurationConverters;\n+    private ConverterSet iIntervalConverters;\n     \n     /**\n      * Restricted constructor.\n             StringConverter.INSTANCE,\n             LongConverter.INSTANCE,\n         });\n+\n+        iIntervalConverters = new ConverterSet(new Converter[] {\n+            ReadableIntervalConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+        });\n     }\n     \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public IntervalConverter getIntervalConverter(Object object) {\n+        IntervalConverter converter =\n+            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No interval converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public IntervalConverter[] getIntervalConverters() {\n+        ConverterSet set = iIntervalConverters;\n+        IntervalConverter[] converters = new IntervalConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public IntervalConverter addIntervalConverter(IntervalConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        IntervalConverter[] removed = new IntervalConverter[1];\n+        iIntervalConverters = iIntervalConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public IntervalConverter removeIntervalConverter(IntervalConverter converter) {\n+        if (converter == null) {\n+            return null;\n+        }\n+        IntervalConverter[] removed = new IntervalConverter[1];\n+        iIntervalConverters = iIntervalConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters, by index.\n+     * \n+     * @param index  the index to remove\n+     * @return replaced converter, or null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public IntervalConverter removeIntervalConverter(int index) {\n+        IntervalConverter[] removed = new IntervalConverter[1];\n+        iIntervalConverters = iIntervalConverters.remove(index, removed);\n+        return removed[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets a debug representation of the object\n      */\n     public String toString() {\n         return \"ConverterManager[\" +\n             iInstantConverters.size() + \" instant converters,\" +\n-            iDurationConverters.size() + \" duration converters]\";\n+            iDurationConverters.size() + \" duration converters,\" +\n+            iIntervalConverters.size() + \" interval converters]\";\n     }\n \n }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.ReadWritableInterval;\n+\n+/**\n+ * IntervalConverter defines how an object is converted to an interval.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface IntervalConverter extends Converter {\n+\n+    /**\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param interval interval to get modified\n+     * @param object  the object to convert, must not be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    void setInto(ReadWritableInterval interval, Object object);\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.DurationType;\n import org.joda.time.ReadableInterval;\n import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableInterval;\n \n /**\n  * Converts intervals into durations of any requested duration type.\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-class ReadableIntervalConverter implements DurationConverter {\n+class ReadableIntervalConverter implements IntervalConverter, DurationConverter {\n \n     /**\n      * Singleton instance.\n     }\n \n     /**\n+     * Selects a suitable duration type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @return the duration type, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public DurationType getDurationType(Object object) {\n+        return ((ReadableInterval) object).getDuration().getDurationType();\n+    }\n+\n+    public void setInto(ReadWritableInterval writableInterval, Object object) {\n+        ReadableInterval interval = (ReadableInterval) object;\n+        writableInterval.setStartMillis(interval.getStartMillis());\n+        writableInterval.setEndMillis(interval.getEndMillis());\n+    }\n+\n+    /**\n      * Returns ReadableInterval.class.\n      */\n     public Class getSupportedType() {\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationType;\n+import org.joda.time.MutableDuration;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n import org.joda.time.ReadWritableDuration;\n+import org.joda.time.ReadWritableInterval;\n import org.joda.time.chrono.iso.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.DurationParser;\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-class StringConverter extends AbstractConverter implements InstantConverter, DurationConverter {\n+class StringConverter extends AbstractConverter\n+    implements InstantConverter, DurationConverter, IntervalConverter {\n     \n     /**\n      * Singleton instance.\n         }\n     }\n \n+    /**\n+     * Selects a suitable duration type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @return the duration type, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public DurationType getDurationType(Object object) {\n+        String str = (String) object;\n+        if (str.indexOf('W') >= 0) {\n+            return DurationType.getYearWeekType();\n+        }\n+        return DurationType.getYearMonthType();\n+    }\n+\n+    public void setInto(ReadWritableInterval writableInterval, Object object) {\n+        String str = (String) object;\n+\n+        int separator = str.indexOf('/');\n+        if (separator < 0) {\n+            throw new IllegalArgumentException(\"Format requires a '/' separator: \" + str);\n+        }\n+\n+        String leftStr = str.substring(0, separator);\n+        if (leftStr.length() <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        String rightStr = str.substring(separator + 1);\n+        if (rightStr.length() <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        long startInstant;\n+        ReadableDuration duration;\n+\n+        char c = leftStr.charAt(0);\n+        if (c == 'P' || c == 'p') {\n+            startInstant = 0;\n+            duration = ISODurationFormat.getInstance().standard()\n+                .parseDuration(getDurationType(leftStr), leftStr);\n+        } else {\n+            startInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(leftStr);\n+            duration = null;\n+        }\n+\n+        c = rightStr.charAt(0);\n+        if (c == 'P' || c == 'p') {\n+            if (duration != null) {\n+                throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n+            }\n+            duration = ISODurationFormat.getInstance().standard()\n+                .parseDuration(getDurationType(rightStr), rightStr);\n+            writableInterval.setStartMillis(startInstant);\n+            writableInterval.setDurationAfterStart(duration);\n+        } else {\n+            long endInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(rightStr);\n+            writableInterval.setEndMillis(endInstant);\n+            if (duration == null) {\n+                writableInterval.setStartMillis(startInstant);\n+            } else {\n+                writableInterval.setDurationBeforeEnd(duration);\n+            }\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns String.class.\n     public Class getSupportedType() {\n         return String.class;\n     }\n-    \n+\n }", "timestamp": 1072050953, "metainfo": ""}