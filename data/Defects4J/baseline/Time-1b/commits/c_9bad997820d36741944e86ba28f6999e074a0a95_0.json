{"sha": "9bad997820d36741944e86ba28f6999e074a0a95", "log": "Allow 'Z' and 'ZZ' in format patterns to parse 'Z' as '+00:00' [2827359]  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n                 break;\n             case 'Z': // time zone offset\n                 if (tokenLen == 1) {\n-                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                 } else if (tokenLen == 2) {\n-                    builder.appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n      * Instructs the printer to emit text and numbers to display time zone\n      * offset from UTC. A parser will use the parsed time zone offset to adjust\n      * the datetime.\n+     * <p>\n+     * If zero offset text is supplied, then it will be printed when the zone is zero.\n+     * During parsing, either the zero offset text, or the offset will be parsed.\n      *\n      * @param zeroOffsetText Text to use if time zone offset is zero. If\n      * null, offset is always shown.\n             String zeroOffsetText, boolean showSeparators,\n             int minFields, int maxFields) {\n         return append0(new TimeZoneOffset\n-                       (zeroOffsetText, showSeparators, minFields, maxFields));\n+                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit text and numbers to display time zone\n+     * offset from UTC. A parser will use the parsed time zone offset to adjust\n+     * the datetime.\n+     * <p>\n+     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n+     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n+     *\n+     * @param zeroOffsetPrintText Text to print if time zone offset is zero. If\n+     * null, offset is always shown.\n+     * @param zeroOffsetParseText Text to optionally parse to indicate that the time\n+     * zone offset is zero. If null, then always use the offset.\n+     * @param showSeparators If true, prints ':' separator before minute and\n+     * second field and prints '.' separator before fraction field.\n+     * @param minFields minimum number of fields to print, stopping when no\n+     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n+     * @param maxFields maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneOffset(\n+            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n+            int minFields, int maxFields) {\n+        return append0(new TimeZoneOffset\n+                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n     }\n \n     //-----------------------------------------------------------------------\n     static class TimeZoneOffset\n             implements DateTimePrinter, DateTimeParser {\n \n-        private final String iZeroOffsetText;\n+        private final String iZeroOffsetPrintText;\n+        private final String iZeroOffsetParseText;\n         private final boolean iShowSeparators;\n         private final int iMinFields;\n         private final int iMaxFields;\n \n-        TimeZoneOffset(String zeroOffsetText,\n+        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                 boolean showSeparators,\n                                 int minFields, int maxFields)\n         {\n             super();\n-            iZeroOffsetText = zeroOffsetText;\n+            iZeroOffsetPrintText = zeroOffsetPrintText;\n+            iZeroOffsetParseText = zeroOffsetParseText;\n             iShowSeparators = showSeparators;\n             if (minFields <= 0 || maxFields < minFields) {\n                 throw new IllegalArgumentException();\n             if (iShowSeparators) {\n                 est += iMinFields - 1;\n             }\n-            if (iZeroOffsetText != null && iZeroOffsetText.length() > est) {\n-                est = iZeroOffsetText.length();\n+            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n+                est = iZeroOffsetPrintText.length();\n             }\n             return est;\n         }\n             if (displayZone == null) {\n                 return;  // no zone\n             }\n-            if (displayOffset == 0 && iZeroOffsetText != null) {\n-                buf.append(iZeroOffsetText);\n+            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n+                buf.append(iZeroOffsetPrintText);\n                 return;\n             }\n             if (displayOffset >= 0) {\n             if (displayZone == null) {\n                 return;  // no zone\n             }\n-            if (displayOffset == 0 && iZeroOffsetText != null) {\n-                out.write(iZeroOffsetText);\n+            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n+                out.write(iZeroOffsetPrintText);\n                 return;\n             }\n             if (displayOffset >= 0) {\n             int limit = text.length() - position;\n \n             zeroOffset:\n-            if (iZeroOffsetText != null) {\n-                if (iZeroOffsetText.length() == 0) {\n+            if (iZeroOffsetParseText != null) {\n+                if (iZeroOffsetParseText.length() == 0) {\n                     // Peek ahead, looking for sign character.\n                     if (limit > 0) {\n                         char c = text.charAt(position);\n                     bucket.setOffset(0);\n                     return position;\n                 }\n-                if (text.regionMatches(true, position, iZeroOffsetText, 0,\n-                                       iZeroOffsetText.length())) {\n+                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                     bucket.setOffset(0);\n-                    return position + iZeroOffsetText.length();\n+                    return position + iZeroOffsetParseText.length();\n                 }\n             }\n \n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testFormatParse_zoneId_noColon() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"HH:mm Z\").withZone(UTC);\n+        String str = new DateTime(2007, 6, 23, 1, 2, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"01:02 +0000\", str);\n+        DateTime parsed = dateFormatter.parseDateTime(str);\n+        assertEquals(1, parsed.getHourOfDay());\n+        assertEquals(2, parsed.getMinuteOfHour());\n+    }\n+\n+    public void testFormatParse_zoneId_noColon_parseZ() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"HH:mm Z\").withZone(UTC);\n+        DateTime parsed = dateFormatter.parseDateTime(\"01:02 Z\");\n+        assertEquals(1, parsed.getHourOfDay());\n+        assertEquals(2, parsed.getMinuteOfHour());\n+    }\n+\n+    public void testFormatParse_zoneId_colon() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"HH:mm ZZ\").withZone(UTC);\n+        String str = new DateTime(2007, 6, 23, 1, 2, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"01:02 +00:00\", str);\n+        DateTime parsed = dateFormatter.parseDateTime(str);\n+        assertEquals(1, parsed.getHourOfDay());\n+        assertEquals(2, parsed.getMinuteOfHour());\n+    }\n+\n+    public void testFormatParse_zoneId_colon_parseZ() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"HH:mm ZZ\").withZone(UTC);\n+        DateTime parsed = dateFormatter.parseDateTime(\"01:02 Z\");\n+        assertEquals(1, parsed.getHourOfDay());\n+        assertEquals(2, parsed.getMinuteOfHour());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     private void check(DateTime test, int hour, int min, int sec) {\n         assertEquals(hour, test.getYear());\n         assertEquals(min, test.getMonthOfYear());", "timestamp": 1257373638, "metainfo": ""}