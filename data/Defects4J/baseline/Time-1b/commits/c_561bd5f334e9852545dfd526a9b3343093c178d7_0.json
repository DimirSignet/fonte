{"sha": "561bd5f334e9852545dfd526a9b3343093c178d7", "log": "Move partial methods to chronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Chronology.java\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n     /**\n      * Validates whether the values are valid for the fields of a partial instant.\n      *\n-     * @param instant  the partial instant to validate\n+     * @param partial  the partial instant to validate\n      * @param values  the values to validate, not null, match fields in partial\n      * @throws IllegalArgumentException if the instant is invalid\n      */\n-    public abstract void validate(ReadablePartial instant, int[] values);\n-\n+    public abstract void validate(ReadablePartial partial, int[] values);\n+\n+    /**\n+     * Gets the values of a partial from an instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to query\n+     * @return the values of this partial extracted from the instant\n+     */\n+    public abstract int[] get(ReadablePartial partial, long instant);\n+\n+    /**\n+     * Sets the partial into the instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to update\n+     * @return the updated instant\n+     */\n+    public abstract long set(ReadablePartial partial, long instant);\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Adds the period to the instant, specifying the number of times to add.\n      *\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n         return withMillis(instant);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets a copy of this datetime with the partial set of fields replacing those\n      * from this instance.\n         return withMillis(instant);\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets a copy of this datetime with the specified duration added.\n-     * <p>\n-     * If the addition is zero, then <code>this</code> is returned.\n-     * \n-     * @param durationToAdd  the duration to add to this one\n-     * @return a copy of this datetime with the duration added\n+    /**\n+     * Gets a copy of this datetime with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * An alternative to this method is to use the properties, for example:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, null ignored\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n      */\n-    public DateTime withDurationAdded(long durationToAdd) {\n-        return withDurationAdded(durationToAdd, 1);\n-    }\n-\n+    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null || amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets a copy of this datetime with the specified duration added.\n      * <p>\n      * If the addition is zero, then <code>this</code> is returned.\n      * \n      * @param durationToAdd  the duration to add to this one, null means zero\n-     * @return a copy of this datetime with the duration added\n-     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n-     */\n-    public DateTime withDurationAdded(ReadableDuration durationToAdd) {\n-        if (durationToAdd == null) {\n-            return this;\n-        }\n-        return withDurationAdded(durationToAdd.getMillis(), 1);\n-    }\n-\n-    /**\n-     * Gets a copy of this datetime with the specified duration added.\n-     * <p>\n-     * If the addition is zero, then <code>this</code> is returned.\n-     * \n-     * @param durationToAdd  the duration to add to this one, null means zero\n      * @param scalar  the amount of times to add, such as -1 to subtract once\n      * @return a copy of this datetime with the duration added\n      * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n             return this;\n         }\n         return withDurationAdded(durationToAdd.getMillis(), scalar);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets a copy of this datetime with the value of the specified field increased.\n-     * <p>\n-     * If the addition is zero or the field is null, then <code>this</code> is returned.\n-     * <p>\n-     * An alternative to this method is to use the properties, for example:\n-     * <pre>\n-     * DateTime added = dt.hourOfDay().addToCopy(6);\n-     * </pre>\n-     * \n-     * @param fieldType  the field type to add to, null ignored\n-     * @param amount  the amount to add\n-     * @return a copy of this datetime with the field updated\n-     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n-     */\n-    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n-        if (fieldType == null || amount == 0) {\n-            return this;\n-        }\n-        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n-        return withMillis(instant);\n     }\n \n     /**\n      * DateTime added = dt.hourOfDay().addToCopy(6);\n      * </pre>\n      * \n-     * @param periodToAdd  the duration to add to this one, null means zero\n-     * @return a copy of this datetime with the period added\n-     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n-     */\n-    public DateTime withPeriodAdded(ReadablePeriod periodToAdd) {\n-        return withPeriodAdded(periodToAdd, 1);\n-    }\n-\n-    /**\n-     * Gets a copy of this datetime with the specified period added.\n-     * <p>\n-     * If the addition is zero, then <code>this</code> is returned.\n-     * <p>\n-     * To add or subtract on a single field use the properties, for example:\n-     * <pre>\n-     * DateTime added = dt.hourOfDay().addToCopy(6);\n-     * </pre>\n-     * \n      * @param period  the period to add to this one, null means zero\n      * @param scalar  the amount of times to add, such as -1 to subtract once\n      * @return a copy of this datetime with the period added\n         }\n         long instant = getChronology().add(getMillis(), period, scalar);\n         return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(6);\n+     * DateTime added = dt.plus(Period.hours(6));\n+     * </pre>\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the specified duration take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified duration take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(ReadableDuration durationToAdd) {\n+        return withDurationAdded(durationToAdd, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(-6);\n+     * DateTime added = dt.minus(Period.hours(6));\n+     * </pre>\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n     }\n \n     // Date properties\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n package org.joda.time;\n \n /**\n- * Defines an partial time that does not support every datetime field.\n+ * Defines a partial time that does not support every datetime field, and is\n+ * thus a local time.\n  * <p>\n  * A <code>ReadablePartial</code> supports a subset of those fields on the chronology.\n  * It cannot be compared to a <code>ReadableInstant</code>, as it does not fully\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n      */\n     public long resolve(long baseInstant, DateTimeZone zone) {\n         Chronology chrono = getChronology().withZone(zone);\n-        return resolve(baseInstant, chrono);\n+        return chrono.set(this, baseInstant);\n     }\n \n     /**\n     public DateTime resolveDateTime(ReadableInstant baseInstant) {\n         Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n         long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n-        long resolved = resolve(instantMillis, chrono);\n+        long resolved = chrono.set(this, instantMillis);\n         return new DateTime(resolved, chrono);\n     }\n \n         if (baseInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        Chronology chrono = baseInstant.getChronology();\n-        long resolved = resolve(baseInstant.getMillis(), chrono);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n+        long resolved = chrono.set(this, baseInstant.getMillis());\n         baseInstant.setMillis(resolved);\n-    }\n-\n-    /**\n-     * Resolve this partial into the base millis using the specified chronology.\n-     * \n-     * @param baseInstant  the base millisecond instant\n-     * @param chrono  the chronology\n-     * @return the new resolved millis\n-     */\n-    protected long resolve(long baseInstant, Chronology chrono) {\n-        long millis = baseInstant;\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            millis = getField(i, chrono).set(millis, getValue(i));\n-        }\n-        return millis;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n         super();\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iValues = initValues(instant, chronology);\n+        iValues = chronology.get(this, instant);\n     }\n \n     /**\n         Chronology chronology = converter.getChronology(instant);\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iValues = initValues(millis, chronology);\n+        iValues = chronology.get(this, millis);\n     }\n \n     /**\n         chronology = converter.getChronology(instant, chronology);\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iValues = initValues(millis, chronology);\n+        iValues = chronology.get(this, millis);\n     }\n \n     /**\n         super();\n         iChronology = other.iChronology;\n         iValues = values;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Initialize the array of values.\n-     * The field and value arrays must match.\n-     * \n-     * @param instant  the instant to use\n-     * @param chrono  the chronology to use\n-     */\n-    protected int[] initValues(long instant, Chronology chrono) {\n-        int[] values = new int[size()];\n-        for (int i = 0; i < values.length; i++) {\n-            values[i] = getField(i, chrono).get(instant);\n-        }\n-        return values;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n     }\n \n     /**\n+     * Gets the values of a partial from an instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to query\n+     * @return the values of this partial extracted from the instant\n+     */\n+    public int[] get(ReadablePartial partial, long instant) {\n+        int size = partial.size();\n+        int[] values = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            values[i] = partial.getFieldType(i).getField(this).get(instant);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Sets the partial into the instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to update\n+     * @return the updated instant\n+     */\n+    public long set(ReadablePartial partial, long instant) {\n+        for (int i = 0, isize = partial.size(); i < isize; i++) {\n+            instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i));\n+        }\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Adds the period to the instant, specifying the number of times to add.\n      *\n      * @param instant  the instant to add to", "timestamp": 1094679718, "metainfo": ""}