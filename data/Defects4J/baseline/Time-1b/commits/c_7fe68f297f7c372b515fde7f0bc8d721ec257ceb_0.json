{"sha": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb", "log": "Move version 0.9 to joda-time repository   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.example.time;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.text.ParseException;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JCheckBox;\n+import javax.swing.JComboBox;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.Timer;\n+import javax.swing.event.DocumentEvent;\n+import javax.swing.event.DocumentListener;\n+import javax.swing.text.Document;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * AgeCalculator is a small Swing application that computes age from a specific\n+ * birthdate and time zone. Age is broken down into multiple fields, which can\n+ * be independently disabled.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class AgeCalculator extends JFrame {\n+    static final int\n+        YEAR = 1,\n+        MONTH_OF_YEAR = 2,\n+        DAY_OF_MONTH = 3,\n+        WEEKYEAR = 4,\n+        WEEK_OF_WEEKYEAR = 5,\n+        DAY_OF_WEEK = 6,\n+        HOUR_OF_DAY = 101,\n+        MINUTE_OF_HOUR = 102,\n+        SECOND_OF_MINUTE = 103;\n+\n+    public static void main(String[] args) throws Exception {\n+        new AgeCalculator().show();\n+    }\n+\n+    static JComponent fixedSize(JComponent component) {\n+        component.setMaximumSize(component.getPreferredSize());\n+        return component;\n+    }\n+\n+    static JComponent fixedHeight(JComponent component) {\n+        Dimension dim = component.getMaximumSize();\n+        dim.height = component.getPreferredSize().height;\n+        component.setMaximumSize(dim);\n+        return component;\n+    }\n+\n+    Chronology iChronology;\n+\n+    private String iBirthdateStr;\n+    private FieldSet[] iFieldSets;\n+    private Timer iTimer;\n+\n+    public AgeCalculator() {\n+        super();\n+\n+        iChronology = ISOChronology.getInstance();\n+        iBirthdateStr = \"1970-01-01T00:00:00\";\n+\n+        setTitle(\"Age Calculator\");\n+        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        addMainArea(getContentPane());\n+        addNotify();\n+        Dimension size = getPreferredSize();\n+        setSize(size);\n+        Dimension screenSize = getToolkit().getScreenSize();\n+        setLocation(screenSize.width / 2 - size.width / 2,\n+                    screenSize.height / 2 - size.height / 2);\n+\n+        iTimer = new Timer(500, new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                updateResults();\n+            }\n+        });\n+\n+        iTimer.setInitialDelay(0);\n+        iTimer.start();\n+    }\n+\n+    private void addMainArea(Container container) {\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n+\n+        addTopArea(panel);\n+        panel.add(Box.createVerticalStrut(10));\n+        addBottomArea(panel);\n+        panel.add(Box.createVerticalGlue());\n+\n+        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        container.add(panel);\n+    }\n+\n+    private void addTopArea(Container container) {\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));\n+\n+        panel.add(fixedHeight(new JLabel(\"Birthdate\")));\n+        panel.add(Box.createHorizontalStrut(10));\n+\n+        final JTextField birthdateField = new JTextField(iBirthdateStr + ' ');\n+        Document doc = birthdateField.getDocument();\n+        doc.addDocumentListener(new DocumentListener() {\n+            public void insertUpdate(DocumentEvent e) {\n+                update(e);\n+            }\n+            public void removeUpdate(DocumentEvent e) {\n+                update(e);\n+            }\n+            public void changedUpdate(DocumentEvent e) {\n+                update(e);\n+            }\n+            private void update(DocumentEvent e) {\n+                iBirthdateStr = birthdateField.getText();\n+                updateResults();\n+            }\n+        });\n+        panel.add(fixedHeight(birthdateField));\n+\n+        panel.add(Box.createHorizontalStrut(10));\n+\n+        Object[] ids = DateTimeZone.getAvailableIDs().toArray();\n+        final JComboBox zoneSelector = new JComboBox(ids);\n+        zoneSelector.setSelectedItem(DateTimeZone.getDefault().getID());\n+        panel.add(fixedSize(zoneSelector));\n+\n+        zoneSelector.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                String id = (String)zoneSelector.getSelectedItem();\n+                iChronology = ISOChronology.getInstance(DateTimeZone.getInstance(id));\n+                updateResults();\n+            }\n+        });\n+\n+        container.add(fixedHeight(panel));\n+    }\n+\n+    private void addBottomArea(Container container) {\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));\n+\n+        ItemListener listener = new ItemListener() {\n+            public void itemStateChanged(ItemEvent e) {\n+                updateResults();\n+            }\n+        };\n+\n+        iFieldSets = new FieldSet[] {\n+            new FieldSet(\"Month Based\", new FieldGroup[] {\n+                new FieldGroup(listener, \"Years\", YEAR),\n+                new FieldGroup(listener, \"Months\", MONTH_OF_YEAR),\n+                new FieldGroup(listener, \"Days\", DAY_OF_MONTH),\n+                new FieldGroup(listener, \"Hours\", HOUR_OF_DAY),\n+                new FieldGroup(listener, \"Minutes\", MINUTE_OF_HOUR),\n+                new FieldGroup(listener, \"Seconds\", SECOND_OF_MINUTE)\n+            })\n+            ,\n+            new FieldSet(\"Week Based\", new FieldGroup[] {\n+                new FieldGroup(listener, \"Weekyears\", WEEKYEAR),\n+                new FieldGroup(listener, \"Weeks\", WEEK_OF_WEEKYEAR),\n+                new FieldGroup(listener, \"Days\", DAY_OF_WEEK),\n+                new FieldGroup(listener, \"Hours\", HOUR_OF_DAY),\n+                new FieldGroup(listener, \"Minutes\", MINUTE_OF_HOUR),\n+                new FieldGroup(listener, \"Seconds\", SECOND_OF_MINUTE)\n+            })\n+        };\n+\n+        for (int i=0; i<iFieldSets.length; i++) {\n+            if (i > 0) {\n+                panel.add(Box.createHorizontalStrut(10));\n+            }\n+            iFieldSets[i].addTo(panel);\n+        }\n+        panel.add(Box.createVerticalGlue());\n+\n+        container.add(fixedHeight(panel));\n+    }\n+\n+    private void updateResults() {\n+        try {\n+            DateTime dt = new DateTime(iBirthdateStr.trim(), iChronology);\n+\n+            long minuend = System.currentTimeMillis();\n+            long subtrahend = dt.getMillis();\n+\n+            for (int i=0; i<iFieldSets.length; i++) {\n+                iFieldSets[i].updateResults(minuend, subtrahend);\n+            }\n+        }\n+        catch (ParseException e) {\n+            for (int i=0; i<iFieldSets.length; i++) {\n+                iFieldSets[i].setResultsText(\"\");\n+            }\n+        }\n+    }\n+\n+    private class FieldGroup {\n+        public final JCheckBox iCheckbox;\n+        public final JTextField iResult;\n+        public final int iFieldType;\n+\n+        FieldGroup(ItemListener listener, String checkboxText, int fieldType) {\n+            iCheckbox = new JCheckBox(checkboxText, true);\n+            iCheckbox.addItemListener(listener);\n+            iResult = new JTextField();\n+            iResult.setEditable(false);\n+            iFieldType = fieldType;\n+        }\n+\n+        public long updateResult(long minuend, long subtrahend) {\n+            // Because time zone can be dynamically changed, field must be\n+            // dynamically acquired.\n+\n+            DateTimeField field;\n+            switch (iFieldType) {\n+            case YEAR:\n+                field = iChronology.year();\n+                break;\n+            case MONTH_OF_YEAR:\n+                field = iChronology.monthOfYear();\n+                break;\n+            case DAY_OF_MONTH:\n+                field = iChronology.dayOfMonth();\n+                break;\n+            case WEEKYEAR:\n+                field = iChronology.weekyear();\n+                break;\n+            case WEEK_OF_WEEKYEAR:\n+                field = iChronology.weekOfWeekyear();\n+                break;\n+            case DAY_OF_WEEK:\n+                field = iChronology.dayOfWeek();\n+                break;\n+            case HOUR_OF_DAY:\n+                field = iChronology.hourOfDay();\n+                break;\n+            case MINUTE_OF_HOUR:\n+                field = iChronology.minuteOfHour();\n+                break;\n+            case SECOND_OF_MINUTE: default:\n+                field = iChronology.secondOfMinute();\n+                break;\n+            }\n+\n+            String textToSet = \"\";\n+\n+            if (iCheckbox.isSelected()) {\n+                long difference = field.getDifference(minuend, subtrahend);\n+                textToSet = Long.toString(difference);\n+                subtrahend = field.add(subtrahend, difference);\n+            }\n+\n+            if (!iResult.getText().equals(textToSet)) {\n+                iResult.setText(textToSet);\n+            }\n+\n+            return subtrahend;\n+        }\n+\n+        public void setResultText(String text) {\n+            iResult.setText(text);\n+        }\n+    }\n+\n+    private static class FieldSet {\n+        private final String iTitle;\n+        private final FieldGroup[] iGroups;\n+\n+        FieldSet(String title, FieldGroup[] groups) {\n+            iTitle = title;\n+            iGroups = groups;\n+        }\n+\n+        private long updateResults(long minuend, long subtrahend) {\n+            for (int i=0; i<iGroups.length; i++) {\n+                subtrahend = iGroups[i].updateResult(minuend, subtrahend);\n+            }\n+            return subtrahend;\n+        }\n+\n+        public void setResultsText(String text) {\n+            for (int i=0; i<iGroups.length; i++) {\n+                iGroups[i].setResultText(text);\n+            }\n+        }\n+\n+        private void addTo(Container container) {\n+            JPanel panel = new JPanel();\n+            GridBagLayout layout = new GridBagLayout();\n+            panel.setLayout(layout);\n+\n+            panel.setBorder(BorderFactory.createTitledBorder(iTitle));\n+\n+            for (int i=0; i<iGroups.length; i++) {\n+                FieldGroup fg = iGroups[i];\n+                panel.add(fg.iCheckbox);\n+                setCheckboxConstraints(layout, fg.iCheckbox, 0, i);\n+                panel.add(fg.iResult);\n+                setResultConstraints(layout, fg.iResult, 1, i);\n+            }\n+\n+            container.add(fixedHeight(panel));\n+        }\n+\n+        private void setCheckboxConstraints(GridBagLayout layout, Component c,\n+                                            int x, int y)\n+        {\n+            GridBagConstraints cons = new GridBagConstraints();\n+            cons.gridx = x;\n+            cons.gridy = y;\n+            cons.weightx = 0.1;\n+            cons.anchor = GridBagConstraints.WEST;\n+            layout.setConstraints(c, cons);\n+        }\n+\n+        private void setResultConstraints(GridBagLayout layout, Component c,\n+                                          int x, int y)\n+        {\n+            GridBagConstraints cons = new GridBagConstraints();\n+            cons.gridx = x;\n+            cons.gridy = y;\n+            cons.weightx = 1.0;\n+            cons.anchor = GridBagConstraints.WEST;\n+            cons.fill = GridBagConstraints.HORIZONTAL;\n+            layout.setConstraints(c, cons);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+/*\n+ * Package statement.\n+ */\n+package org.joda.example.time;\n+/*\n+ * Import required Java packages.\n+ */\n+import java.awt.*;\n+import java.awt.event.*;\n+import javax.swing.*;\n+import javax.swing.table.*;\n+import java.io.*;\n+import java.util.*;\n+import java.text.*;\n+/*\n+ * Import required Joda packages.\n+ */\n+import org.joda.time.*;\n+\n+/** DateTimeBrowser is a Java Swing application which reads a file contining\n+ * strings and displays DateTime values in a JTable.<p>\n+ * The input strings must be suitable for instantiation\n+ * of DateTime objects.  The file is read, and an attempt is made\n+ * to instantiate a DateTimeObject from the input string on each file\n+ * line.<p>\n+ * Comments (beginning with '#') and blank lines may appear in\n+ * the file.<p>\n+ * Error messages may result from invalid input.<p>\n+ * Values calculated from any resulting DateTime objects are placed\n+ * in a JTable and displayed in a JFrame.<p>\n+ *\n+ * @author Guy Allard\n+ * @version 1.0\n+ */\n+public class DateTimeBrowser extends JFrame {\n+    //\n+    private String[] mainArgs = null;           // Copy of args[] reference.\n+    //\n+    private LoadedFile currFile = null;         // New ones possible at\n+                                                // runtime.\n+    private JScrollPane mainSP = null;          // Swapped around at runtime\n+    //\n+    /**\n+     * The getter view  menu item.\n+     */\n+    JMenuItem jmiGetter = null;\n+    /**\n+     * The hexadecimal view menu item.\n+     */\n+    JMenuItem jmiHex = null;\n+    /**\n+     * The Java Date view menu item.\n+     */\n+    JMenuItem jmiDate = null;\n+    /**\n+     * The java calendar menu item.\n+     */\n+    JMenuItem jmiCal = null;\n+    //\n+    // Done deals.\n+    //\n+    private final JFileChooser chooser = new JFileChooser();\n+    private final boolean debugf = false;       // debugging flag\n+    private final boolean debugt = true;        // debugging flag\n+\n+    /**\n+     * This is the main swing application method.   It sets up and displays the\n+     * initial GUI, and controls execution thereafter.  Everything else in\n+     * this class is 'private', please read the code.\n+     */\n+    public static void main(String[] args) {\n+        /*\n+         * Developers Notes:\n+         *\n+         * -No corresponding Junit test class currently\n+         * provided.  Test by eyeball of the output.\n+         *\n+         * -Add a menu with Help(About)\n+         * --> TBD.\n+         *\n+         * -Figure out some sane way to set initial default\n+         * column sizes.\n+         *\n+         * -Lots of inner classes here, done in order to keep\n+         * all the .class files easily identifiable.  Some of\n+         * this code is pretty ugly, very procedural in nature.\n+         * Lots of very tight coupling between all the classes,\n+         * thinly disguised switch statements, etc ..... This\n+         * code written on the fly, with almost no thought given\n+         * to OO design.\n+         *\n+         * -Also, I'm not really a GUI guy, so forgive any\n+         * transgressions.\n+         *\n+         */\n+            if ( args.length < 1 ) {\n+                System.err.println(\"File name is required!\");\n+                usage();\n+                System.exit(1);\n+            }\n+        /*\n+         * Instantiate a DateTimeBrowser and invoke it's go method,\n+         * passing the input argument list.\n+         */\n+        new DateTimeBrowser().go( args );\n+    } // main\n+\n+    /*\n+     * usage A private static method to display usage information to\n+     * the user before an error exit.\n+     */\n+    private static void usage() {\n+            System.err.println(\"Usage:\");\n+            System.err.println(\"DateTimeBrowser <options> <filename>\");\n+            System.err.println(\"<filename> contains a list of Strings\");\n+            System.err.println(\"\\twhich are valid for DateTime instantiation.\");\n+            System.err.println(\"<optons>\");\n+            System.err.println(\"\\t-Duse.time.zone=\");\n+            System.err.println(\"\\t\\tA valid timezone name.  If not specified\");\n+            System.err.println(\"\\t\\tthe OS/user default is used.  If sepcified\");\n+            System.err.println(\"\\t\\tincorrectly, GMT is quietly used.\");\n+            System.err.println(\"\\t-Duse.view=\");\n+            System.err.println(\"\\t\\tAn initial view to be displayed.\");\n+            System.err.println(\"\\t\\tValid names are: getter, hex, date, cal\");\n+            System.err.println(\"\\t\\tIf incorrectly specified, getter is used.\");\n+            System.err.println(\"\\t\\tThis becomes the default view.\");\n+    } // usage\n+\n+    /*\n+     * go This method reads the file, creates the table to display,\n+     * the window to display it in, and displays the window.\n+     * @param fileName the name of the file to read.\n+     * @param tryLines An estimate of the number of lines in\n+     * the file.\n+     */\n+    private void go(String[] args) {\n+\n+        mainArgs = args;\n+        setDefaultTimeZone();   // let user override if needed\n+        // setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        //\n+        JMenuBar menuBar = new JMenuBar();\n+        setJMenuBar( menuBar );\n+        addMenus( menuBar );\n+        /*\n+         * Add a fast close listener\n+         */\n+\n+        addWindowListener( new WindowAdapter() {\n+                    public void windowClosing(WindowEvent e)\n+                    {\n+                        setVisible( false );\n+                        dispose();\n+                        System.exit(0);\n+                    }\n+                }\n+            );\n+\n+        //\n+        // Load current file, prime tables and JFrame.\n+        //\n+        currFile = new LoadedFile( mainArgs[0] );\n+        TableView tView = getDefaultTableView();\n+        resetDefaults( tView );\n+        //\n+        // Set max size at start, and display the window.\n+        //\n+        Dimension screenMax = Toolkit.getDefaultToolkit().getScreenSize();\n+        setSize ( screenMax );\n+        setVisible(true);\n+    }\n+\n+    //\n+    // --> Private implementation methods follow.\n+    //\n+\n+    /*\n+     * getDefaultTableView\n+     */\n+    private TableView getDefaultTableView() {\n+        // No user input.\n+        String viewStr = System.getProperty(\"use.view\");\n+        if ( viewStr == null ) {\n+            jmiGetter.setEnabled( false );\n+            return new GetterTableView( currFile );\n+        }\n+        // Valid user input.\n+        if ( viewStr.equalsIgnoreCase(\"hex\") ) {\n+            jmiHex.setEnabled( false );\n+            return new HexTableView( currFile );\n+        }\n+        else if ( viewStr.equalsIgnoreCase(\"date\") ) {\n+            jmiDate.setEnabled( false );\n+            return new DateTableView( currFile );\n+        }\n+        else if ( viewStr.equalsIgnoreCase(\"cal\") ) {\n+            jmiCal.setEnabled( false );\n+            return new CalTableView( currFile );\n+        }\n+        else if ( viewStr.equalsIgnoreCase(\"getter\") ) {\n+            jmiGetter.setEnabled( false );\n+            return new GetterTableView( currFile );\n+        }\n+        else { // error by user\n+            System.err.println(\"View name: \" + viewStr + \" invalid.\");\n+            jmiGetter.setEnabled( false );\n+            return new GetterTableView( currFile );\n+        }\n+    }\n+    /*\n+    * setDefaultTableView\n+    */\n+    private void setDefaultTableView(String newView) {\n+        System.setProperty( \"use.view\", newView );\n+    }\n+    /*\n+     * setDefaultTimeZone\n+     */\n+    private void setDefaultTimeZone() {\n+        String tzName = System.getProperty(\"use.time.zone\");\n+        if ( tzName == null ) return;   // Use OS/user default.\n+        //\n+        // If tzName is bogus, not understood by the JRE,\n+        // 'getTimeZone' returns GMT.\n+        //\n+        TimeZone toSet = TimeZone.getTimeZone( tzName );\n+        //\n+        // Set default to whatever was returned.\n+        //\n+        TimeZone.setDefault( toSet );\n+    }\n+\n+    /*\n+     * addMenus\n+     */\n+    private void addMenus( JMenuBar menuBar) {\n+        //\n+        // Create all the menus.\n+        //\n+        JMenu fileMenu = new JMenu(\"File\");\n+        JMenu viewMenu = new JMenu(\"View\");\n+        //\n+        // Add them to the menubar in order.\n+        //\n+        menuBar.add( fileMenu );\n+        menuBar.add( viewMenu );\n+        //\n+        // Create action objects and menu items.\n+        //\n+        Action open = new OpenAction();\n+        JMenuItem jmiOpen = new JMenuItem( open );\n+        Action exit = new ExitAction();\n+        JMenuItem jmiExit = new JMenuItem( exit );\n+        //\n+        // Next Menu\n+        //\n+        Action getter = new GetterAction();\n+        jmiGetter = new JMenuItem( getter );\n+        getter.setEnabled( true );\n+        //\n+        Action hex = new HexAction();\n+        jmiHex = new JMenuItem( hex );\n+        hex.setEnabled( true );\n+        //\n+        Action date = new DateAction();\n+        jmiDate = new JMenuItem( date );\n+        date.setEnabled( true );\n+        //\n+        Action cal = new CalAction();\n+        jmiCal = new JMenuItem( cal );\n+        cal.setEnabled( true );\n+        //\n+        // Build the file menu.\n+        //\n+        fileMenu.add( jmiOpen );\n+        fileMenu.addSeparator();\n+        fileMenu.add( jmiExit );\n+        //\n+        // Build the view menu.\n+        //\n+        viewMenu.add( jmiGetter );\n+        viewMenu.add( jmiHex );\n+        viewMenu.add( jmiDate );\n+        viewMenu.add( jmiCal );\n+        //\n+        // *temp Developer's code\n+        //\n+        // jmiGetter.setEnabled( false );\n+        //\n+        // JMenuItem getter2 = new JMenuItem( \"getter2\" );\n+        // getter2.addActionListener( new myMouseListener() );\n+        // viewMenu.add( getter2 );\n+    } // end of addMenus\n+\n+    /*\n+     * A private method to dump the arrays of Object[][]\n+     * if desired by the developer\n+     * @param objs The array of arrays to be dumped.\n+     */\n+    private void dumpObjs(Object[][] objs, PrintStream out ) {\n+        for (int i = 0; i < objs.length; ++i) {\n+            for (int j = 0; j < objs[i].length; ++j) {\n+                out.println(i + \" \" + j + \" \"\n+                    + objs[i][j]);\n+            } // for j\n+        } // for i\n+    }\n+\n+    /*\n+     * enableAll\n+     */\n+    private void enableAllViews() {\n+        jmiGetter.setEnabled( true );\n+        jmiHex.setEnabled( true );\n+        jmiDate.setEnabled( true );\n+        jmiCal.setEnabled( true );\n+    } // end of enableAllViews\n+\n+    /*\n+     * getADate Returns a new DateTime object reference if possible,\n+     * otherwise null.\n+     * @return retDT A DateTime object reference.\n+     */\n+    private DateTime getADate(String s) {\n+        DateTime retDT = null;\n+        try\n+        {\n+            retDT = new DateTime( s );\n+        } // the try\n+        catch(ParseException pe)\n+        {\n+            // ignore it here, caller sees null\n+        } // the catch\n+        return retDT;\n+    } // getADate\n+    //\n+    private static final String PADCHARS = \"00000000000000000000000000000000\";\n+\n+    /*\n+     * LPad Return a String, left padded with '0's as specified\n+     * by the caller.\n+     */\n+    private String LPad(String inStr, int maxLen) {\n+        if (inStr.length() >= maxLen) return inStr.toUpperCase();\n+        String zeroes = PADCHARS.substring(0, maxLen - inStr.length());\n+        String retVal = zeroes + inStr;\n+        return retVal.toUpperCase();\n+    }\n+\n+    /*\n+     * resetDefaults\n+     */\n+    private void resetDefaults( TableView tView ) {\n+        Object[] colNames = tView.getColNames();\n+        Object[][] tableValues = tView.getCalcdValues();\n+        // dumpObjs( tableValues, System.out);\n+        JTable table = new JTable( tableValues, colNames );\n+        tView.setViewColumnsWidth( table );\n+        setTitle( tView.getViewTitle() );\n+        //\n+        if ( mainSP != null ) getContentPane().remove( mainSP );\n+        mainSP = new JScrollPane( table );\n+        getContentPane().add( mainSP, \"Center\" );\n+        validate();\n+    } // end of resetDefaults\n+\n+    //\n+    // ----> Private internal classes follow.\n+    //\n+\n+    /*\n+     * LoadedFile This class represents a file that has been loaded\n+     * for viewing.\n+     */\n+    private class LoadedFile {\n+        // Instance variables\n+        String fileName = null;\n+        ArrayList fileStrings = null;\n+        ArrayList dtObjects = null;\n+        int lineGuess = 0;\n+\n+        /*\n+         * LoadedFile constructor.\n+         */\n+        LoadedFile(String fileName) {\n+            validateFile( fileName );\n+            this.fileName = fileName;\n+            //\n+            fileStrings = new ArrayList( lineGuess );\n+            dtObjects = new ArrayList( lineGuess );\n+\n+            try\n+            {\n+                BufferedReader  rdr =\n+                    new BufferedReader( new FileReader( fileName ) );\n+                String inputLine = null;\n+                DateTime calculatedDT = null;\n+                int currLine = 0;\n+                while( (inputLine = rdr.readLine()) != null ) {\n+                    currLine++;\n+                    inputLine = inputLine.trim();\n+                    // Ignore blank and comment lines\n+                    if ( inputLine.length() == 0 ) continue;\n+                    if ( inputLine.charAt(0) == '#' ) continue;\n+                    // Ignore lines which fail DateTime construction\n+                    if ( (calculatedDT = getADate(inputLine)) == null ) {\n+                        System.err.println(\"Parse failed for: \" + inputLine\n+                            + \" at line number \" + currLine);\n+                        continue;\n+                    }\n+                    // Add the input file string and DateTime to lists\n+                    fileStrings.add( inputLine );\n+                    dtObjects.add( calculatedDT );\n+                }\n+                rdr.close();\n+            }\n+            catch(IOException ioe)\n+            {\n+                System.err.println(\"Load of file: \"\n+                    + fileName + \" failed!\");\n+                ioe.printStackTrace();\n+                System.exit(100);\n+            }\n+\n+            // Try to be efficient (?really?)\n+            fileStrings.trimToSize();\n+            dtObjects.trimToSize();\n+            } // end of LoadedFile() constructor\n+        /*\n+         * General getters.\n+         */\n+        public String getFileName() { return fileName; }\n+        public int getLineGuess() { return lineGuess; }\n+        public ArrayList getFileStrings() { return fileStrings; }\n+        public ArrayList getDtObjects() { return dtObjects; }\n+        public int getLoadedFileSize() {\n+            if ( dtObjects == null ) return 0;\n+            return dtObjects.size();\n+        }\n+        /*\n+         * validateFile\n+         */\n+        private void validateFile(String fileName) {\n+            /*\n+             * Verify the user specified file exists and can\n+             * be read.\n+             */\n+            File f = new File( fileName );\n+            if ( !f.exists() || !f.canRead() ) {\n+                System.err.println(\"File: \" + mainArgs[0]\n+                    + \" does not exist or cannot be read!\");\n+                usage();\n+                System.exit(2);\n+            }\n+            /*\n+             * Try to get a reasonable estimate of the number of lines\n+             * in the file.\n+             */\n+            // Java does not do this right IMO.  The number of bytes in a\n+            // file is a\n+            // long, but the length of a string is an int.  Why?\n+            lineGuess = (int)(f.length() / (long)\"YYYY-MM-DDTHH:MM:SS\".length());\n+            lineGuess += (lineGuess / 10);\n+            //\n+            // Debugging\n+            //\n+            if ( false ) {\n+                System.out.println(\"Line guess is: \" + lineGuess);\n+            }\n+        } // end of validateFile(String)\n+    } // end of class LoadedFile class\n+\n+    /*\n+     * TableView This abstract class defines the operations\n+     * necessary to create and access the Object arrays\n+     * required to create a JTable.\n+     */\n+    private abstract class TableView {\n+        protected Object[] colNames = null;\n+        protected Object[][] calcdValues = null;\n+        protected LoadedFile lddFile = null;\n+        //\n+        TableView(LoadedFile lddFile) {\n+            this.lddFile = lddFile;\n+        }\n+        //\n+        public Object[] getColNames() {\n+            return colNames;\n+        }\n+        public Object[][] getCalcdValues() {\n+            return calcdValues;\n+        }\n+        //\n+        abstract Object[] genColNames();\n+        abstract Object[][] genCalcdValues();\n+        abstract String getViewTitle();\n+        abstract void setViewColumnsWidth(JTable jt);\n+        //\n+    } // end of abstract class TableView\n+\n+    /*\n+     * GetterTableView This class implements the operations\n+     * for the GetterView of the Jtable.\n+     */\n+    private class GetterTableView extends TableView {\n+        //\n+        GetterTableView(LoadedFile lddFile) {\n+            super(lddFile);\n+            setDefaultTableView( \"getter\" );\n+            colNames = genColNames();\n+            calcdValues = genCalcdValues();\n+        }\n+\n+        /*\n+         * genCalcdValues is required by the base class.\n+         */\n+        Object[][] genCalcdValues() {\n+            Object[][] retValues = null;\n+            /*\n+             * Create an array of Objects that will contain\n+             * other arrays of Objects. (This is the 'column'\n+             * array).\n+             */\n+            ArrayList fileStrings = lddFile.getFileStrings();\n+            ArrayList dtObjects = lddFile.getDtObjects();\n+            int numRows = fileStrings.size();\n+            retValues = new Object[numRows][];\n+            int numCols = colNames.length;\n+            // System.err.println(\"NumCols : \" + numCols);\n+            /*\n+             * Prime the array of arrays of Objects, allocating a new\n+             * secondary array for each of the primary array's\n+             * elements.\n+             */\n+            for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {\n+                retValues[nextStrNum] = new Object[numCols]; // get the 'col' array\n+                //****\n+                //* This needs to be sync'd with the colNames array.\n+                //****\n+                // Current row, 1st column\n+                int column = 0; // working row value\n+                String fileString = (String)fileStrings.get(nextStrNum);\n+                retValues[nextStrNum][column++] = fileString;\n+                // Current row, 2nd column\n+                DateTime adt = (DateTime)dtObjects.get(nextStrNum);\n+                String adtStr = adt.toString();\n+                retValues[nextStrNum][column++] = adtStr;\n+                // Current row, other columns.\n+                // Order here must match that specified in the colNames\n+                // array.\n+                retValues[nextStrNum][column++]  = new Integer( adt.getMillisOfSecond() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getSecondOfMinute() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getMinuteOfHour() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getHourOfDay() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfWeek() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfMonth() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfYear() );\n+                retValues[nextStrNum][column++]  = new Integer( adt.getWeekOfWeekyear() );\n+                retValues[nextStrNum][column++] = new Integer( adt.getWeekyear() );\n+                retValues[nextStrNum][column++] = new Integer( adt.getMonthOfYear() );\n+                retValues[nextStrNum][column++] = new Integer( adt.getYear() );\n+                //\n+            } // the for\n+            if ( debugf ) dumpObjs( retValues, System.err );\n+            return retValues;\n+        } // end of genTBValues\n+\n+        /*\n+         * genColNames is required by the base class.\n+         */\n+        Object[] genColNames() {\n+            Object[] retVal = {\n+                \"FileString\",\n+                \"toString()\",\n+                \"MillisOfSec\",\n+                \"SecOfMin\",\n+                \"MinOfHr\",\n+                \"HrOfDay\",\n+                \"DayOfWk\",\n+                \"DayOfMon\",\n+                \"DayOfYr\",\n+                \"WeekOfWY\",\n+                \"YearOfWY\",\n+                \"MonOfYr\",\n+                \"Year\"\n+            };\n+            return retVal;\n+        }\n+\n+        /*\n+         * getViewTitle\n+         */\n+        String getViewTitle() {\n+            return \"DateTime.getXXX() Method Calculations\"\n+                + \" : \"\n+                + TimeZone.getDefault().getDisplayName()\n+                + \" : \"\n+                + \" Record Count \"\n+                + currFile.getLoadedFileSize();\n+        }\n+        /*\n+         * setViewColumnLengths\n+         */\n+        void setViewColumnsWidth(JTable jt) {\n+            /*\n+             * Resize column 0, 1\n+             */\n+            TableColumnModel colmodel = jt.getColumnModel();\n+            TableColumn col0 = colmodel.getColumn(0);\n+            col0.setPreferredWidth(200);\n+            TableColumn col1 = colmodel.getColumn(1);\n+            col1.setPreferredWidth(200);\n+            return;\n+        }\n+\n+    } // end of class getterTableView\n+\n+    /*\n+     * HexView This class implements the operations for\n+     * the HexView of the file.\n+     */\n+    private class HexTableView extends TableView {\n+        //\n+        HexTableView(LoadedFile lddFile) {\n+            super(lddFile);\n+            setDefaultTableView( \"hex\" );\n+            colNames = genColNames();\n+            calcdValues = genCalcdValues();\n+        }\n+\n+        /*\n+         * genCalcdValues is required by the base class.\n+         */\n+        Object[][] genCalcdValues() {\n+            Object[][] retValues = null;\n+            /*\n+             * Create an array of Objects that will contain\n+             * other arrays of Objects. (This is the 'column'\n+             * array).\n+             */\n+            ArrayList fileStrings = lddFile.getFileStrings();\n+            ArrayList dtObjects = lddFile.getDtObjects();\n+            int numRows = fileStrings.size();\n+            retValues = new Object[numRows][];\n+            int numCols = colNames.length;\n+            // System.err.println(\"NumCols : \" + numCols);\n+            String fs = \"yyyy-MM-dd'T'HH:mm:ss\";\n+            DateFormat df = new SimpleDateFormat( fs );\n+            /*\n+             * Prime the array of arrays of Objects, allocating a new\n+             * secondary array for each of the primary array's\n+             * elements.\n+             */\n+            for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {\n+                retValues[nextStrNum] = new Object[numCols]; // get the 'col' array\n+                //****\n+                //* This needs to be sync'd with the colNames array.\n+                //****\n+                // Current row, 1st column\n+                int column = 0;\n+                String fileString = (String)fileStrings.get(nextStrNum);\n+                retValues[nextStrNum][column++] = fileString;\n+                // Current row, 2nd column\n+                DateTime adt = (DateTime)dtObjects.get(nextStrNum);\n+                String adtStr = adt.toString();\n+                retValues[nextStrNum][column++] = adtStr;\n+                // Current row, other columns.\n+                // Order here must match that specified in the colNames\n+                // array.\n+                long lVal = adt.getMillis();\n+                Long millis = new Long( lVal );\n+                retValues[nextStrNum][column++]  = millis;\n+                String hexVal = Long.toHexString( lVal );\n+                String octalVal = Long.toOctalString( lVal );\n+                retValues[nextStrNum][column++]  = \"0\"+ LPad(octalVal,22);\n+                retValues[nextStrNum][column++]  = \"0x\" + LPad(hexVal,16);\n+                //\n+                Date javaDate = null;\n+                try\n+                {\n+                    javaDate = df.parse( fileString );\n+                }\n+                catch(ParseException e)\n+                {\n+                    System.err.println(\"Parse failed for : \" + fileString);\n+                    // pe.printStackTrace();\n+                }\n+                //\n+                lVal = javaDate.getTime();\n+                millis = new Long( lVal );\n+                hexVal = Long.toHexString( lVal );\n+                octalVal = Long.toOctalString( lVal );\n+                retValues[nextStrNum][column++]  = millis;\n+                retValues[nextStrNum][column++]  = \"0\"+ LPad(octalVal,22);\n+                retValues[nextStrNum][column++]  = \"0x\" + LPad(hexVal,16);\n+                //\n+            } // the for\n+            if ( debugf ) dumpObjs( retValues, System.err );\n+            return retValues;\n+        } // end of genTBValues\n+\n+        /*\n+         * genColNames is required by the base class.\n+         */\n+        Object[] genColNames() {\n+            Object[] retVal = {\n+                \"FileString\",\n+                \"toString()\",\n+                \"JDT-millis\",\n+                \"JDT-Oct\",\n+                \"JDT-Hex\",\n+                \"Date-millis\",\n+                \"Date-Oct\",\n+                \"Date-Hex\"\n+            };\n+            return retVal;\n+        }\n+\n+        /*\n+         * getViewTitle\n+         */\n+        String getViewTitle() {\n+            return \"View the long values\"\n+                + \" : \"\n+                + TimeZone.getDefault().getDisplayName()\n+                + \" : \"\n+                + \" Record Count \"\n+                + currFile.getLoadedFileSize();\n+        }\n+        /*\n+         * setViewColumnLengths\n+         */\n+        void setViewColumnsWidth(JTable jt) {\n+            return;\n+        }\n+\n+    } // end of class HexTableView\n+\n+    /*\n+     * DateTableView This class implements the operations for\n+     * the java.util.Date of the file.\n+     */\n+    private class DateTableView extends TableView {\n+        //\n+        DateTableView(LoadedFile lddFile) {\n+            super(lddFile);\n+            setDefaultTableView( \"date\" );\n+            colNames = genColNames();\n+            calcdValues = genCalcdValues();\n+        }\n+\n+        /*\n+         * genCalcdValues is required by the base class.\n+         */\n+        Object[][] genCalcdValues() {\n+            Object[][] retValues = null;\n+            /*\n+             * Create an array of Objects that will contain\n+             * other arrays of Objects. (This is the 'column'\n+             * array).\n+             */\n+            ArrayList fileStrings = lddFile.getFileStrings();\n+            ArrayList dtObjects = lddFile.getDtObjects();\n+            int numRows = fileStrings.size();\n+            retValues = new Object[numRows][];\n+            int numCols = colNames.length;\n+            // System.err.println(\"NumCols : \" + numCols);\n+            /*\n+             * Prime the array of arrays of Objects, allocating a new\n+             * secondary array for each of the primary array's\n+             * elements.\n+             */\n+            for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {\n+                retValues[nextStrNum] = new Object[numCols]; // get the 'col' array\n+                //****\n+                //* This needs to be sync'd with the colNames array.\n+                //****\n+                // Current row, 1st column\n+                int column = 0;\n+                String fileString = (String)fileStrings.get(nextStrNum);\n+                retValues[nextStrNum][column++] = fileString;\n+                // Current row, 2nd column\n+                DateTime adt = (DateTime)dtObjects.get(nextStrNum);\n+                String adtStr = adt.toString();\n+                retValues[nextStrNum][column++] = adtStr;\n+                // Current row, other columns.\n+                // Order here must match that specified in the colNames\n+                // array.\n+                long lVal = adt.getMillis();\n+                java.util.Date jDate = new java.util.Date( lVal );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getSeconds() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getMinutes() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getHours() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getDay() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getDate() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getMonth() );\n+                retValues[nextStrNum][column++] = new Integer( jDate.getYear() );\n+                //\n+            } // the for\n+            if ( debugf ) dumpObjs( retValues, System.err );\n+            return retValues;\n+        } // end of genTBValues\n+\n+        /*\n+         * genColNames is required by the base class.\n+         */\n+        Object[] genColNames() {\n+            Object[] retVal = {\n+                \"FileString\",   // 0\n+                \"toString()\",   // 1\n+                \"Seconds\",      // 2\n+                \"Minutes\",      // 3\n+                \"Hours\",        // 4\n+                \"Day Of Week\",          // 5\n+                \"Day Of Month\",         // 6\n+                \"Month\",        // 7\n+                \"Year\"          // 8\n+            };\n+            return retVal;\n+        }\n+\n+        /*\n+         * getViewTitle\n+         */\n+        String getViewTitle() {\n+            return \"java.util.Date getXXX\"\n+                + \" : \"\n+                + TimeZone.getDefault().getDisplayName()\n+                + \" : \"\n+                + \" Record Count \"\n+                + currFile.getLoadedFileSize();\n+        }\n+        /*\n+         * setViewColumnLengths\n+         */\n+        void setViewColumnsWidth(JTable jt) {\n+            /*\n+             * Resize column 0, 1\n+             */\n+            TableColumnModel colmodel = jt.getColumnModel();\n+            TableColumn col0 = colmodel.getColumn(0);\n+            col0.setPreferredWidth(150);\n+            TableColumn col1 = colmodel.getColumn(1);\n+            col1.setPreferredWidth(150);\n+            return;\n+        }\n+\n+    } // end of class DateTableView\n+\n+    /*\n+     * CalTableView This class implements the operations for\n+     * the java.util.Date of the file.\n+     */\n+    private class CalTableView extends TableView {\n+        //\n+        CalTableView(LoadedFile lddFile) {\n+            super(lddFile);\n+            setDefaultTableView( \"cal\" );\n+            colNames = genColNames();\n+            calcdValues = genCalcdValues();\n+        }\n+\n+        /*\n+         * genCalcdValues is required by the base class.\n+         */\n+        Object[][] genCalcdValues() {\n+            Object[][] retValues = null;\n+            /*\n+             * Create an array of Objects that will contain\n+             * other arrays of Objects. (This is the 'column'\n+             * array).\n+             */\n+            ArrayList fileStrings = lddFile.getFileStrings();\n+            ArrayList dtObjects = lddFile.getDtObjects();\n+            int numRows = fileStrings.size();\n+            retValues = new Object[numRows][];\n+            int numCols = colNames.length;\n+            // System.err.println(\"NumCols : \" + numCols);\n+            /*\n+             * Prime the array of arrays of Objects, allocating a new\n+             * secondary array for each of the primary array's\n+             * elements.\n+             */\n+            for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {\n+                retValues[nextStrNum] = new Object[numCols]; // get the 'col' array\n+                //****\n+                //* This needs to be sync'd with the colNames array.\n+                //****\n+                // Current row, 1st column\n+                int column = 0;\n+                String fileString = (String)fileStrings.get(nextStrNum);\n+                retValues[nextStrNum][column++] = fileString;\n+                // Current row, 2nd column\n+                DateTime adt = (DateTime)dtObjects.get(nextStrNum);\n+                String adtStr = adt.toString();\n+                retValues[nextStrNum][column++] = adtStr;\n+                // Current row, other columns.\n+                // Order here must match that specified in the colNames\n+                // array.\n+                long lVal = adt.getMillis();\n+                GregorianCalendar cal = new GregorianCalendar();\n+                cal.setTime( new Date( lVal ) );\n+                cal.setMinimalDaysInFirstWeek(4);\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.MILLISECOND ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.SECOND ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.MINUTE ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.HOUR_OF_DAY ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.DAY_OF_WEEK ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.DAY_OF_MONTH ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.DAY_OF_YEAR ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.WEEK_OF_YEAR ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.MONTH ) );\n+                retValues[nextStrNum][column++]  = new Integer( cal.get(\n+                    Calendar.YEAR ) );\n+                //\n+            } // the for\n+            if ( debugf ) dumpObjs( retValues, System.err );\n+            return retValues;\n+        } // end of genTBValues\n+\n+        /*\n+         * genColNames is required by the base class.\n+         */\n+        Object[] genColNames() {\n+            Object[] retVal = {\n+                \"FileString\",   // 0\n+                \"toString()\",   // 1\n+                \"Millis\",       // 2\n+                \"Sec\",          // 3\n+                \"Min\",          // 4\n+                \"HrOfDay\",      // 5\n+                \"DayOfWeek\",    // 6\n+                \"DayOfMon\",     // 7\n+                \"DayOfYr\",      // 8\n+                \"WkofYr\",       // 9\n+                \"MonOfYr\",      // 10\n+                \"Year\"          // 11\n+            };\n+            return retVal;\n+        }\n+\n+        /*\n+         * getViewTitle\n+         */\n+        String getViewTitle() {\n+            return \"java.util.Calendar.get(int)\"\n+                + \" : \"\n+                + TimeZone.getDefault().getDisplayName()\n+                + \" : \"\n+                + \" Record Count \"\n+                + currFile.getLoadedFileSize();\n+        }\n+        /*\n+         * setViewColumnLengths\n+         */\n+        void setViewColumnsWidth(JTable jt) {\n+            /*\n+             * Resize column 0, 1\n+             */\n+            TableColumnModel colmodel = jt.getColumnModel();\n+            TableColumn col0 = colmodel.getColumn(0);\n+            col0.setPreferredWidth(175);\n+            TableColumn col1 = colmodel.getColumn(1);\n+            col1.setPreferredWidth(175);\n+            return;\n+        }\n+\n+    } // end of class CalTableView\n+\n+    /*\n+     * OpenAction\n+     */\n+    private class OpenAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public OpenAction() {\n+            super(\"Open\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            int result = chooser.showOpenDialog( DateTimeBrowser.this );\n+            String canPath = null;\n+            if ( result == JFileChooser.APPROVE_OPTION ) {\n+                File chosenFile = chooser.getSelectedFile();\n+                try\n+                {\n+                    canPath = chosenFile.getCanonicalPath();\n+                }\n+                catch(IOException ioe)\n+                {\n+                    System.err.println( \"I/O Error on file: \"\n+                        + chosenFile );\n+                    // Ignore it for now.\n+                }\n+                enableAllViews();\n+                currFile = new LoadedFile( canPath );\n+                TableView tView = getDefaultTableView();\n+                resetDefaults( tView );\n+            } // end of if a file actually chosen.\n+        } // end of actionPerformed\n+    } // end of class OpenAction\n+\n+    /*\n+     * ExitAction\n+     */\n+    private class ExitAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public ExitAction() {\n+            super(\"Exit\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            DateTimeBrowser.this.setVisible( false );\n+            DateTimeBrowser.this.dispose();\n+            System.exit(0);\n+        } // end of actionPerformed\n+    } // end of class OpenAction\n+\n+    /*\n+     * GetterAction\n+     */\n+    private class GetterAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public GetterAction() {\n+            super(\"Getter\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            TableView tView = new GetterTableView( currFile );\n+            resetDefaults( tView );\n+            enableAllViews();\n+            jmiGetter.setEnabled( false );\n+        } // end of actionPerformed\n+    } // end of class OpenAction\n+\n+    /*\n+     * HexAction\n+     */\n+    private class HexAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public HexAction() {\n+            super(\"Hex\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            TableView tView = new HexTableView( currFile );\n+            resetDefaults( tView );\n+            enableAllViews();\n+            jmiHex.setEnabled( false );\n+        } // end of actionPerformed\n+    } // end of class OpenAction\n+\n+    /*\n+     * DateAction\n+     */\n+    private class DateAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public DateAction() {\n+            super(\"Date\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            TableView tView = new DateTableView( currFile );\n+            resetDefaults( tView );\n+            enableAllViews();\n+            jmiDate.setEnabled( false );\n+        } // end of actionPerformed\n+    } // end of class DateAction\n+\n+    /*\n+     * CalAction\n+     */\n+    private class CalAction extends AbstractAction {\n+        /*\n+         * Constructor\n+         */\n+        public CalAction() {\n+            super(\"Calendar\");\n+        } // end of ctor\n+\n+        /*\n+         * actionPerformed\n+         */\n+        public void actionPerformed(ActionEvent e) {\n+            TableView tView = new CalTableView( currFile );\n+            resetDefaults( tView );\n+            enableAllViews();\n+            jmiCal.setEnabled( false );\n+        } // end of actionPerformed\n+    } // end of class CalAction\n+\n+} // class DateTimeBrowser\n--- /dev/null\n+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.example.time;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * DateTimePerformance provides various comparisons between the Java supplied\n+ * Date classes and the Joda ones.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class DateTimePerformance {\n+    \n+    private static class Result {\n+        String object = null;\n+        String name = null;\n+        long time = 0;\n+        long avg = 0;\n+        int runs = 0;\n+    }\n+    \n+    private static int AVERAGE = 1;\n+    private static int COUNT_VERY_FAST = 5000000;\n+    private static int COUNT_FAST = 200000;\n+    private static int COUNT_SLOW = 50000;\n+    \n+    private Map results = new HashMap();\n+    private List resultList = new ArrayList();\n+    \n+    private Result result = null;\n+    private long start = 0;\n+    private long end = 0;\n+    \n+    /**\n+     * Constructor\n+     */\n+    public static void main(String[] args) {\n+        try {\n+            new DateTimePerformance();\n+            \n+        } catch (Throwable th) {\n+            th.printStackTrace();\n+        }\n+    }\n+    \n+    /**\n+     * Constructor\n+     */\n+    public DateTimePerformance() throws Exception {\n+        checkJodaConstructor1();\n+        checkGCalConstructor1();\n+        checkDateConstructor1();\n+        \n+        checkJodaConstructor2();\n+        checkGCalConstructor2();\n+        checkDateConstructor2();\n+        \n+        checkJodaConstructor3();\n+        checkGCalConstructor3();\n+        checkDateConstructor3();\n+        \n+        checkJodaGetYear();\n+        checkGCalGetYear();\n+        checkDateGetYear();\n+        \n+//        checkJodaGetMonth();\n+//        checkGCalGetMonth();\n+//        checkDateGetMonth();\n+        \n+//        checkJodaGetDay();\n+//        checkGCalGetDay();\n+//        checkDateGetDay();\n+        \n+        checkJodaGetHour();\n+        checkGCalGetHour();\n+        checkDateGetHour();\n+        \n+        checkJodaSetYear();\n+        checkGCalSetYear();\n+        checkDateSetYear();\n+        \n+        checkJodaSetGetYear();\n+        checkGCalSetGetYear();\n+        checkDateSetGetYear();\n+        \n+        checkJodaSetHour();\n+        checkGCalSetHour();\n+        checkDateSetHour();\n+        \n+        checkJodaSetGetHour();\n+        checkGCalSetGetHour();\n+        checkDateSetGetHour();\n+        \n+        System.out.println(\"\");\n+        long jodaTotal = 0;\n+        long gcalTotal = 0;\n+        long dateTotal = 0;\n+        for (Iterator it = resultList.iterator(); it.hasNext();) {\n+            Result res = (Result) it.next();\n+            System.out.println(res.object + \".\" + res.name + \": \" + res.avg + \"ns\");\n+            if (res.object.equals(\"Joda\")) {\n+                jodaTotal += res.avg;\n+            } else if (res.object.equals(\"GCal\")) {\n+                gcalTotal += res.avg;\n+            } else if (res.object.equals(\"Date\")) {\n+                dateTotal += res.avg;\n+                System.out.println(\"\");\n+            }\n+        }\n+        System.out.println(\"Joda: \" + jodaTotal);\n+        System.out.println(\"GCal: \" + gcalTotal);\n+        System.out.println(\"Date: \" + dateTotal);\n+    }\n+\n+    // Constructor using currentTimeMillis()\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaConstructor1() {\n+        int COUNT = COUNT_SLOW;\n+        DateTime dt = new DateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"new\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new DateTime(GJChronology.getInstance());\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalConstructor1() {\n+        int COUNT = COUNT_SLOW;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"new\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new GregorianCalendar();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateConstructor1() {\n+        int COUNT = COUNT_SLOW;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"new\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new Date();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Constructor using long millis\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaConstructor2() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(12345L, GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"new(millis)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new DateTime(12345L, GJChronology.getInstance());\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalConstructor2() {\n+        int COUNT = COUNT_SLOW;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"new(millis)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new GregorianCalendar();\n+                dt.setTime(new Date(12345L));\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateConstructor2() {\n+        int COUNT = COUNT_VERY_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"new(millis)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new Date(12345L);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Constructor using year month and day\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaConstructor3() {\n+        int COUNT = COUNT_SLOW;\n+        DateTime dt = new DateTime(12345L, GJChronology.getInstance());\n+        MutableDateTime mdt = new MutableDateTime(ISOChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"new(YMD)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                mdt = new MutableDateTime(ISOChronology.getInstance());\n+                mdt.setDate(1972, 10, 1);\n+                dt = mdt.toDateTime();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalConstructor3() {\n+        int COUNT = COUNT_SLOW;\n+        GregorianCalendar dt = new GregorianCalendar(1972, 10, 1);\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"new(YMD)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new GregorianCalendar(1972, 10, 1);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateConstructor3() {\n+        int COUNT = COUNT_SLOW;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"new(YMD)\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt = new Date(1972, 10, 1);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Get year\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaGetYear() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"getYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getYear();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalGetYear() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"getYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.get(GregorianCalendar.YEAR);\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateGetYear() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"getYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getYear();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Get month\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaGetMonth() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"getMonth\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getMonthOfYear();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalGetMonth() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"getMonth\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.get(GregorianCalendar.MONTH);\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateGetMonth() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"getMonth\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getMonth();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Get day\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaGetDay() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"getDay\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getDayOfMonth();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalGetDay() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"getDay\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.get(GregorianCalendar.DAY_OF_MONTH);\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateGetDay() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"getDay\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getDate();\n+                if (val == 0) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Get hour\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        DateTime dt = new DateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"getHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getHourOfDay();\n+                if (val == -1) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"getHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.get(GregorianCalendar.HOUR_OF_DAY);\n+                if (val == -1) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateGetHour() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"getHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                int val = dt.getHours();\n+                if (val == -1) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Set year\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaSetYear() {\n+        int COUNT = COUNT_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"setYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalSetYear() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"setYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.set(GregorianCalendar.YEAR, 1972);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateSetYear() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"setYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Set then get year\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaSetGetYear() {\n+        int COUNT = COUNT_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"setGetYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                int val = dt.getYear();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalSetGetYear() {\n+        int COUNT = COUNT_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"setGetYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.set(GregorianCalendar.YEAR, 1972);\n+                int val = dt.get(GregorianCalendar.YEAR);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateSetGetYear() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"setGetYear\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setYear(1972);\n+                int val = dt.getYear();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Set hour\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaSetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"setHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHourOfDay(13);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalSetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"setHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.set(GregorianCalendar.HOUR_OF_DAY, 13);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateSetHour() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"setHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHours(13);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    // Set hour\n+    //------------------------------------------------------------------------\n+    \n+    private void checkJodaSetGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        // Is it fair to use only MutableDateTime here? You decide.\n+        MutableDateTime dt = new MutableDateTime(GJChronology.getInstance());\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Joda\", \"setGetHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHourOfDay(13);\n+                int val = dt.getHourOfDay();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkGCalSetGetHour() {\n+        int COUNT = COUNT_VERY_FAST;\n+        GregorianCalendar dt = new GregorianCalendar();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"GCal\", \"setGetHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.set(GregorianCalendar.HOUR_OF_DAY, 13);\n+                int val = dt.get(GregorianCalendar.HOUR_OF_DAY);\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    private void checkDateSetGetHour() {\n+        int COUNT = COUNT_FAST;\n+        Date dt = new Date();\n+        for (int i = 0; i < AVERAGE; i++) {\n+            start(\"Date\", \"setGetHour\");\n+            for (int j = 0; j < COUNT; j++) {\n+                dt.setHours(13);\n+                int val = dt.getHours();\n+                if (dt == null) {System.out.println(\"Anti optimise\");}\n+            }\n+            end(COUNT);\n+        }\n+    }\n+\n+    //------------------------------------------------------------------------\n+    \n+    /**\n+     * Start the stopwatch.\n+     */\n+    private void start(String str1, String str2) {\n+        result = (Result) results.get(str1 + str2);\n+        if (result == null) {\n+            result = new Result();\n+            result.object = str1;\n+            result.name = str2;\n+            results.put(str1 + str2, result);\n+            resultList.add(result);\n+        }\n+        start = System.currentTimeMillis();\n+    }\n+   \n+    /**\n+     * End the stopwatch and print the result.\n+     */\n+    private void end(int count) {\n+        end = System.currentTimeMillis();\n+        long time = (end - start);\n+        result.time = result.time + time;\n+        result.runs = result.runs + count;\n+        result.avg = (result.time * 1000000) / result.runs;\n+        System.out.print(\".\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+import org.joda.time.chrono.buddhist.BuddhistChronology;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractDateTime provides the common behaviour for immutable datetime\n+ * classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractDateTime extends AbstractInstant\n+        implements ReadableDateTime {\n+\n+    // The following package-private static methods are used in the\n+    // constructors for DateTime, DateOnly, TimeOnly, and MutableDateTime.\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param chrono  the chronology to use, must not be null\n+     * @return the passed in Chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    static Chronology selectChronology(Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology. If the\n+     * instant's chronology is null, ISOChronology in the default time zone is\n+     * returned.\n+     * \n+     * @param instant  the instant to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    static Chronology selectChronology(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n+        }\n+        Chronology chrono = instant.getChronology();\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology. If the\n+     * instant's chronology is null, ISOChronology in the given time zone is\n+     * returned.\n+     * \n+     * @param instant  the instant to use, must not be null\n+     * @param zone  the time zone to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the instant or zone is null\n+     */\n+    static Chronology selectChronology(ReadableInstant instant, DateTimeZone zone) {\n+        Chronology chrono = selectChronology(instant);\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (chrono.getDateTimeZone() != zone) {\n+            chrono = chrono.withDateTimeZone(zone);\n+            if (chrono == null) {\n+                chrono = ISOChronology.getInstance(zone);\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     *\n+     * @param instant  the instant to use, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @return the passed in chronology\n+     * @throws IllegalArgumentException if the instant or chronology is null\n+     */\n+    static Chronology selectChronology(ReadableInstant instant, Chronology chrono) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n+        }\n+        return selectChronology(chrono);\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology. If the\n+     * instant's chronology is null, ISOChronology in UTC is returned.\n+     *\n+     * <p>Note: This method does not guarantee returning a UTC chronology\n+     * \n+     * @param instant  the instant to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    static Chronology selectChronologyUTC(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n+        }\n+        Chronology chrono = instant.getChronology();\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param date  the date to be validated, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    static Chronology selectChronology(Date date) {\n+        return selectChronology(date, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param date  the date to be validated, must not be null\n+     * @param zone  the zone to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the date or zone is null\n+     */\n+    static Chronology selectChronology(Date date, DateTimeZone zone) {\n+        return selectChronology(date, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param date  the date to be validated, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    static Chronology selectChronology(Date date, Chronology chrono) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The Date must not be null\");\n+        }\n+        return selectChronology(chrono);\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology. The method\n+     * is aware of GregorianCalendar and BuddhistCalendar and maps them\n+     * accordingly. Other calendars map to ISO.\n+     * \n+     * @param calendar  the calendar to be used, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    static Chronology selectChronology(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The Calendar must not be null\");\n+        }\n+        DateTimeZone zone = null;\n+        try {\n+            zone = DateTimeZone.getInstance(calendar.getTimeZone());\n+        } catch (IllegalArgumentException ex) {\n+            return ISOChronology.getInstance();\n+        }\n+        return selectChronology(calendar, zone);\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology. The method\n+     * is aware of GregorianCalendar and BuddhistCalendar and maps them\n+     * accordingly. Other calendars map to ISO.\n+     * \n+     * @param calendar  the calendar to be used, must not be null\n+     * @param zone  the time zone to use\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    static Chronology selectChronology(Calendar calendar, DateTimeZone zone) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The Calendar must not be null\");\n+        }\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (calendar instanceof GregorianCalendar) {\n+            GregorianCalendar gc = (GregorianCalendar) calendar;\n+            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);\n+        } else if (calendar.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n+            return BuddhistChronology.getInstance(zone);\n+        } else {\n+            return ISOChronology.getInstance(zone);\n+        }\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param calendar  the calendar to be used, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    static Chronology selectChronology(Calendar calendar, Chronology chrono) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The Calendar must not be null\");\n+        }\n+        return selectChronology(chrono);\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param string  the string to parse, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the string is null\n+     */\n+    static Chronology selectChronology(String str) {\n+        return selectChronology(str, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param string  the string to parse, must not be null\n+     * @param zone  the zone to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the string or zone is null\n+     */\n+    static Chronology selectChronology(String str, DateTimeZone zone) {\n+        return selectChronology(str, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Validates the parameters and returns a suitable chronology.\n+     * \n+     * @param str  the string to parse, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @return a suitable Chronology\n+     * @throws IllegalArgumentException if the string or chronology is null\n+     */\n+    static Chronology selectChronology(String str, Chronology chrono) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"The String must not be null\");\n+        }\n+        return selectChronology(chrono);\n+    }\n+\n+    public AbstractDateTime() {\n+        super();\n+    }\n+\n+    // Date field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public final int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * \n+     * @return the day of month\n+     */\n+    public final int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public final int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public final int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public final int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public final int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public final int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public final int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public final int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    // Time field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public final int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public final int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public final int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public final int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public final int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public final int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public final int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @return a DateTime using the same millis\n+     */\n+    public final DateTime toDateTime() {\n+        if (this instanceof DateTime) {\n+            return (DateTime)this;\n+        }\n+        return new DateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return a DateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    public final DateTime toDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (this instanceof DateTime) {\n+            DateTime dt = (DateTime)this;\n+            if (dt.getDateTimeZone() == zone) {\n+                return dt;\n+            }\n+        }\n+        return new DateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a DateTime using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public final DateTime toDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (this instanceof DateTime) {\n+            DateTime dt = (DateTime)this;\n+            if (dt.getChronology() == chronology) {\n+                return dt;\n+            }\n+        }\n+        return new DateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO DateTime.\n+     * \n+     * @return an ISO DateTime using the same millis\n+     */\n+    public final DateTime toISODateTime() {\n+        if (this instanceof DateTime) {\n+            DateTime dt = (DateTime)this;\n+            if (dt.getChronology() instanceof ISOChronology) {\n+                // Verify that the time zone is trusted.\n+                DateTimeZone tz = dt.getDateTimeZone();\n+                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());\n+                if (tz == trusted) {\n+                    return dt;\n+                }\n+                return new DateTime(this, trusted);\n+            }\n+        }\n+        return new DateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO DateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return an ISO DateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    public final DateTime toISODateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (this instanceof DateTime) {\n+            DateTime dt = (DateTime)this;\n+            if (dt.getChronology() instanceof ISOChronology) {\n+                if (dt.getDateTimeZone() == zone) {\n+                    return dt;\n+                }\n+            }\n+        }\n+        return new DateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @return a MutableDateTime using the same millis\n+     */\n+    public final MutableDateTime toMutableDateTime() {\n+        if (this instanceof MutableDateTime) {\n+            return (MutableDateTime)this;\n+        }\n+        return new MutableDateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return a MutableDateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    public final MutableDateTime toMutableDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (this instanceof MutableDateTime) {\n+            MutableDateTime mdt = (MutableDateTime)this;\n+            if (mdt.getDateTimeZone() == zone) {\n+                return mdt;\n+            }\n+        }\n+        return new MutableDateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a MutableDateTime using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public final MutableDateTime toMutableDateTime(Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (this instanceof MutableDateTime) {\n+            MutableDateTime mdt = (MutableDateTime)this;\n+            if (mdt.getChronology() == chronology) {\n+                return mdt;\n+            }\n+        }\n+        return new MutableDateTime(this, chronology);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO MutableDateTime.\n+     * \n+     * @return an ISO MutableDateTime using the same millis\n+     */\n+    public final MutableDateTime toISOMutableDateTime() {\n+        if (this instanceof DateTime) {\n+            MutableDateTime mdt = (MutableDateTime)this;\n+            if (mdt.getChronology() instanceof ISOChronology) {\n+                // Verify that the time zone is trusted.\n+                DateTimeZone tz = mdt.getDateTimeZone();\n+                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());\n+                if (tz == trusted) {\n+                    return mdt;\n+                }\n+                return new MutableDateTime(this, trusted);\n+            }\n+        }\n+        return new MutableDateTime(this);\n+    }\n+\n+    /**\n+     * Get this object as a trusted ISO MutableDateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return an ISO MutableDateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    public final MutableDateTime toISOMutableDateTime(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (this instanceof MutableDateTime) {\n+            MutableDateTime mdt = (MutableDateTime)this;\n+            if (mdt.getChronology() instanceof ISOChronology) {\n+                if (mdt.getDateTimeZone() == zone) {\n+                    return mdt;\n+                }\n+            }\n+        }\n+        return new MutableDateTime(this, zone);\n+    }\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @return a DateOnly using the same millis\n+     */\n+    /*\n+    public final DateOnly toDateOnly() {\n+        if (this instanceof DateOnly) {\n+            return (DateOnly)this;\n+        }\n+        return new DateOnly(this);\n+    }\n+    /*\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a DateOnly using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    /*\n+    public final DateOnly toDateOnly(Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        chronology = chronology.withUTC();\n+        if (this instanceof DateOnly) {\n+            DateOnly d = (DateOnly)this;\n+            if (d.getChronology() == chronology) {\n+                return d;\n+            }\n+        }\n+        return new DateOnly(this, chronology);\n+    }\n+    */\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @return a TimeOnly using the same millis\n+     */\n+    /*\n+    public final TimeOnly toTimeOnly() {\n+        if (this instanceof TimeOnly) {\n+            return (TimeOnly)this;\n+        }\n+        return new TimeOnly(this);\n+    }\n+    */\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a TimeOnly using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    /*\n+    public final TimeOnly toTimeOnly(Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        chronology = chronology.withUTC();\n+        if (this instanceof TimeOnly) {\n+            TimeOnly t = (TimeOnly)this;\n+            if (t.getChronology() == chronology) {\n+                return t;\n+            }\n+        }\n+        return new TimeOnly(this, chronology);\n+    }\n+    */\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification\n+     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     */\n+    public String toString(String pattern) throws IllegalArgumentException {\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return DateTimeFormat.getInstance(chrono).forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification\n+     * @param locale  the Locale to use, must not be null\n+     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     * @throws IllegalArgumentException if the locale is null\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (locale == null) {\n+            throw new IllegalArgumentException(\"The Locale must not be null\");\n+        }\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return DateTimeFormat.getInstance(chrono, locale).forPattern(pattern).print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+/**\n+ * AbstractInstant provides the common behaviour for immutable time classes.\n+ * <p>\n+ * This class has no concept of a chronology, all methods work on the\n+ * millisecond instant.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInstant} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractInstant\n+        implements ReadableInstant, Serializable {\n+\n+    /**\n+     * Constructor.\n+     */\n+    public AbstractInstant() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the time zone of the datetime from the chronology.\n+     * \n+     * @return the DateTimeZone that the datetime is using\n+     */\n+    public final DateTimeZone getDateTimeZone() {\n+        Chronology chrono = getChronology();\n+        return chrono != null ? chrono.getDateTimeZone() : null;\n+    }\n+\n+    /**\n+     * Creates a new instance of this class.\n+     * <p>\n+     * The returned object will be a new instance of the implementation.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param chrono  the new chronology\n+     * @return a new instance of this class\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    protected abstract ReadableInstant create(long millis, Chronology chrono);\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of the specified field.\n+     * <p>\n+     * This could be used to get a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * Instant dt = new Instant();\n+     * int gjYear = dt.get(ISOChronology.getInstance().year());\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField subclass to use\n+     * @return the value\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public final int get(DateTimeField field) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The DateTimeField must not be null\");\n+        }\n+        return field.get(getMillis());\n+    }\n+\n+    // Updates\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of <code>DateTime</code>.\n+     * Only the millis will change, the chronology and time zone are kept.\n+     * If the millis is the same, <code>this</code> will be returned.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public final ReadableInstant toCopy(long newMillis) {\n+        return create(newMillis, getChronology());\n+    }\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of <code>DateTime</code>.\n+     * Only the chronology will change, the millis are kept.\n+     * If the chronology is the same, <code>this</code> will be returned.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public final ReadableInstant toCopy(Chronology newChronology) {\n+        return create(getMillis(), newChronology);\n+    }\n+    \n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an Instant.\n+     * \n+     * @return an Instant using the same millis\n+     */\n+    public final Instant toInstant() {\n+        if (this instanceof Instant) {\n+            return (Instant) this;\n+        }\n+        return new Instant(this);\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Date</code>.\n+     * \n+     * @return a Date initialised with this datetime\n+     */\n+    public final Date toDate() {\n+        return new Date(getMillis());\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Calendar</code>.\n+     * The locale is passed in, enabling Calendar to select the correct\n+     * localized subclass.\n+     * \n+     * @param locale  the locale to get the Calendar for\n+     * @return a localized Calendar initialised with this datetime\n+     * @throws IllegalArgumentException if the locale is null\n+     */\n+    public final Calendar toCalendar(Locale locale) {\n+        if (locale == null) {\n+            throw new IllegalArgumentException(\"The Locale must not be null\");\n+        }\n+        Calendar cal = Calendar.getInstance(locale);\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.GregorianCalendar</code>.\n+     * \n+     * @return a GregorianCalendar initialised with this datetime\n+     */\n+    public final GregorianCalendar toGregorianCalendar() {\n+        GregorianCalendar cal = new GregorianCalendar();\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant and the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     * <p>\n+     * See {@link #isEqual(ReadableInstant)} for an equals method that\n+     * ignores the Chronology.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    public final boolean equals(Object readableInstant) {\n+        if (readableInstant instanceof ReadableInstant) {\n+            ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n+            if (getMillis() == otherInstant.getMillis()) {\n+                Chronology chrono = getChronology();\n+                if (chrono == otherInstant.getChronology()) {\n+                    return true;\n+                }\n+                if (chrono != null && chrono.equals(otherInstant.getChronology())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the instant that is compatable with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public final int hashCode() {\n+        // following rules in [Bloch02]\n+        int result = 317;\n+        result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));\n+        result = 59 * result + (getChronology() == null ? 0 : getChronology().hashCode());\n+        return result;\n+    }\n+\n+    /**\n+     * Compares this object with the specified object for ascending\n+     * millisecond instant order. This ordering is inconsistent with\n+     * equals, as it ignores the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return -1 if this is less, 0 if equal or +1 if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    public final int compareTo(Object readableInstant) {\n+        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n+        long otherMillis = otherInstant.getMillis();\n+        long thisMillis = getMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Is the millisecond value after the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is after the instant passed in\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public final boolean isAfter(ReadableInstant readableInstant) {\n+        if (readableInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return (getMillis() > readableInstant.getMillis());\n+    }\n+\n+    /**\n+     * Is the millisecond value before the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is before the instant passed in\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public final boolean isBefore(ReadableInstant readableInstant) {\n+        if (readableInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return (getMillis() < readableInstant.getMillis());\n+    }\n+\n+    /**\n+     * Is the millisecond value equal to the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is equal to the instant passed in\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public final boolean isEqual(ReadableInstant readableInstant) {\n+        if (readableInstant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return (getMillis() == readableInstant.getMillis());\n+    }\n+\n+    // Output    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public abstract String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Chronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Chronology provides access to the individual date time fields for\n+ * a chronological calendar system.\n+ * <p>\n+ * Chronology subclasses <em>must</em> be immutable.\n+ * <p>\n+ * Various chronologies are supported by subclasses including ISO and \n+ * GregorianJulian. \n+ * <p>\n+ * This class does not strongly define each field. Subclasses may interpret\n+ * the fields differently.\n+ * \n+ * @see org.joda.time.chrono.iso.ISOChronology\n+ * @see org.joda.time.chrono.gj.GJChronology\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class Chronology implements Serializable {\n+    \n+    /**\n+     * Restricted constructor\n+     */\n+    protected Chronology() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone that this Chronology operates in, or null if\n+     * unspecified.\n+     *\n+     * @return DateTimeZone null if unspecified\n+     */\n+    public abstract DateTimeZone getDateTimeZone();\n+\n+    /**\n+     * Returns an instance of this Chronology that operates in the UTC time\n+     * zone. Chronologies that do not operate in a time zone or are already\n+     * UTC must return themself.\n+     *\n+     * @return a version of this chronology that ignores time zones\n+     */\n+    public abstract Chronology withUTC();\n+    \n+    /**\n+     * Returns an instance of this Chronology that operates in any time zone.\n+     *\n+     * @return a version of this chronology with a specific time zone\n+     * @throws IllegalArgumentException if zone is null\n+     * @see org.joda.time.chrono.ZonedChronology\n+     */\n+    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Get the millis for a time only field. The default implementation simply\n+     * returns <code>dayOfYear().remainder(millis)</code>.\n+     * \n+     * @param millis  the millis to convert to time only\n+     * @return millis with the date part stripped\n+     */\n+    public long getTimeOnlyMillis(long millis) {\n+        return dayOfYear().remainder(millis);\n+    }\n+\n+    /**\n+     * Get the millis for a date only field. The default implementation simply\n+     * returns <code>dayOfYear().roundFloor(millis)</code>.\n+     * \n+     * @param millis  the millis to convert to date only\n+     * @return millis with the time part stripped\n+     */\n+    public long getDateOnlyMillis(long millis) {\n+        return dayOfYear().roundFloor(millis);\n+    }\n+\n+    // Millis\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField millisOfSecond() {\n+        throw new UnsupportedOperationException(\"millisOfSecond is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField millisOfDay() {\n+        throw new UnsupportedOperationException(\"millisOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Second\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField secondOfMinute() {\n+        throw new UnsupportedOperationException(\"secondOfMinute is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField secondOfDay() {\n+        throw new UnsupportedOperationException(\"secondOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Minute\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField minuteOfHour() {\n+        throw new UnsupportedOperationException(\"minuteOfHour is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField minuteOfDay() {\n+        throw new UnsupportedOperationException(\"minuteOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Hour\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField hourOfDay() {\n+        throw new UnsupportedOperationException(\"hourOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        throw new UnsupportedOperationException(\"clockhourOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        throw new UnsupportedOperationException(\"hourOfHalfday is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        throw new UnsupportedOperationException(\"clockhourOfHalfday is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        throw new UnsupportedOperationException(\"halfdayOfDay is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Day\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.\n+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField dayOfWeek() {\n+        throw new UnsupportedOperationException(\"dayOfWeek is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField dayOfMonth() {\n+        throw new UnsupportedOperationException(\"dayOfMonth is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField dayOfYear() {\n+        throw new UnsupportedOperationException(\"dayOfYear is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        throw new UnsupportedOperationException(\"weekOfWeekyear is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField weekyear() {\n+        throw new UnsupportedOperationException(\"weekyear is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Month\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the month of year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField monthOfYear() {\n+        throw new UnsupportedOperationException(\"monthOfYear is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField year() {\n+        throw new UnsupportedOperationException(\"year is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField yearOfEra() {\n+        throw new UnsupportedOperationException(\"yearOfEra is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField yearOfCentury() {\n+        throw new UnsupportedOperationException(\"yearOfCentury is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField centuryOfEra() {\n+        throw new UnsupportedOperationException(\"centuryOfEra is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException if unsupported\n+     */\n+    public DateTimeField era() {\n+        throw new UnsupportedOperationException(\"era is unsupported for \" + getClass().getName());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * DateTime is the basic implementation of a datetime class supporting\n+ * chronologies and time zones. It holds the time as milliseconds from the Java\n+ * epoch of 1970-01-01T00:00:00Z.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum value\n+ * <li>minimum value\n+ * </ul>\n+ *\n+ * <p>This class is immutable provided that the Chronology is immutable. All \n+ * Chronology classes supplied are immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Kandarp Shah\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTime extends AbstractDateTime implements ReadableDateTime {\n+    \n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private final long iMillis;\n+    /** The chronology to use */\n+    private final Chronology iChronology;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a DateTime to the current datetime, as reported by the system\n+     * clock. The chronology used is ISO, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     */\n+    public DateTime() {\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime to the current datetime, as reported by the system\n+     * clock. The chronology used is ISO, in the supplied time zone.\n+     *\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public DateTime(DateTimeZone zone) {\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime to the current datetime, as reported by the system\n+     * clock.\n+     *\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public DateTime(Chronology chronology) {\n+        iChronology = selectChronology(chronology);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the ISO chronology, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param millis  the milliseconds\n+     */\n+    public DateTime(long millis) {\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the ISO chronology, in the supplied time zone.\n+     *\n+     * @param millis  the milliseconds\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public DateTime(long millis, DateTimeZone zone) {\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the supplied chronology.\n+     *\n+     * @param millis  the milliseconds\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public DateTime(long millis, Chronology chronology) {\n+        iChronology = selectChronology(chronology);\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a ReadableInstant, using its chronology. If\n+     * its chronology null, then the chronology is set to ISO, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public DateTime(ReadableInstant instant) {\n+        iChronology = selectChronology(instant);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a ReadableInstant, using its chronology\n+     * against a different time zone. If its chronology is null, then the\n+     * chronology is set to ISO. If the selected chronology is not in the\n+     * supplied time zone, a new chronology is created that is.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the instant or zone is null\n+     */\n+    public DateTime(ReadableInstant instant, DateTimeZone zone) {\n+        iChronology = selectChronology(instant, zone);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a ReadableInstant, using the supplied\n+     * chronology.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the instant or chronology is null\n+     */\n+    public DateTime(ReadableInstant instant, Chronology chronology) {\n+        iChronology = selectChronology(instant, chronology);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Date, using the ISO chronology, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param date  the Date, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public DateTime(Date date) {\n+        iChronology = selectChronology(date);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Date, using the ISO chronology, in the\n+     * supplied time zone.\n+     *\n+     * @param date  the Date, must not be null\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the date or zone is null\n+     */\n+    public DateTime(Date date, DateTimeZone zone) {\n+        iChronology = selectChronology(date, zone);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Date, using the supplied chronology.\n+     *\n+     * @param date  the Date, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public DateTime(Date date, Chronology chronology) {\n+        iChronology = selectChronology(date, chronology);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Calendar, using its closest mapped\n+     * chronology and time zone.\n+     *\n+     * <p>When converting calendars to chronologies, the constructor is aware\n+     * of GregorianCalendar and BuddhistCalendar and maps them to the\n+     * equivalent chronology. Other calendars map to ISOChronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    public DateTime(Calendar calendar) {\n+        iChronology = selectChronology(calendar);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Calendar, using its closest mapped\n+     * chronology against a different time zone.\n+     *\n+     * <p>When converting calendars to chronologies, the constructor is aware\n+     * of GregorianCalendar and BuddhistCalendar and maps them to the\n+     * equivalent chronology. Other calendars map to ISOChronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the calendar or zone is null\n+     */\n+    public DateTime(Calendar calendar, DateTimeZone zone) {\n+        iChronology = selectChronology(calendar, zone);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from a Calendar, using the supplied chronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the calendar or chronology is null\n+     */\n+    public DateTime(Calendar calendar, Chronology chronology) {\n+        iChronology = selectChronology(calendar, chronology);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a DateTime from an ISO formatted String, using the ISO\n+     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @throws IllegalArgumentException if the string is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public DateTime(String str) throws ParseException {\n+        iChronology = selectChronology(str);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Constructs a DateTime from an ISO formatted String, using the ISO\n+     * chronology, in the supplied time zone.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @param zone the time zone, must not be null\n+     * @throws IllegalArgumentException if the string or zone is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public DateTime(String str, DateTimeZone zone) throws ParseException {\n+        iChronology = selectChronology(str, zone);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Constructs a DateTime from an ISO formatted String, using the supplied\n+     * chronology.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the string or chronology is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public DateTime(String str, Chronology chronology) throws ParseException {\n+        iChronology = selectChronology(str, chronology);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class.\n+     * <p>\n+     * The returned object will be a new instance of the implementation.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param chrono  the new chronology\n+     * @return a new instance of this class\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    protected ReadableInstant create(long millis, Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (millis == getMillis() && chrono == getChronology()) {\n+            return this;\n+        }\n+        return new DateTime(millis, chrono);\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public final Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    // Date properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week property.\n+     * <p>\n+     * The values for day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week property\n+     */\n+    public final DateTimeFieldProperty dayOfWeek() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     */\n+    public final DateTimeFieldProperty dayOfMonth() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public final DateTimeFieldProperty dayOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public final DateTimeFieldProperty weekOfWeekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public final DateTimeFieldProperty weekyear() {\n+        return new DateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public final DateTimeFieldProperty monthOfYear() {\n+        return new DateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public final DateTimeFieldProperty year() {\n+        return new DateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty yearOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty yearOfCentury() {\n+        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final DateTimeFieldProperty centuryOfEra() {\n+        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public final DateTimeFieldProperty era() {\n+        return new DateTimeFieldProperty(this, getChronology().era());\n+    }\n+\n+    // Time properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis of second property.\n+     * \n+     * @return the millis of second property\n+     */\n+    public final DateTimeFieldProperty millisOfSecond() {\n+        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());\n+    }\n+\n+    /**\n+     * Get the millis of day property.\n+     * \n+     * @return the millis of day property\n+     */\n+    public final DateTimeFieldProperty millisOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property.\n+     * \n+     * @return the second of minute property\n+     */\n+    public final DateTimeFieldProperty secondOfMinute() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the second of day property.\n+     * \n+     * @return the second of day property\n+     */\n+    public final DateTimeFieldProperty secondOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property.\n+     * \n+     * @return the minute of hour property\n+     */\n+    public final DateTimeFieldProperty minuteOfHour() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the minute of day property.\n+     * \n+     * @return the minute of day property\n+     */\n+    public final DateTimeFieldProperty minuteOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of day field property.\n+     * \n+     * @return the hour of day property\n+     */\n+    public final DateTimeFieldProperty hourOfDay() {\n+        return new DateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * DateTimeComparator is the standard implementation of the Comparator\n+ * interface for various Joda and Java objects. The following types\n+ * are supported for comparison:\n+ * <ul>\n+ * <li>ReadableInstant\n+ * <li>java.util.Date\n+ * <li>java.util.Calendar\n+ * <li>java.util.Long (milliseconds)\n+ * </ul>\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTimeComparator implements Comparator {\n+\n+    private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);\n+\n+    /**\n+     * Returns a DateTimeComparator the compares the entire date time value.\n+     */\n+    public static DateTimeComparator getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DateTimeComparator with a lower limit only. Fields of a\n+     * magnitude less than the lower limit are excluded from comparisons.\n+     *\n+     * @param lowerLimit inclusive lower limit for fields to be compared\n+     */\n+    public static DateTimeComparator getInstance(DateTimeField lowerLimit) {\n+        return getInstance(lowerLimit, null);\n+    }\n+\n+    /**\n+     * Returns a DateTimeComparator with a lower and upper limit. Fields of a\n+     * magnitude less than the lower limit are excluded from comparisons.\n+     * Fields of a magnitude greater than or equal to the upper limit are also\n+     * excluded from comparisons. Either limit may be specified as null, which\n+     * indicates an unbounded limit.\n+     *\n+     * @param lowerLimit optional, inclusive lower limit for fields to be compared\n+     * @param upperLimit optional, exclusive upper limit for fields to be compared\n+     */\n+    public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+        if (lowerLimit == null && upperLimit == null) {\n+            return INSTANCE;\n+        }\n+        return new DateTimeComparator(lowerLimit, upperLimit);\n+    }\n+\n+    /**\n+     * Returns a comparator that only considers date fields. Time of day is\n+     * ignored.\n+     */\n+    public static DateTimeComparator getDateOnlyInstance(Chronology chrono) {\n+        return getInstance(chrono.dayOfYear(), null);\n+    }\n+\n+    /**\n+     * Returns a comparator that only considers time fields. Date is ignored.\n+     */\n+    public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {\n+        return getInstance(null, chrono.dayOfYear());\n+    }\n+\n+    private final DateTimeField iLowerLimit;\n+    private final DateTimeField iUpperLimit;\n+\n+    private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+        iLowerLimit = lowerLimit;\n+        iUpperLimit = upperLimit;\n+    }\n+\n+    /**\n+     * Compare two objects against only the range of date time fields as\n+     * specified in the constructor.\n+     * \n+     * @param lhsObj The first object, logically on the left of a &lt;\n+     * comparison\n+     * @param rhsObj The second object, logically on the right of a &lt;\n+     * comparison\n+     * @return 0 if order does not matter, -1 if lhsObj &lt; rhsObj, 1\n+     * otherwise.\n+     * @throws IllegalArgumentException if either argument is null\n+     * @throws ClassCastException if either argument is one of the support\n+     * types\n+     */\n+    public int compare(Object lhsObj, Object rhsObj) {\n+        long lhs = getMillisFromObject(lhsObj);\n+        long rhs = getMillisFromObject(rhsObj);\n+\n+        if (iLowerLimit != null) {\n+            lhs = iLowerLimit.roundFloor(lhs);\n+            rhs = iLowerLimit.roundFloor(rhs);\n+        }\n+\n+        if (iUpperLimit != null) {\n+            lhs = iUpperLimit.remainder(lhs);\n+            rhs = iUpperLimit.remainder(rhs);\n+        }\n+\n+        if (lhs < rhs) {\n+            return -1;\n+        } else if (lhs > rhs) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /*\n+     * Developer's note: The 'equals' method specified by the interface is not\n+     * overridden here. It does not make sense to do so, since 'this' is a\n+     * DateTimeComparator, and 'that' would (presumably) be one of the\n+     * supported object types described elsewhere. The '==' logic provided by\n+     * java.lang.Object for a DateTimeComparator object suffices.\n+     */\n+\n+    /*\n+     * @param obj\n+     * @throws ClassCastException\n+     * @return millis since the epoch\n+     */\n+    private long getMillisFromObject(Object obj) {\n+        if (obj instanceof ReadableInstant) {\n+            return ((ReadableInstant)obj).getMillis();\n+        }\n+        if (obj instanceof java.util.Date) {\n+            return ((java.util.Date)obj).getTime();\n+        }\n+        if (obj instanceof java.util.Calendar) {\n+            return ((java.util.Calendar)obj).getTime().getTime();\n+        }\n+        if (obj instanceof Long) {\n+            return ((Long)obj).longValue();\n+        }\n+\n+        if (obj == null) {\n+            throw new IllegalArgumentException(\"Object to compare must not be null\");\n+        }\n+\n+        throw new ClassCastException\n+            (\"Invalid class for DateTimeComparator: \" + obj.getClass());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.*;\n+\n+/**\n+ * DateTimeConstants is a non-instantiable class of constants used in\n+ * the date time system. These are the ISO8601 constants, but should be\n+ * used by all chronologies.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class DateTimeConstants {\n+\n+    // These are ints not enumerations as they represent genuine int values\n+    /** Constant (1) representing January, the first month */\n+    public static final int JANUARY = 1;\n+\n+    /** Constant (2) representing February, the second month */\n+    public static final int FEBRUARY = 2;\n+\n+    /** Constant (3) representing March, the third month */\n+    public static final int MARCH = 3;\n+\n+    /** Constant (4) representing April, the fourth month */\n+    public static final int APRIL = 4;\n+\n+    /** Constant (5) representing May, the fifth month */\n+    public static final int MAY = 5;\n+\n+    /** Constant (6) representing June, the sixth month */\n+    public static final int JUNE = 6;\n+\n+    /** Constant (7) representing July, the seventh month */\n+    public static final int JULY = 7;\n+\n+    /** Constant (8) representing August, the eighth month */\n+    public static final int AUGUST = 8;\n+\n+    /** Constant (9) representing September, the nineth month */\n+    public static final int SEPTEMBER = 9;\n+\n+    /** Constant (10) representing October, the tenth month */\n+    public static final int OCTOBER = 10;\n+\n+    /** Constant (11) representing November, the eleventh month */\n+    public static final int NOVEMBER = 11;\n+\n+    /** Constant (12) representing December, the twelfth month */\n+    public static final int DECEMBER = 12;\n+\n+\n+    /**\n+     * Constant list of the number of days in the month. The index into\n+     * the list is the month constant as defined in ReadableDate, thus \n+     * MAX_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a \n+     * list rather than an array as it must be unmodifiable.\n+     */\n+    public static final List MAX_DAYS_PER_MONTH =\n+        Collections.unmodifiableList(\n+            Arrays.asList(\n+                new Integer[] {\n+                    null,\n+                    new Integer(31),\n+                    new Integer(29),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31)}));\n+    /**\n+     * Constant list of the number of days in the month. The index into\n+     * the list is the month constant as defined in ReadableDate, thus \n+     * MIN_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a \n+     * list rather than an array as it must be unmodifiable.\n+     */\n+    public static final List MIN_DAYS_PER_MONTH =\n+        Collections.unmodifiableList(\n+            Arrays.asList(\n+                new Integer[] {\n+                    null,\n+                    new Integer(31),\n+                    new Integer(28),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31),\n+                    new Integer(30),\n+                    new Integer(31)}));\n+\n+\n+    // These are ints not enumerations as they represent genuine int values\n+    /** Constant (1) representing Monday, the first day of the week (ISO) */\n+    public static final int MONDAY = 1;\n+\n+    /** Constant (2) representing Monday, the second day of the week (ISO) */\n+    public static final int TUESDAY = 2;\n+\n+    /** Constant (3) representing Monday, the third day of the week (ISO) */\n+    public static final int WEDNESDAY = 3;\n+\n+    /** Constant (4) representing Monday, the fourth day of the week (ISO) */\n+    public static final int THURSDAY = 4;\n+\n+    /** Constant (5) representing Monday, the fifth day of the week (ISO) */\n+    public static final int FRIDAY = 5;\n+\n+    /** Constant (6) representing Monday, the sixth day of the week (ISO) */\n+    public static final int SATURDAY = 6;\n+\n+    /** Constant (7) representing Monday, the seventh day of the week (ISO) */\n+    public static final int SUNDAY = 7;\n+\n+\n+    /** Constant (0) representing AM, the morning (from Calendar) */\n+    public static final int AM = 0;\n+\n+    /** Constant (1) representing PM, the afternoon (from Calendar) */\n+    public static final int PM = 1;\n+\n+\n+    /** Constant (0) representing BC, years before zero (from Calendar) */\n+    public static final int BC = 0;\n+    /** Alternative constant (0) representing BCE, Before Common Era (secular) */\n+    public static final int BCE = 0;\n+\n+    /** Constant (1) representing AD, years after zero (from Calendar) */\n+    public static final int AD = 1;\n+    /** Alternative constant (1) representing CE, Common Era (secular) */\n+    public static final int CE = 1;\n+\n+\n+    /** Milliseconds in one second (1000) */\n+    public static final int MILLIS_PER_SECOND = 1000;\n+\n+    /** Seconds in one minute (60) */\n+    public static final int SECONDS_PER_MINUTE = 60;\n+    public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;\n+\n+    /** Minutes in one hour (60) */\n+    public static final int MINUTES_PER_HOUR = 60;\n+    public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;\n+\n+    /** Hours in a typical day (24). Due to time zone offset changes, the\n+     * number of hours per day can vary. */\n+    public static final int HOURS_PER_DAY = 24;\n+    /** Minutes in a typical day. Due to time zone offset changes, the number\n+     * of minutes per day can vary. */\n+    public static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n+    /** Seconds in a typical day. Due to time zone offset changes, the number\n+     * of seconds per day can vary. */\n+    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n+    /** Milliseconds in a typical day. Due to time zone offset changes, the\n+     * number of milliseconds per day can vary. */\n+    public static final int MILLIS_PER_DAY = MILLIS_PER_HOUR * HOURS_PER_DAY;\n+\n+    /** Days in one week (7) */\n+    public static final int DAYS_PER_WEEK = 7;\n+    /** Hours in a typical week. Due to time zone offset changes, the number of\n+     * hours per week can vary. */\n+    public static final int HOURS_PER_WEEK = HOURS_PER_DAY * DAYS_PER_WEEK;\n+    /** Minutes in a typical week. Due to time zone offset changes, the number\n+     * of minutes per week can vary. */\n+    public static final int MINUTES_PER_WEEK = MINUTES_PER_DAY * DAYS_PER_WEEK;\n+    /** Seconds in a typical week. Due to time zone offset changes, the number\n+     * of seconds per week can vary. */\n+    public static final int SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;\n+    /** Milliseconds in a typical week. Due to time zone offset changes, the\n+     * number of milliseconds per week can vary. */\n+    public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected DateTimeConstants() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+/**\n+ * DateTimeField is an abstract class which allows the date and time\n+ * manipulation code to be field based. Each field within a datetime\n+ * can be accessed and manipulated using a dedicated subclass of this\n+ * one.\n+ * <p>\n+ * This design is extensible, so if you wish to extract a different \n+ * field from the milliseconds, you can do, simply by implementing\n+ * your own subclass.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DateTimeField implements Serializable {\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name a short descriptive name for the field, such as\n+     * millisOfSecond\n+     */\n+    protected DateTimeField(String name) {\n+        super();\n+        \n+        iName = name;\n+    }\n+    \n+    /**\n+     * Get the name of the field.\n+     * \n+     * @return field name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long millis);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(millis)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(long millis, Locale locale) {\n+        return Integer.toString(get(millis));\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * This implementation returns getAsText(millis, null).\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public final String getAsText(long millis) {\n+        return getAsText(millis, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  If the specified locale is null, the default locale is\n+     * used.\n+     * <p>\n+     * The default implementation returns getAsText(millis, locale).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumShortTextLength.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the short text value of the field\n+     */\n+    public String getAsShortText(long millis, Locale locale) {\n+        return getAsText(millis, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  This implementation returns getAsShortText(millis, null).\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the short text value of the field\n+     */\n+    public final String getAsShortText(long millis) {\n+        return getAsShortText(millis, null);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public abstract long add(long millis, int value);\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public abstract long add(long millis, long value);\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapped six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapped two months is 2001-03-31<br>\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long addWrapped(long millis, int value) {\n+        int current = get(millis);\n+        int wrapped = getWrappedValue\n+            (current, value, getMinimumValue(millis), getMaximumValue(millis));\n+        return set(millis, wrapped);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long millis = ...\n+     * int v = ...\n+     * long age = getDifference(add(millis, v), millis);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation performs a guess-and-check algorithm using\n+     * the getUnitMillis and add methods. Subclasses are encouraged to provide\n+     * a more efficient implementation.\n+     *\n+     * @param minuendMillis the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendMillis the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        if (minuendMillis < subtrahendMillis) {\n+            return -getDifference(subtrahendMillis, minuendMillis);\n+        }\n+\n+        long difference = (minuendMillis - subtrahendMillis) / getUnitMillis();\n+        if (add(subtrahendMillis, difference) < minuendMillis) {\n+            do {\n+                difference++;\n+            } while (add(subtrahendMillis, difference) <= minuendMillis);\n+            difference--;\n+        } else if (add(subtrahendMillis, difference) > minuendMillis) {\n+            do {\n+                difference--;\n+            } while (add(subtrahendMillis, difference) > minuendMillis);\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set. If the value is invalid, an\n+     * exception if thrown. Other fields are always unaffected.\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long millis, int value);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns set(millis,\n+     * Integer.parseInt(millis)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getAsText.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public long set(long millis, String text, Locale locale) {\n+        try {\n+            return set(millis, Integer.parseInt(text));\n+        } catch (NumberFormatException ex) {\n+            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n+        }\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. This implementation returns set(millis, text, null).\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public final long set(long millis, String text) {\n+        return set(millis, text, null);\n+    }\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns whether this field is 'leap' for the specified millis.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * <p>\n+     * This implementation returns false.\n+     * \n+     * @return true if the field is 'leap'\n+     */\n+    public boolean isLeap(long millis) {\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified millis.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * <p>\n+     * This implementation returns zero.\n+     */\n+    public int getLeapAmount(long millis) {\n+        return 0;\n+    }\n+\n+    /**\n+     * Returns the amount of milliseconds per unit value of this field. For\n+     * example, if this field represents \"hour of day\", then the unit is the\n+     * amount of milliseconds per one hour.\n+     * <p>\n+     * For fields with a variable unit size, this method returns a suitable\n+     * average value.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     */\n+    public abstract long getUnitMillis();\n+\n+    /**\n+     * Returns the range of this field, in milliseconds. For example, if this\n+     * field represents \"hour of day\", then the range is the amount of\n+     * milliseconds per one day.\n+     * <p>\n+     * For fields with a variable range, this method returns a suitable average\n+     * value. If the range is too large to fit in a long, Long.MAX_VALUE is\n+     * returned.\n+     *\n+     * @return the range of this field, in milliseconds\n+     */\n+    public abstract long getRangeMillis();\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(long millis) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(long millis) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum text value for this field. The default implementation\n+     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        int max = getMaximumValue();\n+        if (max >= 0) {\n+            if (max < 10) {\n+                return 1;\n+            } else if (max < 100) {\n+                return 2;\n+            } else if (max < 1000) {\n+                return 3;\n+            }\n+        }\n+        return Integer.toString(max).length();\n+    }\n+\n+    /**\n+     * Get the maximum short text value for this field. The default\n+     * implementation returns getMaximumTextLength().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getMaximumTextLength(locale);\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long millis);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     * <p>\n+     * The default implementation calls roundFloor, and if the millis is\n+     * modified as a result, adds one field unit. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundCeiling(long millis) {\n+        long newMillis = roundFloor(millis);\n+        if (newMillis != millis) {\n+            millis = add(newMillis, 1);\n+        }\n+        return millis;\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfFloor(long millis) {\n+        long floor = roundFloor(millis);\n+        long ceiling = roundCeiling(millis);\n+\n+        long diffFromFloor = millis - floor;\n+        long diffToCeiling = ceiling - millis;\n+\n+        if (diffFromFloor <= diffToCeiling) {\n+            // Closer to the floor, or halfway - round floor\n+            return floor;\n+        } else {\n+            return ceiling;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfCeiling(long millis) {\n+        long floor = roundFloor(millis);\n+        long ceiling = roundCeiling(millis);\n+\n+        long diffFromFloor = millis - floor;\n+        long diffToCeiling = ceiling - millis;\n+\n+        if (diffToCeiling <= diffFromFloor) {\n+            // Closer to the ceiling, or halfway - round ceiling\n+            return ceiling;\n+        } else {\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfEven(long millis) {\n+        long floor = roundFloor(millis);\n+        long ceiling = roundCeiling(millis);\n+\n+        long diffFromFloor = millis - floor;\n+        long diffToCeiling = ceiling - millis;\n+\n+        if (diffFromFloor < diffToCeiling) {\n+            // Closer to the floor - round floor\n+            return floor;\n+        } else if (diffToCeiling < diffFromFloor) {\n+            // Closer to the ceiling - round ceiling\n+            return ceiling;\n+        } else {\n+            // Round to the millis that makes this field even. If both values\n+            // make this field even (unlikely), favor the ceiling.\n+            if ((get(ceiling) & 1) == 0) {\n+                return ceiling;\n+            }\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Retains only the fractional units of this field. This field value and\n+     * all fields of higher magnitude are reset. In other words, calling\n+     * remainder retains the part of the instant that roundFloor dropped.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 1970-01-01T00:34:56.789.\n+     * <p>\n+     * The default implementation computes\n+     * <code>millis - roundFloor(millis)</code>. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param millis the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder milliseconds\n+     */\n+    public long remainder(long millis) {\n+        return millis - roundFloor(millis);\n+    }\n+\n+    // Implementation helper methods\n+    //------------------------------------------------------------------------\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalArgumentException if value is not in the specified bounds\n+     */\n+    protected void verifyValueBounds(int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalArgumentException(\n+                \"Value: \"\n+                    + value\n+                    + \" for \"\n+                    + iName\n+                    + \" must be in the range (\"\n+                    + lowerBound\n+                    + ','\n+                    + upperBound\n+                    + ')');\n+        }\n+    }\n+\n+    /**\n+     * Utility method used by addWrapped implementations to ensure the new\n+     * value lies within the field's legal value range.\n+     *\n+     * @param currentValue the current value of the data, which may lie outside\n+     * the wrapped value range\n+     * @param wrapValue  the value to add to current value before\n+     *  wrapping.  This may be negative.\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    protected final int getWrappedValue(int currentValue, int wrapValue,\n+                                        int minValue, int maxValue) {\n+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n+    }\n+\n+    /**\n+     * Utility method that ensures the given value lies within the field's\n+     * legal value range.\n+     * \n+     * @param value  the value to fit into the wrapped value range\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    protected final int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+    /**\n+     * If value can be safely cast to an int, then add(long, int) is called,\n+     * returning its result. Otherwise, an IllegalArgumentException is thrown.\n+     *\n+     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     */\n+    protected long addLong(long millis, long value) {\n+        int i_value = (int)value;\n+        if (i_value == value) {\n+            return add(millis, i_value);\n+        }\n+        throw new IllegalArgumentException\n+            (\"Magnitude of add amount is too large: \" + value);\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DateTimeField[\" + iName + ']';\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+import java.io.Serializable;\n+\n+/**\n+ * DateTimeFieldProperty binds a ReadableInstant to a DateTimeField.\n+ * <p>\n+ * DateTimeFieldProperty allows the date and time manipulation code to be \n+ * field based yet still easy to use.\n+ *\n+ * @see ReadableInstant\n+ * @see DateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTimeFieldProperty implements Serializable {\n+    \n+    /** The instant this property is working against */\n+    private final ReadableInstant iInstant;\n+    /** The field this property is working against */\n+    private final DateTimeField iField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param instant  the instant to set\n+     * @param field  the field to use\n+     */\n+    public DateTimeFieldProperty(ReadableInstant instant, DateTimeField field) {\n+        super();\n+        iInstant = instant;\n+        iField = field;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return iField.getName();\n+    }\n+\n+    /**\n+     * Gets the instant being used.\n+     * \n+     * @return the instant\n+     */\n+    public ReadableInstant getInstant() {\n+        return iInstant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a value from the instant.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     */\n+    public int get() {\n+        return iField.get(iInstant.getMillis());\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return iField.getAsText(iInstant.getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public final String getAsText() {\n+        return iField.getAsText(iInstant.getMillis(), null);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return iField.getAsShortText(iInstant.getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets a short text value from the instant.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public final String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant the subtrahend\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public long getDifference(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return iField.getDifference(iInstant.getMillis(), instant.getMillis());\n+    }\n+\n+    /**\n+     * Gets whether this field is leap.\n+     * \n+     * @return true if a leap field\n+     * @see DateTimeField#isLeap\n+     */\n+    public boolean isLeap() {\n+        return iField.isLeap(iInstant.getMillis());\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is leap.\n+     * \n+     * @return the amount by which the field is leap\n+     * @see DateTimeField#getLeapAmount\n+     */\n+    public int getLeapAmount() {\n+        return iField.getLeapAmount(iInstant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue(iInstant.getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue(iInstant.getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the amount of milliseconds per unit value of this field. For\n+     * example, if this field represents \"hour of day\", then the unit is the\n+     * amount of milliseconds per one hour.\n+     * <p>\n+     * For fields with a variable unit size, this method returns a suitable\n+     * average value.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     */\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    /**\n+     * Returns the range of this field, in milliseconds. For example, if this\n+     * field represents \"hour of day\", then the range is the amount of\n+     * milliseconds per one day.\n+     * <p>\n+     * For fields with a variable range, this method returns a suitable average\n+     * value. If the range is too large to fit in a long, Long.MAX_VALUE is\n+     * returned.\n+     *\n+     * @return the range of this field, in milliseconds\n+     */\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The {@link #get()} method is used to obtain the value to compare for\n+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method\n+     * is used for the specified instant.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return -1 if this is less, +1 if more and 0 if equal\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = iField.get(instant.getMillis());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"DateTimeFieldProperty[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.DateTimeFormatterBuilder;\n+import org.joda.time.tz.DefaultNameProvider;\n+import org.joda.time.tz.FixedDateTimeZone;\n+import org.joda.time.tz.NameProvider;\n+import org.joda.time.tz.Provider;\n+import org.joda.time.tz.ZoneInfoProvider;\n+\n+/**\n+ * DateTimeZone represents a time zone.\n+ * <p>\n+ * A time zone is a system of rules to convert time from one geographic \n+ * location to another. For example, Paris, France in one hour ahead of\n+ * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n+ * <p>\n+ * All time zone rules are expressed, for historical reasons, relative to\n+ * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n+ * Time (GMT).  This is similar, but not precisely identical, to Universal \n+ * Coordinated Time, or UTC. This library only uses the term UTC.\n+ * <p>\n+ * Using this system, Pacific Time, USA is expressed as UTC-08:00, or UTC-07:00\n+ * in the summer. The offset -08:00 indicates that Pacific Time is obtained \n+ * from UTC by adding -08:00, that is, by subtracting 8 hours.\n+ * <p>\n+ * The offset differs in the summer because of daylight saving time, or DST.\n+ * The folowing definitions of time are generally used:\n+ * <ul>\n+ * <li>UTC - The reference time.\n+ * <li>Standard Time - The local time without a daylight saving time offset.\n+ * For example, in Paris, standard time is UTC+01:00.\n+ * <li>Daylight Saving Time - The local time with a daylight saving time \n+ * offset. This offset is typically one hour, but not always. It is typically\n+ * used in most countries away from the equator.  In Paris, daylight saving \n+ * time is UTC+02:00.\n+ * <li>Wall Time - This is what a local clock on the wall reads. This will be\n+ * either Standard Time or Daylight Saving Time depending on the time of year\n+ * and whether the location uses Daylight Saving Time.\n+ * </ul>\n+ * <p>\n+ * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n+ * supports long format time zone ids. Thus EST and ECT are not accepted.\n+ * However, the factory that accepts a TimeZone will attempt to convert from\n+ * the old short id to a suitable long id.\n+ * <p>\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class DateTimeZone implements Serializable {\n+    \n+    /** The UTC time zone */\n+    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n+\n+    private static Provider cProvider;\n+    private static NameProvider cNameProvider;\n+    private static Set cAvailableIDs;\n+\n+    private static DateTimeZone cDefault;\n+\n+    private static DateTimeFormatter cOffsetFormatter;\n+\n+    /**\n+     * Cache of old zone IDs to new zone IDs\n+     */\n+    private static Map cZoneIdConversion;\n+\n+    static {\n+        Provider provider = null;\n+\n+        String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+        if (providerClass != null) {\n+            try {\n+                provider = (Provider)Class.forName(providerClass).newInstance();\n+            }\n+            catch (Exception e) {\n+                Thread t = Thread.currentThread();\n+                t.getThreadGroup().uncaughtException(t, e);\n+            }\n+        }\n+\n+        if (provider == null) {\n+            try {\n+                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+            } catch (Exception e) {\n+                Thread t = Thread.currentThread();\n+                t.getThreadGroup().uncaughtException(t, e);\n+            }\n+        }\n+\n+        if (provider == null) {\n+            provider = new UTCProvider();\n+        }\n+\n+        setProvider(provider);\n+\n+        NameProvider nameProvider = null;\n+\n+        providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+        if (providerClass != null) {\n+            try {\n+                nameProvider = (NameProvider)Class.forName(providerClass).newInstance();\n+            }\n+            catch (Exception e) {\n+                Thread t = Thread.currentThread();\n+                t.getThreadGroup().uncaughtException(t, e);\n+            }\n+        }\n+\n+        if (nameProvider == null) {\n+            nameProvider = new DefaultNameProvider();\n+        }\n+\n+        setNameProvider(nameProvider);\n+\n+        try {\n+            try {\n+                cDefault = getInstance(System.getProperty(\"user.timezone\"));\n+            } catch (RuntimeException e) {\n+            }\n+            cDefault = getInstance(java.util.TimeZone.getDefault());\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        if (cDefault == null) {\n+            cDefault = UTC;\n+        }\n+    }\n+\n+    /**\n+     * Gets the default time zone.\n+     * \n+     * @return the default datetime zone object\n+     */\n+    public static DateTimeZone getDefault() {\n+        return cDefault;\n+    }\n+\n+    /**\n+     * Sets the default time zone.\n+     * \n+     * @param zone  the default datetime zone object, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public static void setDefault(DateTimeZone zone) throws SecurityException {\n+        // TODO: Put in a security check.\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n+        }\n+        cDefault = zone;\n+    }\n+\n+    /**\n+     * Get the time zone by id.\n+     * <p>\n+     * The time zone id may be one of those returned by getAvailableIDs. Short\n+     * ids, as accepted by {@link java.util.TimeZone}, are not accepted. All\n+     * IDs must be specified in the long format. The exception is UTC, which is\n+     * an acceptable id.\n+     * <p>\n+     * Alternatively a locale independent, fixed offset, datetime zone can\n+     * be specified. The form <code>[+-]hh:mm</code> can be used.\n+     * \n+     * @param id  the ID of the datetime zone\n+     * @return the DateTimeZone object for the ID\n+     * @throws IllegalArgumentException if the ID is null or not recognised\n+     */\n+    public static DateTimeZone getInstance(String id) throws IllegalArgumentException {\n+        if (id == null) {\n+            throw new IllegalArgumentException(\"The datetime zone id must not be null\");\n+        }\n+        if (id.equals(\"UTC\")) {\n+            return DateTimeZone.UTC;\n+        }\n+        DateTimeZone zone = cProvider.getDateTimeZone(id);\n+        if (zone != null) {\n+            return zone;\n+        }\n+        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n+            try {\n+                int offset = -(int)offsetFormatter().parseMillis(id);\n+                // Canonicalize the id.\n+                id = offsetFormatter().print(0, UTC, offset);\n+                return new FixedDateTimeZone(id, null, offset, offset);\n+            } catch (ParseException e) {\n+                throw new IllegalArgumentException(e.getMessage());\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n+    }\n+\n+    /**\n+     * Get the time zone by Java TimeZone.\n+     * <p>\n+     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n+     * excluded IDs are the short three letter form (except UTC). This \n+     * method will attempt to convert between time zones created using the\n+     * short IDs and the full version.\n+     * \n+     * @param zone the zone to convert\n+     * @return the DateTimeZone object for the zone\n+     * @throws IllegalArgumentException if the zone is null or not recognised\n+     */\n+    public static DateTimeZone getInstance(java.util.TimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The TimeZone must not be null\");\n+        }\n+        final String id = zone.getID();\n+        if (id.equals(\"UTC\")) {\n+            return DateTimeZone.UTC;\n+        }\n+\n+        DateTimeZone dtz;\n+        // Convert from old alias before consulting provider since they may differ.\n+        String convId = getConvertedId(id);\n+        if (convId == null || (dtz = cProvider.getDateTimeZone(convId)) == null) {\n+            dtz = cProvider.getDateTimeZone(id);\n+        }\n+        if (dtz != null) {\n+            return dtz;\n+        }\n+\n+        // Support GMT+/-hh:mm formats\n+        if (convId == null) {\n+            convId = zone.getDisplayName();\n+            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n+                convId = convId.substring(3);\n+                try {\n+                    int offset = -(int)offsetFormatter().parseMillis(convId);\n+                    // Canonicalize the id.\n+                    convId = offsetFormatter().print(0, UTC, offset);\n+                    return new FixedDateTimeZone(convId, null, offset, offset);\n+                } catch (ParseException e) {\n+                    throw new IllegalArgumentException(e.getMessage());\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n+    }\n+\n+    /**\n+     * Gets the available IDs according to the given millisecond time\n+     * zone offset.\n+     * <p>\n+     * For example, \"America/Phoenix\" and \"America/Denver\"\n+     * both have GMT-07:00, but differ in daylight saving behavior.\n+     * \n+     * @param rawOffset  the given millisecond time zone GMT offset\n+     * @return an unmodifiable Set of String IDs\n+     */\n+    /*\n+    public static Set getAvailableIDs(int rawOffset) {\n+        String[] ids = TimeZone.getAvailableIDs(rawOffset);\n+        Set set = new HashSet();\n+        for (int i = 0; i < ids.length; i++) {\n+            if (cZones.containsKey(ids[i])) {\n+                set.add(ids[i]);\n+            }\n+        }\n+        return Collections.unmodifiableSet(set);\n+    }\n+    */\n+\n+    /**\n+     * Gets all the available IDs supported.\n+     * \n+     * @return an unmodifiable Set of String IDs\n+     */\n+    public static Set getAvailableIDs() {\n+        return cAvailableIDs;\n+    }\n+\n+    public static Provider getProvider() {\n+        return cProvider;\n+    }\n+\n+    public static void setProvider(Provider provider) throws SecurityException {\n+        // TODO: Put in a security check.\n+        if (provider == null) {\n+            throw new IllegalArgumentException(\"The provider must not be null\");\n+        }\n+        Set ids = provider.getAvailableIDs();\n+        if (ids == null || ids.size() == 0) {\n+            throw new IllegalArgumentException\n+                (\"The provider doesn't have any available ids\");\n+        }\n+        if (!ids.contains(\"UTC\")) {\n+            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n+        }\n+        if (!UTC.equals(provider.getDateTimeZone(\"UTC\"))) {\n+            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n+        }\n+        cProvider = provider;\n+        cAvailableIDs = ids;\n+    }\n+\n+    public static NameProvider getNameProvider() {\n+        return cNameProvider;\n+    }\n+\n+    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n+        // TODO: Put in a security check.\n+        if (nameProvider == null) {\n+            throw new IllegalArgumentException(\"The provider must not be null\");\n+        }\n+        cNameProvider = nameProvider;\n+    }\n+\n+    private static synchronized String getConvertedId(String id) {\n+        Map map = cZoneIdConversion;\n+        if (map == null) {\n+            // Backwards compatibility with TimeZone.\n+            map = new HashMap();\n+            map.put(\"GMT\", \"UTC\");\n+            map.put(\"MIT\", \"Pacific/Apia\");\n+            map.put(\"HST\", \"Pacific/Honolulu\");\n+            map.put(\"AST\", \"America/Anchorage\");\n+            map.put(\"PST\", \"America/Los_Angeles\");\n+            map.put(\"MST\", \"America/Denver\");\n+            map.put(\"PNT\", \"America/Phoenix\");\n+            map.put(\"CST\", \"America/Chicago\");\n+            map.put(\"EST\", \"America/New_York\");\n+            map.put(\"IET\", \"America/Indianapolis\");\n+            map.put(\"PRT\", \"America/Puerto_Rico\");\n+            map.put(\"CNT\", \"America/St_Johns\");\n+            map.put(\"AGT\", \"America/Buenos_Aires\");\n+            map.put(\"BET\", \"America/Sao_Paulo\");\n+            map.put(\"WET\", \"Europe/London\");\n+            map.put(\"ECT\", \"Europe/Paris\");\n+            map.put(\"ART\", \"Africa/Cairo\");\n+            map.put(\"CAT\", \"Africa/Harare\");\n+            map.put(\"EET\", \"Europe/Bucharest\");\n+            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n+            map.put(\"MET\", \"Asia/Tehran\");\n+            map.put(\"NET\", \"Asia/Yerevan\");\n+            map.put(\"PLT\", \"Asia/Karachi\");\n+            map.put(\"IST\", \"Asia/Calcutta\");\n+            map.put(\"BST\", \"Asia/Dhaka\");\n+            map.put(\"VST\", \"Asia/Saigon\");\n+            map.put(\"CTT\", \"Asia/Shanghai\");\n+            map.put(\"JST\", \"Asia/Tokyo\");\n+            map.put(\"ACT\", \"Australia/Darwin\");\n+            map.put(\"AET\", \"Australia/Sydney\");\n+            map.put(\"SST\", \"Pacific/Guadalcanal\");\n+            map.put(\"NST\", \"Pacific/Auckland\");\n+            cZoneIdConversion = map;\n+        }\n+        return (String)map.get(id);\n+    }\n+\n+    private static synchronized DateTimeFormatter offsetFormatter() {\n+        if (cOffsetFormatter == null) {\n+            cOffsetFormatter = new DateTimeFormatterBuilder(UTC)\n+                .appendTimeZoneOffset(null, true, 2, 4)\n+                .toFormatter();\n+        }\n+        return cOffsetFormatter;\n+    }\n+\n+    // Instance fields and methods\n+    //--------------------------------------------------------------------\n+\n+    private final String iID;\n+\n+    public DateTimeZone(String id) {\n+        if (id == null) {\n+            throw new IllegalArgumentException(\"Id must not be null\");\n+        }\n+        iID = id;\n+    }\n+\n+    // Principal methods\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * Gets the ID of this datetime zone.\n+     * \n+     * @return the ID of this datetime zone\n+     */\n+    public final String getID() {\n+        return iID;\n+    }\n+\n+    /**\n+     * Returns a non-localized name that is unique to this time zone. It can be\n+     * combined with id to form a unique key for fetching localized names.\n+     *\n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return name key or null if id should be used for names\n+     */\n+    public abstract String getNameKey(long millis);\n+\n+    /**\n+     * Gets the short name of this datetime zone suitable for display using\n+     * the default locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable short name in the default locale\n+     */\n+    public final String getShortName(long millis) {\n+        return getShortName(millis, null);\n+    }\n+\n+    /**\n+     * Gets the short name of this datetime zone suitable for display using\n+     * the specified locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable short name in the specified locale\n+     */\n+    public String getShortName(long millis, Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        String nameKey = getNameKey(millis);\n+        if (nameKey == null) {\n+            return iID;\n+        }\n+        String name = cNameProvider.getShortName(locale, iID, nameKey);\n+        if (name != null) {\n+            return name;\n+        }\n+        return offsetFormatter().print(millis, this);\n+    }\n+\n+    /**\n+     * Gets the long name of this datetime zone suitable for display using\n+     * the default locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable long name in the default locale\n+     */\n+    public final String getName(long millis) {\n+        return getName(millis, null);\n+    }\n+\n+    /**\n+     * Gets the long name of this datetime zone suitable for display using\n+     * the specified locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable long name in the specified locale\n+     */\n+    public String getName(long millis, Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        String nameKey = getNameKey(millis);\n+        if (nameKey == null) {\n+            return iID;\n+        }\n+        String name = cNameProvider.getName(locale, iID, nameKey);\n+        if (name != null) {\n+            return name;\n+        }\n+        return offsetFormatter().print(millis, this);\n+    }\n+\n+    /**\n+     * Gets the millisecond offset to add to UTC to get local time.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @return the millisecond offset to add to UTC to get local time\n+     */\n+    public abstract int getOffset(long millis);\n+\n+    /**\n+     * Gets the millisecond offset to add to UTC to get local time.\n+     * \n+     * @param instant instant to get the offset for\n+     * @return the millisecond offset to add to UTC to get local time\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public final int getOffset(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return getOffset(instant.getMillis());\n+    }\n+\n+    /**\n+     * Gets the standard millisecond offset to add to UTC to get local time,\n+     * when standard time is in effect.\n+     * \n+     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @return the millisecond offset to add to UTC to get local time\n+     */\n+    public abstract int getStandardOffset(long millis);\n+\n+    /**\n+     * Gets the millisecond offset to subtract from local time to get UTC time.\n+     * This offset can be used to undo adding the offset obtained by getOffset.\n+     *\n+     * <pre>\n+     * millisLocal == millisUTC   + getOffset(millisUTC)\n+     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n+     * </pre>\n+     *\n+     * Note: After calculating millisLocal, some error may be introduced. At\n+     * offset transitions (due to DST or other historical changes), ranges of\n+     * local times may map to different UTC times.\n+     *\n+     * @param millisLocal the millisecond instant, relative to this time zone, to\n+     * get the offset for\n+     * @return the millisceond offset to subtract from local time to get UTC time.\n+     */\n+    public int getOffsetFromLocal(long millisLocal) {\n+        return getOffset(millisLocal - getOffset(millisLocal));\n+    }\n+\n+    /**\n+     * Advances the given instant to where the time zone offset or name\n+     * changes. If the instant returned is exactly the same as passed in, then\n+     * no changes occur after the given instant.\n+     *\n+     * @param millis milliseconds from 1970-01-01T00:00:00Z\n+     * @return milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public abstract long nextTransition(long millis);\n+\n+    /**\n+     * Retreats the given instant to where the time zone offset or name\n+     * changes. If the instant returned is exactly the same as passed in, then\n+     * no changes occur before the given instant.\n+     *\n+     * @param millis milliseconds from 1970-01-01T00:00:00Z\n+     * @return milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public abstract long previousTransition(long millis);\n+\n+    // Basic methods\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * Get the datetime zone as a {@link java.util.TimeZone}.\n+     * \n+     * @return the equivalent TimeZone object\n+     */\n+    public java.util.TimeZone toTimeZone() {\n+        return java.util.TimeZone.getTimeZone(iID);\n+    }\n+\n+    /**\n+     * Compare this datetime zone with another.\n+     * \n+     * @param object the object to compare with\n+     * @return true if equal, based on the ID and all internal rules\n+     */\n+    public abstract boolean equals(Object obj);\n+\n+    /**\n+     * Gets a hash code compatable with equals.\n+     * \n+     * @return suitable hashcode\n+     */\n+    public int hashCode() {\n+        return 57 + getID().hashCode();\n+    }\n+\n+    /**\n+     * Gets the datetime zone as a string, which is simply its ID.\n+     */\n+    public String toString() {\n+        return getID();\n+    }\n+\n+    /**\n+     * By default, when DateTimeZones are serialized, only a \"stub\" object\n+     * referring to the id is written out. When the stub is read in, it\n+     * replaces itself with a DateTimeZone object.\n+     */\n+    protected Object writeReplace() throws ObjectStreamException {\n+        return new Stub(iID);\n+    }\n+\n+    static class UTCProvider implements Provider {\n+        public DateTimeZone getDateTimeZone(String id) {\n+            if (\"UTC\".equals(id)) {\n+                return UTC;\n+            }\n+            return null;\n+        }\n+\n+        public Set getAvailableIDs() {\n+            return Collections.singleton(\"UTC\");\n+        }\n+    }\n+\n+    /**\n+     * Used to serialize DateTimeZones by id.\n+     */\n+    private static final class Stub implements Serializable {\n+        private transient String iID;\n+\n+        Stub(String id) {\n+            iID = id;\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeUTF(iID);\n+        }\n+\n+        private void readObject(ObjectInputStream in) throws IOException {\n+            iID = in.readUTF();\n+        }\n+\n+        protected Object readResolve() throws ObjectStreamException {\n+            return getInstance(iID);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.format.DateTimeParser;\n+\n+/**\n+ * Instant is the standard implementation of a fully immutable instant in \n+ * time. It holds the instant as milliseconds from the Java Epoch of \n+ * 1970-01-01T00:00:00Z.\n+ * <p>\n+ * There is no concept of a calendar system, chronology or time zone. In \n+ * a fully internationalized program, methods should accept the ReadableInstant \n+ * interface as input and return Instant objects.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class Instant extends AbstractInstant implements ReadableInstant {\n+\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private final long iMillis;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that sets the time to be the current time from the\n+     * system clock.\n+     */\n+    public Instant() {\n+        super();\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructor that takes milliseconds from 1970-01-01T00:00:00Z.\n+     * \n+     * @param millis  the milliseconds\n+     */\n+    public Instant(long millis) {\n+        super();\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructor that takes a ReadableInstant.\n+     * \n+     * @param instant  the ReadableInstant\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public Instant(ReadableInstant instant) {\n+        super();\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The ReadableInstant must not be null\");\n+        }\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructor that takes a Date.\n+     * \n+     * @param date  the Date\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public Instant(Date date) {\n+        super();\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The Date must not be null\");\n+        }\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructor that takes a Calendar.\n+     * \n+     * @param calendar  the Calendar\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    public Instant(Calendar calendar) {\n+        super();\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The Calendar must not be null\");\n+        }\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructor that parses an ISO formatted string.\n+     * \n+     * @param str  the string\n+     * @throws IllegalArgumentException if the string is null\n+     * @throws ParseException if the string is incorrectly formatted\n+     */\n+    public Instant(String str) throws ParseException {\n+        super();\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"The String must not be null\");\n+        }\n+        DateTimeParser p = ISODateTimeFormat.getInstanceUTC().dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class.\n+     * <p>\n+     * The returned object will be a new instance of the implementation.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param chrono  the new chronology\n+     * @return a new instance of this class\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    protected ReadableInstant create(long millis, Chronology chrono) {\n+        // ignore chrono\n+        if (millis == getMillis()) {\n+            return this;\n+        }\n+        return new Instant(millis);\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the instant.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public final long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the instant, which is null.\n+     * <p>\n+     * The {@link Chronology} provides conversion from the millisecond\n+     * value to meaningful fields in a particular calendar system. This\n+     * class represents a chronology free view of time, so this method\n+     * returns null.\n+     * \n+     * @return null\n+     */\n+    public final Chronology getChronology() {\n+        return null;\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format.\n+     * <p>\n+     * ISO8601 is deliberately used here so that the resulting string can be\n+     * re-parsed by the constructor.\n+     * \n+     * @return ISO8601 date formatted string\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstanceUTC().dateTime().print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time;\n+\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * MutableDateTime is the standard implementation of a modifiable\n+ * datetime class.\n+ * It holds the date/time as milliseconds from the Java epoch of\n+ * 1970-01-01T00:00:00Z.\n+ * <p>\n+ * This class requires a Chronology to be specified. The Chronology determines\n+ * how the millisecond instant value is converted into the date time fields.\n+ * <p>\n+ * Each individual field can be accessed in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>get numeric value\n+ * <li>set numeric value\n+ * <li>add to numeric value\n+ * <li>add to numeric value wrapping with the field\n+ * <li>get text vlaue\n+ * <li>get short text value\n+ * <li>set text value\n+ * <li>field maximum value\n+ * <li>field minimum value\n+ * </ul>\n+ *\n+ * @author Guy Allard\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class MutableDateTime extends AbstractDateTime\n+    implements ReadableDateTime, ReadWritableInstant, Cloneable\n+{\n+    /** The millis from 1970-01-01T00:00:00Z. */\n+    private long iMillis;\n+    /** The chronology to use */\n+    private Chronology iChronology;\n+\n+    // Constructors (same as DateTime)\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Constructs a MutableDateTime to the current datetime, as reported by the system\n+     * clock. The chronology used is ISO, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     */\n+    public MutableDateTime() {\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime to the current datetime, as reported by the system\n+     * clock. The chronology used is ISO, in the supplied time zone.\n+     *\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public MutableDateTime(DateTimeZone zone) {\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime to the current datetime, as reported by the system\n+     * clock.\n+     *\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public MutableDateTime(Chronology chronology) {\n+        iChronology = selectChronology(chronology);\n+        iMillis = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the ISO chronology, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param millis  the milliseconds\n+     */\n+    public MutableDateTime(long millis) {\n+        iChronology = ISOChronology.getInstance();\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the ISO chronology, in the supplied time zone.\n+     *\n+     * @param millis  the milliseconds\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public MutableDateTime(long millis, DateTimeZone zone) {\n+        iChronology = ISOChronology.getInstance(zone);\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,\n+     * using the supplied chronology.\n+     *\n+     * @param millis  the milliseconds\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public MutableDateTime(long millis, Chronology chronology) {\n+        iChronology = selectChronology(chronology);\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a ReadableInstant, using its chronology. If\n+     * its chronology null, then the chronology is set to ISO, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public MutableDateTime(ReadableInstant instant) {\n+        iChronology = selectChronology(instant);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a ReadableInstant, using its chronology\n+     * against a different time zone. If its chronology is null, then the\n+     * chronology is set to ISO. If the selected chronology is not in the\n+     * supplied time zone, a new chronology is created that is.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the instant or zone is null\n+     */\n+    public MutableDateTime(ReadableInstant instant, DateTimeZone zone) {\n+        iChronology = selectChronology(instant, zone);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a ReadableInstant, using the supplied\n+     * chronology.\n+     *\n+     * @param instant  the ReadableInstant, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the instant or chronology is null\n+     */\n+    public MutableDateTime(ReadableInstant instant, Chronology chronology) {\n+        iChronology = selectChronology(instant, chronology);\n+        iMillis = instant.getMillis();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the\n+     * {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param date  the Date, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public MutableDateTime(Date date) {\n+        iChronology = selectChronology(date);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the\n+     * supplied time zone.\n+     *\n+     * @param date  the Date, must not be null\n+     * @param zone  the time zone, must not be null\n+     * @throws IllegalArgumentException if the date or zone is null\n+     */\n+    public MutableDateTime(Date date, DateTimeZone zone) {\n+        iChronology = selectChronology(date, zone);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Date, using the supplied chronology.\n+     *\n+     * @param date  the Date, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public MutableDateTime(Date date, Chronology chronology) {\n+        iChronology = selectChronology(date, chronology);\n+        iMillis = date.getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Calendar, using its closest mapped\n+     * chronology and time zone.\n+     *\n+     * <p>When converting calendars to chronologies, the constructor is aware\n+     * of GregorianCalendar and BuddhistCalendar and maps them to the\n+     * equivalent chronology. Other calendars map to ISOChronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @throws IllegalArgumentException if the calendar is null\n+     */\n+    public MutableDateTime(Calendar calendar) {\n+        iChronology = selectChronology(calendar);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Calendar, using its closest mapped\n+     * chronology against a different time zone.\n+     *\n+     * <p>When converting calendars to chronologies, the constructor is aware\n+     * of GregorianCalendar and BuddhistCalendar and maps them to the\n+     * equivalent chronology. Other calendars map to ISOChronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the calendar or zone is null\n+     */\n+    public MutableDateTime(Calendar calendar, DateTimeZone zone) {\n+        iChronology = selectChronology(calendar, zone);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from a Calendar, using the supplied chronology.\n+     *\n+     * @param calendar  the Calendar, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the calendar or chronology is null\n+     */\n+    public MutableDateTime(Calendar calendar, Chronology chronology) {\n+        iChronology = selectChronology(calendar, chronology);\n+        iMillis = calendar.getTime().getTime();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from an ISO formatted String, using the ISO\n+     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @throws IllegalArgumentException if the string is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public MutableDateTime(String str) throws ParseException {\n+        iChronology = selectChronology(str);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from an ISO formatted String, using the ISO\n+     * chronology, in the supplied time zone.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @param zone the time zone, must not be null\n+     * @throws IllegalArgumentException if the string or zone is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public MutableDateTime(String str, DateTimeZone zone) throws ParseException {\n+        iChronology = selectChronology(str, zone);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Constructs a MutableDateTime from an ISO formatted String, using the supplied\n+     * chronology.\n+     *\n+     * @param str  the string to parse, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the string or chronology is null\n+     * @throws ParseException if parsing fails\n+     */\n+    public MutableDateTime(String str, Chronology chronology) throws ParseException {\n+        iChronology = selectChronology(str, chronology);\n+        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();\n+        iMillis = p.parseMillis(str);\n+    }\n+\n+    /**\n+     * Creates a new instance of this class.\n+     * <p>\n+     * The returned object will be a new instance of the implementation.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param millis  the new millis, from 1970-01-01T00:00:00Z\n+     * @param chrono  the new chronology\n+     * @return a new instance of this class\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    protected ReadableInstant create(long millis, Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        return new MutableDateTime(millis, chrono);\n+    }\n+    \n+    // Accessor/mutator/adder methods (Accessors same as for DateTime)\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Set the milliseconds of the datetime.\n+     *\n+     * @param millis the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * datetime to\n+     */\n+    public void setMillis(long millis) {\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Set the number of milliseconds of the datetime.\n+     * \n+     * @param datetime  a ReadableInstant, Date, Calendar, Long or String\n+     * @throws IllegalArgumentException if the object is null\n+     * @throws ClassCastException if the object's type cannot be recognised\n+     */\n+    public void setMillis(Object object) {\n+        iMillis = getDateTimeMillisFromObject(object);\n+    }\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param duration duration to add.\n+     */\n+    /*\n+    public void add(ReadableDuration duration) {\n+        duration.addTo(this, 1);\n+    }\n+    */\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param duration duration to add.\n+     * @param scalar direction and amount to add, which may be negative\n+     */\n+    /*\n+    public void add(ReadableDuration duration, int scalar) {\n+        duration.addTo(this, scalar);\n+    }\n+    */\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param object a ReadableDuration, Long or String evaluating to a\n+     * duration\n+     */\n+    public void add(Object object) {\n+        /*\n+        if (object instanceof ReadableDuration) {\n+            add((ReadableDuration)object);\n+        } else {\n+            iMillis += getDurationMillisFromObject(object);\n+        }\n+        */\n+        iMillis += getDurationMillisFromObject(object);\n+    }\n+\n+    /**\n+     * Add an amount of time to the datetime.\n+     * \n+     * @param millis  the millis to add\n+     */\n+    public void addMillis(long millis) {\n+        iMillis += millis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Set the chronology of the datetime.\n+     * \n+     * @param chronology  the chronology to use\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public void setChronology(Chronology chronology) {\n+        if (chronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Sets the time zone of the datetime via the chronology.\n+     *\n+     * @param zone  the time zone to use\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    public void setDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (iChronology.getDateTimeZone() != zone) {\n+            iChronology = iChronology.withDateTimeZone(zone);\n+        }\n+    }\n+\n+    // public int get(DateTimeField field);  inherited from AbstractInstant\n+\n+    /**\n+     * Set a value in the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateTime dt = new MutableDateTime();\n+     * dt.set(GJChronology.getInstance().year(), 2002);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void set(DateTimeField field, int value) {\n+        iMillis = field.set(getMillis(), value);\n+    }\n+\n+    /**\n+     * Add a value to the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateTime dt = new MutableDateTime();\n+     * dt.add(GJChronology.getInstance().year(), 2);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void add(DateTimeField field, int value) {\n+        iMillis = field.add(getMillis(), value);\n+    }\n+\n+    /**\n+     * Add a value to the specified field, wrapping within that field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateTime dt = new MutableDateTime();\n+     * dt.addWrapped(GJChronology.getInstance().monthOfYear(), 6);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void addWrapped(DateTimeField field, int value) {\n+        iMillis = field.addWrapped(getMillis(), value);\n+    }\n+\n+    // Date field mutator/adder methods\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Set the day of week to a value.\n+     *\n+     * @param dayOfWeek  the day of the week.\n+     */\n+    public void setDayOfWeek(int dayOfWeek) {\n+        iMillis = getChronology().dayOfWeek().set(iMillis, dayOfWeek);\n+    }\n+\n+    /**\n+     * Set the day of the month to a value.\n+     *\n+     * @param dayOfMonth  the day of the month.\n+     */\n+    public void setDayOfMonth(int dayOfMonth) {\n+        iMillis = getChronology().dayOfMonth().set(iMillis, dayOfMonth);\n+    }\n+\n+    /**\n+     * Set the day of year to a value.\n+     *\n+     * @param dayOfYear the day of the year.\n+     */\n+    public void setDayOfYear(int dayOfYear) {\n+        iMillis = getChronology().dayOfYear().set(iMillis, dayOfYear);\n+    }\n+\n+    /**\n+     * Add a number of days to the date.\n+     *\n+     * @param days  the days to add.\n+     */\n+    public void addDays(int days) {\n+        iMillis = getChronology().dayOfYear().add(iMillis, days);\n+    }\n+\n+    /**\n+     * Set the week of weekyear to a value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear.\n+     */\n+    public void setWeekOfWeekyear(int weekOfWeekyear) {\n+        iMillis = getChronology().weekOfWeekyear().set(iMillis, weekOfWeekyear);\n+    }\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add.\n+     */\n+    public void addWeeks(int weeks) {\n+        iMillis = getChronology().weekOfWeekyear().add(iMillis, weeks);\n+    }\n+\n+    /**\n+     * Set the week of the year to a value.\n+     *\n+     * @param weekyear  the weekyear.\n+     */\n+    public void setWeekyear(int weekyear) {\n+        iMillis = getChronology().weekyear().set(iMillis, weekyear);\n+    }\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add.\n+     */\n+    public void addWeekyears(int weekyears) {\n+        iMillis = getChronology().weekyear().add(iMillis, weekyears);\n+    }\n+\n+    /**\n+     * Set the month of the year to a value.\n+     *\n+     * @param month  the month of the year.\n+     */\n+    public void setMonthOfYear(int month) {\n+        iMillis = getChronology().monthOfYear().set(iMillis, month);\n+    }\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add.\n+     */\n+    public void addMonths(int months) {\n+        iMillis = getChronology().monthOfYear().add(iMillis, months);\n+    }\n+\n+    /**\n+     * Set the year to a value.\n+     *\n+     * @param year  the year.\n+     */\n+    public void setYear(int year) {\n+        iMillis = getChronology().year().set(iMillis, year);\n+    }\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add.\n+     */\n+    public void addYears(int years) {\n+        iMillis = getChronology().year().add(iMillis, years);\n+    }\n+\n+    // Time field mutator/adder methods\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Set the millis of the second.\n+     *\n+     * @param millis  the millis of second.\n+     */\n+    public void setMillisOfSecond(int millis) {\n+        iMillis = getChronology().millisOfSecond().set(iMillis, millis);\n+    }\n+\n+    /**\n+     * Set the millis of the day.\n+     *\n+     * @param millis  the millis of day.\n+     */\n+    public void setMillisOfDay(int millis) {\n+        iMillis = getChronology().millisOfDay().set(iMillis, millis);\n+    }\n+\n+    /**\n+     * Set the second of the minute.\n+     *\n+     * @param second  the second of minute.\n+     */\n+    public void setSecondOfMinute(int second) {\n+        iMillis = getChronology().secondOfMinute().set(iMillis, second);\n+    }\n+\n+    /**\n+     * Set the second of the day.\n+     *\n+     * @param second  the second of day.\n+     */\n+    public void setSecondOfDay(int second) {\n+        iMillis = getChronology().secondOfDay().set(iMillis, second);\n+    }\n+\n+    /**\n+     * Add a number of seconds to the date.\n+     *\n+     * @param seconds  the seconds to add.\n+     */\n+    public void addSeconds(int seconds) {\n+        iMillis = getChronology().secondOfDay().add(iMillis, seconds);\n+    }\n+\n+    /**\n+     * Set the minute of the hour.\n+     *\n+     * @param minute  the minute of hour.\n+     */\n+    public void setMinuteOfHour(int minute) {\n+        iMillis = getChronology().minuteOfHour().set(iMillis, minute);\n+    }\n+\n+    /**\n+     * Set the minute of the day.\n+     *\n+     * @param minute  the minute of day.\n+     */\n+    public void setMinuteOfDay(int minute) {\n+        iMillis = getChronology().minuteOfDay().set(iMillis, minute);\n+    }\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add.\n+     */\n+    public void addMinutes(int minutes) {\n+        iMillis = getChronology().minuteOfDay().add(iMillis, minutes);\n+    }\n+\n+    /**\n+     * Set the hour of the day.\n+     *\n+     * @param hour  the hour of day.\n+     */\n+    public void setHourOfDay(int hour) {\n+        iMillis = getChronology().hourOfDay().set(iMillis, hour);\n+    }\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add.\n+     */\n+    public void addHours(int hours) {\n+        iMillis = getChronology().hourOfDay().add(iMillis, hours);\n+    }\n+\n+    // Convenient helpers\n+    //----------------------------------------------------\n+    \n+    /**\n+     * Set the date from various different types of object.\n+     * The time part of the parameter will be ignored.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param date  a ReadableInstant, Date, Calendar, Long or String\n+     * @throws IllegalArgumentException if the object is null.\n+     * @throws ClassCastException if the object's type cannot be recognised\n+     */\n+    public void setDate(Object date) {\n+        setDate(getDateTimeMillisFromObject(date));\n+    }\n+\n+    /**\n+     * Set the date from milliseconds.\n+     * The time part of the parameter will be ignored.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param millis milliseconds from 1970-01-01T00:00:00Z, ignoring time of\n+     * day\n+     */\n+    public void setDate(long millis) {\n+        Chronology c = getChronology();\n+        iMillis = c.getDateOnlyMillis(millis) + c.getTimeOnlyMillis(iMillis);\n+    }\n+\n+    /**\n+     * Set the date from fields.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param year  the year\n+     * @param month  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public void setDate(int year, int monthOfYear, int dayOfMonth) {\n+        // Do not modify this object until method completion\n+        Chronology c = getChronology();\n+        long workVal = c.getTimeOnlyMillis( iMillis );\n+        workVal = c.year().set( workVal, year );\n+        workVal = c.monthOfYear().set( workVal, monthOfYear );\n+        workVal = c.dayOfMonth().set( workVal, dayOfMonth );\n+        iMillis = workVal;\n+    }\n+\n+    /**\n+     * Set the time from an object.\n+     * The date part of the parameter will be ignored.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param time  a ReadableInstant, Date, Calendar, Long or String\n+     * @throws IllegalArgumentException if the object is null.\n+     * @throws ClassCastException if the object's type cannot be recognised\n+     */\n+    public void setTime(Object time) {\n+        setTime(getDateTimeMillisFromObject(time));\n+    }\n+\n+    /**\n+     * Set the time from milliseconds.\n+     * The date part of the parameter will be ignored.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param millis milliseconds from T00:00:00Z, ignoring date\n+     */\n+    public void setTime(long millis) {\n+        Chronology c = getChronology();\n+        iMillis = c.getDateOnlyMillis(iMillis) + c.getTimeOnlyMillis(millis);\n+    }\n+\n+    /**\n+     * Set the time from fields.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    public void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        // Do not modify this object until method completion\n+        Chronology c = getChronology();\n+        long workVal = c.getDateOnlyMillis( iMillis );\n+        workVal = c.hourOfDay().set( workVal, hour );\n+        workVal = c.minuteOfHour().set( workVal, minuteOfHour );\n+        workVal = c.secondOfMinute().set( workVal, secondOfMinute );\n+        workVal = c.millisOfSecond().set( workVal, millisOfSecond );\n+        iMillis = workVal;\n+    }\n+\n+    /**\n+     * Set the date and time from an object.\n+     *\n+     * @param datetime  a ReadableInstant, Date, Calendar, Long or String\n+     * @throws IllegalArgumentException if the object is null.\n+     * @throws ClassCastException if the object's type cannot be recognised\n+     */\n+    public void setDateTime(Object datetime) {\n+        iMillis = getDateTimeMillisFromObject(datetime);\n+    }\n+\n+    /**\n+     * Set the date and time from milliseconds.\n+     *\n+     * @param millis  the millis\n+     */\n+    public void setDateTime(long millis) {\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Set the date and time from fields.\n+     *\n+     * @param year  the year\n+     * @param month  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the milisecond of the second\n+     */\n+    public void setDateTime(int year,\n+                            int monthOfYear,\n+                            int dayOfMonth,\n+                            int hourOfDay,\n+                            int minuteOfHour,\n+                            int secondOfMinute,\n+                            int millisOfSecond)\n+    {\n+        // Do not modify this object until method completion\n+        Chronology c = getChronology();\n+        long workVal = 0;\n+        workVal = c.year().set( workVal, year );\n+        workVal = c.monthOfYear().set( workVal, monthOfYear );\n+        workVal = c.dayOfMonth().set( workVal, dayOfMonth );\n+        workVal = c.hourOfDay().set( workVal, hourOfDay );\n+        workVal = c.minuteOfHour().set( workVal, minuteOfHour );\n+        workVal = c.secondOfMinute().set( workVal, secondOfMinute );\n+        workVal = c.millisOfSecond().set( workVal, millisOfSecond );\n+        iMillis = workVal;\n+    }\n+\n+    // Date properties\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Get the day of week property.\n+     * <p>\n+     * The values for day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week property\n+     */\n+    public MutableDateTimeFieldProperty dayOfWeek() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     */\n+    public MutableDateTimeFieldProperty dayOfMonth() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public MutableDateTimeFieldProperty dayOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public MutableDateTimeFieldProperty weekOfWeekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public MutableDateTimeFieldProperty weekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public MutableDateTimeFieldProperty monthOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public MutableDateTimeFieldProperty year() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty yearOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty yearOfCentury() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public MutableDateTimeFieldProperty centuryOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public MutableDateTimeFieldProperty era() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().era());\n+    }\n+\n+    // Time properties\n+    //-----------------------------------------------------------\n+    \n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public MutableDateTimeFieldProperty millisOfSecond() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     */\n+    public MutableDateTimeFieldProperty millisOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public MutableDateTimeFieldProperty secondOfMinute() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     */\n+    public MutableDateTimeFieldProperty secondOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public MutableDateTimeFieldProperty minuteOfHour() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     */\n+    public MutableDateTimeFieldProperty minuteOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public MutableDateTimeFieldProperty hourOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n+    }\n+\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableDateTime copy() {\n+        try {\n+            return (MutableDateTime)super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+    /**\n+     * Extracts a long datetime value from an object.\n+     *\n+     * @param object  an input object\n+     * @return a long date-time value\n+     * @throws IllegalArgumentException if the object is null, or the string invalid\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    protected long getDateTimeMillisFromObject(Object object) {\n+        if (object instanceof ReadableInstant) {\n+            return ((ReadableInstant) object).getMillis();\n+\n+        } else if (object instanceof Date) {\n+            return ((Date) object).getTime();\n+\n+        } else if (object instanceof Calendar) {\n+            return ((Calendar) object).getTime().getTime();\n+\n+        } else if (object instanceof Long) {\n+            return ((Long) object).longValue();\n+\n+        } else if (object instanceof String) {\n+            try {\n+                Instant instant = new Instant((String) object);\n+                return instant.getMillis();\n+\n+            } catch (ParseException ex) {\n+                throw new IllegalArgumentException(\"String '\" + object + \"' is an invalid date format\");\n+            }\n+        } else if (object == null) {\n+            throw new IllegalArgumentException(\"<null> cannot be converted to a datetime\");\n+        } else {\n+            throw new ClassCastException(\"Class '\" + object.getClass().getName() + \"' cannot be converted to a datetime\");\n+        }\n+    }\n+\n+    /**\n+     * Extracts a fixed millisecond duration from an object.\n+     * \n+     * @param object  Long or String\n+     * @throws IllegalArgumentException if the object is null, or the string invalid\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    protected long getDurationMillisFromObject(Object object) {\n+        if (object instanceof Long) {\n+            Long other = (Long) object;\n+            return other.longValue();\n+        /* TODO } else if (object instanceof String) {\n+            try {\n+                TimePeriod other = new TimePeriod((String) object);\n+                return other.getMillis();\n+            } catch (ParseException ex) {\n+                throw new IllegalArgumentException\n+                    (\"String '\" + object + \"' is an invalid time period format\");\n+            }*/\n+        } else {\n+            String type;\n+            if (object == null) {\n+                type = \"<null>\";\n+            } else {\n+                type = \"Object of type \\\"\" + object.getClass().getName() + '\"';\n+            }\n+            throw new IllegalArgumentException(type + \" cannot be converted to a duration\");\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+/**\n+ * MutableDateTimeFieldProperty binds a ReadWritableInstant to a DateTimeField.\n+ * <p>\n+ * MutableDateTimeFieldProperty allows the date and time manipulation code to\n+ * be field based yet still easy to use.\n+ *\n+ * @see ReadWritableInstant\n+ * @see DateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class MutableDateTimeFieldProperty extends DateTimeFieldProperty {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param instant  the instant to set\n+     * @param field  the field to use\n+     */\n+    public MutableDateTimeFieldProperty(ReadWritableInstant instant, DateTimeField field) {\n+        super(instant, field);\n+    }\n+\n+    /**\n+     * Adds a value to the millis value.\n+     * \n+     * @param value  the value to add.\n+     * @see DateTimeField#add(long,int)\n+     */\n+    public void add(int value) {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().add(instant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Adds a value to the millis value.\n+     * \n+     * @param value  the value to add.\n+     * @see DateTimeField#add(long,long)\n+     */\n+    public void add(long value) {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().add(instant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Adds a value, possibly wrapped, to the millis value.\n+     * \n+     * @param value  the value to add.\n+     * @see DateTimeField#addWrapped\n+     */\n+    public void addWrapped(int value) {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().addWrapped(instant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Sets a value.\n+     * \n+     * @param value  the value to set.\n+     * @see DateTimeField#set(long,int)\n+     */\n+    public void set(int value) {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().set(instant.getMillis(), value));\n+    }\n+\n+    /**\n+     * Sets a text value.\n+     * \n+     * @param text  the text value to set\n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n+     */\n+    public void set(String text, Locale locale) {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().set(instant.getMillis(), text, locale));\n+    }\n+\n+    /**\n+     * Sets a text value.\n+     * \n+     * @param text  the text value to set\n+     * @throws IllegalArgumentException if the text value isn't valid\n+     * @see DateTimeField#set(long,java.lang.String)\n+     */\n+    public final void set(String text) {\n+        set(text, null);\n+    }\n+\n+    /**\n+     * Round to the lowest whole unit of this field.\n+     *\n+     * @see DateTimeField#roundFloor\n+     */\n+    public void roundFloor() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().roundFloor(instant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the highest whole unit of this field.\n+     *\n+     * @see DateTimeField#roundCeiling\n+     */\n+    public void roundCeiling() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().roundCeiling(instant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field, favoring the floor if\n+     * halfway.\n+     *\n+     * @see DateTimeField#roundHalfFloor\n+     */\n+    public void roundHalfFloor() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().roundHalfFloor(instant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field, favoring the ceiling if\n+     * halfway.\n+     *\n+     * @see DateTimeField#roundHalfCeiling\n+     */\n+    public void roundHalfCeiling() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().roundHalfCeiling(instant.getMillis()));\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If halfway, the ceiling\n+     * is favored the floor only if it makes this field's value even.\n+     *\n+     * @see DateTimeField#roundHalfEven\n+     */\n+    public void roundHalfEven() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().roundHalfEven(instant.getMillis()));\n+    }\n+\n+    /**\n+     * Retains only the fractional units of this field.\n+     *\n+     * @see DateTimeField#remainder\n+     */\n+    public void remainder() {\n+        ReadWritableInstant instant = (ReadWritableInstant)getInstant();\n+        instant.setMillis(getField().remainder(instant.getMillis()));\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Writable interface for an instant in the datetime continuum. \n+ * <p>\n+ * This interface expresses the datetime as milliseconds from \n+ * 1970-01-01T00:00:00Z.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritableInstant extends ReadableInstant {\n+\n+    /**\n+     * Set the value as the number of miliseconds since\n+     * the epoch, 1970-01-01T00:00:00Z.\n+     *\n+     * @return the value as milliseconds\n+     */\n+    void setMillis(long millis);\n+\n+    /**\n+     * Set the value from Date, Calendar, DateTime etc.\n+     *\n+     * @return the value as a Calendar\n+     */\n+    void setMillis(Object obj);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an amount of time.\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     *\n+     * @param duration duration to add.\n+     */\n+    //void add(ReadableDuration duration);\n+\n+    /**\n+     * Add an amount of time.\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     *\n+     * @param duration duration to add.\n+     * @param scalar direction and amount to add, which may be negative\n+     */\n+    //void add(ReadableDuration duration, int scalar);\n+\n+    /**\n+     * Add an amount of time, either a ReadableDuration or Long (millis).\n+     * <p>\n+     * If the resulting value is too large for the implementation,\n+     * an exception is thrown.\n+     *\n+     * @param object  an object evaluating to an a period of time to\n+     *  add.\n+     */\n+    void add(Object object);\n+\n+    /**\n+     * Add a number of millis to the value.\n+     * <p>\n+     * If the resulting value is too large for millis, seconds\n+     * will change and so on unless it is too large for the\n+     * implementation, when an exception is thrown.\n+     *\n+     * @param millis  the millis to add\n+     */\n+    void addMillis(long millis);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the value of one of the fields of a datetime.\n+     * <p>\n+     * DateTimeField instances are generally obtained from a {@link Chronology} subclass.\n+     * However, an application can create its own DateTimeField to manipulate the\n+     * date time millis in new ways.\n+     *\n+     * @param field  a DateTimeField instance, usually obtained from a Chronology\n+     * @param value  the value of that field for the millis set in the implementation\n+     */\n+    void set(DateTimeField field, int value);\n+    \n+    /**\n+     * Add to the value of one of the fields of a datetime.\n+     * <p>\n+     * DateTimeField instances are generally obtained from a {@link Chronology} subclass.\n+     * However, an application can create its own DateTimeField to manipulate the\n+     * date time millis in new ways.\n+     *\n+     * @param field  a DateTimeField instance, usually obtained from a Chronology\n+     * @param value  the value of that field for the millis set in the implementation\n+     */\n+    void add(DateTimeField field, int value);\n+    \n+    /**\n+     * Add to the value of one of the fields of a datetime, wrapping within that field.\n+     * <p>\n+     * For example, 2002-03-01 add 14 months gives 2003-05-01. But 2002-03-01 add wrapped\n+     * 14 months gives 2002-05-01. This is similar to the <code>roll</code> method on Calendar.\n+     * <p>\n+     * DateTimeField instances are generally obtained from a {@link Chronology} subclass.\n+     * However, an application can create its own DateTimeField to manipulate the\n+     * date time millis in new ways.\n+     *\n+     * @param field  a DateTimeField instance, usually obtained from a Chronology\n+     * @param value  the value of that field for the millis set in the implementation\n+     */\n+    void addWrapped(DateTimeField field, int value);\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Extends the ReadableInstant interface to support specific datetime fields.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface ReadableDateTime extends ReadableInstant {\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    int getDayOfWeek();\n+\n+    /**\n+     * Get the day of month field value.\n+     * \n+     * @return the day of month\n+     */\n+    int getDayOfMonth();\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    int getDayOfYear();\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    int getWeekOfWeekyear();\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    int getWeekyear();\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    int getMonthOfYear();\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    int getYear();\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    int getYearOfEra();\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    int getYearOfCentury();\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    int getCenturyOfEra();\n+\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    int getEra();\n+\n+    // Time field access methods\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    int getMillisOfSecond();\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    int getMillisOfDay();\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    int getSecondOfMinute();\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    int getSecondOfDay();\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    int getMinuteOfHour();\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    int getMinuteOfDay();\n+\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    int getHourOfDay();\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @return a DateTime using the same millis\n+     */\n+    DateTime toDateTime();\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return a DateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    DateTime toDateTime(DateTimeZone zone);\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a DateTime using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    DateTime toDateTime(Chronology chronology);\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @return a MutableDateTime using the same millis\n+     */\n+    MutableDateTime toMutableDateTime();\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param zone time zone to apply\n+     * @return a MutableDateTime using the same millis\n+     * @throws IllegalArgumentException if the time zone is null\n+     */\n+    MutableDateTime toMutableDateTime(DateTimeZone zone);\n+\n+    /**\n+     * Get this object as a MutableDateTime.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a MutableDateTime using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    MutableDateTime toMutableDateTime(Chronology chronology);\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @return a DateOnly using the same millis\n+     */\n+    //DateOnly toDateOnly();\n+\n+    /**\n+     * Get this object as a DateOnly.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a DateOnly using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    //DateOnly toDateOnly(Chronology chronology);\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @return a TimeOnly using the same millis\n+     */\n+    //TimeOnly toTimeOnly();\n+\n+    /**\n+     * Get this object as a TimeOnly.\n+     * \n+     * @param chronology chronology to apply\n+     * @return a TimeOnly using the same millis\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    //TimeOnly toTimeOnly(Chronology chronology);\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern pattern specification\n+     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     */\n+    String toString(String pattern) throws IllegalArgumentException;\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern pattern specification\n+     * @param locale Locale to use, must not be null\n+     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+     * @throws IllegalArgumentException if the locale is null\n+     */\n+    String toString(String pattern, Locale locale) throws IllegalArgumentException;\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Readable interface for an instant in the datetime continuum. \n+ * <p>\n+ * This interface expresses the datetime as milliseconds from \n+ * 1970-01-01T00:00:00Z.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableInstant extends Comparable {\n+\n+    /**\n+     * Get the value as the number of miliseconds since\n+     * the epoch, 1970-01-01T00:00:00Z.\n+     *\n+     * @return the value as milliseconds\n+     */\n+    long getMillis();\n+\n+    /**\n+     * Gets the chronology of the instant, null if not applicable.\n+     * <p>\n+     * The {@link Chronology} provides conversion from the millisecond\n+     * value to meaningful fields in a particular calendar system.\n+     * \n+     * @return the Chronology, null if not applicable\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Gets the time zone of the instant, null if not applicable.\n+     * \n+     * @return the DateTimeZone, null if not applicable\n+     */\n+    DateTimeZone getDateTimeZone();\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * DateTimeField instances are generally obtained from a {@link Chronology} subclass.\n+     * However, an application can create its own DateTimeField to manipulate the\n+     * date time millis in new ways.\n+     *\n+     * @param field  a DateTimeField instance, usually obtained from a Chronology\n+     * @return the value of that field for the millis set in the implementation\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    int get(DateTimeField field);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the millis will change, the chronology and time zone are kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    ReadableInstant toCopy(long newMillis);\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the chronology will change, the millis are kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    ReadableInstant toCopy(Chronology newChronology);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a simple immutable <code>Instant</code> object.\n+     * <p>\n+     * This can be useful if you don't trust the implementation\n+     * of the interface to be well-behaved, or to get a guaranteed\n+     * immutable object.\n+     *\n+     * @return the value as an <code>Instant</code> object\n+     */\n+    Instant toInstant();\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant and the Chronology. All ReadableInstant\n+     * instances are accepted.\n+     * <p>\n+     * To compare two instants for absolute time (ie. UTC milliseconds \n+     * ignoring the chronology), use {@link #isEqual(ReadableInstant)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    boolean equals(Object readableInstant);\n+\n+    /**\n+     * Gets a hash code for the instant that is compatable with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be as follows:\n+     * <pre>int result = 317;\n+     * result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));\n+     * result = 59 * result + (getChronology() == null ? 0 : getChronology().hashCode());\n+     * return result;</pre>\n+     *\n+     * @return a hash code as defined above\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for ascending\n+     * millisecond instant order. This ordering is inconsistent with\n+     * equals, as it ignores the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return -1 if this is less, 0 if equal or +1 if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    int compareTo(Object readableInstant);\n+\n+    /**\n+     * Is the millisecond value after the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is after the instant passed in\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    boolean isAfter(ReadableInstant readableInstant);\n+\n+    /**\n+     * Is the millisecond value before the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is before the instant passed in\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    boolean isBefore(ReadableInstant readableInstant);\n+    \n+    /**\n+     * Is the millisecond value equal to the millisecond passed in.\n+     *\n+     * @param readableInstant  an instant to check against\n+     * @return true if the instant is equal to the instant passed in\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    boolean isEqual(ReadableInstant readableInstant);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DelegateChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * <code>DelegateChronology</code> delegates each method call to the\n+ * chronology it wraps.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class DelegateChronology extends Chronology {\n+    \n+    /** The Chonology being wrapped */\n+    private final Chronology iChronology;\n+    \n+    /**\n+     * Create a DelegateChronology for any chronology.\n+     *\n+     * @param chrono the chronology\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    protected DelegateChronology(Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        iChronology = chrono;\n+    }\n+    \n+    /**\n+     * Gets the wrapped chronology.\n+     * \n+     * @return the wrapped Chronology\n+     */\n+    protected Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Get the Chronology in the UTC time zone.\n+     * \n+     * @return Chronology in UTC\n+     */\n+    public abstract Chronology withUTC();\n+\n+    /**\n+     * Get the Chronology in the any time zone.\n+     * \n+     * @return Chronology in ant time zone\n+     */\n+    public abstract Chronology withDateTimeZone(DateTimeZone zone);\n+\n+    /**\n+     * Gets the time zone that this chronolog is using.\n+     * \n+     * @return the DateTimeZone\n+     */\n+    public DateTimeZone getDateTimeZone() {\n+        return iChronology.getDateTimeZone();\n+    }\n+\n+    // Millis\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return iChronology.millisOfSecond();\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField millisOfDay() {\n+        return iChronology.millisOfDay();\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return iChronology.secondOfMinute();\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField secondOfDay() {\n+        return iChronology.secondOfDay();\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return iChronology.minuteOfHour();\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return iChronology.minuteOfDay();\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfDay() {\n+        return iChronology.hourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return iChronology.clockhourOfDay();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return iChronology.hourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return iChronology.clockhourOfHalfday();\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return iChronology.halfdayOfDay();\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return iChronology.dayOfWeek();\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return iChronology.dayOfMonth();\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField dayOfYear() {\n+        return iChronology.dayOfYear();\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekyear() {\n+        return iChronology.weekyear();\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField monthOfYear() {\n+        return iChronology.monthOfYear();\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField year() {\n+        return iChronology.year();\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField yearOfEra() {\n+        return iChronology.yearOfEra();\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField yearOfCentury() {\n+        return iChronology.yearOfCentury();\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField centuryOfEra() {\n+        return iChronology.centuryOfEra();\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField era() {\n+        return iChronology.era();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DelegateDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * <code>DelegateDateTimeField</code> delegates each method call to the\n+ * date time field it wraps.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DelegateDateTimeField extends DateTimeField {\n+\n+    private static DateTimeField getField(DateTimeField field) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        return field;\n+    }\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+\n+    protected DelegateDateTimeField(DateTimeField field) {\n+        super(getField(field).getName());\n+        iField = field;\n+    }\n+\n+    protected DelegateDateTimeField(String name, DateTimeField field) {\n+        super(name);\n+        iField = getField(field);\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    protected DateTimeField getDateTimeField() {\n+        return iField;\n+    }\n+\n+    public int get(long millis) {\n+        return iField.get(millis);\n+    }\n+\n+    public String getAsText(long millis, Locale locale) {\n+        return iField.getAsText(millis, locale);\n+    }\n+\n+    public String getAsShortText(long millis, Locale locale) {\n+        return iField.getAsShortText(millis, locale);\n+    }\n+\n+    public long add(long millis, int value) {\n+        return iField.add(millis, value);\n+    }\n+\n+    public long add(long millis, long value) {\n+        return iField.add(millis, value);\n+    }\n+\n+    public long addWrapped(long millis, int value) {\n+        return iField.addWrapped(millis, value);\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    public long set(long millis, int value) {\n+        return iField.set(millis, value);\n+    }\n+\n+    public long set(long millis, String text, Locale locale) {\n+        return iField.set(millis, text, locale);\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        return iField.isLeap(millis);\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        return iField.getLeapAmount(millis);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMinimumValue(long millis) {\n+        return iField.getMinimumValue(millis);\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        return iField.getMaximumValue(millis);\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iField.roundFloor(millis);\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        return iField.roundCeiling(millis);\n+    }\n+\n+    public long roundHalfFloor(long millis) {\n+        return iField.roundHalfFloor(millis);\n+    }\n+\n+    public long roundHalfCeiling(long millis) {\n+        return iField.roundHalfCeiling(millis);\n+    }\n+\n+    public long roundHalfEven(long millis) {\n+        return iField.roundHalfEven(millis);\n+    }\n+\n+    public long remainder(long millis) {\n+        return iField.remainder(millis);\n+    }\n+\n+    public String toString() {\n+        return iField.toString();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Generic division datetime field.\n+ *\n+ * @see RemainderDateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DividedDateTimeField extends DateTimeField {\n+\n+    /** The field to divide */\n+    private final DateTimeField iField;\n+    /** The amount to divide by in the correct units */\n+    private final int iUnitDivisor;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param name  short, descriptive name, like \"century\".\n+     * @param field  the field to wrap, like \"year()\".\n+     * @param unitDivisor  divisor in units, such as 100 years in a century\n+     * @throws IllegalArgumentException if unit is less than two\n+     */\n+    public DividedDateTimeField(String name, DateTimeField field, int unitDivisor) {\n+        super(name);\n+                \n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (unitDivisor < 2) {\n+            throw new IllegalArgumentException(\"The unit divisor must be at least 2\");\n+        }\n+        iField = field;\n+        iUnitDivisor = unitDivisor;\n+\n+        int i = iField.getMinimumValue();\n+        int min = (i >= 0) ? i / unitDivisor : ((i + 1) / unitDivisor - 1);\n+\n+        int j = iField.getMaximumValue();\n+        int max = (j >= 0) ? j / unitDivisor : ((j + 1) / unitDivisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Get the amount of divided units from the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the amount of divided units extracted from the input.\n+     */\n+    public int get(long millis) {\n+        int value = iField.get(millis);\n+        if (value >= 0) {\n+            return value / iUnitDivisor;\n+        } else {\n+            return ((value + 1) / iUnitDivisor) - 1;\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount of divided units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of divided units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int amount) {\n+        return iField.add(millis, amount * iUnitDivisor);\n+    }\n+\n+    /**\n+     * Add the specified amount of divided units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of divided units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long amount) {\n+        return iField.add(millis, amount * iUnitDivisor);\n+    }\n+\n+    /**\n+     * Add to the divided component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of divided units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int amount) {\n+        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iField.getDifference(minuendMillis, subtrahendMillis) / iUnitDivisor;\n+    }\n+\n+    /**\n+     * Set the specified amount of divided units to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param value  value of divided units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long millis, int value) {\n+        verifyValueBounds(value, iMin, iMax);\n+        int remainder = getRemainder(iField.get(millis));\n+        return iField.set(millis, value * iUnitDivisor + remainder);\n+    }\n+\n+    /**\n+     * Returns the wrapped field's unit size multiplied by the unit divisor.\n+     */\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis() * iUnitDivisor;\n+    }\n+\n+    /**\n+     * Returns the wrapped field's range.\n+     */\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+    \n+    public long roundFloor(long millis) {\n+        return iField.roundFloor(iField.set(millis, get(millis) * iUnitDivisor));\n+    }\n+\n+    public long remainder(long millis) {\n+        return set(millis, get(iField.remainder(millis)));\n+    }\n+\n+    /**\n+     * Returns the DateTimeField being wrapped.\n+     * \n+     * @return field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Returns the divisor to apply to the field in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getUnitDivisor() {\n+        return iUnitDivisor;\n+    }\n+\n+    private int getRemainder(int value) {\n+        if (value >= 0) {\n+            return value % iUnitDivisor;\n+        } else {\n+            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/FractionalDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Generic fractional datetime field.\n+ * <p>\n+ * This DateTimeField is useful for extracting a fractional part from the\n+ * milliseconds. This is very useful for time values.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class FractionalDateTimeField extends DateTimeField {\n+\n+    /** The fractional unit in millis */\n+    private final long iUnitMillis;\n+    /** The maximum range in the correct units */\n+    private final int iRange;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  short, descriptive name, like \"secondOfMinute\".\n+     * @param unitMillis  milliseconds per unit, such as 1000 for one second\n+     * @param range  range in units, such as 60 seconds per minute\n+     * @throws IllegalArgumentException if fractional unit is less than one, or if range is\n+     *  less than two.\n+     */\n+    public FractionalDateTimeField(String name, long unitMillis, int range) {\n+        super(name);\n+                \n+        if (unitMillis < 1) {\n+            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n+        }\n+        if (range < 2) {\n+            throw new IllegalArgumentException(\"The range must be at least 2\");\n+        }\n+        iUnitMillis = unitMillis;\n+        iRange = range;\n+    }\n+\n+    /**\n+     * Get the amount of fractional units from the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the amount of fractional units extracted from the input.\n+     */\n+    public int get(long millis) {\n+        if (millis >= 0) {\n+            return (int) ((millis / iUnitMillis) % iRange);\n+        } else {\n+            return iRange - 1 + (int) (((millis + 1) / iUnitMillis) % iRange);\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount of fractional units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int amount) {\n+        return millis + amount * iUnitMillis;\n+    }\n+\n+    /**\n+     * Add the specified amount of fractional units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long amount) {\n+        return millis + amount * iUnitMillis;\n+    }\n+\n+    /**\n+     * Add to the fractional component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int amount) {\n+        int thisValue = get(millis);\n+        int wrappedValue = getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue());\n+        // copy code from set() to avoid repeat call to get()\n+        return millis + (wrappedValue - thisValue) * iUnitMillis;\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return (minuendMillis - subtrahendMillis) / iUnitMillis;\n+    }\n+\n+    /**\n+     * Set the specified amount of fractional units to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param value  value of fractional units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long millis, int value) {\n+        verifyValueBounds(value, getMinimumValue(), getMaximumValue());\n+        return millis + (value - get(millis)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * Returns the milliseconds representing one unit of the field.\n+     * <p>\n+     * For example, 1000 for one second.\n+     * \n+     * @return unit millis\n+     */\n+    public long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    public long getRangeMillis() {\n+        return iRange * iUnitMillis;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iRange - 1;\n+    }\n+    \n+    public long roundFloor(long millis) {\n+        if (millis >= 0) {\n+            return millis - millis % iUnitMillis;\n+        } else {\n+            millis += 1;\n+            return millis - millis % iUnitMillis - iUnitMillis;\n+        }\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        if (millis >= 0) {\n+            millis -= 1;\n+            return millis - millis % iUnitMillis + iUnitMillis;\n+        } else {\n+            return millis - millis % iUnitMillis;\n+        }\n+    }\n+\n+    public long remainder(long millis) {\n+        if (millis >= 0) {\n+            return millis % iUnitMillis;\n+        } else {\n+            return (millis + 1) % iUnitMillis + iUnitMillis - 1;\n+        }\n+    }\n+\n+    /**\n+     * Returns the range of the field in the field's units.\n+     * <p>\n+     * For example, 60 for seconds per minute. The field is allowed values\n+     * from 0 to range - 1.\n+     * \n+     * @return unit range\n+     */\n+    public int getRange() {\n+        return iRange;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Generic limiting datetime field.\n+ * <p>\n+ * This DateTimeField allows specific millisecond boundaries to be applied \n+ * to DateTimeFields.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class LimitDateTimeField extends DateTimeField {\n+\n+    /** The field to wrap */\n+    private final DateTimeField iField;\n+    /** The lower boundary in millis */\n+    private final long iLowerBound;\n+    /** The upper boundary in millis */\n+    private final long iUpperBound;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param name  short, descriptive name, like \"secondOfMinute\".\n+     * @param lowerBound  milliseconds to form the lower boundary inclusive\n+     * @param upperBound  milliseconds to form the upper boundary inclusive\n+     * @throws IllegalArgumentException if field is null or boundary is invalid\n+     */\n+    public LimitDateTimeField(String name, DateTimeField field, long lowerBound, long upperBound) {\n+        super(name);\n+                \n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (lowerBound >= upperBound) {\n+            throw new IllegalArgumentException(\"The lowerBound must be less than the upperBound\");\n+        }\n+        iField = field;\n+        iLowerBound = lowerBound;\n+        iUpperBound = upperBound;\n+    }\n+\n+    /**\n+     * Get the amount of fractional units from the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the amount of fractional units extracted from the input.\n+     */\n+    public int get(long millis) {\n+        checkBounds(millis, \"value\");\n+        return iField.get(millis);\n+    }\n+\n+    public String getAsText(long millis, Locale locale) {\n+        checkBounds(millis, \"value\");\n+        return iField.getAsText(millis, locale);\n+    }\n+\n+    public String getAsShortText(long millis, Locale locale) {\n+        checkBounds(millis, \"value\");\n+        return iField.getAsShortText(millis, locale);\n+    }\n+\n+    /**\n+     * Add the specified amount of fractional units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int amount) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.add(millis, amount);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    /**\n+     * Add the specified amount of fractional units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long amount) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.add(millis, amount);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    /**\n+     * Add to the fractional component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of fractional units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int amount) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.addWrapped(millis, amount);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        checkBounds(minuendMillis, \"minuend\");\n+        checkBounds(subtrahendMillis, \"subtrahend\");\n+        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    /**\n+     * Set the specified amount of fractional units to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param value  value of fractional units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long millis, int value) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.set(millis, value);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long set(long millis, String text, Locale locale) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.set(millis, text, locale);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.roundFloor(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.roundCeiling(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long roundHalfFloor(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.roundHalfFloor(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long roundHalfCeiling(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.roundHalfCeiling(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long roundHalfEven(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.roundHalfEven(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+    public long remainder(long millis) {\n+        checkBounds(millis, \"value\");\n+        long result = iField.remainder(millis);\n+        checkBounds(millis, \"result\");\n+        return result;\n+    }\n+\n+   /**\n+     * Returns the DateTimeField being wrapped.\n+     * \n+     * @return field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Returns the milliseconds lower bound.\n+     * \n+     * @return lower bound\n+     */\n+    public long getLowerBound() {\n+        return iLowerBound;\n+    }\n+\n+    /**\n+     * Returns the milliseconds upper bound.\n+     * \n+     * @return upper bound\n+     */\n+    public long getUpperBound() {\n+        return iUpperBound;\n+    }\n+\n+    private void checkBounds(long millis, String desc) {\n+        if (millis < iLowerBound) {\n+            throw new IllegalArgumentException(\"The millisecond \" + desc + \" is below the minimum\");\n+        }\n+        if (millis > iUpperBound) {\n+            throw new IllegalArgumentException(\"The millisecond \" + desc + \" is above the maximum\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Wraps another field such that zero values are replaced with one more than\n+ * it's maximum. This is particularly useful for implementing an clockhourOfDay\n+ * field, where the midnight value of 0 is replaced with 24.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class NonZeroDateTimeField extends DateTimeField {\n+    private final DateTimeField iField;\n+\n+    /**\n+     * @param name  short, descriptive name, like \"clockhourOfDay\".\n+     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n+     */\n+    public NonZeroDateTimeField(String name, DateTimeField field) {\n+        super(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (field.getMinimumValue() != 0) {\n+            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n+        }\n+        iField = field;\n+    }\n+\n+    public int get(long millis) {\n+        int value = iField.get(millis);\n+        if (value == 0) {\n+            value = getMaximumValue();\n+        }\n+        return value;\n+    }\n+\n+    public long add(long millis, int amount) {\n+        return iField.add(millis, amount);\n+    }\n+\n+    public long add(long millis, long amount) {\n+        return iField.add(millis, amount);\n+    }\n+\n+    public long addWrapped(long millis, int amount) {\n+        return iField.addWrapped(millis, amount);\n+    }\n+    \n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    public long set(long millis, int value) {\n+        int max = getMaximumValue();\n+        verifyValueBounds(value, 1, max);\n+        if (value == max) {\n+            value = 0;\n+        }\n+        return iField.set(millis, value);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(long millis) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue() + 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue(long millis) {\n+        return iField.getMaximumValue(millis) + 1;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iField.roundFloor(millis);\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        return iField.roundCeiling(millis);\n+    }\n+\n+    public long remainder(long millis) {\n+        return iField.remainder(millis);\n+    }\n+\n+    /**\n+     * Returns the DateTimeField being wrapped.\n+     * \n+     * @return field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Generic offset adjusting datetime field.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class OffsetDateTimeField extends DateTimeField {\n+    /** The field to adjust */\n+    private final DateTimeField iField;\n+    private final int iOffset;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param name  short, descriptive name, like \"offsetYear\".\n+     * @param field  the field to wrap, like \"year()\".\n+     * @param offset  offset to add to field values\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(String name, DateTimeField field, int offset) {\n+        this(name, field, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param name  short, descriptive name, like \"offsetYear\".\n+     * @param field  the field to wrap, like \"year()\".\n+     * @param offset  offset to add to field values\n+     * @param minValue  minimum allowed value\n+     * @param maxValue  maximum allowed value\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(String name, DateTimeField field, int offset,\n+                               int minValue, int maxValue) {\n+        super(name);\n+                \n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (offset == 0) {\n+            throw new IllegalArgumentException(\"The offset cannot be zero\");\n+        }\n+\n+        iField = field;\n+        iOffset = offset;\n+\n+        if (minValue < (iField.getMinimumValue() + offset)) {\n+            iMin = iField.getMinimumValue() + offset;\n+        } else {\n+            iMin = minValue;\n+        }\n+        if (maxValue > (iField.getMaximumValue() + offset)) {\n+            iMax = iField.getMaximumValue() + offset;\n+        } else {\n+            iMax = maxValue;\n+        }\n+    }\n+\n+    /**\n+     * Get the amount of offset units from the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the amount of units extracted from the input.\n+     */\n+    public int get(long millis) {\n+        return iField.get(millis) + iOffset;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int amount) {\n+        millis = iField.add(millis, amount);\n+        verifyValueBounds(get(millis), iMin, iMax);\n+        return millis;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long amount) {\n+        millis = iField.add(millis, amount);\n+        verifyValueBounds(get(millis), iMin, iMax);\n+        return millis;\n+    }\n+\n+    /**\n+     * Add to the offset component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int amount) {\n+        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    /**\n+     * Set the specified amount of offset units to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long millis, int value) {\n+        verifyValueBounds(value, iMin, iMax);\n+        return iField.set(millis, value - iOffset);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public long getRangeMillis() {\n+        return iField.getRangeMillis();\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+    \n+    public long roundFloor(long millis) {\n+        return iField.roundFloor(millis);\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        return iField.roundCeiling(millis);\n+    }\n+\n+    public long roundHalfFloor(long millis) {\n+        return iField.roundHalfFloor(millis);\n+    }\n+\n+    public long remainder(long millis) {\n+        return iField.remainder(millis);\n+    }\n+\n+    /**\n+     * Returns the DateTimeField being wrapped.\n+     * \n+     * @return field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Returns the offset added to the field values.\n+     * \n+     * @return the offset\n+     */\n+    public int getOffset() {\n+        return iOffset;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Generic remainder datetime field.\n+ * \n+ * @see DividedDateTimeField\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class RemainderDateTimeField extends DateTimeField {\n+    /** The field to get the remainder */\n+    private final DateTimeField iField;\n+    /** The amount to divide by in the correct units */\n+    private final int iUnitDivisor;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param name  short, descriptive name, like \"yearOfCentury\".\n+     * @param field  the field to wrap, like \"year()\".\n+     * @param unitDivisor  divisor in units, such as 100 years in a century\n+     * @throws IllegalArgumentException if unit is less than two\n+     */\n+    public RemainderDateTimeField(String name, DateTimeField field, int unitDivisor) {\n+        super(name);\n+                \n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (unitDivisor < 2) {\n+            throw new IllegalArgumentException(\"The unit divisor must be at least 2\");\n+        }\n+        iField = field;\n+        iUnitDivisor = unitDivisor;\n+    }\n+\n+    /**\n+     * Get the remainder from the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the remainder extracted from the input.\n+     */\n+    public int get(long millis) {\n+        int value = iField.get(millis);\n+        if (value >= 0) {\n+            return value % iUnitDivisor;\n+        } else {\n+            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);\n+        }\n+    }\n+    \n+    /**\n+     * Add the specified amount to the specified time instant. The amount added\n+     * may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int amount) {\n+        return iField.add(millis, amount);\n+    }\n+    \n+    /**\n+     * Add the specified amount to the specified time instant. The amount added\n+     * may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long amount) {\n+        return iField.add(millis, amount);\n+    }\n+\n+    /**\n+     * Add the specified amount to the specified time instant, wrapping around\n+     * within the remainder range if necessary. The amount added may be\n+     * negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param amount  the amount to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int amount) {\n+        return set(millis, getWrappedValue(get(millis), amount, 0, iUnitDivisor - 1));\n+    }\n+    \n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iField.getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    /**\n+     * Set the specified amount of remainder units to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param value  value of remainder units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long millis, int value) {\n+        verifyValueBounds(value, 0, iUnitDivisor - 1);\n+        int divided = getDivided(iField.get(millis));\n+        return iField.set(millis, divided * iUnitDivisor + value);\n+    }\n+    \n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    /**\n+     * Returns the wrapped field's unit size multiplied by the unit divisor.\n+     */\n+    public long getRangeMillis() {\n+        return iField.getUnitMillis() * iUnitDivisor;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field, which is always zero.\n+     * \n+     * @return the minimum value of zero.\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+    \n+    /**\n+     * Get the maximum value for the field, which is always one less than the\n+     * unit divisor.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iUnitDivisor - 1;\n+    }\n+    \n+    public long roundFloor(long millis) {\n+        return iField.roundFloor(millis);\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        return iField.roundCeiling(millis);\n+    }\n+\n+    public long remainder(long millis) {\n+        return iField.remainder(millis);\n+    }\n+\n+    /**\n+     * Returns the DateTimeField being wrapped.\n+     * \n+     * @return field\n+     */\n+    public DateTimeField getField() {\n+        return iField;\n+    }\n+\n+    /**\n+     * Returns the divisor to apply to the field in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getUnitDivisor() {\n+        return iUnitDivisor;\n+    }\n+\n+    private int getDivided(int value) {\n+        if (value >= 0) {\n+            return value / iUnitDivisor;\n+        } else {\n+            return ((value + 1) / iUnitDivisor) - 1;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Wraps another Chronology for supporting time zones.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class ZonedChronology extends Chronology {\n+    private final Chronology iChronology;\n+    private final DateTimeZone iZone;\n+\n+    private transient DateTimeField iYearField;\n+    private transient DateTimeField iYearOfEraField;\n+    private transient DateTimeField iYearOfCenturyField;\n+    private transient DateTimeField iCenturyOfEraField;\n+    private transient DateTimeField iEraField;\n+    private transient DateTimeField iDayOfWeekField;\n+    private transient DateTimeField iDayOfMonthField;\n+    private transient DateTimeField iDayOfYearField;\n+    private transient DateTimeField iMonthOfYearField;\n+    private transient DateTimeField iWeekOfWeekyearField;\n+    private transient DateTimeField iWeekyearField;\n+\n+    private transient DateTimeField iMillisOfSecondField;\n+    private transient DateTimeField iMillisOfDayField;\n+    private transient DateTimeField iSecondOfMinuteField;\n+    private transient DateTimeField iSecondOfDayField;\n+    private transient DateTimeField iMinuteOfHourField;\n+    private transient DateTimeField iMinuteOfDayField;\n+    private transient DateTimeField iHourOfDayField;\n+    private transient DateTimeField iHourOfHalfdayField;\n+    private transient DateTimeField iClockhourOfDayField;\n+    private transient DateTimeField iClockhourOfHalfdayField;\n+    private transient DateTimeField iHalfdayOfDayField;\n+\n+    /**\n+     * Create a ZonedChronology for any chronology, overriding any time zone it\n+     * may already have.\n+     *\n+     * @param chrono the chronology\n+     * @param zone the time zone\n+     * @throws IllegalArgumentException if chronology or time zone is null\n+     */\n+    public ZonedChronology(Chronology chrono, DateTimeZone zone) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        chrono = chrono.withUTC();\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n+        }\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n+        }\n+\n+        iChronology = chrono;\n+        iZone = zone;\n+        setFields();\n+    }\n+\n+    private void setFields() {\n+        Chronology c = iChronology;\n+        DateTimeZone z = iZone;\n+\n+        iYearField = new ZonedDateField(c.year(), z);\n+        iYearOfEraField = new ZonedDateField(c.yearOfEra(), z);\n+        iYearOfCenturyField = new ZonedDateField(c.yearOfCentury(), z);\n+        iCenturyOfEraField = new ZonedDateField(c.centuryOfEra(), z);\n+        iEraField = new ZonedDateField(c.era(), z);\n+        iDayOfMonthField = new ZonedDateField(c.dayOfMonth(), z);\n+        iDayOfWeekField = new ZonedDateField(c.dayOfWeek(), z);\n+        iDayOfYearField = new ZonedDateField(c.dayOfYear(), z);\n+        iMonthOfYearField = new ZonedDateField(c.monthOfYear(), z);\n+        iWeekOfWeekyearField = new ZonedDateField(c.weekOfWeekyear(), z);\n+        iWeekyearField = new ZonedDateField(c.weekyear(), z);\n+        \n+        iMillisOfSecondField = new ZonedTimeField(c.millisOfSecond(), z);\n+        iMillisOfDayField = new ZonedTimeField(c.millisOfDay(), z);\n+        iSecondOfMinuteField = new ZonedTimeField(c.secondOfMinute(), z);\n+        iSecondOfDayField = new ZonedTimeField(c.secondOfDay(), z);\n+        iMinuteOfHourField = new ZonedTimeField(c.minuteOfHour(), z);\n+        iMinuteOfDayField = new ZonedTimeField(c.minuteOfDay(), z);\n+        iHourOfDayField = new ZonedTimeField(c.hourOfDay(), z);\n+        iHourOfHalfdayField = new ZonedTimeField(c.hourOfHalfday(), z);\n+        iClockhourOfDayField = new ZonedTimeField(c.clockhourOfDay(), z);\n+        iClockhourOfHalfdayField = new ZonedTimeField(c.clockhourOfHalfday(), z);\n+\n+        // Treat halfday as a date field for adds.\n+        iHalfdayOfDayField = new ZonedDateField(c.halfdayOfDay(), z);\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        return iZone;\n+    }\n+\n+    public Chronology withUTC() {\n+        return iChronology;\n+    }\n+\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (zone == iZone) {\n+            return this;\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return iChronology;\n+        }\n+        return new ZonedChronology(iChronology, zone);\n+    }\n+\n+    // Milliseconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField millisOfSecond() {\n+        return iMillisOfSecondField;\n+    }\n+\n+    public DateTimeField millisOfDay() {\n+        return iMillisOfDayField;\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField secondOfMinute() {\n+        return iSecondOfMinuteField;\n+    }\n+\n+    public DateTimeField secondOfDay() {\n+        return iSecondOfDayField;\n+    }\n+\n+    // Minutes\n+    //------------------------------------------------------------\n+\n+    public DateTimeField minuteOfHour() {\n+        return iMinuteOfHourField;\n+    }\n+\n+    public DateTimeField minuteOfDay() {\n+        return iMinuteOfDayField;\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    public DateTimeField hourOfDay() {\n+        return iHourOfDayField;\n+    }\n+\n+    public DateTimeField clockhourOfDay() {\n+        return iClockhourOfDayField;\n+    }\n+\n+    public DateTimeField hourOfHalfday() {\n+        return iHourOfHalfdayField;\n+    }\n+\n+    public DateTimeField clockhourOfHalfday() {\n+        return iClockhourOfHalfdayField;\n+    }\n+\n+    public DateTimeField halfdayOfDay() {\n+        return iHalfdayOfDayField;\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField dayOfWeek() {\n+        return iDayOfWeekField;\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return iDayOfMonthField;\n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        return iDayOfYearField;\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField weekOfWeekyear() {\n+        return iWeekOfWeekyearField;\n+    }\n+\n+    public DateTimeField weekyear() {\n+        return iWeekyearField;\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField monthOfYear() {\n+        return iMonthOfYearField;\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField year() {\n+        return iYearField;\n+    }\n+\n+    public DateTimeField yearOfEra() {\n+        return iYearOfEraField;\n+    }\n+\n+    public DateTimeField yearOfCentury() {\n+        return iYearOfCenturyField;\n+    }\n+\n+    public DateTimeField centuryOfEra() {\n+        return iCenturyOfEraField;\n+    }\n+\n+    public DateTimeField era() {\n+        return iEraField;\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        setFields();\n+    }\n+\n+    /**\n+     * A DateTimeField that decorates another to add timezone behaviour.\n+     * <p>\n+     * This class converts passed in millis to local wall millis, and \n+     * vice versa on output.\n+     */\n+    static class ZonedDateField extends DateTimeField {\n+        final DateTimeField iField;\n+        final DateTimeZone iZone;\n+        \n+        ZonedDateField(DateTimeField field, DateTimeZone zone) {\n+            super(field.getName());\n+            iField = field;\n+            this.iZone = zone;\n+        }\n+        \n+        public int get(long millis) {\n+            return iField.get(millis + this.iZone.getOffset(millis));\n+        }\n+        \n+        public String getAsText(long millis, Locale locale) {\n+            return iField.getAsText(millis + this.iZone.getOffset(millis), locale);\n+        }\n+        \n+        public String getAsShortText(long millis, Locale locale) {\n+            return iField.getAsShortText(millis + this.iZone.getOffset(millis), locale);\n+        }\n+        \n+        public long add(long millis, int value) {\n+            millis = iField.add(millis + this.iZone.getOffset(millis), value);\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+        \n+        public long add(long millis, long value) {\n+            millis = iField.add(millis + this.iZone.getOffset(millis), value);\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+\n+        public long addWrapped(long millis, int value) {\n+            millis = iField.addWrapped(millis + this.iZone.getOffset(millis), value);\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+\n+        public long getDifference(long minuendMillis, long subtrahendMillis) {\n+            return iField.getDifference(minuendMillis + this.iZone.getOffset(minuendMillis),\n+                                        subtrahendMillis + this.iZone.getOffset(subtrahendMillis));\n+        }\n+\n+        public long set(long millis, int value) {\n+            long offset = this.iZone.getOffset(millis);\n+            \n+            millis = iField.set(millis + offset, value);\n+            long offsetFromLocal = this.iZone.getOffsetFromLocal(millis);\n+            millis -= offsetFromLocal;\n+            \n+            if (offset != offsetFromLocal) {\n+                if (get(millis) != value) {\n+                    throw new IllegalArgumentException\n+                        (\"Illegal value for \" + iField.getName() + \": \" + value);\n+                }\n+            }\n+            \n+            return millis;\n+        }\n+        \n+        public long set(long millis, String text, Locale locale) {\n+            millis = iField.set(millis + this.iZone.getOffset(millis), text, locale);\n+            // Cannot verify that new value stuck because set may be lenient.\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+        \n+        public boolean isLeap(long millis) {\n+            return iField.isLeap(millis + this.iZone.getOffset(millis));\n+        }\n+\n+        public int getLeapAmount(long millis) {\n+            return iField.getLeapAmount(millis + this.iZone.getOffset(millis));\n+        }\n+        \n+        public long getUnitMillis() {\n+            return iField.getUnitMillis();\n+        }\n+\n+        public long getRangeMillis() {\n+            return iField.getRangeMillis();\n+        }\n+\n+        public int getMinimumValue() {\n+            return iField.getMinimumValue();\n+        }\n+        \n+        public int getMinimumValue(long millis) {\n+            return iField.getMinimumValue(millis + this.iZone.getOffset(millis));\n+        }\n+        \n+        public int getMaximumValue() {\n+            return iField.getMaximumValue();\n+        }\n+        \n+        public int getMaximumValue(long millis) {\n+            return iField.getMaximumValue(millis + this.iZone.getOffset(millis));\n+        }\n+        \n+        public long roundFloor(long millis) {\n+            millis = iField.roundFloor(millis + this.iZone.getOffset(millis));\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+        \n+        public long roundCeiling(long millis) {\n+            millis = iField.roundCeiling(millis + this.iZone.getOffset(millis));\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+\n+        public long remainder(long millis) {\n+            millis = iField.remainder(millis + this.iZone.getOffset(millis));\n+            return millis - this.iZone.getOffsetFromLocal(millis);\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return iField.getMaximumTextLength(locale);\n+        }\n+        \n+        public int getMaximumShortTextLength(Locale locale) {\n+            return iField.getMaximumShortTextLength(locale);\n+        }\n+    }\n+\n+    static class ZonedTimeField extends ZonedDateField {\n+        ZonedTimeField(DateTimeField field, DateTimeZone zone) {\n+            super(field, zone);\n+        }\n+\n+        // Because time fields are smaller than time zone offsets, override the\n+        // arithmetic methods to follow more expected behavior when crossing\n+        // time zone offset transitions. The original add method can nullify or\n+        // reverse an add when crossing a transition.\n+\n+        public long add(long millis, int value) {\n+            int offset = this.iZone.getOffset(millis);\n+            return iField.add(millis + offset, value) - offset;\n+        }\n+        \n+        public long add(long millis, long value) {\n+            int offset = this.iZone.getOffset(millis);\n+            return iField.add(millis + offset, value) - offset;\n+        }\n+\n+        public long addWrapped(long millis, int value) {\n+            int offset = this.iZone.getOffset(millis);\n+            return iField.addWrapped(millis + offset, value) - offset;\n+        }\n+\n+        public long getDifference(long minuendMillis, long subtrahendMillis) {\n+            int offset = this.iZone.getOffset(subtrahendMillis);\n+            return iField.getDifference(minuendMillis + offset, subtrahendMillis + offset);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.buddhist;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.DelegateChronology;\n+import org.joda.time.chrono.OffsetDateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+\n+/**\n+ * <code>BuddhistChronology</code> provides access to the individual date\n+ * time fields for the Buddhist chronological calendar system.\n+ * <p>\n+ * The Buddhist calendar differs from the GregorianJulian calendar only \n+ * in the year. This class is compatable with the BuddhistCalendar class \n+ * supplied by Sun.\n+ * <p>\n+ * At present the century fields are unsupported.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class BuddhistChronology extends DelegateChronology {\n+    \n+    /**\n+     * Constant value for 'Buddhist Era', equivalent to the value returned\n+     * for AD/CE.\n+     */\n+    public static final int BE = DateTimeConstants.CE;\n+\n+    /** Number of years difference in calendars. */\n+    private static final int BUDDHIST_OFFSET = 543;\n+\n+    /** UTC instance of the chronology */\n+    private static final BuddhistChronology INSTANCE_UTC =\n+        new BuddhistChronology(GJChronology.getInstance(DateTimeZone.UTC, null, false));\n+\n+    /** Cache of zone to chronology */\n+    private static final Map cCache = new HashMap();\n+    static {\n+        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     * <p>\n+     * The time zone of the returned instance is UTC.\n+     */\n+    public static BuddhistChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     */\n+    public static BuddhistChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @throws IllegalArgumentException if the zone is null\n+     */\n+    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);\n+        if (chrono == null) {\n+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null, false));\n+            cCache.put(zone, chrono);\n+        }\n+        return chrono;\n+    }\n+    \n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    // Fields are transient because readResolve will always return a cached instance.\n+    private transient DateTimeField iYearField;\n+    private transient DateTimeField iWeekyearField;\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private BuddhistChronology(GJChronology gjChronology) {\n+        super(gjChronology);\n+        DateTimeField field = gjChronology.year();\n+        iYearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);\n+        field = gjChronology.weekyear();\n+        iWeekyearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);\n+        // All other fields delegated to GJ\n+    }\n+    \n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getChronology().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     *\n+     * @return DateTimeField\n+     */\n+    public DateTimeField weekyear() {\n+        return iWeekyearField;\n+    }\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField year() {\n+        // TODO block negative years\n+        return iYearField;\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField yearOfEra() {\n+        // TODO block negative years\n+        return iYearField;\n+    }\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException always\n+     */\n+    public DateTimeField yearOfCentury() {\n+        // TODO\n+        throw new UnsupportedOperationException(\"yearOfCentury is unsupported for \" + getClass().getName());\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     * @throws UnsupportedOperationException always\n+     */\n+    public DateTimeField centuryOfEra() {\n+        // TODO\n+        throw new UnsupportedOperationException(\"centuryOfEra is unsupported for \" + getClass().getName());\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField\n+     */\n+    public DateTimeField era() {\n+        return BuddhistEraDateTimeField.INSTANCE;\n+    }\n+    \n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        DateTimeZone zone = getDateTimeZone();\n+        return \"BuddhistChronology[\" + (zone == null ? \"\" : zone.getID()) + \"]\";\n+    }\n+   \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.buddhist;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the buddhist era component of time.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class BuddhistEraDateTimeField extends DateTimeField {\n+    \n+    /**\n+     * Singleton instance of BuddhistYearDateTimeField\n+     */\n+    static final DateTimeField INSTANCE = new BuddhistEraDateTimeField();\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private BuddhistEraDateTimeField() {\n+        super(\"era\");\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the era extracted from the input.\n+     */\n+    public int get(long millis) {\n+        return BuddhistChronology.BE;\n+    }\n+\n+    /**\n+     * Unsupported - add the specified eras to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int era) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported - add the specified eras to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, long era) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported - add the specified eras to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param era  the era to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int era) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        throw new UnsupportedOperationException(\"Era field difference is unsupported\");\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param era  the era (BuddhistChonology.BE) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long millis, int era) {\n+        super.verifyValueBounds(era, getMinimumValue(), getMaximumValue());\n+\n+        return millis;\n+    }\n+\n+    public long getUnitMillis() {\n+        // Should actually be double this, but that is not possible since Java\n+        // doesn't support unsigned types.\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public long getRangeMillis() {\n+        // Should actually be double this, but that is not possible since Java\n+        // doesn't support unsigned types.\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+\n+    public int getMaximumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsShortText(long millis, Locale locale) {\n+        return \"BE\";\n+    }\n+    \n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)\n+     */\n+    public String getAsText(long millis, Locale locale) {\n+        return \"BE\";\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return 2;\n+    }\n+\n+    /**\n+     * @see org.joda.time.DateTimeField#set(long, String, Locale)\n+     */\n+    public long set(long millis, String text, Locale locale) {\n+        if (\"BE\".equals(text) == false) {\n+            throw new IllegalArgumentException(\"Invalid era text: \" + text);\n+        }\n+        return millis;    \n+    }\n+    \n+\n+    /**\n+     * Unsupported.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public long roundFloor(long millis) {\n+        throw new UnsupportedOperationException(\"Rounding an Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public long remainder(long millis) {\n+        throw new UnsupportedOperationException(\"Calculating remainder from Era field is unsupported\");\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Chronology for supporting the cutover from the Julian calendar to the\n+ * Gregorian calendar.\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class CutoverChronology extends GJChronology {\n+    /**\n+     * Convert a datetime from one chronology to another.\n+     */\n+    private static long convert(long millis, Chronology from, Chronology to) {\n+        if (from == to) {\n+            return millis;\n+        }\n+\n+        int year = from.year().get(millis);\n+        int monthOfYear = from.monthOfYear().get(millis);\n+        int dayOfMonth = from.dayOfMonth().get(millis);\n+        int millisOfDay = from.millisOfDay().get(millis);\n+\n+        millis = to.year().set(0, year);\n+        millis = to.monthOfYear().set(millis, monthOfYear);\n+        millis = to.dayOfMonth().set(millis, dayOfMonth);\n+        millis = to.millisOfDay().set(millis, millisOfDay);\n+\n+        return millis;\n+    }\n+\n+    private static void checkUTC(Chronology chrono) {\n+        if (chrono.getDateTimeZone() != null &&\n+            chrono.getDateTimeZone() != DateTimeZone.UTC) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    private final GJChronology iJulianChronology;\n+    private final GJChronology iGregorianChronology;\n+\n+    final long iCutoverMillis;\n+    transient final long iGapMillis;\n+\n+    /**\n+     * @param julian chronology used before the cutover instant\n+     * @param gregorian chronology used at and after the cutover instant\n+     * @param cutoverMillis instant when the gregorian chronology began\n+     */\n+    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverMillis) {\n+        checkUTC(julian);\n+        checkUTC(gregorian);\n+\n+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (julian.isCenturyISO() != gregorian.isCenturyISO()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        iJulianChronology = julian;\n+        iGregorianChronology = gregorian;\n+        iCutoverMillis = cutoverMillis;\n+\n+        // Compute difference between the chronologies at the cutover instant\n+        iGapMillis = cutoverMillis - julianToGregorian(cutoverMillis);\n+\n+        // Begin field definitions.\n+\n+        // Assuming cutover is at midnight, all time of day fields can be\n+        // gregorian since they are unaffected by cutover.\n+        iMillisOfSecondField = gregorian.millisOfSecond();\n+        iMillisOfDayField = gregorian.millisOfDay();\n+        iSecondOfMinuteField = gregorian.secondOfMinute();\n+        iSecondOfDayField = gregorian.secondOfDay();\n+        iMinuteOfHourField = gregorian.minuteOfHour();\n+        iMinuteOfDayField = gregorian.minuteOfDay();\n+        iHourOfDayField = gregorian.hourOfDay();\n+        iHourOfHalfdayField = gregorian.hourOfHalfday();\n+        iClockhourOfDayField = gregorian.clockhourOfDay();\n+        iClockhourOfHalfdayField = gregorian.clockhourOfHalfday();\n+        iHalfdayOfDayField = gregorian.halfdayOfDay();\n+\n+        // Verify assumption.\n+        if (gregorian.millisOfDay().get(cutoverMillis) == 0) {\n+            // Cutover is sometime in the day, so cutover fields are required\n+            // for time of day.\n+\n+            iMillisOfSecondField = new CutoverField(julian.millisOfSecond(), iMillisOfSecondField);\n+            iMillisOfDayField = new CutoverField(julian.millisOfDay(), iMillisOfDayField);\n+            iSecondOfMinuteField = new CutoverField(julian.secondOfMinute(), iSecondOfMinuteField);\n+            iSecondOfDayField = new CutoverField(julian.secondOfDay(), iSecondOfDayField);\n+            iMinuteOfHourField = new CutoverField(julian.minuteOfHour(), iMinuteOfHourField);\n+            iMinuteOfDayField = new CutoverField(julian.minuteOfDay(), iMinuteOfDayField);\n+            iHourOfDayField = new CutoverField(julian.hourOfDay(), iHourOfDayField);\n+            iHourOfHalfdayField = new CutoverField(julian.hourOfHalfday(), iHourOfHalfdayField);\n+            iClockhourOfDayField = new CutoverField(julian.clockhourOfDay(), iClockhourOfDayField);\n+            iClockhourOfHalfdayField = new CutoverField(julian.clockhourOfHalfday(), iClockhourOfHalfdayField);\n+            iHalfdayOfDayField = new CutoverField(julian.halfdayOfDay(), iHalfdayOfDayField);\n+        }\n+\n+        // These fields just require basic cutover support.\n+        iEraField = new CutoverField(julian.era(), gregorian.era());\n+        iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());\n+\n+        // These fields require special attention when add is called since they\n+        // internally call set.\n+        iYearField = new CutoverVarField(julian.year(), gregorian.year());\n+        iYearOfEraField = new CutoverVarField(julian.yearOfEra(), gregorian.yearOfEra());\n+        iYearOfCenturyField = new CutoverVarField(julian.yearOfCentury(), gregorian.yearOfCentury());\n+        iCenturyOfEraField = new CutoverVarField(julian.centuryOfEra(), gregorian.centuryOfEra());\n+        iMonthOfYearField = new CutoverVarField(julian.monthOfYear(), gregorian.monthOfYear());\n+        iWeekyearField = new CutoverVarField(julian.weekyear(), gregorian.weekyear());\n+\n+        // DayOfYear and weekOfWeekyear require special handling since cutover\n+        // year has fewer days and weeks. Extend the cutover to the start of\n+        // the next year or weekyear. This keeps the sequence unbroken during\n+        // the cutover year.\n+\n+        {\n+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n+            iDayOfYearField = new CutoverField\n+                (julian.dayOfYear(), gregorian.dayOfYear(), cutover);\n+        }\n+\n+        {\n+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n+            iWeekOfWeekyearField = new CutoverField\n+                (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover);\n+        }\n+\n+        // Day of week is unaffected by cutover. Either julian or gregorian will work.\n+        iDayOfWeekField = gregorian.dayOfWeek();\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return iCutoverMillis;\n+    }\n+\n+    public boolean isCenturyISO() {\n+        return iGregorianChronology.isCenturyISO();\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iGregorianChronology.getMinimumDaysInFirstWeek();\n+    }\n+\n+    long julianToGregorian(long millis) {\n+        return convert(millis, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulian(long millis) {\n+        return convert(millis, iGregorianChronology, iJulianChronology);\n+    }\n+\n+    /**\n+     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n+     * assumes that calls to add and addWrapped are unaffected by the cutover.\n+     */\n+    private class CutoverField extends DateTimeField {\n+        final DateTimeField iJulianField;\n+        final DateTimeField iGregorianField;\n+        final long iCutover;\n+\n+        /**\n+         * @param julianField field from the chronology used before the cutover instant\n+         * @param gregorianField field from the chronology used at and after the cutover\n+         */\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField) {\n+            super(gregorianField.getName());\n+            iJulianField = julianField;\n+            iGregorianField = gregorianField;\n+            iCutover = iCutoverMillis;\n+        }\n+\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n+            super(gregorianField.getName());\n+            iJulianField = julianField;\n+            iGregorianField = gregorianField;\n+            iCutover = cutoverMillis;\n+        }\n+\n+        public int get(long millis) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.get(millis);\n+            } else {\n+                return iJulianField.get(millis);\n+            }\n+        }\n+\n+        public String getAsText(long millis, Locale locale) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.getAsText(millis, locale);\n+            } else {\n+                return iJulianField.getAsText(millis, locale);\n+            }\n+        }\n+\n+        public String getAsShortText(long millis, Locale locale) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.getAsShortText(millis, locale);\n+            } else {\n+                return iJulianField.getAsShortText(millis, locale);\n+            }\n+        }\n+\n+        public long add(long millis, int value) {\n+            return iGregorianField.add(millis, value);\n+        }\n+\n+        public long add(long millis, long value) {\n+            return iGregorianField.add(millis, value);\n+        }\n+\n+        public long addWrapped(long millis, int value) {\n+            return iGregorianField.addWrapped(millis, value);\n+        }\n+\n+        public long getDifference(long minuendMillis, long subtrahendMillis) {\n+            return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n+        }\n+\n+        public long set(long millis, int value) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.set(millis, value);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(millis) != value) {\n+                        throw new IllegalArgumentException\n+                            (\"Illegal value for \" + iGregorianField.getName() + \": \" + value);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.set(millis, value);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(millis) != value) {\n+                        throw new IllegalArgumentException\n+                            (\"Illegal value for \" + iJulianField.getName() + \": \" + value);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.set(millis, text, locale);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            } else {\n+                millis = iJulianField.set\n+                    (millis, text, locale);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public boolean isLeap(long millis) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.isLeap(millis);\n+            } else {\n+                return iJulianField.isLeap(millis);\n+            }\n+        }\n+\n+        public int getLeapAmount(long millis) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.getLeapAmount(millis);\n+            } else {\n+                return iJulianField.getLeapAmount(millis);\n+            }\n+        }\n+\n+        public long getUnitMillis() {\n+            // Since getUnitSize doesn't accept a millis argument, return\n+            // Gregorian unit size because it is more accurate.\n+            return iGregorianField.getUnitMillis();\n+        }\n+\n+        public long getRangeMillis() {\n+            return iGregorianField.getRangeMillis();\n+        }\n+\n+        // Note on getMinimumValue and getMaximumValue: For all fields but\n+        // year, yearOfEra, and centuryOfEra, the Julian and Gregorian limits\n+        // are identical. The Julian limit is returned for getMaximumValue\n+        // because it is smaller than the Gregorian limit. This is to prevent\n+        // calling a field mutator that advances so far beyond the gap that the\n+        // Julian calendar overflows.\n+\n+        public int getMinimumValue() {\n+            return iJulianField.getMinimumValue();\n+        }\n+        \n+        public int getMinimumValue(long millis) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.getMinimumValue(millis);\n+            } else {\n+                return iJulianField.getMinimumValue(millis);\n+            }\n+        }\n+\n+        public int getMaximumValue() {\n+            return iJulianField.getMaximumValue();\n+        }\n+\n+        public int getMaximumValue(long millis) {\n+            if (millis >= iCutover) {\n+                return iGregorianField.getMaximumValue(millis);\n+            } else {\n+                return iJulianField.getMaximumValue(millis);\n+            }\n+        }\n+\n+        public long roundFloor(long millis) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.roundFloor(millis);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.roundFloor(millis);\n+            }\n+            return millis;\n+        }\n+\n+        public long roundCeiling(long millis) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.roundCeiling(millis);\n+            } else {\n+                millis = iJulianField.roundCeiling(millis);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public long remainder(long millis) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.remainder(millis);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.remainder(millis);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumTextLength(locale),\n+                            iGregorianField.getMaximumTextLength(locale));\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n+                            iGregorianField.getMaximumShortTextLength(locale));\n+        }\n+    }\n+\n+    /**\n+     * Cutover field for variable length fields. These fields internally call\n+     * set whenever add is called. As a result, the same correction applied to\n+     * set must be applied to add and addWrapped. Knowing when to use this\n+     * field requires specific knowledge of how the GJ fields are implemented.\n+     */\n+    private class CutoverVarField extends CutoverField {\n+        CutoverVarField(DateTimeField julianField, DateTimeField gregorianField) {\n+            super(julianField, gregorianField);\n+        }\n+\n+        public long add(long millis, int value) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.add(millis, value);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.add(millis, value);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+        \n+        public long add(long millis, long value) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.add(millis, value);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.add(millis, value);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public long addWrapped(long millis, int value) {\n+            if (millis >= iCutover) {\n+                millis = iGregorianField.addWrapped(millis, value);\n+                if (millis < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis + iGapMillis < iCutover) {\n+                        millis = gregorianToJulian(millis);\n+                    }\n+                }\n+            } else {\n+                millis = iJulianField.addWrapped(millis, value);\n+                if (millis >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (millis - iGapMillis >= iCutover) {\n+                        millis = julianToGregorian(millis);\n+                    }\n+                }\n+            }\n+            return millis;\n+        }\n+\n+        public long getDifference(long minuendMillis, long subtrahendMillis) {\n+            if (minuendMillis >= iCutover) {\n+                if (subtrahendMillis >= iCutover) {\n+                    return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendMillis = gregorianToJulian(minuendMillis);\n+                return iJulianField.getDifference(minuendMillis, subtrahendMillis);\n+            } else {\n+                if (subtrahendMillis < iCutover) {\n+                    return iJulianField.getDifference(minuendMillis, subtrahendMillis);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendMillis = julianToGregorian(minuendMillis);\n+                return iGregorianField.getDifference(minuendMillis, subtrahendMillis);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.OffsetDateTimeField;\n+import org.joda.time.chrono.DividedDateTimeField;\n+import org.joda.time.chrono.NonZeroDateTimeField;\n+\n+/**\n+ * Chronology for supporting GJ style centuries. Century 1 begin on year 1, and\n+ * century of year ranges from 1 to 100.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class GJCenturyChronology extends GJChronology {\n+    private final GJChronology iChronology;\n+\n+    /**\n+     * @param chrono wrapped chronology\n+     */\n+    public GJCenturyChronology(GJChronology chrono) {\n+        if (chrono.getDateTimeZone() != null &&\n+            chrono.getDateTimeZone() != DateTimeZone.UTC) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (!chrono.isCenturyISO()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        iChronology = chrono;\n+\n+        iYearField = chrono.year();\n+        iYearOfEraField = chrono.yearOfEra();\n+        iEraField = chrono.era();\n+        iDayOfMonthField = chrono.dayOfMonth();\n+        iDayOfWeekField = chrono.dayOfWeek();\n+        iDayOfYearField = chrono.dayOfYear();\n+        iMonthOfYearField = chrono.monthOfYear();\n+        iWeekOfWeekyearField = chrono.weekOfWeekyear();\n+        iWeekyearField = chrono.weekyear();\n+\n+        iMillisOfSecondField = chrono.millisOfSecond();\n+        iMillisOfDayField = chrono.millisOfDay();\n+        iSecondOfMinuteField = chrono.secondOfMinute();\n+        iSecondOfDayField = chrono.secondOfDay();\n+        iMinuteOfHourField = chrono.minuteOfHour();\n+        iMinuteOfDayField = chrono.minuteOfDay();\n+        iHourOfDayField = chrono.hourOfDay();\n+        iHourOfHalfdayField = chrono.hourOfHalfday();\n+        iClockhourOfDayField = chrono.clockhourOfDay();\n+        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();\n+        iHalfdayOfDayField = chrono.halfdayOfDay();\n+\n+        DateTimeField offsetYear =\n+            new OffsetDateTimeField(\"yearOfEra\", iYearOfEraField, 99);\n+        iCenturyOfEraField =\n+            new DividedDateTimeField(\"centuryOfEra\", offsetYear, 100);\n+        iYearOfCenturyField =\n+            new NonZeroDateTimeField(\"yearOfCentury\", chrono.yearOfCentury());\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return iChronology.getGregorianJulianCutoverMillis();\n+    }\n+    \n+    public boolean isCenturyISO() {\n+        return false;\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iChronology.getMinimumDaysInFirstWeek();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.SoftReference;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * GJChronology provides access to the individual date time fields \n+ * for the Gregorian/Julian defined chronological calendar system.\n+ * <p>\n+ * The Gregorian calendar replaced the Julian calendar, and the point in time\n+ * when this chronology switches can be controlled using the second parameter\n+ * of the getInstance method. By default this cutover is set to the date the\n+ * Gregorian calendar was first instituted, October 15, 1582.\n+ * <p>\n+ * Before this date, this chronology uses the proleptic Julian calendar\n+ * (proleptic means extending indefinitely). The Julian calendar has leap \n+ * years every four years, whereas the Gregorian has special rules for 100 \n+ * and 400 years. A meaningful result will thus be obtained for all input \n+ * values. However before March 1, 4 CE, Julian leap years were irregular,\n+ * and before 45 BCE there was no Julian calendar.\n+ * <p>\n+ * This chronology differs from {@link java.util.GregorianCalendar\n+ * java.util.GregorianCalendar} in that years in BCE are returned\n+ * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra\n+ * field produces results compatible with GregorianCalendar.\n+ * <p>\n+ * The Julian calendar does not have a year zero, and so year -1 is followed by\n+ * year 1. If the Gregorian cutover date is specified at or before year -1\n+ * (Julian), year zero is defined. In other words, the proleptic Gregorian\n+ * chronology implemented by this class has a year zero.\n+ * <p>\n+ * A pure proleptic Gregorian chronology is obtained by specifying a cutover of\n+ * Long.MIN_VALUE. Likewise, a pure Julian chronology is obtained with a\n+ * cutover of Long.MAX_VALUE.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class GJChronology extends Chronology {\n+    /**\n+     * The default GregorianJulian cutover point\n+     */\n+    static final long DEFAULT_CUTOVER = -12219292800000L;\n+\n+    // Cache that maps DateTimeZones to Factory instances.\n+    private static HashMap cZonesToFactories = new HashMap();\n+\n+    transient DateTimeField iYearField;\n+    transient DateTimeField iYearOfEraField;\n+    transient DateTimeField iYearOfCenturyField;\n+    transient DateTimeField iCenturyOfEraField;\n+    transient DateTimeField iEraField;\n+    transient DateTimeField iDayOfWeekField;\n+    transient DateTimeField iDayOfMonthField;\n+    transient DateTimeField iDayOfYearField;\n+    transient DateTimeField iMonthOfYearField;\n+    transient DateTimeField iWeekOfWeekyearField;\n+    transient DateTimeField iWeekyearField;\n+\n+    transient DateTimeField iMillisOfSecondField;\n+    transient DateTimeField iMillisOfDayField;\n+    transient DateTimeField iSecondOfMinuteField;\n+    transient DateTimeField iSecondOfDayField;\n+    transient DateTimeField iMinuteOfHourField;\n+    transient DateTimeField iMinuteOfDayField;\n+    transient DateTimeField iHourOfDayField;\n+    transient DateTimeField iHourOfHalfdayField;\n+    transient DateTimeField iClockhourOfDayField;\n+    transient DateTimeField iClockhourOfHalfdayField;\n+    transient DateTimeField iHalfdayOfDayField;\n+\n+    /**\n+     * Factory method returns instances of the default GJ chronology. This uses\n+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n+     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n+     * (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * <p>The time zone of the returned instance is UTC.\n+     */\n+    public static GJChronology getInstanceUTC() {\n+        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, false);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the default GJ chronology. This uses\n+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n+     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n+     * (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * <p>The returned chronology is in the default time zone.\n+     */\n+    public static GJChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, false);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the default GJ chronology. This uses\n+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n+     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n+     * (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     */\n+    public static GJChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, DEFAULT_CUTOVER, false);\n+    }\n+\n+    /**\n+     * Factory method allowing the Gregorian cutover point and year zero\n+     * handling to be set. If the cutover millis is Long.MIN_VALUE, a proleptic\n+     * Gregorian calendar is returned. If the cutover millis is Long.MAX_VALUE,\n+     * a proleptic Julian calendar is returned.\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover as a ReadableInstant, null means default\n+     * @param centuryISO  when true, century related fields follow ISO rules\n+     */\n+    public static GJChronology getInstance(DateTimeZone zone,\n+                                           ReadableInstant gregorianCutover,\n+                                           boolean centuryISO)\n+    {\n+        return getInstance(zone, gregorianCutover, centuryISO, 4);\n+    }\n+    \n+    /**\n+     * Factory method allowing the Gregorian cutover point and year zero\n+     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic\n+     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a\n+     * proleptic Julian calendar is returned.\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the\n+     * first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z\n+     * @param centuryISO  when true, century related fields follow ISO rules\n+     */\n+    public static synchronized GJChronology getInstance(DateTimeZone zone,\n+                                                        long gregorianCutover,\n+                                                        boolean centuryISO)\n+    {\n+        return getInstance(zone, gregorianCutover, centuryISO, 4);\n+    }\n+\n+    /**\n+     * Factory method allowing the Gregorian cutover point and year zero\n+     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic\n+     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a\n+     * proleptic Julian calendar is returned.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover as a ReadableInstant, null means default\n+     * @param centuryISO  when true, century related fields follow ISO rules\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4\n+     */\n+    public static synchronized GJChronology getInstance(DateTimeZone zone,\n+                                                        ReadableInstant gregorianCutover,\n+                                                        boolean centuryISO,\n+                                                        int minDaysInFirstWeek)\n+    {\n+        long millis;\n+        if (gregorianCutover != null) {\n+            millis = gregorianCutover.getMillis();\n+        } else {\n+            millis = DEFAULT_CUTOVER;\n+        }\n+        return getInstance(zone, millis, centuryISO, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Factory method allowing the Gregorian cutover point and year zero\n+     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic\n+     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a\n+     * proleptic Julian calendar is returned.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z\n+     * @param centuryISO  when true, century related fields follow ISO rules\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4\n+     */\n+    public static synchronized GJChronology getInstance(DateTimeZone zone,\n+                                                        long gregorianCutover,\n+                                                        boolean centuryISO,\n+                                                        int minDaysInFirstWeek)\n+    {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+\n+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n+            throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+        }\n+\n+        Factory factory;\n+        getFactory: {\n+            SoftReference ref = (SoftReference)cZonesToFactories.get(zone);\n+            if (ref != null) {\n+                factory = (Factory)ref.get();\n+                if (factory != null) {\n+                    break getFactory;\n+                }\n+            }\n+            factory = new Factory(zone);\n+            cZonesToFactories.put(zone, new SoftReference(factory));\n+        }\n+\n+        return factory.getInstance(gregorianCutover, centuryISO, minDaysInFirstWeek);\n+    }\n+\n+    GJChronology() {\n+        super();\n+    }\n+\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The DateTimeZone must not be null\");\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return withUTC();\n+        }\n+        return getInstance(zone, getGregorianJulianCutoverMillis(),\n+                           isCenturyISO(), getMinimumDaysInFirstWeek());\n+    }\n+\n+    // This method is overridden by GJZonedChronology.\n+    public DateTimeZone getDateTimeZone() {\n+        return DateTimeZone.UTC;\n+    }\n+\n+    /**\n+     * Gets the cutover instant between Gregorian and Julian chronologies.\n+     * @return the cutover instant\n+     */\n+    public Instant getGregorianJulianCutover() {\n+        return new Instant(getGregorianJulianCutoverMillis());\n+    }\n+    \n+    /**\n+     * Gets the cutover millis between Gregorian and Julian chronologies.\n+     * @return the cutover millis\n+     */\n+    public abstract long getGregorianJulianCutoverMillis();\n+    \n+    /**\n+     * Returns true when century fields follow ISO rules. In ISO rules, the\n+     * century is simply the year divided by 100, and the year of century is\n+     * the remainder.\n+     * <p>\n+     * When false is returned, the first century is defined to start on year\n+     * one, and the year of century can range from 1 to 100.\n+     */\n+    public abstract boolean isCenturyISO();\n+\n+    public abstract int getMinimumDaysInFirstWeek();\n+    \n+    // Milliseconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField millisOfSecond() {\n+        return iMillisOfSecondField;\n+    }\n+\n+    public DateTimeField millisOfDay() {\n+        return iMillisOfDayField;\n+    }\n+\n+    // Seconds\n+    //------------------------------------------------------------\n+\n+    public DateTimeField secondOfMinute() {\n+        return iSecondOfMinuteField;\n+    }\n+\n+    public DateTimeField secondOfDay() {\n+        return iSecondOfDayField;\n+    }\n+\n+    public DateTimeField minuteOfHour() {\n+        return iMinuteOfHourField;\n+    }\n+\n+    public DateTimeField minuteOfDay() {\n+        return iMinuteOfDayField;\n+    }\n+\n+    // Hours\n+    //------------------------------------------------------------\n+\n+    public DateTimeField hourOfDay() {\n+        return iHourOfDayField;\n+    }\n+\n+    public DateTimeField clockhourOfDay() {\n+        return iClockhourOfDayField;\n+    }\n+\n+    public DateTimeField hourOfHalfday() {\n+        return iHourOfHalfdayField;\n+    }\n+\n+    public DateTimeField clockhourOfHalfday() {\n+        return iClockhourOfHalfdayField;\n+    }\n+\n+    public DateTimeField halfdayOfDay() {\n+        return iHalfdayOfDayField;\n+    }\n+\n+    // Day\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField dayOfWeek() {\n+        return iDayOfWeekField;\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return iDayOfMonthField;\n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        return iDayOfYearField;\n+    }\n+\n+    // Week\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField weekOfWeekyear() {\n+        return iWeekOfWeekyearField;\n+    }\n+\n+    public DateTimeField weekyear() {\n+        return iWeekyearField;\n+    }\n+\n+    // Month\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField monthOfYear() {\n+        return iMonthOfYearField;\n+    }\n+\n+    // Year\n+    //------------------------------------------------------------\n+    \n+    public DateTimeField year() {\n+        return iYearField;\n+    }\n+\n+    public DateTimeField yearOfEra() {\n+        return iYearOfEraField;\n+    }\n+\n+    public DateTimeField yearOfCentury() {\n+        return iYearOfCenturyField;\n+    }\n+\n+    public DateTimeField centuryOfEra() {\n+        return iCenturyOfEraField;\n+    }\n+\n+    public DateTimeField era() {\n+        return iEraField;\n+    }\n+\n+    /**\n+     * Serialize GJChronology instances using a small stub. This reduces the\n+     * serialized size, and deserialized instances come from the cache.\n+     *\n+     * <p>This method is intentionally package-private in order for sub-classes\n+     * to inherit this method.\n+     */\n+    Object writeReplace() {\n+        return new Stub(getDateTimeZone(),\n+                        getGregorianJulianCutoverMillis(),\n+                        isCenturyISO(),\n+                        getMinimumDaysInFirstWeek());\n+    }\n+\n+    private static final class Stub implements Serializable {\n+        private transient DateTimeZone iZone;\n+        private transient long iCutover;\n+        private transient boolean iCenturyISO;\n+        private transient byte iMinDaysInFirstWeek;\n+\n+        Stub(DateTimeZone zone, long gregorianCutover,\n+             boolean centuryISO, int minDaysInFirstWeek)\n+        {\n+            iZone = zone;\n+            iCutover = gregorianCutover;\n+            iCenturyISO = centuryISO;\n+            iMinDaysInFirstWeek = (byte)minDaysInFirstWeek;\n+        }\n+\n+        Object readResolve() {\n+            return GJChronology.getInstance(iZone,\n+                                            iCutover,\n+                                            iCenturyISO,\n+                                            iMinDaysInFirstWeek);\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeBoolean(iCenturyISO);\n+            out.writeObject(iZone);\n+            out.writeLong(iCutover);\n+            out.writeByte(iMinDaysInFirstWeek);\n+        }\n+\n+        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            iCenturyISO = in.readBoolean();\n+            iZone = (DateTimeZone)in.readObject();\n+            iCutover = in.readLong();\n+            iMinDaysInFirstWeek = in.readByte();\n+        }\n+    }\n+\n+    /**\n+     * Creates instances for a specific time zone.\n+     */\n+    private static final class Factory {\n+        private final DateTimeZone iZone;\n+\n+        // A simple cache that performs in O(n) time.\n+        private ArrayList iCache;\n+\n+        Factory(DateTimeZone zone) {\n+            iZone = zone;\n+            iCache = new ArrayList();\n+        }\n+\n+        public synchronized GJChronology getInstance(long gregorianCutover,\n+                                                     boolean centuryISO,\n+                                                     int minDaysInFirstWeek)\n+        {\n+            GJChronology chrono;\n+            ArrayList cache = iCache;\n+            \n+            for (int i=cache.size(); --i>=0; ) {\n+                chrono = (GJChronology)((SoftReference)cache.get(i)).get();\n+                if (chrono == null) {\n+                    cache.remove(i);\n+                    continue;\n+                }\n+                \n+                if (chrono.getGregorianJulianCutoverMillis() == gregorianCutover &&\n+                    chrono.isCenturyISO() == centuryISO &&\n+                    chrono.getMinimumDaysInFirstWeek() == minDaysInFirstWeek) {\n+                    \n+                    return chrono;\n+                }\n+            }\n+\n+            if (gregorianCutover == Long.MAX_VALUE) {\n+                chrono = new JulianChronology(minDaysInFirstWeek);\n+            } else if (gregorianCutover == Long.MIN_VALUE) {\n+                chrono = new GregorianChronology(minDaysInFirstWeek);\n+            } else {\n+                JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance\n+                    (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);\n+                GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance\n+                    (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);\n+\n+                chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);\n+            }\n+\n+            if (!centuryISO) {\n+                chrono = new GJCenturyChronology(chrono);\n+            }\n+            \n+            if (iZone != DateTimeZone.UTC) {\n+                chrono = new GJZonedChronology(chrono, iZone);\n+            }\n+\n+            cache.add(new SoftReference(chrono));\n+            return chrono;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the month component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJDayOfMonthDateTimeField extends DateTimeField {\n+\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJDayOfMonthDateTimeField(ProlepticChronology chronology) {\n+        super(\"dayOfMonth\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the month component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the day of the month extracted from the input.\n+     */\n+    public int get(long millis) {\n+        return iChronology.getDayOfMonth(millis);\n+    }\n+\n+    /**\n+     * Add the specified day of the month to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param days  the days to add to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int days) {\n+        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long add(long millis, long days) {\n+        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Add to the day of the month component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param days  the days to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int days) {\n+        // This method deviates from the normal logic found in\n+        // concrete subclasses of DateTimeField.\n+        // This is because the maximum allowed day for a given\n+        // month must be calculated at run time.\n+        int thisYear = iChronology.year().get(millis);\n+        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        int wrappedDom = getWrappedValue\n+            (thisDom, days, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));\n+        return set(millis, wrappedDom);\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Set the day of the month component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param year  the day (1,28-31) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if day is is invalid for this year and month.\n+     */\n+    public long set(long millis, int day) {\n+        int thisYear = iChronology.year().get(millis);\n+        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        verifyValueBounds(day, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));\n+        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        return millis + (day - thisDom) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getUnitMillis() {\n+        return DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.getRoughMillisPerMonth();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 31;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        int thisYear = iChronology.year().get(millis);\n+        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        return iChronology.getDaysInYearMonth(thisYear, thisMonth);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        if (millis >= 0) {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            millis += 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        if (millis >= 0) {\n+            millis -= 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long remainder(long millis) {\n+        if (millis >= 0) {\n+            return millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY - 1;\n+        }\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * GJDayOfWeekDateTimeField provides time calculations for the\n+ * day of the week component of time.\n+ *\n+ * @since 1.0\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+final class GJDayOfWeekDateTimeField extends DateTimeField {\n+    \n+    private static final int MIN = DateTimeConstants.MONDAY;\n+    private static final int MAX = DateTimeConstants.SUNDAY;\n+    \n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJDayOfWeekDateTimeField(ProlepticChronology chronology) {\n+        super(\"dayOfWeek\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the value of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query\n+     * @return the day of the week extracted from the input\n+     */\n+    public int get(long millis) {\n+        // 1970-01-01 is day of week 4, Thursday.\n+\n+        long daysSince19700101;\n+        if (millis >= 0) {\n+            daysSince19700101 = millis / DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+                / DateTimeConstants.MILLIS_PER_DAY;\n+            if (daysSince19700101 < -3) {\n+                return 7 + (int) ((daysSince19700101 + 4) % 7);\n+            }\n+        }\n+\n+        return 1 + (int) ((daysSince19700101 + 3) % 7);\n+    }\n+\n+    /**\n+     * Get the textual value of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Monday'\n+     */\n+    public String getAsText(long millis, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n+    }\n+\n+    /**\n+     * Get the abbreviated textual value of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Mon'\n+     */\n+    public String getAsShortText(long millis, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(millis));\n+    }\n+\n+    /**\n+     * Add to the value of the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update\n+     * @param day  the day of the week to add (can be negative)\n+     * @return the updated time instant\n+     */\n+    public long add(long millis, int days) {\n+        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long add(long millis, long days) {\n+        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Add to the value of the specified time instant wrapping around\n+     * within that component if necessary.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update\n+     * @param day  the day of the week to add (can be negative)\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int days) {\n+        int thisDow = get(millis);\n+        int wrappedDow = getWrappedValue(thisDow, days, MIN, MAX);\n+        // copy code from set() to avoid repeat call to get()\n+        return millis + (wrappedDow - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Set the value of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update\n+     * @param day  the day of the week (1,7) to update the time to\n+     * @return the updated time instant\n+     * @throws IllegalArgumentException  if day is invalid\n+     */\n+    public long set(long millis, int day) {\n+        verifyValueBounds(day, MIN, MAX);\n+        int thisDow = get(millis);\n+        return millis + (day - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Set the value of the specified time instant from text.\n+     * \n+     * @param millis  the time instant in millis to update\n+     * @param text  the text to set from\n+     * @param locale  the locale to use\n+     * @return the updated millis\n+     */\n+    public long set(long millis, String text, Locale locale) {\n+        return set(millis, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));\n+    }\n+\n+    public long getUnitMillis() {\n+        return DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return DateTimeConstants.MILLIS_PER_WEEK;\n+    }\n+\n+    /**\n+     * Get the minimum value that this field can have.\n+     * \n+     * @return the field's minimum value\n+     */\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    /**\n+     * Get the maximum value that this field can have.\n+     * \n+     * @return the field's maximum value\n+     */\n+    public int getMaximumValue() {\n+        return MAX;\n+    }\n+\n+    /**\n+     * Get the maximum length of the text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum textual length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();\n+    }\n+\n+    /**\n+     * Get the maximum length of the abbreviated text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum abbreviated textual length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\n+    }\n+    \n+    public long roundFloor(long millis) {\n+        if (millis >= 0) {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            millis += 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        if (millis >= 0) {\n+            millis -= 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long remainder(long millis) {\n+        if (millis >= 0) {\n+            return millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);\n+        }\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfWeek();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJDayOfYearDateTimeField extends DateTimeField {\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJDayOfYearDateTimeField(ProlepticChronology chronology) {\n+        super(\"dayOfYear\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the year component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the day of the year extracted from the input.\n+     */\n+    public int get(long millis) {\n+        long dateMillis = iChronology.year().roundFloor(millis);\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * Add the specified day of the year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param days  the days to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int days) {\n+        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long add(long millis, long days) {\n+        return millis + days * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Add to the day of the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int days) {\n+        int thisDoy = get(millis);\n+        int wrappedDoy = getWrappedValue(thisDoy, days, getMinimumValue(millis), getMaximumValue(millis));\n+        // avoid recalculating fields in set\n+        return millis + (wrappedDoy - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Set the day of the year component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param day  the day of the year (1,365/366) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+    */\n+    public long set(long millis, int day) {\n+        verifyValueBounds(day, getMinimumValue(millis), getMaximumValue(millis));\n+        int thisDoy = get(millis);\n+        return millis + (day - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getUnitMillis() {\n+        return DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.getRoughMillisPerYear();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        int thisYear = iChronology.year().get(millis);\n+        return iChronology.getDaysInYear(thisYear);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        if (millis >= 0) {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            millis += 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        if (millis >= 0) {\n+            millis -= 1;\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    public long remainder(long millis) {\n+        if (millis >= 0) {\n+            return millis % DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);\n+        }\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the era component of time.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJEraDateTimeField extends DateTimeField {\n+    \n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJEraDateTimeField(ProlepticChronology chronology) {\n+        super(\"era\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     */\n+    public int get(long millis) {\n+        if (iChronology.year().get(millis) <= 0) {\n+            return DateTimeConstants.BCE;\n+        } else {\n+            return DateTimeConstants.CE;\n+        }\n+    }\n+\n+    public String getAsText(long millis, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(millis));\n+    }\n+\n+    /**\n+     * Unsupported - add the specified eras to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param eras  \n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int eras) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    public long add(long millis, long value) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported - add the specified eras to the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param eras\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int years) {\n+        throw new UnsupportedOperationException(\"Adding to Era field is unsupported\");\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        throw new UnsupportedOperationException(\"Era field difference is unsupported\");\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param era  the era to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long millis, int era) {\n+        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n+            \n+        int oldEra = get(millis);\n+        if (oldEra != era) {\n+            int year = iChronology.year().get(millis);\n+            return iChronology.year().set(millis, -year);\n+        } else {\n+            return millis;\n+        }\n+    }\n+\n+    public long set(long millis, String text, Locale locale) {\n+        return set(millis, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));\n+    }\n+\n+    public long getUnitMillis() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public long getRangeMillis() {\n+        // Should actually be double this, but that is not possible since Java\n+        // doesn't support unsigned types.\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return DateTimeConstants.BCE;\n+    }\n+\n+    public int getMaximumValue() {\n+        return DateTimeConstants.CE;\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public long roundFloor(long millis) {\n+        throw new UnsupportedOperationException(\"Rounding an Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public long remainder(long millis) {\n+        throw new UnsupportedOperationException(\"Calculating remainder from Era field is unsupported\");\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.era();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono.gj;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.HashMap;\n+import java.util.Locale;\n+\n+/**\n+ * Utility class used by a few of the DateTimeFields.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+class GJLocaleSymbols {\n+    private static HashMap cCache = new HashMap();\n+\n+    public static synchronized GJLocaleSymbols forLocale(Locale locale) {\n+        GJLocaleSymbols symbols = (GJLocaleSymbols)cCache.get(locale);\n+        if (symbols == null) {\n+            symbols = new GJLocaleSymbols(locale);\n+            cCache.put(locale, symbols);\n+        }\n+        return symbols;\n+    }\n+\n+    private static String[] realignMonths(String[] months) {\n+        String[] a = new String[13];\n+        for (int i=1; i<13; i++) {\n+            a[i] = months[i - 1];\n+        }\n+        return a;\n+    }\n+\n+    private static String[] realignDaysOfWeek(String[] daysOfWeek) {\n+        String[] a = new String[8];\n+        for (int i=1; i<8; i++) {\n+            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];\n+        }\n+        return a;\n+    }\n+\n+    private static int maxLength(String[] a) {\n+        int max = 0;\n+        for (int i=a.length; --i>=0; ) {\n+            String s = a[i];\n+            if (s != null) {\n+                int len = s.length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+\n+    private final String[] iEras;\n+    private final String[] iDaysOfWeek;\n+    private final String[] iShortDaysOfWeek;\n+    private final String[] iMonths;\n+    private final String[] iShortMonths;\n+    private final String[] iHalfday;\n+\n+    private final int iMaxEraLength;\n+    private final int iMaxDayOfWeekLength;\n+    private final int iMaxShortDayOfWeekLength;\n+    private final int iMaxMonthLength;\n+    private final int iMaxShortMonthLength;\n+    private final int iMaxHalfdayLength;\n+\n+    private GJLocaleSymbols(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        DateFormatSymbols dfs = new DateFormatSymbols(locale);\n+\n+        iEras = dfs.getEras();\n+        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());\n+        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());\n+        iMonths = realignMonths(dfs.getMonths());\n+        iShortMonths = realignMonths(dfs.getShortMonths());\n+        iHalfday = dfs.getAmPmStrings();\n+\n+        iMaxEraLength = maxLength(iEras);\n+        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);\n+        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);\n+        iMaxMonthLength = maxLength(iMonths);\n+        iMaxShortMonthLength = maxLength(iShortMonths);\n+        iMaxHalfdayLength = maxLength(iHalfday);\n+    }\n+\n+    public String eraValueToText(int value) {\n+        return iEras[value];\n+    }\n+\n+    public int eraTextToValue(String text) {\n+        String[] eras = iEras;\n+        for (int i=eras.length; --i>=0; ) {\n+            if (eras[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal era text: \" + text);\n+    }\n+\n+    public int getEraMaxTextLength() {\n+        return iMaxEraLength;\n+    }\n+\n+    public String monthOfYearValueToText(int value) {\n+        return iMonths[value];\n+    }\n+\n+    public String monthOfYearValueToShortText(int value) {\n+        return iShortMonths[value];\n+    }\n+\n+    public int monthOfYearTextToValue(String text) {\n+        String[] months = iMonths;\n+        for (int i=months.length; --i>=1; ) {\n+            if (months[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        months = iShortMonths;\n+        for (int i=months.length; --i>=1; ) {\n+            if (months[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal monthOfYear text: \" + text);\n+    }\n+\n+    public int getMonthMaxTextLength() {\n+        return iMaxMonthLength;\n+    }\n+\n+    public int getMonthMaxShortTextLength() {\n+        return iMaxShortMonthLength;\n+    }\n+\n+    public String dayOfWeekValueToText(int value) {\n+        return iDaysOfWeek[value];\n+    }\n+\n+    public String dayOfWeekValueToShortText(int value) {\n+        return iShortDaysOfWeek[value];\n+    }\n+\n+    public int dayOfWeekTextToValue(String text) {\n+        String[] daysOfWeek = iDaysOfWeek;\n+        for (int i=daysOfWeek.length; --i>=1; ) {\n+            if (daysOfWeek[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        daysOfWeek = iShortDaysOfWeek;\n+        for (int i=daysOfWeek.length; --i>=1; ) {\n+            if (daysOfWeek[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal dayOfWeek text: \" + text);\n+    }\n+\n+    public int getDayOfWeekMaxTextLength() {\n+        return iMaxDayOfWeekLength;\n+    }\n+\n+    public int getDayOfWeekMaxShortTextLength() {\n+        return iMaxShortDayOfWeekLength;\n+    }\n+\n+    public String halfdayValueToText(int value) {\n+        return iHalfday[value];\n+    }\n+\n+    public int halfdayTextToValue(String text) {\n+        String[] halfday = iHalfday;\n+        for (int i = halfday.length; --i>=0; ) {\n+            if (halfday[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Illegal halfday text: \" + text);\n+    }\n+\n+    public int getHalfdayMaxTextLength() {\n+        return iMaxHalfdayLength;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the month of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJMonthOfYearDateTimeField extends DateTimeField {\n+    private static final int MIN = DateTimeConstants.JANUARY;\n+    private static final int MAX = DateTimeConstants.DECEMBER;\n+\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJMonthOfYearDateTimeField(ProlepticChronology chronology) {\n+        super(\"monthOfYear\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the Month component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n+     * @param millis  the time instant in millis to query.\n+     * @return the month extracted from the input.\n+     */\n+    public int get(long millis) {\n+        return iChronology.getMonthOfYear(millis);\n+    }\n+\n+    public String getAsText(long millis, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(millis));\n+    }\n+\n+    public String getAsShortText(long millis, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(millis));\n+    }\n+\n+    /**\n+     * Add the specified month to the specified time instant.\n+     * The amount added may be negative.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 - (1 month) = 06-30<p>\n+     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n+     * @param millis  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int months) {\n+        if (months == 0) {\n+            return millis; // the easy case\n+        }\n+        //\n+        // Save time part first.\n+        //\n+        long timePart = iChronology.millisOfDay().get(millis);\n+        //\n+        //\n+        // Get this year and month.\n+        //\n+        int thisYear = iChronology.year().get(millis);\n+        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+        // ----------------------------------------------------------\n+        //\n+        // Do not refactor without careful consideration.\n+        // Order of calculation is important.\n+        //\n+        int yearToUse;\n+        // Initially, monthToUse is zero-based\n+        int monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = monthToUse % MAX;\n+            // Take care of the boundary condition\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            // Take care of the boundary condition\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+        // End of do not refactor.\n+        // ----------------------------------------------------------\n+\n+        //\n+        // Quietly force DOM to nearest sane value.\n+        //\n+        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+        //\n+        // get proper date part, and return result\n+        //\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    public long add(long millis, long months) {\n+        int i_months = (int)months;\n+        if (i_months == months) {\n+            return add(millis, i_months);\n+        }\n+\n+        // Copied from add(long, int) and modified slightly:\n+\n+        long timePart = iChronology.millisOfDay().get(millis);\n+\n+        int thisYear = iChronology.year().get(millis);\n+        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);\n+\n+        long yearToUse;\n+        long monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = (int)(monthToUse % MAX);\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+\n+        if (yearToUse < iChronology.getMinYear() ||\n+            yearToUse > iChronology.getMaxYear()) {\n+\n+            throw new IllegalArgumentException\n+                (\"Magnitude of add amount is too large: \" + months);\n+        }\n+\n+        int i_yearToUse = (int)yearToUse;\n+        int i_monthToUse = (int)monthToUse;\n+\n+        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    /**\n+     * Add to the Month component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapped\n+     * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)\n+     * @param millis  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int months) {\n+        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        if (minuendMillis < subtrahendMillis) {\n+            return -getDifference(subtrahendMillis, minuendMillis);\n+        }\n+\n+        DateTimeField yearField = iChronology.year();\n+        int minuendYear = yearField.get(minuendMillis);\n+        int minuendMonth = iChronology.getMonthOfYear(minuendMillis, minuendYear);\n+        int subtrahendYear = yearField.get(subtrahendMillis);\n+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendMillis, subtrahendYear);\n+\n+        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;\n+\n+        // Before adjusting for remainder, account for special case of add\n+        // where the day-of-month is forced to the nearest sane value.\n+        int minuendDom = iChronology.getDayOfMonth\n+            (minuendMillis, minuendYear, minuendMonth);\n+        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n+            // Last day of the minuend month...\n+            int subtrahendDom = iChronology.getDayOfMonth\n+                (subtrahendMillis, subtrahendYear, subtrahendMonth);\n+            if (subtrahendDom > minuendDom) {\n+                // ...and day of subtrahend month is larger.\n+                subtrahendMillis = iChronology.dayOfMonth().set(subtrahendMillis, minuendDom);\n+            }\n+        }\n+\n+        // Inlined remainder method to avoid duplicate calls.\n+        long minuendRem = minuendMillis\n+            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n+        long subtrahendRem = subtrahendMillis\n+            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n+\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Month component of the specified time instant.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 to month 6 = 06-30<p>\n+     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param month  the month (1,12) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if month is invalid\n+     */\n+    public long set(long millis, int month) {\n+        super.verifyValueBounds(month, MIN, MAX);\n+        //\n+        int thisYear = iChronology.year().get(millis);\n+        //\n+        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n+        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n+        if (thisDom > maxDom) {\n+            // Quietly force DOM to nearest sane value.\n+            thisDom = maxDom;\n+        }\n+        // Return newly calculated millis value\n+        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n+            iChronology.millisOfDay().get(millis);\n+    }\n+\n+    public long set(long millis, String text, Locale locale) {\n+        return set(millis, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.getRoughMillisPerMonth();\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.getRoughMillisPerYear();\n+    }\n+\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    public int getMaximumValue() {\n+        return MAX;\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();\n+    }\n+\n+    public long roundFloor(long millis) {\n+        int year = iChronology.year().get(millis);\n+        int month = iChronology.getMonthOfYear(millis, year);\n+        return iChronology.getYearMonthMillis(year, month);\n+    }\n+\n+    public long remainder(long millis) {\n+        return millis - roundFloor(millis);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of a week based year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ */\n+final class GJWeekOfWeekyearDateTimeField extends DateTimeField {\n+\n+    private static final int MIN = 1;\n+    private static final int MAX = 53;\n+\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology) {\n+        super(\"weekOfWeekyear\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the week of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @param millis  the time instant in millis to query.\n+     * @return the week of the year extracted from the input.\n+     */\n+    public int get(long millis) {\n+        int year = iChronology.year().get(millis);\n+        //\n+        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);\n+        if (millis < firstWeekMillis1) {\n+            return iChronology.getWeeksInYear(year - 1);\n+        }\n+        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);\n+        if (millis >= firstWeekMillis2) {\n+            return 1;\n+        }\n+        return (int) ((millis - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+    }\n+\n+    /**\n+     * Add the specified weeks to the specified time instant.\n+     * <p>\n+     * The amount added may be negative.\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @param millis  the time instant in millis to update.\n+     * @param weeks  the weeks to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int weeks) {\n+        // Return newly calculated millis value\n+        return millis + (weeks * (long)DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    public long add(long millis, long weeks) {\n+        // Return newly calculated millis value\n+        return millis + (weeks * DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Add to the week component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapped\n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int weeks) {\n+        int thisWeek = get(millis);\n+        int wrappedWeek = getWrappedValue(thisWeek, weeks, 1, getMaximumValue(millis));\n+        return millis + (wrappedWeek - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_WEEK;\n+    }\n+\n+    /**\n+     * Set the week of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#set\n+     * @param millis  the time instant in millis to update.\n+     * @param week  the week (1,53) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if week is invalid.\n+     */\n+    public long set(long millis, int week) {\n+        verifyValueBounds(week, 1, getMaximumValue(millis));\n+        int thisWeek = get(millis);\n+        return millis + (week - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+    }\n+\n+    public long getUnitMillis() {\n+        return DateTimeConstants.MILLIS_PER_WEEK;\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.getRoughMillisPerYear();\n+    }\n+\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    public int getMaximumValue() {\n+        return MAX;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        int thisYear = iChronology.weekyear().get(millis);\n+        return iChronology.getWeeksInYear(thisYear);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        DateTimeField dowField = iChronology.dayOfWeek();\n+        millis = dowField.roundFloor(millis);\n+        int dow = dowField.get(millis);\n+        if (dow > 1) {\n+            millis = dowField.add(millis, 1 - dow);\n+        }\n+        return millis;\n+    }\n+\n+    public long remainder(long millis) {\n+        return millis - roundFloor(millis);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of the weekyear component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @version 1.0\n+ * @since 1.0\n+ * @see org.joda.time.DateTimeField\n+ */\n+final class GJWeekyearDateTimeField extends DateTimeField {\n+    \n+    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n+\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJWeekyearDateTimeField(ProlepticChronology chronology) {\n+        super(\"weekyear\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the Year of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get\n+     * @param millis  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long millis) {\n+        int week = iChronology.weekOfWeekyear().get(millis);\n+        if (week == 1) {\n+            return iChronology.year().get(millis + DateTimeConstants.MILLIS_PER_WEEK);\n+        } else if (week > 51) {\n+            return iChronology.year().get(millis - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+        } else {\n+            return iChronology.year().get(millis);\n+        }\n+    }\n+\n+    /**\n+     * Add the specified years to the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int years) {\n+        if (years == 0) {\n+            return millis;\n+        }\n+        return set(millis, get(millis) + years);\n+    }\n+\n+    public long add(long millis, long value) {\n+        return addLong(millis, value);\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapped\n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int years) {\n+        return add(millis, years);\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        if (minuendMillis < subtrahendMillis) {\n+            return -getDifference(subtrahendMillis, minuendMillis);\n+        }\n+\n+        int minuendWeekyear = get(minuendMillis);\n+        int subtrahendWeekyear = get(subtrahendMillis);\n+\n+        long minuendRem = remainder(minuendMillis);\n+        long subtrahendRem = remainder(subtrahendMillis);\n+\n+        // Balance leap weekyear differences on remainders.\n+        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {\n+            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+\n+        int difference = minuendWeekyear - subtrahendWeekyear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year of a week based year component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#set\n+     * @param millis  the time instant in millis to update.\n+     * @param year  the year (-9999,9999) to set the date to.\n+     * @return the updated DateTime.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long millis, int year) {\n+        super.verifyValueBounds(Math.abs(year),\n+                                iChronology.getMinYear(), iChronology.getMaxYear());\n+        //\n+        // Do nothing if no real change is requested.\n+        //\n+        int thisWeekyear = get( millis );\n+        if ( thisWeekyear == year ) {\n+            return millis;\n+        }\n+        //\n+        // Calculate the DayOfWeek (to be preserved).\n+        //\n+        int thisDow = iChronology.dayOfWeek().get( millis );\n+        //\n+        // Calculate the maximum weeks in the target year.\n+        //\n+        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n+        int weeksInToYear = iChronology.getWeeksInYear( year );\n+        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n+            weeksInToYear : weeksInFromYear;\n+        //\n+        // Get the current week of the year. This will be preserved in\n+        // the output unless it is greater than the maximum possible\n+        // for the target weekyear.  In that case it is adjusted\n+        // to the maximum possible.\n+        //\n+        int setToWeek = iChronology.weekOfWeekyear().get( millis );\n+        if ( setToWeek > maxOutWeeks ) {\n+            setToWeek = maxOutWeeks;\n+        }\n+        //\n+        // Get a wroking copy of the current date-time.\n+        // This can be a convenience for debugging.\n+        //\n+        long workMillis = millis; // Get a copy\n+        //\n+        // Attempt to get close to the proper weekyear.\n+        // Note - we cannot currently call ourself, so we just call\n+        // set for the year.  This at least gets us close.\n+        //\n+        workMillis = iChronology.year().set( workMillis, year );\n+        //\n+        // Calculate the weekyear number for the get close to value\n+        // (which might not be equal to the year just set).\n+        //\n+        int workWoyYear = iChronology.weekyear().get( workMillis );\n+\n+        // *TEMP Debugging\n+        /*\n+        MutableDateTime temp = new MutableDateTime(workMillis,\n+            ISOChronology.getInstance());\n+        System.out.println(\"Current mdt value 01: \"\n+            + temp\n+            + \" \" + workWoyYear\n+        );\n+        System.out.println(\"->Temp: \" + temp.toString()\n+            + \" WOYYr=\" + temp.getWeekyear()\n+            + \" WOYWk=\" + temp.getWeekOfWeekyear()\n+            + \" DoW=\" + temp.getDayOfWeek()\n+        );\n+        */\n+\n+        //\n+        // At most we are off by one year, which can be \"fixed\" by\n+        // adding/subtracting a week.\n+        //\n+        if ( workWoyYear < year ) {\n+            // System.out.println(\"Year: Adding \"+workWoyYear+\" \"+year);\n+            workMillis += DateTimeConstants.MILLIS_PER_WEEK;\n+        } else if ( workWoyYear > year ) {\n+            // System.out.println(\"Year: Subing \"+workWoyYear+\" \"+year);\n+            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+        //\n+        // Set the proper week in the current weekyear.\n+        //\n+\n+        // BEGIN: possible set WeekOfWeekyear logic.\n+        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );\n+        // No range check required (we already know it is OK).\n+        workMillis = workMillis + (setToWeek - currentWoyWeek)\n+            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+        // END: possible set WeekOfWeekyear logic.\n+\n+        //\n+        // Reset DayOfWeek to previous value.\n+        //\n+        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );\n+        //\n+        // Return result.\n+        //\n+        return workMillis;\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.getRoughMillisPerYear();\n+    }\n+\n+    public long getRangeMillis() {\n+        // Should actually be double this, but that is not possible since Java\n+        // doesn't support unsigned types.\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long millis) {\n+        DateTimeField wowField = iChronology.weekOfWeekyear();\n+        millis = wowField.roundFloor(millis);\n+        int wow = wowField.get(millis);\n+        if (wow > 1) {\n+            millis = wowField.add(millis, 1 - wow);\n+        }\n+        return millis;\n+    }\n+\n+    public long remainder(long millis) {\n+        return millis - roundFloor(millis);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJYearDateTimeField extends DateTimeField {\n+\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private final ProlepticChronology iChronology;\n+    private final transient long iRoughMillisPerYear;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJYearDateTimeField(ProlepticChronology chronology) {\n+        super(\"year\");\n+        iChronology = chronology;\n+        iRoughMillisPerYear = chronology.getRoughMillisPerYear();\n+    }\n+\n+    /**\n+     * Get the Year component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long millis) {\n+        // Get an initial estimate of the year, and the millis value\n+        // that represents the start of that year.\n+        int year = 1970 + (int) (millis / iRoughMillisPerYear);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+\n+        if (millis > yearStartMillis) {\n+            for (;;) {\n+                // Actual year may be greater than what we estimated. Check if\n+                // year should advance.\n+                if (iChronology.isLeapYear(year)) {\n+                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n+                } else {\n+                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n+                }\n+                if (millis < yearStartMillis) {\n+                    // Year was correct, no need to advance.\n+                    break;\n+                }\n+                year++;\n+                if (millis == yearStartMillis) {\n+                    // Millis is at start of year; year is now correct, so no\n+                    // need to check anymore.\n+                    break;\n+                }\n+                if ((millis ^ yearStartMillis) < 0) {\n+                    // Sign mismatch, operation overflowed.\n+                    return getOverflow(millis);\n+                }\n+            }\n+        } else if (millis < yearStartMillis) {\n+            for (;;) {\n+                // Actual year less than what we estimated. Go to previous year\n+                // and check.\n+                year--;\n+                if (iChronology.isLeapYear(year)) {\n+                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;\n+                } else {\n+                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;\n+                }\n+                if (millis >= yearStartMillis) {\n+                    // Year is now correct.\n+                    break;\n+                }\n+                if ((millis ^ yearStartMillis) < 0) {\n+                    // Sign mismatch, operation overflowed.\n+                    return getOverflow(millis);\n+                }\n+            }\n+        }\n+\n+        return year;\n+    }\n+\n+    private int getOverflow(long millis) {\n+        if (millis > 0) {\n+            int year = iChronology.getMaxYear();\n+            long yearStartMillis = iChronology.getYearMillis(year);\n+            if (iChronology.isLeapYear(year)) {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+            long yearEndMillis = yearStartMillis - 1;\n+\n+            if (millis <= yearEndMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too large: \" + millis + \" > \" + yearEndMillis);\n+        } else {\n+            int year = iChronology.getMinYear();\n+            long yearStartMillis = iChronology.getYearMillis(year);\n+            if (millis >= yearStartMillis) {\n+                return year;\n+            }\n+\n+            throw new IllegalArgumentException\n+                (\"Instant too small: \" + millis + \" < \" + yearStartMillis);\n+        }\n+    }\n+\n+    /**\n+     * Add the specified year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int years) {\n+        if (years == 0) {\n+            return millis;\n+        }\n+        int thisYear = get(millis);\n+        int newYear = thisYear + years;\n+        return set(millis, newYear);\n+    }\n+\n+    public long add(long millis, long years) {\n+        return addLong(millis, years);\n+    }\n+\n+    /**\n+     * Add to the Year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int years) {\n+        if (years == 0) {\n+            return millis;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.year().get(millis);\n+        int wrappedYear = getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(millis, wrappedYear);\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        if (minuendMillis < subtrahendMillis) {\n+            return -getDifference(subtrahendMillis, minuendMillis);\n+        }\n+\n+        int minuendYear = get(minuendMillis);\n+        int subtrahendYear = get(subtrahendMillis);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendMillis - iChronology.getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendMillis - iChronology.getYearMillis(subtrahendYear);\n+\n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (iChronology.isLeapYear(subtrahendYear)) {\n+                if (!iChronology.isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && iChronology.isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param year  the year (-292269055,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long millis, int year) {\n+        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());\n+\n+        int dayOfYear = iChronology.dayOfYear().get(millis);\n+        int millisOfDay = iChronology.millisOfDay().get(millis);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeap(millis)) {\n+                // Old date is Feb 29 or later.\n+                if (!iChronology.isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Old date is Mar 01 or later.\n+                if (iChronology.isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n+        millis += millisOfDay;\n+\n+        return millis;\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        return iChronology.isLeapYear(get(millis));\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        if (iChronology.isLeapYear(get(millis))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public long getUnitMillis() {\n+        return iRoughMillisPerYear;\n+    }\n+\n+    public long getRangeMillis() {\n+        // Should actually be double this, but that is not possible since Java\n+        // doesn't support unsigned types.\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getYearMillis(get(millis));\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        int year = get(millis);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (millis != yearStartMillis) {\n+            // Bump up to start of next year.\n+            millis = iChronology.getYearMillis(year + 1);\n+        }\n+        return millis;\n+    }\n+\n+    public long remainder(long millis) {\n+        return millis - roundFloor(millis);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Provides time calculations for the year of era component of time.\n+ * \n+ * @author Brian S O'Neill\n+ */\n+final class GJYearOfEraDateTimeField extends DateTimeField {\n+    private final ProlepticChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJYearOfEraDateTimeField(ProlepticChronology chronology) {\n+        super(\"yearOfEra\");\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the year of era component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to query.\n+     * @return the year of era extracted from the input.\n+     */\n+    public int get(long millis) {\n+        int year = iChronology.year().get(millis);\n+        if (year <= 0) {\n+            year = 1 - year;\n+        }\n+        return year;\n+    }\n+\n+    /**\n+     * Add the specified year to the specified time instant.\n+     * The amount added may be negative.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long millis, int years) {\n+        return iChronology.year().add(millis, years);\n+    }\n+\n+    public long add(long millis, long years) {\n+        return addLong(millis, years);\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapped(long millis, int years) {\n+        return iChronology.year().addWrapped(millis, years);\n+    }\n+\n+    public long getDifference(long minuendMillis, long subtrahendMillis) {\n+        return iChronology.year().getDifference(minuendMillis, subtrahendMillis);\n+    }\n+\n+    /**\n+     * Set the year component of the specified time instant.\n+     * \n+     * @param millis  the time instant in millis to update.\n+     * @param year  the year (0,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long millis, int year) {\n+        super.verifyValueBounds(year, 1, iChronology.getMaxYear());\n+        if (iChronology.era().get(millis) == DateTimeConstants.BCE) {\n+            return iChronology.year().set(millis, 1 - year);\n+        } else {\n+            return iChronology.year().set(millis, year);\n+        }\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.getRoughMillisPerYear();\n+    }\n+\n+    public long getRangeMillis() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.year().roundFloor(millis);\n+    }\n+\n+    public long roundCeiling(long millis) {\n+        return iChronology.year().roundCeiling(millis);\n+    }\n+\n+    public long remainder(long millis) {\n+        return iChronology.year().remainder(millis);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.yearOfEra();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.ZonedChronology;\n+\n+/**\n+ * A specialism of zoned chronology for the GJ chronology.\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class GJZonedChronology extends GJChronology {\n+    private final GJChronology iChronology;\n+    private final DateTimeZone iZone;\n+\n+    GJZonedChronology(GJChronology chrono, DateTimeZone zone) {\n+        iChronology = chrono;\n+        iZone = zone;\n+\n+        Chronology zc = new ZonedChronology(chrono, zone);\n+\n+        iYearField = zc.year();\n+        iYearOfEraField = zc.yearOfEra();\n+        iYearOfCenturyField = zc.yearOfCentury();\n+        iCenturyOfEraField = zc.centuryOfEra();\n+        iEraField = zc.era();\n+        iDayOfMonthField = zc.dayOfMonth();\n+        iDayOfWeekField = zc.dayOfWeek();\n+        iDayOfYearField = zc.dayOfYear();\n+        iMonthOfYearField = zc.monthOfYear();\n+        iWeekOfWeekyearField = zc.weekOfWeekyear();\n+        iWeekyearField = zc.weekyear();\n+        \n+        iMillisOfSecondField = zc.millisOfSecond();\n+        iMillisOfDayField = zc.millisOfDay();\n+        iSecondOfMinuteField = zc.secondOfMinute();\n+        iSecondOfDayField = zc.secondOfDay();\n+        iMinuteOfHourField = zc.minuteOfHour();\n+        iMinuteOfDayField = zc.minuteOfDay();\n+        iHourOfDayField = zc.hourOfDay();\n+        iHourOfHalfdayField = zc.hourOfHalfday();\n+        iClockhourOfDayField = zc.clockhourOfDay();\n+        iClockhourOfHalfdayField = zc.clockhourOfHalfday();\n+        iHalfdayOfDayField = zc.halfdayOfDay();\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        return iZone;\n+    }\n+\n+    public Chronology withUTC() {\n+        return iChronology;\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return iChronology.getGregorianJulianCutoverMillis();\n+    }\n+\n+    public boolean isCenturyISO() {\n+        return iChronology.isCenturyISO();\n+    }\n+\n+    public int getMinimumDaysInFirstWeek() {\n+        return iChronology.getMinimumDaysInFirstWeek();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+\n+/**\n+ * \n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+final class GregorianChronology extends ProlepticChronology {\n+    GregorianChronology(int minDaysInFirstWeek) {\n+        super(minDaysInFirstWeek);\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return Long.MIN_VALUE;\n+    }\n+    \n+    public boolean isLeapYear(int year) {\n+        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+    }\n+\n+    protected long calculateFirstDayOfYearMillis(int year) {\n+        // Calculate relative to 2000 as that is on a 400 year boundary\n+        // and that makes the sum easier\n+        int relativeYear = year - 2000;\n+        // Initial value is just temporary.\n+        int leapYears = relativeYear / 100;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers. When the expression is written as\n+            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),\n+            // it works for both positive and negative values, except this optimization\n+            // eliminates two divisions.\n+            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);\n+        } else {\n+            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);\n+            // For post 2000 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        \n+        // Previous line was reduced from this to eliminate a multiplication.\n+        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;\n+        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y\n+        \n+        return millis + MILLIS_1970_TO_2000;\n+    }\n+\n+    protected int getMinYear() {\n+        // The lowest year that can be fully supported.\n+        return -292275054;\n+    }\n+\n+    protected int getMaxYear() {\n+        // The highest year that can be fully supported.\n+        return 292278993;\n+    }\n+\n+    protected long getRoughMillisPerYear() {\n+        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    protected long getRoughMillisPerMonth() {\n+        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.DelegateDateTimeField;\n+\n+/**\n+ * Year zero is dropped from the year and weekyear fields.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+final class JulianChronology extends GJChronology {\n+    private final JulianWithYearZeroChronology iChronology;\n+\n+    /**\n+     * @param chrono wrapped chronology\n+     */\n+    JulianChronology(int minDaysInFirstWeek) {\n+        JulianWithYearZeroChronology chrono =\n+            new JulianWithYearZeroChronology(minDaysInFirstWeek);\n+        iChronology = chrono;\n+\n+        iYearField = new NoYearZeroField(chrono.year());\n+        iYearOfEraField = chrono.yearOfEra();\n+        iYearOfCenturyField = chrono.yearOfCentury();\n+        iCenturyOfEraField = chrono.centuryOfEra();\n+        iEraField = chrono.era();\n+        iDayOfMonthField = chrono.dayOfMonth();\n+        iDayOfWeekField = chrono.dayOfWeek();\n+        iDayOfYearField = chrono.dayOfYear();\n+        iMonthOfYearField = chrono.monthOfYear();\n+        iWeekOfWeekyearField = chrono.weekOfWeekyear();\n+        iWeekyearField = new NoWeekyearZeroField(chrono.weekyear());\n+        \n+        iMillisOfSecondField = chrono.millisOfSecond();\n+        iMillisOfDayField = chrono.millisOfDay();\n+        iSecondOfMinuteField = chrono.secondOfMinute();\n+        iSecondOfDayField = chrono.secondOfDay();\n+        iMinuteOfHourField = chrono.minuteOfHour();\n+        iMinuteOfDayField = chrono.minuteOfDay();\n+        iHourOfDayField = chrono.hourOfDay();\n+        iHourOfHalfdayField = chrono.hourOfHalfday();\n+        iClockhourOfDayField = chrono.clockhourOfDay();\n+        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();\n+        iHalfdayOfDayField = chrono.halfdayOfDay();\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return iChronology.getGregorianJulianCutoverMillis();\n+    }\n+\n+    public boolean isCenturyISO() {\n+        return iChronology.isCenturyISO();\n+    }\n+\n+    public int getMinimumDaysInFirstWeek() {\n+        return iChronology.getMinimumDaysInFirstWeek();\n+    }\n+\n+    private class NoYearZeroField extends DelegateDateTimeField {\n+        private transient int iMinYear;\n+\n+        NoYearZeroField(DateTimeField field) {\n+            super(field);\n+            iMinYear = super.getMinimumValue() - 1;\n+        }\n+        \n+        public int get(long millis) {\n+            int year = super.get(millis);\n+            if (year <= 0) {\n+                year--;\n+            }\n+            return year;\n+        }\n+\n+        public long set(long millis, int year) {\n+            super.verifyValueBounds(year, iMinYear, getMaximumValue());\n+            if (year <= 0) {\n+                if (year == 0) {\n+                    throw new IllegalArgumentException(\"Invalid year: \" + year);\n+                }\n+                year++;\n+            }\n+            return super.set(millis, year);\n+        }\n+\n+        public int getMinimumValue() {\n+            return iMinYear;\n+        }\n+\n+        private Object readResolve() {\n+            return JulianChronology.this.year();\n+        }\n+    }\n+\n+    private final class NoWeekyearZeroField extends NoYearZeroField {\n+        NoWeekyearZeroField(DateTimeField field) {\n+            super(field);\n+        }\n+        \n+        private Object readResolve() {\n+            return JulianChronology.this.weekyear();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import org.joda.time.DateTimeConstants;\n+\n+/**\n+ * JulianWithZeroChronology includes year zero to simplify implementation.\n+ * \n+ * @author Guy Allard\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ */\n+final class JulianWithYearZeroChronology extends ProlepticChronology {\n+    JulianWithYearZeroChronology(int minDaysInFirstWeek) {\n+        super(minDaysInFirstWeek);\n+    }\n+\n+    public long getGregorianJulianCutoverMillis() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public boolean isLeapYear(int year) {\n+        return (year & 3) == 0;\n+    }\n+\n+    protected long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1968;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1968 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n+\n+        return millis - (366L + 365 - 13) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    protected int getMinYear() {\n+        // The lowest year that can be fully supported.\n+        return -292269053;\n+    }\n+\n+    protected int getMaxYear() {\n+        // The highest year that can be fully supported.\n+        return 292272992;\n+    }\n+\n+    protected long getRoughMillisPerYear() {\n+        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    protected long getRoughMillisPerMonth() {\n+        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.gj;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.DividedDateTimeField;\n+import org.joda.time.chrono.FractionalDateTimeField;\n+//import org.joda.time.chrono.OneBasedFractionalDateTimeField;\n+import org.joda.time.chrono.NonZeroDateTimeField;\n+import org.joda.time.chrono.RemainderDateTimeField;\n+\n+/**\n+ * ProlepticChronology uses a consistent set of rules for all dates and\n+ * times. Year zero is included.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+abstract class ProlepticChronology extends GJChronology {\n+    static final long MILLIS_1970_TO_2000 = 946684800000L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+\n+    private static final DateTimeField cMillisOfSecondField;\n+    private static final DateTimeField cMillisOfDayField;\n+    private static final DateTimeField cSecondOfMinuteField;\n+    private static final DateTimeField cSecondOfDayField;\n+    private static final DateTimeField cMinuteOfHourField;\n+    private static final DateTimeField cMinuteOfDayField;\n+    private static final DateTimeField cHourOfDayField;\n+    private static final DateTimeField cHourOfHalfdayField;\n+    private static final DateTimeField cClockhourOfDayField;\n+    private static final DateTimeField cClockhourOfHalfdayField;\n+    private static final DateTimeField cHalfdayOfDayField;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i=0; i<12; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+        }\n+\n+        cMillisOfSecondField = new FractionalDateTimeField\n+            (\"millisOfSecond\",\n+             1,\n+             DateTimeConstants.MILLIS_PER_SECOND);\n+\n+        cMillisOfDayField = new FractionalDateTimeField\n+            (\"millisOfDay\",\n+             1,\n+             DateTimeConstants.MILLIS_PER_DAY);\n+\n+        cSecondOfMinuteField = new FractionalDateTimeField\n+            (\"secondOfMinute\", \n+             DateTimeConstants.MILLIS_PER_SECOND, \n+             DateTimeConstants.SECONDS_PER_MINUTE);\n+\n+        cSecondOfDayField = new FractionalDateTimeField\n+            (\"secondOfDay\",\n+             DateTimeConstants.MILLIS_PER_SECOND,\n+             DateTimeConstants.SECONDS_PER_DAY);\n+\n+        cMinuteOfHourField = new FractionalDateTimeField\n+            (\"minuteOfHour\",\n+             DateTimeConstants.MILLIS_PER_MINUTE,\n+             DateTimeConstants.MINUTES_PER_HOUR);\n+\n+        cMinuteOfDayField = new FractionalDateTimeField\n+            (\"minuteOfDay\",\n+             DateTimeConstants.MILLIS_PER_MINUTE,\n+             DateTimeConstants.MINUTES_PER_DAY);\n+\n+        cHourOfDayField = new FractionalDateTimeField\n+            (\"hourOfDay\",\n+             DateTimeConstants.MILLIS_PER_HOUR,\n+             DateTimeConstants.HOURS_PER_DAY);\n+\n+        cHourOfHalfdayField = new FractionalDateTimeField\n+            (\"hourOfHalfday\",\n+             DateTimeConstants.MILLIS_PER_HOUR,\n+             DateTimeConstants.HOURS_PER_DAY / 2);\n+\n+        cClockhourOfDayField = new NonZeroDateTimeField\n+            (\"clockhourOfDay\", cHourOfDayField);\n+\n+        cClockhourOfHalfdayField = new NonZeroDateTimeField\n+            (\"clockhourOfHalfday\", cHourOfHalfdayField);\n+\n+        cHalfdayOfDayField = new HalfdayField();\n+    }\n+\n+    private transient YearInfo[] iYearInfoCache;\n+    private transient int iYearInfoCacheMask;\n+\n+    private final int iMinDaysInFirstWeek;\n+\n+    ProlepticChronology(int minDaysInFirstWeek) {\n+        super();\n+        iMinDaysInFirstWeek = minDaysInFirstWeek;\n+\n+        Integer i = Integer.getInteger(\"org.joda.time.gj.ProlepticChronology.yearInfoCacheSize\");\n+        int cacheSize = (i == null) ? 1024 : i.intValue();\n+        // Ensure cache size is even power of 2.\n+        cacheSize--;\n+        int shift = 0;\n+        while (cacheSize > 0) {\n+            shift++;\n+            cacheSize >>= 1;\n+        }\n+        cacheSize = 1 << shift;\n+        iYearInfoCache = new YearInfo[cacheSize];\n+        iYearInfoCacheMask = cacheSize - 1;\n+\n+        iYearField = new GJYearDateTimeField(this);\n+        iYearOfEraField = new GJYearOfEraDateTimeField(this);\n+\n+        iCenturyOfEraField = new DividedDateTimeField(\"centuryOfEra\", iYearOfEraField, 100);\n+        iYearOfCenturyField = new RemainderDateTimeField(\"yearOfCentury\", iYearOfEraField, 100);\n+\n+        iEraField = new GJEraDateTimeField(this);\n+        iDayOfWeekField = new GJDayOfWeekDateTimeField(this);\n+        iDayOfMonthField = new GJDayOfMonthDateTimeField(this);\n+        iDayOfYearField = new GJDayOfYearDateTimeField(this);\n+        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);\n+        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this);\n+        iWeekyearField = new GJWeekyearDateTimeField(this);\n+\n+        iMillisOfSecondField = cMillisOfSecondField;\n+        iMillisOfDayField = cMillisOfDayField;\n+        iSecondOfMinuteField = cSecondOfMinuteField;\n+        iSecondOfDayField = cSecondOfDayField;\n+        iMinuteOfHourField = cMinuteOfHourField;\n+        iMinuteOfDayField = cMinuteOfDayField;\n+        iHourOfDayField = cHourOfDayField;\n+        iHourOfHalfdayField = cHourOfHalfdayField;\n+        iClockhourOfDayField = cClockhourOfDayField;\n+        iClockhourOfHalfdayField = cClockhourOfHalfdayField;\n+        iHalfdayOfDayField = cHalfdayOfDayField;\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    public final boolean isCenturyISO() {\n+        return true;\n+    }\n+\n+    public final int getMinimumDaysInFirstWeek() {\n+        return iMinDaysInFirstWeek;\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     * @param year The year to use.\n+     * @return 366 if a leap year, otherwise 365.\n+     */\n+    public final int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 366 : 365;\n+    }\n+\n+    public final int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Returns the total number of milliseconds elapsed in the year, by the end\n+     * of the month.\n+     */\n+    public final long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    /**\n+     * Get the number of weeks in the year.\n+     * @param year  the year to use.\n+     * @return number of weeks in the year.\n+     */\n+    public final int getWeeksInYear(int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Get the millis for the first week of a year.\n+     * @param year  the year to use.\n+     * @return millis\n+     */\n+    public final long getFirstWeekOfYearMillis(int year) {\n+        long jan1millis = getYearMillis(year);\n+        int jan1dayOfWeek = dayOfWeek().get(jan1millis);\n+        \n+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n+            // First week is end of previous year because it doesn't have enough days.\n+            return jan1millis + (8 - jan1dayOfWeek)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            // First week is start of this year because it has enough days.\n+            return jan1millis - (jan1dayOfWeek - 1)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a year.\n+     *\n+     * @param year The year to use.\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    public final long getYearMillis(int year) {\n+        return getYearInfo(year).iFirstDayMillis;\n+        //return calculateFirstDayOfYearMillis(year);\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a month.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    public final long getYearMonthMillis(int year, int month) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return millis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for a particular date.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @param dayOfMonth The day of the month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    public final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+        long millis = getYearMillis(year);\n+        // month\n+        if (month > 1) {\n+            millis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        // day\n+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+    \n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    public final int getMonthOfYear(long millis) {\n+        return getMonthOfYear(millis, year().get(millis));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    public final int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    public final int getDayOfMonth(long millis) {\n+        int year = year().get(millis);\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    public final int getDayOfMonth(long millis, int year) {\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     * @param month precalculated month of millis\n+     */\n+    public final int getDayOfMonth(long millis, int year, int month) {\n+        long dateMillis = getYearMillis(year);\n+        if (month > 1) {\n+            dateMillis += getTotalMillisByYearMonth(year, month - 1);\n+        }\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    public abstract boolean isLeapYear(int year);\n+\n+    protected abstract long calculateFirstDayOfYearMillis(int year);\n+\n+    protected abstract int getMinYear();\n+\n+    protected abstract int getMaxYear();\n+\n+    protected abstract long getRoughMillisPerYear();\n+\n+    protected abstract long getRoughMillisPerMonth();\n+\n+    // Although accessed by multiple threads, this method doesn't need to be synchronized.\n+    private YearInfo getYearInfo(int year) {\n+        YearInfo[] cache = iYearInfoCache;\n+        int index = year & iYearInfoCacheMask;\n+        YearInfo info = cache[index];\n+        if (info == null || info.iYear != year) {\n+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n+            cache[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    private static class HalfdayField extends FractionalDateTimeField {\n+        HalfdayField() {\n+            super(\"halfdayOfDay\", DateTimeConstants.MILLIS_PER_HOUR * 12, 2);\n+        }\n+\n+        public String getAsText(long millis, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(get(millis));\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();\n+        }\n+    }\n+\n+    private static class YearInfo {\n+        public final int iYear;\n+        public final long iFirstDayMillis;\n+\n+        YearInfo(int year, long firstDayMillis) {\n+            iYear = year;\n+            iFirstDayMillis = firstDayMillis;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono.iso;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.DelegateChronology;\n+import org.joda.time.chrono.gj.GJChronology;\n+\n+/**\n+ * ISOChronology provides access to the individual date time fields \n+ * for the ISO8601 defined chronological calendar system. When ISO \n+ * does not define a field, but it can be determined (such as AM/PM)\n+ * it is included.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ISOChronology extends DelegateChronology {\n+    \n+    /** Singleton instance of a UTC ISOChronology */\n+    private static final ISOChronology INSTANCE_UTC =\n+        new ISOChronology(GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true));\n+        \n+    /** Cache of zone to chronology */\n+    private static final Map cCache = new HashMap();\n+    static {\n+        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static ISOChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static ISOChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static synchronized ISOChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        ISOChronology chrono = (ISOChronology) cCache.get(zone);\n+        if (chrono == null) {\n+            chrono = new ISOChronology(GJChronology.getInstance(zone, Long.MIN_VALUE, true));\n+            cCache.put(zone, chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor\n+     */\n+    private ISOChronology(GJChronology gjChronology) {\n+        super(gjChronology);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getChronology().getDateTimeZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getDateTimeZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        DateTimeZone zone = getDateTimeZone();\n+        return \"ISOChronology[\" + (zone == null ? \"\" : zone.getID()) + \"]\";\n+    }\n+   \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.lang.reflect.Method;\n+import java.text.ParseException;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * Abstract base class for implementing {@link DateTimePrinter}s,\n+ * {@link DateTimeParser}s, and {@link DateTimeFormatter}s. This class\n+ * intentionally does not implement any of those interfaces. You can subclass\n+ * and implement only the interfaces that you need to.\n+ * <p>\n+ * The print methods assume that your subclass has implemented DateTimePrinter or\n+ * DateTimeFormatter. If not, a ClassCastException is thrown when calling those\n+ * methods.\n+ * <p>\n+ * Likewise, the parse methods assume that your subclass has implemented\n+ * DateTimeParser or DateTimeFormatter. If not, a ClassCastException is thrown\n+ * when calling the parse methods.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public abstract class AbstractDateTimeFormatter {\n+\n+    private static Method cInitCauseMethod;\n+\n+    static {\n+        // cope with JDK 1.4 enhancements\n+        Method initCauseMethod = null;\n+        try {\n+            initCauseMethod = Throwable.class.getMethod\n+                (\"initCause\", new Class[] {Throwable.class});\n+            \n+        } catch (NoSuchMethodException ex) {\n+            // ignore\n+        } catch (SecurityException ex) {\n+            // ignore\n+        }\n+        cInitCauseMethod = initCauseMethod;\n+    }\n+\n+    // Accessed also by AbstractDurationFormatter.\n+    static String createErrorMessage(String text, int errorPos) {\n+        int sampleLen = errorPos + 20;\n+        String sampleText;\n+        if (text.length() <= sampleLen) {\n+            sampleText = text;\n+        } else {\n+            sampleText = text.substring(0, sampleLen).concat(\"...\");\n+        }\n+        \n+        if (errorPos <= 0) {\n+            return \"Invalid format: \\\"\" + sampleText + '\"';\n+        }\n+        \n+        if (errorPos >= text.length()) {\n+            return \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n+        }\n+        \n+        return \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n+            sampleText.substring(errorPos) + '\"';\n+    }\n+\n+    private static void setCause(ParseException pe, Throwable initCause) {\n+        if (cInitCauseMethod != null) {\n+            try {\n+                cInitCauseMethod.invoke(pe, new Object[]{initCause});\n+            } catch (Exception e) {\n+                cInitCauseMethod = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the Chronology being used by the formatter, or null if none.\n+     */\n+    public abstract Chronology getChronology();\n+\n+    public void printTo(StringBuffer buf, ReadableInstant instant) {\n+        long millisUTC = instant.getMillis();\n+        Chronology chrono;\n+        if ((chrono = instant.getChronology()) != null) {\n+            printTo(buf, millisUTC, chrono.getDateTimeZone());\n+        } else {\n+            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+        long millisUTC = instant.getMillis();\n+        Chronology chrono;\n+        if ((chrono = instant.getChronology()) != null) {\n+            printTo(out, millisUTC, chrono.getDateTimeZone());\n+        } else {\n+            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public void printTo(StringBuffer buf, long millisUTC) {\n+        printTo(buf, millisUTC, null);\n+    }\n+\n+    public void printTo(Writer out, long millisUTC) throws IOException {\n+        printTo(out, millisUTC, null);\n+    }\n+\n+    public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n+        if (zone != null) {\n+            ((DateTimePrinter)this).printTo\n+                (buf, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n+        } else {\n+            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException {\n+        if (zone != null) {\n+            ((DateTimePrinter)this).printTo\n+                (out, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n+        } else {\n+            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public String print(ReadableInstant instant) {\n+        long millisUTC = instant.getMillis();\n+        Chronology chrono;\n+        if ((chrono = instant.getChronology()) != null) {\n+            return print(millisUTC, chrono.getDateTimeZone());\n+        } else {\n+            return print(millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public String print(long millisUTC) {\n+        return print(millisUTC, null);\n+    }\n+\n+    public String print(long millisUTC, DateTimeZone zone) {\n+        if (zone != null) {\n+            return print\n+                (millisUTC, zone, millisUTC + zone.getOffset(millisUTC));\n+        } else {\n+            return print(millisUTC, null, millisUTC);\n+        }\n+    }\n+\n+    public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+        DateTimePrinter p = (DateTimePrinter)this;\n+        StringBuffer buf = new StringBuffer(p.estimatePrintedLength());\n+        p.printTo(buf, millisUTC, zone, millisLocal);\n+        return buf.toString();\n+    }\n+\n+    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+        DateTimeParser p = (DateTimeParser)this;\n+\n+        long millis = instant.getMillis();\n+        Chronology chrono = instant.getChronology();\n+        if (chrono != null) {\n+            DateTimeZone zone = chrono.getDateTimeZone();\n+            if (zone != null) {\n+                // Move millis to local time.\n+                millis += zone.getOffset(millis);\n+            }\n+        }\n+\n+        DateTimeParserBucket bucket = createBucket(millis);\n+        position = p.parseInto(bucket, text, position);\n+        instant.setMillis(bucket.computeMillis());\n+        return position;\n+    }\n+    \n+    public long parseMillis(String text) throws ParseException {\n+        return parseMillis(text, 0);\n+    }\n+\n+    public long parseMillis(String text, long millis) throws ParseException {\n+        DateTimeParser p = (DateTimeParser)this;\n+        DateTimeParserBucket bucket = createBucket(millis);\n+\n+        int newPos = p.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                try {\n+                    return bucket.computeMillis();\n+                } catch (IllegalArgumentException ex) {\n+                    ParseException pe = new ParseException(ex.getMessage(), 0);\n+                    setCause(pe, ex);\n+                    throw pe;\n+                }\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+\n+        throw new ParseException(createErrorMessage(text, newPos), newPos);\n+    }\n+\n+    public DateTime parseDateTime(String text) throws ParseException {\n+        return new DateTime(parseMillis(text), getChronology());\n+    }\n+\n+    public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+        return new MutableDateTime(parseMillis(text), getChronology());\n+    }\n+\n+    private DateTimeParserBucket createBucket(long millis) {\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(millis);\n+        Chronology chrono = getChronology();\n+        if (chrono != null) {\n+            DateTimeZone zone = chrono.getDateTimeZone();\n+            if (zone != null) {\n+                bucket.setDateTimeZone(zone);\n+            }\n+        }\n+        return bucket;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * DateTimeFormat provides localized printing and parsing capabilities for all\n+ * dates and times.\n+ *\n+ * @author Brian S O'Neill\n+ * @see ISODateTimeFormat\n+ * @see DateTimeFormatterBuilder\n+ */\n+public class DateTimeFormat {\n+\n+    // Maps Chronology instances to maps that map Locales to DateTimeFormat instances.\n+    private static Map cInstanceCache = new HashMap(7);\n+\n+    public static DateTimeFormat getInstanceUTC() {\n+        return getInstance(ISOChronology.getInstanceUTC(), Locale.getDefault());\n+    }\n+\n+    public static DateTimeFormat getInstance() {\n+        return getInstance(ISOChronology.getInstance(), Locale.getDefault());\n+    }\n+\n+    public static DateTimeFormat getInstance(DateTimeZone zone) {\n+        return getInstance(ISOChronology.getInstance(zone), Locale.getDefault());\n+    }\n+\n+    public static DateTimeFormat getInstance(DateTimeZone zone, Locale locale) {\n+        return getInstance(ISOChronology.getInstance(zone), locale);\n+    }\n+\n+    /**\n+     * @param chrono Chronology to use\n+     */\n+    public static DateTimeFormat getInstance(Chronology chrono) {\n+        return getInstance(chrono, Locale.getDefault());\n+    }\n+\n+    /**\n+     * @param chrono Chronology to use\n+     * @param locale Locale to use\n+     */\n+    public static synchronized DateTimeFormat getInstance(Chronology chrono, Locale locale) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (locale == null) {\n+            throw new IllegalArgumentException(\"The Locale must not be null\");\n+        }\n+        Map map = (Map)cInstanceCache.get(chrono);\n+        if (map == null) {\n+            map = new HashMap(7);\n+            cInstanceCache.put(chrono, map);\n+        }\n+        DateTimeFormat dtf = (DateTimeFormat)map.get(locale);\n+        if (dtf == null) {\n+            dtf = new DateTimeFormat(chrono, locale);\n+            map.put(locale, dtf);\n+        }\n+        return dtf;\n+    }\n+\n+    private final Chronology iChrono;\n+    private final Locale iLocale;\n+\n+    // Maps patterns to formatters.\n+    private Map iPatternedCache = new HashMap(7);\n+\n+    // Maps styles to formatters.\n+    private Map iStyledCache = new HashMap(7);\n+\n+    private DateTimeFormat(Chronology chrono, Locale locale) {\n+        iChrono = chrono;\n+        iLocale = locale;\n+    }\n+\n+    /**\n+     * Select a format from a custom {@link DateTimeFormatterBuilder#appendPattern pattern}.\n+     *\n+     * @param pattern pattern specification\n+     * @throws IllegalArgumentException\n+     * @see DateTimeFormatterBuilder#appendPattern\n+     */\n+    public synchronized DateTimeFormatter forPattern(String pattern) {\n+        DateTimeFormatter formatter = (DateTimeFormatter)iPatternedCache.get(pattern);\n+        if (formatter != null) {\n+            return formatter;\n+        }\n+\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"Invalid pattern specification\");\n+        }\n+\n+        DateTimeFormatterBuilder builder = \n+            new DateTimeFormatterBuilder(iChrono, iLocale).appendPattern(pattern);\n+\n+        if (builder.canBuildFormatter()) {\n+            formatter = builder.toFormatter();\n+        } else if (builder.canBuildPrinter()) {\n+            formatter = new FPrinter(builder.toPrinter());\n+        } else if (builder.canBuildParser()) {\n+            // I don't expect this case to ever occur.\n+            formatter = new FParser(builder.toParser());\n+        } else {\n+            throw new UnsupportedOperationException(\"Pattern unsupported: \" + pattern);\n+        }\n+\n+        iPatternedCache.put(pattern, formatter);\n+        return formatter;\n+    }\n+\n+    /**\n+     * Select a format from a two character style pattern. The first character\n+     * is the date style, and the second character is the time style. Specify a\n+     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'\n+     * for full. A date or time may be ommitted by specifying a style character '-'.\n+     *\n+     * @param style two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @throws IllegalArgumentException\n+     */\n+    public synchronized DateTimeFormatter forStyle(String style) {\n+        DateTimeFormatter formatter = (DateTimeFormatter)iStyledCache.get(style);\n+        if (formatter == null) {\n+            formatter = forPattern(getPatternForStyle(style));\n+            iStyledCache.put(style, formatter);\n+        }\n+        return formatter;\n+    }\n+\n+    /**\n+     * Returns a pattern specification from a two character style. The first\n+     * character is the date style, and the second character is the time\n+     * style. Specify a character of 'S' for short style, 'M' for medium, 'L'\n+     * for long, and 'F' for full. A date or time may be ommitted by specifying\n+     * a style character '-'.\n+     *\n+     * @param style two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @throws IllegalArgumentException\n+     */\n+    public String getPatternForStyle(String style) {\n+        if (style == null || style.length() != 2) {\n+            throw new IllegalArgumentException(\"Invalid style specification: \" + style);\n+        }\n+\n+        if (style.charAt(1) == '-') {\n+            // date only\n+            return getDatePattern(style.charAt(0));\n+        } else if (style.charAt(0) == '-') {\n+            // time only\n+            return getTimePattern(style.charAt(1));\n+        } else {\n+            // datetime\n+            return getDateTimePattern(style.charAt(0), style.charAt(1));\n+        }\n+    }\n+\n+    private String getDatePattern(char style) {\n+        int istyle = selectStyle(style);\n+        try {\n+            return ((SimpleDateFormat)DateFormat.getDateInstance(istyle, iLocale)).toPattern();\n+        } catch (ClassCastException e) {\n+            throw new IllegalArgumentException(\"No date pattern for locale: \" + iLocale);\n+        }\n+    }\n+\n+    private String getTimePattern(char style) {\n+        int istyle = selectStyle(style);\n+        try {\n+            return ((SimpleDateFormat)DateFormat.getTimeInstance(istyle, iLocale)).toPattern();\n+        } catch (ClassCastException e) {\n+            throw new IllegalArgumentException(\"No time pattern for locale: \" + iLocale);\n+        }\n+    }\n+\n+    private String getDateTimePattern(char dateStyle, char timeStyle) {\n+        int idateStyle = selectStyle(dateStyle);\n+        int itimeStyle = selectStyle(dateStyle);\n+        try {\n+            return ((SimpleDateFormat)DateFormat.getDateTimeInstance\n+                    (idateStyle, itimeStyle, iLocale)).toPattern();\n+        } catch (ClassCastException e) {\n+            throw new IllegalArgumentException(\"No datetime pattern for locale: \" + iLocale);\n+        }\n+    }\n+\n+    private int selectStyle(char c) {\n+        switch (c) {\n+        case 'S':\n+            return DateFormat.SHORT;\n+        case 'M':\n+            return DateFormat.MEDIUM;\n+        case 'L':\n+            return DateFormat.LONG;\n+        case 'F':\n+            return DateFormat.FULL;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid style character: \" + c);\n+        }\n+    }\n+\n+    /**\n+     * A fake formatter that can only print.\n+     */\n+    private static class FPrinter implements DateTimeFormatter {\n+        private final DateTimePrinter mPrinter;\n+\n+        FPrinter(DateTimePrinter printer) {\n+            mPrinter = printer;\n+        }\n+\n+        public Chronology getChronology() {\n+            return mPrinter.getChronology();\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return mPrinter.estimatePrintedLength();\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableInstant instant) {\n+            mPrinter.printTo(buf, instant);\n+        }\n+\n+        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+            mPrinter.printTo(out, instant);\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC) {\n+            mPrinter.printTo(buf, millisUTC);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC) throws IOException {\n+            mPrinter.printTo(out, millisUTC);\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n+            mPrinter.printTo(buf, millisUTC, zone);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC, DateTimeZone zone)\n+            throws IOException {\n+            mPrinter.printTo(out, millisUTC, zone);\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            mPrinter.printTo(buf, millisUTC, zone, millisLocal);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal)\n+            throws IOException {\n+            mPrinter.printTo(out, millisUTC, zone, millisLocal);\n+        }\n+\n+        public String print(ReadableInstant instant) {\n+            return mPrinter.print(instant);\n+        }\n+\n+        public String print(long millisUTC) {\n+            return mPrinter.print(millisUTC);\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone) {\n+            return mPrinter.print(millisUTC, zone);\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            return mPrinter.print(millisUTC, zone, millisLocal);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return 0;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            throw unsupported();\n+        }\n+\n+        public int parseInto(ReadWritableInstant instant, String text, int position) {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(String text) throws ParseException {\n+            throw unsupported();\n+        }\n+\n+        public long parseMillis(String text, long millis) throws ParseException {\n+            throw unsupported();\n+        }\n+\n+        public DateTime parseDateTime(String text) throws ParseException {\n+            throw unsupported();\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+            throw unsupported();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Parsing not supported\");\n+        }\n+    }\n+\n+    /**\n+     * A fake formatter that can only parse.\n+     */\n+    private static class FParser implements DateTimeFormatter {\n+        private final DateTimeParser mParser;\n+\n+        FParser(DateTimeParser parser) {\n+            mParser = parser;\n+        }\n+\n+        public Chronology getChronology() {\n+            return mParser.getChronology();\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return 0;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long millisUTC) throws IOException {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long millisUTC, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            throw unsupported();\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            throw unsupported();\n+        }\n+\n+        public String print(ReadableInstant instant) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long millisUTC) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone) {\n+            throw unsupported();\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            throw unsupported();\n+        }\n+\n+        public int estimateParsedLength() {\n+            return mParser.estimateParsedLength();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            return mParser.parseInto(bucket, text, position);\n+        }\n+\n+        public int parseInto(ReadWritableInstant instant, String text, int position) {\n+            return mParser.parseInto(instant, text, position);\n+        }\n+\n+        public long parseMillis(String text) throws ParseException {\n+            return mParser.parseMillis(text);\n+        }\n+\n+        public long parseMillis(String text, long millis) throws ParseException {\n+            return mParser.parseMillis(text, millis);\n+        }\n+\n+        public DateTime parseDateTime(String text) throws ParseException {\n+            return mParser.parseDateTime(text);\n+        }\n+\n+        public MutableDateTime parseMutableDateTime(String text) throws ParseException {\n+            return mParser.parseMutableDateTime(text);\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Printing not supported\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.text.ParseException;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * Combined interface for printing and parsing.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public interface DateTimeFormatter extends DateTimePrinter, DateTimeParser {\n+    \n+    /**\n+     * Returns the Chronology being used by the formatter, or null if none.\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Returns the expected maximum number of characters produced. The actual\n+     * amount should rarely exceed this estimate.\n+     */\n+    int estimatePrintedLength();\n+\n+    /**\n+     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n+     * the instant.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param instant instant to format\n+     */\n+    void printTo(StringBuffer buf, ReadableInstant instant);\n+\n+    /**\n+     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n+     * the instant.\n+     *\n+     * @param out formatted instant is written out\n+     * @param instant instant to format\n+     */\n+    void printTo(Writer out, ReadableInstant instant) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(StringBuffer buf, long millisUTC);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(Writer out, long millisUTC) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     */\n+    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     */\n+    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n+     * printers\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     */\n+    void printTo(StringBuffer buf, long millisUTC,\n+                 DateTimeZone zone, long millisLocal);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n+     * printers\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     */\n+    void printTo(Writer out, long millisUTC,\n+                 DateTimeZone zone, long millisLocal) throws IOException;\n+\n+    /**\n+     * Prints a ReadableInstant to a new String, attempting to use the\n+     * DateTimeZone supplied by the instant.\n+     *\n+     * @param instant instant to format\n+     * @return the printed result\n+     */\n+    String print(ReadableInstant instant);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    String print(long millisUTC);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @return the printed result\n+     */\n+    String print(long millisUTC, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     * @return the printed result\n+     */\n+    String print(long millisUTC, DateTimeZone zone, long millisLocal);\n+\n+    /**\n+     * Returns the expected maximum number of characters consumed. The actual\n+     * amount should rarely exceed this estimate.\n+     */\n+    int estimateParsedLength();\n+\n+    /**\n+     * Parse an element from the given text, saving any fields into the given\n+     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n+     * text position. Note that the parse may succeed without fully reading the\n+     * text.\n+     * <p>\n+     * If it fails, the return value is negative. To determine the position\n+     * where the parse failed, apply the one's complement operator (~) on the\n+     * return value.\n+     *\n+     * @param bucket field are saved into this\n+     * @param text the text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(DateTimeParserBucket bucket, String text, int position);\n+\n+    /**\n+     * Parses a datetime from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableInstant. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the instant may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param instant an instant that will be modified\n+     * @param text text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritableInstant instant, String text, int position);\n+\n+    /**\n+     * Parses a datetime from the given text, returning the number of\n+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     *\n+     * @param text text to parse\n+     * @return parsed value expressed in milliseconds since the epoch\n+     * @throws ParseException if any field is out of range\n+     */\n+    long parseMillis(String text) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, at the given position, returning\n+     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An\n+     * initial millisecond value is passed in, which is relative to the epoch,\n+     * local time.\n+     *\n+     * @param text text to parse\n+     * @param millis initial value of millis, relative to the epoch, local time\n+     * @return parsed value expressed in milliseconds since the epoch, UTC\n+     * @throws ParseException if any field is out of range\n+     */\n+    long parseMillis(String text, long millis) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime.\n+     *\n+     * @param text text to parse\n+     * @return parsed value in a DateTime object\n+     * @throws ParseException if any field is out of range\n+     */\n+    DateTime parseDateTime(String text) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime.\n+     *\n+     * @param text text to parse\n+     * @return parsed value in a MutabkeDateTime object\n+     * @throws ParseException if any field is out of range\n+     */\n+    MutableDateTime parseMutableDateTime(String text) throws ParseException;\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.FractionalDateTimeField;\n+import org.joda.time.chrono.RemainderDateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.\n+ * DateTimeFormatters can be built by appending specific fields, patterns, or\n+ * other formatters.\n+ *\n+ * <p>\n+ * For example, a formatter that prints month and year, like \"January 1970\", can\n+ * be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n+ *     .appendMonthOfYearText()\n+ *     .appendLiteral(' ')\n+ *     .appendYear(4, 4)\n+ *     .toFormatter();\n+ * </pre>\n+ *\n+ * @see DateTimeFormat\n+ * @author Brian S O'Neill\n+ */\n+public class DateTimeFormatterBuilder {\n+\n+    private static String parseToken(String pattern, int[] indexRef) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+                \n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    private final Chronology iChrono;\n+    private final Chronology iChronoUTC;\n+    private final Locale iLocale;\n+\n+    // Array contents alternate between printers and parsers.\n+    private ArrayList iElementPairs;\n+    private Object iFormatter;\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n+     * default time zone and locale.\n+     */\n+    public DateTimeFormatterBuilder() {\n+        this(ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n+     * given time zone, with the default locale.\n+     */\n+    public DateTimeFormatterBuilder(DateTimeZone zone) {\n+        this(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the\n+     * given time zone, with any locale.\n+     */\n+    public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {\n+        this(ISOChronology.getInstance(zone), locale);\n+    }\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder with any chronology and the default\n+     * locale.\n+     *\n+     * @param chrono Chronology to use\n+     */\n+    public DateTimeFormatterBuilder(Chronology chrono) {\n+        this(chrono, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Creates a DateTimeFormatterBuilder with any chronology and locale.\n+     *\n+     * @param chrono Chronology to use\n+     * @param locale Locale to use\n+     */\n+    public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        if (locale == null) {\n+            throw new IllegalArgumentException(\"The Locale must not be null\");\n+        }\n+        iChrono = chrono;\n+        iChronoUTC = chrono.withUTC();\n+        DateTimeZone zone = chrono.getDateTimeZone();\n+        iLocale = locale;\n+        iElementPairs = new ArrayList();\n+    }\n+\n+    /**\n+     * Returns the chronology being used by the formatter builder.\n+     */\n+    public Chronology getChronology() {\n+        return iChrono;\n+    }\n+\n+    /**\n+     * Returns the locale being used the formatter builder.\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n+    /**\n+     * Converts to a DateTimePrinter that prints using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * printer.\n+     *\n+     * @throws UnsupportedOperationException if any formatter element doesn't support\n+     * printing\n+     */\n+    public DateTimePrinter toPrinter() throws UnsupportedOperationException {\n+        Object f = getFormatter();\n+        if (isPrinter(f)) {\n+            return (DateTimePrinter)f;\n+        }\n+        throw new UnsupportedOperationException(\"Printing not supported\");\n+    }\n+\n+    /**\n+     * Converts to a DateTimeParser that parses using all the appended\n+     * elements. Subsequent changes to this builder do not affect the returned\n+     * parser.\n+     *\n+     * @throws UnsupportedOperationException if any formatter element doesn't support\n+     * parsing\n+     */\n+    public DateTimeParser toParser() throws UnsupportedOperationException {\n+        Object f = getFormatter();\n+        if (isParser(f)) {\n+            return (DateTimeParser)f;\n+        }\n+        throw new UnsupportedOperationException(\"Parsing not supported\");\n+    }\n+\n+    /**\n+     * Converts to a DateTimeFormatter that prints and parses using all the\n+     * appended elements. Subsequent changes to this builder do not affect the\n+     * returned formatter.\n+     *\n+     * @throws UnsupportedOperationException if any formatter element doesn't support\n+     * both printing and parsing\n+     */\n+    public DateTimeFormatter toFormatter() throws UnsupportedOperationException {\n+        Object f = getFormatter();\n+        if (isFormatter(f)) {\n+            return (DateTimeFormatter)f;\n+        }\n+        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n+    }\n+\n+    /**\n+     * Returns true if toPrinter can be called without throwing an\n+     * UnsupportedOperationException.\n+     */\n+    public boolean canBuildPrinter() {\n+        return isPrinter(getFormatter());\n+    }\n+\n+    /**\n+     * Returns true if toParser can be called without throwing an\n+     * UnsupportedOperationException.\n+     */\n+    public boolean canBuildParser() {\n+        return isParser(getFormatter());\n+    }\n+\n+    /**\n+     * Returns true if toFormatter can be called without throwing an\n+     * UnsupportedOperationException.\n+     */\n+    public boolean canBuildFormatter() {\n+        return isFormatter(getFormatter());\n+    }\n+\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be\n+     * reused.\n+     */\n+    public void clear() {\n+        iFormatter = null;\n+        iElementPairs.clear();\n+    }\n+\n+    /**\n+     * Appends another formatter.\n+     *\n+     * @throws IllegalArgumentException if formatter is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimeFormatter formatter)\n+        throws IllegalArgumentException\n+    {\n+        if (formatter == null) {\n+            throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        return append0(formatter);\n+    }\n+\n+    /**\n+     * Appends just a printer. With no matching parser, a parser cannot be\n+     * built from this DateTimeFormatterBuilder.\n+     *\n+     * @throws IllegalArgumentException if printer is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer)\n+        throws IllegalArgumentException\n+    {\n+        if (printer == null) {\n+            throw new IllegalArgumentException(\"No printer supplied\");\n+        }\n+        return append0(printer, null);\n+    }\n+\n+    /**\n+     * Appends just a parser. With no matching printer, a printer cannot be\n+     * built from this builder.\n+     *\n+     * @throws IllegalArgumentException if parser is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n+        if (parser == null) {\n+            throw new IllegalArgumentException(\"No parser supplied\");\n+        }\n+        return append0(null, parser);\n+    }\n+\n+    /**\n+     * Appends a printer/parser pair.\n+     *\n+     * @throws IllegalArgumentException if printer or parser is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n+                                           DateTimeParser parser)\n+        throws IllegalArgumentException\n+    {\n+        if (printer == null) {\n+            throw new IllegalArgumentException(\"No printer supplied\");\n+        }\n+        if (parser == null) {\n+            throw new IllegalArgumentException(\"No parser supplied\");\n+        }\n+        return append0(printer, parser);\n+    }\n+\n+    /**\n+     * Appends a printer and a set of matching parsers. When parsing, the first\n+     * parser in the list is selected for parsing. If it fails, the next is\n+     * chosen, and so on. If none of these parsers succeeds, then the failed\n+     * position of the parser that made the greatest progress is returned.\n+     * <p>\n+     * Only the printer is optional. In addtion, it is illegal for any but the\n+     * last of the parser array elements to be null. If the last element is\n+     * null, this represents the empty parser. The presence of an empty parser\n+     * indicates that the entire array of parse formats is optional.\n+     *\n+     * @throws IllegalArgumentException if any parser element but the last is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer,\n+                                           DateTimeParser[] parsers)\n+        throws IllegalArgumentException\n+    {\n+        if (parsers == null) {\n+            throw new IllegalArgumentException(\"No parsers supplied\");\n+        }\n+        int length = parsers.length;\n+        if (length == 1) {\n+            // If the last element is null, an exception is still thrown.\n+            return append(printer, parsers[0]);\n+        }\n+\n+        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n+        int i;\n+        for (i = 0; i < length - 1; i++) {\n+            if ((copyOfParsers[i] = parsers[i]) == null) {\n+                throw new IllegalArgumentException(\"Incomplete parser array\");\n+            }\n+        }\n+        copyOfParsers[i] = parsers[i];\n+\n+        return append0(printer, new MatchingParser(iChrono, copyOfParsers));\n+    }\n+\n+    /**\n+     * Appends just a parser element which is optional. With no matching\n+     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n+     *\n+     * @throws IllegalArgumentException if parser is null\n+     */\n+    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n+        if (parser == null) {\n+            throw new IllegalArgumentException(\"No parser supplied\");\n+        }\n+        return append0(null, new MatchingParser(iChrono, new DateTimeParser[] {parser, null}));\n+    }\n+\n+    private DateTimeFormatterBuilder append0(Object element) {\n+        iFormatter = null;\n+        // Add the element as both a printer and parser.\n+        iElementPairs.add(element);\n+        iElementPairs.add(element);\n+        return this;\n+    }\n+\n+    private DateTimeFormatterBuilder append0(DateTimePrinter printer,\n+                                             DateTimeParser parser)\n+    {\n+        iFormatter = null;\n+        iElementPairs.add(printer);\n+        iElementPairs.add(parser);\n+        return this;\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a specific character, and the parser to\n+     * expect it. The parser is case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendLiteral(char c) {\n+        return append0(new CharacterLiteral(iChrono, c));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect\n+     * it. The parser is case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendLiteral(String text) {\n+        return append0(new StringLiteral(iChrono, text));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a decimal number, and the\n+     * parser to expect an unsigned decimal number.\n+     *\n+     * @param field field should operate in UTC or be time zone agnostic\n+     * @param minDigits minumum number of digits to <i>print</i>\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendNumeric(DateTimeField field,\n+                                                  int minDigits, int maxDigits)\n+    {\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (minDigits <= 1) {\n+            return append0(new UnpaddedNumber(iChrono, field, maxDigits, false));\n+        } else {\n+            return append0(new PaddedNumber(iChrono, field, maxDigits, false, minDigits));\n+        }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a decimal number, and the\n+     * parser to expect a signed decimal number.\n+     *\n+     * @param field field should operate in UTC or be time zone agnostic\n+     * @param minDigits minumum number of digits to <i>print</i>\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendSignedNumeric(DateTimeField field,\n+                                                        int minDigits, int maxDigits)\n+    {\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (minDigits <= 1) {\n+            return append0(new UnpaddedNumber(iChrono, field, maxDigits, true));\n+        } else {\n+            return append0(new PaddedNumber(iChrono, field, maxDigits, true, minDigits));\n+        }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as text, and the\n+     * parser to expect text.\n+     *\n+     * @param field field should operate in UTC or be time zone agnostic\n+     */\n+    public DateTimeFormatterBuilder appendText(DateTimeField field) {\n+        return append0(new TextField(iChrono, field, iLocale, false));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as short text, and the\n+     * parser to expect text.\n+     *\n+     * @param field field should operate in UTC or be time zone agnostic\n+     */\n+    public DateTimeFormatterBuilder appendShortText(DateTimeField field) {\n+        return append0(new TextField(iChrono, field, iLocale, true));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a remainder of time as a decimal fraction,\n+     * sans decimal point. For example, if the range is specified as 60000\n+     * (milliseconds in one minute) and the time is 12:30:45, the value printed\n+     * is 75. A decimal point is implied, so the fraction is 0.75, or three-quarters\n+     * of a minute.\n+     *\n+     * @param minDigits minumum number of digits to print.\n+     * @param maxDigits maximum number of digits to print or parse.\n+     * @param rangeInMillis range of values in fraction\n+     */\n+    public DateTimeFormatterBuilder appendFraction(int minDigits, int maxDigits,\n+                                                   int rangeInMillis)\n+    {\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return append0(new Fraction(iChrono, minDigits, maxDigits, rangeInMillis));\n+    }\n+\n+    /**\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to print or parse\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n+        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_SECOND);\n+    }\n+\n+    /**\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to print or parse\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n+        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_MINUTE);\n+    }\n+\n+    /**\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to print or parse\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n+        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_HOUR);\n+    }\n+\n+    /**\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to print or parse\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n+        return appendFraction\n+            (minDigits, maxDigits, DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric millisOfSecond field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n+        return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric millisOfDay field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n+        return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric secondOfMinute field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n+        return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric secondOfDay field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n+        return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric minuteOfHour field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n+        return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric minuteOfDay field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n+        return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric hourOfDay field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n+        return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric clockhourOfDay field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n+        return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric hourOfHalfday field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n+        return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n+        return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfWeek field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n+        return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfMonth field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n+        return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfYear field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n+        return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekOfWeekyear field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n+        return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field.\n+     *\n+     * @param minDigits minumum number of digits to <i>print</i>\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n+        return appendNumeric\n+            (iChronoUTC.weekyear(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric monthOfYear field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n+        return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year field.\n+     *\n+     * @param minDigits minumum number of digits to <i>print</i>\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n+        return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric yearOfEra field.\n+     *\n+     * @param minDigits minumum number of digits to <i>print</i>\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n+        return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year of century field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n+        return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric century of era field.\n+     *\n+     * @param minDigits minumum number of digits to print\n+     * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     */\n+    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n+        return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific AM/PM text, and the\n+     * parser to expect it. The parser is case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n+        return appendText(iChronoUTC.halfdayOfDay());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n+     * parser will accept a long or short dayOfWeek text, case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeekText() {\n+        return appendText(iChronoUTC.dayOfWeek());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific dayOfWeek\n+     * text. The parser will accept a long or short dayOfWeek text,\n+     * case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n+        return appendShortText(iChronoUTC.dayOfWeek());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific monthOfYear\n+     * text. The parser will accept a long or short monthOfYear text,\n+     * case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYearText() { \n+        return appendText(iChronoUTC.monthOfYear());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific monthOfYear text. The\n+     * parser will accept a long or short monthOfYear text, case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n+        return appendShortText(iChronoUTC.monthOfYear());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n+     * the parser to expect it. The parser is case-insensitive.\n+     */\n+    public DateTimeFormatterBuilder appendEraText() {\n+        return appendText(iChronoUTC.era());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific time zone name. A\n+     * parser cannot be created from this builder if a time zone name is\n+     * appended.\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneName() {\n+        return append0(new TimeZonePrinter(iChrono, iLocale, false), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific time zone\n+     * name. A parser cannot be created from this builder if time zone\n+     * name is appended.\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n+        return append0(new TimeZonePrinter(iChrono, iLocale, true), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit text and numbers to display time zone\n+     * offset from UTC. A parser will use the parsed time zone offset to adjust\n+     * the datetime.\n+     *\n+     * @param zeroOffsetText Text to use if time zone offset is zero. If\n+     * null, offset is always shown.\n+     * @param showSeparators If true, prints ':' separator before minute and\n+     * second field and prints '.' separator before fraction field.\n+     * @param minFields minimum number of fields to print, stopping when no\n+     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n+     * @param maxFields maximum number of fields to print\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText,\n+                                                         boolean showSeparators,\n+                                                         int minFields, int maxFields)\n+    {\n+        return append0(new TimeZoneOffsetFormatter\n+                       (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));\n+    }\n+\n+    /**\n+     * The pattern syntax is compatible with java.text.SimpleDateFormat, but a\n+     * few more symbols are also supported.\n+     * <p>\n+     * To specify the time format use a <em>time pattern</em> string.\n+     * In this pattern, all ASCII letters are reserved as pattern letters,\n+     * which are defined as the following:\n+     * <blockquote>\n+     * <pre>\n+     * Symbol  Meaning                      Presentation  Examples\n+     * ------  -------                      ------------  -------\n+     * G       era                          text          AD\n+     * C       century of era (&gt;=0)         number        20\n+     * Y       year of era (&gt;=0)            year          1996\n+     *\n+     * x       weekyear                     year          1996\n+     * w       week of weekyear             number        27\n+     * e       day of week                  number        2\n+     * E       day of week                  text          Tuesday; Tue\n+     *\n+     * y       year                         year          1996\n+     * D       day of year                  number        189\n+     * M       month of year                month         July; Jul; 07\n+     * d       day of month                 number        10\n+     *\n+     * a       halfday of day               text          PM\n+     * K       hour of halfday (0~11)       number        0\n+     * h       clockhour of halfday (1~12)  number        12\n+     *\n+     * H       hour of day (0~23)           number        0\n+     * k       clockhour of day (1~24)      number        24\n+     * m       minute of hour               number        30\n+     * s       second of minute             number        55\n+     * S       fraction of second           number        978\n+     *\n+     * z       time zone                    text          Pacific Standard Time; PST\n+     * Z       RFC 822 time zone            text          -0800; -08:00\n+     *\n+     * '       escape for text              delimiter\n+     * ''      single quote                 literal       '\n+     * </pre>\n+     * </blockquote>\n+     * The count of pattern letters determine the format.\n+     * <p>\n+     * <strong>Text</strong>: If the number of pattern letters is 4 or more,\n+     * the full form is used; otherwise a short or abbreviated form is used if\n+     * available.\n+     * <p>\n+     * <strong>Number</strong>: The minimum number of digits. Shorter numbers\n+     * are zero-padded to this amount.\n+     * <p>\n+     * <strong>Year</strong>: Numeric presentation for year and weekyear fields\n+     * are handled specially. For example, if the count of 'y' is 2, the year\n+     * will be displayed as the zero-based year of the century, which is two\n+     * digits.\n+     * <p>\n+     * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n+     * <p>\n+     * Any characters in the pattern that are not in the ranges of ['a'..'z']\n+     * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n+     * like ':', '.', ' ', '#' and '@' will appear in the resulting time text\n+     * even they are not embraced within single quotes.\n+     */\n+    public DateTimeFormatterBuilder appendPattern(String pattern)\n+        throws IllegalArgumentException\n+    {\n+        int length = pattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i=0; i<length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(pattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                appendEraText();\n+                break;\n+            case 'C': // century of era (number)\n+                appendCenturyOfEra(tokenLen, tokenLen);\n+                break;\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+                if (tokenLen == 2) {\n+                    // Use a new RemainderDateTimeField to ensure that the year\n+                    // of century is zero-based.\n+                    DateTimeField field;\n+                    switch (c) {\n+                    case 'x':\n+                        field = new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                        break;\n+                    case 'y': default:\n+                        field = new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                        break;\n+                    case 'Y':\n+                        field = new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                        break;\n+                    }\n+                    appendNumeric(field, 2, 2);\n+                } else {\n+                    // Try to support long year values.\n+                    int maxDigits = 9;\n+\n+                    // Peek ahead to next token.\n+                    if (i + 1 < length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            // If next token is a number, cannot support long years.\n+                            maxDigits = tokenLen;\n+                        }\n+                        indexRef[0]--;\n+                    }\n+\n+                    switch (c) {\n+                    case 'x':\n+                        appendWeekyear(tokenLen, maxDigits);\n+                        break;\n+                    case 'y':\n+                        appendYear(tokenLen, maxDigits);\n+                        break;\n+                    case 'Y':\n+                        appendYearOfEra(tokenLen, maxDigits);\n+                        break;\n+                    }\n+                }\n+                break;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen >= 3) {\n+                    if (tokenLen >= 4) {\n+                        appendMonthOfYearText();\n+                    } else {\n+                        appendMonthOfYearShortText();\n+                    }\n+                } else {\n+                    appendMonthOfYear(tokenLen);\n+                }\n+                break;\n+            case 'd': // day of month (number)\n+                appendDayOfMonth(tokenLen);\n+                break;\n+            case 'h': // hour of day (number, 1..12)\n+                appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case 'H': // hour of day (number, 0..23)\n+                appendHourOfDay(tokenLen);\n+                break;\n+            case 'm': // minute of hour (number)\n+                appendMinuteOfHour(tokenLen);\n+                break;\n+            case 's': // second of minute (number)\n+                appendSecondOfMinute(tokenLen);\n+                break;\n+            case 'S': // fraction of second (number)\n+                appendFractionOfSecond(tokenLen, tokenLen);\n+                break;\n+            case 'e': // day of week (number)\n+                appendDayOfWeek(tokenLen);\n+                break;\n+            case 'E': // dayOfWeek (text)\n+                if (tokenLen >= 4) {\n+                    appendDayOfWeekText();\n+                } else {\n+                    appendDayOfWeekShortText();\n+                }\n+                break;\n+            case 'D': // day of year (number)\n+                appendDayOfYear(tokenLen);\n+                break;\n+            case 'w': // week of weekyear (number)\n+                appendWeekOfWeekyear(tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                appendHalfdayOfDayText();\n+                break;\n+            case 'k': // hour of day (1..24)\n+                appendClockhourOfDay(tokenLen);\n+                break;\n+            case 'K': // hour of day (0..11)\n+                appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    appendTimeZoneName();\n+                } else {\n+                    appendTimeZoneShortName();\n+                }\n+                break;\n+            case 'Z': // RFC 822 time zone\n+                if (tokenLen >= 4) {\n+                    appendTimeZoneOffset(null, true, 2, 2);\n+                } else {\n+                    appendTimeZoneOffset(null, false, 2, 2);\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    appendLiteral(sub.charAt(0));\n+                } else {\n+                    // Create copy of sub since otherwise the temporary quoted\n+                    // string would still be referenced internally.\n+                    appendLiteral(new String(sub));\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException\n+                    (\"Illegal pattern component: \" + token);\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    // Returns true if token should be parsed as a numeric field.\n+    private boolean isNumericToken(String token) {\n+        int tokenLen = token.length();\n+        if (tokenLen > 0) {\n+            char c = token.charAt(0);\n+            switch (c) {\n+            case 'c': // century (number)\n+            case 'C': // century of era (number)\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+            case 'd': // day of month (number)\n+            case 'h': // hour of day (number, 1..12)\n+            case 'H': // hour of day (number, 0..23)\n+            case 'm': // minute of hour (number)\n+            case 's': // second of minute (number)\n+            case 'S': // fraction of second (number)\n+            case 'e': // day of week (number)\n+            case 'D': // day of year (number)\n+            case 'F': // day of week in month (number)\n+            case 'w': // week of year (number)\n+            case 'W': // week of month (number)\n+            case 'k': // hour of day (1..24)\n+            case 'K': // hour of day (0..11)\n+                return true;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen <= 2) {\n+                    return true;\n+                }\n+            }\n+        }\n+            \n+        return false;\n+    }\n+\n+    private Object getFormatter() {\n+        Object f = iFormatter;\n+\n+        if (f == null) {\n+            if (iElementPairs.size() == 2) {\n+                Object printer = iElementPairs.get(0);\n+                Object parser = iElementPairs.get(1);\n+\n+                if (printer != null) {\n+                    if (printer == parser || parser == null) {\n+                        f = printer;\n+                    }\n+                } else {\n+                    f = parser;\n+                }\n+            }\n+\n+            if (f == null) {\n+                f = new Composite(iChrono, iElementPairs);\n+            }\n+\n+            iFormatter = f;\n+        }\n+\n+        return f;\n+    }\n+\n+    private boolean isPrinter(Object f) {\n+        if (f instanceof DateTimePrinter) {\n+            if (f instanceof Composite) {\n+                return ((Composite)f).isPrinter();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isParser(Object f) {\n+        if (f instanceof DateTimeParser) {\n+            if (f instanceof Composite) {\n+                return ((Composite)f).isParser();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isFormatter(Object f) {\n+        if (f instanceof DateTimeFormatter) {\n+            if (f instanceof Composite) {\n+                return ((Composite)f).isPrinter()\n+                    && ((Composite)f).isParser();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static abstract class AbstractFormatter extends AbstractDateTimeFormatter {\n+        protected final Chronology iChrono;\n+\n+        AbstractFormatter(Chronology chrono) {\n+            iChrono = chrono;\n+        }\n+\n+        public Chronology getChronology() {\n+            return iChrono;\n+        }\n+\n+        protected final DateTimeZone getDateTimeZone() {\n+            DateTimeZone zone = iChrono.getDateTimeZone();\n+            return zone == null ? DateTimeZone.UTC : zone;\n+        }\n+    }\n+\n+    private static class CharacterLiteral extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final char iValue;\n+\n+        CharacterLiteral(Chronology chrono, char value) {\n+            super(chrono);\n+            iValue = value;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return 1;\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            return String.valueOf(iValue);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return 1;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            if (position >= text.length()) {\n+                return ~position;\n+            }\n+\n+            char a = text.charAt(position);\n+            char b = iValue;\n+\n+            if (a != b) {\n+                a = Character.toUpperCase(a);\n+                b = Character.toUpperCase(b);\n+                if (a != b) {\n+                    a = Character.toLowerCase(a);\n+                    b = Character.toLowerCase(b);\n+                    if (a != b) {\n+                        return ~position;\n+                    }\n+                }\n+            }\n+\n+            return position + 1;\n+        }\n+    }\n+\n+    private static class StringLiteral extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final String iValue;\n+\n+        StringLiteral(Chronology chrono, String value) {\n+            super(chrono);\n+            iValue = value;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iValue.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            return iValue;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iValue.length();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n+                return position + iValue.length();\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    private abstract static class NumberFormatter extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        protected final DateTimeField iField;\n+        protected final int iMaxParsedDigits;\n+        protected final boolean iSigned;\n+\n+        NumberFormatter(Chronology chrono,\n+                        DateTimeField field, int maxParsedDigits,\n+                        boolean signed) {\n+            super(chrono);\n+            iField = field;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iSigned = signed;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n+\n+            boolean negative = false;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n+                    negative = c == '-';\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            int value;\n+            if (length == 3 && negative) {\n+                value = -FormatUtils.parseTwoDigits(text, position + 1);\n+            } else if (length == 2) {\n+                if (negative) {\n+                    value = text.charAt(position + 1) - '0';\n+                    value = -value;\n+                } else {\n+                    value = FormatUtils.parseTwoDigits(text, position);\n+                }\n+            } else if (length == 1 && !negative) {\n+                value = text.charAt(position) - '0';\n+            } else {\n+                String sub = text.substring(position, position + length);\n+                try {\n+                    value = Integer.parseInt(sub);\n+                } catch (NumberFormatException e) {\n+                    return ~position;\n+                }\n+            }\n+\n+            bucket.saveField(iField, value);\n+\n+            return position + length;\n+        }\n+    }\n+\n+    private static class UnpaddedNumber extends NumberFormatter {\n+        UnpaddedNumber(Chronology chrono,\n+                       DateTimeField field, int maxParsedDigits,\n+                       boolean signed)\n+        {\n+            super(chrono, field, maxParsedDigits, signed);\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            FormatUtils.appendUnpaddedInteger(buf, iField.get(millisLocal));\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            FormatUtils.writeUnpaddedInteger(out, iField.get(millisLocal));\n+        }\n+    }\n+\n+    private static class PaddedNumber extends NumberFormatter {\n+        private final int iMinPrintedDigits;\n+\n+        PaddedNumber(Chronology chrono,\n+                     DateTimeField field, int maxParsedDigits,\n+                     boolean signed, int minPrintedDigits)\n+        {\n+            super(chrono, field, maxParsedDigits, signed);\n+            iMinPrintedDigits = minPrintedDigits;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            FormatUtils.appendPaddedInteger\n+                (buf, iField.get(millisLocal), iMinPrintedDigits);\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            FormatUtils.writePaddedInteger\n+                (out, iField.get(millisLocal), iMinPrintedDigits);\n+        }\n+    }\n+\n+    private static class TextField extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final DateTimeField iField;\n+        private final Locale iLocale;\n+        private final boolean iShort;\n+\n+        TextField(Chronology chrono,\n+                  DateTimeField field, Locale locale, boolean isShort) {\n+            super(chrono);\n+            iField = field;\n+            iLocale = locale;\n+            iShort = isShort;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            if (iShort) {\n+                return iField.getMaximumShortTextLength(iLocale);\n+            } else {\n+                return iField.getMaximumTextLength(iLocale);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            buf.append(print(millisUTC, zone, millisLocal));\n+        }\n+    \n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            out.write(print(millisUTC, zone, millisLocal));\n+        }\n+\n+        public final String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            if (iShort) {\n+                return iField.getAsShortText(millisLocal, iLocale);\n+            } else {\n+                return iField.getAsText(millisLocal, iLocale);\n+            }\n+        }\n+\n+        public int estimateParsedLength() {\n+            return estimatePrintedLength();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = text.length();\n+            int i = position;\n+            for (; i<limit; i++) {\n+                char c = text.charAt(i);\n+                if (c < 'A') {\n+                    break;\n+                }\n+                if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || Character.isLetter(c)) {\n+                    continue;\n+                }\n+                break;\n+            }\n+\n+            if (i == position) {\n+                return ~position;\n+            }\n+\n+            bucket.saveField(iField, text.substring(position, i), iLocale);\n+\n+            return i;\n+        }\n+    }\n+\n+    private static class Fraction extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final int iMinDigits;\n+        private final int iMaxDigits;\n+        private final int iRange;\n+\n+        private final long iScaler;\n+\n+        private transient DateTimeField iField;\n+\n+        Fraction(Chronology chrono,\n+                 int minDigits, int maxDigits, int rangeInMillis) {\n+            super(chrono);\n+\n+            // Limit the precision requirements.\n+            if (maxDigits > 18) {\n+                maxDigits = 18;\n+            }\n+\n+            iMinDigits = minDigits;\n+            iRange = rangeInMillis;\n+\n+            long scaler;\n+            while (true) {\n+                switch (maxDigits) {\n+                default: scaler = 1L; break;\n+                case 1:  scaler = 10L; break;\n+                case 2:  scaler = 100L; break;\n+                case 3:  scaler = 1000L; break;\n+                case 4:  scaler = 10000L; break;\n+                case 5:  scaler = 100000L; break;\n+                case 6:  scaler = 1000000L; break;\n+                case 7:  scaler = 10000000L; break;\n+                case 8:  scaler = 100000000L; break;\n+                case 9:  scaler = 1000000000L; break;\n+                case 10: scaler = 10000000000L; break;\n+                case 11: scaler = 100000000000L; break;\n+                case 12: scaler = 1000000000000L; break;\n+                case 13: scaler = 10000000000000L; break;\n+                case 14: scaler = 100000000000000L; break;\n+                case 15: scaler = 1000000000000000L; break;\n+                case 16: scaler = 10000000000000000L; break;\n+                case 17: scaler = 100000000000000000L; break;\n+                case 18: scaler = 1000000000000000000L; break;\n+                }\n+                if (((rangeInMillis * scaler) / scaler) == rangeInMillis) {\n+                    break;\n+                }\n+                // Overflowed: scale down.\n+                maxDigits--;\n+            }\n+\n+            iMaxDigits = maxDigits;\n+            iScaler = scaler;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            try {\n+                printTo(buf, null, millisLocal);\n+            } catch (IOException e) {\n+                // Not gonna happen.\n+            }\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            printTo(null, out, millisLocal);\n+        }\n+\n+        private void printTo(StringBuffer buf, Writer out, long millis)\n+            throws IOException\n+        {\n+            long fraction;\n+            if (millis >= 0) {\n+                fraction = millis % iRange;\n+            } else {\n+                fraction = iRange - 1 + (millis + 1) % iRange;\n+            }\n+\n+            int minDigits = iMinDigits;\n+\n+            if (fraction == 0) {\n+                if (buf != null) {\n+                    while (--minDigits >= 0) {\n+                        buf.append('0');\n+                    }\n+                } else {\n+                    while (--minDigits >= 0) {\n+                        out.write('0');\n+                    }\n+                }\n+                return;\n+            }\n+\n+            String str;\n+            long scaled = fraction * iScaler / iRange;\n+            if ((scaled & 0x7fffffff) == scaled) {\n+                str = Integer.toString((int)scaled);\n+            } else {\n+                str = Long.toString(scaled);\n+            }\n+\n+            int length = str.length();\n+            int digits = iMaxDigits;\n+\n+            while (length < digits) {\n+                if (buf != null) {\n+                    buf.append('0');\n+                } else {\n+                    out.write('0');\n+                }\n+                minDigits--;\n+                digits--;\n+            }\n+\n+            if (minDigits < digits) {\n+                // Chop off as many trailing zero digits as necessary.\n+                while (minDigits < digits) {\n+                    if (length <= 1 || str.charAt(length - 1) != '0') {\n+                        break;\n+                    }\n+                    digits--;\n+                    length--;\n+                }\n+                if (length < str.length()) {\n+                    if (buf != null) {\n+                        for (int i=0; i<length; i++) {\n+                            buf.append(str.charAt(i));\n+                        }\n+                    } else {\n+                        for (int i=0; i<length; i++) {\n+                            out.write(str.charAt(i));\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+\n+            if (buf != null) {\n+                buf.append(str);\n+            } else {\n+                out.write(str);\n+            }\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = Math.min(iMaxDigits, text.length() - position);\n+\n+            long value = 0;\n+            long n = iRange;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+                if (c != '0') {\n+                    value += (c - '0') * n / 10;\n+                }\n+                n /= 10;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            if (value > Integer.MAX_VALUE) {\n+                return ~position;\n+            }\n+\n+            if (iField == null) {\n+                iField = new FractionalDateTimeField(\"\", 1, iRange);\n+            }\n+\n+            bucket.saveField(iField, (int)value);\n+\n+            return position + length;\n+        }\n+    }\n+\n+    private static class TimeZoneOffsetFormatter extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final String iZeroOffsetText;\n+        private final boolean iShowSeparators;\n+        private final int iMinFields;\n+        private final int iMaxFields;\n+\n+        TimeZoneOffsetFormatter(Chronology chrono,\n+                                String zeroOffsetText,\n+                                boolean showSeparators,\n+                                int minFields, int maxFields)\n+        {\n+            super(chrono);\n+            iZeroOffsetText = zeroOffsetText;\n+            iShowSeparators = showSeparators;\n+            if (minFields <= 0 || maxFields < minFields) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (minFields > 4) {\n+                minFields = 4;\n+                maxFields = 4;\n+            }\n+            iMinFields = minFields;\n+            iMaxFields = maxFields;\n+        }\n+            \n+        public int estimatePrintedLength() {\n+            int est = 1 + iMinFields << 1;\n+            if (iShowSeparators) {\n+                est += iMinFields - 1;\n+            }\n+            if (iZeroOffsetText != null && iZeroOffsetText.length() > est) {\n+                est = iZeroOffsetText.length();\n+            }\n+            return est;\n+        }\n+        \n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            int offset = (int)(millisLocal - millisUTC);\n+\n+            if (offset == 0 && iZeroOffsetText != null) {\n+                buf.append(iZeroOffsetText);\n+                return;\n+            }\n+            if (offset >= 0) {\n+                buf.append('+');\n+            } else {\n+                buf.append('-');\n+                offset = -offset;\n+            }\n+\n+            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+            FormatUtils.appendPaddedInteger(buf, hours, 2);\n+            if (iMaxFields == 1) {\n+                return;\n+            }\n+            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (offset == 0 && iMinFields <= 1) {\n+                return;\n+            }\n+\n+            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (iShowSeparators) {\n+                buf.append(':');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n+            if (iMaxFields == 2) {\n+                return;\n+            }\n+            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (offset == 0 && iMinFields <= 2) {\n+                return;\n+            }\n+\n+            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+            if (iShowSeparators) {\n+                buf.append(':');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n+            if (iMaxFields == 3) {\n+                return;\n+            }\n+            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (offset == 0 && iMinFields <= 3) {\n+                return;\n+            }\n+\n+            if (iShowSeparators) {\n+                buf.append('.');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, offset, 3);\n+        }\n+        \n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            int offset = (int)(millisLocal - millisUTC);\n+\n+            if (offset == 0 && iZeroOffsetText != null) {\n+                out.write(iZeroOffsetText);\n+                return;\n+            }\n+            if (offset >= 0) {\n+                out.write('+');\n+            } else {\n+                out.write('-');\n+                offset = -offset;\n+            }\n+\n+            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+            FormatUtils.writePaddedInteger(out, hours, 2);\n+            if (iMaxFields == 1) {\n+                return;\n+            }\n+            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (offset == 0 && iMinFields == 1) {\n+                return;\n+            }\n+\n+            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (iShowSeparators) {\n+                out.write(':');\n+            }\n+            FormatUtils.writePaddedInteger(out, minutes, 2);\n+            if (iMaxFields == 2) {\n+                return;\n+            }\n+            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (offset == 0 && iMinFields == 2) {\n+                return;\n+            }\n+\n+            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+            if (iShowSeparators) {\n+                out.write(':');\n+            }\n+            FormatUtils.writePaddedInteger(out, seconds, 2);\n+            if (iMaxFields == 3) {\n+                return;\n+            }\n+            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (offset == 0 && iMinFields == 3) {\n+                return;\n+            }\n+\n+            if (iShowSeparators) {\n+                out.write('.');\n+            }\n+            FormatUtils.writePaddedInteger(out, offset, 3);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return estimatePrintedLength();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            if (iZeroOffsetText != null) {\n+                if (text.regionMatches(true, position, iZeroOffsetText, 0,\n+                                       iZeroOffsetText.length())) {\n+                    bucket.setOffset(0);\n+                    return position + iZeroOffsetText.length();\n+                }\n+            }\n+\n+            // Format to expect is sign character followed by at least one digit.\n+\n+            int limit = text.length() - position;\n+            if (limit <= 1) {\n+                return ~position;\n+            }\n+\n+            boolean negative;\n+            char c = text.charAt(position);\n+            if (c == '-') {\n+                negative = true;\n+            } else if (c == '+') {\n+                negative = false;\n+            } else {\n+                return ~position;\n+            }\n+\n+            limit--;\n+            position++;\n+\n+            // Format following sign is one of:\n+            //\n+            // hh\n+            // hhmm\n+            // hhmmss\n+            // hhmmssSSS\n+            // hh:mm\n+            // hh:mm:ss\n+            // hh:mm:ss.SSS\n+\n+            // First parse hours.\n+\n+            if (digitCount(text, position, 2) < 2) {\n+                // Need two digits for hour.\n+                return ~position;\n+            }\n+\n+            int offset;\n+\n+            int hours = FormatUtils.parseTwoDigits(text, position);\n+            if (hours > 23) {\n+                return ~position;\n+            }\n+            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n+            limit -= 2;\n+            position += 2;\n+\n+            parse: {\n+                // Need to decide now if separators are expected or parsing\n+                // stops at hour field.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                boolean expectSeparators;\n+                c = text.charAt(position);\n+                if (c == ':') {\n+                    expectSeparators = true;\n+                    limit--;\n+                    position++;\n+                } else if (c >= '0' && c <= '9') {\n+                    expectSeparators = false;\n+                } else {\n+                    break parse;\n+                }\n+\n+                // Proceed to parse minutes.\n+\n+                int count = digitCount(text, position, 2);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 2) {\n+                    // Need two digits for minute.\n+                    return ~position;\n+                }\n+\n+                int minutes = FormatUtils.parseTwoDigits(text, position);\n+                if (minutes > 59) {\n+                    return ~position;\n+                }\n+                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+                limit -= 2;\n+                position += 2;\n+\n+                // Proceed to parse seconds.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                if (expectSeparators) {\n+                    if (text.charAt(position) != ':') {\n+                        break parse;\n+                    }\n+                    limit--;\n+                    position++;\n+                }\n+\n+                count = digitCount(text, position, 2);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 2) {\n+                    // Need two digits for second.\n+                    return ~position;\n+                }\n+\n+                int seconds = FormatUtils.parseTwoDigits(text, position);\n+                if (seconds > 59) {\n+                    return ~position;\n+                }\n+                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+                limit -= 2;\n+                position += 2;\n+\n+                // Proceed to parse fraction of second.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                if (expectSeparators) {\n+                    if (text.charAt(position) != '.') {\n+                        break parse;\n+                    }\n+                    limit--;\n+                    position++;\n+                }\n+                \n+                count = digitCount(text, position, 3);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 1) {\n+                    // Need at least one digit for fraction of second.\n+                    return ~position;\n+                }\n+\n+                offset += (text.charAt(position++) - '0') * 100;\n+                if (count > 1) {\n+                    offset += (text.charAt(position++) - '0') * 10;\n+                    if (count > 2) {\n+                        offset += text.charAt(position++) - '0';\n+                    }\n+                }\n+            }\n+\n+            bucket.setOffset(negative ? -offset : offset);\n+            return position;\n+        }\n+\n+        /**\n+         * Returns actual amount of digits to parse, but no more than original\n+         * 'amount' parameter.\n+         */\n+        private int digitCount(String text, int position, int amount) {\n+            int limit = Math.min(text.length() - position, amount);\n+            amount = 0;\n+            for (; limit > 0; limit--) {\n+                char c = text.charAt(position + amount);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                amount++;\n+            }\n+            return amount;\n+        }\n+    }\n+\n+    private static class TimeZonePrinter extends AbstractFormatter\n+        implements DateTimePrinter \n+    {\n+        private final Locale iLocale;\n+        private final boolean iShortFormat;\n+\n+        TimeZonePrinter(Chronology chrono, Locale locale, boolean shortFormat) {\n+            super(chrono);\n+            iLocale = locale;\n+            iShortFormat = shortFormat;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iShortFormat ? 4 : 20;\n+        }\n+        \n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            if (zone == null) {\n+                zone = getDateTimeZone();\n+            }\n+            if (iShortFormat) {\n+                buf.append(zone.getShortName(millisUTC, this.iLocale));\n+            } else {\n+                buf.append(zone.getName(millisUTC, this.iLocale));\n+            }\n+        }\n+        \n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            if (zone == null) {\n+                zone = getDateTimeZone();\n+            }\n+            if (iShortFormat) {\n+                out.write(zone.getShortName(millisUTC, this.iLocale));\n+            } else {\n+                out.write(zone.getName(millisUTC, this.iLocale));\n+            }\n+        }\n+\n+        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {\n+            if (zone == null) {\n+                zone = getDateTimeZone();\n+            }\n+            if (iShortFormat) {\n+                return zone.getShortName(millisUTC, this.iLocale);\n+            } else {\n+                return zone.getName(millisUTC, this.iLocale);\n+            }\n+        }\n+    }\n+\n+    private static final class Composite extends AbstractFormatter\n+        implements DateTimeFormatter\n+    {\n+        private final DateTimePrinter[] iPrinters;\n+        private final DateTimeParser[] iParsers;\n+\n+        private final int iPrintedLengthEstimate;\n+        private final int iParsedLengthEstimate;\n+\n+        Composite(Chronology chrono, ArrayList elementPairs) {\n+            super(chrono);\n+\n+            int len = elementPairs.size() / 2;\n+\n+            boolean isPrinter = true;\n+            boolean isParser = true;\n+\n+            int printEst = 0;\n+            int parseEst = 0;\n+\n+            DateTimePrinter[] printers = new DateTimePrinter[len];\n+            DateTimeParser[] parsers = new DateTimeParser[len];\n+            for (int i=0; i<len; i++) {\n+                Object element = elementPairs.get(i * 2);\n+                if (element == null || !(element instanceof DateTimePrinter)) {\n+                    isPrinter = false;\n+                } else {\n+                    DateTimePrinter printer = (DateTimePrinter)element;\n+                    printEst += printer.estimatePrintedLength();\n+                    printers[i] = printer;\n+                }\n+\n+                element = elementPairs.get(i * 2 + 1);\n+                if (element == null || !(element instanceof DateTimeParser)) {\n+                    isParser = false;\n+                } else {\n+                    DateTimeParser parser = (DateTimeParser)element;\n+                    parseEst += parser.estimateParsedLength();\n+                    parsers[i] = parser;\n+                }\n+            }\n+\n+            if (!isPrinter) {\n+                printers = null;\n+            }\n+            if (!isParser) {\n+                parsers = null;\n+            }\n+\n+            iPrinters = printers;\n+            iParsers = parsers;\n+            iPrintedLengthEstimate = printEst;\n+            iParsedLengthEstimate = parseEst;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iPrintedLengthEstimate;\n+        }\n+    \n+        public void printTo(StringBuffer buf, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) {\n+            DateTimePrinter[] elements = iPrinters;\n+\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(buf, millisUTC, zone, millisLocal);\n+            }\n+        }\n+\n+        public void printTo(Writer out, long millisUTC,\n+                            DateTimeZone zone, long millisLocal) throws IOException {\n+            DateTimePrinter[] elements = iPrinters;\n+\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(out, millisUTC, zone, millisLocal);\n+            }\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iParsedLengthEstimate;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] elements = iParsers;\n+\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = elements[i].parseInto(bucket, text, position);\n+            }\n+            return position;\n+        }\n+\n+        boolean isPrinter() {\n+            return iPrinters != null;\n+        }\n+\n+        boolean isParser() {\n+            return iParsers != null;\n+        }\n+    }\n+\n+    private static final class MatchingParser extends AbstractFormatter\n+        implements DateTimeParser\n+    {\n+        private final DateTimeParser[] iParsers;\n+        private final int iParsedLengthEstimate;\n+\n+        MatchingParser(Chronology chrono, DateTimeParser[] parsers) {\n+            super(chrono);\n+            iParsers = parsers;\n+            int est = 0;\n+            for (int i=parsers.length; --i>=0 ;) {\n+                DateTimeParser parser = parsers[i];\n+                if (parser != null) {\n+                    int len = parser.estimateParsedLength();\n+                    if (len > est) {\n+                        len = est;\n+                    }\n+                }\n+            }\n+            iParsedLengthEstimate = est;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iParsedLengthEstimate;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] parsers = iParsers;\n+            int length = parsers.length;\n+\n+            Object state = bucket.saveState();\n+            \n+            int bestInvalidPos = position;\n+            int bestInvalidParser = 0;\n+            int bestValidPos = position;\n+            int bestValidParser = 0;\n+\n+            for (int i=0; i<length; i++) {\n+                if (i != 0) {\n+                    bucket.undoChanges(state);\n+                }\n+\n+                DateTimeParser parser = parsers[i];\n+                if (parser == null) {\n+                    // The empty parser wins only if nothing is better.\n+                    if (bestValidPos > position) {\n+                        break;\n+                    }\n+                    return position;\n+                }\n+\n+                int parsePos = parser.parseInto(bucket, text, position);\n+                if (parsePos >= position) {\n+                    if (parsePos >= text.length()) {\n+                        return parsePos;\n+                    }\n+                    if (parsePos > bestValidPos) {\n+                        bestValidPos = parsePos;\n+                        bestValidParser = i;\n+                    }\n+                } else {\n+                    parsePos = ~parsePos;\n+                    if (parsePos > bestInvalidPos) {\n+                        bestInvalidPos = parsePos;\n+                        bestInvalidParser = i;\n+                    }\n+                }\n+            }\n+\n+            if (bestValidPos > position) {\n+                if (bestValidParser == length - 1) {\n+                    // The best valid parser was the last one, so the bucket is\n+                    // already in the best state.\n+                    return bestValidPos;\n+                }\n+                bucket.undoChanges(state);\n+                // Call best valid parser again to restore bucket state.\n+                return parsers[bestValidParser].parseInto(bucket, text, position);\n+            }\n+\n+            if (bestInvalidParser == length - 1) {\n+                // The best invalid parser was the last one, so the bucket is\n+                // already in the best state.\n+                return ~bestInvalidPos;\n+            }\n+\n+            bucket.undoChanges(state);\n+            // Call best invalid parser again to restore bucket state.\n+            return parsers[bestInvalidParser].parseInto(bucket, text, position);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.text.ParseException;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+\n+/**\n+ * Converts sequences of human-readable characters into datetimes.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DateTimeFormatter\n+ * @see DateTimeFormatterBuilder\n+ * @see DateTimeFormat\n+ */\n+public interface DateTimeParser {\n+\n+    /**\n+     * Returns the Chronology being used by the parser, or null if none.\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Returns the expected maximum number of characters consumed. The actual\n+     * amount should rarely exceed this estimate.\n+     */\n+    int estimateParsedLength();\n+\n+    /**\n+     * Parse an element from the given text, saving any fields into the given\n+     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n+     * text position. Note that the parse may succeed without fully reading the\n+     * text.\n+     * <p>\n+     * If it fails, the return value is negative. To determine the position\n+     * where the parse failed, apply the one's complement operator (~) on the\n+     * return value.\n+     *\n+     * @param bucket field are saved into this\n+     * @param text the text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(DateTimeParserBucket bucket, String text, int position);\n+\n+    /**\n+     * Parses a datetime from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableInstant. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the instant may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param instant an instant that will be modified\n+     * @param text text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritableInstant instant, String text, int position);\n+\n+    /**\n+     * Parses a datetime from the given text, returning the number of\n+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     *\n+     * @param text text to parse\n+     * @return parsed value expressed in milliseconds since the epoch\n+     * @throws ParseException if any field is out of range\n+     */\n+    long parseMillis(String text) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, at the given position, returning\n+     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An\n+     * initial millisecond value is passed in, which is relative to the epoch,\n+     * local time.\n+     *\n+     * @param text text to parse\n+     * @param millis initial value of millis, relative to the epoch, local time\n+     * @return parsed value expressed in milliseconds since the epoch, UTC\n+     * @throws ParseException if any field is out of range\n+     */\n+    long parseMillis(String text, long millis) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime.\n+     *\n+     * @param text text to parse\n+     * @return parsed value in a DateTime object\n+     * @throws ParseException if any field is out of range\n+     */\n+    DateTime parseDateTime(String text) throws ParseException;\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime.\n+     *\n+     * @param text text to parse\n+     * @return parsed value in a MutabkeDateTime object\n+     * @throws ParseException if any field is out of range\n+     */\n+    MutableDateTime parseMutableDateTime(String text) throws ParseException;\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Allows fields to be saved in any order, but physically set in a consistent\n+ * order.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class DateTimeParserBucket {\n+\n+    final long iMillis;\n+\n+    // TimeZone to switch to in computeMillis. If null, use offset.\n+    DateTimeZone iZone;\n+    int iOffset;\n+\n+    ArrayList iSavedFields = new ArrayList();\n+\n+    /**\n+     * @param millis the initial millis from 1970-01-01T00:00:00, local time\n+     */\n+    public DateTimeParserBucket(long millis) {\n+        iMillis = millis;\n+    }\n+\n+    /**\n+     * Returns the time zone used by computeMillis, or null if an offset is\n+     * used instead.\n+     */\n+    public DateTimeZone getDateTimeZone() {\n+        return iZone;\n+    }\n+\n+    /**\n+     * Set a time zone to be used when computeMillis is called, which\n+     * overrides any set time zone offset.\n+     *\n+     * @param zone the date time zone to operate in, or null if UTC\n+     */\n+    public void setDateTimeZone(DateTimeZone zone) {\n+        iZone = zone == DateTimeZone.UTC ? null : zone;\n+        iOffset = 0;\n+    }\n+\n+    /**\n+     * Returns the time zone offset used by computeMillis, unless\n+     * getDateTimeZone doesn't return null.\n+     */\n+    public long getOffset() {\n+        return iOffset;\n+    }\n+\n+    /**\n+     * Set a time zone offset to be used when computeMillis is called, which\n+     * overrides the time zone.\n+     */\n+    public void setOffset(int offset) {\n+        iOffset = offset;\n+        iZone = null;\n+    }\n+\n+    /**\n+     * Saves a datetime field value.\n+     */\n+    public void saveField(DateTimeField field, int value) {\n+        iSavedFields.add(new SavedField(field, value));\n+    }\n+\n+    /**\n+     * Saves a datetime field text value.\n+     */\n+    public void saveField(DateTimeField field, String text, Locale locale) {\n+        iSavedFields.add(new SavedField(field, text, locale));\n+    }\n+\n+    /**\n+     * Saves the state of this bucket, returning it in an opaque object. Call\n+     * undoChanges to undo any changes that were made since the state was\n+     * saved. Calls to saveState may be nested.\n+     *\n+     * @return opaque saved state, which may be passed to undoChanges\n+     */\n+    public Object saveState() {\n+        Object state = new SavedState();\n+        iSavedFields = (ArrayList)iSavedFields.clone();\n+        return state;\n+    }\n+\n+    /**\n+     * Undos any changes that were made to this bucket since the given state\n+     * was saved. Once the changes have been undone, they are lost. Any states\n+     * that were saved after saving the previous state are also lost.\n+     * <p>\n+     * The state object passed into this method is not lost, and it can be used\n+     * later to revert to that state again.\n+     *\n+     * @param savedState opaque saved state, returned from saveState\n+     * @return true state object is valid and changes were undone\n+     */\n+    public boolean undoChanges(Object savedState) {\n+        if (savedState instanceof SavedState) {\n+            return ((SavedState)savedState).revertState(this);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * Calling this method does not affect the state of this object.\n+     *\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public long computeMillis() {\n+        int length = iSavedFields.size();\n+        SavedField[] savedFields = new SavedField[length];\n+        iSavedFields.toArray(savedFields);\n+\n+        Arrays.sort(savedFields);\n+\n+        long millis = iMillis;\n+        for (int i=0; i<length; i++) {\n+            millis = savedFields[i].set(millis);\n+        }\n+\n+        if (iZone == null) {\n+            millis -= iOffset;\n+        } else {\n+            int offset = iZone.getOffsetFromLocal(millis);\n+            millis -= offset;\n+            if (offset != iZone.getOffset(millis)) {\n+                throw new IllegalArgumentException\n+                    (\"Illegal instant due to time zone offset transition\");\n+            }\n+        }\n+\n+        return millis;\n+    }\n+\n+    private static class SavedField implements Comparable {\n+        final DateTimeField iField;\n+        final int iValue;\n+        final String iText;\n+        final Locale iLocale;\n+\n+        SavedField(DateTimeField field, int value) {\n+            iField = field;\n+            iValue = value;\n+            iText = null;\n+            iLocale = null;\n+        }\n+\n+        SavedField(DateTimeField field, String text, Locale locale) {\n+            iField = field;\n+            iValue = 0;\n+            iText = text;\n+            iLocale = locale;\n+        }\n+\n+        long set(long millis) {\n+            if (iText == null) {\n+                return iField.set(millis, iValue);\n+            } else {\n+                return iField.set(millis, iText, iLocale);\n+            }\n+        }\n+\n+        /**\n+         * The field with the larger range is ordered first. If the ranges\n+         * match, then the field with the larger unit is ordered first. This\n+         * ordering gives preference to more precise fields. For example,\n+         * dayOfYear is chosen over monthOfYear.\n+         */\n+        public int compareTo(Object obj) {\n+            DateTimeField other = ((SavedField)obj).iField;\n+            long a = iField.getRangeMillis();\n+            long b = other.getRangeMillis();\n+            if (a > b) {\n+                return -1;\n+            } else if (a < b) {\n+                return 1;\n+            }\n+            a = iField.getUnitMillis();\n+            b = other.getUnitMillis();\n+            if (a > b) {\n+                return -1;\n+            } else if (a < b) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    private class SavedState {\n+        final DateTimeZone iZone;\n+        final int iOffset;\n+        final ArrayList iSavedFields;\n+\n+        SavedState() {\n+            this.iZone = DateTimeParserBucket.this.iZone;\n+            this.iOffset = DateTimeParserBucket.this.iOffset;\n+            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n+        }\n+\n+        boolean revertState(DateTimeParserBucket enclosing) {\n+            if (enclosing != DateTimeParserBucket.this) {\n+                return false;\n+            }\n+            DateTimeParserBucket.this.iZone = this.iZone;\n+            DateTimeParserBucket.this.iOffset = this.iOffset;\n+            DateTimeParserBucket.this.iSavedFields = this.iSavedFields;\n+            return true;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+\n+/**\n+ * Converts datetimes into a sequence of human-readable characters.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DateTimeFormatter\n+ * @see DateTimeFormatterBuilder\n+ * @see DateTimeFormat\n+ */\n+public interface DateTimePrinter {\n+    \n+    /**\n+     * Returns the Chronology being used by the printer, or null if none.\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Returns the expected maximum number of characters produced. The actual\n+     * amount should rarely exceed this estimate.\n+     */\n+    int estimatePrintedLength();\n+\n+    /**\n+     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n+     * the instant.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param instant instant to format\n+     */\n+    void printTo(StringBuffer buf, ReadableInstant instant);\n+\n+    /**\n+     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by\n+     * the instant.\n+     *\n+     * @param out formatted instant is written out\n+     * @param instant instant to format\n+     */\n+    void printTo(Writer out, ReadableInstant instant) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(StringBuffer buf, long millisUTC);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     */\n+    void printTo(Writer out, long millisUTC) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     */\n+    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     */\n+    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param buf formatted instant is appended to this buffer\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n+     * printers\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     */\n+    void printTo(StringBuffer buf, long millisUTC,\n+                 DateTimeZone zone, long millisLocal);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param out formatted instant is written out\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone\n+     * printers\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     */\n+    void printTo(Writer out, long millisUTC,\n+                 DateTimeZone zone, long millisLocal) throws IOException;\n+\n+    /**\n+     * Prints a ReadableInstant to a new String, attempting to use the\n+     * DateTimeZone supplied by the instant.\n+     *\n+     * @param instant instant to format\n+     * @return the printed result\n+     */\n+    String print(ReadableInstant instant);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the formatter's DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    String print(long millisUTC);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @return the printed result\n+     */\n+    String print(long millisUTC, DateTimeZone zone);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * attempting to use the given DateTimeZone.\n+     *\n+     * @param millisUTC millis since 1970-01-01T00:00:00Z\n+     * @param zone DateTimeZone to use, overriding the formatter's own zone if\n+     * not null\n+     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,\n+     * local time\n+     * @return the printed result\n+     */\n+    String print(long millisUTC, DateTimeZone zone, long millisLocal);\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Utility methods used by formatters.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class FormatUtils {\n+    private static final double LOG_10 = Math.log(10);\n+\n+    private FormatUtils() {\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\n+        if (value < 0) {\n+            buf.append('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                for (; size > 10; size--) {\n+                    buf.append('0');\n+                }\n+                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            for (; size > 1; size--) {\n+                buf.append('0');\n+            }\n+            buf.append((char)(value + '0'));\n+        } else if (value < 100) {\n+            for (; size > 2; size--) {\n+                buf.append('0');\n+            }\n+            buf.append((char)(value / 10 + '0'));\n+            buf.append((char)(value % 10 + '0'));\n+        } else {\n+            int digits;\n+            if (value < 1000) {\n+                digits = 3;\n+            } else if (value < 10000) {\n+                digits = 4;\n+            } else {\n+                digits = (int)(Math.log(value) / LOG_10) + 1;\n+            }\n+            for (; size > digits; size--) {\n+                buf.append('0');\n+            }\n+            buf.append(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void appendPaddedInteger(StringBuffer buf, long value, int size) {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            appendPaddedInteger(buf, intValue, size);\n+        } else if (size <= 19) {\n+            buf.append(Long.toString(value));\n+        } else {\n+            if (value < 0) {\n+                buf.append('-');\n+                if (value != Long.MIN_VALUE) {\n+                    value = -value;\n+                } else {\n+                    for (; size > 19; size--) {\n+                        buf.append('0');\n+                    }\n+                    buf.append(\"9223372036854775808\");\n+                    return;\n+                }\n+            }\n+            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            for (; size > digits; size--) {\n+                buf.append('0');\n+            }\n+            buf.append(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void writePaddedInteger(Writer out, int value, int size)\n+        throws IOException\n+    {\n+        if (value < 0) {\n+            out.write('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                for (; size > 10; size--) {\n+                    out.write('0');\n+                }\n+                out.write(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            for (; size > 1; size--) {\n+                out.write('0');\n+            }\n+            out.write(value + '0');\n+        } else if (value < 100) {\n+            for (; size > 2; size--) {\n+                out.write('0');\n+            }\n+            out.write(value / 10 + '0');\n+            out.write(value % 10 + '0');\n+        } else {\n+            int digits;\n+            if (value < 1000) {\n+                digits = 3;\n+            } else if (value < 10000) {\n+                digits = 4;\n+            } else {\n+                digits = (int)(Math.log(value) / LOG_10) + 1;\n+            }\n+            for (; size > digits; size--) {\n+                out.write('0');\n+            }\n+            out.write(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void writePaddedInteger(Writer out, long value, int size)\n+        throws IOException\n+    {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            writePaddedInteger(out, intValue, size);\n+        } else if (size <= 19) {\n+            out.write(Long.toString(value));\n+        } else {\n+            if (value < 0) {\n+                out.write('-');\n+                if (value != Long.MIN_VALUE) {\n+                    value = -value;\n+                } else {\n+                    for (; size > 19; size--) {\n+                        out.write('0');\n+                    }\n+                    out.write(\"9223372036854775808\");\n+                    return;\n+                }\n+            }\n+            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            for (; size > digits; size--) {\n+                out.write('0');\n+            }\n+            out.write(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void appendUnpaddedInteger(StringBuffer buf, int value) {\n+        if (value < 0) {\n+            buf.append('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            buf.append((char)(value + '0'));\n+        } else if (value < 100) {\n+            buf.append((char)(value / 10 + '0'));\n+            buf.append((char)(value % 10 + '0'));\n+        } else {\n+            buf.append(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void appendUnpaddedInteger(StringBuffer buf, long value) {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            appendUnpaddedInteger(buf, intValue);\n+        } else {\n+            buf.append(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void writeUnpaddedInteger(Writer out, int value)\n+        throws IOException\n+    {\n+        if (value < 0) {\n+            out.write('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                out.write(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            out.write(value + '0');\n+        } else if (value < 100) {\n+            out.write(value / 10 + '0');\n+            out.write(value % 10 + '0');\n+        } else {\n+            out.write(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void writeUnpaddedInteger(Writer out, long value)\n+        throws IOException\n+    {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            writeUnpaddedInteger(out, intValue);\n+        } else {\n+            out.write(Long.toString(value));\n+        }\n+    }\n+\n+    static int parseTwoDigits(String text, int position) {\n+        int value = text.charAt(position) - '0';\n+        return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * Factory methods for many ISO8601 formats (the ISO standard is a framework\n+ * for outputting data, but not an absolute standard). The most common formats\n+ * are date, time, and dateTime.\n+ * \n+ * @author Brian S O'Neill\n+ * @see DateTimeFormat\n+ * @see DateTimeFormatterBuilder\n+ */\n+public class ISODateTimeFormat {\n+\n+    // Maps Chronology instances to instances.\n+    private static Map cCache = new HashMap(7);\n+\n+    public static ISODateTimeFormat getInstanceUTC() {\n+        return getInstance(ISOChronology.getInstanceUTC());\n+    }\n+\n+    public static ISODateTimeFormat getInstance() {\n+        return getInstance(ISOChronology.getInstance());\n+    }\n+\n+    public static ISODateTimeFormat getInstance(DateTimeZone zone) {\n+        return getInstance(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * @param chrono Chronology to use\n+     */\n+    public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {\n+        if (chrono == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        ISODateTimeFormat instance = (ISODateTimeFormat)cCache.get(chrono);\n+        if (instance == null) {\n+            instance = new ISODateTimeFormat(chrono);\n+            cCache.put(chrono, instance);\n+        }\n+        return instance;\n+    }\n+\n+    private final Chronology iChrono;\n+\n+    private transient DateTimeFormatter\n+        ye,  // year element (yyyy)\n+        me,  // month element (-MM)\n+        de,  // day element (-dd)\n+        he,  // hour element (HH)\n+        mne, // minute element (:mm)\n+        se,  // second element (:ss)\n+        fe,  // fraction element (.SSS)\n+        ze,  // zone offset element\n+        \n+        //y,   // year (same as year element)\n+        ym,  // year month\n+        ymd, // year month day\n+\n+        //h,    // hour (same as hour element)\n+        hm,   // hour minute\n+        hms,  // hour minute second\n+        hmsf, // hour minute second fraction\n+\n+        dh,    // date hour\n+        dhm,   // date hour minute\n+        dhms,  // date hour minute second\n+        dhmsf, // date hour minute second fraction\n+\n+        //d,  // date (same as ymd)\n+        t,  // time\n+        dt, // date time\n+\n+        bd,  // basic date\n+        bt,  // basic time\n+        bdt; // basic date time\n+\n+    private transient DateTimeParser\n+        dpe, // date parser element\n+        tpe, // time parser element\n+        dp, // date parser\n+        tp, // time parser\n+        dtp; // date time parser\n+\n+    private ISODateTimeFormat(Chronology chrono) {\n+        iChrono = chrono;\n+    }\n+\n+    /**\n+     * Returns a generic ISO date parser that accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * date         = date-element ['T' offset]\n+     * date-element = yyyy ['-' MM ['-' dd]]\n+     * offset       = 'Z' | (('+' | '-') HH ':' mm)\n+     * </pre>\n+     */\n+    public DateTimeParser dateParser() {\n+        if (dp == null) {\n+            dp = new DateTimeFormatterBuilder(iChrono)\n+                .append(dateElementParser())\n+                .appendOptional\n+                (new DateTimeFormatterBuilder(iChrono)\n+                 .appendLiteral('T')\n+                 .append(offsetElement())\n+                 .toParser())\n+                .toParser();\n+        }\n+        return dp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO date parser that accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * date-element = yyyy ['-' MM ['-' dd]]\n+     * </pre>\n+     */\n+    public DateTimeParser dateElementParser() {\n+        if (dpe == null) {\n+            dpe = new DateTimeFormatterBuilder(iChrono)\n+                .append(yearElement())\n+                .appendOptional\n+                (new DateTimeFormatterBuilder(iChrono)\n+                 .append(monthElement())\n+                 .appendOptional(dayElement())\n+                 .toParser())\n+                .toParser();\n+        }\n+        return dpe;\n+    }\n+\n+    /**\n+     * Returns a generic ISO time parser that accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * time         = ['T'] time-element [offset]\n+     * time-element = HH [':' mm [':' ss ['.' SSS]]]\n+     * offset       = 'Z' | (('+' | '-') HH ':' mm)\n+     * </pre>\n+     */\n+    public DateTimeParser timeParser() {\n+        if (tp == null) {\n+            tp = new DateTimeFormatterBuilder(iChrono)\n+                .appendOptional\n+                (new DateTimeFormatterBuilder(iChrono)\n+                 .appendLiteral('T')\n+                 .toParser())\n+                .append(timeElementParser())\n+                .appendOptional(offsetElement())\n+                .toParser();\n+        }\n+        return tp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO time parser that accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * time-element = HH [':' mm [':' ss ['.' SSS]]]\n+     * </pre>\n+     */\n+    public DateTimeParser timeElementParser() {\n+        if (tpe == null) {\n+            tpe = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourElement())\n+                .appendOptional\n+                (new DateTimeFormatterBuilder(iChrono)\n+                 .append(minuteElement())\n+                 .appendOptional\n+                 (new DateTimeFormatterBuilder(iChrono)\n+                  .append(secondElement())\n+                  .appendOptional(fractionElement())\n+                  .toParser())\n+                 .toParser())\n+                .toParser();\n+        }\n+        return tpe;\n+    }\n+\n+    /**\n+     * Returns a generic ISO datetime parser that accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * datetime     = time | (date-element [time | ('T' offset)])\n+     * time         = 'T' time-element [offset]\n+     * date-element = yyyy ['-' MM ['-' dd]]\n+     * time-element = HH [':' mm [':' ss ['.' SSS]]]\n+     * offset       = 'Z' | (('+' | '-') HH ':' mm)\n+     * </pre>\n+     */\n+    public DateTimeParser dateTimeParser() {\n+        if (dtp == null) {\n+            // This is different from the general time parser in that the 'T'\n+            // is required.\n+            DateTimeParser time = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('T')\n+                .append(timeElementParser())\n+                .appendOptional(offsetElement())\n+                .toParser();\n+\n+            dtp = new DateTimeFormatterBuilder(iChrono)\n+                .append(null, new DateTimeParser[] {\n+                    time,\n+                    new DateTimeFormatterBuilder(iChrono)\n+                    .append(dateElementParser())\n+                    .append(null, new DateTimeParser[] {\n+                        time,\n+                        new DateTimeFormatterBuilder(iChrono)\n+                        .appendLiteral('T')\n+                        .append(offsetElement())\n+                        .toParser(),\n+                        null\n+                    })\n+                    .toParser()\n+                })\n+                .toParser();\n+        }\n+        return dtp;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full date as four digit year, two digit month\n+     * of year, and two digit day of month. (yyyy-MM-dd)\n+     */\n+    public DateTimeFormatter date() {\n+        return yearMonthDay();\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, three digit fraction of second, and\n+     * time zone offset. (HH:mm:ss.SSSZ) The time zone offset is 'Z' for zero, and\n+     * of the form '\\u00b1HH:mm' for non-zero.\n+     */\n+    public DateTimeFormatter time() {\n+        if (t == null) {\n+            t = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourMinuteSecondFraction())\n+                .append(offsetElement())\n+                .toFormatter();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and time, separated by a 'T'.\n+     * (yyyy-MM-ddTHH:mm:ss.SSSZ)\n+     */\n+    public DateTimeFormatter dateTime() {\n+        if (dt == null) {\n+            dt = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(time())\n+                .toFormatter();\n+        }\n+        return dt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a full date as four digit year, two digit\n+     * month of year, and two digit day of month. (yyyyMMdd)\n+     */\n+    public DateTimeFormatter basicDate() {\n+        if (bd == null) {\n+            bd = new DateTimeFormatterBuilder(iChrono)\n+                .appendPattern(\"yyyyMMdd\")\n+                .toFormatter();\n+        }\n+        return bd;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, and time zone offset. (HHmmssZ) The time zone\n+     * offset is blank for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     */\n+    public DateTimeFormatter basicTime() {\n+        if (bt == null) {\n+            bt = new DateTimeFormatterBuilder(iChrono)\n+                .appendPattern(\"HHmmss\")\n+                .appendTimeZoneOffset(\"\", false, 1, 2)\n+                .toFormatter();\n+        }\n+        return bt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter that combines a basic date and time, separated\n+     * by a 'T'. (yyyyMMddTHHmmssZ)\n+     */\n+    public DateTimeFormatter basicDateTime() {\n+        if (bdt == null) {\n+            bdt = new DateTimeFormatterBuilder(iChrono)\n+                .append(basicDate())\n+                .appendLiteral('T')\n+                .append(basicTime())\n+                .toFormatter();\n+        }\n+        return bdt;\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit year. (yyyy)\n+     */\n+    public DateTimeFormatter year() {\n+        return yearElement();\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit year and two digit month of\n+     * year. (yyyy-MM)\n+     */\n+    public DateTimeFormatter yearMonth() {\n+        if (ym == null) {\n+            ym = new DateTimeFormatterBuilder(iChrono)\n+                .append(yearElement())\n+                .append(monthElement())\n+                .toFormatter();\n+        }\n+        return ym;\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit year, two digit month of year, and\n+     * two digit day of month. (yyyy-MM-dd)\n+     */\n+    public DateTimeFormatter yearMonthDay() {\n+        if (ymd == null) {\n+            ymd = new DateTimeFormatterBuilder(iChrono)\n+                .append(yearElement())\n+                .append(monthElement())\n+                .append(dayElement())\n+                .toFormatter();\n+        }\n+        return ymd;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day. (HH)\n+     */\n+    public DateTimeFormatter hour() {\n+        return hourElement();\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day and two digit minute of\n+     * hour. (HH:mm)\n+     */\n+    public DateTimeFormatter hourMinute() {\n+        if (hm == null) {\n+            hm = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .toFormatter();\n+        }\n+        return hm;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, and two digit second of minute. (HH:mm:ss)\n+     */\n+    public DateTimeFormatter hourMinuteSecond() {\n+        if (hms == null) {\n+            hms = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .toFormatter();\n+        }\n+        return hms;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and three digit fraction of\n+     * second. (HH:mm:ss.SSS)\n+     */\n+    public DateTimeFormatter hourMinuteSecondFraction() {\n+        if (hmsf == null) {\n+            hmsf = new DateTimeFormatterBuilder(iChrono)\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .append(fractionElement())\n+                .toFormatter();\n+        }\n+        return hmsf;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and two digit hour of\n+     * day. (yyyy-MM-ddTHH)\n+     */\n+    public DateTimeFormatter dateHour() {\n+        if (dh == null) {\n+            dh = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(hour())\n+                .toFormatter();\n+        }\n+        return dh;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * and two digit minute of hour. (yyyy-MM-ddTHH:mm)\n+     */\n+    public DateTimeFormatter dateHourMinute() {\n+        if (dhm == null) {\n+            dhm = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(hourMinute())\n+                .toFormatter();\n+        }\n+        return dhm;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, and two digit second of\n+     * minute. (yyyy-MM-ddTHH:mm:ss)\n+     */\n+    public DateTimeFormatter dateHourMinuteSecond() {\n+        if (dhms == null) {\n+            dhms = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(hourMinuteSecond())\n+                .toFormatter();\n+        }\n+        return dhms;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, two digit second of minute, and three digit\n+     * fraction of second. (yyyy-MM-ddTHH:mm:ss.SSS)\n+     */\n+    public DateTimeFormatter dateHourMinuteSecondFraction() {\n+        if (dhmsf == null) {\n+            dhmsf = new DateTimeFormatterBuilder(iChrono)\n+                .append(date())\n+                .appendLiteral('T')\n+                .append(hourMinuteSecondFraction())\n+                .toFormatter();\n+        }\n+        return dhmsf;\n+    }\n+\n+    private DateTimeFormatter yearElement() {\n+        if (ye == null) {\n+            ye = new DateTimeFormatterBuilder(iChrono)\n+                .appendYear(4, 9)\n+                .toFormatter();\n+        }\n+        return ye;\n+    }\n+\n+    private DateTimeFormatter monthElement() {\n+        if (me == null) {\n+            me = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('-')\n+                .appendMonthOfYear(2)\n+                .toFormatter();\n+        }\n+        return me;\n+    }\n+\n+    private DateTimeFormatter dayElement() {\n+        if (de == null) {\n+            de = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('-')\n+                .appendDayOfMonth(2)\n+                .toFormatter();\n+        }\n+        return de;\n+    }\n+\n+    private DateTimeFormatter hourElement() {\n+        if (he == null) {\n+            he = new DateTimeFormatterBuilder(iChrono)\n+                .appendHourOfDay(2)\n+                .toFormatter();\n+        }\n+        return he;\n+    }\n+\n+    private DateTimeFormatter minuteElement() {\n+        if (mne == null) {\n+            mne = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral(':')\n+                .appendMinuteOfHour(2)\n+                .toFormatter();\n+        }\n+        return mne;\n+    }\n+\n+    private DateTimeFormatter secondElement() {\n+        if (se == null) {\n+            se = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral(':')\n+                .appendSecondOfMinute(2)\n+                .toFormatter();\n+        }\n+        return se;\n+    }\n+\n+    private DateTimeFormatter fractionElement() {\n+        if (fe == null) {\n+            fe = new DateTimeFormatterBuilder(iChrono)\n+                .appendLiteral('.')\n+                // Support parsing up to nanosecond precision even though\n+                // those extra digits will be dropped.\n+                .appendFractionOfSecond(3, 9)\n+                .toFormatter();\n+        }\n+        return fe;\n+    }\n+\n+    private DateTimeFormatter offsetElement() {\n+        if (ze == null) {\n+            ze = new DateTimeFormatterBuilder(iChrono)\n+                .appendTimeZoneOffset(\"Z\", true, 2, 2)\n+                .toFormatter();\n+        }\n+        return ze;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Improves the performance of requesting time zone offsets and name keys by\n+ * caching the results. Time zones that have simple rules or are fixed should\n+ * not be cached, as it is unlikely to improve performance.\n+ * \n+ * @author Brian S O'Neill\n+ */\n+public class CachedDateTimeZone extends DateTimeZone {\n+    private static final int cInfoCacheMask;\n+\n+    static {\n+        Integer i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n+\n+        // With a cache size of 512, dates that lie within any 69.7 year period\n+        // have no cache collisions.\n+        int cacheSize = (i == null) ? 512 : i.intValue();\n+\n+        // Ensure cache size is even power of 2.\n+        cacheSize--;\n+        int shift = 0;\n+        while (cacheSize > 0) {\n+            shift++;\n+            cacheSize >>= 1;\n+        }\n+        cacheSize = 1 << shift;\n+\n+        cInfoCacheMask = cacheSize - 1;\n+    }\n+\n+    /**\n+     * Returns a new CachedDateTimeZone unless given zone is already cached.\n+     */\n+    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n+        if (zone instanceof CachedDateTimeZone) {\n+            return (CachedDateTimeZone)zone;\n+        }\n+        return new CachedDateTimeZone(zone);\n+    }\n+\n+    /*\n+     * Caching is performed by breaking timeline down into periods of 2^32\n+     * milliseconds, or about 49.7 days. A year has about 7.3 periods, usually\n+     * with only 2 time zone offset periods. Most of the 49.7 day periods will\n+     * have no transition, about one quarter have one transition, and very rare\n+     * cases have multiple transitions.\n+     */\n+\n+    private final DateTimeZone iZone;\n+\n+    private transient Info[] iInfoCache;\n+\n+    private CachedDateTimeZone(DateTimeZone zone) {\n+        super(zone.getID());\n+        iZone = zone;\n+        iInfoCache = new Info[cInfoCacheMask + 1];\n+    }\n+\n+    private void readObject(java.io.ObjectInputStream in)\n+        throws java.io.IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        iInfoCache = new Info[cInfoCacheMask + 1];\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone being wrapped.\n+     */\n+    public DateTimeZone getUncachedZone() {\n+        return iZone;\n+    }\n+\n+    public String getNameKey(long millis) {\n+        return getInfo(millis).getNameKey(millis);\n+    }\n+\n+    public int getOffset(long millis) {\n+        return getInfo(millis).getOffset(millis);\n+    }\n+\n+    public int getStandardOffset(long millis) {\n+        return getInfo(millis).getStandardOffset(millis);\n+    }\n+\n+    public long nextTransition(long millis) {\n+        return iZone.nextTransition(millis);\n+    }\n+\n+    public long previousTransition(long millis) {\n+        return iZone.previousTransition(millis);\n+    }\n+\n+    public int hashCode() {\n+        return iZone.hashCode();\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof CachedDateTimeZone) {\n+            return iZone.equals(((CachedDateTimeZone)obj).iZone);\n+        }\n+        return false;\n+    }\n+\n+    // Although accessed by multiple threads, this method doesn't need to be\n+    // synchronized.\n+\n+    private Info getInfo(long millis) {\n+        int period = (int)(millis >> 32);\n+        Info[] cache = iInfoCache;\n+        int index = period & cInfoCacheMask;\n+        Info info = cache[index];\n+        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {\n+            info = createInfo(millis);\n+            cache[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    private Info createInfo(long millis) {\n+        long periodStart = millis & (0xffffffffL << 32);\n+        Info info = new Info(iZone, periodStart);\n+        \n+        long end = periodStart | 0xffffffffL;\n+        Info chain = info;\n+        while (true) {\n+            long next = iZone.nextTransition(periodStart);\n+            if (next == periodStart || next > end) {\n+                break;\n+            }\n+            periodStart = next;\n+            chain = (chain.iNextInfo = new Info(iZone, periodStart));\n+        }\n+\n+        return info;\n+    }\n+\n+    private final static class Info {\n+        // For first Info in chain, iPeriodStart's lower 32 bits are clear.\n+        public final long iPeriodStart;\n+        public final DateTimeZone iZoneRef;\n+\n+        Info iNextInfo;\n+\n+        private String iNameKey;\n+        private int iOffset = Integer.MIN_VALUE;\n+        private int iStandardOffset = Integer.MIN_VALUE;\n+\n+        Info(DateTimeZone zone, long periodStart) {\n+            iPeriodStart = periodStart;\n+            iZoneRef = zone;\n+        }\n+\n+        public String getNameKey(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iNameKey == null) {\n+                    iNameKey = iZoneRef.getNameKey(iPeriodStart);\n+                }\n+                return iNameKey;\n+            }\n+            return iNextInfo.getNameKey(millis);\n+        }\n+\n+        public int getOffset(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iOffset == Integer.MIN_VALUE) {\n+                    iOffset = iZoneRef.getOffset(iPeriodStart);\n+                }\n+                return iOffset;\n+            }\n+            return iNextInfo.getOffset(millis);\n+        }\n+\n+        public int getStandardOffset(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iStandardOffset == Integer.MIN_VALUE) {\n+                    iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);\n+                }\n+                return iStandardOffset;\n+            }\n+            return iNextInfo.getStandardOffset(millis);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since\n+ * creating a new DateTimeZone this way is a relatively expensive operation,\n+ * built zones can be written to a file. Reading back the encoded data is a\n+ * quick operation.\n+ *\n+ * @author Brian S O'Neill\n+ * @see ZoneInfoCompiler\n+ * @see ZoneInfoProvider\n+ */\n+public class DateTimeZoneBuilder {\n+    /**\n+     * Decodes a built DateTimeZone from the given stream, as encoded by\n+     * writeTo.\n+     *\n+     * @param in input stream to read encoded DateTimeZone from.\n+     * @param id time zone id to assign\n+     */\n+    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n+        if (in instanceof DataInput) {\n+            return readFrom((DataInput)in, id);\n+        } else {\n+            return readFrom((DataInput)new DataInputStream(in), id);\n+        }\n+    }\n+\n+    /**\n+     * Decodes a built DateTimeZone from the given stream, as encoded by\n+     * writeTo.\n+     *\n+     * @param in input stream to read encoded DateTimeZone from.\n+     * @param id time zone id to assign\n+     */\n+    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n+        switch (in.readUnsignedByte()) {\n+        case 'F':\n+            DateTimeZone fixed = new FixedDateTimeZone\n+                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n+            if (fixed.equals(DateTimeZone.UTC)) {\n+                fixed = DateTimeZone.UTC;\n+            }\n+            return fixed;\n+        case 'C':\n+            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n+        case 'P':\n+            return PrecalculatedZone.readFrom(in, id);\n+        default:\n+            throw new IOException(\"Invalid encoding\");\n+        }\n+    }\n+\n+    /**\n+     * Millisecond encoding formats:\n+     *\n+     * upper two bits  units       field length  approximate range\n+     * ---------------------------------------------------------------\n+     * 00              30 minutes  1 byte        +/- 16 hours\n+     * 01              minutes     4 bytes       +/- 1020 years\n+     * 10              seconds     5 bytes       +/- 4355 years\n+     * 11              millis      9 bytes       +/- 292,000,000 years\n+     *\n+     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.\n+     */\n+    static void writeMillis(DataOutput out, long millis) throws IOException {\n+        if (millis % (30 * 60000L) == 0) {\n+            // Try to write in 30 minute units.\n+            long units = millis / (30 * 60000L);\n+            if (((units << (64 - 6)) >> (64 - 6)) == units) {\n+                // Form 00 (6 bits effective precision)\n+                out.writeByte((int)(units & 0x3f));\n+                return;\n+            }\n+        }\n+\n+        if (millis % 60000L == 0) {\n+            // Try to write minutes.\n+            long minutes = millis / 60000L;\n+            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n+                // Form 01 (30 bits effective precision)\n+                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));\n+                return;\n+            }\n+        }\n+        \n+        if (millis % 1000L == 0) {\n+            // Try to write seconds.\n+            long seconds = millis / 1000L;\n+            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n+                // Form 10 (38 bits effective precision)\n+                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));\n+                out.writeInt((int)(seconds & 0xffffffff));\n+                return;\n+            }\n+        }\n+\n+        // Write milliseconds either because the additional precision is\n+        // required or the minutes didn't fit in the field.\n+        \n+        // Form 11 (64 bits effective precision, but write as if 70 bits)\n+        out.writeByte(millis < 0 ? 0xff : 0xc0);\n+        out.writeLong(millis);\n+    }\n+\n+    /**\n+     * Reads encoding generated by writeMillis.\n+     */\n+    static long readMillis(DataInput in) throws IOException {\n+        int v = in.readUnsignedByte();\n+        switch (v >> 6) {\n+        case 0: default:\n+            // Form 00 (6 bits effective precision)\n+            v = (v << (32 - 6)) >> (32 - 6);\n+            return v * (30 * 60000L);\n+\n+        case 1:\n+            // Form 01 (30 bits effective precision)\n+            v = (v << (32 - 6)) >> (32 - 30);\n+            v |= (in.readUnsignedByte()) << 16;\n+            v |= (in.readUnsignedByte()) << 8;\n+            v |= (in.readUnsignedByte());\n+            return v * 60000L;\n+\n+        case 2:\n+            // Form 10 (38 bits effective precision)\n+            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n+            w |= (in.readUnsignedByte()) << 24;\n+            w |= (in.readUnsignedByte()) << 16;\n+            w |= (in.readUnsignedByte()) << 8;\n+            w |= (in.readUnsignedByte());\n+            return w * 1000L;\n+\n+        case 3:\n+            // Form 11 (64 bits effective precision)\n+            return in.readLong();\n+        }\n+    }\n+\n+    private static DateTimeZone buildFixedZone(String id, String nameKey,\n+                                               int wallOffset, int standardOffset) {\n+        if (\"UTC\".equals(id) && id.equals(nameKey) &&\n+            wallOffset == 0 && standardOffset == 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);\n+    }\n+\n+    // List of RuleSets.\n+    private final ArrayList iRuleSets;\n+\n+    public DateTimeZoneBuilder() {\n+        iRuleSets = new ArrayList(10);\n+    }\n+\n+    /**\n+     * Adds a cutover for added rules. The standard offset at the cutover\n+     * defaults to 0. Call setStandardOffset afterwards to change it.\n+     *\n+     * @param year year of cutover\n+     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall\n+     * offset, 's' - against standard offset.\n+     * @param dayOfMonth if negative, set to ((last day of month) - ~dayOfMonth).\n+     * For example, if -1, set to last day of month\n+     * @param dayOfWeek if 0, ignore\n+     * @param advanceDayOfWeek if dayOfMonth does not fall on dayOfWeek, advance to\n+     * dayOfWeek when true, retreat when false.\n+     * @param millisOfDay additional precision for specifying time of day of\n+     * cutover\n+     */\n+    public DateTimeZoneBuilder addCutover(int year,\n+                                          char mode,\n+                                          int monthOfYear,\n+                                          int dayOfMonth,\n+                                          int dayOfWeek,\n+                                          boolean advanceDayOfWeek,\n+                                          int millisOfDay)\n+    {\n+        OfYear ofYear = new OfYear\n+            (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n+        if (iRuleSets.size() > 0) {\n+            RuleSet lastRuleSet = (RuleSet)iRuleSets.get(iRuleSets.size() - 1);\n+            lastRuleSet.setUpperLimit(year, ofYear);\n+        }\n+        iRuleSets.add(new RuleSet());\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the standard offset to use for newly added rules until the next\n+     * cutover is added.\n+     */\n+    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {\n+        getLastRuleSet().setStandardOffset(standardOffset);\n+        return this;\n+    }\n+\n+    /**\n+     * Set a fixed savings rule at the cutover.\n+     */\n+    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {\n+        getLastRuleSet().setFixedSavings(nameKey, saveMillis);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a recurring daylight saving time rule.\n+     *\n+     * @param nameKey name key of new rule\n+     * @param saveMillis milliseconds to add to standard offset\n+     * @param fromYear First year that rule is in effect. MIN_VALUE indicates\n+     * beginning of time.\n+     * @param toYear Last year (inclusive) that rule is in effect. MAX_VALUE\n+     * indicates end of time.\n+     * @param mode 'u' - transitions are calculated against UTC, 'w' -\n+     * transitions are calculated against wall offset, 's' - transitions are\n+     * calculated against standard offset.\n+     * @param dayOfMonth if negative, set to ((last day of month) - ~dayOfMonth).\n+     * For example, if -1, set to last day of month\n+     * @param dayOfWeek if 0, ignore\n+     * @param advanceDayOfWeek if dayOfMonth does not fall on dayOfWeek, advance to\n+     * dayOfWeek when true, retreat when false.\n+     * @param millisOfDay additional precision for specifying time of day of\n+     * transitions\n+     */\n+    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,\n+                                                   int fromYear, int toYear,\n+                                                   char mode,\n+                                                   int monthOfYear,\n+                                                   int dayOfMonth,\n+                                                   int dayOfWeek,\n+                                                   boolean advanceDayOfWeek,\n+                                                   int millisOfDay)\n+    {\n+        if (fromYear <= toYear) {\n+            OfYear ofYear = new OfYear\n+                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n+            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n+            Rule rule = new Rule(recurrence, fromYear, toYear);\n+            getLastRuleSet().addRule(rule);\n+        }\n+        return this;\n+    }\n+\n+    private RuleSet getLastRuleSet() {\n+        if (iRuleSets.size() == 0) {\n+            addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);\n+        }\n+        return (RuleSet)iRuleSets.get(iRuleSets.size() - 1);\n+    }\n+    \n+    /**\n+     * Processes all the rules and builds a DateTimeZone.\n+     *\n+     * @param id time zone id to assign\n+     */\n+    public DateTimeZone toDateTimeZone(String id) {\n+        if (id == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        // Discover where all the transitions occur and store the results in\n+        // these lists.\n+        ArrayList transitions = new ArrayList();\n+\n+        // Tail zone picks up remaining transitions in the form of an endless\n+        // DST cycle.\n+        DSTZone tailZone = null;\n+\n+        long millis = Long.MIN_VALUE;\n+        int saveMillis = 0;\n+            \n+        int ruleSetCount = iRuleSets.size();\n+        for (int i=0; i<ruleSetCount; i++) {\n+            RuleSet rs = (RuleSet)iRuleSets.get(i);\n+            Transition next = rs.firstTransition(millis);\n+            if (next == null) {\n+                continue;\n+            }\n+            addTransition(transitions, next);\n+            millis = next.getMillis();\n+            saveMillis = next.getSaveMillis();\n+\n+            // Copy it since we're going to destroy it.\n+            rs = new RuleSet(rs);\n+\n+            while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n+                if (addTransition(transitions, next)) {\n+                    if (tailZone != null) {\n+                        // Got the extra transition before DSTZone.\n+                        break;\n+                    }\n+                }\n+                millis = next.getMillis();\n+                saveMillis = next.getSaveMillis();\n+                if (tailZone == null && i == ruleSetCount - 1) {\n+                    tailZone = rs.buildTailZone(id);\n+                    // If tailZone is not null, don't break out of main loop until\n+                    // at least one more transition is calculated. This ensures a\n+                    // correct 'seam' to the DSTZone.\n+                }\n+            }\n+\n+            millis = rs.getUpperLimit(saveMillis);\n+        }\n+\n+        // Check if a simpler zone implementation can be returned.\n+        if (transitions.size() == 0) {\n+            if (tailZone != null) {\n+                // This shouldn't happen, but handle just in case.\n+                return tailZone;\n+            }\n+            return buildFixedZone(id, \"UTC\", 0, 0);\n+        }\n+        if (transitions.size() == 1 && tailZone == null) {\n+            Transition tr = (Transition)transitions.get(0);\n+            return buildFixedZone(id, tr.getNameKey(),\n+                                  tr.getWallOffset(), tr.getStandardOffset());\n+        }\n+\n+        PrecalculatedZone zone = new PrecalculatedZone(id, transitions, tailZone);\n+        if (zone.isCachable()) {\n+            return CachedDateTimeZone.forZone(zone);\n+        }\n+        return zone;\n+    }\n+\n+    private boolean addTransition(ArrayList transitions, Transition tr) {\n+        int size = transitions.size();\n+        if (size == 0) {\n+            transitions.add(tr);\n+            return true;\n+        }\n+\n+        Transition last = (Transition)transitions.get(size - 1);\n+        if (!tr.isTransitionFrom(last)) {\n+            return false;\n+        }\n+\n+        // If local time of new transition is same as last local time, just\n+        // replace last transition with new one.\n+        int offsetForLast = 0;\n+        if (size >= 2) {\n+            offsetForLast = ((Transition)transitions.get(size - 2)).getWallOffset();\n+        }\n+        int offsetForNew = last.getWallOffset();\n+\n+        long lastLocal = last.getMillis() + offsetForLast;\n+        long newLocal = tr.getMillis() + offsetForNew;\n+\n+        if (newLocal != lastLocal) {\n+            transitions.add(tr);\n+            return true;\n+        }\n+\n+        transitions.remove(size - 1);\n+        return addTransition(transitions, tr);\n+    }\n+\n+    /**\n+     * Encodes a built DateTimeZone to the given stream. Call readFrom to\n+     * decode the data into a DateTimeZone object.\n+     *\n+     * @param out output stream to receive encoded DateTimeZone.\n+     */\n+    public void writeTo(OutputStream out) throws IOException {\n+        if (out instanceof DataOutput) {\n+            writeTo((DataOutput)out);\n+        } else {\n+            writeTo((DataOutput)new DataOutputStream(out));\n+        }\n+    }\n+\n+    /**\n+     * Encodes a built DateTimeZone to the given stream. Call readFrom to\n+     * decode the data into a DateTimeZone object.\n+     *\n+     * @param out output stream to receive encoded DateTimeZone.\n+     */\n+    public void writeTo(DataOutput out) throws IOException {\n+        // The zone id is not written out, so the empty string is okay.\n+        DateTimeZone zone = toDateTimeZone(\"\");\n+\n+        if (zone instanceof FixedDateTimeZone) {\n+            out.writeByte('F'); // 'F' for fixed\n+            out.writeUTF(zone.getNameKey(0));\n+            writeMillis(out, zone.getOffset(0));\n+            writeMillis(out, zone.getStandardOffset(0));\n+        } else {\n+            if (zone instanceof CachedDateTimeZone) {\n+                out.writeByte('C'); // 'C' for cached, precalculated\n+                zone = ((CachedDateTimeZone)zone).getUncachedZone();\n+            } else {\n+                out.writeByte('P'); // 'P' for precalculated, uncached\n+            }\n+            ((PrecalculatedZone)zone).writeTo(out);\n+        }\n+    }\n+\n+    /**\n+     * Supports setting fields of year and moving between transitions.\n+     */\n+    private static final class OfYear {\n+        static OfYear readFrom(DataInput in) throws IOException {\n+            return new OfYear((char)in.readUnsignedByte(),\n+                              (int)in.readUnsignedByte(),\n+                              (int)in.readByte(),\n+                              (int)in.readUnsignedByte(),\n+                              in.readBoolean(),\n+                              (int)readMillis(in));\n+        }\n+\n+        // Is 'u', 'w', or 's'.\n+        final char iMode;\n+\n+        final int iMonthOfYear;\n+        final int iDayOfMonth;\n+        final int iDayOfWeek;\n+        final boolean iAdvance;\n+        final int iMillisOfDay;\n+\n+        OfYear(char mode,\n+               int monthOfYear,\n+               int dayOfMonth,\n+               int dayOfWeek, boolean advanceDayOfWeek,\n+               int millisOfDay)\n+        {\n+            if (mode != 'u' && mode != 'w' && mode != 's') {\n+                throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n+            }\n+\n+            iMode = mode;\n+            iMonthOfYear = monthOfYear;\n+            iDayOfMonth = dayOfMonth;\n+            iDayOfWeek = dayOfWeek;\n+            iAdvance = advanceDayOfWeek;\n+            iMillisOfDay = millisOfDay;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before instant\n+         */\n+        public long setInstant(int year, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long millis = chrono.year().set(0, year);\n+            millis = chrono.monthOfYear().set(millis, iMonthOfYear);\n+            millis = chrono.millisOfDay().set(millis, iMillisOfDay);\n+            millis = setDayOfMonth(chrono, millis);\n+\n+            if (iDayOfWeek != 0) {\n+                millis = setDayOfWeek(chrono, millis);\n+            }\n+\n+            // Convert from local time to UTC.\n+            return millis - offset;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before next recurrence\n+         */\n+        public long next(long millis, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            // Convert from UTC to local time.\n+            millis += offset;\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long next = chrono.monthOfYear().set(millis, iMonthOfYear);\n+            next = chrono.millisOfDay().set(next, iMillisOfDay);\n+            next = setDayOfMonthNext(chrono, next);\n+\n+            if (iDayOfWeek == 0) {\n+                if (next <= millis) {\n+                    next = chrono.year().add(next, 1);\n+                    next = setDayOfMonthNext(chrono, next);\n+                }\n+            } else {\n+                next = setDayOfWeek(chrono, next);\n+                if (next <= millis) {\n+                    next = chrono.year().add(next, 1);\n+                    next = chrono.monthOfYear().set(next, iMonthOfYear);\n+                    next = setDayOfMonthNext(chrono, next);\n+                    next = setDayOfWeek(chrono, next);\n+                }\n+            }\n+\n+            // Convert from local time to UTC.\n+            return next - offset;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before previous recurrence\n+         */\n+        public long previous(long millis, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            // Convert from UTC to local time.\n+            millis += offset;\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long prev = chrono.monthOfYear().set(millis, iMonthOfYear);\n+            prev = chrono.millisOfDay().set(prev, iMillisOfDay);\n+            prev = setDayOfMonthPrevious(chrono, prev);\n+\n+            if (iDayOfWeek == 0) {\n+                if (prev >= millis) {\n+                    prev = chrono.year().add(prev, -1);\n+                    prev = setDayOfMonthPrevious(chrono, prev);\n+                }\n+            } else {\n+                prev = setDayOfWeek(chrono, prev);\n+                if (prev >= millis) {\n+                    prev = chrono.year().add(prev, -1);\n+                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n+                    prev = setDayOfMonthPrevious(chrono, prev);\n+                    prev = setDayOfWeek(chrono, prev);\n+                }\n+            }\n+\n+            // Convert from local time to UTC.\n+            return prev - offset;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof OfYear) {\n+                OfYear other = (OfYear)obj;\n+                return\n+                    iMode == other.iMode &&\n+                    iMonthOfYear == other.iMonthOfYear &&\n+                    iDayOfMonth == other.iDayOfMonth &&\n+                    iDayOfWeek == other.iDayOfWeek &&\n+                    iAdvance == other.iAdvance &&\n+                    iMillisOfDay == other.iMillisOfDay;\n+            }\n+            return false;\n+        }\n+\n+        /*\n+        public String toString() {\n+            return\n+                \"[OfYear]\\n\" + \n+                \"Mode: \" + iMode + '\\n' +\n+                \"MonthOfYear: \" + iMonthOfYear + '\\n' +\n+                \"DayOfMonth: \" + iDayOfMonth + '\\n' +\n+                \"DayOfWeek: \" + iDayOfWeek + '\\n' +\n+                \"AdvanceDayOfWeek: \" + iAdvance + '\\n' +\n+                \"MillisOfDay: \" + iMillisOfDay + '\\n';\n+        }\n+        */\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            out.writeByte(iMode);\n+            out.writeByte(iMonthOfYear);\n+            out.writeByte(iDayOfMonth);\n+            out.writeByte(iDayOfWeek);\n+            out.writeBoolean(iAdvance);\n+            writeMillis(out, iMillisOfDay);\n+        }\n+\n+        /**\n+         * If month-day is 02-29 and year isn't leap, advances to next leap year.\n+         */\n+        private long setDayOfMonthNext(Chronology chrono, long next) {\n+            try {\n+                next = setDayOfMonth(chrono, next);\n+            } catch (IllegalArgumentException e) {\n+                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n+                    while (chrono.year().isLeap(next) == false) {\n+                        next = chrono.year().add(next, 1);\n+                    }\n+                    next = setDayOfMonth(chrono, next);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+            return next;\n+        }\n+\n+        /**\n+         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n+         */\n+        private long setDayOfMonthPrevious(Chronology chrono, long prev) {\n+            try {\n+                prev = setDayOfMonth(chrono, prev);\n+            } catch (IllegalArgumentException e) {\n+                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n+                    while (chrono.year().isLeap(prev) == false) {\n+                        prev = chrono.year().add(prev, -1);\n+                    }\n+                    prev = setDayOfMonth(chrono, prev);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+            return prev;\n+        }\n+\n+        private long setDayOfMonth(Chronology chrono, long millis) {\n+            if (iDayOfMonth >= 0) {\n+                millis = chrono.dayOfMonth().set(millis, iDayOfMonth);\n+            } else {\n+                millis = chrono.dayOfMonth().set(millis, 1);\n+                millis = chrono.monthOfYear().add(millis, 1);\n+                millis = chrono.dayOfMonth().add(millis, iDayOfMonth);\n+            }\n+            return millis;\n+        }\n+\n+        private long setDayOfWeek(Chronology chrono, long millis) {\n+            int dayOfWeek = chrono.dayOfWeek().get(millis);\n+            int daysToAdd = iDayOfWeek - dayOfWeek;\n+            if (daysToAdd != 0) {\n+                if (iAdvance) {\n+                    if (daysToAdd < 0) {\n+                        daysToAdd += 7;\n+                    }\n+                } else {\n+                    if (daysToAdd > 0) {\n+                        daysToAdd -= 7;\n+                    }\n+                }\n+                millis = chrono.dayOfWeek().add(millis, daysToAdd);\n+            }\n+            return millis;\n+        }\n+    }\n+\n+    /**\n+     * Extends OfYear with a nameKey and savings.\n+     */\n+    private static final class Recurrence {\n+        static Recurrence readFrom(DataInput in) throws IOException {\n+            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n+        }\n+\n+        final OfYear iOfYear;\n+        final String iNameKey;\n+        final int iSaveMillis;\n+\n+        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\n+            iOfYear = ofYear;\n+            iNameKey = nameKey;\n+            iSaveMillis = saveMillis;\n+        }\n+\n+        public OfYear getOfYear() {\n+            return iOfYear;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before next recurrence\n+         */\n+        public long next(long millis, int standardOffset, int saveMillis) {\n+            return iOfYear.next(millis, standardOffset, saveMillis);\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before previous recurrence\n+         */\n+        public long previous(long millis, int standardOffset, int saveMillis) {\n+            return iOfYear.previous(millis, standardOffset, saveMillis);\n+        }\n+\n+        public String getNameKey() {\n+            return iNameKey;\n+        }\n+\n+        public int getSaveMillis() {\n+            return iSaveMillis;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof Recurrence) {\n+                Recurrence other = (Recurrence)obj;\n+                return\n+                    iSaveMillis == other.iSaveMillis &&\n+                    iNameKey.equals(other.iNameKey) &&\n+                    iOfYear.equals(other.iOfYear);\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            iOfYear.writeTo(out);\n+            out.writeUTF(iNameKey);\n+            writeMillis(out, iSaveMillis);\n+        }\n+    }\n+\n+    /**\n+     * Extends Recurrence with inclusive year limits.\n+     */\n+    private static final class Rule {\n+        final Recurrence iRecurrence;\n+        final int iFromYear; // inclusive\n+        final int iToYear;   // inclusive\n+\n+        Rule(Recurrence recurrence, int fromYear, int toYear) {\n+            iRecurrence = recurrence;\n+            iFromYear = fromYear;\n+            iToYear = toYear;\n+        }\n+\n+        public int getFromYear() {\n+            return iFromYear;\n+        }\n+\n+        public int getToYear() {\n+            return iToYear;\n+        }\n+\n+        public OfYear getOfYear() {\n+            return iRecurrence.getOfYear();\n+        }\n+\n+        public String getNameKey() {\n+            return iRecurrence.getNameKey();\n+        }\n+\n+        public int getSaveMillis() {\n+            return iRecurrence.getSaveMillis();\n+        }\n+\n+        public long next(final long millis, int standardOffset, int saveMillis) {\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+            final int wallOffset = standardOffset + saveMillis;\n+            long testMillis = millis;\n+\n+            int year;\n+            if (millis == Long.MIN_VALUE) {\n+                year = Integer.MIN_VALUE;\n+            } else {\n+                year = chrono.year().get(millis + wallOffset);\n+            }\n+\n+            if (year < iFromYear) {\n+                // First advance millis to start of from year.\n+                testMillis = chrono.year().set(0, iFromYear) - wallOffset;\n+                // Back off one millisecond to account for next recurrence\n+                // being exactly at the beginning of the year.\n+                testMillis -= 1;\n+            }\n+\n+            long next = iRecurrence.next(testMillis, standardOffset, saveMillis);\n+\n+            if (next > millis) {\n+                year = chrono.year().get(next + wallOffset);\n+                if (year > iToYear) {\n+                    // Out of range, return original value.\n+                    next = millis;\n+                }\n+            }\n+\n+            return next;\n+        }\n+    }\n+\n+    private static final class Transition {\n+        private final long iMillis;\n+        private final String iNameKey;\n+        private final int iWallOffset;\n+        private final int iStandardOffset;\n+\n+        Transition(long millis, Transition tr) {\n+            iMillis = millis;\n+            iNameKey = tr.iNameKey;\n+            iWallOffset = tr.iWallOffset;\n+            iStandardOffset = tr.iStandardOffset;\n+        }\n+\n+        Transition(long millis, Rule rule, int standardOffset) {\n+            iMillis = millis;\n+            iNameKey = rule.getNameKey();\n+            iWallOffset = standardOffset + rule.getSaveMillis();\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        Transition(long millis, String nameKey,\n+                   int wallOffset, int standardOffset) {\n+            iMillis = millis;\n+            iNameKey = nameKey;\n+            iWallOffset = wallOffset;\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        public long getMillis() {\n+            return iMillis;\n+        }\n+\n+        public String getNameKey() {\n+            return iNameKey;\n+        }\n+\n+        public int getWallOffset() {\n+            return iWallOffset;\n+        }\n+\n+        public int getStandardOffset() {\n+            return iStandardOffset;\n+        }\n+\n+        public int getSaveMillis() {\n+            return iWallOffset - iStandardOffset;\n+        }\n+\n+        /**\n+         * There must be a change in the millis, wall offsets or name keys.\n+         */\n+        public boolean isTransitionFrom(Transition other) {\n+            if (other == null) {\n+                return true;\n+            }\n+            return iMillis > other.iMillis &&\n+                (iWallOffset != other.iWallOffset ||\n+                 //iStandardOffset != other.iStandardOffset ||\n+                 !(iNameKey.equals(other.iNameKey)));\n+        }\n+    }\n+\n+    private static final class RuleSet {\n+        private static final int YEAR_LIMIT;\n+\n+        static {\n+            // Don't pre-calculate more than 100 years into the future. Almost\n+            // all zones will stop pre-calculating far sooner anyhow. Either a\n+            // simple DST cycle is detected or the last rule is a fixed\n+            // offset. If a zone has a fixed offset set more than 100 years\n+            // into the future, then it won't be observed.\n+            long now = System.currentTimeMillis();\n+            YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;\n+        }\n+\n+        private int iStandardOffset;\n+        private ArrayList iRules;\n+\n+        // Optional.\n+        private String iInitialNameKey;\n+        private int iInitialSaveMillis;\n+\n+        // Upper limit is exclusive.\n+        private int iUpperYear;\n+        private OfYear iUpperOfYear;\n+\n+        RuleSet() {\n+            iRules = new ArrayList(10);\n+            iUpperYear = Integer.MAX_VALUE;\n+        }\n+\n+        /**\n+         * Copy constructor.\n+         */\n+        RuleSet(RuleSet rs) {\n+            iStandardOffset = rs.iStandardOffset;\n+            iRules = new ArrayList(rs.iRules);\n+            iInitialNameKey = rs.iInitialNameKey;\n+            iInitialSaveMillis = rs.iInitialSaveMillis;\n+            iUpperYear = rs.iUpperYear;\n+            iUpperOfYear = rs.iUpperOfYear;\n+        }\n+\n+        public int getStandardOffset() {\n+            return iStandardOffset;\n+        }\n+\n+        public void setStandardOffset(int standardOffset) {\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        public void setFixedSavings(String nameKey, int saveMillis) {\n+            iInitialNameKey = nameKey;\n+            iInitialSaveMillis = saveMillis;\n+        }\n+\n+        public void addRule(Rule rule) {\n+            if (!iRules.contains(rule)) {\n+                iRules.add(rule);\n+            }\n+        }\n+\n+        public void setUpperLimit(int year, OfYear ofYear) {\n+            iUpperYear = year;\n+            iUpperOfYear = ofYear;\n+        }\n+\n+        /**\n+         * Returns a transition at firstMillis with the first name key and\n+         * offsets for this rule set. This method may return null.\n+         *\n+         * @param firstMillis millis of first transition\n+         */\n+        public Transition firstTransition(final long firstMillis) {\n+            if (iInitialNameKey != null) {\n+                // Initial zone info explicitly set, so don't search the rules.\n+                return new Transition(firstMillis, iInitialNameKey,\n+                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);\n+            }\n+\n+            // Make a copy before we destroy the rules.\n+            ArrayList copy = new ArrayList(iRules);\n+\n+            // Iterate through all the transitions until firstMillis is\n+            // reached. Use the name key and savings for whatever rule reaches\n+            // the limit.\n+\n+            long millis = Long.MIN_VALUE;\n+            int saveMillis = 0;\n+            Transition first = null;\n+\n+            Transition next;\n+            while ((next = nextTransition(millis, saveMillis)) != null) {\n+                millis = next.getMillis();\n+\n+                if (millis == firstMillis) {\n+                    first = new Transition(firstMillis, next);\n+                    break;\n+                }\n+\n+                if (millis > firstMillis) {\n+                    if (first == null) {\n+                        // Find first rule without savings. This way a more\n+                        // accurate nameKey is found even though no rule\n+                        // extends to the RuleSet's lower limit.\n+                        Iterator it = copy.iterator();\n+                        while (it.hasNext()) {\n+                            Rule rule = (Rule)it.next();\n+                            if (rule.getSaveMillis() == 0) {\n+                                first = new Transition(firstMillis, rule, iStandardOffset);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    if (first == null) {\n+                        // Found no rule without savings. Create a transition\n+                        // with no savings anyhow, and use the best available\n+                        // name key.\n+                        first = new Transition(firstMillis, next.getNameKey(),\n+                                               iStandardOffset, iStandardOffset);\n+                    }\n+                    break;\n+                }\n+                \n+                // Set first to the best transition found so far, but next\n+                // iteration may find something closer to lower limit.\n+                first = new Transition(firstMillis, next);\n+\n+                saveMillis = next.getSaveMillis();\n+            }\n+\n+            iRules = copy;\n+            return first;\n+        }\n+\n+        /**\n+         * Returns null if RuleSet is exhausted or upper limit reached. Calling\n+         * this method will throw away rules as they each become\n+         * exhausted. Copy the RuleSet before using it to compute transitions.\n+         *\n+         * Returned transition may be a duplicate from previous\n+         * transition. Caller must call isTransitionFrom to filter out\n+         * duplicates.\n+         *\n+         * @param saveMillis savings before next transition\n+         */\n+        public Transition nextTransition(final long millis, final int saveMillis) {\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+            // Find next matching rule.\n+            Rule nextRule = null;\n+            long nextMillis = Long.MAX_VALUE;\n+            \n+            Iterator it = iRules.iterator();\n+            while (it.hasNext()) {\n+                Rule rule = (Rule)it.next();\n+                long next = rule.next(millis, iStandardOffset, saveMillis);\n+                if (next <= millis) {\n+                    it.remove();\n+                    continue;\n+                }\n+                // Even if next is same as previous next, choose the rule\n+                // in order for more recently added rules to override.\n+                if (next <= nextMillis) {\n+                    // Found a better match.\n+                    nextRule = rule;\n+                    nextMillis = next;\n+                }\n+            }\n+            \n+            if (nextRule == null) {\n+                return null;\n+            }\n+            \n+            // Stop precalculating if year reaches some arbitrary limit.\n+            if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {\n+                return null;\n+            }\n+            \n+            // Check if upper limit reached or passed.\n+            if (iUpperYear < Integer.MAX_VALUE) {\n+                long upperMillis =\n+                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n+                if (nextMillis >= upperMillis) {\n+                    // At or after upper limit.\n+                    return null;\n+                }\n+            }\n+            \n+            return new Transition(nextMillis, nextRule, iStandardOffset);\n+        }\n+\n+        /**\n+         * @param saveMillis savings before upper limit\n+         */\n+        public long getUpperLimit(int saveMillis) {\n+            if (iUpperYear == Integer.MAX_VALUE) {\n+                return Long.MAX_VALUE;\n+            }\n+            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n+        }\n+\n+        /**\n+         * Returns null if none can be built.\n+         */\n+        public DSTZone buildTailZone(String id) {\n+            if (iRules.size() == 2) {\n+                Rule startRule = (Rule)iRules.get(0);\n+                Rule endRule = (Rule)iRules.get(1);\n+                if (startRule.getToYear() == Integer.MAX_VALUE &&\n+                    endRule.getToYear() == Integer.MAX_VALUE) {\n+\n+                    // With exactly two infinitely recurring rules left, a\n+                    // simple DSTZone can be formed.\n+\n+                    // The order of rules can come in any order, and it doesn't\n+                    // really matter which rule was chosen the 'start' and\n+                    // which is chosen the 'end'. DSTZone works properly either\n+                    // way.\n+                    return new DSTZone(id, iStandardOffset,\n+                                       startRule.iRecurrence, endRule.iRecurrence);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class DSTZone extends DateTimeZone {\n+        static DSTZone readFrom(DataInput in, String id) throws IOException {\n+            return new DSTZone(id, (int)readMillis(in), \n+                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n+        }\n+\n+        private final int iStandardOffset;\n+        private final Recurrence iStartRecurrence;\n+        private final Recurrence iEndRecurrence;\n+\n+        DSTZone(String id, int standardOffset,\n+                Recurrence startRecurrence, Recurrence endRecurrence) {\n+            super(id);\n+            iStandardOffset = standardOffset;\n+            iStartRecurrence = startRecurrence;\n+            iEndRecurrence = endRecurrence;\n+        }\n+\n+        public String getNameKey(long millis) {\n+            return findMatchingRecurrence(millis).getNameKey();\n+        }\n+\n+        public int getOffset(long millis) {\n+            return iStandardOffset + findMatchingRecurrence(millis).getSaveMillis();\n+        }\n+\n+        public int getStandardOffset(long millis) {\n+            return iStandardOffset;\n+        }\n+\n+        public long nextTransition(long millis) {\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start = startRecurrence.next\n+                (millis, standardOffset, endRecurrence.getSaveMillis());\n+            long end = endRecurrence.next\n+                (millis, standardOffset, startRecurrence.getSaveMillis());\n+\n+            return (start > end) ? end : start;\n+        }\n+\n+        public long previousTransition(long millis) {\n+            // Increment in order to handle the case where millis is exactly at\n+            // a transition.\n+            millis++;\n+\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start = startRecurrence.previous\n+                (millis, standardOffset, endRecurrence.getSaveMillis());\n+            long end = endRecurrence.previous\n+                (millis, standardOffset, startRecurrence.getSaveMillis());\n+\n+            return ((start > end) ? start : end) - 1;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof DSTZone) {\n+                DSTZone other = (DSTZone)obj;\n+                return\n+                    getID().equals(other.getID()) &&\n+                    iStandardOffset == other.iStandardOffset &&\n+                    iStartRecurrence.equals(other.iStartRecurrence) &&\n+                    iEndRecurrence.equals(other.iEndRecurrence);\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            writeMillis(out, iStandardOffset);\n+            iStartRecurrence.writeTo(out);\n+            iEndRecurrence.writeTo(out);\n+        }\n+\n+        private Recurrence findMatchingRecurrence(long millis) {\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start = startRecurrence.next\n+                (millis, standardOffset, endRecurrence.getSaveMillis());\n+            long end = endRecurrence.next\n+                (millis, standardOffset, startRecurrence.getSaveMillis());\n+\n+            return (start > end) ? startRecurrence : endRecurrence;\n+        }\n+    }\n+\n+    private static final class PrecalculatedZone extends DateTimeZone {\n+        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n+            // Read string pool.\n+            int poolSize = in.readUnsignedShort();\n+            String[] pool = new String[poolSize];\n+            for (int i=0; i<poolSize; i++) {\n+                pool[i] = in.readUTF();\n+            }\n+\n+            int size = in.readInt();\n+            long[] transitions = new long[size];\n+            int[] wallOffsets = new int[size];\n+            int[] standardOffsets = new int[size];\n+            String[] nameKeys = new String[size];\n+            \n+            for (int i=0; i<size; i++) {\n+                transitions[i] = readMillis(in);\n+                wallOffsets[i] = (int)readMillis(in);\n+                standardOffsets[i] = (int)readMillis(in);\n+                try {\n+                    int index;\n+                    if (poolSize < 256) {\n+                        index = in.readUnsignedByte();\n+                    } else {\n+                        index = in.readUnsignedShort();\n+                    }\n+                    nameKeys[i] = pool[index];\n+                } catch (ArrayIndexOutOfBoundsException e) {\n+                    throw new IOException(\"Invalid encoding\");\n+                }\n+            }\n+\n+            DSTZone tailZone = null;\n+            if (in.readBoolean()) {\n+                tailZone = DSTZone.readFrom(in, id);\n+            }\n+\n+            return new PrecalculatedZone\n+                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n+        }\n+\n+        // All array fields have the same length.\n+\n+        private final long[] iTransitions;\n+\n+        private final int[] iWallOffsets;\n+        private final int[] iStandardOffsets;\n+        private final String[] iNameKeys;\n+\n+        private final DSTZone iTailZone;\n+\n+        PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n+                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n+        {\n+            super(id);\n+            iTransitions = transitions;\n+            iWallOffsets = wallOffsets;\n+            iStandardOffsets = standardOffsets;\n+            iNameKeys = nameKeys;\n+            iTailZone = tailZone;\n+        }\n+\n+        /**\n+         * @param tailZone optional zone for getting info beyond precalculated\n+         * tables.\n+         */\n+        PrecalculatedZone(String id, ArrayList transitions, DSTZone tailZone) {\n+            super(id);\n+\n+            int size = transitions.size();\n+            if (size == 0) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            iTransitions = new long[size];\n+            iWallOffsets = new int[size];\n+            iStandardOffsets = new int[size];\n+            iNameKeys = new String[size];\n+\n+            Transition last = null;\n+            for (int i=0; i<size; i++) {\n+                Transition tr = (Transition)transitions.get(i);\n+\n+                if (!tr.isTransitionFrom(last)) {\n+                    throw new IllegalArgumentException(id);\n+                }\n+\n+                iTransitions[i] = tr.getMillis();\n+                iWallOffsets[i] = tr.getWallOffset();\n+                iStandardOffsets[i] = tr.getStandardOffset();\n+                iNameKeys[i] = tr.getNameKey();\n+\n+                last = tr;\n+            }\n+\n+            iTailZone = tailZone;\n+        }\n+\n+        public String getNameKey(long millis) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, millis);\n+            if (i >= 0) {\n+                return iNameKeys[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iNameKeys[i - 1];\n+                }\n+                return \"UTC\";\n+            }\n+            if (iTailZone == null) {\n+                return iNameKeys[i - 1];\n+            }\n+            return iTailZone.getNameKey(millis);\n+        }\n+\n+        public int getOffset(long millis) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, millis);\n+            if (i >= 0) {\n+                return iWallOffsets[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iWallOffsets[i - 1];\n+                }\n+                return 0;\n+            }\n+            if (iTailZone == null) {\n+                return iWallOffsets[i - 1];\n+            }\n+            return iTailZone.getOffset(millis);\n+        }\n+\n+        public int getStandardOffset(long millis) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, millis);\n+            if (i >= 0) {\n+                return iStandardOffsets[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iStandardOffsets[i - 1];\n+                }\n+                return 0;\n+            }\n+            if (iTailZone == null) {\n+                return iStandardOffsets[i - 1];\n+            }\n+            return iTailZone.getStandardOffset(millis);\n+        }\n+\n+        public long nextTransition(long millis) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, millis);\n+            i = (i >= 0) ? (i + 1) : ~i;\n+            if (i < transitions.length) {\n+                return transitions[i];\n+            }\n+            if (iTailZone == null) {\n+                return millis;\n+            }\n+            long end = transitions[transitions.length - 1];\n+            if (millis < end) {\n+                millis = end;\n+            }\n+            return iTailZone.nextTransition(millis);\n+        }\n+\n+        public long previousTransition(long millis) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, millis);\n+            if (i >= 0) {\n+                if (millis > Long.MIN_VALUE) {\n+                    return millis - 1;\n+                }\n+                return millis;\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    long prev = transitions[i - 1];\n+                    if (prev > Long.MIN_VALUE) {\n+                        return prev - 1;\n+                    }\n+                }\n+                return millis;\n+            }\n+            if (iTailZone != null) {\n+                long prev = iTailZone.previousTransition(millis);\n+                if (prev < millis) {\n+                    return prev;\n+                }\n+            }\n+            long prev = transitions[i - 1];\n+            if (prev > Long.MIN_VALUE) {\n+                return prev - 1;\n+            }\n+            return millis;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof PrecalculatedZone) {\n+                PrecalculatedZone other = (PrecalculatedZone)obj;\n+                return\n+                    getID().equals(other.getID()) &&\n+                    Arrays.equals(iTransitions, other.iTransitions) &&\n+                    Arrays.equals(iNameKeys, other.iNameKeys) &&\n+                    Arrays.equals(iWallOffsets, other.iWallOffsets) &&\n+                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &&\n+                    ((iTailZone == null)\n+                     ? (null == other.iTailZone)\n+                     : (iTailZone.equals(other.iTailZone)));\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            int size = iTransitions.length;\n+\n+            // Create unique string pool.\n+            Set poolSet = new HashSet();\n+            for (int i=0; i<size; i++) {\n+                poolSet.add(iNameKeys[i]);\n+            }\n+\n+            int poolSize = poolSet.size();\n+            if (poolSize > 65535) {\n+                throw new UnsupportedOperationException(\"String pool is too large\");\n+            }\n+            String[] pool = new String[poolSize];\n+            Iterator it = poolSet.iterator();\n+            for (int i=0; it.hasNext(); i++) {\n+                pool[i] = (String)it.next();\n+            }\n+\n+            // Write out the pool.\n+            out.writeShort(poolSize);\n+            for (int i=0; i<poolSize; i++) {\n+                out.writeUTF(pool[i]);\n+            }\n+\n+            out.writeInt(size);\n+\n+            for (int i=0; i<size; i++) {\n+                writeMillis(out, iTransitions[i]);\n+                writeMillis(out, iWallOffsets[i]);\n+                writeMillis(out, iStandardOffsets[i]);\n+                \n+                // Find pool index and write it out.\n+                String nameKey = iNameKeys[i];\n+                for (int j=0; j<poolSize; j++) {\n+                    if (pool[j].equals(nameKey)) {\n+                        if (poolSize < 256) {\n+                            out.writeByte(j);\n+                        } else {\n+                            out.writeShort(j);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            out.writeBoolean(iTailZone != null);\n+            if (iTailZone != null) {\n+                iTailZone.writeTo(out);\n+            }\n+        }\n+\n+        public boolean isCachable() {\n+            if (iTailZone != null) {\n+                return true;\n+            }\n+            long[] transitions = iTransitions;\n+            if (transitions.length <= 1) {\n+                return false;\n+            }\n+\n+            // Add up all the distances between transitions that are less than\n+            // about two years.\n+            double distances = 0;\n+            int count = 0;\n+\n+            for (int i=1; i<transitions.length; i++) {\n+                long diff = transitions[i] - transitions[i - 1];\n+                if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) {\n+                    distances += (double)diff;\n+                    count++;\n+                }\n+            }\n+\n+            if (count > 0) {\n+                double avg = distances / count;\n+                avg /= 24 * 60 * 60 * 1000;\n+                if (avg >= 25) {\n+                    // Only bother caching if average distance between\n+                    // transitions is at least 25 days. Why 25?\n+                    // CachedDateTimeZone is more efficient if the distance\n+                    // between transitions is large. With an average of 25, it\n+                    // will on average perform about 2 tests per cache\n+                    // hit. (49.7 / 25) is approximately 2.\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.HashMap;\n+import java.util.Locale;\n+\n+/**\n+ * The default name provider acquires localized names from\n+ * {@link DateFormatSymbols java.text.DateFormatSymbols}.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class DefaultNameProvider implements NameProvider {\n+    // locale -> (id -> (nameKey -> [shortName, name]))\n+    private HashMap iByLocaleCache = createCache();\n+\n+    public DefaultNameProvider() {\n+    }\n+\n+    public String getShortName(Locale locale, String id, String nameKey) {\n+        String[] nameSet = getNameSet(locale, id, nameKey);\n+        return nameSet == null ? null : nameSet[0];\n+    }\n+    \n+    public String getName(Locale locale, String id, String nameKey) {\n+        String[] nameSet = getNameSet(locale, id, nameKey);\n+        return nameSet == null ? null : nameSet[1];\n+    }\n+\n+    private synchronized String[] getNameSet(Locale locale, String id, String nameKey) {\n+        if (locale == null || id == null || nameKey == null) {\n+            return null;\n+        }\n+\n+        HashMap byIdCache = (HashMap)iByLocaleCache.get(locale);\n+        if (byIdCache == null) {\n+            iByLocaleCache.put(locale, byIdCache = createCache());\n+        }\n+\n+        HashMap byNameKeyCache = (HashMap)byIdCache.get(id);\n+        if (byNameKeyCache == null) {\n+            byIdCache.put(id, byNameKeyCache = createCache());\n+            String[][] zoneStrings = new DateFormatSymbols(locale).getZoneStrings();\n+            for (int i=0; i<zoneStrings.length; i++) {\n+                String[] set = zoneStrings[i];\n+                if (set != null && set.length == 5 && id.equals(set[0])) {\n+                    byNameKeyCache.put(set[2], new String[] {set[2], set[1]});\n+                    byNameKeyCache.put(set[4], new String[] {set[4], set[3]});\n+                }\n+            }\n+        }\n+\n+        return (String[])byNameKeyCache.get(nameKey);\n+    }\n+\n+    private HashMap createCache() {\n+        return new HashMap(7);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Basic DateTimeZone implementation that has a fixed name key and offsets.\n+ * \n+ * @author Brian S O'Neill\n+ */\n+public final class FixedDateTimeZone extends DateTimeZone {\n+    private final String iNameKey;\n+    private final int iWallOffset;\n+    private final int iStandardOffset;\n+\n+    public FixedDateTimeZone(String id, String nameKey,\n+                             int wallOffset, int standardOffset) {\n+        super(id);\n+        iNameKey = nameKey;\n+        iWallOffset = wallOffset;\n+        iStandardOffset = standardOffset;\n+    }\n+\n+    public String getNameKey(long millis) {\n+        return iNameKey;\n+    }\n+\n+    public int getOffset(long millis) {\n+        return iWallOffset;\n+    }\n+\n+    public int getStandardOffset(long millis) {\n+        return iStandardOffset;\n+    }\n+\n+    public int getOffsetFromLocal(long millisLocal) {\n+        return iWallOffset;\n+    }\n+\n+    public long nextTransition(long millis) {\n+        return millis;\n+    }\n+\n+    public long previousTransition(long millis) {\n+        return millis;\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof FixedDateTimeZone) {\n+            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n+            return\n+                getID().equals(other.getID()) &&\n+                iStandardOffset == other.iStandardOffset &&\n+                iWallOffset == other.iWallOffset;\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/NameProvider.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Service provider factory for localized time zone names.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public interface NameProvider {\n+\t/**\n+\t * Returns a localized short name, or null if not found.\n+\t *\n+\t * @param locale locale to use for selecting name set\n+\t * @param id time zone id\n+\t * @param nameKey time zone name key\n+\t */\n+\tString getShortName(Locale locale, String id, String nameKey);\n+\t\n+\t/**\n+\t * Returns a localized name, or null if not found.\n+\t *\n+\t * @param locale locale to use for selecting name set\n+\t * @param id time zone id\n+\t * @param nameKey time zone name key\n+\t */\n+\tString getName(Locale locale, String id, String nameKey);\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/Provider.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.util.Set;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Service provider factory for time zones.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public interface Provider {\n+    /**\n+     * Retrieves a DateTimeZone for the given id. All providers must at\n+     * least support id \"UTC\".\n+     *\n+     * @return null if not found\n+     */\n+    DateTimeZone getDateTimeZone(String id);\n+\n+    /**\n+     * Returns an unmodifiable set of ids. All providers must at least\n+     * support id \"UTC\".\n+     */        \n+    Set getAvailableIDs();\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * Compiles Olson ZoneInfo database files into binary files for each time zone\n+ * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n+ * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n+ * converts them back into {@link DateTimeZone} objects.\n+ *\n+ * <p>Although this tool is similar to zic, the binary formats are not\n+ * compatible. The latest Olson database files may be obtained\n+ * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class ZoneInfoCompiler {\n+    static final DateTimeOfYear START_OF_YEAR = new DateTimeOfYear();\n+\n+    /**\n+     * Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...\n+     */\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            printUsage();\n+            return;\n+        }\n+\n+        String[] sources = args;\n+        String outputDir = null;\n+\n+        if (\"-d\".equals(args[0])) {\n+            if (args.length < 3) {\n+                printUsage();\n+                return;\n+            }\n+            outputDir = args[1];\n+            String[] newSources = new String[args.length - 2];\n+            System.arraycopy(args, 2, newSources, 0, newSources.length);\n+            sources = newSources;\n+        }\n+\n+        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n+        zic.compile(outputDir, sources);\n+    }\n+\n+    private static void printUsage() {\n+        System.out.println\n+            (\"Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...\");\n+    }\n+\n+    static int parseYear(String str, int def) {\n+        str = str.toLowerCase();\n+        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n+            return Integer.MIN_VALUE;\n+        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n+            return Integer.MAX_VALUE;\n+        } else if (str.equals(\"only\")) {\n+            return def;\n+        }\n+        return Integer.parseInt(str);\n+    }\n+\n+    static int parseMonth(String str) {\n+        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n+        return field.get(field.set(0, str, Locale.ENGLISH));\n+    }\n+\n+    static int parseDayOfWeek(String str) {\n+        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n+        return field.get(field.set(0, str, Locale.ENGLISH));\n+    }\n+    \n+    static String parseOptional(String str) {\n+        return (str.equals(\"-\")) ? null : str;\n+    }\n+\n+    static int parseTime(String str) {\n+        Chronology chrono = ISOChronology.getInstanceUTC();\n+        DateTimeParser p = ISODateTimeFormat\n+            .getInstance(chrono)\n+            .hourMinuteSecondFraction();\n+        MutableDateTime mdt = new MutableDateTime(0, chrono);\n+        int pos = 0;\n+        if (str.startsWith(\"-\")) {\n+            pos = 1;\n+        }\n+        int newPos = p.parseInto(mdt, str, pos);\n+        if (newPos == ~pos) {\n+            throw new IllegalArgumentException(str);\n+        }\n+        int millis = (int)mdt.getMillis();\n+        if (pos == 1) {\n+            millis = -millis;\n+        }\n+        return millis;\n+    }\n+\n+    static char parseZoneChar(char c) {\n+        switch (c) {\n+        case 's': case 'S':\n+            // Standard time\n+            return 's';\n+        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n+            // UTC\n+            return 'u';\n+        case 'w': case 'W': default:\n+            // Wall time\n+            return 'w';\n+        }\n+    }\n+\n+    /**\n+     * @return false if error.\n+     */\n+    static boolean test(String id, DateTimeZone tz) {\n+        if (!id.equals(tz.getID())) {\n+            return true;\n+        }\n+\n+        // Test to ensure that reported transitions are not duplicated.\n+\n+        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n+        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n+\n+        int offset = tz.getOffset(millis);\n+        int standardOffset = tz.getStandardOffset(millis);\n+        String key = tz.getNameKey(millis);\n+\n+        List transitions = new ArrayList();\n+\n+        while (true) {\n+            long next = tz.nextTransition(millis);\n+            if (next == millis || next > end) {\n+                break;\n+            }\n+\n+            millis = next;\n+\n+            int nextOffset = tz.getOffset(millis);\n+            String nextKey = tz.getNameKey(millis);\n+\n+            if (offset == nextOffset\n+                && key.equals(nextKey)) {\n+                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC()));\n+                return false;\n+            }\n+\n+            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n+                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC())\n+                                   + \", nameKey=\" + nextKey);\n+                return false;\n+            }\n+\n+            transitions.add(new Long(millis));\n+\n+            offset = nextOffset;\n+            key = nextKey;\n+        }\n+\n+        // Now verify that reverse transitions match up.\n+\n+        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n+        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n+\n+        for (int i=transitions.size(); --i>= 0; ) {\n+            long prev = tz.previousTransition(millis);\n+            if (prev == millis || prev < end) {\n+                break;\n+            }\n+\n+            millis = prev;\n+\n+            long trans = ((Long)transitions.get(i)).longValue();\n+            \n+            if (trans - 1 != millis) {\n+                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC()) + \" != \"\n+                                   + new DateTime(trans - 1,\n+                                                  ISOChronology.getInstanceUTC()));\n+                                   \n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    // Maps names to RuleSets.\n+    private Map iRuleSets;\n+\n+    // List of Zone objects.\n+    private List iZones;\n+\n+    // List String pairs to link.\n+    private List iLinks;\n+\n+    public ZoneInfoCompiler() {\n+        iRuleSets = new HashMap();\n+        iZones = new ArrayList();\n+        iLinks = new ArrayList();\n+    }\n+\n+    /**\n+     * Returns a map of ids to DateTimeZones.\n+     *\n+     * @param outputDir optional directory to write compiled data files to\n+     * @param sources optional list of source file paths to parse\n+     */\n+    public Map compile(String outputDir, String[] sources) throws IOException {\n+        if (sources != null) {\n+            for (int i=0; i<sources.length; i++) {\n+                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n+                parseDataFile(in);\n+                in.close();\n+            }\n+        }\n+\n+        File dir = null;\n+        if (outputDir != null) {\n+            dir = new File(outputDir);\n+            if (!dir.exists()) {\n+                throw new IOException(\"Destination directory doesn't exist: \" + outputDir);\n+            }\n+            if (!dir.isDirectory()) {\n+                throw new IOException(\"Destination is not a directory: \" + outputDir);\n+            }\n+        }\n+\n+        Map map = new TreeMap();\n+\n+        for (int i=0; i<iZones.size(); i++) {\n+            Zone zone = (Zone)iZones.get(i);\n+            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n+            zone.addToBuilder(builder, iRuleSets);\n+            final DateTimeZone original = builder.toDateTimeZone(zone.iName);\n+            DateTimeZone tz = original;\n+            if (test(tz.getID(), tz)) {\n+                map.put(tz.getID(), tz);\n+                if (dir != null) {\n+                    System.out.println(\"Writing \" + tz.getID());\n+                    File file = new File(dir, tz.getID());\n+                    if (!file.getParentFile().exists()) {\n+                        file.getParentFile().mkdirs();\n+                    }\n+                    OutputStream out = new FileOutputStream(file);\n+                    builder.writeTo(out);\n+                    out.close();\n+\n+                    // Test if it can be read back.\n+                    InputStream in = new FileInputStream(file);\n+                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n+                    in.close();\n+\n+                    if (!original.equals(tz2)) {\n+                        System.out.println(\"*e* Error in \" + tz.getID() +\n+                                           \": Didn't read properly from file\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int pass=0; pass<2; pass++) {\n+            for (int i=0; i<iLinks.size(); i += 2) {\n+                String id = (String)iLinks.get(i);\n+                String alias = (String)iLinks.get(i + 1);\n+                DateTimeZone tz = (DateTimeZone)map.get(id);\n+                if (tz == null) {\n+                    if (pass > 0) {\n+                        System.out.println(\"Cannot find time zone '\" + id +\n+                                           \"' to link alias '\" + alias + \"' to\");\n+                    }\n+                } else {\n+                    map.put(alias, tz);\n+                }\n+            }\n+        }\n+\n+        if (dir != null) {\n+            Map zimap = new TreeMap();\n+            Iterator it = map.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry entry = (Map.Entry)it.next();\n+                String id = (String)entry.getKey();\n+                DateTimeZone tz = (DateTimeZone)entry.getValue();\n+                zimap.put(id, tz.getID());\n+            }\n+\n+            System.out.println(\"Writing ZoneInfoMap\");\n+            File file = new File(dir, \"ZoneInfoMap\");\n+            if (!file.getParentFile().exists()) {\n+                file.getParentFile().mkdirs();\n+            }\n+            OutputStream out = new FileOutputStream(file);\n+            ObjectOutputStream oout = new ObjectOutputStream(out);\n+            oout.writeObject(zimap);\n+            oout.close();\n+        }\n+\n+        return map;\n+    }\n+\n+    public void parseDataFile(BufferedReader in) throws IOException {\n+        Zone zone = null;\n+        String line;\n+        while ((line = in.readLine()) != null) {\n+            if (line.length() == 0 || line.charAt(0) == '#') {\n+                continue;\n+            }\n+\n+            int index = line.indexOf('#');\n+            if (index >= 0) {\n+                line = line.substring(0, index);\n+            }\n+\n+            //System.out.println(line);\n+\n+            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n+\n+            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n+                if (zone != null) {\n+                    // Zone continuation\n+                    zone.chain(st);\n+                }\n+                continue;\n+            } else {\n+                if (zone != null) {\n+                    iZones.add(zone);\n+                }\n+                zone = null;\n+            }\n+\n+            if (st.hasMoreTokens()) {\n+                String token = st.nextToken();\n+                if (token.equalsIgnoreCase(\"Rule\")) {\n+                    Rule r = new Rule(st);\n+                    RuleSet rs = (RuleSet)iRuleSets.get(r.iName);\n+                    if (rs == null) {\n+                        rs = new RuleSet(r);\n+                        iRuleSets.put(r.iName, rs);\n+                    } else {\n+                        rs.addRule(r);\n+                    }\n+                } else if (token.equalsIgnoreCase(\"Zone\")) {\n+                    zone = new Zone(st);\n+                } else if (token.equalsIgnoreCase(\"Link\")) {\n+                    iLinks.add(st.nextToken());\n+                    iLinks.add(st.nextToken());\n+                } else {\n+                    System.out.println(\"Unknown line: \" + line);\n+                }\n+            }\n+        }\n+\n+        if (zone != null) {\n+            iZones.add(zone);\n+        }\n+    }\n+\n+    private static class DateTimeOfYear {\n+        public final int iMonthOfYear;\n+        public final int iDayOfMonth;\n+        public final int iDayOfWeek;\n+        public final boolean iAdvanceDayOfWeek;\n+        public final int iMillisOfDay;\n+        public final char iZoneChar;\n+\n+        DateTimeOfYear() {\n+            iMonthOfYear = 1;\n+            iDayOfMonth = 1;\n+            iDayOfWeek = 0;\n+            iAdvanceDayOfWeek = false;\n+            iMillisOfDay = 0;\n+            iZoneChar = 'w';\n+        }\n+\n+        DateTimeOfYear(StringTokenizer st) {\n+            int month = 1;\n+            int day = 1;\n+            int dayOfWeek = 0;\n+            int millis = 0;\n+            boolean advance = false;\n+            char zoneChar = 'w';\n+\n+            if (st.hasMoreTokens()) {\n+                month = parseMonth(st.nextToken());\n+\n+                if (st.hasMoreTokens()) {\n+                    String str = st.nextToken();\n+                    if (str.startsWith(\"last\")) {\n+                        day = -1;\n+                        dayOfWeek = parseDayOfWeek(str.substring(4));\n+                        advance = false;\n+                    } else {\n+                        try {\n+                            day = Integer.parseInt(str);\n+                            dayOfWeek = 0;\n+                            advance = false;\n+                        } catch (NumberFormatException e) {\n+                            int index = str.indexOf(\">=\");\n+                            if (index > 0) {\n+                                day = Integer.parseInt(str.substring(index + 2));\n+                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n+                                advance = true;\n+                            } else {\n+                                index = str.indexOf(\"<=\");\n+                                if (index > 0) {\n+                                    day = Integer.parseInt(str.substring(index + 2));\n+                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n+                                    advance = false;\n+                                } else {\n+                                    throw new IllegalArgumentException(str);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if (st.hasMoreTokens()) {\n+                        str = st.nextToken();\n+                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n+                        millis = parseTime(str);\n+                    }\n+                }\n+            }\n+\n+            iMonthOfYear = month;\n+            iDayOfMonth = day;\n+            iDayOfWeek = dayOfWeek;\n+            iAdvanceDayOfWeek = advance;\n+            iMillisOfDay = millis;\n+            iZoneChar = zoneChar;\n+        }\n+\n+        /**\n+         * Adds a recurring savings rule to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameKey,\n+                                 int saveMillis, int fromYear, int toYear)\n+        {\n+            builder.addRecurringSavings(nameKey, saveMillis,\n+                                        fromYear, toYear,\n+                                        iZoneChar,\n+                                        iMonthOfYear,\n+                                        iDayOfMonth,\n+                                        iDayOfWeek,\n+                                        iAdvanceDayOfWeek,\n+                                        iMillisOfDay);\n+        }\n+\n+        /**\n+         * Adds a cutover to the builder.\n+         */\n+        public void addCutover(DateTimeZoneBuilder builder, int year) {\n+            builder.addCutover(year,\n+                               iZoneChar,\n+                               iMonthOfYear,\n+                               iDayOfMonth,\n+                               iDayOfWeek,\n+                               iAdvanceDayOfWeek,\n+                               iMillisOfDay);\n+        }\n+\n+        public String toString() {\n+            return\n+                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n+                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n+                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n+                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n+                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n+                \"ZoneChar: \" + iZoneChar + \"\\n\";\n+        }\n+    }\n+\n+    private static class Rule {\n+        public final String iName;\n+        public final int iFromYear;\n+        public final int iToYear;\n+        public final String iType;\n+        public final DateTimeOfYear iDateTimeOfYear;\n+        public final int iSaveMillis;\n+        public final String iLetterS;\n+\n+        Rule(StringTokenizer st) {\n+            iName = st.nextToken().intern();\n+            iFromYear = parseYear(st.nextToken(), 0);\n+            iToYear = parseYear(st.nextToken(), iFromYear);\n+            if (iToYear < iFromYear) {\n+                throw new IllegalArgumentException();\n+            }\n+            iType = parseOptional(st.nextToken());\n+            iDateTimeOfYear = new DateTimeOfYear(st);\n+            iSaveMillis = parseTime(st.nextToken());\n+            iLetterS = parseOptional(st.nextToken());\n+        }\n+\n+        /**\n+         * Adds a recurring savings rule to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n+            String nameKey = formatName(nameFormat);\n+            iDateTimeOfYear.addRecurring\n+                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n+        }\n+\n+        private String formatName(String nameFormat) {\n+            int index = nameFormat.indexOf('/');\n+            if (index > 0) {\n+                if (iSaveMillis == 0) {\n+                    // Extract standard name.\n+                    return nameFormat.substring(0, index).intern();\n+                } else {\n+                    return nameFormat.substring(index + 1).intern();\n+                }\n+            }\n+            index = nameFormat.indexOf(\"%s\");\n+            if (index < 0) {\n+                return nameFormat;\n+            }\n+            String left = nameFormat.substring(0, index);\n+            String right = nameFormat.substring(index + 2);\n+            String name;\n+            if (iLetterS == null) {\n+                name = left.concat(right);\n+            } else {\n+                name = left + iLetterS + right;\n+            }\n+            return name.intern();\n+        }\n+\n+        public String toString() {\n+            return\n+                \"[Rule]\\n\" + \n+                \"Name: \" + iName + \"\\n\" +\n+                \"FromYear: \" + iFromYear + \"\\n\" +\n+                \"ToYear: \" + iToYear + \"\\n\" +\n+                \"Type: \" + iType + \"\\n\" +\n+                iDateTimeOfYear +\n+                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n+                \"LetterS: \" + iLetterS + \"\\n\";\n+        }\n+    }\n+\n+    private static class RuleSet {\n+        private List iRules;\n+\n+        RuleSet(Rule rule) {\n+            iRules = new ArrayList();\n+            iRules.add(rule);\n+        }\n+\n+        void addRule(Rule rule) {\n+            if (!(rule.iName.equals(((Rule)iRules.get(0)).iName))) {\n+                throw new IllegalArgumentException(\"Rule name mismatch\");\n+            }\n+            iRules.add(rule);\n+        }\n+\n+        /**\n+         * Adds recurring savings rules to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n+            for (int i=0; i<iRules.size(); i++) {\n+                Rule rule = (Rule)iRules.get(i);\n+                rule.addRecurring(builder, nameFormat);\n+            }\n+        }\n+    }\n+\n+    private static class Zone {\n+        public final String iName;\n+        public final int iOffsetMillis;\n+        public final String iRules;\n+        public final String iFormat;\n+        public final int iUntilYear;\n+        public final DateTimeOfYear iUntilDateTimeOfYear;\n+\n+        private Zone iNext;\n+\n+        Zone(StringTokenizer st) {\n+            this(st.nextToken(), st);\n+        }\n+\n+        private Zone(String name, StringTokenizer st) {\n+            iName = name.intern();\n+            iOffsetMillis = parseTime(st.nextToken());\n+            iRules = parseOptional(st.nextToken());\n+            iFormat = st.nextToken().intern();\n+\n+            int year = Integer.MAX_VALUE;\n+            DateTimeOfYear dtOfYear = START_OF_YEAR;\n+\n+            if (st.hasMoreTokens()) {\n+                year = Integer.parseInt(st.nextToken());\n+                if (st.hasMoreTokens()) {\n+                    dtOfYear = new DateTimeOfYear(st);\n+                }\n+            }\n+\n+            iUntilYear = year;\n+            iUntilDateTimeOfYear = dtOfYear;\n+        }\n+\n+        void chain(StringTokenizer st) {\n+            if (iNext != null) {\n+                iNext.chain(st);\n+            } else {\n+                iNext = new Zone(iName, st);\n+            }\n+        }\n+\n+        public DateTimeZone buildDateTimeZone(Map ruleSets) {\n+            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n+            addToBuilder(builder, ruleSets);\n+            return builder.toDateTimeZone(iName);\n+        }\n+\n+        /**\n+         * Adds zone info to the builder.\n+         */\n+        public void addToBuilder(DateTimeZoneBuilder builder, Map ruleSets) {\n+            addToBuilder(this, builder, ruleSets);\n+        }\n+\n+        private static void addToBuilder(Zone zone,\n+                                         DateTimeZoneBuilder builder,\n+                                         Map ruleSets)\n+        {\n+            for (; zone != null; zone = zone.iNext) {\n+                builder.setStandardOffset(zone.iOffsetMillis);\n+\n+                if (zone.iRules == null) {\n+                    builder.setFixedSavings(zone.iFormat, 0);\n+                } else {\n+                    try {\n+                        // Check if iRules actually just refers to a savings.\n+                        int saveMillis = parseTime(zone.iRules);\n+                        builder.setFixedSavings(zone.iFormat, saveMillis);\n+                    }\n+                    catch (Exception e) {\n+                        RuleSet rs = (RuleSet)ruleSets.get(zone.iRules);\n+                        if (rs == null) {\n+                            throw new IllegalArgumentException\n+                                (\"Rules not found: \" + zone.iRules);\n+                        }\n+                        rs.addRecurring(builder, zone.iFormat);\n+                    }\n+                }\n+\n+                if (zone.iUntilYear == Integer.MAX_VALUE) {\n+                    break;\n+                }\n+\n+                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n+            }\n+        }\n+\n+        public String toString() {\n+            String str =\n+                \"[Zone]\\n\" + \n+                \"Name: \" + iName + \"\\n\" +\n+                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n+                \"Rules: \" + iRules + \"\\n\" +\n+                \"Format: \" + iFormat + \"\\n\" +\n+                \"UntilYear: \" + iUntilYear + \"\\n\" +\n+                iUntilDateTimeOfYear;\n+\n+            if (iNext == null) {\n+                return str;\n+            }\n+\n+            return str + \"...\\n\" + iNext.toString();\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.time.tz;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.lang.ref.SoftReference;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * ZoneInfoProvider loads compiled data files as generated by\n+ * {@link ZoneInfoCompiler}.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class ZoneInfoProvider implements Provider {\n+    private static Map loadZoneInfoMap(InputStream in) throws IOException {\n+        ObjectInputStream oin = new ObjectInputStream(in);\n+        Map map;\n+        try {\n+            map = (Map)oin.readObject();\n+        } catch (ClassNotFoundException e) {\n+            throw new IOException(e.toString());\n+        } finally {\n+            try {\n+                oin.close();\n+            } catch (IOException e) {\n+            }\n+        }\n+        map.put(\"UTC\", new SoftReference(DateTimeZone.UTC));\n+        return map;\n+    }\n+\n+    private final File iFileDir;\n+    private final String iResourcePath;\n+    private ClassLoader iLoader;\n+\n+    // Maps ids to strings or SoftReferences to DateTimeZones.\n+    private final Map iZoneInfoMap;\n+\n+    /**\n+     * ZoneInfoProvider searches the given directory for compiled data files.\n+     *\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(File fileDir) throws IOException {\n+        if (fileDir == null) {\n+            throw new IllegalArgumentException(\"No file directory provided\");\n+        }\n+        if (!fileDir.exists()) {\n+            throw new IOException(\"File directory doesn't exist: \" + fileDir);\n+        }\n+        if (!fileDir.isDirectory()) {\n+            throw new IOException(\"File doesn't refer to a directory: \" + fileDir);\n+        }\n+\n+        iFileDir = fileDir;\n+        iResourcePath = null;\n+\n+        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n+    }\n+\n+    /**\n+     * ZoneInfoProvider searches the given ClassLoader resource path for\n+     * compiled data files. Resources are loaded from the ClassLoader that\n+     * loaded this class.\n+     *\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(String resourcePath) throws IOException {\n+        this(resourcePath, null);\n+        iLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * ZoneInfoProvider searches the given ClassLoader resource path for\n+     * compiled data files.\n+     *\n+     * @param loader ClassLoader to load compiled data files from. If null,\n+     * use system ClassLoader.\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(String resourcePath, ClassLoader loader)\n+        throws IOException\n+    {\n+        if (resourcePath == null) {\n+            throw new IllegalArgumentException(\"No resource path provided\");\n+        }\n+        if (!resourcePath.endsWith(\"/\")) {\n+            resourcePath += '/';\n+        }\n+\n+        iFileDir = null;\n+        iResourcePath = resourcePath;\n+        iLoader = loader;\n+\n+        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n+    }\n+\n+    /**\n+     * If an error is thrown while loading zone data, uncaughtException is\n+     * called to log the error and null is returned for this and all future\n+     * requests.\n+     */\n+    public synchronized DateTimeZone getDateTimeZone(String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        Object obj = iZoneInfoMap.get(id);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        if (id.equals(obj)) {\n+            // Load zone data for the first time.\n+            return loadZoneData(id);\n+        }\n+\n+        if (obj instanceof SoftReference) {\n+            DateTimeZone tz = (DateTimeZone)((SoftReference)obj).get();\n+            if (tz != null) {\n+                return tz;\n+            }\n+            // Reference cleared; load data again.\n+            return loadZoneData(id);\n+        }\n+\n+        // If this point is reached, mapping must link to another.\n+        return getDateTimeZone((String)obj);\n+    }\n+\n+    public synchronized Set getAvailableIDs() {\n+        return Collections.unmodifiableSet(iZoneInfoMap.keySet());\n+    }\n+\n+    /**\n+     * Called if an exception is thrown from getDateTimeZone while loading zone\n+     * data.\n+     */\n+    protected void uncaughtException(Exception e) {\n+        Thread t = Thread.currentThread();\n+        t.getThreadGroup().uncaughtException(t, e);\n+    }\n+\n+    private InputStream openResource(String name) throws IOException {\n+        InputStream in;\n+        if (iFileDir != null) {\n+            in = new FileInputStream(new File(iFileDir, name));\n+        } else {\n+            String path = iResourcePath.concat(name);\n+            if (iLoader != null) {\n+                in = iLoader.getResourceAsStream(path);\n+            } else {\n+                in = ClassLoader.getSystemResourceAsStream(path);\n+            }\n+            if (in == null) {\n+                throw new IOException(\"Resource not found: \" + path);\n+            }\n+        }\n+        return in;\n+    }\n+\n+    private DateTimeZone loadZoneData(String id) {\n+        InputStream in = null;\n+        try {\n+            in = openResource(id);\n+            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n+            iZoneInfoMap.put(id, new SoftReference(tz));\n+            return tz;\n+        } catch (IOException e) {\n+            uncaughtException(e);\n+            iZoneInfoMap.remove(id);\n+            return null;\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestAbstractInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+import org.joda.time.AbstractInstant;\n+/**\n+ * This class is a Junit unit test base class for\n+ * Instant implementations.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public abstract class AbstractTestAbstractInstant\n+\textends AbstractTestReadableInstant {\n+\n+    private static Class cls = AbstractInstant.class;\n+\n+\t/**\n+\t * AbstractTestAbstractInstant constructor.\n+\t * A constructor with this signature\n+\t * is required for Junit testing.\n+\t * @param name\n+\t */\n+\tpublic AbstractTestAbstractInstant(String name) {\n+\t\tsuper(name, cls);\n+\t}\n+\t/**\n+\t * AbstractTestAbstractInstant constructor.\n+\t * A constructor with this signature\n+\t * is required for mapping the system inheritance tree to the\n+\t * test class inheritance tree.\n+\t * @param name The human readable name of the class.\n+\t * @param cls A reference to the Class being tested.\n+\t */\n+\tpublic AbstractTestAbstractInstant(String name, Class cls) {\n+\t\tsuper(name, cls);\n+        AbstractTestAbstractInstant.cls = cls;\n+\t}\n+\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tprotected void setUp() /* throws Exception */ {\n+        super.setUp();\n+\t}\n+\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+        super.tearDown();\n+\t}\n+\n+    /**\n+     * Create a AbstractInstant by reflection\n+     */\n+    private AbstractInstant createAI(Class reflectClass, Class[] types, Object[] args) throws Throwable {\n+        return (AbstractInstant) create(reflectClass, types, args);\n+    }\n+\n+\t//\n+\t// Tests of non-CTORs\n+\t//\n+    public void testToDate() throws Throwable {\n+        AbstractInstant ri = createAI(cls, null, null);\n+        Date date = ri.toDate();\n+        assertEquals(ri.getMillis(), date.getTime());\n+    }\n+\n+    public void testToCalendar() throws Throwable {\n+        AbstractInstant ri = createAI(cls, null, null);\n+        Calendar cal = ri.toCalendar(Locale.UK);\n+        assertEquals(ri.getMillis(), cal.getTime().getTime());\n+    }\n+\n+    public void testToCalendarEx() throws Throwable {\n+        try {\n+            AbstractInstant ri = createAI(cls, null, null);\n+            Calendar cal = ri.toCalendar(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testToGregorianCalendar() throws Throwable {\n+        AbstractInstant ri = createAI(cls, null, null);\n+        GregorianCalendar cal = ri.toGregorianCalendar();\n+        assertEquals(ri.getMillis(), cal.getTime().getTime());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test base class for\n+ * DateOnly, TimeOnly, DateTime, and MutableDateTime implementations.\n+ * <p>This class handles testing of CTORs for the named classes.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public abstract class AbstractTestDateTimeCommon\n+       extends AbstractTestAbstractInstant {\n+\n+    // The class to be tested.\n+    private Class cls;\n+    //\n+    private static final DateTimeZone ZONE = DateTimeZone.getInstance(\"+02:00\");\n+\n+    /**\n+     * AbstractTestDateTimeCommon constructor.\n+     * A constructor with this signature\n+     * is required for mapping the system inheritance tree to the\n+     * test class inheritance tree.\n+     * @param name The human readable name of the class.\n+     * @param cls A reference to the Class being tested.\n+     */\n+    public AbstractTestDateTimeCommon(String name, Class cls) {\n+        super(name, cls);\n+        this.cls = cls;\n+    }\n+\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        super.tearDown();\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (Chronology).\n+     */\n+    public void testCurrentTimeChronologyConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis();\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Chronology.class}, \n+            new Object[] {GJChronology.getInstance(ZONE)});\n+        currentMillis = round(currentMillis, ZONE.toTimeZone());\n+        assertTrue(ri.getMillis() - currentMillis < 1000);\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Chronology), null chronology.\n+     */\n+    public void testCurrentTimeChronologyNullConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis();\n+        ReadableInstant ri = create(cls, new Class[] {Chronology.class}, new Object[] {null});\n+        currentMillis = round(currentMillis, DateTimeZone.getDefault().toTimeZone());\n+        assertTrue(ri.getMillis() - currentMillis < 20);\n+        assertEquals(ISOChronology.getInstance(DateTimeZone.getDefault()), ri.getChronology());\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (long, Chronology).\n+     */\n+    public void testMillisChronologyConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis() + 1000;\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Long.TYPE, Chronology.class}, \n+            new Object[] {new Long(currentMillis), GJChronology.getInstance(ZONE)});\n+        currentMillis = round(currentMillis, ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (long, Chronology), null chronology.\n+     */\n+    public void testMillisChronologyNullConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis() + 1000;\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Long.TYPE, Chronology.class}, \n+            new Object[] {new Long(currentMillis), null});\n+        currentMillis = round(currentMillis, DateTimeZone.getDefault().toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(ISOChronology.getInstance(DateTimeZone.getDefault()), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (long, Chronology). Fixed time 1\n+     */\n+    public void testMillisChronologyConstructorTime1() throws Throwable {\n+        long currentMillis = 20L * 24 * 60 * 60 * 1000 + 5L * 60 * 60 * 1000; // 20 days 5hrs\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Long.TYPE, Chronology.class}, \n+            new Object[] {new Long(currentMillis), GJChronology.getInstance(ZONE)});\n+        currentMillis = round(currentMillis, ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (long, Chronology). Fixed time 2\n+     */\n+    public void testMillisChronologyConstructorTime2() throws Throwable {\n+        long currentMillis = 20L * 24 * 60 * 60 * 1000 + 22L * 60 * 60 * 1000; // 20 days 22hrs\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Long.TYPE, Chronology.class}, \n+            new Object[] {new Long(currentMillis), GJChronology.getInstance(ZONE)});\n+        currentMillis = round(currentMillis, ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (ReadableInstant, Chronology).\n+     */\n+    public void testReadableInstantChronologyConstructor() throws Throwable {\n+        ReadableInstant instant = create(Instant.class, null, null);\n+        ReadableInstant ri = create(cls, \n+            new Class[] {ReadableInstant.class, Chronology.class}, \n+            new Object[] {instant, GJChronology.getInstance(ZONE)});\n+        long currentMillis = round(instant.getMillis(), ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (ReadableInstant, Chronology), null Chronology.\n+     */\n+    public void testReadableInstantChronologyNullConstructor() throws Throwable {\n+        ReadableInstant instant = create(Instant.class, null, null);\n+        ReadableInstant ri = create(cls, \n+            new Class[] {ReadableInstant.class, Chronology.class}, \n+            new Object[] {instant, null});\n+        long currentMillis = round(instant.getMillis(), DateTimeZone.getDefault().toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(ISOChronology.getInstance(DateTimeZone.getDefault()), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (ReadableInstant, Chronology), null RI.\n+     */\n+    public void testReadableInstantNullChronologyConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {ReadableInstant.class, Chronology.class}, \n+                new Object[] {null, GJChronology.getInstanceUTC()});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (ReadableInstant, Chronology), null RI, chronology.\n+     */\n+    public void testReadableInstantNullChronologyNullConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {ReadableInstant.class, Chronology.class}, \n+                new Object[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (Date, Chronology).\n+     */\n+    public void testDateChronologyConstructor() throws Throwable {\n+        Date date = new Date();\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Date.class, Chronology.class}, \n+            new Object[] {date, GJChronology.getInstance(ZONE)});\n+        long currentMillis = round(date.getTime(), ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Date, Chronology), null Chronology.\n+     */\n+    public void testDateChronologyNullConstructor() throws Throwable {\n+        Date date = new Date();\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Date.class, Chronology.class}, \n+            new Object[] {date, null});\n+        long currentMillis = round(date.getTime(), DateTimeZone.getDefault().toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(ISOChronology.getInstance(DateTimeZone.getDefault()), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Date, Chronology), null RI.\n+     */\n+    public void testDateNullChronologyConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {Date.class, Chronology.class}, \n+                new Object[] {null, GJChronology.getInstanceUTC()});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Date, Chronology), null RI, chronology.\n+     */\n+    public void testDateNullChronologyNullConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {Date.class, Chronology.class}, \n+                new Object[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (Calendar, Chronology).\n+     */\n+    public void testCalendarChronologyConstructor() throws Throwable {\n+        Calendar calendar = Calendar.getInstance();\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Calendar.class, Chronology.class}, \n+            new Object[] {calendar, GJChronology.getInstance(ZONE)});\n+        long currentMillis = round(calendar.getTime().getTime(), ZONE.toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Calendar, Chronology), null Chronology.\n+     */\n+    public void testCalendarChronologyNullConstructor() throws Throwable {\n+        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+02:00\"));\n+        ReadableInstant ri = create(cls, \n+            new Class[] {Calendar.class, Chronology.class}, \n+            new Object[] {calendar, null});\n+        long currentMillis = round(calendar.getTime().getTime(), DateTimeZone.getInstance(\"+02:00\").toTimeZone());\n+        assertEquals(new Instant(currentMillis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Calendar, Chronology), null RI.\n+     */\n+    public void testCalendarNullChronologyConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {Calendar.class, Chronology.class}, \n+                new Object[] {null, GJChronology.getInstanceUTC()});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Calendar, Chronology), null RI, chronology.\n+     */\n+    public void testCalendarNullChronologyNullConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {Calendar.class, Chronology.class}, \n+                new Object[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Test the CTOR with signature: (String, Chronology).\n+     */\n+    public void testStringChronologyConstructor() throws Throwable {\n+        String str = \"1970-01-01T13:02:03.004Z\";\n+        long millis = 4 + 3*1000 + 2*1000*60 + 13*1000*60*60;\n+        if (isDateOnly()) {\n+            str = \"1970-01-02TZ\";\n+            millis = 1 * 24 * 60 * 60 * 1000;\n+        } else if (isTimeOnly()) {\n+            str = \"T13:02:03.004Z\";\n+        }\n+        ReadableInstant ri = create(cls, \n+            new Class[] {String.class, Chronology.class}, \n+            new Object[] {str, GJChronology.getInstance(ZONE)});\n+        assertEquals(new Instant(millis), new Instant(ri.getMillis()));\n+        assertEquals(GJChronology.getInstance(ZONE), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (String, Chronology), null Chronology.\n+     */\n+    public void testStringChronologyNullConstructor() throws Throwable {\n+        String str = \"1970-01-01T13:02:03.004Z\";\n+        long millis = 4 + 3*1000 + 2*1000*60 + 13*1000*60*60;\n+        if (isDateOnly()) {\n+            str = \"1970-01-02TZ\";\n+            millis = 1 * 24 * 60 * 60 * 1000;\n+        } else if (isTimeOnly()) {\n+            str = \"T13:02:03.004Z\";\n+        }\n+        ReadableInstant ri = create(cls, \n+            new Class[] {String.class, Chronology.class}, \n+            new Object[] {str, null});\n+        assertEquals(new Instant(millis), new Instant(ri.getMillis()));\n+        assertEquals(ISOChronology.getInstance(), ri.getChronology());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (String, Chronology), null RI.\n+     */\n+    public void testStringNullChronologyConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {String.class, Chronology.class}, \n+                new Object[] {null, GJChronology.getInstanceUTC()});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (String, Chronology), null RI, chronology.\n+     */\n+    public void testStringNullChronologyNullConstructor() throws Throwable {\n+        try {\n+            create(cls, \n+                new Class[] {String.class, Chronology.class}, \n+                new Object[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.text.DateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.TestCase;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+/**\n+ * This class is the abstract Junit unit test for the\n+ * DateTimeField date time field subclasses.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestDateTimeField extends TestCase {\n+    \n+    protected static final TimeZone UTC = TimeZone.getTimeZone(\"GMT+00:00\");\n+//    protected static final TimeZone OLD_PARIS = UTC;\n+//    protected static final DateTimeZone PARIS = DateTimeZone.UTC;\n+    protected static final TimeZone OLD_PARIS = TimeZone.getTimeZone(\"Europe/Paris\");\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    protected static final long MILLIS_1970;\n+    protected static final long MILLIS_1972_MARCH;\n+    protected static final long MILLIS_2000;\n+    protected static final long MILLIS_2000_MARCH;\n+    protected static final long MILLIS_1600;\n+    protected static final long MILLIS_1600_MARCH;\n+    protected static final long MILLIS_1583;\n+    protected static final long MILLIS_1582_OCTOBER;// = -12219292800000L;\n+    protected static final long MILLIS_1582;\n+    protected static final long MILLIS_1;\n+    protected static final long MILLIS_100;\n+    protected static final long MILLIS_100_MARCH;\n+    protected static final long MILLIS_400;\n+    protected static final long MILLIS_400_MARCH;\n+    protected static long[] RESULT;\n+    \n+    protected GregorianCalendar iCalendar = new GregorianCalendar(OLD_PARIS);\n+    protected Date iDate = new Date();\n+    \n+    static {\n+        GregorianCalendar cal = new GregorianCalendar(OLD_PARIS);\n+        cal.setTime(new Date(0L));\n+        cal.set(Calendar.HOUR_OF_DAY, 0);\n+        cal.set(Calendar.DAY_OF_MONTH, 1);\n+        cal.set(Calendar.YEAR, 1970);\n+        MILLIS_1970 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 2000);\n+        MILLIS_2000 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 1600);\n+        MILLIS_1600 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 100);\n+        MILLIS_100 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 400);\n+        MILLIS_400 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 1583);\n+        MILLIS_1583 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 1582);\n+        MILLIS_1582 = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 1);\n+        MILLIS_1 = cal.getTime().getTime();\n+        \n+        cal.set(Calendar.YEAR, 1972);\n+        cal.set(Calendar.MONTH, Calendar.MARCH);\n+        cal.set(Calendar.DAY_OF_MONTH, 1);\n+        MILLIS_1972_MARCH = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 2000);\n+        MILLIS_2000_MARCH = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 1600);\n+        MILLIS_1600_MARCH = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 100);\n+        MILLIS_100_MARCH = cal.getTime().getTime();\n+        cal.set(Calendar.YEAR, 400);\n+        MILLIS_400_MARCH = cal.getTime().getTime();\n+        \n+//        System.out.println(new GJDateTime(MILLIS_1 + 4 * 366L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 4 * 366L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 3 * 366L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 3 * 366L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 2 * 366L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 2 * 366L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 1 * 366L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 + 1 * 366L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 1 * 360L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 1 * 360L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 2 * 360L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 2 * 360L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 3 * 360L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 3 * 360L * 24 * 60 * 60 * 1000).getYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 4 * 360L * 24 * 60 * 60 * 1000).getLeapYear());\n+//        System.out.println(new GJDateTime(MILLIS_1 - 4 * 360L * 24 * 60 * 60 * 1000).getYear());\n+        \n+        cal.set(Calendar.YEAR, 1582);\n+        cal.set(Calendar.MONTH, Calendar.OCTOBER);\n+        cal.set(Calendar.DAY_OF_MONTH, 15);\n+//        System.out.println(new GJDateTime(cal).getMonthOfYear());\n+//        System.out.println(new GJDateTime(cal).getDayOfMonth());\n+//        System.out.println(new GJDateTime(cal).getHourOfDay());\n+//        System.out.println(\"1 \"+cal);\n+//        System.out.println(new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 2);\n+//        System.out.println(cal);\n+//        System.out.println(\"2 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 3);\n+//        System.out.println(cal);\n+//        System.out.println(\"3 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 4);\n+//        System.out.println(cal);\n+//        System.out.println(\"4 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 5);\n+//        System.out.println(cal);\n+//        System.out.println(\"5 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 6);\n+//        System.out.println(cal);\n+//        System.out.println(\"6 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 9);\n+//        System.out.println(cal);\n+//        System.out.println(\"9 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 12);\n+//        System.out.println(cal);\n+//        System.out.println(\"12 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 14);\n+//        System.out.println(cal);\n+//        System.out.println(\"14 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 15);\n+//        System.out.println(cal);\n+//        System.out.println(\"15 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 16);\n+//        System.out.println(cal);\n+//        System.out.println(\"16 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 30);\n+//        System.out.println(cal);\n+//        System.out.println(\"30 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 31);\n+//        System.out.println(cal);\n+//        System.out.println(\"31 \"+new Instant(cal));\n+//        cal.set(Calendar.DAY_OF_MONTH, 1);\n+//        cal.set(Calendar.MONTH, Calendar.NOVEMBER);\n+//        System.out.println(cal);\n+//        System.out.println(\"1 \"+new Instant(cal));\n+        MILLIS_1582_OCTOBER = cal.getTime().getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * TestDateTimeField constructor.\n+     * @param name\n+     */\n+    public AbstractTestDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    // subclass calculations\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to return the field name.\n+     */\n+    protected abstract String getFieldName();\n+    /**\n+     * Override to return the unit size in millis\n+     */\n+    protected abstract long getUnitSize();\n+    /**\n+     * Override to return the field.\n+     */\n+    protected abstract DateTimeField getField();\n+    protected abstract int getMinimumValue();\n+    protected abstract int getMaximumValue();\n+    protected abstract int getCalendarValue(long millis);\n+    protected String getText(int value, Locale loc) {\n+        return Integer.toString(value);\n+    }\n+    protected String getShortText(int value, Locale loc) {\n+        return Integer.toString(value);\n+    }\n+    protected int getMaximumTextLength(Locale loc) {\n+        int max = getMaximumValue();\n+        return Integer.toString(max).length();\n+    }\n+    protected int getMaximumShortTextLength(Locale loc) {\n+        int max = getMaximumValue();\n+        return Integer.toString(max).length();\n+    }\n+    protected long getAddedResult(long millis, int add) {\n+        return millis + add * getUnitSize();\n+    }\n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int val = getCalendarValue(millis);\n+        int max = getMaximumValue();\n+        int min = getMinimumValue();\n+        int add = val + addWrapped;\n+        while (add > max || add < min) {\n+            if (addWrapped >= 0) {\n+                add = add - (max - min) - 1;\n+            } else {\n+                add = add + (max - min) + 1;\n+            }\n+        }\n+        return millis + ((add - val) * getUnitSize());\n+    }\n+    \n+    // building of the multiple test point approach\n+    //-----------------------------------------------------------------------\n+    protected long getIncrementSize() {\n+        return 1 * 60 * 60 * 1000;  // 1 hour\n+    }\n+    protected long getTestRange() {\n+        return 2 * 24 * 60 * 60 * 1000;  // 2 days\n+    }\n+    \n+    protected long[] getTestPositions() {\n+        return new long[] {\n+            MILLIS_1970, MILLIS_1972_MARCH,\n+            MILLIS_2000, MILLIS_2000_MARCH,\n+            MILLIS_1600, MILLIS_1600_MARCH,\n+            MILLIS_1583, MILLIS_1582_OCTOBER,\n+            MILLIS_400, MILLIS_400_MARCH,\n+            MILLIS_100, MILLIS_100_MARCH,\n+            MILLIS_1582, MILLIS_1\n+        };\n+    }\n+    protected long[] getAllTestPositions() {\n+        if (RESULT == null) {\n+            long[] var = getTestPositions();\n+            RESULT = new long[7 * var.length * (2 * ((int) (getTestRange() / getIncrementSize())))];\n+            int count = 0;\n+            for (int i = 0; i < var.length; i++) {\n+                long start = var[i] - getTestRange();\n+                long end = var[i] + getTestRange();\n+//                System.out.println(\"START \" + new Date(start));\n+//                System.out.println(\"END   \" + new Date(end));\n+                for (long j = start; j < end ; j = j + getIncrementSize()) {\n+                    RESULT[count++] = j - 60000; // -1min\n+                    RESULT[count++] = j - 1000; // -1sec\n+                    RESULT[count++] = j - 1; // -1ms\n+                    RESULT[count++] = j;\n+                    RESULT[count++] = j + 1; // +1ms\n+                    RESULT[count++] = j + 1000; // +1sec\n+                    RESULT[count++] = j + 60000; // +1min\n+                }\n+            }\n+        }\n+        return RESULT;\n+    }\n+\n+    protected DateTimeZone getZone() {\n+        return PARIS;\n+    }\n+    \n+    // test helpers for debugging\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Special version of assert that debugs.\n+     */        \n+    private void assertEquals(long[] var, int i, int expected, int actual) {\n+        try {\n+            assertEquals(expected, actual);\n+        } catch (AssertionFailedError ex) {\n+            System.out.println(\n+                \"\\n Test:            \" + getName() + \" for \" + getFieldName() +\n+                \"\\n loop count:      \" + i +\n+                \"\\n milliseconds:    \" + var[i] +\n+                \"\\n converted value: \" + getCalendarValue(var[i]) +\n+                \"\\n test expects:    \" + expected +\n+                \"\\n joda returned:   \" + actual +\n+                \"\\n time via Instant:\" + new Instant(var[i]) +\n+                \"\\n time via Date   :\" + new Date(var[i]) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.FRANCE).format(new Date(var[i])) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.UK).format(new Date(var[i]))\n+            );\n+            throw ex;\n+        }\n+    }\n+\n+    /**\n+     * Special version of assert that debugs.\n+     */        \n+    private void assertEquals(long[] var, int i, long expected, long actual) {\n+        try {\n+            assertEquals(expected, actual);\n+        } catch (AssertionFailedError ex) {\n+            System.out.println(\n+                \"\\n Test:            \" + getName() + \" for \" + getFieldName() +\n+                \"\\n loop count:      \" + i +\n+                \"\\n milliseconds:    \" + var[i] +\n+                \"\\n converted value: \" + getCalendarValue(var[i]) +\n+                \"\\n test expects:    \" + expected +\n+                \"\\n joda returned:   \" + actual +\n+                \"\\n test via Instant:\" + new Instant(expected) +\n+                \"\\n test via Date:   \" + new Date(expected) +\n+                \"\\n joda via Instant:\" + new Instant(actual) +\n+                \"\\n joda via Date:   \" + new Date(actual) +\n+                \"\\n time via Instant:\" + new Instant(var[i]) +\n+                \"\\n time via Date   :\" + new Date(var[i]) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.FRANCE).format(new Date(var[i])) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.UK).format(new Date(var[i]))\n+            );\n+            throw ex;\n+        }\n+    }\n+\n+    /**\n+     * Special version of assert that debugs.\n+     */        \n+    private void assertEquals(long[] var, int i, String expected, String actual) {\n+        try {\n+            assertEquals(expected, actual);\n+        } catch (AssertionFailedError ex) {\n+            System.out.println(\n+                \"\\n Test:            \" + getName() + \" for \" + getFieldName() +\n+                \"\\n loop count:      \" + i +\n+                \"\\n milliseconds:    \" + var[i] +\n+                \"\\n converted value: \" + getCalendarValue(var[i]) +\n+                \"\\n test expects:    \" + expected +\n+                \"\\n joda returned:   \" + actual +\n+                \"\\n time via Instant:\" + new Instant(var[i]) +\n+                \"\\n time via Date   :\" + new Date(var[i]) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.FRANCE).format(new Date(var[i])) +\n+                \"\\n time via Date   :\" + DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.UK).format(new Date(var[i]))\n+            );\n+            throw ex;\n+        }\n+    }\n+\n+    // the tests\n+    //-----------------------------------------------------------------------\n+    public void testGetName() {\n+        assertEquals(getFieldName(), getField().getName());\n+    }\n+    \n+    public void testGet() throws Exception {\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, getCalendarValue(var[i]), getField().get(var[i]));\n+        }\n+    }\n+\n+    public void testGetEx() throws Exception {\n+//        try {\n+//            getField().get(Long.MIN_VALUE);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+//        try {\n+//            getField().get(Long.MAX_VALUE);\n+//            fail();\n+//        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testSet() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        int min = getMinimumValue();\n+        int max = getMaximumValue();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, min, getCalendarValue(field.set(var[i], min)));\n+        }\n+        if (min != max) {\n+            for (int i = 0; i < var.length; i++) {\n+                assertEquals(var, i, min + 1, getCalendarValue(field.set(var[i], min + 1)));\n+            }\n+        }\n+    }\n+    \n+    public void testSetEx() throws Exception {\n+        try {\n+            getField().set(0L, getMaximumValue() + 1);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            getField().set(0L, getMinimumValue() - 1);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testAdd() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            long millis = var[i];\n+            assertEquals(var, i, getAddedResult(millis, 1), field.add(millis, 1));\n+            assertEquals(var, i, getAddedResult(millis, -1), field.add(millis, -1));\n+            assertEquals(var, i, getAddedResult(millis, 0), field.add(millis, 0));\n+            assertEquals(var, i, getAddedResult(millis, 2), field.add(millis, 2));\n+            assertEquals(var, i, getAddedResult(millis, 8), field.add(millis, 8));\n+            assertEquals(var, i, getAddedResult(millis, 9), field.add(millis, 9));\n+            assertEquals(var, i, getAddedResult(millis, -13), field.add(millis, -13));\n+        }\n+    }\n+    \n+    public void testAddWrapped() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            long millis = var[i];\n+            assertEquals(var, i, getAddWrappedResult(millis, 1), field.addWrapped(millis, 1));\n+            assertEquals(var, i, getAddWrappedResult(millis, -1), field.addWrapped(millis, -1));\n+            assertEquals(var, i, getAddWrappedResult(millis, 0), field.addWrapped(millis, 0));\n+            assertEquals(var, i, getAddWrappedResult(millis, 2), field.addWrapped(millis, 2));\n+            assertEquals(var, i, getAddWrappedResult(millis, 8), field.addWrapped(millis, 8));\n+            assertEquals(var, i, getAddWrappedResult(millis, 9), field.addWrapped(millis, 9));\n+            assertEquals(var, i, getAddWrappedResult(millis, -13), field.addWrapped(millis, -13));\n+        }\n+    }\n+\n+    public void testGetDifference() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            long millis = var[i];\n+            long sum = field.add(millis, 1);\n+            assertEquals(var, i, 1, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, -1);\n+            assertEquals(var, i, -1, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, 0);\n+            assertEquals(var, i, 0, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, 2);\n+            assertEquals(var, i, 2, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, 8);\n+            assertEquals(var, i, 8, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, 9);\n+            assertEquals(var, i, 9, (int)field.getDifference(sum, millis));\n+            sum = field.add(millis, -13);\n+            assertEquals(var, i, -13, (int)field.getDifference(sum, millis));\n+        }\n+    }\n+\n+    public void testGetAsTextLocale() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, getText(field.get(var[i]), Locale.FRENCH), field.getAsText(var[i], Locale.FRENCH));\n+        }\n+    }\n+\n+    public void testGetAsText() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, getText(field.get(var[i]), Locale.getDefault()), field.getAsText(var[i]));\n+        }\n+    }\n+\n+    public void testGetAsShortTextLocale() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, getShortText(field.get(var[i]), Locale.FRENCH), field.getAsShortText(var[i], Locale.FRENCH));\n+        }\n+    }\n+\n+    public void testGetAsShortText() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, getShortText(field.get(var[i]), Locale.getDefault()), field.getAsShortText(var[i]));\n+        }\n+    }\n+\n+    public void testSetTextLocale() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        int min = getMinimumValue();\n+        int max = getMaximumValue();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, min, getCalendarValue(field.set(var[i], getText(min, Locale.FRENCH), Locale.FRENCH)));\n+        }\n+        if (min != max) {\n+            for (int i = 0; i < var.length; i++) {\n+                assertEquals(var, i, min + 1, getCalendarValue(field.set(var[i], getText(min + 1, Locale.FRENCH), Locale.FRENCH)));\n+            }\n+        }\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, min, getCalendarValue(field.set(var[i], getShortText(min, Locale.FRENCH), Locale.FRENCH)));\n+        }\n+        if (min != max) {\n+            for (int i = 0; i < var.length; i++) {\n+                assertEquals(var, i, min + 1, getCalendarValue(field.set(var[i], getShortText(min + 1, Locale.FRENCH), Locale.FRENCH)));\n+            }\n+        }\n+    }\n+\n+    public void testSetText() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        int min = getMinimumValue();\n+        int max = getMaximumValue();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, min, getCalendarValue(field.set(var[i], getText(min, Locale.getDefault()))));\n+        }\n+        if (min != max) {\n+            for (int i = 0; i < var.length; i++) {\n+                assertEquals(var, i, min + 1, getCalendarValue(field.set(var[i], getText(min + 1, Locale.getDefault()))));\n+            }\n+        }\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(var, i, min, getCalendarValue(field.set(var[i], getShortText(min, Locale.getDefault()))));\n+        }\n+        if (min != max) {\n+            for (int i = 0; i < var.length; i++) {\n+                assertEquals(var, i, min + 1, getCalendarValue(field.set(var[i], getShortText(min + 1, Locale.getDefault()))));\n+            }\n+        }\n+    }\n+\n+    public void testIsLeapYear() throws Exception {\n+        assertEquals(false, getField().isLeap(0L));\n+    }\n+    \n+    public void testGetLeapAmount() throws Exception {\n+        assertEquals(0, getField().getLeapAmount(0L));\n+    }\n+    \n+    public void testGetMinimumValue() throws Exception {\n+        assertEquals(getMinimumValue(), getField().getMinimumValue());\n+    }\n+\n+    public void testGetMinimumValueMillis() throws Exception {\n+    }\n+\n+    public void testGetMaximumValue() throws Exception {\n+        assertEquals(getMaximumValue(), getField().getMaximumValue());\n+    }\n+    \n+    public void testGetMaximumValueMillis() throws Exception {\n+    }\n+    \n+    public void testGetMaximumTextLength() throws Exception {\n+        DateTimeField field = getField();\n+        assertEquals(getMaximumTextLength(Locale.FRENCH), field.getMaximumTextLength(Locale.FRENCH));\n+    }\n+\n+    public void testGetMaximumShortTextLength(Locale loc) throws Exception {\n+        DateTimeField field = getField();\n+        assertEquals(getMaximumShortTextLength(Locale.FRENCH), field.getMaximumShortTextLength(Locale.FRENCH));\n+    }\n+\n+    public void testRoundFloor() throws Exception {\n+    }\n+\n+    public void testRoundCeiling() throws Exception {\n+    }\n+\n+    public void testRoundHalfFloor() throws Exception {\n+    }\n+\n+    public void testRoundHalfCeiling() throws Exception {\n+    }\n+\n+    public void testRoundHalfEven() throws Exception {\n+    }\n+\n+    public void testRemainder() throws Exception {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test base class for\n+ * ReadableInstant implementations.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public abstract class AbstractTestReadableInstant extends TestCase {\n+\n+    private SimpleDateFormat dateTimeFormat;\n+    private final Class cls;\n+    private final Class otherClass;\n+    \n+    private TimeZone storeTimeZone = null;\n+\n+    /**\n+     * Constructor.\n+     * @param name\n+     */\n+    public AbstractTestReadableInstant(String name, Class cls) {\n+        super(name);\n+        this.cls = cls;\n+        if (cls == Instant.class) {\n+            otherClass = DateTime.class;\n+        } else {\n+            otherClass = Instant.class;\n+        }\n+    }\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        dateTimeFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.sss'Z'\");\n+        storeTimeZone = TimeZone.getDefault();\n+        // this way we don't hide time zone problems during UK winter\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT+04:00\"));\n+    }\n+\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        dateTimeFormat = null;\n+        TimeZone.setDefault(storeTimeZone);\n+    }\n+\n+    /**\n+     * Create a ReadableInstant by reflection\n+     */\n+    protected ReadableInstant create(Class reflectClass, Class[] types, Object[] args) throws Throwable {\n+        try {\n+            Constructor con = reflectClass.getConstructor(types);\n+            return (ReadableInstant) con.newInstance(args);\n+\n+        } catch (InvocationTargetException ex) {\n+            throw ex.getTargetException();\n+        } catch (NoSuchMethodException ex) {\n+            if (types == null || types.length == 0) {\n+                types = new Class[] {Chronology.class};\n+                args = new Object[] {ISOChronology.getInstance(DateTimeZone.getDefault())};\n+            }\n+            if (types.length == 1 && types[0] == Long.TYPE) {\n+                types = new Class[] {Long.TYPE, Chronology.class};\n+                args = new Object[] {args[0], ISOChronology.getInstance(DateTimeZone.getDefault())};\n+            }\n+            try {\n+                Constructor con = reflectClass.getConstructor(types);\n+                return (ReadableInstant) con.newInstance(args);\n+    \n+            } catch (InvocationTargetException ex2) {\n+                throw ex2.getTargetException();\n+            }\n+        }\n+    }\n+    \n+    protected abstract ReadableInstant createSmall(boolean ofAnotherClass);\n+    protected abstract ReadableInstant createMid(boolean ofAnotherClass);\n+    protected abstract ReadableInstant createLarge(boolean ofAnotherClass);\n+    protected abstract ReadableInstant createUTC(long millis);\n+    \n+    protected boolean isDateOnly() {\n+        return false;\n+    }\n+\n+    protected boolean isTimeOnly() {\n+        return false;\n+    }\n+\n+    /**\n+     * Round the millis\n+     * @param currentMillis\n+     * @return long\n+     */\n+    protected long round(long currentMillis, TimeZone zone) {\n+        if (zone == null) {\n+            zone = TimeZone.getDefault();\n+        }\n+        if (isDateOnly()) {\n+            GregorianCalendar cal = new GregorianCalendar(zone);\n+            cal.setTime(new Date(currentMillis));\n+            cal.set(GregorianCalendar.AM_PM, GregorianCalendar.AM);\n+            cal.set(GregorianCalendar.HOUR, 0);\n+            cal.set(GregorianCalendar.HOUR_OF_DAY, 0);\n+            cal.set(GregorianCalendar.MINUTE, 0);\n+            cal.set(GregorianCalendar.SECOND, 0);\n+            cal.set(GregorianCalendar.MILLISECOND, 0);\n+            return cal.getTime().getTime();\n+        } else if (isTimeOnly()) {\n+            GregorianCalendar cal = new GregorianCalendar(zone);\n+            cal.setTime(new Date(currentMillis));\n+            cal.set(GregorianCalendar.YEAR, 1970);\n+            cal.set(GregorianCalendar.MONTH, 0);\n+            cal.set(GregorianCalendar.DAY_OF_MONTH, 1);\n+            return cal.getTime().getTime();\n+        }\n+        return currentMillis;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test getMillis\n+     */\n+    public void testGetMillis() throws Throwable {\n+        ReadableInstant ri1 = createUTC(0);\n+        assertEquals(0, ri1.getMillis());\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test getChronology\n+     */\n+    public void testGetChronology() throws Throwable {\n+        ReadableInstant ri1 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(-300)});\n+        assertNotNull(ri1.getChronology());\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test get\n+     */\n+    public void testGetField() throws Throwable {\n+        ReadableInstant ri1 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(1000)});\n+        if (isDateOnly()) {\n+            assertEquals(0, ri1.get(ISOChronology.getInstance(DateTimeZone.getDefault()).secondOfMinute()));\n+        } else {\n+            assertEquals(1, ri1.get(ISOChronology.getInstance(DateTimeZone.getDefault()).secondOfMinute()));\n+        }\n+        assertEquals(0, ri1.get(ISOChronology.getInstance(DateTimeZone.getDefault()).minuteOfHour()));\n+    }\n+\n+    /**\n+     * Test get\n+     */\n+    public void testGetFieldEx() throws Throwable {\n+        ReadableInstant ri1 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(1000)});\n+        try {\n+            ri1.get(null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+        \n+    /**\n+     * Test equals\n+     */\n+    public void testEquals() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = createLarge(false);\n+        assertTrue(ri1.equals(ri1) == true);\n+        assertTrue(ri1.equals(ri2) == false);\n+        assertTrue(ri1.equals(ri3) == false);\n+        \n+        assertTrue(ri2.equals(ri1) == false);\n+        assertTrue(ri2.equals(ri2) == true);\n+        assertTrue(ri2.equals(ri3) == false);\n+        \n+        assertTrue(ri3.equals(ri1) == false);\n+        assertTrue(ri3.equals(ri2) == false);\n+        assertTrue(ri3.equals(ri3) == true);\n+        \n+        ReadableInstant ri4 = createSmall(true);\n+        assertTrue(ri2.equals(ri4) == false);\n+        ri4 = createMid(true);\n+        assertTrue(ri2.equals(ri4) == false);  // different chronology\n+        ri4 = createLarge(true);\n+        assertTrue(ri2.equals(ri4) == false);\n+\n+        assertTrue(ri2.equals(null) == false);\n+        assertTrue(ri2.equals(new Integer(8)) == false);\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+        \n+    /**\n+     * Test hashCode\n+     */\n+    public void testHashCode() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(200000000L)});\n+        assertEquals(ri1.hashCode(), ri1.hashCode());\n+        ReadableInstant ri4 = createSmall(false);\n+        assertEquals(ri1.hashCode(), ri4.hashCode());\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+        \n+    /**\n+     * Test compareTo\n+     */\n+    public void testCompareTo() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = createLarge(false);\n+        assertTrue(ri1.compareTo(ri1) == 0);\n+        assertTrue(ri1.compareTo(ri2) < 0);\n+        assertTrue(ri1.compareTo(ri3) < 0);\n+        \n+        assertTrue(ri2.compareTo(ri1) > 0);\n+        assertTrue(ri2.compareTo(ri2) == 0);\n+        assertTrue(ri2.compareTo(ri3) < 0);\n+        \n+        assertTrue(ri3.compareTo(ri1) > 0);\n+        assertTrue(ri3.compareTo(ri2) > 0);\n+        assertTrue(ri3.compareTo(ri3) == 0);\n+        \n+        ReadableInstant ri4 = createSmall(true);\n+        assertTrue(ri2.compareTo(ri4) > 0);\n+        ri4 = createMid(true);\n+        assertTrue(ri2.compareTo(ri4) == 0);\n+        ri4 = createLarge(true);\n+        assertTrue(ri2.compareTo(ri4) < 0);\n+    }\n+    \n+    /**\n+     * Test compareTo\n+     */\n+    public void testCompareToEx1() throws Throwable {\n+        ReadableInstant ri = createSmall(false);\n+        try {\n+            ri.compareTo(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Test compareTo\n+     */\n+    public void testCompareToEx2() throws Throwable {\n+        ReadableInstant ri = createSmall(false);\n+        try {\n+            ri.compareTo(new Integer(2));\n+        } catch (ClassCastException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+        \n+    /**\n+     * Test IsAfter\n+     */\n+    public void testIsAfter() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = createLarge(false);\n+        assertTrue(ri1.isAfter(ri1) == false);\n+        assertTrue(ri1.isAfter(ri2) == false);\n+        assertTrue(ri1.isAfter(ri3) == false);\n+        \n+        assertTrue(ri2.isAfter(ri1) == true);\n+        assertTrue(ri2.isAfter(ri2) == false);\n+        assertTrue(ri2.isAfter(ri3) == false);\n+\n+        assertTrue(ri3.isAfter(ri1) == true);\n+        assertTrue(ri3.isAfter(ri2) == true);\n+        assertTrue(ri3.isAfter(ri3) == false);\n+\n+        ReadableInstant ri4 = createSmall(true);\n+        assertTrue(ri2.isAfter(ri4) == true);\n+        ri4 = createMid(true);\n+        assertTrue(ri2.isAfter(ri4) == false);\n+        ri4 = createLarge(true);\n+        assertTrue(ri2.isAfter(ri4) == false);\n+    }\n+\n+    /**\n+     * Test IsAfter\n+     */\n+    public void testIsAfterEx() throws Throwable {\n+        ReadableInstant ri = createSmall(false);\n+        try {\n+            ri.isAfter(null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test IsBefore\n+     */\n+    public void testIsBefore() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = createLarge(false);\n+        assertTrue(ri1.isBefore(ri1) == false);\n+        assertTrue(ri1.isBefore(ri2) == true);\n+        assertTrue(ri1.isBefore(ri3) == true);\n+\n+        assertTrue(ri2.isBefore(ri1) == false);\n+        assertTrue(ri2.isBefore(ri2) == false);\n+        assertTrue(ri2.isBefore(ri3) == true);\n+\n+        assertTrue(ri3.isBefore(ri1) == false);\n+        assertTrue(ri3.isBefore(ri2) == false);\n+        assertTrue(ri3.isBefore(ri3) == false);\n+\n+        ReadableInstant ri4 = createSmall(true);\n+        assertTrue(ri2.isBefore(ri4)  == false);\n+        ri4 = createMid(true);\n+        assertTrue(ri2.isBefore(ri4) == false);\n+        ri4 = createLarge(true);\n+        assertTrue(ri2.isBefore(ri4) == true);\n+    }\n+\n+    /**\n+     * Test IsBefore\n+     */\n+    public void testIsBeforeEx() throws Throwable {\n+        ReadableInstant ri = createSmall(false);\n+        try {\n+            ri.isBefore(null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test isEqual\n+     */\n+    public void testIsEqual() throws Throwable {\n+        ReadableInstant ri1 = createSmall(false);\n+        ReadableInstant ri2 = createMid(false);\n+        ReadableInstant ri3 = createLarge(false);\n+        assertTrue(ri1.isEqual(ri1) == true);\n+        assertTrue(ri1.isEqual(ri2) == false);\n+        assertTrue(ri1.isEqual(ri3) == false);\n+\n+        assertTrue(ri2.isEqual(ri1) == false);\n+        assertTrue(ri2.isEqual(ri2) == true);\n+        assertTrue(ri2.isEqual(ri3) == false);\n+\n+        assertTrue(ri3.isEqual(ri1) == false);\n+        assertTrue(ri3.isEqual(ri2) == false);\n+        assertTrue(ri3.isEqual(ri3) == true);\n+\n+        ReadableInstant ri4 = createSmall(true);\n+        assertTrue(ri2.isEqual(ri4) == false);\n+        ri4 = createMid(true);\n+        assertTrue(ri2.isEqual(ri4) == true);\n+        ri4 = createLarge(true);\n+        assertTrue(ri2.isEqual(ri4) == false);\n+    }\n+\n+    /**\n+     * Test isEqual\n+     */\n+    public void testIsEqualEx() throws Throwable {\n+        ReadableInstant ri = createSmall(false);\n+        try {\n+            ri.isEqual(null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test toInstant\n+     */\n+    public void testToInstant() throws Throwable {\n+        ReadableInstant ri = create(cls, null, null);\n+        Instant instant = ri.toInstant();\n+        assertEquals(instant.getMillis(), ri.getMillis());\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ * This currently forces tests using GMT only.\n+ *\n+ * @author Guy Allard\n+ */\n+public class BulkMDTTests extends BulkTest {\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(BulkMDTTests.class);\n+    }\n+    /**\n+     * BulkMDTTests constructor.\n+     * @param name\n+     */\n+    public BulkMDTTests(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.MutableDateTime\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+    //\n+    private PrintStream ewtr = System.err;\n+    public void testDummy() {\n+        ewtr.println(\"Dummy Test Completes\");\n+        ewtr.flush();\n+    }\n+\n+    public BulkTest bulkTestGet() {\n+        return new TestMDTGet(\"Mutable Date Time get Method Tests\");\n+    }\n+\n+    public BulkTest bulkTestSet() {\n+        return new TestMDTSet(\"Mutable Date Time set Method Tests\");\n+    }\n+\n+    public BulkTest bulkTestAdd() {\n+        return new TestMDTAdd(\"Mutable Date Time add Method Tests\");\n+    }\n+\n+    public BulkTest bulkTestAddWrapped() {\n+        return new TestMDTAddWrapped(\"Mutable Date Time addWrapped Method Tests\");\n+    }\n+\n+} // end of class BulkMDTTests\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time ;\n+//\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.text.ParseException;\n+import org.joda.time.* ;\n+import org.joda.time.chrono.iso.* ;\n+/**\n+ *  A {@link TestCase} that can define both simple and bulk test methods.<P>\n+ *\n+ *  A <I>simple test method</I> is the type of test traditionally\n+ *  supplied by by {@link TestCase}.  To define a simple test, create a public\n+ *  no-argument method whose name starts with \"test\".  You can specify the\n+ *  the name of simple test in the constructor of <Code>BulkTest</Code>;\n+ *  a subsequent call to {@link TestCase#run} will run that simple test.<P>\n+ *\n+ *  A <I>bulk test method</I>, on the other hand, returns a new instance\n+ *  of <Code>BulkTest</Code>, which can itself define new simple and bulk\n+ *  test methods.  By using the {@link #makeSuite} method, you can\n+ *  automatically create a hierarchal suite of tests and child bulk tests.<P>\n+ *\n+ *  For instance, consider the following two classes:\n+ *\n+ *  <Pre>\n+ *  public class TestSet extends BulkTest {\n+ *\n+ *      private Set set;\n+ *\n+ *      public TestSet(Set set) {\n+ *          this.set = set;\n+ *      }\n+ *\n+ *      public void testContains() {\n+ *          boolean r = set.contains(set.iterator().next()));\n+ *          assertTrue(\"Set should contain first element, r);\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          set.clear();\n+ *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n+ *      }\n+ *  }\n+ *\n+ *\n+ *  public class TestHashMap extends BulkTest {\n+ *\n+ *      private Map makeFullMap() {\n+ *          HashMap result = new HashMap();\n+ *          result.put(\"1\", \"One\");\n+ *          result.put(\"2\", \"Two\");\n+ *          return result;\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          Map map = makeFullMap();\n+ *          map.clear();\n+ *          assertTrue(\"Map empty after clear\", map.isEmpty());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestKeySet() {\n+ *          return new TestSet(makeFullMap().keySet());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestEntrySet() {\n+ *          return new TestSet(makeFullMap().entrySet());\n+ *      }\n+ *  }\n+ *  </Pre>\n+ *\n+ *  In the above examples, <Code>TestSet</Code> defines two\n+ *  simple test methods and no bulk test methods; <Code>TestHashMap</Code>\n+ *  defines one simple test method and two bulk test methods.  When\n+ *  <Code>makeSuite(TestHashMap.class).run</Code> is executed,\n+ *  <I>five</I> simple test methods will be run, in this order:<P>\n+ *\n+ *  <Ol>\n+ *  <Li>TestHashMap.testClear()\n+ *  <Li>TestHashMap.bulkTestKeySet().testContains();\n+ *  <Li>TestHashMap.bulkTestKeySet().testClear();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  </Ol>\n+ *\n+ *  In the graphical junit test runners, the tests would be displayed in\n+ *  the following tree:<P>\n+ *\n+ *  <UL>\n+ *  <LI>TestHashMap</LI>\n+ *      <UL>\n+ *      <LI>testClear\n+ *      <LI>bulkTestKeySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      <LI>bulkTestEntrySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      </UL>\n+ *  </UL>\n+ *\n+ *  A subclass can override a superclass's bulk test by\n+ *  returning <Code>null</Code> from the bulk test method.  If you only\n+ *  want to override specific simple tests within a bulk test, use the\n+ *  {@link #ignoredSimpleTests} method.<P>\n+ *\n+ *  Note that if you want to use the bulk test methods, you <I>must</I>\n+ *  define your <Code>suite()</Code> method to use {@link #makeSuite}.\n+ *  The ordinary {@link TestSuite} constructor doesn't know how to\n+ *  interpret bulk test methods.\n+ *\n+ *  Original implementation modified slightly for use with Joda ISO Time\n+ *  testing.\n+ *\n+ *  @author Paul Jack\n+ *  @author Guy Allard\n+ *\n+ */\n+public class BulkTest extends TestCase implements Cloneable {\n+\n+\n+    // Note:  BulkTest is Cloneable to make it easier to construct\n+    // BulkTest instances for simple test methods that are defined in\n+    // anonymous inner classes.  Basically we don't have to worry about\n+    // finding wierd constructors.  (And even if we found them, techinically\n+    // it'd be illegal for anyone but the outer class to invoke them).\n+    // Given one BulkTest instance, we can just clone it and reset the\n+    // method name for every simple test it defines.\n+\n+\n+    /**\n+     *  The full name of this bulk test instance.  This is the full name\n+     *  that is compared to {@link #ignoredSimpleTests} to see if this\n+     *  test should be ignored.  It's also displayed in the text runner\n+     *  to ease debugging.\n+     */\n+    String verboseName;\n+\n+\n+    /**\n+     *  Constructs a new <Code>BulkTest</Code> instance that will run the\n+     *  specified simple test.\n+     *\n+     *  @param name  the name of the simple test method to run\n+     */\n+    public BulkTest(String name) {\n+        super(name);\n+        this.verboseName = getClass().getName();\n+    }\n+\n+\n+    /**\n+     *  Creates a clone of this <Code>BulkTest</Code>.<P>\n+     *\n+     *  @return  a clone of this <Code>BulkTest</Code>\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new Error(); // should never happen\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns an array of simple test names to ignore.<P>\n+     *\n+     *  If a simple test that's defined by this <Code>BulkTest</Code> or\n+     *  by one of its bulk test methods has a name that's in the returned\n+     *  array, then that simple test will not be executed.<P>\n+     *\n+     *  A simple test's name is formed by taking the class name of the\n+     *  root <Code>BulkTest</Code>, eliminating the package name, then\n+     *  appending the names of any bulk test methods that were invoked\n+     *  to get to the simple test, and then appending the simple test\n+     *  method name.  The method names are delimited by periods:\n+     *\n+     *  <Pre>\n+     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  </Pre>\n+     *\n+     *  is the name of one of the simple tests defined in the sample classes\n+     *  described above.  If the sample <Code>TestHashMap</Code> class\n+     *  included this method:\n+     *\n+     *  <Pre>\n+     *  public String[] ignoredSimpleTests() {\n+     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *  }\n+     *  </Pre>\n+     *\n+     *  then the entry set's clear method wouldn't be tested, but the key\n+     *  set's clear method would.\n+     *\n+     *  @return an array of the names of simple tests to ignore, or null if\n+     *   no tests should be ignored\n+     */\n+    public String[] ignoredSimpleTests() {\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Returns the display name of this <Code>BulkTest</Code>.\n+     *\n+     *  @return the display name of this <Code>BulkTest</Code>\n+     */\n+    public String toString() {\n+        return getName() + \"(\" + verboseName + \") \";\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link TestSuite} for testing all of the simple tests\n+     *  <I>and</I> all the bulk tests defined by the given class.<P>\n+     *\n+     *  The class is examined for simple and bulk test methods; any child\n+     *  bulk tests are also examined recursively; and the results are stored\n+     *  in a hierarchal {@link TestSuite}.<P>\n+     *\n+     *  The given class must be a subclass of <Code>BulkTest</Code> and must\n+     *  not be abstract.<P>\n+     *\n+     *  @param c  the class to examine for simple and bulk tests\n+     *  @return  a {@link TestSuite} containing all the simple and bulk tests\n+     *    defined by that class\n+     */\n+    public static TestSuite makeSuite(Class c) {\n+        if (Modifier.isAbstract(c.getModifiers())) {\n+            throw new IllegalArgumentException(\"Class must not be abstract.\");\n+        }\n+        if (!BulkTest.class.isAssignableFrom(c)) {\n+            throw new IllegalArgumentException(\"Class must extend BulkTest.\");\n+        }\n+        return new BulkTestSuiteMaker(c).make();\n+    }\n+    //\n+    // Methods added by the Joda project for testing of the\n+    // org.joda.time package and it's subpackages.\n+    //\n+    /**\n+     * Build an ISODateTime string from a Gregorian calendar.\n+     * @param gc a Gregorian Calendar instance.\n+     * @return a String suitable for ISODateTime instantiation.\n+     */\n+    protected String getDateTimeString(GregorianCalendar gc) {\n+        int year = gc.get(Calendar.YEAR);\n+        StringBuffer retVal = new StringBuffer();\n+        if ( gc.get(Calendar.ERA) == GregorianCalendar.BC ) {\n+            if ( year > 1 ) retVal.append(\"-\");\n+            year = year - 1;\n+        }\n+        //\n+        retVal.append( padNumberToLen( Math.abs(year), 4 ) );\n+        retVal.append(\"-\");\n+        retVal.append( padNumberToLen(gc.get(Calendar.MONTH)+1, 2) );\n+        retVal.append(\"-\");\n+        retVal.append( padNumberToLen(gc.get(Calendar.DATE), 2) );\n+        retVal.append(\"T\");\n+        retVal.append(  padNumberToLen(gc.get(Calendar.HOUR), 2) );\n+        retVal.append(\":\");\n+        retVal.append( padNumberToLen(gc.get(Calendar.MINUTE), 2) );\n+        retVal.append(\":\");\n+        retVal.append( padNumberToLen(gc.get(Calendar.SECOND), 2) );\n+        retVal.append(\".\");\n+        retVal.append( padNumberToLen(gc.get(Calendar.MILLISECOND), 3) );\n+        retVal.append(\"Z\");\n+        return retVal.toString();\n+    }\n+    /**\n+     * Create a string from an integer, pad it on the left with\n+     * '0's to the length specified.\n+     * @param num The number to use.\n+     * @param len The length to pad to.\n+     * @return The created string.\n+     */\n+    protected String padNumberToLen(int num, int len) {\n+        StringBuffer retVal = new StringBuffer( len );\n+        retVal.insert(0, \"\" + num);\n+        if ( retVal.length() >= len ) return retVal.toString();\n+        retVal.insert(0, copiesOf(\"0\", len - retVal.length()));\n+        if (num < 0) {\n+            retVal.insert(0,\"-\");\n+        }\n+        return retVal.toString();\n+    }\n+    /**\n+     * Generate the specified number of copies of a String and\n+     * return it.\n+     * @param s The String to copy.\n+     * @param c The number of copies.\n+     * @return The generated String.\n+     */\n+    protected String copiesOf(String s, int c) {\n+        if ( c == 0 ) return s;\n+        StringBuffer retBuff = new StringBuffer( s.length() * c );\n+        for (int i = 1; i <= c; ++i) {\n+            retBuff.insert( retBuff.length(), s );\n+        }\n+        return retBuff.toString();\n+    }\n+    /**\n+     * Convert a String to an Integer, and return the int\n+     * value.\n+     * @param s The string to convert.\n+     * @return The int to return.\n+     * @throws A NullPointerException if the string fails conversion.\n+     */\n+    protected int getPartValue(String s) {\n+        Integer iVal = null;\n+        try\n+        {\n+            iVal = new Integer( s );\n+        }\n+        catch(NumberFormatException nfe)\n+        {\n+        }\n+        return iVal.intValue();\n+    }\n+    /**\n+     *\n+     * @param s An ISO format Date/Time string.\n+     * @return The left hand side of the string.\n+     */\n+    protected String lhsDT(String s) {\n+        return s.substring(0,s.indexOf('T'));\n+    }\n+    /**\n+     *\n+     * @param s An ISO format Date/Time string.\n+     * @return The right hand side of the string.\n+     */\n+    protected String rhsDT(String s) {\n+        return s.substring(s.indexOf('T')+1);\n+    }\n+    /**\n+     *\n+     * @param s An ISO format Date/Time string.\n+     * @return An array list containing all the subelements\n+     * of the input string.\n+     */\n+    protected ArrayList getDTA(String s) {\n+        ArrayList al = new ArrayList();\n+        String dateSide = lhsDT( s );\n+        String timeSide = rhsDT( s );\n+        // Date Side\n+        if ( dateSide.substring(0,1).equals(\"-\") )\n+        {\n+            al.add(\"-\");\n+            dateSide = dateSide.substring(1);\n+        }\n+        else\n+        {\n+            al.add(\"\");\n+        }\n+        int pos = dateSide.indexOf('-');\n+        al.add( dateSide.substring(0, pos) );\n+        al.add(\"-\");\n+        pos += 1;\n+        dateSide = dateSide.substring( pos );\n+        //\n+        pos = dateSide.indexOf('-');\n+        al.add( dateSide.substring(0, pos) );\n+        al.add(\"-\");\n+        al.add( dateSide.substring( ++pos ) );\n+        al.add(\"T\");\n+        //\n+        // Time Side\n+        //\n+        pos = timeSide.indexOf(':');\n+        al.add( timeSide.substring(0, pos) );\n+        al.add(\":\");\n+        pos += 1;\n+        timeSide = timeSide.substring( pos );\n+        //\n+        pos = timeSide.indexOf(':');\n+        al.add( timeSide.substring(0, pos) );\n+        al.add(\":\");\n+        pos += 1;\n+        timeSide = timeSide.substring( pos );\n+        //\n+        pos = timeSide.indexOf('.');\n+        if ( pos == -1 ) {\n+            al.add( timeSide );\n+            return al;\n+        }\n+        al.add( timeSide.substring(0,pos) );\n+        al.add(\".\");\n+        pos += 1;\n+        timeSide = timeSide.substring(pos);\n+        pos = timeSide.indexOf('Z');\n+        al.add( timeSide.substring(0,pos) );\n+        al.add(\"Z\");\n+        //\n+        return al;\n+    }\n+\n+    /**\n+     * An array of the short names of the days of the week.\n+     */\n+    protected final String[] dowShort = {\n+        \"N/A\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"\n+    };\n+    /**\n+     * An array of the long names of the days of the week.\n+     */\n+    protected final String[] dowLong = {\n+        \"N/A\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"\n+    };\n+    /**\n+     * An array of the short names of the month.\n+     */\n+    protected final String[] moyShort = {\n+        \"N/A\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n+            \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"\n+    };\n+    /**\n+     * An array of the long names of the month.\n+     */\n+    protected final String[] moyLong = {\n+        \"N/A\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\n+            \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"\n+    };\n+\n+    /**\n+     *\n+     * @param s An ISO format Date/Time string.\n+     * @return A Joda MutableDateTime object, or null if\n+     * parsing fails.\n+     */\n+    MutableDateTime getMDTFromString(String s) {\n+        MutableDateTime retVal = null;\n+        try\n+        {\n+            retVal = new MutableDateTime( s,\n+                ISOChronology.getInstanceUTC() );\n+        }\n+        catch(ParseException pe)\n+        {\n+            System.err.println(\"ParseException Detected\");\n+            pe.printStackTrace();\n+        }\n+        return retVal;\n+    }\n+\n+} // End of BulkTest class\n+\n+\n+// It was easier to use a separate class to do all the reflection stuff\n+// for making the TestSuite instances.  Having permanent state around makes\n+// it easier to handle the recursion.\n+class BulkTestSuiteMaker {\n+\n+\n+    /** The class that defines simple and bulk tests methods. */\n+    private Class startingClass;\n+\n+\n+    /** List of ignored simple test names. */\n+    private List ignored;\n+\n+\n+    /** The TestSuite we're currently populating.  Can change over time. */\n+    private TestSuite result;\n+\n+\n+    /**\n+     *  The prefix for simple test methods.  Used to check if a test is in\n+     *  the ignored list.\n+     */\n+    private String prefix;\n+\n+\n+    /**\n+     *  Constructor.\n+     *\n+     *  @param startingClass  the starting class\n+     */\n+    public BulkTestSuiteMaker(Class startingClass) {\n+        this.startingClass = startingClass;\n+    }\n+\n+\n+    /**\n+     *  Makes a hierarchal TestSuite based on the starting class.\n+     *\n+     *  @return  the hierarchal TestSuite for startingClass\n+     */\n+    public TestSuite make() {\n+         this.result = new TestSuite();\n+         this.prefix = getBaseName(startingClass);\n+         result.setName(prefix);\n+\n+         BulkTest bulk = makeFirstTestCase(startingClass);\n+         ignored = new ArrayList();\n+         String[] s = bulk.ignoredSimpleTests();\n+         if (s != null) {\n+             ignored.addAll(Arrays.asList(s));\n+         }\n+         make(bulk);\n+         return result;\n+    }\n+\n+\n+    /**\n+     *  Appends all the simple tests and bulk tests defined by the given\n+     *  instance's class to the current TestSuite.\n+     *\n+     *  @param bulk  An instance of the class that defines simple and bulk\n+     *    tests for us to append\n+     */\n+    void make(BulkTest bulk) {\n+        Class c = bulk.getClass();\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) addTest(bulk, all[i]);\n+            if (isBulk(all[i])) addBulk(bulk, all[i]);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *   (I know it's wierd.  But the point is, we can clone the instance\n+     *   and not have to worry about constructors.)\n+     *  @param m  The simple test method\n+     */\n+    void addTest(BulkTest bulk, Method m) {\n+        BulkTest bulk2 = (BulkTest)bulk.clone();\n+        bulk2.setName(m.getName());\n+        bulk2.verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(bulk2.verboseName)) return;\n+        result.addTest(bulk2);\n+    }\n+\n+\n+    /**\n+     *  Adds a whole new suite of tests that are defined by the result of\n+     *  the given bulk test method.  In other words, the given bulk test\n+     *  method is invoked, and the resulting BulkTest instance is examined\n+     *  for yet more simple and bulk tests.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *  @param m  The bulk test method\n+     */\n+    void addBulk(BulkTest bulk, Method m) {\n+        BulkTest bulk2;\n+        try {\n+            bulk2 = (BulkTest)m.invoke(bulk, null);\n+            if (bulk2 == null) return;\n+        } catch (InvocationTargetException e) {\n+            throw new Error(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // FIXME;\n+        }\n+\n+        // Save current state on the stack.\n+        String oldPrefix = prefix;\n+        TestSuite oldResult = result;\n+\n+        prefix = prefix + \".\" + m.getName();\n+        result = new TestSuite();\n+        result.setName(m.getName());\n+\n+        make(bulk2);\n+\n+        oldResult.addTest(result);\n+\n+        // Restore the old state\n+        prefix = oldPrefix;\n+        result = oldResult;\n+    }\n+\n+\n+    /**\n+     *  Returns the base name of the given class.\n+     *\n+     *  @param c  the class\n+     *  @return the name of that class, minus any package names\n+     */\n+    private static String getBaseName(Class c) {\n+        String name = c.getName();\n+        int p = name.lastIndexOf('.');\n+        if (p > 0) {\n+            name = name.substring(p + 1);\n+        }\n+        return name;\n+    }\n+\n+\n+    // These three methods are used to create a valid BulkTest instance\n+    // from a class.\n+\n+    private static Constructor getTestCaseConstructor(Class c) {\n+        try {\n+            return c.getConstructor(new Class[] { String.class });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(c + \" must provide \" +\n+             \"a (String) constructor\");\n+        }\n+    }\n+\n+\n+    private static BulkTest makeTestCase(Class c, Method m) {\n+        Constructor con = getTestCaseConstructor(c);\n+        try {\n+            return (BulkTest)con.newInstance(new String[] { m.getName() });\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // should never occur\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(); // FIXME;\n+        }\n+    }\n+\n+\n+    private static BulkTest makeFirstTestCase(Class c) {\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) return makeTestCase(c, all[i]);\n+        }\n+        throw new IllegalArgumentException(c.getName() + \" must provide \"\n+          + \" at least one test method.\");\n+    }\n+\n+\n+    /**\n+     *  Returns true if the given method is a simple test method.\n+     */\n+    private static boolean isTest(Method m) {\n+        if (!m.getName().startsWith(\"test\")) return false;\n+        if (m.getReturnType() != Void.TYPE) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+\n+    /**\n+     *  Returns true if the given method is a bulk test method.\n+     */\n+    private static boolean isBulk(Method m) {\n+        if (!m.getName().startsWith(\"bulkTest\")) return false;\n+        if (m.getReturnType() != BulkTest.class) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+} // end of BulkTestSuiteMaker class\n+\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.GregorianCalendar;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.buddhist.BuddhistChronology;\n+\n+import junit.framework.TestSuite;\n+/**\n+ * This class is a Junit unit test for the\n+ * BuddhistChronology date time class.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestBuddhistChronology extends BulkTest {\n+    // TODO: These are not TimeZone safe\n+    private static final long SMALL_MILLIS = new GregorianCalendar(-20000, 0, 1).getTime().getTime();\n+    private static final long LARGE_MILLIS = new GregorianCalendar(20000, 0, 1).getTime().getTime();\n+    private static final long MILLIS_1971 = new GregorianCalendar(1971, 0, 1).getTime().getTime();\n+    private static final long MILLIS_1970 = new GregorianCalendar(1970, 0, 1).getTime().getTime();\n+    private static final long MILLIS_1969 = new GregorianCalendar(1969, 0, 1).getTime().getTime();\n+    \n+    private BuddhistChronology iChrono = null;\n+\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestBuddhistChronology.class);\n+    }\n+    /**\n+     * TestDateTimeField constructor.\n+     * @param name\n+     */\n+    public TestBuddhistChronology(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        iChrono = BuddhistChronology.getInstanceUTC();\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void testEraConstant() throws Exception {\n+        assertEquals(DateTimeConstants.CE, BuddhistChronology.BE);\n+    }\n+    public void testGetInstanceUTC() throws Exception {\n+        assertNotNull(BuddhistChronology.getInstanceUTC());\n+        assertTrue(BuddhistChronology.getInstanceUTC() instanceof BuddhistChronology);\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());\n+    }\n+    public void testGetInstanceNull() throws Exception {\n+        DateTimeZone zone = DateTimeZone.getDefault();\n+        assertNotNull(BuddhistChronology.getInstance());\n+        assertTrue(BuddhistChronology.getInstance() instanceof BuddhistChronology);\n+        assertSame(zone, BuddhistChronology.getInstance().getDateTimeZone());\n+    }\n+    public void testGetInstanceZone() throws Exception {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"+01:00\");\n+        assertNotNull(BuddhistChronology.getInstance(zone));\n+        assertTrue(BuddhistChronology.getInstance(zone) instanceof BuddhistChronology);\n+        assertSame(zone, BuddhistChronology.getInstance(zone).getDateTimeZone());\n+    }\n+    public void testGetInstanceZoneUTC() throws Exception {\n+        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(DateTimeZone.UTC));\n+    }\n+    \n+    public void testMillisOfSecond() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testMillisOfDay() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testSecondOfMinute() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testSecondOfDay() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testMinuteOfHour() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testMinuteOfDay() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testHourOfDay() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testClockhourOfDay() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testHourOfHalfday() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testClockhourOfHalfday() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testAmPm() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testDayOfWeek() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testDayOfMonth() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testDayOfYear() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testWeekOfYearWeek() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testMonthOfYear() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    public void testLeapYear() {\n+        // TODO: Its the same as GJChronology, so checking it isn't that important\n+    }\n+    \n+    public void testWeekOfYearYear() {\n+        fail(\"TBD\");\n+    }\n+    public void testYear() {\n+        assertEquals(\"year\", iChrono.year().getName());\n+        assertSame(iChrono.year(), iChrono.year());\n+        \n+        assertEquals(1970 + 543, iChrono.year().get(MILLIS_1970));\n+        assertEquals(20000 + 543, iChrono.year().get(LARGE_MILLIS));\n+        \n+        assertEquals(MILLIS_1970, iChrono.year().set(LARGE_MILLIS, 1970 + 543));\n+        \n+        assertEquals(MILLIS_1971, iChrono.year().add(MILLIS_1970, 1));\n+        assertEquals(MILLIS_1969, iChrono.year().add(MILLIS_1970, -1));\n+        \n+        assertEquals(MILLIS_1971, iChrono.year().addWrapped(MILLIS_1970, 1));\n+        assertEquals(MILLIS_1969, iChrono.year().addWrapped(MILLIS_1970, -1));\n+        \n+        assertEquals(\"2513\", iChrono.year().getAsShortText(MILLIS_1970));\n+        assertEquals(9, iChrono.year().getMaximumShortTextLength(null));\n+        assertEquals(\"2513\", iChrono.year().getAsText(MILLIS_1970));\n+        assertEquals(9, iChrono.year().getMaximumTextLength(null));\n+        \n+        assertEquals(1, iChrono.year().getMinimumValue());\n+        assertEquals(250000000 + 543, iChrono.year().getMaximumValue());\n+        \n+        assertEquals(MILLIS_1970, iChrono.year().set(MILLIS_1970, \"2513\"));\n+        assertEquals(MILLIS_1971, iChrono.year().set(MILLIS_1970, \"2514\"));\n+        assertEquals(LARGE_MILLIS, iChrono.year().set(MILLIS_1970, \"20543\"));\n+        try {\n+            iChrono.year().set(MILLIS_1970, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            iChrono.year().set(MILLIS_1970, \"AD\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    public void testYearOfCentury() {\n+        try {\n+            iChrono.yearOfCentury();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+    public void testCenturyOfEra() {\n+        try {\n+            iChrono.centuryOfEra();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+    public void testEra() {\n+        assertEquals(\"era\", iChrono.era().getName());\n+        assertSame(iChrono.era(), iChrono.era());\n+        \n+        assertEquals(BuddhistChronology.BE, iChrono.era().get(SMALL_MILLIS));\n+        assertEquals(BuddhistChronology.BE, iChrono.era().get(MILLIS_1970));\n+        assertEquals(BuddhistChronology.BE, iChrono.era().get(LARGE_MILLIS));\n+        \n+        assertEquals(SMALL_MILLIS, iChrono.era().set(SMALL_MILLIS, BuddhistChronology.BE));\n+        try {\n+            iChrono.era().set(SMALL_MILLIS, DateTimeConstants.BCE);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            iChrono.era().add(SMALL_MILLIS, 1);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        \n+        try {\n+            iChrono.era().addWrapped(SMALL_MILLIS, 1);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        \n+        assertEquals(\"BE\", iChrono.era().getAsShortText(MILLIS_1970));\n+        assertEquals(2, iChrono.era().getMaximumShortTextLength(null));\n+        assertEquals(\"BE\", iChrono.era().getAsText(MILLIS_1970));\n+        assertEquals(2, iChrono.era().getMaximumTextLength(null));\n+        \n+        assertEquals(BuddhistChronology.BE, iChrono.era().getMinimumValue());\n+        assertEquals(BuddhistChronology.BE, iChrono.era().getMaximumValue());\n+        \n+        assertEquals(MILLIS_1970, iChrono.era().set(MILLIS_1970, \"BE\"));\n+        try {\n+            iChrono.era().set(SMALL_MILLIS, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            iChrono.era().set(SMALL_MILLIS, \"AD\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestConstructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+//\n+import java.text.ParseException;\n+import java.io.PrintStream;\n+//\n+import junit.framework.TestSuite;\n+//\n+import org.joda.time.DateTime;\n+//import org.joda.time.DateOnly;\n+//import org.joda.time.TimeOnly;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.DateTimeFieldProperty;\n+//\n+/**\n+ * This class is a Junit unit test for the\n+ * constructors of various ISODateTime, ISODateOnly, and\n+ * ISOTimeOnly objects.\n+ *\n+ * @author Guy Allard\n+ *\n+ */\n+public class TestConstructors extends BulkTest {\n+\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite suite() is a junit required method.\n+     * @see org.joda.test.time.BulkTest\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestConstructors.class);\n+    }\n+    /**\n+     * TestConstructors constructor.\n+     * @param name\n+     */\n+    public TestConstructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    /**\n+     * Test the <code>ISODateOnly</code> constructors.\n+     * @see org.joda.time.iso.ISODateOnly\n+     */\n+    public void testDateOnlyConstructors() {\n+        dateOnly = true;\n+        //\n+        // Tests for Spec Section 5.2.1\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.1.1\", dates5211 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.1.2\", dates5212 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.1.3\", dates5213 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.1.4\", dates5214 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.2.1\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.2.1\", dates5221 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.2.2\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.2.2\", dates5222 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.2.3\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.2.3\", dates5223 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.3.1\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.3.1\", dates5231 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.3.2\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.3.2\", dates5232 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.3.3\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.3.3\", dates5233 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.2.3.4\n+        //\n+        new SectionRunner( new SpecSection( \"5.2.3.4\", dates5234 ),\n+            \"\", \"\" ).run();\n+        //\n+        wtr.println(\"Running Totals:\");\n+        tt.showResults();\n+    }\n+    /**\n+     * Test the <code>ISOTimeOnly</code> constructors.\n+     * @see org.joda.time.iso.ISOTimeOnly\n+     */\n+    public void testTimeOnlyConstructors() {\n+        dateOnly = false;\n+        //\n+        // Tests for Spec Section 5.3.1 - No Leading 'T', no 'Z' suffix\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.1\", times5311 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.2\", times5312 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.3\", times5313 ),\n+            \"\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.4\", times5314 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.3.1 - Leading 'T', no 'Z' suffix\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.1\", times5311 ),\n+            \"T\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.2\", times5312 ),\n+            \"T\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.3\", times5313 ),\n+            \"T\", \"\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.4\", times5314 ),\n+            \"T\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.3.1 - No leading 'T\", 'Z' suffix\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.1\", times5311 ),\n+            \"\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.2\", times5312 ),\n+            \"\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.3\", times5313 ),\n+            \"\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.4\", times5314 ),\n+            \"\", \"Z\" ).run();\n+        //\n+        // Tests for Spec Section 5.3.1 - Leading 'T\" and 'Z' suffix\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.1\", times5311 ),\n+            \"T\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.2\", times5312 ),\n+            \"T\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.3\", times5313 ),\n+            \"T\", \"Z\" ).run();\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.1.4\", times5314 ),\n+            \"T\", \"Z\" ).run();\n+        //\n+        // Tests for Spec Section 5.3.2\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.2\", times532 ),\n+            \"\", \"\" ).run();\n+        //\n+        // Tests for Spec Section 5.3.4.2\n+        //\n+        new SectionRunner( new SpecSection( \"5.3.4.2\", times5342 ),\n+            \"\", \"\" ).run();\n+        //\n+        wtr.println(\"Running Totals:\");\n+        tt.showResults();\n+    }\n+    /**\n+     * Test the <code>ISODateTime</code> constructors.\n+     * @see org.joda.time.iso.ISODateTime\n+     */\n+    public void testDateTimeConstructors() {\n+        dateTimes = true;\n+        //\n+        // Tests for Spec Section 5.4.1\n+        //\n+        new SectionRunner( new SpecSection( \"5.4.1\", datetimes541 ),\n+            \"\", \"\" ).run();\n+        new SectionRunner( new SpecSection( \"5.4.1\", datetimes541 ),\n+            \"\", \"Z\" ).run();\n+        //\n+        // Tests for Spec Section 5.4.2\n+        //\n+        new SectionRunner( new SpecSection( \"5.4.2\", datetimes542 ),\n+            \"\", \"\" ).run();\n+        //\n+        wtr.println(\"Running Totals:\");\n+        tt.showResults();\n+    }\n+//\n+// ------------------------------------------------------------\n+// Private data and methods\n+// ------------------------------------------------------------\n+//\n+    private final TotalsTracker tt = new TotalsTracker();\n+//\n+    private boolean dateOnly = true;\n+    private boolean dateTimes = false;\n+    protected  PrintStream wtr = System.err;\n+    //\n+    // Spec Section 5.2 - Dates\n+    //\n+    // Spec Section 5.2.1 - Calendar Dates\n+    //\n+    // Spec Section 5.2.1.1 - Complete Representation\n+    //\n+    private final String[][] dates5211 = {\n+            {\"19990101\",\n+                \"Complete~Basic~YYYYMMDD~Spec 5.2.1.1\"},\n+            {\"1999-01-01\",\n+                \"Complete~Extended~YYYY-MM-DD~Spec 5.2.1.1\"},\n+    };\n+    //\n+    // Spec Section 5.2.1.2 - Representations with reduced precision\n+    //\n+    private final String[][] dates5212 = {\n+            // A specific month\n+            {\"1999-01\",\n+                \"Reduced~Basic~YYYY-MM~Spec 5.2.1.2(a)\"},\n+            // A specific year\n+            {\"1999\",\n+                \"Reduced~Basic~YYYY~Spec 5.2.1.2(b)\"},\n+            // A specific century\n+            {\"19\",\n+                \"Reduced~Basic~YY~Spec 5.2.1.2(c)\"},\n+        };\n+    //\n+    // Spec Section 5.2.1.3 - Truncated representations\n+    //\n+    private final String[][] dates5213 = {\n+            // A specific date in the implied century\n+            {\"990101\",\n+                \"Truncated~Basic~YYMMDD~Spec 5.2.1.3(a)\"},\n+            {\"99-01-01\",\n+                \"Truncated~Extended~YY-MM-DD~Spec 5.2.1.3(a)\"},\n+            // A specific year and month in the implied century\n+            {\"-9901\",\n+                \"Truncated~Basic~-YYMM~Spec 5.2.1.3(b)\"},\n+            {\"-99-01\",\n+                \"Truncated~Extended~YYMMDD~Spec 5.2.1.3(b)\"},\n+            // A specific year in the implied century\n+            {\"-99\",\n+                \"Truncated~Basic~-YY~Spec 5.2.1.3(c)\"},\n+            // A specific day of a month in the implied year\n+            {\"--0101\",\n+                \"Truncated~Basic~--MMDD~Spec 5.2.1.3(d)\"},\n+            {\"--01-01\",\n+                \"Truncated~Basic~--MM-DD~Spec 5.2.1.3(d)\"},\n+            // A specific month in the implied year\n+            {\"--01\",\n+                \"Truncated~Basic~--MM~Spec 5.2.1.3(e)\"},\n+            // A specific day in the implied month\n+            {\"---01\",\n+                \"Truncated~Basic~---DD~Spec 5.2.1.3(f)\"},\n+    };\n+    //\n+    // Spec Section 5.2.1.4 - Expanded Representations\n+    //\n+    private final String[][] dates5214 = {\n+            // A specific day\n+            {\"-19990101\",\n+                \"Expanded~Basic~-YYYYMMDD~Spec 5.2.1.4(a)\"},\n+            {\"+19990101\",\n+                \"Expanded~Basic~+YYYYMMDD~Spec 5.2.1.4(a)\"},\n+            {\"-1999-01-01\",\n+                \"Expanded~Extended~-YYYY-MM-DD~Spec 5.2.1.4(a)\"},\n+            {\"+1999-01-01\",\n+                \"Expanded~Extended~+YYYY-MM-DD~Spec 5.2.1.4(a)\"},\n+            // A specific month\n+            {\"-1999-01\",\n+                \"Expanded~Basic~-YYYY-MM~Spec 5.2.1.4(b)\"},\n+            {\"+1999-01\",\n+                \"Expanded~Basic~+YYYY-MM~Spec 5.2.1.4(b)\"},\n+            // A specific year\n+            {\"-1999\",\n+                \"Expanded~Basic~-YYYY~Spec 5.2.1.4(c)\"},\n+            {\"+1999\",\n+                \"Expanded~Basic~+YYYY~Spec 5.2.1.4(c)\"},\n+            // A specific century\n+            {\"-19\",\n+                \"Expanded~Basic~-YY~Spec 5.2.1.4(d)\"},\n+            {\"+19\",\n+                \"Expanded~Basic~+YY~Spec 5.2.1.4(d)\"},\n+    };\n+    //\n+    // Spec Section 5.2.2 - Ordinal Dates\n+    //\n+    // Spec Section 5.2.2.1 - Complete Representation\n+    //\n+    private final String[][] dates5221 = {\n+            {\"1999123\",\n+                \"Complete~Basic~YYYYDDD~Spec 5.2.2.1\"},\n+            {\"1999-123\",\n+                \"Complete~Extended~YYYY-DDD~Spec 5.2.2.1\"},\n+    };\n+    //\n+    // Spec Section 5.2.2.2 - Truncated Representation\n+    //\n+    private final String[][] dates5222 = {\n+            // A specific year and day in the implied century\n+            {\"99123\",\n+                \"Truncated~Basic~YYDDD~Spec 5.2.2.2(a)\"},\n+            {\"99-123\",\n+                \"Truncated~Extended~YY-DDD~Spec 5.2.2.2(a)\"},\n+            // Day only in the implied year\n+            {\"-123\",\n+                \"Truncated~Basic~-DDD~Spec 5.2.2.2(b)\"},\n+    };\n+    //\n+    // Spec Section 5.2.2.3 - Expanded Representation\n+    //\n+    private final String[][] dates5223 = {\n+        // A specific day\n+            {\"-1999123\",\n+                \"Expanded~Basic~-YYYYDDD~Spec 5.2.2.3(a)\"},\n+            {\"-1999-123\",\n+                \"Expanded~Extended~-YYYY-DDD~Spec 5.2.2.3(a)\"},\n+    };\n+    //\n+    // Spec Section 5.2.3 - Week Date\n+    //\n+    // Spec Section 5.2.3.1 - Complete representation\n+    //\n+    private final String[][] dates5231 = {\n+            {\"1999W236\",\n+                \"Complete~Basic~YYYYWwwD~Spec 5.2.3.1\"},\n+            {\"1999-W23-6\",\n+                \"Complete~Extended~YYYY-Www-D~Spec 5.2.3.1\"},\n+    };\n+    //\n+    // Spec Section 5.2.3.2 - Representations with reduced precision\n+    //\n+    private final String[][] dates5232 = {\n+        // A specific week\n+            {\"1999W23\",\n+                \"Reduced~Basic~YYYYWww~Spec 5.2.3.2(a)\"},\n+            {\"1999-W23\",\n+                \"Reduced~Extended~YYYY-Www~Spec 5.2.3.2(a)\"},\n+    };\n+    //\n+    // Spec Section 5.2.3.3 - Truncated representations\n+    //\n+    private final String[][] dates5233 = {\n+        // Year, week, and day in the implied century\n+            {\"99W236\",\n+                \"Truncated~Basic~YYWwwD~Spec 5.2.3.3(a)\"},\n+            {\"99-W23-6\",\n+                \"Truncated~Extended~YYWwwD~Spec 5.2.3.3(a)\"},\n+        // Year and week only in the implied century\n+            {\"99W23\",\n+                \"Truncated~Basic~YYWww~Spec 5.2.3.3(b)\"},\n+            {\"99-W23\",\n+                \"Truncated~Extended~YY-Www~Spec 5.2.3.3(b)\"},\n+        // Year of the implied decade, week and day only\n+            {\"-5W236\",\n+                \"Truncated~Basic~-YWwwD~Spec 5.2.3.3(c)\"},\n+            {\"-5-W23-6\",\n+                \"Truncated~Extended~-Y-Www-D~Spec 5.2.3.3(c)\"},\n+        // Year of the implied decade and week only\n+            {\"-5W23\",\n+                \"Truncated~Basic~-YWww~Spec 5.2.3.3(d)\"},\n+            {\"-5-W23\",\n+                \"Truncated~Extended~-Y-Www~Spec 5.2.3.3(d)\"},\n+        // Week and day only of the implied year\n+            {\"-W236\",\n+                \"Truncated~Basic~-WwwD~Spec 5.2.3.3(e)\"},\n+            {\"-W23-6\",\n+                \"Truncated~Extended~-Www-D~Spec 5.2.3.3(e)\"},\n+        // Week only of the implied year\n+            {\"-W23\",\n+                \"Truncated~Basic~-Www~Spec 5.2.3.3(f)\"},\n+        // Day only of the implied week\n+            {\"-W-6\",\n+                \"Truncated~Basic~-W-D~Spec 5.2.3.3(g)\"},\n+    };\n+    //\n+    // Spec Section 5.2.3.4 - Expanded representations\n+    //\n+    private final String[][] dates5234 = {\n+        // A specific day\n+            {\"-1999W236\",\n+                \"Truncated~Basic~-YYYYWwwd~Spec 5.2.3.4(a)\"},\n+            {\"+1999W236\",\n+                \"Truncated~Basic~+YYYYWwwd~Spec 5.2.3.4(a)\"},\n+            {\"-1999-W23-6\",\n+                \"Truncated~Extended~-YYYY-Www-d~Spec 5.2.3.4(a)\"},\n+            {\"+1999-W23-6\",\n+                \"Truncated~Extended~+YYYY-Www-d~Spec 5.2.3.4(a)\"},\n+        // A specific week\n+            {\"-1999W23\",\n+                \"Truncated~Basic~-YYYYWww~Spec 5.2.3.4(b)\"},\n+            {\"+1999W23\",\n+                \"Truncated~Basic~+YYYYWww~Spec 5.2.3.4(b)\"},\n+            {\"-1999-W23\",\n+                \"Truncated~Extended~-YYYY-Www~Spec 5.2.3.4(b)\"},\n+            {\"+1999-W23\",\n+                \"Truncated~Extended~+YYYY-Www~Spec 5.2.3.4(b)\"},\n+    };\n+    //\n+    // Spec Section 5.3 - Time of day\n+    //\n+    // Spec Section 5.3.1.1 - Complete representation\n+    //\n+    private final String[][] times5311 = {\n+            {\"232050\",\n+                \"Complete~Basic~hhmmss~Spec 5.3.1.1\"},\n+            {\"23:20:50\",\n+                \"Complete~Extended~hh:mm:ss~Spec 5.3.1.1\"},\n+    };\n+    //\n+    // Spec Section 5.3.1.2 - Representations with reduced precision\n+    //\n+    private final String[][] times5312 = {\n+            // A specific hour and minute\n+            {\"2320\",\n+                \"Reduced~Basic~hhmm~Spec 5.3.1.2(a)\"},\n+            {\"23:20\",\n+                \"Reduced~Extended~hh:mm~Spec 5.3.1.2(a)\"},\n+            // A specific hour\n+            {\"23\",\n+                \"Reduced~Basic~hh~Spec 5.3.1.2(b)\"},\n+    };\n+    //\n+    // Spec Section 5.3.1.3 - Representation of decimal fractions\n+    //\n+    private final String[][] times5313 = {\n+            // A specific hour, minute, second, and decimal fraction of\n+            // a second\n+            {\"232050,5\",\n+                \"Decimal~Basic~hhmmss,ss~Spec 5.3.1.3(a)\"},\n+            {\"23:20:50,5\",\n+                \"Decimal~Extended~hh:mm:ss,ss~Spec 5.3.1.3(a)\"},\n+            // A specific hour, minute, and decimal fraction of a minute\n+            {\"2320,8\",\n+                \"Decimal~Basic~hhmm,mm~Spec 5.3.1.3(b)\"},\n+            {\"23:20,8\",\n+                \"Decimal~Extended~hh:mm,mm~Spec 5.3.1.3(b)\"},\n+            // A specific hour and decimal fraction of an hour\n+            {\"23,8\",\n+                \"Decimal~Basic~hh,hh~Spec 5.3.1.3(c)\"},\n+    };\n+    //\n+    // Spec Section 5.3.1.4 - Truncated representations\n+    //\n+    private final String[][] times5314 = {\n+        // A specific minute and second of the implied hour\n+            {\"-2050\",\n+                \"Truncated~Basic~-mmss~Spec 5.3.1.4(a)\"},\n+            {\"-20:50\",\n+                \"Truncated~Extended~-mm:ss~Spec 5.3.1.4(a)\"},\n+        // A specific minute of the implied hour\n+            {\"-20\",\n+                \"Truncated~Basic~-mm~Spec 5.3.1.4(b)\"},\n+        // A specific second of the implied minute\n+            {\"--50\",\n+                \"Truncated~Basic~--ss~Spec 5.3.1.4(c)\"},\n+        // A specific minute and second of the implied hour and\n+        // a decimal fraction of a second\n+            {\"-2050,5\",\n+                \"Truncated~Basic~-mmss,s~Spec 5.3.1.4(d)\"},\n+            {\"-20:50,5\",\n+                \"Truncated~Extended~-mm:ss,s~Spec 5.3.1.4(d)\"},\n+        // A specific minute of the implied hour and a decimal fraction\n+        // of the minute\n+            {\"-20,8\",\n+                \"Truncated~Basic~-mm,m~Spec 5.3.1.4(e)\"},\n+        // A specific second of the implied minute and a decimal fraction\n+        // of the second\n+            {\"--50,5\",\n+                \"Truncated~Basic~--ss,s~Spec 5.3.1.4(f)\"},\n+    };\n+    //\n+    // Spec Section 5.3.2 - Midnight\n+    //\n+    private final String[][] times532 = {\n+            {\"000000\",\n+                \"Midnight~Basic~000000~Spec 5.3.2\"},\n+            {\"00:00:00\",\n+                \"Midnight~Extended~00:00:00~Spec 5.3.2\"},\n+            {\"240000\",\n+                \"Midnight~Basic~240000~Spec 5.3.2\"},\n+            {\"24:00:00\",\n+                \"Midnight~Extended~24:00:00~Spec 5.3.2\"},\n+            {\"0000\",\n+                \"Midnight~Basic~0000~Spec 5.3.2 Note 1\"},\n+            {\"2400\",\n+                \"Midnight~Basic~2400~Spec 5.3.2 Note 1\"},\n+    };\n+    //\n+    // Spec Section 5.3.4.2 - Local time and the difference with UTC\n+    //\n+    private final String[][] times5342 = {\n+            {\"152746+0100\",\n+                \"Difference~Basic~hhmmss(+/-)hhmm~Spec 5.3.4.2\"},\n+            {\"15:27:46+01:00\",\n+                \"Difference~Extended~hh:mm:ss(+/-)hh:mm~Spec 5.3.4.2\"},\n+            {\"152746-0500\",\n+                \"Difference~Basic~hhmmss(+/-)hhmm~Spec 5.3.4.2\"},\n+            {\"15:27:46-05:00\",\n+                \"Difference~Extended~hh:mm:ss(+/-)hh:mm~Spec 5.3.4.2\"},\n+    };\n+    //\n+    // Spec Section 5.4 - Combinations of date and time of day\n+    //\n+    // Spec Section 5.4.1 - Complete representation\n+    //\n+    private final String[][] datetimes541 = {\n+            {\"19990101T112233\",\n+                \"Combination~Basic~YYYYMMDDThhmmss~Spec 5.4.1(a)\"},\n+            {\"1999-01-01T11:22:33\",\n+                \"Combination~Extended~YYYY-MM-DDThh:mm:ss~Spec 5.4.1(a)\"},\n+            {\"1999123T112233\",\n+                \"Combination~Basic~YYYYDDDThhmmss~Spec 5.4.1(b)\"},\n+            {\"1999-123T11:22:33\",\n+                \"Combination~Extended~YYYY-DDDThh:mm:ss~Spec 5.4.1(b)\"},\n+            {\"1999W176T112233\",\n+                \"Combination~Basic~YYYYWwwDThhmmss~Spec 5.4.1(c)\"},\n+            {\"1999-W17-6T11:22:33\",\n+                \"Combination~Extended~YYYY-Www-DThh:mm:ss~Spec 5.4.1(c)\"},\n+    };\n+    //\n+    // Spec Section 5.4.2 - Representations other than complete\n+    //\n+    private final String[][] datetimes542 = {\n+            {\"19990101T1516\",\n+                \"Reduced-Combo~Basic~YYYYMMDDThhmm~Spec 5.4.2(a)\"},\n+            {\"1999-01-01T15:16\",\n+                \"Reduced-Combo~Extended~YYYY-MM-DDThh:mm~Spec 5.4.2(a)\"},\n+            {\"1999123T1516\",\n+                \"Reduced-Combo~Basic~YYYYDDDThhmm~Spec 5.4.2(b)\"},\n+            {\"1999-123T15:16\",\n+                \"Reduced-Combo~Extended~YYYY-DDDThh:mm~Spec 5.4.2(b)\"},\n+            {\"1985W155T1015+0400\",\n+                \"Reduced-Combo~Basic~YYYYWwwDThhmm+hhmm~Spec 5.4.2(b)\"},\n+            {\"1985W155T1015-0400\",\n+                \"Reduced-Combo~Basic~YYYYWwwDThhmm-hhmm~Spec 5.4.2(b)\"},\n+            {\"1985-W15-5T10:15+04:00\",\n+                \"Reduced-Combo~Extended~YYYY-Www-DThh:mm+hh:mm~Spec 5.4.2(b)\"},\n+            {\"1985-W15-5T10:15-04:00\",\n+                \"Reduced-Combo~Extended~YYYY-Www-DThh:mm-hh:mm~Spec 5.4.2(b)\"},\n+    };\n+    //\n+    // A Specification Section\n+    //\n+    private class SpecSection {\n+        private final String name;\n+        private final String[][] testData;\n+        private final int numTests;\n+        private int failedTests = 0;\n+        SpecSection(final String name, final String[][] testData) {\n+            this.name = name;\n+            this.testData = testData;\n+            this.numTests = this.testData.length;\n+        }\n+        public String getName() {\n+            return name;\n+        }\n+        public String[][] getTestData() {\n+            return testData;\n+        }\n+        public int getNumTests() {\n+            return numTests;\n+        }\n+        public int getFailedTests() {\n+            return failedTests;\n+        }\n+        public void bumpFailedTests() {\n+            ++failedTests;\n+        }\n+        public void showResults() {\n+            wtr.println(\"Section Results For: \" + name );\n+            wtr.println(\"\\tSection Number of CTOR tests: \" + numTests );\n+            wtr.println(\"\\tSection Failed CTOR tests: \" + failedTests );\n+        }\n+\n+    }\n+    //\n+    // A Specification Section Test Runner\n+    //\n+    private class SectionRunner {\n+        private final SpecSection ss;\n+        private final String prepend;\n+        private final String append;\n+        private ReadableInstant ri = null;\n+        SectionRunner(final SpecSection ss, final String prepend,\n+                      final String append) {\n+            this.ss = ss;\n+            this.prepend = prepend;\n+            this.append = append;\n+        }\n+        public final void run() {\n+            wtr.println(\" \");\n+            wtr.println(\"-> Start Section: \" + ss.getName());\n+            String[][] testData = ss.getTestData();\n+            String sDT = null;\n+            boolean raised = false;\n+            for(int nextDate = 0; nextDate < testData.length; ++nextDate) {\n+                sDT = prepend + testData[nextDate][0] + append;\n+                wtr.println(\" \");\n+                wtr.println( \"The Next String Is: \" + sDT );\n+                wtr.println( \"The Spec Reference Is: \"\n+                    + testData[nextDate][1] );\n+                tt.bumpNumTests();\n+                try\n+                {\n+                    if ( dateTimes ) {\n+                        ri = new DateTime( sDT );\n+                    }\n+                    /*\n+                    else\n+                    {\n+                        if ( dateOnly ) {\n+                            ri = new DateOnly( sDT );\n+                        }\n+                        else\n+                        {\n+                            ri = new TimeOnly( sDT );\n+                        }\n+                    }\n+                    */\n+                }\n+                catch(ParseException pe)\n+                {\n+                    ss.bumpFailedTests();\n+                    tt.bumpFailedTests();\n+                    wtr.println(\"Parse Exception Detected\");\n+                    pe.printStackTrace( wtr );\n+                    raised = true;\n+                }\n+                if ( !raised ) {\n+                    wtr.print(\"Construction Complete, \");\n+                    wtr.println(\"As String: \" + this.ri);\n+                }\n+                raised = false;\n+            } // end of the for\n+            ss.showResults();\n+            tt.showResults();\n+        } // end of run\n+    }\n+    //\n+    // Running Totals Tracker\n+    //\n+    private class TotalsTracker {\n+        private int numTests = 0;\n+        private int failedTests = 0;\n+        public final int getNumTests() { return numTests; }\n+        public final int getFailedTests() { return failedTests; }\n+        public final void bumpNumTests() { ++numTests; }\n+        public final void bumpFailedTests() { ++failedTests; }\n+        public final void showResults() {\n+            // wtr.println(\" \");\n+            wtr.println(\"\\tCurrent Total of CTOR tests: \" + numTests );\n+            wtr.println(\"\\tCurrent # of Failed CTOR tests: \" + failedTests );\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import junit.framework.TestSuite;\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.DateTimeComparator class.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeComparator extends BulkTest {\n+\n+    /**\n+     * The main method for this test program.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestDateTimeComparator.class);\n+    }\n+    /**\n+     * TestDateTimeComparator constructor.\n+     * @param name\n+     */\n+    public TestDateTimeComparator(String name) {\n+        super(name);\n+    }\n+    /**\n+     * A reference to a DateTime object.\n+     */\n+    DateTime aDateTime = null;\n+    /**\n+     * A reference to a DateTime object.\n+     */\n+    DateTime bDateTime = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for millis of seconds.\n+     */\n+    Comparator cMillis = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for seconds.\n+     */\n+    Comparator cSecond = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for minutes.\n+     */\n+    Comparator cMinute = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for hours.\n+     */\n+    Comparator cHour = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the week.\n+     */\n+    Comparator cDayOfWeek = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the month.\n+     */\n+    Comparator cDayOfMonth = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for day of the year.\n+     */\n+    Comparator cDayOfYear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for week of the weekyear.\n+     */\n+    Comparator cWeekOfWeekyear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for year given a week of the year.\n+     */\n+    Comparator cWeekyear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for months.\n+     */\n+    Comparator cMonth = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for year.\n+     */\n+    Comparator cYear = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for the date portion of an\n+     * object.\n+     */\n+    Comparator cDate = null;\n+    /**\n+     * A reference to a DateTimeComparator object\n+     * (a Comparator) for the time portion of an\n+     * object.\n+     */\n+    Comparator cTime = null;\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    public void setUp() /* throws Exception */ {\n+        Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+        // super.setUp();\n+        // Obtain comparator's\n+        cMillis = DateTimeComparator.getInstance(null, chrono.secondOfMinute());\n+        cSecond = DateTimeComparator.getInstance(chrono.secondOfMinute(), chrono.minuteOfHour());\n+        cMinute = DateTimeComparator.getInstance(chrono.minuteOfHour(), chrono.hourOfDay());\n+        cHour = DateTimeComparator.getInstance(chrono.hourOfDay(), chrono.dayOfYear());\n+        cDayOfWeek = DateTimeComparator.getInstance(chrono.dayOfWeek(), chrono.weekOfWeekyear());\n+        cDayOfMonth = DateTimeComparator.getInstance(chrono.dayOfMonth(), chrono.monthOfYear());\n+        cDayOfYear = DateTimeComparator.getInstance(chrono.dayOfYear(), chrono.year());\n+        cWeekOfWeekyear = DateTimeComparator.getInstance(chrono.weekOfWeekyear(), chrono.weekyear());\n+        cWeekyear = DateTimeComparator.getInstance(chrono.weekyear());\n+        cMonth = DateTimeComparator.getInstance(chrono.monthOfYear(), chrono.year());\n+        cYear = DateTimeComparator.getInstance(chrono.year());\n+        cDate = DateTimeComparator.getDateOnlyInstance(chrono);\n+        cTime = DateTimeComparator.getTimeOnlyInstance(chrono);\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+        aDateTime = null;\n+        bDateTime = null;\n+        //\n+        cMillis = null;\n+        cSecond = null;\n+        cMinute = null;\n+        cHour = null;\n+        cDayOfWeek = null;\n+        cDayOfMonth = null;\n+        cDayOfYear = null;\n+        cWeekOfWeekyear = null;\n+        cWeekyear = null;\n+        cMonth = null;\n+        cYear = null;\n+        cDate = null;\n+        cTime = null;\n+    }\n+\n+    /**\n+     * Test all basic comparator operation with DateTime objects.\n+     */\n+    public void testBasicComps1() {\n+        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n+        assertEquals( \"getMillis\", aDateTime.getMillis(),\n+            bDateTime.getMillis() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+\n+    /**\n+     * Test all basic comparator operation with ReadableInstant objects.\n+     */\n+    public void testBasicComps2() {\n+        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );\n+        assertEquals( \"getMillis\", aDateTime.getMillis(),\n+            bDateTime.getMillis() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with java Date objects.\n+     */\n+    public void testBasicComps3() {\n+        Date aDateTime\n+            = new Date( System.currentTimeMillis() );\n+        Date bDateTime\n+            = new Date( aDateTime.getTime() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with Long objects.\n+     */\n+    public void testBasicComps4() {\n+        Long aDateTime\n+            = new Long( System.currentTimeMillis() );\n+        Long bDateTime\n+            = new Long( aDateTime.longValue() );\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+    /**\n+     * Test all basic comparator operation with Calendar objects.\n+     */\n+    public void testBasicComps5() {\n+        Calendar aDateTime\n+            = Calendar.getInstance();   // right now\n+        Calendar bDateTime = aDateTime;\n+        assertEquals( \"MILLIS\", 0, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SECOND\", 0, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MINUTE\", 0, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HOUR\", 0, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOW\", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOM\", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOY\", 0, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOW\", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WY\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTH\", 0, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEAR\", 0, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DATE\", 0, cDate.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"TIME\", 0, cTime.compare( aDateTime, bDateTime ) );\n+    }   // end of testBasicComps\n+\n+\n+    /**\n+     * Test unequal comparisons with millis of second comparators.\n+     */\n+    public void testMillis() {\n+        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );\n+        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );\n+        assertEquals( \"MillisM1\", -1, cMillis.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MillisP1\", 1, cMillis.compare( bDateTime, aDateTime ) );\n+    }   // end of testMillis\n+\n+    /**\n+     * Test unequal comparisons with second comparators.\n+     */\n+    public void testSecond() {\n+        aDateTime = getADate( \"1969-12-31T23:59:58\" );\n+        bDateTime = getADate( \"1969-12-31T23:50:59\" );\n+        assertEquals( \"SecondM1a\", -1, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SecondP1a\", 1, cSecond.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:01\" );\n+        assertEquals( \"SecondM1b\", -1, cSecond.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"SecondP1b\", 1, cSecond.compare( bDateTime, aDateTime ) );\n+    }   // end of testSecond\n+\n+    /**\n+     * Test unequal comparisons with minute comparators.\n+     */\n+    public void testMinute() {\n+        aDateTime = getADate( \"1969-12-31T23:58:00\" );\n+        bDateTime = getADate( \"1969-12-31T23:59:00\" );\n+        assertEquals( \"MinuteM1a\", -1, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MinuteP1a\", 1, cMinute.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T00:01:00\" );\n+        assertEquals( \"MinuteM1b\", -1, cMinute.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MinuteP1b\", 1, cMinute.compare( bDateTime, aDateTime ) );\n+    }   // end of testMinute\n+\n+    /**\n+     * Test unequal comparisons with hour comparators.\n+     */\n+    public void testHour() {\n+        aDateTime = getADate( \"1969-12-31T22:00:00\" );\n+        bDateTime = getADate( \"1969-12-31T23:00:00\" );\n+        assertEquals( \"HourM1a\", -1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourP1a\", 1, cHour.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1970-01-01T01:00:00\" );\n+        assertEquals( \"HourM1b\", -1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourP1b\", 1, cHour.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1969-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"HourP1c\", 1, cHour.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"HourM1c\", -1, cHour.compare( bDateTime, aDateTime ) );\n+    }   // end of testHour\n+\n+    /**\n+     * Test unequal comparisons with day of week comparators.\n+     */\n+    public void testDOW() {\n+        /*\n+         * Dates chosen when I wrote the code, so I know what day of\n+         * the week it is.\n+         */\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOWM1a\", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOWP1a\", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOW\n+\n+    /**\n+     * Test unequal comparisons with day of month comparators.\n+     */\n+    public void testDOM() {\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOMM1a\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOMP1a\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-12-01T00:00:00\" );\n+        bDateTime = getADate( \"1814-04-30T00:00:00\" );\n+        assertEquals( \"DOMM1b\", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOMP1b\", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOM\n+\n+    /**\n+     * Test unequal comparisons with day of year comparators.\n+     */\n+    public void testDOY() {\n+        aDateTime = getADate( \"2002-04-12T00:00:00\" );\n+        bDateTime = getADate( \"2002-04-13T00:00:00\" );\n+        assertEquals( \"DOYM1a\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOYP1a\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-02-29T00:00:00\" );\n+        bDateTime = getADate( \"1814-11-30T00:00:00\" );\n+        assertEquals( \"DOYM1b\", -1, cDayOfYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"DOYP1b\", 1, cDayOfYear.compare( bDateTime, aDateTime ) );\n+    }   // end of testDOY\n+\n+    /**\n+     * Test unequal comparisons with week of weekyear comparators.\n+     */\n+    public void testWOW() {\n+        // 1st week of year contains Jan 04.\n+        aDateTime = getADate( \"2000-01-04T00:00:00\" );\n+        bDateTime = getADate( \"2000-01-11T00:00:00\" );\n+        assertEquals( \"WOWM1a\", -1,\n+            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOWP1a\", 1,\n+            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"2000-01-04T00:00:00\" );\n+        bDateTime = getADate( \"1999-12-31T00:00:00\" );\n+        assertEquals( \"WOWM1b\", -1,\n+            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"WOWP1b\", 1,\n+            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );\n+    }   // end of testMillis\n+\n+    /**\n+     * Test unequal comparisons with year given the week comparators.\n+     */\n+    public void testWOYY() {\n+        // How do I test the end conditions of this?\n+        // Don't understand ......\n+        aDateTime = getADate( \"1998-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1999-01-01T00:00:00\" );\n+        assertEquals( \"YOYYZ\", 0, cWeekyear.compare( aDateTime, bDateTime ) );\n+        bDateTime = getADate( \"1999-01-04T00:00:00\" );\n+        assertEquals( \"YOYYM1\", -1, cWeekyear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YOYYP1\", 1, cWeekyear.compare( bDateTime, aDateTime ) );\n+    }   // end of testWOYY\n+\n+    /**\n+     * Test unequal comparisons with month comparators.\n+     */\n+    public void testMonth() {\n+        aDateTime = getADate( \"2002-04-30T00:00:00\" );\n+        bDateTime = getADate( \"2002-05-01T00:00:00\" );\n+        assertEquals( \"MONTHM1a\", -1, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTHP1a\", 1, cMonth.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1900-01-01T00:00:00\" );\n+        bDateTime = getADate( \"1899-12-31T00:00:00\" );\n+        assertEquals( \"MONTHM1b\", -1, cMonth.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"MONTHP1b\", 1, cMonth.compare( bDateTime, aDateTime ) );\n+    }   // end of testMonth\n+\n+    /**\n+     * Test unequal comparisons with year comparators.\n+     */\n+    public void testYear() {\n+        aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+        bDateTime = getADate( \"2001-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1a\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1a\", 1, cYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1968-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1b\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1b\", 1, cYear.compare( bDateTime, aDateTime ) );\n+        aDateTime = getADate( \"1969-12-31T23:59:59\" );\n+        bDateTime = getADate( \"1970-01-01T00:00:00\" );\n+        assertEquals( \"YEARM1c\", -1, cYear.compare( aDateTime, bDateTime ) );\n+        assertEquals( \"YEARP1c\", 1, cYear.compare( bDateTime, aDateTime ) );\n+    }   // end of testYear\n+\n+    /*\n+     * 'List' processing tests follow.\n+     */\n+\n+     /**\n+      * Test sorting with full default comparator.\n+      */\n+     public void testListBasic() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-01-20T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListBasic\", !isSorted1, isSorted2);\n+     } // end of testListBasic\n+\n+     /**\n+      * Test sorting with millis of second comparator.\n+      */\n+    public void testListMillis() {\n+        //\n+        List sl = new ArrayList();\n+        long base = 12345L * 1000L;\n+        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );\n+        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );\n+        //\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMillis );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListLillis\", !isSorted1, isSorted2);\n+    } // end of testListSecond\n+\n+\n+     /**\n+      * Test sorting with second comparator.\n+      */\n+    public void testListSecond() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:10\",\n+            \"1999-02-01T00:00:30\",\n+            \"1999-02-01T00:00:25\",\n+            \"1999-02-01T00:00:18\",\n+            \"1999-02-01T00:00:01\",\n+            \"1999-02-01T00:00:59\",\n+            \"1999-02-01T00:00:22\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cSecond );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListSecond\", !isSorted1, isSorted2);\n+    } // end of testListSecond\n+\n+     /**\n+      * Test sorting with minute comparator.\n+      */\n+    public void testListMinute() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:10:00\",\n+            \"1999-02-01T00:30:00\",\n+            \"1999-02-01T00:25:00\",\n+            \"1999-02-01T00:18:00\",\n+            \"1999-02-01T00:01:00\",\n+            \"1999-02-01T00:59:00\",\n+            \"1999-02-01T00:22:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMinute );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListMinute\", !isSorted1, isSorted2);\n+    } // end of testListMinute\n+\n+     /**\n+      * Test sorting with hour comparator.\n+      */\n+    public void testListHour() {\n+        String[] dtStrs = {\n+            \"1999-02-01T10:00:00\",\n+            \"1999-02-01T23:00:00\",\n+            \"1999-02-01T01:00:00\",\n+            \"1999-02-01T15:00:00\",\n+            \"1999-02-01T05:00:00\",\n+            \"1999-02-01T20:00:00\",\n+            \"1999-02-01T17:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cHour );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListHour\", !isSorted1, isSorted2);\n+    } // end of testListHour\n+\n+\n+     /**\n+      * Test sorting with day of week comparator.\n+      */\n+    public void testListDOW() {\n+        String[] dtStrs = {\n+            /* 2002-04-15 = Monday */\n+            \"2002-04-21T10:00:00\",\n+            \"2002-04-16T10:00:00\",\n+            \"2002-04-15T10:00:00\",\n+            \"2002-04-17T10:00:00\",\n+            \"2002-04-19T10:00:00\",\n+            \"2002-04-18T10:00:00\",\n+            \"2002-04-20T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfWeek );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOW\", !isSorted1, isSorted2);\n+    } // end of testListDOW\n+\n+     /**\n+      * Test sorting with day of month comparator.\n+      */\n+    public void testListDOM() {\n+        String[] dtStrs = {\n+            /* 2002-04-14 = Sunday */\n+            \"2002-04-20T10:00:00\",\n+            \"2002-04-16T10:00:00\",\n+            \"2002-04-15T10:00:00\",\n+            \"2002-04-17T10:00:00\",\n+            \"2002-04-19T10:00:00\",\n+            \"2002-04-18T10:00:00\",\n+            \"2002-04-14T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfMonth );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOM\", !isSorted1, isSorted2);\n+    } // end of testListDOM\n+\n+     /**\n+      * Test sorting with day of year comparator.\n+      */\n+    public void testListDOY() {\n+        String[] dtStrs = {\n+            \"2002-04-20T10:00:00\",\n+            \"2002-01-16T10:00:00\",\n+            \"2002-12-31T10:00:00\",\n+            \"2002-09-14T10:00:00\",\n+            \"2002-09-19T10:00:00\",\n+            \"2002-02-14T10:00:00\",\n+            \"2002-10-30T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDayOfYear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDOY\", !isSorted1, isSorted2);\n+    } // end of testListDOY\n+\n+     /**\n+      * Test sorting with week of weekyear comparator.\n+      */\n+    public void testListWOW() {\n+        String[] dtStrs = {\n+            \"2002-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\",\n+            \"2002-12-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-02-01T10:00:00\",\n+            \"2002-10-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cWeekOfWeekyear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListWOW\", !isSorted1, isSorted2);\n+    } // end of testListWOW\n+\n+     /**\n+      * Test sorting with year (given week) comparator.\n+      */\n+    public void testListYOYY() {\n+        // ?? How to catch end conditions ??\n+        String[] dtStrs = {\n+            \"2010-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cWeekyear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListYOYY\", !isSorted1, isSorted2);\n+    } // end of testListYOYY\n+\n+\n+     /**\n+      * Test sorting with month comparator.\n+      */\n+    public void testListMonth() {\n+        String[] dtStrs = {\n+            \"2002-04-01T10:00:00\",\n+            \"2002-01-01T10:00:00\",\n+            \"2002-12-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-09-01T10:00:00\",\n+            \"2002-02-01T10:00:00\",\n+            \"2002-10-01T10:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cMonth );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListMonth\", !isSorted1, isSorted2);\n+    } // end of testListMonth\n+\n+     /**\n+      * Test sorting with year comparator.\n+      */\n+     public void testListYear() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-02-01T00:00:00\",\n+            \"2525-02-01T00:00:00\",\n+            \"1776-02-01T00:00:00\",\n+            \"1863-02-01T00:00:00\",\n+            \"1066-02-01T00:00:00\",\n+            \"2100-02-01T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cYear );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListYear\", !isSorted1, isSorted2);\n+     } // end of testListYear\n+\n+     /**\n+      * Test sorting with date only comparator.\n+      */\n+    public void testListDate() {\n+        String[] dtStrs = {\n+            \"1999-02-01T00:00:00\",\n+            \"1998-10-03T00:00:00\",\n+            \"2525-05-20T00:00:00\",\n+            \"1776-12-25T00:00:00\",\n+            \"1863-01-31T00:00:00\",\n+            \"1066-09-22T00:00:00\",\n+            \"2100-07-04T00:00:00\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cDate );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListDate\", !isSorted1, isSorted2);\n+    } // end of testListDate\n+\n+     /**\n+      * Test sorting with time only comparator.\n+      */\n+    public void testListTime() {\n+        String[] dtStrs = {\n+            \"1999-02-01T01:02:05\",\n+            \"1999-02-01T22:22:22\",\n+            \"1999-02-01T05:30:45\",\n+            \"1999-02-01T09:17:59\",\n+            \"1999-02-01T09:17:58\",\n+            \"1999-02-01T15:30:00\",\n+            \"1999-02-01T17:00:44\"\n+        };\n+        //\n+        List sl = loadAList( dtStrs );\n+        boolean isSorted1 = isListSorted( sl );\n+        Collections.sort( sl, cTime );\n+        boolean isSorted2 = isListSorted( sl );\n+        assertEquals(\"ListTime\", !isSorted1, isSorted2);\n+    } // end of testListTime\n+\n+\n+    /**\n+     * Test comparator operation with null object(s).\n+     */\n+    public void testNullDT() {\n+        try\n+        {\n+            aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+            assertEquals(\"NULLDT Expected Fail\", 0,     // should not matter\n+                    cYear.compare( null, aDateTime ) );\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            return;\n+        }\n+        fail(\"null object failed\");\n+    } // end of testNullDT\n+\n+    /**\n+     * Test comparator operation with an invalid object type.\n+     */\n+    public void testInvalidObj() {\n+        try\n+        {\n+            aDateTime = getADate( \"2000-01-01T00:00:00\" );\n+            assertEquals(\"INVLO Expected Fail\", 0,  // should not matter\n+                    cYear.compare( \"FreeBird\" , aDateTime ) );\n+        }\n+        catch(ClassCastException cce)\n+        {\n+            return;\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            return;\n+        }\n+        fail(\"Invalid object failed\");\n+    } // end of testInvalidObj\n+\n+\n+    /*\n+     * -----------------------------------------\n+     * private convenience methods\n+     * -----------------------------------------\n+     */\n+    /*\n+     * getADate\n+     */\n+    private DateTime getADate(String s) {\n+        DateTime retDT = null;\n+        try\n+        {\n+            retDT = new DateTime( s, DateTimeZone.UTC );\n+        }\n+        catch(ParseException pe)\n+        {\n+            pe.printStackTrace();\n+        }\n+        return retDT;\n+    } // end of getADate\n+    /*\n+     * loadAList\n+     */\n+    private List loadAList(String[] someStrs) {\n+        List newList = new ArrayList();\n+        try\n+        {\n+            for (int i = 0; i < someStrs.length; ++i) {\n+                newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );\n+            } // end of the for\n+        }\n+        catch(ParseException pe)\n+        {\n+            pe.printStackTrace();\n+        }\n+        return newList;\n+    } // end of loadAList\n+    /*\n+     * isListSorted\n+     */\n+    private boolean isListSorted( List tl ) {\n+        // tl must be populated with DateTime objects.\n+        DateTime lhDT = (DateTime)tl.get(0);\n+        DateTime rhDT = null;\n+        Long lhVal = new Long( lhDT.getMillis() );\n+        Long rhVal = null;\n+        for (int i = 1; i < tl.size(); ++i) {\n+            rhDT = (DateTime)tl.get(i);\n+            rhVal = new Long( rhDT.getMillis() );\n+            if ( lhVal.compareTo( rhVal) > 0 ) return false;\n+            //\n+            lhVal = rhVal;  // swap for next iteration\n+            lhDT = rhDT;    // swap for next iteration\n+        } // end of the for\n+        return true;\n+    } // end of isListSorted\n+\n+} // end of class TestDateTimeComparator\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the CTORs of the\n+ * DateTime date time class.  The DateTime class is passed\n+ * to the base class, which actually invokes the proper\n+ * constructors.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeCtors\n+    extends AbstractTestDateTimeCommon {\n+\n+    // The class to be tested.\n+    private static Class cls = DateTime.class;\n+\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestDateTimeCtors.class);\n+    }\n+    /**\n+     * Constructor.\n+     * @param name\n+     */\n+    public TestDateTimeCtors(String name) {\n+        super(name, cls);\n+    }\n+    /**\n+     * Constructor\n+     * @param name The class name.\n+     * @param cls The class to be tested.\n+     */\n+    public TestDateTimeCtors(String name, Class cls) {\n+        super(name, cls);\n+        TestDateTimeCtors.cls = cls;\n+    }\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        super.tearDown();\n+    }\n+    \n+    protected ReadableInstant createSmall(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(-1L * 1000, GJChronology.getInstance());\n+        }\n+        return new DateTime(-1L * 1000);\n+    }\n+    \n+    protected ReadableInstant createMid(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(2L * 1000, GJChronology.getInstance());\n+        }\n+        return new DateTime(2L * 1000);\n+    }\n+    \n+    protected ReadableInstant createLarge(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(3L * 1000, GJChronology.getInstance());\n+        }\n+        return new DateTime(3L * 1000);\n+    }\n+\n+    protected ReadableInstant createUTC(long millis) {\n+        return new DateTime(millis, ISOChronology.getInstance(DateTimeZone.UTC));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+//import java.util.*;\n+//import java.text.* ;\n+import junit.framework.TestSuite;\n+//import org.joda.time.*;\n+//import org.joda.time.gj.*;\n+//import org.joda.time.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * GJDateTimeFormat date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeFormat extends BulkTest {\n+\n+\t/**\n+\t * This is the main class for this test suite.\n+\t * @param args command line arguments.\n+\t */\n+\tpublic static void main(String[] args) {\n+\t\tjunit.textui.TestRunner.run(suite());\n+\t}\n+\t/**\n+\t * TestSuite is a junit required method.\n+\t */\n+\tpublic static TestSuite suite() {\n+\t\treturn BulkTest.makeSuite(TestDateTimeFormat.class);\n+\t}\n+\t/**\n+\t * TestDateTimeField constructor.\n+\t * @param name\n+\t */\n+\tpublic TestDateTimeFormat(String name) {\n+\t\tsuper(name);\n+\t}\n+\t// Class Name: org.joda.time.format.DateTimeFormat\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tpublic void setUp() /* throws Exception */ {\n+\t\t// super.setUp();\n+\t}\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+\t\t// super.tearDown();\n+\t}\n+\t/**\n+\t * Test the <code>getInstance()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance()\n+\t */\n+\tprotected void testGetInstance() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String)\n+\t */\n+\tpublic void testGetInstanceString() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String, java.util.TimeZone)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone)\n+\t */\n+\tpublic void testGetInstanceSTZ() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)\n+\t */\n+\tpublic void testGetInstanceSTZL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology)\n+\t */\n+\tpublic void testGetInstanceSC() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)\n+\t */\n+\tpublic void testGetInstanceSCT() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n+\t */\n+\tpublic void testGetInstanceSCTL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n+\t */\n+\tpublic void testGetDateInstance() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n+\t */\n+\tpublic void testGetTimeInstance() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)\n+\t */\n+\tpublic void testGetDateTimeInstance() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getPattern()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getPattern()\n+\t */\n+\tpublic void testGetPattern() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getChronology()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getChronology()\n+\t */\n+\tpublic void testGetChronology() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTimeZone()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getTimeZone()\n+\t */\n+\tpublic void testGetTimeZone() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getLocale()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getLocale()\n+\t */\n+\tpublic void testGetLocale() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getPrinter()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getPrinter()\n+\t */\n+\tpublic void testGetPrinter() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getParser()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#getParser()\n+\t */\n+\tpublic void testGetParser() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>estimatePrintedLength()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#estimatePrintedLength()\n+\t */\n+\tpublic void testEstimatePrintedLength() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.lang.StringBuffer, long, long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long, long)\n+\t */\n+\tpublic void testPrintToSLL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.io.Writer, long, long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long, long)\n+\t */\n+\tpublic void testPrintToWLL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)\n+\t */\n+\tpublic void testPrintToSBRI() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.lang.StringBuffer, long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long)\n+\t */\n+\tpublic void testPrintToSBL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.io.Writer, org.joda.time.ReadableInstant)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, org.joda.time.ReadableInstant)\n+\t */\n+\tpublic void testPrintToWRI() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>printTo(java.io.Writer, long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long)\n+\t */\n+\tpublic void testPrintToWL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>print(org.joda.time.ReadableInstant)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#print(org.joda.time.ReadableInstant)\n+\t */\n+\tpublic void testPrintRI() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>print(long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#print(long)\n+\t */\n+\tpublic void testPrintL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>estimateParsedLength()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#estimateParsedLength()\n+\t */\n+\tpublic void testEstimateParsedLength() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)\n+\t */\n+\tpublic void testParseIntoPBSI() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String)\n+\t */\n+\tpublic void testParseIntoRWIS() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)\n+\t */\n+\tpublic void testParseIntoRWISI() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parse(java.lang.String)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String)\n+\t */\n+\tpublic void testParseS() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parse(java.lang.String, int, long)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String, int, long)\n+\t */\n+\tpublic void testParseSL() {\n+\t\tfail(\"TBD\");\n+\t}\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormatterBuilder.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+//import java.util.*;\n+//import java.text.* ;\n+import junit.framework.TestSuite;\n+//import org.joda.time.*;\n+//import org.joda.time.gj.*;\n+//import org.joda.time.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * GJDateTimeFormatterBuilder date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeFormatterBuilder extends BulkTest {\n+\n+\t/**\n+\t * This is the main class for this test suite.\n+\t * @param args command line arguments.\n+\t */\n+\tpublic static void main(String[] args) {\n+\t\tjunit.textui.TestRunner.run(suite());\n+\t}\n+\t/**\n+\t * TestSuite is a junit required method.\n+\t */\n+\tpublic static TestSuite suite() {\n+\t\treturn BulkTest.makeSuite(TestDateTimeFormatterBuilder.class);\n+\t}\n+\t/**\n+\t * TestDateTimeField constructor.\n+\t * @param name\n+\t */\n+\tpublic TestDateTimeFormatterBuilder(String name) {\n+\t\tsuper(name);\n+\t}\n+\t// Class Name: org.joda.time.format.DateTimeFormatterBuilder\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tprotected void setUp() /* throws Exception */ {\n+\t\t// super.setUp();\n+\t}\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+\t\t// super.tearDown();\n+\t}\n+\t/**\n+\t * Test the <code>toPrinter()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#toPrinter()\n+\t */\n+\tpublic void testToPrinter() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>toParser()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#toParser()\n+\t */\n+\tpublic void testToParser() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>toFormatter()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#toFormatter()\n+\t */\n+\tpublic void testToFormatter() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>canBuildPrinter()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildPrinter()\n+\t */\n+\tpublic void testCanBuildPrinter() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>canBuildParser()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildParser()\n+\t */\n+\tpublic void testCanBuildParser() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>canBuilderFormatter()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#canBuilderFormatter()\n+\t */\n+\tpublic void testCanBuilderFormatter() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>clear()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#clear()\n+\t */\n+\tpublic void testClear() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>append(org.joda.time.format.DateTimeFormatter)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimeFormatter)\n+\t */\n+\tpublic void testAppendDTF() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement)\n+\t */\n+\tpublic void testAppendDTPE() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendLiteral(char)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(char)\n+\t */\n+\tpublic void testAppendLiteralC() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendLiteral(java.lang.String)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(java.lang.String)\n+\t */\n+\tpublic void testAppendLiteralS() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendNumeric(org.joda.time.DateTimeField, int, int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendNumeric(org.joda.time.DateTimeField, int, int, int)\n+\t */\n+\tpublic void testAppendNumeric() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendSignedNumeric(org.joda.time.DateTimeField, int, int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendSignedNumeric(org.joda.time.DateTimeField, int, int, int)\n+\t */\n+\tpublic void testAppendSignedNumeric() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendFraction(int, int, int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendFraction(int, int, int, int)\n+\t */\n+\tpublic void testAppendFraction() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendFractionOfSecond(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfSecond(int, int)\n+\t */\n+\tpublic void testAppendFractionOfSecond() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendFractionOfMinute(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfMinute(int, int)\n+\t */\n+\tpublic void testAppendFractionOfMinute() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendFractionOfHour(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfHour(int, int)\n+\t */\n+\tpublic void testAppendFractionOfHour() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendFractionOfDay(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfDay(int, int)\n+\t */\n+\tpublic void testAppendFractionOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMillisOfSecond(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfSecond(int)\n+\t */\n+\tpublic void testAppendMillisOfSecond() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMillisOfDay(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfDay(int)\n+\t */\n+\tpublic void testAppendMillisOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendSecondOfMinute(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfMinute(int)\n+\t */\n+\tpublic void testAppendSecondOfMinute() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendSecondOfDay(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfDay(int)\n+\t */\n+\tpublic void testAppendSecondOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMinuteOfHour(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfHour(int)\n+\t */\n+\tpublic void testAppendMinuteOfHour() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMinuteOfDay(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfDay(int)\n+\t */\n+\tpublic void testAppendMinuteOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendHourOfDay(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfDay(int)\n+\t */\n+\tpublic void testAppendHourOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendClockhourOfDay(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfDay(int)\n+\t */\n+\tpublic void testAppendClockhourOfDay() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendHourOfHalfday(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfHalfday(int)\n+\t */\n+\tpublic void testAppendHourOfHalfday() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendClockhourOfHalfday(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfHalfday(int)\n+\t */\n+\tpublic void testAppendClockhourOfHalfday() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendDayOfWeek(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeek(int)\n+\t */\n+\tpublic void testAppendDayOfWeek() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendDayOfMonth(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfMonth(int)\n+\t */\n+\tpublic void testAppendDayOfMonth() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendDayOfYear(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfYear(int)\n+\t */\n+\tpublic void testAppendDayOfYear() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendWeekOfYearWeek(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearWeek(int)\n+\t */\n+\tpublic void testAppendWeekOfYearWeek() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendWeekOfYearYear(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearYear(int, int)\n+\t */\n+\tpublic void testAppendWeekOfYearYear() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMonthOfYear(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYear(int)\n+\t */\n+\tpublic void testAppendMonthOfYear() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendYear(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendYear(int, int)\n+\t */\n+\tpublic void testAppendYear() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendYearOfEra(int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfEra(int, int)\n+\t */\n+\tpublic void testAppendYearOfEra() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendYearOfCentury()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfCentury()\n+\t */\n+\tpublic void testAppendYearOfCentury() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendCentury(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendCentury(int)\n+\t */\n+\tpublic void testAppendCentury() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendCenturyOfEra(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendCenturyOfEra(int)\n+\t */\n+\tpublic void testAppendCenturyOfEra() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendAmPmSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendAmPmSymbol()\n+\t */\n+\tpublic void testAppendAmPmSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendDayOfWeekSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekSymbol()\n+\t */\n+\tpublic void testAppendDayOfWeekSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendDayOfWeekShortSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekShortSymbol()\n+\t */\n+\tpublic void testAppendDayOfWeekShortSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMonthOfYearSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearSymbol()\n+\t */\n+\tpublic void testAppendMonthOfYearSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendMonthOfYearShortSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearShortSymbol()\n+\t */\n+\tpublic void testAppendMonthOfYearShortSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendEraSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendEraSymbol()\n+\t */\n+\tpublic void testAppendEraSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendTimeZoneSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneSymbol()\n+\t */\n+\tpublic void testAppendTimeZoneSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendTimeZoneShortSymbol()</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneShortSymbol()\n+\t */\n+\tpublic void testAppendTimeZoneShortSymbol() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendTimeZoneOffset(java.lang.String, java.lang.String, boolean)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneOffset(java.lang.String, java.lang.String, boolean)\n+\t */\n+\tpublic void testAppendTimeZoneOffset() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>appendPattern(java.lang.String)</code> method.\n+\t * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)\n+\t */\n+\tpublic void testAppendPattern() {\n+\t\tfail(\"TBD\");\n+\t}\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeParserBucket.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+//import java.util.*;\n+//import java.text.* ;\n+import junit.framework.TestSuite;\n+//import org.joda.time.*;\n+//import org.joda.time.gj.*;\n+//import org.joda.time.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * GJDateTimeParserBucket date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestDateTimeParserBucket extends BulkTest {\n+\n+\t/**\n+\t * This is the main class for this test suite.\n+\t * @param args command line arguments.\n+\t */\n+\tpublic static void main(String[] args) {\n+\t\tjunit.textui.TestRunner.run(suite());\n+\t}\n+\t/**\n+\t * TestSuite is a junit required method.\n+\t */\n+\tpublic static TestSuite suite() {\n+\t\treturn BulkTest.makeSuite(TestDateTimeParserBucket.class);\n+\t}\n+\t/**\n+\t * TestDateTimeField constructor.\n+\t * @param name\n+\t */\n+\tpublic TestDateTimeParserBucket(String name) {\n+\t\tsuper(name);\n+\t}\n+\t// Class Name: org.joda.time.format.DateTimeParserBucket\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tprotected void setUp() /* throws Exception */ {\n+\t\t// super.setUp();\n+\t}\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+\t\t// super.tearDown();\n+\t}\n+\t/**\n+\t * Test the <code>setMillis(long)</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#setMillis(long)\n+\t */\n+\tpublic void testSetMillis() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>saveField(org.joda.time.DateTimeField, int, int)</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#saveField(org.joda.time.DateTimeField, int, int)\n+\t */\n+\tpublic void testSaveField() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>setTimeZone(java.util.TimeZone)</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#setTimeZone(java.util.TimeZone)\n+\t */\n+\tpublic void testSetTimeZone() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>setTimeZoneOffset(int)</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#setTimeZoneOffset(int)\n+\t */\n+\tpublic void testSetTimeZoneOffset() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTimeZone()</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#getTimeZone()\n+\t */\n+\tpublic void testGetTimeZone() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTimeZoneOffset()</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#getTimeZoneOffset()\n+\t */\n+\tpublic void testGetTimeZoneOffset() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>computeMillis()</code> method.\n+\t * @see org.joda.time.format.DateTimeParserBucket#computeMillis()\n+\t */\n+\tpublic void testComputeMillis() {\n+\t\tfail(\"TBD\");\n+\t}\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestInstant.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.AbstractInstant;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+/**\n+ * This class is a Junit unit test for the\n+ * Instant date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestInstant extends AbstractTestAbstractInstant {\n+\n+    private static Class cls = Instant.class;\n+    \n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestInstant.class);\n+    }\n+    /**\n+     * TestDateTimeField constructor.\n+     * @param name\n+     */\n+    public TestInstant(String name) {\n+        super(name, Instant.class);\n+    }\n+    \n+    /**\n+     * Test the CTOR with signature: ().\n+     */\n+    public void testCurrentTimeConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis();\n+        ReadableInstant ri = create(cls, null, null);\n+        assertTrue(ri.getMillis() - currentMillis < 100);\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (long).\n+     */\n+    public void testMillisConstructor() throws Throwable {\n+        long currentMillis = System.currentTimeMillis() + 1000;\n+        ReadableInstant ri = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(currentMillis)});\n+        assertEquals(currentMillis, ri.getMillis());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (ReadableInstant).\n+     */\n+    public void testReadableInstantConstructor() throws Throwable {\n+        ReadableInstant instant = create(Instant.class, null, null);\n+        ReadableInstant ri = create(cls, new Class[] {ReadableInstant.class}, new Object[] {instant});\n+        assertEquals(instant.getMillis(), ri.getMillis());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (ReadableInstant), null RI.\n+     */\n+    public void testReadableInstantConstructorEx() throws Throwable {\n+        try {\n+            create(cls, new Class[] {ReadableInstant.class}, new Object[] {null});\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Date).\n+     */\n+    public void testDateConstructor() throws Throwable {\n+        Date date = new Date();\n+        ReadableInstant ri = create(cls, new Class[] {Date.class}, new Object[] {date});\n+        assertEquals(date.getTime(), ri.getMillis());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Date), null date.\n+     */\n+    public void testDateConstructorEx() throws Throwable {\n+        try {\n+            create(cls, new Class[] {Date.class}, new Object[] {null});\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Calendar).\n+     */\n+    public void testCalendarConstructor() throws Throwable {\n+        Calendar cal = Calendar.getInstance();\n+        ReadableInstant ri = create(cls, new Class[] {Calendar.class}, new Object[] {cal});\n+        assertEquals(cal.getTime().getTime(), ri.getMillis());\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (Calendar), null calendar.\n+     */\n+    public void testCalendarConstructorEx() throws Throwable {\n+        try {\n+            create(cls, new Class[] {Calendar.class}, new Object[] {null});\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (String).\n+     */\n+    public void testStringConstructor() throws Throwable {\n+        ReadableInstant ri = create(cls, new Class[] {String.class}, new Object[] {\"1970-01-01T13:02:03.004Z\"});\n+        assertEquals(4 + 3*1000 + 2*1000*60 + 13*1000*60*60, ri.getMillis());\n+        // TODO: Merge in proper ISO testing from TestConstructors\n+    }\n+\n+    /**\n+     * Test the CTOR with signature: (String), null string.\n+     */\n+    public void testStringConstructorEx() throws Throwable {\n+        try {\n+            create(cls, new Class[] {String.class}, new Object[] {null});\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test getChronology\n+     */\n+    public void testGetChronology() throws Throwable {\n+        ReadableInstant ri1 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(-300)});\n+        assertNull(ri1.getChronology());\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Test toInstant\n+     */\n+    public void testToInstant() throws Throwable {\n+        ReadableInstant ri = create(cls, null, null);\n+        Instant instant = ri.toInstant();\n+        assertSame(instant, ri);\n+    }\n+\n+    /**\n+     * Test toString\n+     */\n+    public void testToString() throws Throwable {\n+        ReadableInstant ri = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(4 + 3*1000 + 2*1000*60 + 13*1000*60*60)});\n+        assertEquals(\"1970-01-01T13:02:03.004Z\", ri.toString());\n+    }\n+\n+    /**\n+     * @see org.joda.test.time.AbstractTestReadableInstant#createLarge(boolean)\n+     */\n+    protected ReadableInstant createLarge(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(400, DateTimeZone.UTC);\n+        }\n+        return new Instant(400);\n+    }\n+\n+    /**\n+     * @see org.joda.test.time.AbstractTestReadableInstant#createMid(boolean)\n+     */\n+    protected ReadableInstant createMid(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(100, DateTimeZone.UTC);\n+        }\n+        return new Instant(100);\n+    }\n+\n+    /**\n+     * @see org.joda.test.time.AbstractTestReadableInstant#createSmall(boolean)\n+     */\n+    protected ReadableInstant createSmall(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(-300, DateTimeZone.UTC);\n+        }\n+        return new Instant(-300);\n+    }\n+\n+    protected ReadableInstant createUTC(long millis) {\n+        return new Instant(millis);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.* ;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ * This currently forces tests using GMT only.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestMDTAdd extends BulkTest {\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMDTAdd.class);\n+    }\n+    /**\n+     * TestMDTAdd constructor.\n+     * @param name\n+     */\n+    public TestMDTAdd(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.MutableDateTime\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        // super.setUp();\n+        ++testNum;\n+        TimeZone.setDefault( new SimpleTimeZone(0, \"UTC\") );\n+        // gcals = gcalsMiscBunch;\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+\n+    private boolean debug = true;\n+    private static int testNum = 0;\n+    private PrintStream ewtr = System.err;\n+\n+    GregorianCalendar[] gcals0 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    /**\n+     *\n+     */\n+    ReadableInstant rica = null;\n+    /**\n+     *\n+     */\n+    Chronology cronca = null;\n+    /**\n+     *\n+     */\n+    Date jdtca = null;\n+    /**\n+     *\n+     */\n+    Calendar calca = null;\n+\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals = null;\n+    /**\n+     *\n+     */\n+    final int bumpValue = 385;\n+    // final int bumpValue = 0;\n+    /**\n+     *\n+     */\n+    // GregorianCalendar gcal = null;\n+    /**\n+     *\n+     */\n+    String isoString = null;\n+    /**\n+     *\n+     */\n+    MutableDateTime mdt = null;\n+    /**\n+     *\n+     */\n+    Chronology chrona = null;\n+    /**\n+     *\n+     */\n+    long setMillis = -1L;\n+    /**\n+     *\n+     */\n+    int setYear = -1;\n+    int setMonth = -1;\n+    int setDay = -1;\n+    int setHour = -1;\n+    int setMinute = -1;\n+    int setSecond = -1;\n+    int setMillisecond = -1;\n+    String setString = null;\n+    String yearStr = null;\n+    String monthStr = null;\n+    String dayStr = null;\n+    String hourStr = null;\n+    String minuteStr = null;\n+    String secondStr = null;\n+    String millisecondStr = null;\n+    /**\n+     *\n+     */\n+    Long longVal = null;\n+    /**\n+     *\n+     */\n+    boolean failed;\n+\n+    /**\n+     * Test the <code>addMillis(long)</code> method.\n+     * @see org.joda.time.MutableDateTime#addMillis(long)\n+     */\n+    public void testAddMillis() {\n+        fail(\"TBD\");\n+    }\n+\n+    public void testLast() {\n+        ewtr.println(\"TestMDTAdd completes\");\n+        ewtr.flush();\n+    }\n+    //-----------------------------------------------------------------\n+    //\n+    // Private methods.\n+    //\n+    //\n+    private  void prepTest(int item) {\n+        GregorianCalendar wrkgcal = new GregorianCalendar(\n+            gcals[item].get( Calendar.YEAR ),\n+            gcals[item].get( Calendar.MONTH ),\n+            gcals[item].get( Calendar.DATE ),\n+            gcals[item].get( Calendar.HOUR ),\n+            gcals[item].get( Calendar.MINUTE ),\n+            gcals[item].get( Calendar.SECOND )\n+        );\n+        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n+        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));\n+        //\n+        wrkgcal.add(Calendar.MILLISECOND, bumpValue);\n+        wrkgcal.setMinimalDaysInFirstWeek(4);\n+        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);\n+        //\n+        // Force the GregorianCalendar to recalculate all internal\n+        // values.\n+        //\n+        wrkgcal.setTime( wrkgcal.getTime() );\n+\n+        if ( debug ) {\n+            ewtr.println(\"====Test Number: \" + testNum);\n+            ewtr.println(\"  ==Item Number: \" + item);\n+            ewtr.flush();\n+        }\n+        isoString = getDateTimeString( wrkgcal );\n+        mdt = null;\n+        try\n+        {\n+            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n+        }\n+        catch(ParseException pe)\n+        {\n+            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println( pe.getMessage() );\n+            ewtr.flush();\n+        }\n+\n+        if ( debug ) {\n+            ewtr.println(\"    =ISO String: \" + isoString);\n+            ewtr.flush();\n+        }\n+\n+        setMillis = System.currentTimeMillis();\n+        GregorianCalendar gx = new GregorianCalendar();\n+        gx.setTime( new Date( setMillis ) );\n+        //\n+        setYear = gx.get(Calendar.YEAR);\n+        setMonth = gx.get(Calendar.MONTH) + 1;\n+        setDay = gx.get(Calendar.DATE);\n+        setHour = gx.get(Calendar.HOUR_OF_DAY);\n+        setMinute = gx.get(Calendar.MINUTE);\n+        setSecond = gx.get(Calendar.SECOND);\n+        setMillisecond = gx.get(Calendar.MILLISECOND);\n+        //\n+        rica = new Instant( setMillis );\n+        jdtca = new Date( setMillis );\n+        calca = Calendar.getInstance();\n+        calca.setTime( jdtca );\n+        longVal = new Long( setMillis );\n+        //\n+        MutableDateTime temp = new MutableDateTime( setMillis,\n+            ISOChronology.getInstanceUTC() );\n+        setString = \"\" + temp;\n+    }\n+\n+} // end of class TestMDTAdd\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.* ;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ * This currently forces tests using GMT only.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestMDTAddWrapped extends BulkTest {\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMDTAddWrapped.class);\n+    }\n+    /**\n+     * TestMDTAddWrapped constructor.\n+     * @param name\n+     */\n+    public TestMDTAddWrapped(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.MutableDateTime\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        // super.setUp();\n+        ++testNum;\n+        TimeZone.setDefault( new SimpleTimeZone(0, \"UTC\") );\n+        // gcals = gcalsMiscBunch;\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+\n+    private boolean debug = true;\n+    private static int testNum = 0;\n+    private PrintStream ewtr = System.err;\n+\n+    GregorianCalendar[] gcals0 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    /**\n+     *\n+     */\n+    ReadableInstant rica = null;\n+    /**\n+     *\n+     */\n+    Chronology cronca = null;\n+    /**\n+     *\n+     */\n+    Date jdtca = null;\n+    /**\n+     *\n+     */\n+    Calendar calca = null;\n+\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals = null;\n+    /**\n+     *\n+     */\n+    final int bumpValue = 385;\n+    // final int bumpValue = 0;\n+    /**\n+     *\n+     */\n+    // GregorianCalendar gcal = null;\n+    /**\n+     *\n+     */\n+    String isoString = null;\n+    /**\n+     *\n+     */\n+    MutableDateTime mdt = null;\n+    /**\n+     *\n+     */\n+    Chronology chrona = null;\n+    /**\n+     *\n+     */\n+    long setMillis = -1L;\n+    /**\n+     *\n+     */\n+    int setYear = -1;\n+    int setMonth = -1;\n+    int setDay = -1;\n+    int setHour = -1;\n+    int setMinute = -1;\n+    int setSecond = -1;\n+    int setMillisecond = -1;\n+    String setString = null;\n+    String yearStr = null;\n+    String monthStr = null;\n+    String dayStr = null;\n+    String hourStr = null;\n+    String minuteStr = null;\n+    String secondStr = null;\n+    String millisecondStr = null;\n+    /**\n+     *\n+     */\n+    Long longVal = null;\n+    /**\n+     *\n+     */\n+    boolean failed;\n+    /**\n+     *\n+     */\n+    public void testFailure() {\n+        fail(\"TBD - all MDT Add tests\");\n+    }\n+\n+    public void testLast() {\n+        ewtr.println(\"TestMDTAddWrapped completes\");\n+        ewtr.flush();\n+    }\n+    //-----------------------------------------------------------------\n+    //\n+    // Private methods.\n+    //\n+    //\n+    private  void prepTest(int item) {\n+        GregorianCalendar wrkgcal = new GregorianCalendar(\n+            gcals[item].get( Calendar.YEAR ),\n+            gcals[item].get( Calendar.MONTH ),\n+            gcals[item].get( Calendar.DATE ),\n+            gcals[item].get( Calendar.HOUR ),\n+            gcals[item].get( Calendar.MINUTE ),\n+            gcals[item].get( Calendar.SECOND )\n+        );\n+        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n+        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));\n+        //\n+        wrkgcal.add(Calendar.MILLISECOND, bumpValue);\n+        wrkgcal.setMinimalDaysInFirstWeek(4);\n+        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);\n+        //\n+        // Force the GregorianCalendar to recalculate all internal\n+        // values.\n+        //\n+        wrkgcal.setTime( wrkgcal.getTime() );\n+\n+        if ( debug ) {\n+            ewtr.println(\"====Test Number: \" + testNum);\n+            ewtr.println(\"  ==Item Number: \" + item);\n+            ewtr.flush();\n+        }\n+        isoString = getDateTimeString( wrkgcal );\n+        mdt = null;\n+        try\n+        {\n+            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n+        }\n+        catch(ParseException pe)\n+        {\n+            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println( pe.getMessage() );\n+            ewtr.flush();\n+        }\n+\n+        if ( debug ) {\n+            ewtr.println(\"    =ISO String: \" + isoString);\n+            ewtr.flush();\n+        }\n+\n+        setMillis = System.currentTimeMillis();\n+        GregorianCalendar gx = new GregorianCalendar();\n+        gx.setTime( new Date( setMillis ) );\n+        //\n+        setYear = gx.get(Calendar.YEAR);\n+        setMonth = gx.get(Calendar.MONTH) + 1;\n+        setDay = gx.get(Calendar.DATE);\n+        setHour = gx.get(Calendar.HOUR_OF_DAY);\n+        setMinute = gx.get(Calendar.MINUTE);\n+        setSecond = gx.get(Calendar.SECOND);\n+        setMillisecond = gx.get(Calendar.MILLISECOND);\n+        //\n+        rica = new Instant( setMillis );\n+        jdtca = new Date( setMillis );\n+        calca = Calendar.getInstance();\n+        calca.setTime( jdtca );\n+        longVal = new Long( setMillis );\n+        //\n+        MutableDateTime temp = new MutableDateTime( setMillis,\n+            ISOChronology.getInstanceUTC() );\n+        setString = \"\" + temp;\n+    }\n+\n+} // end of class TestMDTAddWrapped\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ * This currently forces tests using GMT only.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestMDTGet extends BulkTest {\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMDTGet.class);\n+    }\n+    /**\n+     * TestMDTGet constructor.\n+     * @param name\n+     */\n+    public TestMDTGet(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.MutableDateTime\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        // super.setUp();\n+        ++testNum;\n+        TimeZone.setDefault( new SimpleTimeZone(0, \"UTC\") );\n+        gcals = gcals0;\n+        // gcals = gcalsMiscBunch;\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+\n+    private boolean debug = true;\n+    private static int testNum = 0;\n+    private PrintStream ewtr = System.err;\n+\n+    /**\n+     *\n+     */\n+    boolean failed;\n+    // Developers/Testers Note:\n+    //\n+    // 1) Construct any valid array of Gregorian calendar objects,\n+    //    e.g. 'gcals1' below.\n+    // 2) Change the assignment statement in the setUp() method.\n+    // 3) Recompile+jar.\n+    //\n+    // The new array will be used in all the tests.\n+    //\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals0 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcals1 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 2, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 0, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 2, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsGJCutOver = {\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsPreCut = {\n+        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),\n+        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),\n+        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),\n+        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),\n+    };\n+\n+    GregorianCalendar[] gcalsYear0 = {\n+        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),\n+    };\n+    GregorianCalendar[] gcalsYearM1 = {\n+        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsEndPoints = {\n+        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),\n+    };\n+    // This don't work.  ParseException from the CTOR.\n+    GregorianCalendar[] gcalsOutSide = {\n+        new GregorianCalendar(+76542, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(-12345, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    //\n+    GregorianCalendar[] gcalsMiscBunch = {\n+        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),\n+        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),\n+        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),\n+        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 2, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 0, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 2, 1, 0, 0, 0),\n+    };\n+    //\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals = null;\n+    /**\n+     *\n+     */\n+    final int bumpValue = 385;\n+    // final int bumpValue = 0;\n+    /**\n+     *\n+     */\n+    // GregorianCalendar gcal = null;\n+    /**\n+     *\n+     */\n+    String isoString = null;\n+    /**\n+     *\n+     */\n+    MutableDateTime mdt = null;\n+    /**\n+     *\n+     */\n+    int expected_year = -1;         // Calculated in setup\n+    /**\n+     *\n+     */\n+    int expected_mon = -1;\n+    /**\n+     *\n+     */\n+    int expected_day = -1;\n+    /**\n+     *\n+     */\n+    int expected_hour = -1;\n+    /**\n+     *\n+     */\n+    int expected_minute = -1;\n+    /**\n+     *\n+     */\n+    int expected_second = -1;\n+    /**\n+     *\n+     */\n+    int expected_doy = -1;\n+    /**\n+     *\n+     */\n+    int expected_woyw = -1;\n+    /**\n+     *\n+     */\n+    int expected_woyy = -1;\n+    /**\n+     *\n+     */\n+    int expected_dow = -1;\n+    /**\n+     *\n+     */\n+    long expected_gcmillis = -1L;\n+    /**\n+     *\n+     */\n+    long expected_millisofday = -1L;\n+    /**\n+     *\n+     */\n+    long expected_secondofday = -1L;\n+    /**\n+     *\n+     */\n+    long expected_minuteofday = -1L;\n+    /**\n+     *\n+     */\n+    Chronology chrona = null;\n+    //\n+    // Test 'get' methods - 1st.\n+    //\n+    /**\n+     * Test the <code>getChronology()</code> method.\n+     * @see org.joda.time.MutableDateTime#getChronology()\n+     */\n+    public void testGetChronology() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            chrona = mdt.getChronology();\n+            assertNotNull(\"GC1:\"+isoString, chrona);\n+            // Commented out until ?\n+            // assertTrue(\"GC2:\"+isoString, chrona instanceof ISOChronology);\n+        }\n+    }\n+    /**\n+     * Test the <code>getMillis()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMillis()\n+     */\n+    public void testGetMillis() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GM1:\"+isoString, expected_gcmillis, mdt.getMillis());\n+        }\n+    }\n+    /**\n+     * Test the <code>getDayOfWeek()</code> method.\n+     * @see org.joda.time.MutableDateTime#getDayOfWeek()\n+     */\n+    public void testGetDayOfWeek() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GDOW1:\"+isoString, expected_dow, mdt.getDayOfWeek() );\n+        }\n+    }\n+    /**\n+     * Test the <code>getDayOfMonth()</code> method.\n+     * @see org.joda.time.MutableDateTime#getDayOfMonth()\n+     */\n+    public void testGetDayOfMonth() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GDOM1:\"+isoString, expected_day, mdt.getDayOfMonth());\n+        }\n+    }\n+    /**\n+     * Test the <code>getDayOfYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#getDayOfYear()\n+     */\n+    public void testGetDayOfYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GDOY1:\"+isoString, expected_doy, mdt.getDayOfYear());\n+        }\n+    }\n+    /**\n+     * Test the <code>getWeekOfYearWeek()</code> method.\n+     * @see org.joda.time.MutableDateTime#getWeekOfYearWeek()\n+     */\n+    public void testGetWeekOfWeekyear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GWOYW1:\"+isoString, expected_woyw, mdt.getWeekOfWeekyear());\n+        }\n+    }\n+    /**\n+     * Test the <code>getWeekOfYearYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#getWeekOfYearYear()\n+     */\n+    public void testGetYearOfWeekyear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GWOYY1:\"+isoString, expected_woyy, mdt.getWeekyear());\n+        }\n+    }\n+    /**\n+     * Test the <code>getMonthOfYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMonthOfYear()\n+     */\n+    public void testGetMonthOfYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GMOY1:\"+isoString, expected_mon, mdt.getMonthOfYear());\n+        }\n+    }\n+    /**\n+     * Test the <code>getYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#getYear()\n+     */\n+    public void testGetYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GY1:\"+isoString, expected_year, mdt.getYear());\n+        }\n+    }\n+    /**\n+     * Test the <code>getYearOfEra()</code> method.\n+     * @see org.joda.time.MutableDateTime#getYearOfEra()\n+     */\n+    /*\n+    public void testGetYearOfEra() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GYOE1:\"+isoString, Math.abs(expected_year), mdt.getYearOfEra());\n+        }\n+    }\n+    */\n+    /**\n+     * Test the <code>getEra()</code> method.\n+     * @see org.joda.time.MutableDateTime#getEra()\n+     */\n+    /*\n+    public void testGetEra() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            if ( gcals[ngc].get(Calendar.ERA) == GregorianCalendar.AD) {\n+                assertEquals(\"GERA1:\"+isoString,\n+                    DateTimeConstants.AD, mdt.getEra());\n+            } else {\n+                assertEquals(\"GERA1:\"+isoString,\n+                    DateTimeConstants.BC, mdt.getEra());\n+            }\n+        }\n+    }\n+    */\n+    /**\n+     * Test the <code>getMillisOfSecond()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMillisOfSecond()\n+     */\n+    public void testGetMillisOfSecond() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GMOS1:\"+isoString, bumpValue, mdt.getMillisOfSecond());\n+        }\n+    }\n+    /**\n+     * Test the <code>getMillisOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMillisOfDay()\n+     */\n+    public void testGetMillisOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GMLSOD1:\"+isoString, expected_millisofday, mdt.getMillisOfDay());\n+        }\n+    }\n+    /**\n+     * Test the <code>getSecondOfMinute()</code> method.\n+     * @see org.joda.time.MutableDateTime#getSecondOfMinute()\n+     */\n+    public void testGetSecondOfMinute() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GSOM1:\"+isoString, expected_second, mdt.getSecondOfMinute());\n+        }\n+    }\n+    /**\n+     * Test the <code>getSecondOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#getSecondOfDay()\n+     */\n+    public void testGetSecondOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GSOD1:\"+isoString, expected_secondofday, mdt.getSecondOfDay());\n+        }\n+    }\n+    /**\n+     * Test the <code>getMinuteOfHour()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMinuteOfHour()\n+     */\n+    public void testGetMinuteOfHour() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GMOH1:\"+isoString, expected_minute, mdt.getMinuteOfHour());\n+        }\n+    }\n+    /**\n+     * Test the <code>getMinuteOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#getMinuteOfDay()\n+     */\n+    public void testGetMinuteOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GMINOD1:\"+isoString,\n+                expected_minuteofday, mdt.getMinuteOfDay());\n+        }\n+    }\n+    /**\n+     * Test the <code>getHourOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#getHourOfDay()\n+     */\n+    public void testGetHourOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"GHOD1:\"+isoString, expected_hour,\n+                mdt.getHourOfDay());\n+        }\n+    }\n+    /**\n+     * Test the <code>dayOfWeek()</code> method.\n+     * @see org.joda.time.MutableDateTime#dayOfWeek()\n+     */\n+    public void testDayOfWeek() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"DOW1:\"+isoString, expected_dow,\n+                mdt.dayOfWeek().get() );\n+            assertEquals(\"DOW2:\"+isoString, expected_dow,\n+                mdt.dayOfWeek().getField().get(mdt.getMillis()));\n+            //\n+            assertEquals(\"DOW3:\"+isoString,\n+                dowShort[mdt.dayOfWeek().get()],\n+                mdt.dayOfWeek().getAsShortText() );\n+            assertEquals(\"DOW4:\"+isoString,\n+                dowLong[mdt.dayOfWeek().get()],\n+                mdt.dayOfWeek().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>dayOfMonth()</code> method.\n+     * @see org.joda.time.MutableDateTime#dayOfMonth()\n+     */\n+    public void testDayOfMonth() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"DOM1:\"+isoString, expected_day,\n+                mdt.dayOfMonth().getField().get(mdt.getMillis()));\n+            assertEquals(\"DOM2:\"+isoString, expected_day,\n+                mdt.dayOfMonth().getField().get(mdt.getMillis()));\n+            assertEquals(\"DOM3:\"+isoString,\n+                \"\"+expected_day, mdt.dayOfMonth().getAsShortText() );\n+            assertEquals(\"DOM4:\"+isoString,\n+                \"\"+expected_day, mdt.dayOfMonth().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>dayOfYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#dayOfYear()\n+     */\n+    public void testDayOfYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"DOY1:\"+isoString, expected_doy,\n+                mdt.dayOfYear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DOY2:\"+isoString, expected_doy,\n+                mdt.dayOfYear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DOY3:\"+isoString,\n+                \"\"+expected_doy, mdt.dayOfYear().getAsShortText() );\n+            assertEquals(\"DOY4:\"+isoString,\n+                \"\"+expected_doy, mdt.dayOfYear().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>weekOfYearWeek()</code> method.\n+     * @see org.joda.time.MutableDateTime#weekOfYearWeek()\n+     */\n+    public void testWeekOfWeekyear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"DWOYW1:\"+isoString, expected_woyw,\n+                mdt.weekOfWeekyear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DWOYW2:\"+isoString, expected_woyw,\n+                mdt.weekOfWeekyear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DWOYW3:\"+isoString,\n+                \"\"+expected_woyw, mdt.weekOfWeekyear().getAsShortText() );\n+            assertEquals(\"DWOYW4:\"+isoString,\n+                \"\"+expected_woyw, mdt.weekOfWeekyear().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>weekOfYearYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#weekOfYearYear()\n+     */\n+    public void testYearOfWeekyear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"DWOYY1:\"+isoString, expected_woyy,\n+                mdt.weekyear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DWOYY2:\"+isoString, expected_woyy,\n+                mdt.weekyear().getField().get(mdt.getMillis()));\n+            assertEquals(\"DWOYY3:\"+isoString,\n+                \"\"+expected_woyy, mdt.weekyear().getAsShortText() );\n+            assertEquals(\"DWOYY4:\"+isoString,\n+                \"\"+expected_woyy, mdt.weekyear().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>monthOfYear()</code> method.\n+     * @see org.joda.time.MutableDateTime#monthOfYear()\n+     */\n+    public void testMonthOfYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"MOY1:\"+isoString, expected_mon,\n+                mdt.monthOfYear().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOY2:\"+isoString, expected_mon,\n+                mdt.monthOfYear().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOY3:\"+isoString,\n+                moyShort[mdt.monthOfYear().getField().get(mdt.getMillis())],\n+                mdt.monthOfYear().getAsShortText() );\n+            assertEquals(\"MOY4:\"+isoString,\n+                moyLong[mdt.monthOfYear().getField().get(mdt.getMillis())],\n+                mdt.monthOfYear().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>year()</code> method.\n+     * @see org.joda.time.MutableDateTime#year()\n+     */\n+    public void testYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"Y1:\"+isoString, expected_year,\n+                mdt.year().getField().get(mdt.getMillis()));\n+            assertEquals(\"Y2:\"+isoString, expected_year,\n+                mdt.year().getField().get(mdt.getMillis()));\n+            assertEquals(\"Y3:\"+isoString, \"\"+expected_year, mdt.year().getAsShortText() );\n+            assertEquals(\"Y4:\"+isoString, \"\"+expected_year, mdt.year().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>yearOfEra()</code> method.\n+     * @see org.joda.time.MutableDateTime#yearOfEra()\n+     */\n+    /*\n+    public void testYearOfEra() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            int lty = Math.abs( expected_year );\n+            assertEquals(\"YOE1:\"+isoString, lty,\n+                mdt.yearOfEra().getField().get(mdt.getMillis()));\n+            assertEquals(\"YOE2:\"+isoString, lty,\n+                mdt.yearOfEra().getField().get(mdt.getMillis()));\n+            assertEquals(\"YOE3:\"+isoString, \"\"+lty, mdt.yearOfEra().getAsShortText() );\n+            assertEquals(\"YOE4:\"+isoString, \"\"+lty, mdt.yearOfEra().getAsText() );\n+        }\n+    }\n+    */\n+    /**\n+     * Test the <code>era()</code> method.\n+     * @see org.joda.time.MutableDateTime#era()\n+     */\n+    /*\n+    public void testEra() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            if ( gcals[ngc].get(Calendar.ERA) == GregorianCalendar.AD) {\n+                assertEquals(\"ERA1:\"+isoString, DateTimeConstants.AD,\n+                    mdt.era().getField().get(mdt.getMillis()));\n+                assertEquals(\"ERA2:\"+isoString, DateTimeConstants.AD,\n+                    mdt.era().getField().get(mdt.getMillis()));\n+                assertEquals(\"ERA3:\"+isoString, \"AD\", mdt.era().getAsShortText() );\n+                assertEquals(\"ERA4:\"+isoString, \"AD\", mdt.era().getAsText() );\n+            } else {\n+                assertEquals(\"ERA1:\"+isoString, DateTimeConstants.BC,\n+                    mdt.era().getField().get(mdt.getMillis()));\n+                assertEquals(\"ERA2:\"+isoString, DateTimeConstants.BC,\n+                    mdt.era().getField().get(mdt.getMillis()));\n+                assertEquals(\"ERA3:\"+isoString, \"BC\", mdt.era().getAsShortText() );\n+                assertEquals(\"ERA4:\"+isoString, \"BC\", mdt.era().getAsText() );\n+            }\n+        }\n+    }\n+    */\n+    /**\n+     * Test the <code>millisOfSecond()</code> method.\n+     * @see org.joda.time.MutableDateTime#millisOfSecond()\n+     */\n+    public void testMillisOfSecond() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"MOS1:\"+isoString,\n+                bumpValue, mdt.millisOfSecond().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOS2:\"+isoString,\n+                bumpValue, mdt.millisOfSecond().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOS3:\"+isoString,\n+                \"\"+bumpValue, mdt.millisOfSecond().getAsShortText() );\n+            assertEquals(\"MOS4:\"+isoString,\n+                \"\"+bumpValue, mdt.millisOfSecond().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>millisOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#millisOfDay()\n+     */\n+    public void testMillisOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"MLSOD1:\"+isoString,\n+                expected_millisofday,\n+                mdt.millisOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"MLSOD2:\"+isoString,\n+                expected_millisofday,\n+                mdt.millisOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"MLSOD3:\"+isoString,\n+                \"\"+expected_millisofday, mdt.millisOfDay().getAsShortText() );\n+            assertEquals(\"MLSOD4:\"+isoString,\n+                \"\"+expected_millisofday, mdt.millisOfDay().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>secondOfMinute()</code> method.\n+     * @see org.joda.time.MutableDateTime#secondOfMinute()\n+     */\n+    public void testSecondOfMinute() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"SOM1:\"+isoString, expected_second,\n+                mdt.secondOfMinute().getField().get(mdt.getMillis()));\n+            assertEquals(\"SOM2:\"+isoString, expected_second,\n+                mdt.secondOfMinute().getField().get(mdt.getMillis()));\n+            assertEquals(\"SOM3:\"+isoString,\n+                \"\"+expected_second, mdt.secondOfMinute().getAsShortText() );\n+            assertEquals(\"SOM4:\"+isoString,\n+                \"\"+expected_second, mdt.secondOfMinute().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>secondOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#secondOfDay()\n+     */\n+    public void testSecondOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"SOD1:\"+isoString, expected_secondofday,\n+                mdt.secondOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"SOD2:\"+isoString, expected_secondofday,\n+                mdt.secondOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"SOD3:\"+isoString, \"\"+expected_secondofday,\n+                mdt.secondOfDay().getAsShortText() );\n+            assertEquals(\"SOD4:\"+isoString, \"\"+expected_secondofday,\n+                mdt.secondOfDay().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>minuteOfHour()</code> method.\n+     * @see org.joda.time.MutableDateTime#minuteOfHour()\n+     */\n+    public void testMinuteOfHour() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"MOH1:\"+isoString, expected_minute,\n+                mdt.minuteOfHour().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOH2:\"+isoString, expected_minute,\n+                mdt.minuteOfHour().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOH3:\"+isoString,\n+                \"\"+expected_minute, mdt.minuteOfHour().getAsShortText() );\n+            assertEquals(\"MOH4:\"+isoString,\n+                \"\"+expected_minute, mdt.minuteOfHour().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>minuteOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#minuteOfDay()\n+     */\n+    public void testMinuteOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"MOD1:\"+isoString, expected_minuteofday,\n+                mdt.minuteOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOD2:\"+isoString, expected_minuteofday,\n+                mdt.minuteOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"MOD3:\"+isoString, \"\"+expected_minuteofday,\n+                mdt.minuteOfDay().getAsShortText() );\n+            assertEquals(\"MOD4:\"+isoString, \"\"+expected_minuteofday,\n+                mdt.minuteOfDay().getAsText() );\n+        }\n+    }\n+    /**\n+     * Test the <code>hourOfDay()</code> method.\n+     * @see org.joda.time.MutableDateTime#hourOfDay()\n+     */\n+    public void testHourOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            assertEquals(\"HOD1:\"+isoString, expected_hour,\n+                mdt.hourOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"HOD2:\"+isoString, expected_hour,\n+                mdt.hourOfDay().getField().get(mdt.getMillis()));\n+            assertEquals(\"HOD3:\"+isoString,\n+                \"\"+expected_hour, mdt.hourOfDay().getAsShortText() );\n+            assertEquals(\"HOD4:\"+isoString,\n+                \"\"+expected_hour, mdt.hourOfDay().getAsText() );\n+        }\n+    }\n+    private static boolean getsDone = false;\n+    /**\n+     * Test the <code>toString()</code> method.\n+     * @see org.joda.time.MutableDateTime#toString()\n+     */\n+    public void testToString() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            assertEquals(\"TOS1:\"+isoString,\n+                // isoString + \".\" + bumpValue + \"Z\",\n+                isoString,\n+                mdt.toString());\n+            /*\n+            assertEquals(\"TOS1:\"+isoString,\n+                isoString + \".\" + \"000\" + \"Z\",\n+                mdt.toString());\n+            */\n+        }\n+    }\n+\n+    public void testLast() {\n+        ewtr.println(\"TestMDTGet completes\");\n+        ewtr.flush();\n+    }\n+\n+    //-----------------------------------------------------------------\n+    //\n+    // Private methods.\n+    //\n+    //\n+    private  void prepTest(int item) {\n+        GregorianCalendar wrkgcal = new GregorianCalendar(\n+            gcals[item].get( Calendar.YEAR ),\n+            gcals[item].get( Calendar.MONTH ),\n+            gcals[item].get( Calendar.DATE ),\n+            gcals[item].get( Calendar.HOUR ),\n+            gcals[item].get( Calendar.MINUTE ),\n+            gcals[item].get( Calendar.SECOND )\n+        );\n+        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n+        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));\n+        //\n+        wrkgcal.add(Calendar.MILLISECOND, bumpValue);\n+        wrkgcal.setMinimalDaysInFirstWeek(4);\n+        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);\n+        //\n+        // Force the GregorianCalendar to recalculate all internal\n+        // values.\n+        //\n+        wrkgcal.setTime( wrkgcal.getTime() );\n+\n+        if ( debug ) {\n+            ewtr.println(\"====Test Number: \" + testNum);\n+            ewtr.println(\"  ==Item Number: \" + item);\n+            ewtr.flush();\n+        }\n+        isoString = getDateTimeString( wrkgcal );\n+        mdt = null;\n+        try\n+        {\n+            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n+        }\n+        catch(ParseException pe)\n+        {\n+            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println( pe.getMessage() );\n+            ewtr.flush();\n+        }\n+        if ( debug ) {\n+            ewtr.println(\"    =ISO String: \" + isoString);\n+            ewtr.flush();\n+        }\n+        //\n+        // When it is easy to do, we locally calculate test comparison\n+        // values rather than depend on Java Calendar's.\n+        // If it is not fairly convenient, we call the Calendar's\n+        // get method.\n+        //\n+        // However, the following is very ugly code and needs to be\n+        // cleaned up.\n+        //\n+        int pb = 0;\n+        if ( isoString.substring(0,1).equals(\"-\") ) {\n+            pb = 1;\n+        }\n+        //\n+        // Calculate expected values.\n+        //\n+        expected_gcmillis = wrkgcal.getTime().getTime();\n+        //\n+        expected_year = getPartValue( isoString.substring(0+pb,4+pb) );\n+        if ( pb == 1 ) {\n+            expected_year = -expected_year;\n+        }\n+        //\n+        expected_mon = getPartValue( isoString.substring(5+pb,7+pb) );\n+        expected_day = getPartValue( isoString.substring(8+pb,10+pb) );\n+        expected_hour = getPartValue( isoString.substring(11+pb,13+pb) );\n+        expected_minute = getPartValue( isoString.substring(14+pb,16+pb) );\n+        expected_second = getPartValue( isoString.substring(17+pb,19+pb) );\n+        //\n+        expected_doy = wrkgcal.get(Calendar.DAY_OF_YEAR);\n+        expected_dow = wrkgcal.get(Calendar.DAY_OF_WEEK) - 1;\n+        expected_dow = (expected_dow <= 0 ? 7 : expected_dow);\n+        //\n+        expected_woyw = wrkgcal.get(Calendar.WEEK_OF_YEAR);\n+        if (expected_woyw == 1) {\n+            wrkgcal.add(Calendar.DATE, +7);\n+        } else if (expected_woyw > 51) {\n+            wrkgcal.add(Calendar.DATE, -14);\n+        }\n+        expected_woyy = wrkgcal.get(Calendar.YEAR);\n+        if ( wrkgcal.get(Calendar.ERA) == GregorianCalendar.BC ) {\n+            expected_woyy = -(expected_woyy-1);\n+        }\n+        //\n+        expected_millisofday = expected_hour * DateTimeConstants.MILLIS_PER_HOUR\n+            + expected_minute * DateTimeConstants.MILLIS_PER_MINUTE\n+            + expected_second * DateTimeConstants.MILLIS_PER_SECOND\n+            + bumpValue;\n+        expected_secondofday = expected_hour * DateTimeConstants.SECONDS_PER_HOUR\n+            + expected_minute * DateTimeConstants.SECONDS_PER_MINUTE\n+            + expected_second;\n+        expected_minuteofday = expected_hour * DateTimeConstants.MINUTES_PER_HOUR\n+            + expected_minute;\n+        return;\n+    }\n+} // end of class TestMDTGet\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.*;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ * This currently forces tests using GMT only.\n+ *\n+ * @author Guy Allard\n+ */\n+public class TestMDTSet extends BulkTest {\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMDTSet.class);\n+    }\n+    /**\n+     * TestMDTSet constructor.\n+     * @param name\n+     */\n+    public TestMDTSet(String name) {\n+        super(name);\n+    }\n+    // Class Name: org.joda.time.MutableDateTime\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        // super.setUp();\n+        ++testNum;\n+        TimeZone.setDefault( new SimpleTimeZone(0, \"UTC\") );\n+        gcals = gcals0;\n+        // gcals = gcalsMiscBunch;\n+    }\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+\n+    private boolean debug = true;\n+    private static int testNum = 0;\n+    private PrintStream ewtr = System.err;\n+    /**\n+     *\n+     */\n+    Long longVal = null;\n+    /**\n+     *\n+     */\n+    boolean failed;\n+    // Developers/Testers Note:\n+    //\n+    // 1) Construct any valid array of Gregorian calendar objects,\n+    //    e.g. 'gcals1' below.\n+    // 2) Change the assignment statement in the setUp() method.\n+    // 3) Recompile+jar.\n+    //\n+    // The new array will be used in all the tests.\n+    //\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals0 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcals1 = {\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 2, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 0, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 2, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsGJCutOver = {\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsPreCut = {\n+        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),\n+        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),\n+        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),\n+        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),\n+    };\n+\n+    GregorianCalendar[] gcalsYear0 = {\n+        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),\n+    };\n+    GregorianCalendar[] gcalsYearM1 = {\n+        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    GregorianCalendar[] gcalsEndPoints = {\n+        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),\n+    };\n+    // This don't work.  ParseException from the CTOR.\n+    GregorianCalendar[] gcalsOutSide = {\n+        new GregorianCalendar(+76542, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(-12345, Calendar.JANUARY, 1, 0, 0, 0),\n+    };\n+    //\n+    GregorianCalendar[] gcalsMiscBunch = {\n+        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),\n+        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),\n+        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),\n+        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),\n+        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),\n+        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),\n+        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),\n+        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(1999, 2, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 0, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 1, 1, 0, 0, 0),\n+        new GregorianCalendar(2000, 2, 1, 0, 0, 0),\n+    };\n+    /**\n+     *\n+     */\n+    ReadableInstant rica = null;\n+    /**\n+     *\n+     */\n+    Chronology cronca = null;\n+    /**\n+     *\n+     */\n+    Date jdtca = null;\n+    /**\n+     *\n+     */\n+    Calendar calca = null;\n+\n+    /**\n+     *\n+     */\n+    GregorianCalendar[] gcals = null;\n+    /**\n+     *\n+     */\n+    final int bumpValue = 385;\n+    // final int bumpValue = 0;\n+    /**\n+     *\n+     */\n+    // GregorianCalendar gcal = null;\n+    /**\n+     *\n+     */\n+    String isoString = null;\n+    /**\n+     *\n+     */\n+    MutableDateTime mdt = null;\n+    /**\n+     *\n+     */\n+    Chronology chrona = null;\n+    /**\n+     *\n+     */\n+    long setMillis = -1L;\n+    /**\n+     *\n+     */\n+    int setYear = -1;\n+    int setMonth = -1;\n+    int setDay = -1;\n+    int setHour = -1;\n+    int setMinute = -1;\n+    int setSecond = -1;\n+    int setMillisecond = -1;\n+    String setString = null;\n+    String yearStr = null;\n+    String monthStr = null;\n+    String dayStr = null;\n+    String hourStr = null;\n+    String minuteStr = null;\n+    String secondStr = null;\n+    String millisecondStr = null;\n+    //\n+    // Long longVal = null;\n+    //\n+    boolean getsDone = true;\n+    //\n+    // Test 'set' methods - 2nd.\n+    //\n+    //----------------------------------------------------------------\n+    //\n+    // Sets of Millis value.\n+    //\n+    /**\n+     * Test the <code>setMillis(long)</code> method.\n+     * @see org.joda.time.MutableDateTime#setMillis(long)\n+     */\n+    public void testSetMillisL() {\n+        getsDone = true;\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            mdt.setMillis( setMillis );\n+            assertEquals(\"SML1:\"+isoString+\":\"+setString,\n+                mdt.getMillis(), setMillis);\n+        }\n+    }\n+    /**\n+     * Test the <code>setMillis(java.lang.Object)</code> method.\n+     * @see org.joda.time.MutableDateTime#setMillis(java.lang.Object)\n+     */\n+    public void testSetMillisO() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            //ewtr.println(\"getsDone: \" + getsDone);\n+            //ewtr.println(\"rica: \" + rica);\n+            //ewtr.flush();\n+            mdt.setMillis( rica );\n+            assertEquals(\"SMO1:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+            //\n+            mdt.setMillis( jdtca );\n+            assertEquals(\"SMO2:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+            //\n+            mdt.setMillis( calca );\n+            assertEquals(\"SMO3:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+            //\n+            mdt.setMillis( longVal );\n+            assertEquals(\"SMO4:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+            //\n+            mdt.setMillis( setString );\n+            assertEquals(\"SMO5:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+            //\n+            failed = false;\n+            rica = null;\n+            try\n+            {\n+                mdt.setMillis( rica );\n+            }\n+            catch(IllegalArgumentException iae)\n+            {\n+                failed = true;\n+            }\n+            if ( !failed ) {\n+                fail(\"SMO6:null\");\n+            }\n+        }\n+    }\n+    //\n+    // Set of individual fields through individual DateTe=imeFields.\n+    //\n+    /**\n+     * Test the <code>set(org.joda.time.DateTimeField, int)</code> method.\n+     * @see org.joda.time.MutableDateTime#set(org.joda.time.DateTimeField, int)\n+     */\n+    public void testSetDTFI() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            mdt.set( mdt.year().getField(), setYear );\n+            mdt.set( mdt.monthOfYear().getField(), setMonth );\n+            mdt.set( mdt.dayOfMonth().getField(), setDay );\n+            mdt.set( mdt.hourOfDay().getField(), setHour );\n+            mdt.set( mdt.minuteOfHour().getField(), setMinute );\n+            mdt.set( mdt.secondOfMinute().getField(), setSecond );\n+            mdt.set( mdt.millisOfSecond().getField(), setMillisecond );\n+            //ewtr.println(\"setString: \" + setString);\n+            //ewtr.println(\"mdt: \" + mdt);\n+            assertEquals(\"DTFI1:\"+isoString+\":\"+setString,\n+                setString, \"\"+mdt);\n+        }\n+    }\n+    //\n+    // Sets of the date portion.\n+    //\n+    /**\n+     * Test the <code>setDate(long)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDate(long)\n+     */\n+    public void testSetDateL() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            String before = \"\" + mdt;\n+            mdt.setDate( setMillis );\n+            String after = \"\" + mdt;\n+            assertEquals(\"SDL1:\",\n+                rhsDT(before), rhsDT(after) );\n+            assertEquals(\"SDL2:\",\n+                lhsDT(setString), lhsDT(after) );\n+        }\n+    }\n+    /**\n+     * Test the <code>setDate(java.lang.Object)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDate(java.lang.Object)\n+     */\n+    public void testSetDateO() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            //\n+            String before = \"\" + mdt;\n+            String rhsBefore = rhsDT( before );\n+            //\n+            mdt.setDate( rica );\n+            String after = \"\" + mdt;\n+            String rhsAfter = rhsDT( after );\n+            assertEquals(\"SDO1:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"SDO1A:\",\n+                lhsDT(setString), lhsDT(after));\n+            //\n+            mdt.setDate( jdtca );\n+            after = \"\" + mdt;\n+            rhsAfter = rhsDT( after );\n+            assertEquals(\"SDO2:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"SDO2A:\",\n+                lhsDT(setString), lhsDT(after));\n+            //\n+            mdt.setDate( calca );\n+            after = \"\" + mdt;\n+            rhsAfter = rhsDT( after );\n+            assertEquals(\"SDO3:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"SDO3A:\",\n+                lhsDT(setString), lhsDT(after));\n+            //\n+            mdt.setDate( longVal );\n+            after = \"\" + mdt;\n+            rhsAfter = rhsDT( after );\n+            assertEquals(\"SDO4:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"SDO4A:\",\n+                lhsDT(setString), lhsDT(after));\n+            //\n+            mdt.setDate( setString );\n+            after = \"\" + mdt;\n+            rhsAfter = rhsDT( after );\n+            assertEquals(\"SDO5:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"SDO5A:\",\n+                lhsDT(setString), lhsDT(after));\n+            //\n+            failed = false;\n+            rica = null;\n+            try\n+            {\n+                mdt.setDate( rica );\n+            }\n+            catch(IllegalArgumentException iae)\n+            {\n+                failed = true;\n+            }\n+            if ( !failed ) {\n+                fail(\"SDO6:null\");\n+            }\n+\n+        }\n+    }\n+    /**\n+     * Test the <code>setDate(int, int, int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDate(int, int, int)\n+     */\n+    public void testSetDateIII() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            //\n+            String before = \"\" + mdt;\n+            String rhsBefore = rhsDT( before );\n+            //\n+            mdt.setDate( setYear, setMonth, setDay );\n+            //\n+            String after = \"\" + mdt;\n+            String rhsAfter = rhsDT( after );\n+            assertEquals(\"DIII1:\",\n+                rhsBefore, rhsAfter);\n+            assertEquals(\"DIII1A:\",\n+                lhsDT(setString), lhsDT(after));\n+        }\n+    }\n+    //\n+    // Sets of the time portion of the DT.\n+    //\n+    /**\n+     * Test the <code>setTime(long)</code> method.\n+     * @see org.joda.time.MutableDateTime#setTime(long)\n+     */\n+    public void testSetTimeL() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            String before = \"\" + mdt;\n+            mdt.setTime( setMillis );\n+            String after = \"\" + mdt;\n+            assertEquals(\"SDL1:\",\n+                lhsDT(before), lhsDT(after) );\n+            assertEquals(\"SDL2:\",\n+                rhsDT(setString), rhsDT(after) );\n+        }\n+    }\n+    /**\n+     * Test the <code>setTime(java.lang.Object)</code> method.\n+     * @see org.joda.time.MutableDateTime#setTime(java.lang.Object)\n+     */\n+    public void testSetTimeO() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            String before = \"\" + mdt;\n+            String lhsBefore = lhsDT( before );\n+            //\n+            mdt.setTime( rica );\n+            String after = \"\" + mdt;\n+            String lhsAfter = lhsDT( after );\n+\n+            // ewtr.println(\"before: \" + before);\n+            // ewtr.println(\"after: \" + after);\n+            // ewtr.println(\"setString: \" + setString);\n+            // ewtr.flush();\n+\n+            assertEquals(\"STO1:\",\n+                lhsBefore, lhsAfter);\n+            assertEquals(\"STO1A:\",\n+                rhsDT(setString), rhsDT(after));\n+            //\n+            mdt.setTime( jdtca );\n+            after = \"\" + mdt;\n+            lhsAfter = lhsDT( after );\n+            assertEquals(\"STO2:\",\n+                lhsBefore, lhsAfter);\n+            assertEquals(\"STO2A:\",\n+                rhsDT(setString), rhsDT(after));\n+            //\n+            mdt.setTime( calca );\n+            after = \"\" + mdt;\n+            lhsAfter = lhsDT( after );\n+            assertEquals(\"STO3:\",\n+                lhsBefore, lhsAfter);\n+            assertEquals(\"STO3A:\",\n+                rhsDT(setString), rhsDT(after));\n+            //\n+            mdt.setTime( longVal );\n+            after = \"\" + mdt;\n+            lhsAfter = lhsDT( after );\n+            assertEquals(\"STO4:\",\n+                lhsBefore, lhsAfter);\n+            assertEquals(\"STO4A:\",\n+                rhsDT(setString), rhsDT(after));\n+            //\n+            mdt.setTime( setString );\n+            after = \"\" + mdt;\n+            lhsAfter = lhsDT( after );\n+            assertEquals(\"STO5:\",\n+                lhsBefore, lhsAfter);\n+            assertEquals(\"STO5A:\",\n+                rhsDT(setString), rhsDT(after));\n+            //\n+            failed = false;\n+            rica = null;\n+            try\n+            {\n+                mdt.setTime( rica );\n+            }\n+            catch(IllegalArgumentException iae)\n+            {\n+                failed = true;\n+            }\n+            if ( !failed ) {\n+                fail(\"STO6:null\");\n+            }\n+\n+        }\n+    }\n+    /**\n+     * Test the <code>setTime(int, int, int, int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setTime(int, int, int, int)\n+     */\n+    public void testSetTimeIIII() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            String before = \"\" + mdt;\n+            mdt.setTime( setHour, setMinute, setSecond, setMillisecond );\n+            String after = \"\" + mdt;\n+            assertEquals(\"TIII1:\",\n+                lhsDT(before), lhsDT(after) );\n+            assertEquals(\"TIII2:\",\n+                rhsDT(setString), rhsDT(after) );\n+        }\n+    }\n+    //\n+    // Sets of both the Date and Time portions.\n+    //\n+    /**\n+     * Test the <code>setDateTime(long)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDateTime(long)\n+     */\n+    public void testSetDateTimeL() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            mdt.setDateTime( setMillis );\n+            assertEquals(\"SDT1:\",\n+                setString, \"\"+mdt );\n+        }\n+    }\n+    /**\n+     * Test the <code>setDateTime(java.lang.Object)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDateTime(java.lang.Object)\n+     */\n+    public void testSetDateTimeO() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            //\n+            mdt.setDateTime( rica );\n+            assertEquals(\"SDTO1:\",\n+                setString, \"\"+mdt );\n+            //\n+            mdt.setDateTime( jdtca );\n+            assertEquals(\"SDTO2:\",\n+                setString, \"\"+mdt );\n+            //\n+            mdt.setDateTime( calca );\n+            assertEquals(\"SDTO3:\",\n+                setString, \"\"+mdt );\n+            //\n+            mdt.setDateTime( longVal );\n+            assertEquals(\"SDTO4:\",\n+                setString, \"\"+mdt );\n+            //\n+            mdt.setDateTime( setString );\n+            assertEquals(\"SDTO5:\",\n+                setString, \"\"+mdt );\n+            //\n+            failed = false;\n+            rica = null;\n+            try\n+            {\n+                mdt.setDateTime( rica );\n+            }\n+            catch(IllegalArgumentException iae)\n+            {\n+                failed = true;\n+            }\n+            if ( !failed ) {\n+                fail(\"SDTO6:null\");\n+            }\n+        }\n+    }\n+    /**\n+     * Test the <code>setDateTime(int, int, int, int, int, int, int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDateTime(int, int, int, int, int, int, int)\n+     */\n+    public void testSetDateTimeIs() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+            mdt.setDateTime( setYear, setMonth, setDay,\n+                setHour, setMinute, setSecond, setMillisecond );\n+            assertEquals(\"SDTIIs\",\n+                setString, \"\"+mdt );\n+        }\n+    }\n+    //\n+    // Individual field sets.\n+    //\n+    /**\n+     * Test the <code>setYear(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setYear(int)\n+     */\n+    public void testSetYear() {\n+\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setYear( setYear );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {3,5,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSYR1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(1);\n+            assertEquals(\"TSYR2\",\n+                e, padNumberToLen(setYear,e.length())\n+            );\n+        }\n+\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.year().set( setYear );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {3,5,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSYR1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(1);\n+            assertEquals(\"TSYR2\",\n+                e, padNumberToLen(setYear,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setMonthOfYear(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setMonthOfYear(int)\n+     */\n+    public void testSetMonthOfYear() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setMonthOfYear( setMonth );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,5,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMO1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(3);\n+            assertEquals(\"TSMO2\",\n+                e, padNumberToLen(setMonth,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.monthOfYear().set( setMonth );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,5,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMO1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(3);\n+            assertEquals(\"TSMO2\",\n+                e, padNumberToLen(setMonth,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setDayOfMonth(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDayOfMonth(int)\n+     */\n+    public void testSetDayOfMonth() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setDayOfMonth( setDay );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSDA1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(5);\n+            assertEquals(\"TSDA2\",\n+                e, padNumberToLen(setDay,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.dayOfMonth().set( setDay );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,7,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSDA1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(5);\n+            assertEquals(\"TSDA2\",\n+                e, padNumberToLen(setDay,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setHourOfDay(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setHourOfDay(int)\n+     */\n+    public void testSetHourOfDay() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setHourOfDay( setHour );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSHD1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(7);\n+            assertEquals(\"TSHD2\",\n+                e, padNumberToLen(setHour,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.hourOfDay().set( setHour );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,9,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSHD1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(7);\n+            assertEquals(\"TSHD2\",\n+                e, padNumberToLen(setHour,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setMinuteOfHour(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setMinuteOfHour(int)\n+     */\n+    public void testSetMinuteOfHour() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setMinuteOfHour( setHour );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMH1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(9);\n+            assertEquals(\"TSMH2\",\n+                e, padNumberToLen(setHour,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.minuteOfHour().set( setHour );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,11,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMH1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(9);\n+            assertEquals(\"TSMH2\",\n+                e, padNumberToLen(setHour,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setSecondOfMinute(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setSecondOfMinute(int)\n+     */\n+    public void testSetSecondOfMinute() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setSecondOfMinute( setSecond );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,9,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSSM1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(11);\n+            assertEquals(\"TSSM2\",\n+                e, padNumberToLen(setSecond,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.secondOfMinute().set( setSecond );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,9,13};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSSM1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(11);\n+            assertEquals(\"TSSM2\",\n+                e, padNumberToLen(setSecond,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setMillisOfSecond(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setMillisOfSecond(int)\n+     */\n+    public void testSetMillisOfSecond() {\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.setMillisOfSecond( setMillisecond );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,9,11};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMS1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(13);\n+            assertEquals(\"TSMS2\",\n+                e, padNumberToLen(setMillisecond,e.length())\n+            );\n+        }\n+        for (int ngc = 0; ngc < gcals.length; ++ngc) {\n+            prepTest( ngc );\n+\n+            ArrayList before = getDTA( \"\"+mdt );\n+            mdt.millisOfSecond().set( setMillisecond );\n+            ArrayList after = getDTA( \"\"+mdt );\n+\n+            int[] mc = {1,3,5,7,9,11};\n+            for (int i = 0; i < mc.length; ++i) {\n+                assertEquals(\"TSMS1\",\n+                    \"\"+(String)before.get(mc[i]),\n+                    \"\"+(String)after.get(mc[i])\n+                );\n+            }\n+            String e = (String)after.get(13);\n+            assertEquals(\"TSMS2\",\n+                e, padNumberToLen(setMillisecond,e.length())\n+            );\n+        }\n+    }\n+    /**\n+     * Test the <code>setDayOfYear(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDayOfYear(int)\n+     */\n+    public void testSetDayOfYear() {\n+        //\n+        ewtr.println(\"testSetDayOfYear needs enhancement\");\n+        ewtr.flush();\n+        //\n+        String ts = \"1776-07-04T11:22:33.000Z\";\n+        //\n+        mdt = getMDTFromString( ts );\n+        mdt.setDayOfYear( 8 );\n+        assertEquals(\"SDOY1\",\n+            \"1776-01-08T11:22:33.000Z\",\n+            mdt.toString() );\n+\n+        mdt = getMDTFromString( ts );\n+        mdt.setDayOfYear( 60 );\n+        assertEquals(\"SDOY2\",\n+            \"1776-02-29T11:22:33.000Z\",\n+            mdt.toString() );\n+\n+        mdt = getMDTFromString( ts );\n+        mdt.setDayOfYear( 366 );\n+        assertEquals(\"SDOY3\",\n+            \"1776-12-31T11:22:33.000Z\",\n+            mdt.toString() );\n+\n+        mdt = getMDTFromString( ts );\n+        failed = false;\n+        try\n+        {\n+            mdt.setDayOfYear( 367 );\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            failed = true;\n+        }\n+        if ( !failed ) {\n+            fail(\"SDOY4\");\n+        }\n+\n+        mdt = getMDTFromString( \"1777-12-31T11:22:33.000Z\" );\n+        failed = false;\n+        try\n+        {\n+            mdt.setDayOfYear( 366 );\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            failed = true;\n+        }\n+        if ( !failed ) {\n+            fail(\"SDOY4\");\n+        }\n+    }\n+    /**\n+     * Test the <code>setDayOfWeek(int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setDayOfWeek(int)\n+     */\n+    public void testSetDayOfWeek() {\n+        //\n+        ewtr.println(\"testSetDayOfWeek needs enhancement\");\n+        ewtr.flush();\n+        String ts = \"1776-07-04T11:22:33.000Z\";\n+        //\n+        mdt = getMDTFromString( ts );\n+\n+        mdt.setDayOfWeek( DateTimeConstants.MONDAY );\n+        assertEquals(\"SDOW1\",\n+            \"1776-07-01T11:22:33.000Z\",\n+            mdt.toString() );\n+\n+        mdt.setDayOfWeek( DateTimeConstants.SUNDAY );\n+        assertEquals(\"SDOW2\",\n+            \"1776-07-07T11:22:33.000Z\",\n+            mdt.toString() );\n+        //\n+        failed = false;\n+        try\n+        {\n+            mdt.setDayOfWeek( 8 );\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            failed = true;\n+        }\n+        if ( !failed ) {\n+            fail(\"SWOY4\");\n+        }\n+\n+\n+    }\n+    /**\n+     * Test the <code>setWeekOfYear(int, int)</code> method.\n+     * @see org.joda.time.MutableDateTime#setWeekOfYear(int, int)\n+     */\n+    public void testSetWeekOfYear() {\n+        ewtr.println(\"testSetWeekOfYear needs enhancement\");\n+        ewtr.flush();\n+        String ts = \"1776-07-04T11:22:33.000Z\";\n+        //\n+        mdt = getMDTFromString( ts );\n+\n+        mdt.setWeekyear( 1944 );\n+        mdt.setWeekOfWeekyear( 2 );\n+        assertEquals(\"SWOY1\", 2, mdt.getWeekOfWeekyear());\n+        assertEquals(\"SWOY2\", 1944, mdt.getWeekyear());\n+        assertEquals(\"SWOY3\",\n+            \"1944-01-13T11:22:33.000Z\",\n+            mdt.toString() );\n+        //\n+        failed = false;\n+        try\n+        {\n+            mdt.setWeekyear( 2003 );\n+            mdt.setWeekOfWeekyear( 53 ); // 03 has 52 weeks\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            failed = true;\n+        }\n+        if ( !failed ) {\n+            fail(\"SWOY4\");\n+        }\n+        //\n+        failed = false;\n+        try\n+        {\n+            mdt.setWeekyear( 2004 );\n+            mdt.setWeekOfWeekyear( 53 ); // 03 has 52 weeks\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            failed = true;\n+        }\n+        if ( failed ) {\n+            fail(\"SWOY5\");\n+        }\n+    }\n+\n+    public void testLast() {\n+        ewtr.println(\"TestMDTSet completes\");\n+        ewtr.flush();\n+    }\n+\n+    //-----------------------------------------------------------------\n+    //\n+    // Private methods.\n+    //\n+    //\n+    private  void prepTest(int item) {\n+        GregorianCalendar wrkgcal = new GregorianCalendar(\n+            gcals[item].get( Calendar.YEAR ),\n+            gcals[item].get( Calendar.MONTH ),\n+            gcals[item].get( Calendar.DATE ),\n+            gcals[item].get( Calendar.HOUR ),\n+            gcals[item].get( Calendar.MINUTE ),\n+            gcals[item].get( Calendar.SECOND )\n+        );\n+        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n+        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));\n+        //\n+        wrkgcal.add(Calendar.MILLISECOND, bumpValue);\n+        wrkgcal.setMinimalDaysInFirstWeek(4);\n+        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);\n+        //\n+        // Force the GregorianCalendar to recalculate all internal\n+        // values.\n+        //\n+        wrkgcal.setTime( wrkgcal.getTime() );\n+\n+        if ( debug ) {\n+            ewtr.println(\"====Test Number: \" + testNum);\n+            ewtr.println(\"  ==Item Number: \" + item);\n+            ewtr.flush();\n+        }\n+        isoString = getDateTimeString( wrkgcal );\n+        mdt = null;\n+        try\n+        {\n+            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );\n+        }\n+        catch(ParseException pe)\n+        {\n+            ewtr.println(\"ParseException Detected: \" + isoString);\n+            ewtr.println( pe.getMessage() );\n+            ewtr.flush();\n+        }\n+\n+        if ( debug ) {\n+            ewtr.println(\"    =ISO String: \" + isoString);\n+            ewtr.flush();\n+        }\n+\n+        setMillis = System.currentTimeMillis();\n+        GregorianCalendar gx = new GregorianCalendar();\n+        gx.setTime( new Date( setMillis ) );\n+        //\n+        setYear = gx.get(Calendar.YEAR);\n+        setMonth = gx.get(Calendar.MONTH) + 1;\n+        setDay = gx.get(Calendar.DATE);\n+        setHour = gx.get(Calendar.HOUR_OF_DAY);\n+        setMinute = gx.get(Calendar.MINUTE);\n+        setSecond = gx.get(Calendar.SECOND);\n+        setMillisecond = gx.get(Calendar.MILLISECOND);\n+        //\n+        rica = new Instant( setMillis );\n+        jdtca = new Date( setMillis );\n+        calca = Calendar.getInstance();\n+        calca.setTime( jdtca );\n+        longVal = new Long( setMillis );\n+        //\n+        MutableDateTime temp = new MutableDateTime( setMillis,\n+            ISOChronology.getInstanceUTC() );\n+        setString = \"\" + temp;\n+    }\n+} // end of class TestMDTSet\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.util.*;\n+import java.text.* ;\n+import java.io.*;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the\n+ * org.joda.time.MutableDateTime class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestMutableDateTime\n+    extends BulkTest {\n+\n+    private static Class cls = MutableDateTime.class;\n+\n+    /**\n+     * main\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMutableDateTime.class);\n+    }\n+    /**\n+     * TestMutableDateTime constructor.  A constructor with this signature\n+     * is required for Junit testing.\n+     * @param name The human readable name of the class.\n+     */\n+    public TestMutableDateTime(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        // TimeZone.setDefault( new SimpleTimeZone(0, \"UTC\") );\n+    }\n+    \n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        // super.tearDown();\n+    }\n+\n+    //\n+    // No CTOR test methods are provided here!\n+    // All MutableDateTime CTORs map directly to AbstractDateTime\n+    // CTORS, and all each MDT CTOR does is call super.\n+    //\n+    // New CTOR tests are required only for:\n+    // 1) CTORs which do *NOT* call super(...) at all.\n+    // 1) CTORs which do *NOT* call super(...) with a matching signature.\n+    // 2) CTORs with differing method signatures (new at this level).\n+    //\n+    // Add Other BulkTests\n+    //\n+    public BulkTest bulkTestGet() {\n+        return new TestMDTGet(\"Mutable Date Time get Method Tests\");\n+    }\n+\n+    public BulkTest bulkTestSet() {\n+        return new TestMDTSet(\"Mutable Date Time set Method Tests\");\n+    }\n+\n+} // end of class TestMutableDateTime\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DateTime;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.gj.GJChronology;\n+import org.joda.time.chrono.iso.ISOChronology;\n+/**\n+ * This class is a Junit unit test for the CTORs of the\n+ * MutableDateTime date time class.  The MutableDateTime class is passed\n+ * to the base class, which actually invokes the proper\n+ * constructors.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestMutableDateTimeCtors\n+       extends AbstractTestDateTimeCommon {\n+\n+    // The class to be tested.\n+    private static Class cls = MutableDateTime.class;\n+\n+    /**\n+     * This is the main class for this test suite.\n+     * @param args command line arguments.\n+     */\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    /**\n+     * TestSuite is a junit required method.\n+     */\n+    public static TestSuite suite() {\n+        return BulkTest.makeSuite(TestMutableDateTimeCtors.class);\n+    }\n+    /**\n+     * Constructor.\n+     * @param name\n+     */\n+    public TestMutableDateTimeCtors(String name) {\n+        super(name, cls);\n+    }\n+    /**\n+     * Constructor\n+     * @param name The class name.\n+     * @param cls The class to be tested.\n+     */\n+    public TestMutableDateTimeCtors(String name, Class cls) {\n+        super(name, cls);\n+        TestMutableDateTimeCtors.cls = cls;\n+    }\n+    /**\n+     * Junit <code>setUp()</code> method.\n+     */\n+    protected void setUp() /* throws Exception */ {\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Junit <code>tearDown()</code> method.\n+     */\n+    protected void tearDown() /* throws Exception */ {\n+        super.tearDown();\n+    }\n+    \n+    protected ReadableInstant createSmall(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(-1L * 1000, GJChronology.getInstance());\n+        }\n+        return new MutableDateTime(-1L * 1000);\n+    }\n+    \n+    protected ReadableInstant createMid(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(2L * 1000, GJChronology.getInstance());\n+        }\n+        return new MutableDateTime((2L * 1000));\n+    }\n+    \n+    protected ReadableInstant createLarge(boolean ofAnotherClass) {\n+        if (ofAnotherClass) {\n+            return new DateTime(3L * 1000, GJChronology.getInstance());\n+        }\n+        return new MutableDateTime((3L * 1000));\n+    }\n+\n+    protected ReadableInstant createUTC(long millis) {\n+        return new MutableDateTime(millis, ISOChronology.getInstance(DateTimeZone.UTC));\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestTimePeriod.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+//import java.util.*;\n+//import java.text.* ;\n+import junit.framework.TestSuite;\n+//import org.joda.time.*;\n+//import org.joda.time.gj.*;\n+//import org.joda.time.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * GJTimePeriod date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestTimePeriod extends BulkTest {\n+\n+\t/**\n+\t * This is the main class for this test suite.\n+\t * @param args command line arguments.\n+\t */\n+\tpublic static void main(String[] args) {\n+\t\tjunit.textui.TestRunner.run(suite());\n+\t}\n+\t/**\n+\t * TestSuite is a junit required method.\n+\t */\n+\tpublic static TestSuite suite() {\n+\t\treturn BulkTest.makeSuite(TestTimePeriod.class);\n+\t}\n+\t/**\n+\t * TestDateTimeField constructor.\n+\t * @param name\n+\t */\n+\tpublic TestTimePeriod(String name) {\n+\t\tsuper(name);\n+\t}\n+\t// Class Name: org.joda.time.TimePeriod\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tprotected void setUp() /* throws Exception */ {\n+\t\t// super.setUp();\n+\t}\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+\t\t// super.tearDown();\n+\t}\n+\t/**\n+\t * Test the <code>clone()</code> method.\n+\t * @see org.joda.time.TimePeriod#clone()\n+\t */\n+\tpublic void testClone() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>format(java.text.Format)</code> method.\n+\t * @see org.joda.time.TimePeriod#format(java.text.Format)\n+\t */\n+\tpublic void testFormat() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getMillis()</code> method.\n+\t * @see org.joda.time.TimePeriod#getMillis()\n+\t */\n+\tpublic void testGetMillis() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getStartInstant()</code> method.\n+\t * @see org.joda.time.TimePeriod#getStartInstant()\n+\t */\n+\tpublic void testGetStartInstant() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getEndInstant()</code> method.\n+\t * @see org.joda.time.TimePeriod#getEndInstant()\n+\t */\n+\tpublic void testGetEndInstant() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>toTimePeriod()</code> method.\n+\t * @see org.joda.time.TimePeriod#toTimePeriod()\n+\t */\n+\tpublic void testToTimePeriod() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalSeconds()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalSeconds()\n+\t */\n+\tpublic void testGetTotalSeconds() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalMinutes()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalMinutes()\n+\t */\n+\tpublic void testGetTotalMinutes() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalHours()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalHours()\n+\t */\n+\tpublic void testGetTotalHours() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalDays()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalDays()\n+\t */\n+\tpublic void testGetTotalDays() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalMonths()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalMonths()\n+\t */\n+\tpublic void testGetTotalMonths() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getTotalWeeks()</code> method.\n+\t * @see org.joda.time.TimePeriod#getTotalWeeks()\n+\t */\n+\tpublic void testGetTotalWeeks() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getSeconds()</code> method.\n+\t * @see org.joda.time.TimePeriod#getSeconds()\n+\t */\n+\tpublic void testGetSeconds() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getMinutes()</code> method.\n+\t * @see org.joda.time.TimePeriod#getMinutes()\n+\t */\n+\tpublic void testGetMinutes() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getHours()</code> method.\n+\t * @see org.joda.time.TimePeriod#getHours()\n+\t */\n+\tpublic void testGetHours() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getDays()</code> method.\n+\t * @see org.joda.time.TimePeriod#getDays()\n+\t */\n+\tpublic void testGetDays() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getMonths()</code> method.\n+\t * @see org.joda.time.TimePeriod#getMonths()\n+\t */\n+\tpublic void testGetMonths() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>getYears()</code> method.\n+\t * @see org.joda.time.TimePeriod#getYears()\n+\t */\n+\tpublic void testGetYears() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>equals(java.lang.Object)</code> method.\n+\t * @see org.joda.time.TimePeriod#equals(java.lang.Object)\n+\t */\n+\tpublic void testEquals() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>hashCode()</code> method.\n+\t * @see org.joda.time.TimePeriod#hashCode()\n+\t */\n+\tpublic void testHashCode() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>compareTo(java.lang.Object)</code> method.\n+\t * @see org.joda.time.TimePeriod#compareTo(java.lang.Object)\n+\t */\n+\tpublic void testCompareTo() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>isLongerThan(java.lang.Object)</code> method.\n+\t * @see org.joda.time.TimePeriod#isLongerThan(java.lang.Object)\n+\t */\n+\tpublic void testIsLongerThan() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>isShorterThan(java.lang.Object)</code> method.\n+\t * @see org.joda.time.TimePeriod#isShorterThan(java.lang.Object)\n+\t */\n+\tpublic void testIsShorterThan() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>toString()</code> method.\n+\t * @see org.joda.time.TimePeriod#toString()\n+\t */\n+\tpublic void testToString() {\n+\t\tfail(\"TBD\");\n+\t}\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/TestTimePeriodFormat.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time;\n+\n+//import java.util.*;\n+//import java.text.* ;\n+import junit.framework.TestSuite;\n+//import org.joda.time.*;\n+//import org.joda.time.gj.*;\n+//import org.joda.time.iso.*;\n+/**\n+ * This class is a Junit unit test for the\n+ * GJTimePeriodFormat date time class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Guy Allard\n+ */\n+public class TestTimePeriodFormat extends BulkTest {\n+\n+\t/**\n+\t * This is the main class for this test suite.\n+\t * @param args command line arguments.\n+\t */\n+\tpublic static void main(String[] args) {\n+\t\tjunit.textui.TestRunner.run(suite());\n+\t}\n+\t/**\n+\t * TestSuite is a junit required method.\n+\t */\n+\tpublic static TestSuite suite() {\n+\t\treturn BulkTest.makeSuite(TestTimePeriodFormat.class);\n+\t}\n+\t/**\n+\t * TestDateTimeField constructor.\n+\t * @param name\n+\t */\n+\tpublic TestTimePeriodFormat(String name) {\n+\t\tsuper(name);\n+\t}\n+\n+\t// Class Name: org.joda.time.TimePeriodFormat\n+\t/**\n+\t * Junit <code>setUp()</code> method.\n+\t */\n+\tprotected void setUp() /* throws Exception */ {\n+\t\t// super.setUp();\n+\t}\n+\t/**\n+\t * Junit <code>tearDown()</code> method.\n+\t */\n+\tprotected void tearDown() /* throws Exception */ {\n+\t\t// super.tearDown();\n+\t}\n+\t/**\n+\t * Test the <code>format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)</code> method.\n+\t * @see org.joda.time.TimePeriodFormat#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+\t */\n+\tpublic void testFormat() {\n+\t\tfail(\"TBD\");\n+\t}\n+\t/**\n+\t * Test the <code>parseObject(java.lang.String, java.text.ParsePosition)</code> method.\n+\t * @see org.joda.time.TimePeriodFormat#parseObject(java.lang.String, java.text.ParsePosition)\n+\t */\n+\tpublic void testParseObject() {\n+\t\tfail(\"TBD\");\n+\t}\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.buddhist;\n+\n+import java.util.Calendar;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.test.time.BulkTest;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.buddhist.BuddhistChronology;\n+/**\n+ * This class is the Junit unit test for a DateTimeField.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestBuddhistEraDateTimeField extends AbstractTestDateTimeField {\n+\n+    public TestBuddhistEraDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestBuddhistEraDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"era\";\n+    }\n+    protected DateTimeField getField() {\n+        return BuddhistChronology.getInstanceUTC().era();\n+    }\n+    protected int getMinimumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+    protected int getMaximumValue() {\n+        return BuddhistChronology.BE;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        return BuddhistChronology.BE;\n+    }\n+    protected long getUnitSize() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public void testGetAsTextLocale() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(\"BE\", field.getAsText(var[i], Locale.ENGLISH));\n+        }\n+    }\n+\n+    public void testGetAsText() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(\"BE\", field.getAsText(var[i]));\n+        }\n+    }\n+\n+    public void testGetAsShortTextLocale() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(\"BE\", field.getAsShortText(var[i], Locale.ENGLISH));\n+        }\n+    }\n+\n+    public void testGetAsShortText() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(\"BE\", field.getAsShortText(var[i]));\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+import java.util.Random;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.gj.GJChronology;\n+\n+/**\n+ * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj\n+ * against the implementations in this package. It tests all the date fields\n+ * against their principal methods.\n+ * <p>\n+ * Randomly generated values are fed into the DateTimeField methods and the\n+ * results are compared between the two chronologies. If any result doesn't\n+ * match, an error report is generated and the program exits. Each time this\n+ * test program is run, the pseudo random number generator is seeded with the\n+ * same value. This ensures consistent results between test runs.\n+ * <p>\n+ * The main method accepts three optional arguments: iterations, mode, seed. By\n+ * default, iterations is set to 1,000,000. The test will take several minutes\n+ * to run, depending on the computer's performance. Every 5 seconds a progress\n+ * message is printed.\n+ * <p>\n+ * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for\n+ * proleptic julian. To override the default random number generator seed, pass\n+ * in a thrid argument which accepts a long signed integer.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class Test {\n+    public static final int GREGORIAN_MODE = 0;\n+    public static final int JULIAN_MODE = 1;\n+\n+    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;\n+    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;\n+    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;\n+    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;\n+    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;\n+\n+    // Show progess reports every 5 seconds.\n+    private static final long UPDATE_INTERVAL = 5000;\n+\n+    /**\n+     * Arguments: iterations [mode [seed]]\n+     */\n+    public static void main(String[] args) throws Exception {\n+        int iterations = 1000000;\n+        int mode = GREGORIAN_MODE;\n+        long seed = 1345435247779935L;\n+\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+            if (args.length > 1) {\n+                if (args[1].startsWith(\"g\")) {\n+                    mode = GREGORIAN_MODE;\n+                } else if (args[1].startsWith(\"j\")) {\n+                    mode = JULIAN_MODE;\n+                } else {\n+                    throw new IllegalArgumentException\n+                        (\"Unknown mode: \" + args[1]);\n+                }\n+                if (args.length > 2) {\n+                    seed = Long.parseLong(args[2]);\n+                }\n+            }\n+        }\n+\n+        test(iterations, mode, seed);\n+    }\n+\n+    /**\n+     * @param iterations number of test iterations to perform\n+     * @param mode GREGORIAN_MODE or JULIAN_MODE\n+     * @param seed seed for random number generator\n+     */\n+    public static void test(final int iterations, int mode, long seed) {\n+        String modeStr;\n+        if (mode == GREGORIAN_MODE) {\n+            modeStr = \"Gregorian\";\n+        } else {\n+            modeStr = \"Julian\";\n+        }\n+\n+        System.out.println(\"Testing \" + modeStr + \" chronology over \" + iterations + \" iterations\");\n+\n+        Test t = new Test(mode);\n+        Random rnd = new Random(seed);\n+        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;\n+\n+        for (int i=0; i<iterations; i++) {\n+            long now = System.currentTimeMillis();\n+            if (now >= updateMillis) {\n+                updateMillis = now + UPDATE_INTERVAL;\n+                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;\n+                if (complete < 100) {\n+                    System.out.println(\"\" + complete + \"% complete (i=\" + i + \")\");\n+                }\n+            }\n+\n+            long millis = randomMillis(rnd);\n+            int value = rnd.nextInt(200) - 100;\n+            // millis2 is used for difference tests.\n+            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;\n+\n+            try {\n+                t.testFields(millis, value, millis2);\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Failure index: \" + i);\n+                System.out.println(\"Test millis: \" + millis);\n+                System.out.println(\"Test value: \" + value);\n+                System.out.println(\"Test millis2: \" + millis2);\n+                throw e;\n+            }\n+        }\n+\n+        System.out.println(\"100% complete (i=\" + iterations + \")\");\n+    }\n+\n+    private static long randomMillis(Random rnd) {\n+        long millis = rnd.nextLong();\n+        if (millis >= 0) {\n+            millis = millis % MAX_MILLIS;\n+        } else {\n+            millis = millis % -MIN_MILLIS;\n+        }\n+        return millis;\n+    }\n+\n+    private static void dump(Chronology chrono, long millis) {\n+        System.out.println(\"year:           \" + chrono.year().get(millis));\n+        System.out.println(\"monthOfYear:    \" + chrono.monthOfYear().get(millis));\n+        System.out.println(\"dayOfMonth:     \" + chrono.dayOfMonth().get(millis));\n+        System.out.println(\"weekyear:       \" + chrono.weekyear().get(millis));\n+        System.out.println(\"weekOfWeekyear: \" + chrono.weekOfWeekyear().get(millis));\n+        System.out.println(\"dayOfWeek:      \" + chrono.dayOfWeek().get(millis));\n+        System.out.println(\"dayOfYear:      \" + chrono.dayOfYear().get(millis));\n+    }\n+\n+    private final int iMode;\n+    private final Chronology iTest;\n+    private final Chronology iActual;\n+\n+    /**\n+     * @param mode 0=Gregorian, 1=Julian\n+     */\n+    public Test(int mode) {\n+        iMode = mode;\n+        if (mode == GREGORIAN_MODE) {\n+            iTest = new TestGregorianChronology();\n+            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true);\n+        } else {\n+            iTest = new TestJulianChronology();\n+            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MAX_VALUE, true);\n+        }\n+    }\n+\n+    public void testFields(long millis, int value, long millis2) {\n+        testField(iTest.year(), iActual.year(), millis, value, millis2);\n+        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);\n+        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);\n+        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);\n+        testField(iTest.weekOfWeekyear(),\n+                  iActual.weekOfWeekyear(), millis, value, millis2);\n+        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);\n+        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);\n+    }\n+\n+    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,\n+                           int value, long millis2)\n+    {\n+        int a, b;\n+        long x, y;\n+\n+        // get test\n+        a = fieldA.get(millis);\n+        b = fieldB.get(millis);\n+        testValue(fieldA, fieldB, \"get\", millis, a, b);\n+\n+        // getMaximumValue test\n+        // Restrict this test to the fields that matter.\n+        Class fieldClass = fieldA.getClass();\n+        if (fieldClass == TestGJDayOfYearField.class ||\n+            fieldClass == TestGJDayOfMonthField.class ||\n+            fieldClass == TestGJWeekOfWeekyearField.class) {\n+            \n+            a = fieldA.getMaximumValue(millis);\n+            b = fieldB.getMaximumValue(millis);\n+            testValue(fieldA, fieldB, \"getMaximumValue\", millis, a, b);\n+        }\n+\n+        // set test\n+        a = getWrappedValue\n+            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));\n+        b = getWrappedValue\n+            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));\n+        if (iMode == JULIAN_MODE && a == 0\n+            && (fieldA.getName().equals(\"year\") || fieldA.getName().equals(\"weekyear\"))) {\n+            // Exclude setting Julian year of zero.\n+        } else {\n+            x = fieldA.set(millis, a);\n+            y = fieldB.set(millis, b);\n+            testMillis(fieldA, fieldB, \"set\", millis, x, y, a, b);\n+        }\n+\n+        // roundFloor test\n+        x = fieldA.roundFloor(millis);\n+        y = fieldB.roundFloor(millis);\n+        testMillis(fieldA, fieldB, \"roundFloor\", millis, x, y);\n+\n+        // roundCeiling test\n+        x = fieldA.roundCeiling(millis);\n+        y = fieldB.roundCeiling(millis);\n+        testMillis(fieldA, fieldB, \"roundCeiling\", millis, x, y);\n+\n+        // roundHalfFloor test\n+        x = fieldA.roundHalfFloor(millis);\n+        y = fieldB.roundHalfFloor(millis);\n+        testMillis(fieldA, fieldB, \"roundHalfFloor\", millis, x, y);\n+\n+        // roundHalfEven test\n+        x = fieldA.roundHalfEven(millis);\n+        y = fieldB.roundHalfEven(millis);\n+        testMillis(fieldA, fieldB, \"roundHalfEven\", millis, x, y);\n+\n+        // remainder test\n+        x = fieldA.remainder(millis);\n+        y = fieldB.remainder(millis);\n+        testMillis(fieldA, fieldB, \"remainder\", millis, x, y);\n+\n+        // add test\n+        x = fieldA.add(millis, value);\n+        y = fieldB.add(millis, value);\n+        testMillis(fieldA, fieldB, \"add\", millis, x, y);\n+\n+        // addWrapped test\n+        x = fieldA.addWrapped(millis, value);\n+        y = fieldB.addWrapped(millis, value);\n+        testMillis(fieldA, fieldB, \"addWrapped\", millis, x, y);\n+\n+        // getDifference test\n+        x = fieldA.getDifference(millis, millis2);\n+        y = fieldB.getDifference(millis, millis2);\n+        try {\n+            testValue(fieldA, fieldB, \"getDifference\", millis, x, y);\n+        } catch (RuntimeException e) {\n+            System.out.println(\"Test datetime 2: \" + makeDatetime(millis2));\n+            throw e;\n+        }\n+    }\n+\n+    private int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+    private void testValue(DateTimeField fieldA, DateTimeField fieldB,\n+                           String method, long millis, long valueA, long valueB) {\n+        if (valueA != valueB) {\n+            failValue(fieldA, fieldB, method, millis, valueA, valueB);\n+        }\n+    }\n+\n+    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB) {\n+        if (millisA != millisB) {\n+            failMillis(fieldA, fieldB, method, millis, millisA, millisB);\n+        }\n+    }\n+\n+    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB,\n+                            int valueA, int valueB) {\n+        if (millisA != millisB) {\n+            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);\n+        }\n+    }\n+\n+    private void failValue(DateTimeField fieldA, DateTimeField fieldB,\n+                           String method, long millis, long valueA, long valueB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(valueA + \" != \" + valueB);\n+        throw new RuntimeException();\n+    }\n+\n+    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(makeDatetime(millisA) + \" != \" + makeDatetime(millisB));\n+        System.out.println(millisA + \" != \" + millisB);\n+        System.out.println(\"Original value as reported by first field: \" +\n+                           fieldA.get(millis));\n+        System.out.println(\"Original value as reported by second field: \" +\n+                           fieldB.get(millis));\n+        System.out.println(\"First new value as reported by first field: \" +\n+                           fieldA.get(millisA));\n+        System.out.println(\"First new value as reported by second field: \" +\n+                           fieldB.get(millisA));\n+        System.out.println(\"Second new value as reported by first field: \" +\n+                           fieldA.get(millisB));\n+        System.out.println(\"Second new value as reported by second field: \" +\n+                           fieldB.get(millisB));\n+        throw new RuntimeException();\n+    }\n+\n+    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,\n+                            String method, long millis, long millisA, long millisB,\n+                            int valueA, int valueB) {\n+        System.out.println(\"Failure on \" + makeName(fieldA, fieldB) + \".\" + method);\n+        System.out.println(fieldA.getClass().getName() + \"\\n\\tvs. \"\n+                           + fieldB.getClass().getName());\n+        System.out.println(\"Datetime: \" + makeDatetime(millis));\n+        System.out.println(\"Millis from 1970: \" + millis);\n+        System.out.println(makeDatetime(millisA) + \" != \" + makeDatetime(millisB));\n+        System.out.println(millisA + \" != \" + millisB);\n+        System.out.println(\"Original value as reported by first field: \" +\n+                           fieldA.get(millis));\n+        System.out.println(\"Original value as reported by second field: \" +\n+                           fieldB.get(millis));\n+        System.out.println(\"First new value as reported by first field: \" +\n+                           fieldA.get(millisA));\n+        System.out.println(\"First new value as reported by second field: \" +\n+                           fieldB.get(millisA));\n+        System.out.println(\"Second new value as reported by first field: \" +\n+                           fieldA.get(millisB));\n+        System.out.println(\"Second new value as reported by second field: \" +\n+                           fieldB.get(millisB));\n+        System.out.println(\"Value to set for first field: \" + valueA);\n+        System.out.println(\"Value to set for second field: \" + valueB);\n+        throw new RuntimeException();\n+    }\n+\n+    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {\n+        if (fieldA.getName().equals(fieldB.getName())) {\n+            return fieldA.getName();\n+        } else {\n+            return fieldA.getName() + \"/\" + fieldB.getName();\n+        }\n+    }\n+\n+    private String makeDatetime(long millis) {\n+        return makeDatetime(millis, iActual);\n+    }\n+\n+    private String makeDatetime(long millis, Chronology chrono) {\n+        return chrono.dayOfWeek().getAsShortText(millis) + \" \"\n+            + new DateTime(millis, chrono).toString() + \" / \" +\n+            chrono.weekyear().get(millis) + \"-W\" + chrono.weekOfWeekyear().get(millis) +\n+            \"-\" + chrono.dayOfWeek().get(millis);\n+    }\n+\n+    private String makeDate(long millis) {\n+        return makeDate(millis, iActual);\n+    }\n+\n+    private String makeDate(long millis, Chronology chrono) {\n+        return chrono.dayOfWeek().getAsShortText(millis) + \" \"\n+            + new DateTime(millis, chrono).toString(\"yyyy-MM-dd\") + \" / \" +\n+            chrono.weekyear().get(millis) + \"-W\" + chrono.weekOfWeekyear().get(millis) +\n+            \"-\" + chrono.dayOfWeek().get(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * A reference Gregorian/Julian chronology implementation, intended for testing\n+ * purposes only. Correctness is favored over performance. The key functions\n+ * for date calculations are based on ones provided in \"Calendrical\n+ * Calculations\", ISBN 0-521-77752-6.\n+ *\n+ * <p>In theory, this class can be used to test any other Gregorian/Julian\n+ * chronology as long as almost all datetime fields are implemented differently\n+ * between the two. Fields that would most likely be implemented the same are\n+ * not supported by this class.\n+ *\n+ * <p>Unsupported features\n+ * <ul>\n+ * <li>time zones\n+ * <li>time of day\n+ * <li>year of era\n+ * <li>year of century\n+ * <li>century of era\n+ * <li>era\n+ * </ul>\n+ *\n+ * @author Brian S O'Neill\n+ */\n+abstract class TestGJChronology extends Chronology {\n+    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;\n+\n+    /**\n+     * Divide with round-negative behavior.\n+     *\n+     * @param divisor must be positive\n+     */\n+    static long div(long dividend, long divisor) {\n+        if (divisor < 0) {\n+            throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n+        }\n+        if (dividend >= 0) {\n+            return dividend / divisor;\n+        } else {\n+            return (dividend + 1) / divisor - 1;\n+        }\n+    }\n+\n+    /**\n+     * Modulus with round-negative behavior, result is always positive.\n+     *\n+     * @param divisor must be positive\n+     */\n+    static long mod(long dividend, long divisor) {\n+        if (divisor < 0) {\n+            throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n+        }\n+        if (dividend >= 0) {\n+            return dividend % divisor;\n+        } else {\n+            return (dividend + 1) % divisor - 1 + divisor;\n+        }\n+    }\n+\n+    static long amod(long dividend, long divisor) {\n+        long mod = mod(dividend, divisor);\n+        return (mod == 0) ? divisor : mod;\n+    }\n+\n+    /** Milliseconds from 0001-01-01 to the epoch. */\n+    private final long iEpochMillis;\n+\n+    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {\n+        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;\n+    }\n+\n+    public DateTimeZone getDateTimeZone() {\n+        return null;\n+    }\n+\n+    public Chronology withUTC() {\n+        return this;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Chronology withDateTimeZone(DateTimeZone zone) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public long getTimeOnlyMillis(long millis) {\n+        return mod(millis, MILLIS_PER_DAY);\n+    }\n+\n+    public long getDateOnlyMillis(long millis) {\n+        return millis - mod(millis, MILLIS_PER_DAY);\n+    }\n+\n+    public DateTimeField dayOfWeek() {\n+        return new TestGJDayOfWeekField(this);\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return new TestGJDayOfMonthField(this); \n+    }\n+\n+    public DateTimeField dayOfYear() {\n+        return new TestGJDayOfYearField(this);\n+    }\n+\n+    public DateTimeField weekOfWeekyear() {\n+        return new TestGJWeekOfWeekyearField(this);\n+    }\n+\n+    public DateTimeField weekyear() {\n+        return new TestGJWeekyearField(this);\n+    }\n+\n+    public DateTimeField monthOfYear() {\n+        return new TestGJMonthOfYearField(this);\n+    }\n+\n+    public DateTimeField year() {\n+        return new TestGJYearField(this);\n+    }\n+\n+    abstract boolean isLeapYear(int year);\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    abstract int gjYearFromFixed(long date);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    abstract int[] gjFromFixed(long date);\n+\n+    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    abstract int[] isoFromFixed(long date);\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromMillis(long millis) {\n+        return div(millis + iEpochMillis, MILLIS_PER_DAY);\n+    }\n+\n+    /**\n+     * @param fixed days from 0001-01-01\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromFixed(long fixed) {\n+        return fixed * MILLIS_PER_DAY - iEpochMillis;\n+    }\n+\n+    /**\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return gj year\n+     */\n+    int gjYearFromMillis(long millis) {\n+        return gjYearFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromMillis(long millis) {\n+        return gjFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @return milliseconds from epoch\n+     */\n+    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));\n+    }\n+\n+    /**\n+     * @param millis milliseconds from epoch\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromMillis(long millis) {\n+        return isoFromFixed(fixedFromMillis(millis));\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday\n+     * @param date days from 0001-01-01, on or before weekday\n+     */\n+    long weekdayOnOrBefore(long date, int weekday) {\n+        return date - mod(date - mod(weekday, 7), 7);\n+    }\n+\n+    long weekdayOnOrAfter(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 6, weekday);\n+    }\n+\n+    long weekdayNearest(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 3, weekday);\n+    }\n+\n+    long weekdayBefore(long date, int weekday) {\n+        return weekdayOnOrBefore(date - 1, weekday);\n+    }\n+\n+    long weekdayAfter(long date, int weekday) {\n+        return weekdayOnOrBefore(date + 7, weekday);\n+    }\n+\n+    long nthWeekday(int n, int weekday,\n+                    int year, int monthOfYear, int dayOfMonth)\n+    {\n+        if (n > 0) {\n+            return 7 * n + weekdayBefore\n+                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);\n+        } else {\n+            return 7 * n + weekdayAfter\n+                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);\n+        }\n+    }\n+\n+    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {\n+        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);\n+    }\n+\n+    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {\n+        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+abstract class TestGJDateTimeField extends DateTimeField {\n+    protected final TestGJChronology iChronology;\n+\n+    public TestGJDateTimeField(String name, TestGJChronology chrono) {\n+        super(name);\n+        iChronology = chrono;\n+    }\n+\n+    // Redeclare to work around compiler bug.\n+    public abstract long add(long millis, int value);\n+\n+    public long add(long millis, long value) {\n+        return addLong(millis, value);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfMonthField extends TestGJDateTimeField {\n+    public TestGJDayOfMonthField(TestGJChronology chrono) {\n+        super(\"dayOfMonth\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[2];\n+    }\n+\n+    public long add(long millis, int value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        return iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromGJ(ymd[0], ymd[1], value);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 31;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+        if (iChronology.year().isLeap(millis)) {\n+            lengths[2] = 29;\n+        }\n+        return lengths[iChronology.monthOfYear().get(millis)];\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfWeekField extends TestGJDateTimeField {\n+    public TestGJDayOfWeekField(TestGJChronology chrono) {\n+        super(\"dayOfWeek\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+\t\tint dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);\n+\t\tif (dayOfWeek == 0) {\n+\t\t\tdayOfWeek = 7;\n+\t\t}\n+\t\treturn dayOfWeek;\n+    }\n+\n+    public long add(long millis, int value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long set(long millis, int value) {\n+        return add(millis, value - get(millis));\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return iChronology.MILLIS_PER_DAY * 7;\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 7;\n+    }\n+\n+    public long roundFloor(long millis) {\n+\t\treturn iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJDayOfYearField extends TestGJDateTimeField {\n+    public TestGJDayOfYearField(TestGJChronology chrono) {\n+        super(\"dayOfYear\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        int year = iChronology.gjYearFromMillis(millis);\n+        return (int)(iChronology.fixedFromMillis(millis)\n+                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;\n+    }\n+\n+    public long add(long millis, int value) {\n+        return millis + value * iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long set(long millis, int value) {\n+        return add(millis, value - get(millis));\n+    }\n+\n+    public long getUnitMillis() {\n+        return iChronology.MILLIS_PER_DAY;\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 366;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        return iChronology.year().isLeap(millis) ? 366 : 365;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.getDateOnlyMillis(millis);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJMonthOfYearField extends TestGJDateTimeField {\n+    public TestGJMonthOfYearField(TestGJChronology chrono) {\n+        super(\"monthOfYear\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[1];\n+    }\n+\n+    public long add(long millis, int value) {\n+        int newYear = iChronology.year().get(millis)\n+            + (int)iChronology.div(value, 12);\n+        int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n+        if (newMonth > 12) {\n+            newYear++;\n+            newMonth -= 12;\n+        }\n+        int newDay = iChronology.dayOfMonth().get(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis) \n+            + iChronology.millisFromGJ(newYear, newMonth, newDay);\n+        while (get(millis) != newMonth) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+\n+    public long set(long millis, int value) {\n+        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        // First set to start of month...\n+        millis = iChronology.millisFromGJ(ymd[0], value, 1);\n+        // ...and use dayOfMonth field to check range.\n+        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);\n+        if (ymd[2] > maxDay) {\n+            ymd[2] = maxDay;\n+        }\n+        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 12;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJWeekOfWeekyearField extends TestGJDateTimeField {\n+    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {\n+        super(\"weekOfWeekyear\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.isoFromMillis(millis)[1];\n+    }\n+\n+    public long add(long millis, int value) {\n+        return iChronology.dayOfYear().add(millis, value * 7);\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        return iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromISO(wwd[0], value, wwd[2]);\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(iChronology.MILLIS_PER_DAY * 7);\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(long millis) {\n+        // Move millis to end of weekyear.\n+        millis = iChronology.weekyear().roundFloor(millis);\n+        millis = iChronology.weekyear().add(millis, 1);\n+        millis = iChronology.dayOfYear().add(millis, -1);\n+        return get(millis);\n+    }\n+\n+    public long roundFloor(long millis) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        return iChronology.millisFromISO(wwd[0], wwd[1], 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJWeekyearField extends TestGJDateTimeField {\n+    public TestGJWeekyearField(TestGJChronology chrono) {\n+        super(\"weekyear\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.isoFromMillis(millis)[0];\n+    }\n+\n+    public long add(long millis, int value) {\n+        return set(millis, get(millis) + value);\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] wwd = iChronology.isoFromMillis(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromISO(value, wwd[1], wwd[2]);\n+        if (wwd[1] == 53) {\n+            int[] wwd2 = iChronology.isoFromMillis(millis);\n+            if (wwd2[0] != value) {\n+                // Set year doesn't have 53 weeks, so back off a week.\n+                millis = iChronology.dayOfYear().add(millis, -7);\n+            }\n+        }\n+        return millis;\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public long getRangeMillis() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.millisFromISO(get(millis), 1, 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestGJYearField extends TestGJDateTimeField {\n+    public TestGJYearField(TestGJChronology chrono) {\n+        super(\"year\", chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjYearFromMillis(millis);\n+    }\n+\n+    public long add(long millis, int value) {\n+        return set(millis, get(millis) + value);\n+    }\n+\n+    public long set(long millis, int value) {\n+        int[] ymd = iChronology.gjFromMillis(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis)\n+            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);\n+        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+\n+    public boolean isLeap(long millis) {\n+        return iChronology.isLeapYear(get(millis));\n+    }\n+\n+    public int getLeapAmount(long millis) {\n+        return isLeap(millis) ? 1 : 0;\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public long getRangeMillis() {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+\n+    public long roundFloor(long millis) {\n+        return iChronology.millisFromGJ(get(millis), 1, 1);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * A reference Gregorian chronology implementation, intended for testing\n+ * purposes only. Correctness is favored over performance. The key functions\n+ * for date calculations are based on ones provided in \"Calendrical\n+ * Calculations\", ISBN 0-521-77752-6.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class TestGregorianChronology extends TestGJChronology {\n+    /**\n+     * Constructs with an epoch of 1970-01-01.\n+     */\n+    public TestGregorianChronology() {\n+        super(1970, 1, 1);\n+    }\n+\n+    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {\n+        super(epochYear, epochMonth, epochDay);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        if (mod(year, 4) == 0) {\n+            int t = (int)mod(year, 400);\n+            if (t != 100 && t != 200 & t != 300) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        long year_m1 = year - 1;\n+        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)\n+            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n+        if (monthOfYear > 2) {\n+            f += isLeapYear(year) ? -1 : -2;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    int gjYearFromFixed(long date) {\n+        long d0 = date - 1;\n+        long n400 = div(d0, 146097);\n+        long d1 = mod(d0, 146097);\n+        long n100 = div(d1, 36524);\n+        long d2 = mod(d1, 36524);\n+        long n4 = div(d2, 1461);\n+        long d3 = mod(d2, 1461);\n+        long n1 = div(d3, 365);\n+        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;\n+        if (!(n100 == 4 || n1 == 4)) {\n+            year += 1;\n+        }\n+\n+        int year_i = (int)year;\n+        if (year_i == year) {\n+            return year_i;\n+        } else {\n+            throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n+        }\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromFixed(long date) {\n+        int year = gjYearFromFixed(date);\n+        long priorDays = date - fixedFromGJ(year, 1, 1);\n+        long correction;\n+        if (date < fixedFromGJ(year, 3, 1)) {\n+            correction = 0;\n+        } else if (isLeapYear(year)) {\n+            correction = 1;\n+        } else {\n+            correction = 2;\n+        }\n+        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n+        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);\n+\n+        return new int[]{year, monthOfYear, day};\n+    }\n+\n+    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromFixed(long date) {\n+        int weekyear = gjYearFromFixed(date - 3);\n+        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {\n+            weekyear += 1;\n+        }\n+        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n+        int dayOfWeek = (int)amod(date, 7);\n+        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * A reference Julian chronology implementation, intended for testing purposes\n+ * only. Correctness is favored over performance. The key functions for date\n+ * calculations are based on ones provided in \"Calendrical Calculations\", ISBN\n+ * 0-521-77752-6.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public final class TestJulianChronology extends TestGJChronology {\n+\n+    private static final long JULIAN_EPOCH;\n+\n+    static {\n+        // Constant as defined in book.\n+        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);\n+    }\n+\n+    /**\n+     * Constructs with an epoch of 1969-12-19.\n+     */\n+    public TestJulianChronology() {\n+        super(1969, 12, 19);\n+    }\n+\n+    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {\n+        super(epochYear, epochMonth, epochDay);\n+    }\n+\n+    public DateTimeField dayOfMonth() {\n+        return new TestJulianDayOfMonthField(this); \n+    }\n+\n+    public DateTimeField weekyear() {\n+        return new TestJulianWeekyearField(this);\n+    }\n+\n+    public DateTimeField monthOfYear() {\n+        return new TestJulianMonthOfYearField(this);\n+    }\n+\n+    public DateTimeField year() {\n+        return new TestJulianYearField(this);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        if (year == 0) {\n+            throw new IllegalArgumentException(\"Illegal year: \" + year);\n+        }\n+        return mod(year, 4) == (year > 0 ? 0 : 3);\n+    }\n+\n+    /**\n+     * @return days from 0001-01-01\n+     */\n+    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {\n+        if (year == 0) {\n+            throw new IllegalArgumentException(\"Illegal year: \" + year);\n+        }\n+        int y = (year < 0) ? year + 1 : year;\n+        long y_m1 = y - 1;\n+        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)\n+            + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n+        if (monthOfYear > 2) {\n+            f += isLeapYear(year) ? -1 : -2;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year\n+     */\n+    int gjYearFromFixed(long date) {\n+        return gjFromFixed(date)[0];\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return gj year, monthOfYear, dayOfMonth\n+     */\n+    int[] gjFromFixed(long date) {\n+        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);\n+        long year = (approx <= 0) ? approx - 1 : approx;\n+        int year_i = (int)year;\n+        if (year_i != year) {\n+            throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n+        }\n+        long priorDays = date - fixedFromGJ(year_i, 1, 1);\n+        long correction;\n+        if (date < fixedFromGJ(year_i, 3, 1)) {\n+            correction = 0;\n+        } else if (isLeapYear(year_i)) {\n+            correction = 1;\n+        } else {\n+            correction = 2;\n+        }\n+        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);\n+        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);\n+\n+        return new int[]{year_i, monthOfYear, day};\n+    }\n+\n+    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {\n+        if (weekyear == 0) {\n+            throw new IllegalArgumentException(\"Illegal weekyear: \" + weekyear);\n+        }\n+        if (weekyear == 1) {\n+            weekyear = -1;\n+        } else {\n+            weekyear--;\n+        }\n+        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;\n+    }\n+\n+    /**\n+     * @param date days from 0001-01-01\n+     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n+     */\n+    int[] isoFromFixed(long date) {\n+        int weekyear = gjYearFromFixed(date - 3);\n+        int nextWeekyear;\n+        if (weekyear == -1) {\n+            nextWeekyear = 1;\n+        } else {\n+            nextWeekyear = weekyear + 1;\n+        }\n+        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {\n+            weekyear = nextWeekyear;\n+        }\n+        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n+        int dayOfWeek = (int)amod(date, 7);\n+        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianDayOfMonthField extends TestGJDayOfMonthField {\n+    public TestJulianDayOfMonthField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianMonthOfYearField extends TestGJMonthOfYearField {\n+    public TestJulianMonthOfYearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public int get(long millis) {\n+        return iChronology.gjFromMillis(millis)[1];\n+    }\n+\n+    public long add(long millis, int value) {\n+\t\tint year = iChronology.year().get(millis);\n+        int newYear = year + (int)iChronology.div(value, 12);\n+        if (year < 0) {\n+            if (newYear >= 0) {\n+                newYear++;\n+            }\n+        } else {\n+            if (newYear <= 0) {\n+                newYear--;\n+            }\n+        }\n+        int newMonth = get(millis) + (int)iChronology.mod(value, 12);\n+        if (newMonth > 12) {\n+\t\t\tif (newYear == -1) {\n+\t\t\t\tnewYear = 1;\n+\t\t\t} else {\n+\t\t\t\tnewYear++;\n+\t\t\t}\n+            newMonth -= 12;\n+        }\n+        int newDay = iChronology.dayOfMonth().get(millis);\n+        millis = iChronology.getTimeOnlyMillis(millis) \n+            + iChronology.millisFromGJ(newYear, newMonth, newDay);\n+        while (get(millis) != newMonth) {\n+            millis = iChronology.dayOfYear().add(millis, -1);\n+        }\n+        return millis;\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);\n+    }\n+\n+    public long getRangeMillis() {\n+        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianWeekyearField extends TestGJWeekyearField {\n+    public TestJulianWeekyearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long addWrapped(long millis, int value) {\n+        int weekyear = get(millis);\n+        int wrapped = getWrappedValue\n+            (weekyear, value, getMinimumValue(), getMaximumValue());\n+        return add(millis, wrapped - weekyear);\n+    }\n+\n+    public long add(long millis, int value) {\n+        int weekyear = get(millis);\n+        int newWeekyear = weekyear + value;\n+        if (weekyear < 0) {\n+            if (newWeekyear >= 0) {\n+                newWeekyear++;\n+            }\n+        } else {\n+            if (newWeekyear <= 0) {\n+                newWeekyear--;\n+            }\n+        }\n+        return set(millis, newWeekyear);\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+\n+package org.joda.test.time.chrono.gj;\n+\n+/**\n+ * \n+ * @author Brian S O'Neill\n+ */\n+class TestJulianYearField extends TestGJYearField {\n+    public TestJulianYearField(TestJulianChronology chrono) {\n+        super(chrono);\n+    }\n+\n+    public long addWrapped(long millis, int value) {\n+        int year = get(millis);\n+        int wrapped = getWrappedValue\n+            (year, value, getMinimumValue(), getMaximumValue());\n+        return add(millis, wrapped - year);\n+    }\n+\n+    public long add(long millis, int value) {\n+        int year = get(millis);\n+        int newYear = year + value;\n+        if (year < 0) {\n+            if (newYear >= 0) {\n+                newYear++;\n+            }\n+        } else {\n+            if (newYear <= 0) {\n+                newYear--;\n+            }\n+        }\n+        return set(millis, newYear);\n+    }\n+\n+    public long getUnitMillis() {\n+        return (long)(365.25 * iChronology.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return -100000000;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 100000000;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestGJDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public AbstractTestGJDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    static final int[] monthLengths = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianJulianCutoverMillis();\n+    \n+    protected int[] getDMYDS(long millis) {\n+        return getDMYDS(millis, GJ_CUTOVER_MILLIS, 1582, 10);\n+    }\n+    \n+    protected final int[] getDMYDS(long millis, long cutoverMillis, int cutoverYear, int cutoverAmount) {\n+        long days = 0;\n+        if (millis >= 0) {\n+            days = (int) ((millis / (24 * 60 * 60 * 1000)));\n+            int day = 1;\n+            int month = 1;\n+            int year = 1970;\n+            int doy = 1;\n+            for (int i = 0; i < days; i++) {\n+                boolean leap = isLeap(year, cutoverYear);\n+                int yearLength = (leap ? 366 : 365);\n+                if ((days - i) > yearLength) {\n+                    // shortcut\n+                    year++;\n+                    i = i + yearLength - 1;\n+                } else {\n+                    day++;\n+                    doy++;\n+                    if (day > monthLengths[month]) {\n+                        if (month == 2 && day == 29 && isLeap(year, cutoverYear)) {\n+                            // do nothing\n+                        } else {\n+                            day = 1;\n+                            month++;\n+                            if (month == 13) {\n+                                month = 1;\n+                                year++;\n+                                doy = 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            int monthLength = (month == 2 && isLeap(year, cutoverYear) ? 29 : monthLengths[month]);\n+            int yearLength = (isLeap(year, cutoverYear) ? 366 : 365);\n+            return new int[] {day, month, year, doy, monthLength, yearLength};\n+        } else {\n+            days = (int) (((-millis - 1) / (24 * 60 * 60 * 1000)));\n+            if (millis < cutoverMillis) {\n+                // fake the cutover (calculation will be wrong until it gets to before the cutover)\n+                days = days + cutoverAmount;\n+            }\n+            int day = 1;  // count in reverse!\n+            int month = 12;\n+            int year = 1969;\n+            int doy = 1;\n+            for (int i = 0; i < days; i++) {\n+                boolean leap = isLeap(year, cutoverYear);\n+                int yearLength = (leap ? 366 : 365);\n+                if ((days - i) > yearLength) {\n+                    // shortcut\n+                    year--;\n+                    i = i + yearLength - 1;\n+                } else {\n+                    day++;\n+                    doy++;\n+                    if (day > monthLengths[month]) {\n+                        if (month == 2 && day == 29 && leap) {\n+                            // do nothing\n+                        } else {\n+                            day = 1;\n+                            month--;\n+                            if (month == 0) {\n+                                month = 12;\n+                                year--;\n+                                doy = 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            int monthLength = (month == 2 && isLeap(year, cutoverYear) ? 29 : monthLengths[month]);\n+            if (year == cutoverYear && month == 10) {\n+                monthLength = monthLength - cutoverAmount;\n+            }\n+            if (month == 2 && isLeap(year, cutoverYear)) {\n+                day = monthLengths[month] + 2 - day;\n+            } else {\n+                day = monthLengths[month] + 1 - day;\n+            }\n+            int yearLength = (isLeap(year, cutoverYear) ? 366 : 365);\n+            yearLength = (year == cutoverYear && millis >= cutoverMillis  ? yearLength - cutoverAmount : yearLength);\n+            doy = (isLeap(year, cutoverYear) ? 367 - doy : 366 - doy);\n+            doy = (year == cutoverYear && millis >= cutoverMillis  ? doy - cutoverAmount : doy);\n+            return new int[] {day, month, year, doy, monthLength, yearLength};\n+        }\n+    }\n+    \n+    /**\n+     * @param year\n+     * @return true if a leap year\n+     */\n+    protected boolean isLeap(int year, int cutoverYear) {\n+        if (year < cutoverYear) {\n+            return (year % 4 == 0);\n+        }\n+        if (year % 400 == 0) {\n+            return true;\n+        }\n+        if (year % 100 == 0) {\n+            return false;\n+        }\n+        return (year % 4 == 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJClockhourOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJClockhourOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJClockhourOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int val = getCalendarValue(millis);\n+        if (val == 24) {\n+            val = 0;\n+        }\n+        int max = 23;\n+        int min = 0;\n+        int add = val + addWrapped;\n+        while (add > max || add < min) {\n+            if (addWrapped >= 0) {\n+                add = add - (max - min) - 1;\n+            } else {\n+                add = add + (max - min) + 1;\n+            }\n+        }\n+        return millis + ((add - val) * getUnitSize());\n+    }\n+    \n+    protected String getFieldName() {\n+        return \"clockhourOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).clockhourOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 24;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        int val = 0;\n+        if (millis >= 0) {\n+            val = (int) ((millis / (60 * 60 * 1000)) % 24);\n+        } else {\n+            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);\n+        }\n+        return (val == 0 ? 24 : val);\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 60 * 1000; // 1 hour\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJClockhourOfHalfdayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJClockhourOfHalfdayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJClockhourOfHalfdayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int val = getCalendarValue(millis);\n+        if (val == 12) {\n+            val = 0;\n+        }\n+        int max = 11;\n+        int min = 0;\n+        int add = val + addWrapped;\n+        while (add > max || add < min) {\n+            if (addWrapped >= 0) {\n+                add = add - (max - min) - 1;\n+            } else {\n+                add = add + (max - min) + 1;\n+            }\n+        }\n+        return millis + ((add - val) * getUnitSize());\n+    }\n+    \n+    protected String getFieldName() {\n+        return \"clockhourOfHalfday\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).clockhourOfHalfday();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 12;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        int val = 0;\n+        if (millis >= 0) {\n+            val = ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;\n+        } else {\n+            val = ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;\n+        }\n+        return (val == 0 ? 12 : val);\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 60 * 1000; // 1 hour\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJDayOfMonthDateTimeField extends AbstractTestGJDateTimeField {\n+\n+\n+    public TestGJDayOfMonthDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJDayOfMonthDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"dayOfMonth\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).dayOfMonth();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 31;\n+    }\n+    \n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        return getDMYDS(millis)[0];\n+    }\n+\n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        int[] dmyd = getDMYDS(millis + getZone().getOffset(millis));\n+        int day = dmyd[0];\n+        int month = dmyd[1];\n+        int year = dmyd[2];\n+        int monthSize = dmyd[4];\n+        if (millis == -12219469260000L && addWrapped == -13) {\n+            int i = 0;\n+        }\n+        \n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int newDay = day + addWrapped;\n+        boolean loop = false;\n+        do {\n+            loop = false;\n+            if (newDay < 1) {\n+                newDay = newDay + monthSize;\n+                loop = true;\n+            } else if (newDay > monthSize) {\n+                newDay = newDay - monthSize;\n+                loop = true;\n+            }\n+        } while (loop);\n+        return millis + ((long) (newDay - day)) * 24 * 60 * 60 * 1000;\n+    }\n+\n+    protected long getUnitSize() {\n+        return 24 * 60 * 60 * 1000; // 1 day\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.Calendar;\n+import java.util.Locale;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJDayOfWeekDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJDayOfWeekDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJDayOfWeekDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"dayOfWeek\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).dayOfWeek();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 7;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        int val = 0;\n+        if (millis >= 0) {\n+            val = (int) ((millis / (24 * 60 * 60 * 1000)) % 7);\n+        } else {\n+            val = (int) 6 + (int) (((millis + 1) / (24 * 60 * 60 * 1000)) % 7);\n+        }\n+        val = val + 4;  // shift 1970-01-01 to Thursday\n+        val = val % 7;  // readjust\n+        return (val == 0 ? 7 : val);\n+    }\n+    protected long getUnitSize() {\n+        return 24 * 60 * 60 * 1000; // 1 day\n+    }\n+    protected String getText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        switch (value) {\n+            case DateTimeConstants.MONDAY :\n+            return sym.getWeekdays()[Calendar.MONDAY];\n+            case DateTimeConstants.TUESDAY :\n+            return sym.getWeekdays()[Calendar.TUESDAY];\n+            case DateTimeConstants.WEDNESDAY :\n+            return sym.getWeekdays()[Calendar.WEDNESDAY];\n+            case DateTimeConstants.THURSDAY :\n+            return sym.getWeekdays()[Calendar.THURSDAY];\n+            case DateTimeConstants.FRIDAY :\n+            return sym.getWeekdays()[Calendar.FRIDAY];\n+            case DateTimeConstants.SATURDAY :\n+            return sym.getWeekdays()[Calendar.SATURDAY];\n+            case DateTimeConstants.SUNDAY :\n+            return sym.getWeekdays()[Calendar.SUNDAY];\n+        }\n+        return null;\n+    }\n+    protected String getShortText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        switch (value) {\n+            case DateTimeConstants.MONDAY :\n+            return sym.getShortWeekdays()[Calendar.MONDAY];\n+            case DateTimeConstants.TUESDAY :\n+            return sym.getShortWeekdays()[Calendar.TUESDAY];\n+            case DateTimeConstants.WEDNESDAY :\n+            return sym.getShortWeekdays()[Calendar.WEDNESDAY];\n+            case DateTimeConstants.THURSDAY :\n+            return sym.getShortWeekdays()[Calendar.THURSDAY];\n+            case DateTimeConstants.FRIDAY :\n+            return sym.getShortWeekdays()[Calendar.FRIDAY];\n+            case DateTimeConstants.SATURDAY :\n+            return sym.getShortWeekdays()[Calendar.SATURDAY];\n+            case DateTimeConstants.SUNDAY :\n+            return sym.getShortWeekdays()[Calendar.SUNDAY];\n+        }\n+        return null;\n+    }\n+\n+    protected int getMaximumTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getWeekdays().length; i++) {\n+            max = (max >= sym.getWeekdays()[i].length() ? max : sym.getWeekdays()[i].length());\n+        }\n+        return max;\n+    }\n+    protected int getMaximumShortTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getShortWeekdays().length; i++) {\n+            max = (max >= sym.getShortWeekdays()[i].length() ? max : sym.getShortWeekdays()[i].length());\n+        }\n+        return max;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJDayOfYearDateTimeField extends AbstractTestGJDateTimeField {\n+\n+\n+    public TestGJDayOfYearDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJDayOfYearDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"dayOfYear\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).dayOfYear();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 366;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        return getDMYDS(millis)[3];\n+    }\n+\n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int[] dmyds = getDMYDS(millis + getZone().getOffset(millis));\n+        int val = dmyds[3];\n+        int max = dmyds[5];\n+        int add = val + addWrapped;\n+        while (add > max || add < 1) {\n+            if (addWrapped >= 0) {\n+                add -= max;\n+            } else {\n+                add += max;\n+            }\n+        }\n+        return millis + ((add - val) * getUnitSize());\n+    }\n+\n+    protected long getUnitSize() {\n+        return 24 * 60 * 60 * 1000; // 1 day\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.Locale;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJHalfdayOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJHalfdayOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJHalfdayOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"halfdayOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).halfdayOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 1;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        int val = 0;\n+        if (millis >= 0) {\n+            val = (int) ((millis / (60 * 60 * 1000)) % 24);\n+        } else {\n+            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);\n+        }\n+        return (val < 12 ? 0 : 1);\n+    }\n+    protected long getUnitSize() {\n+        return 12 * 60 * 60 * 1000; // 12 hours\n+    }\n+    protected String getText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        return sym.getAmPmStrings()[value];\n+    }\n+    protected String getShortText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        return sym.getAmPmStrings()[value];\n+    }\n+    \n+    protected int getMaximumTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getAmPmStrings().length; i++) {\n+            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());\n+        }\n+        return max;\n+    }\n+    protected int getMaximumShortTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getAmPmStrings().length; i++) {\n+            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());\n+        }\n+        return max;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJHourOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJHourOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJHourOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"hourOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).hourOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 23;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) ((millis / (60 * 60 * 1000)) % 24);\n+        } else {\n+            return (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 60 * 1000; // 1 hour\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJHourOfHalfdayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJHourOfHalfdayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJHourOfHalfdayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"hourOfHalfday\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).hourOfHalfday();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 11;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;\n+        } else {\n+            return ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 60 * 1000; // 1 hour\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJMillisOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJMillisOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJMillisOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"millisOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).millisOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 24 * 60 * 60 * 1000 - 1;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) (millis % (24 * 60 * 60 * 1000));\n+        } else {\n+            return (int) (24 * 60 * 60 * 1000 - 1) + (int) ((millis + 1) % (24 * 60 * 60 * 1000));\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 1; // 1 milli\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJMillisOfSecondDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJMillisOfSecondDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJMillisOfSecondDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"millisOfSecond\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).millisOfSecond();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 999;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) (millis % 1000);\n+        } else {\n+            return (int) (999 - ((-millis - 1) % 1000));\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 1; // 1 milli\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJMinuteOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJMinuteOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJMinuteOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"minuteOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).minuteOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 24 * 60 - 1;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) ((millis / 60000) % (24 * 60));\n+        } else {\n+            return (int) (24 * 60 - 1) + (int) (((millis + 1) / 60000) % (24 * 60));\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 1000; // 1 sec\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJMinuteOfHourDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJMinuteOfHourDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJMinuteOfHourDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"minuteOfHour\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).minuteOfHour();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 59;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) ((millis / 60000) % 60);\n+        } else {\n+            return (int) 59 + (int) (((millis + 1) / 60000) % 60);\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 60 * 1000; // 1 sec\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.Locale;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJMonthOfYearDateTimeField extends AbstractTestGJDateTimeField {\n+\n+\n+    public TestGJMonthOfYearDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJMonthOfYearDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"monthOfYear\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).monthOfYear();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 12;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        return getDMYDS(millis)[1];\n+    }\n+    protected long getAddedResult(long millis, int add) {\n+        if (add == 0) {\n+            return millis;\n+        }\n+//        System.out.println(new Instant(millis) + \"  \" + add);\n+        \n+        int[] before = getDMYDS(millis + getZone().getOffset(millis));\n+        int currentDay = before[0];\n+        int currentMonth = before[1];\n+        long newMillis = millis + (add * getUnitSize()) + (((int) (add/2)) * 24 * 60 * 60 * 1000);\n+        int[] after = getDMYDS(newMillis + getZone().getOffset(newMillis));\n+        int newDay = after[0];\n+        int newMonth = after[1];\n+        \n+        // calc effective add\n+        int max = 12;\n+        int min = 1;\n+        int added = currentMonth + add;\n+        while (added > max || added < min) {\n+            if (add >= 0) {\n+                added = added - (max - min) - 1;\n+            } else {\n+                added = added + (max - min) + 1;\n+            }\n+        }\n+        int effectiveAdd = added - currentMonth;\n+        \n+        // ensure month correct\n+        while (currentMonth + effectiveAdd != newMonth) {\n+            if (currentMonth + effectiveAdd == 1 && newMonth == 12) {\n+                newMillis = newMillis + 24 * 60 * 60 * 1000;\n+            } else if (currentMonth + effectiveAdd == 12 && newMonth == 1) {\n+                newMillis = newMillis - 24 * 60 * 60 * 1000;\n+            } else if (currentMonth + effectiveAdd > newMonth) {\n+                newMillis = newMillis + 24 * 60 * 60 * 1000;\n+            } else {\n+                newMillis = newMillis - 24 * 60 * 60 * 1000;\n+            }\n+            after = getDMYDS(newMillis + getZone().getOffset(newMillis));\n+            newDay = after[0];\n+            newMonth = after[1];\n+        }\n+        \n+        // ensure day correct\n+        if (currentDay < newDay) {\n+            while (currentDay < newDay) {\n+                newMillis = newMillis - 24 * 60 * 60 * 1000;\n+                after = getDMYDS(newMillis + getZone().getOffset(newMillis));\n+                newDay = after[0];\n+                newMonth = after[1];\n+                if (currentMonth + effectiveAdd != newMonth) {\n+                    newMillis = newMillis + 24 * 60 * 60 * 1000;\n+                    break;\n+                }\n+            }\n+        } else {\n+            while (currentDay > newDay) {\n+                newMillis = newMillis + 24 * 60 * 60 * 1000;\n+                after = getDMYDS(newMillis + getZone().getOffset(newMillis));\n+                newDay = after[0];\n+                newMonth = after[1];\n+                if (currentMonth + effectiveAdd != newMonth) {\n+                    newMillis = newMillis - 24 * 60 * 60 * 1000;\n+                    break;\n+                }\n+            }\n+        }\n+        \n+//        System.out.println(new Instant(newMillis) + \"  \" + add);\n+        return newMillis;\n+    }\n+    protected long getAddWrappedResult(long millis, int addWrapped) {\n+        if (addWrapped == 0) {\n+            return millis;\n+        }\n+        int[] before = getDMYDS(millis + getZone().getOffset(millis));\n+        int val = before[1];\n+        int max = 12;\n+        int min = 1;\n+        int add = val + addWrapped;\n+        while (add > max || add < min) {\n+            if (addWrapped >= 0) {\n+                add = add - (max - min) - 1;\n+            } else {\n+                add = add + (max - min) + 1;\n+            }\n+        }\n+        int amount = add - val;\n+        if (amount == 0) {\n+            return millis;\n+        } else {\n+            return getAddedResult(millis, amount);\n+        }\n+    }\n+    \n+    protected long getUnitSize() {\n+        return 30L * 24 * 60 * 60 * 1000; // 30 day\n+    }\n+    protected long getIncrementSize() {\n+        return 8L * 60 * 60 * 1000;  // 8 hours\n+    }\n+    protected long getTestRange() {\n+        return 32L * 24 * 60 * 60 * 1000;  // 32 days\n+    }\n+    \n+    protected String getText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        return sym.getMonths()[value - 1];\n+    }\n+    protected String getShortText(int value, Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        return sym.getShortMonths()[value - 1];\n+    }\n+    \n+    protected int getMaximumTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getMonths().length; i++) {\n+            max = (max >= sym.getMonths()[i].length() ? max : sym.getMonths()[i].length());\n+        }\n+        return max;\n+    }\n+    protected int getMaximumShortTextLength(Locale loc) {\n+        if (loc == null) {\n+            loc = Locale.getDefault();\n+        }\n+        DateFormatSymbols sym = new DateFormatSymbols(loc);\n+        int max = 0;\n+        for (int i = 0; i < sym.getShortMonths().length; i++) {\n+            max = (max >= sym.getShortMonths()[i].length() ? max : sym.getShortMonths()[i].length());\n+        }\n+        return max;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJSecondOfDayDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJSecondOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJSecondOfDayDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"secondOfDay\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).secondOfDay();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 24 * 60 * 60 - 1;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) ((millis / 1000) % (24 * 60 * 60));\n+        } else {\n+            return (int) (24 * 60 * 60 - 1) + (int) (((millis + 1) / 1000) % (24 * 60 * 60));\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 1000; // 1 sec\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJSecondOfMinuteDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJSecondOfMinuteDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJSecondOfMinuteDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"secondOfMinute\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).secondOfMinute();\n+    }\n+    protected int getMinimumValue() {\n+        return 0;\n+    }\n+    protected int getMaximumValue() {\n+        return 59;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        if (millis >= 0) {\n+            return (int) ((millis / 1000) % 60);\n+        } else {\n+            return (int) 59 + (int) (((millis + 1) / 1000) % 60);\n+        }\n+    }\n+    protected long getUnitSize() {\n+        return 1000; // 1 sec\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.util.Date;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.Instant;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJYearDateTimeField extends AbstractTestGJDateTimeField {\n+\n+\n+    public TestGJYearDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJYearDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"year\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).year();\n+    }\n+    protected int getMinimumValue() {\n+        return -292269053;\n+    }\n+    protected int getMaximumValue() {\n+        return 292272992;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        millis = millis + getZone().getOffset(millis);\n+        return getDMYDS(millis)[2];\n+    }\n+    protected long getAddedResult(long millis, int add) {\n+        if (add == 0) {\n+            return millis;\n+        }\n+        int[] fields = getDMYDS(millis + getZone().getOffset(millis));\n+        int day = fields[0];\n+        int month = fields[1];\n+        int year = fields[2];\n+        int yearLength = fields[5];\n+        int newYear = year + add;\n+        if (add > 0) {\n+            int addDays = 0;\n+            if (month >= 3) {\n+                for (int i = year + 1; i <= newYear; i++) {\n+                    if (isLeap(i, 1582)) {\n+                        addDays += 366;\n+                    } else {\n+                        addDays += 365;\n+                    }\n+                }\n+            } else {\n+                for (int i = year; i < newYear; i++) {\n+                    if (isLeap(i, 1582)) {\n+                        addDays += 366;\n+                    } else {\n+                        addDays += 365;\n+                    }\n+                }\n+            }\n+            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {\n+                addDays = addDays - 1;\n+            }\n+            millis = millis + (addDays * 24 * 60 * 60 * 1000L);\n+        } else {\n+            int addDays = 0;\n+            if (month >= 3) {\n+                for (int i = year; i > newYear; i--) {\n+                    if (isLeap(i, 1582)) {\n+                        addDays -= 366;\n+                    } else {\n+                        addDays -= 365;\n+                    }\n+                }\n+            } else {\n+                for (int i = year - 1; i >= newYear; i--) {\n+                    if (isLeap(i, 1582)) {\n+                        addDays -= 366;\n+                    } else {\n+                        addDays -= 365;\n+                    }\n+                }\n+            }\n+            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {\n+                addDays = addDays - 1;\n+            }\n+            millis = millis + (addDays * 24 * 60 * 60 * 1000L);\n+        }\n+        return millis;\n+    }\n+    protected long getAddWrappedResult(long millis, int add) {\n+        return getAddedResult(millis, add);\n+    }\n+    \n+    protected long getUnitSize() {\n+        return 365 * 24 * 60 * 60 * 1000; // 365 day\n+    }\n+    protected long getIncrementSize() {\n+        return 8 * 60 * 60 * 1000;  // 8 hours\n+    }\n+    protected long getTestRange() {\n+        return 20L * 24 * 60 * 60 * 1000;  // 20 days\n+    }\n+    \n+    \n+    public void testIsLeapYear() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            try {\n+                assertEquals(iCalendar.isLeapYear(field.get(var[i])), field.isLeap(var[i]));\n+            } catch (AssertionFailedError ex) {\n+                System.out.println(\"LEAPYEAR: i: \"+i+\" cal:\"+getCalendarValue(var[i])+\" get:\"+getField().get(var[i])+\n+                    \" time:\"+new Instant(var[i])+\",\"+new Date(var[i])+\n+                    \" day:\"+new DateTime(var[i], GJChronology.getInstance()).getDayOfMonth()+\n+                    \" month:\"+new DateTime(var[i], GJChronology.getInstance()).getMonthOfYear()+\n+                    \" year:\"+new DateTime(var[i], GJChronology.getInstance()).getYear());\n+                throw ex;\n+            }\n+        }\n+    }\n+    \n+    public void testGetLeapAmount() throws Exception {\n+        DateTimeField field = getField();\n+        long[] var = getAllTestPositions();\n+        for (int i = 0; i < var.length; i++) {\n+            assertEquals(iCalendar.isLeapYear(field.get(var[i])) ? 1 : 0, field.getLeapAmount(var[i]));\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.util.Calendar;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJYearOfCenturyDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJYearOfCenturyDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJYearOfCenturyDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"yearOfCentury\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).yearOfCentury();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 100;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        iDate.setTime(millis);\n+        iCalendar.setTime(iDate);\n+        int val = iCalendar.get(Calendar.YEAR);\n+        val = val % 100;\n+        return (val == 0 ? 100 : val);\n+    }\n+    protected long getAddedResult(long millis, int add) {\n+        iDate.setTime(millis);\n+        iCalendar.setTime(iDate);\n+        iCalendar.add(Calendar.YEAR, add);\n+        return iCalendar.getTime().getTime();\n+    }\n+    \n+    protected long getUnitSize() {\n+        return 365 * 24 * 60 * 60 * 1000; // 365 day\n+    }\n+    protected long getIncrementSize() {\n+        return 8 * 60 * 60 * 1000;  // 8 hours\n+    }\n+    protected long getTestRange() {\n+        return 32L * 24 * 60 * 60 * 1000;  // 32 days\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import java.util.Calendar;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.AbstractTestDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.gj.GJChronology;\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGJYearOfEraDateTimeField extends AbstractTestDateTimeField {\n+\n+\n+    public TestGJYearOfEraDateTimeField(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestGJYearOfEraDateTimeField.class);\n+    }\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    \n+    protected String getFieldName() {\n+        return \"yearOfEra\";\n+    }\n+    protected DateTimeField getField() {\n+        return GJChronology.getInstance(getZone()).yearOfEra();\n+    }\n+    protected int getMinimumValue() {\n+        return 1;\n+    }\n+    protected int getMaximumValue() {\n+        return 292272992;\n+    }\n+    protected int getCalendarValue(long millis) {\n+        iDate.setTime(millis);\n+        iCalendar.setTime(iDate);\n+        int val = iCalendar.get(Calendar.YEAR);\n+        return val;\n+    }\n+    protected long getAddedResult(long millis, int add) {\n+        iDate.setTime(millis);\n+        iCalendar.setTime(iDate);\n+        iCalendar.add(Calendar.YEAR, add);\n+        return iCalendar.getTime().getTime();\n+    }\n+    protected long getAddWrappedResult(long millis, int add) {\n+        iDate.setTime(millis);\n+        iCalendar.setTime(iDate);\n+        iCalendar.add(Calendar.YEAR, add);\n+        return iCalendar.getTime().getTime();\n+    }\n+    \n+    protected long getUnitSize() {\n+        return 365 * 24 * 60 * 60 * 1000; // 365 day\n+    }\n+    protected long getIncrementSize() {\n+        return 8 * 60 * 60 * 1000;  // 8 hours\n+    }\n+    protected long getTestRange() {\n+        return 32L * 24 * 60 * 60 * 1000;  // 32 days\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/gj/TestSuiteGJ.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.gj;\n+\n+import junit.framework.TestSuite;\n+/**\n+ * This class is a Junit unit test suite.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSuiteGJ extends TestSuite {\n+\n+    public TestSuiteGJ(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    \n+    public static TestSuite suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(TestGJMillisOfSecondDateTimeField.suite());\n+        suite.addTest(TestGJMillisOfDayDateTimeField.suite());\n+        suite.addTest(TestGJSecondOfMinuteDateTimeField.suite());\n+        suite.addTest(TestGJSecondOfDayDateTimeField.suite());\n+        suite.addTest(TestGJMinuteOfHourDateTimeField.suite());\n+        suite.addTest(TestGJMinuteOfDayDateTimeField.suite());\n+        suite.addTest(TestGJHalfdayOfDayDateTimeField.suite());\n+        suite.addTest(TestGJHourOfDayDateTimeField.suite());\n+        suite.addTest(TestGJHourOfHalfdayDateTimeField.suite());\n+        suite.addTest(TestGJClockhourOfDayDateTimeField.suite());\n+        suite.addTest(TestGJClockhourOfHalfdayDateTimeField.suite());\n+        \n+        suite.addTest(TestGJDayOfWeekDateTimeField.suite());\n+        suite.addTest(TestGJDayOfMonthDateTimeField.suite());\n+        suite.addTest(TestGJDayOfYearDateTimeField.suite());\n+        \n+        suite.addTest(TestGJMonthOfYearDateTimeField.suite());\n+        suite.addTest(TestGJYearDateTimeField.suite());\n+        suite.addTest(TestGJYearOfEraDateTimeField.suite());\n+        suite.addTest(TestGJYearOfCenturyDateTimeField.suite());\n+        return suite;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOClockhourOfDayDateTimeField extends TestGJClockhourOfDayDateTimeField {\n+\n+    public TestISOClockhourOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOClockhourOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).clockhourOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOClockhourOfHalfdayDateTimeField extends TestGJClockhourOfHalfdayDateTimeField {\n+\n+    public TestISOClockhourOfHalfdayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOClockhourOfHalfdayDateTimeField.class);\n+    }\n+    \n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).clockhourOfHalfday();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISODayOfMonthDateTimeField extends TestGJDayOfMonthDateTimeField {\n+\n+    public TestISODayOfMonthDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISODayOfMonthDateTimeField.class);\n+    }\n+    \n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).dayOfMonth();\n+    }\n+    protected int[] getDMYDS(long millis) {\n+        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISODayOfWeekDateTimeField extends TestGJDayOfWeekDateTimeField {\n+\n+    public TestISODayOfWeekDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISODayOfWeekDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).dayOfWeek();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISODayOfYearDateTimeField extends TestGJDayOfYearDateTimeField {\n+\n+    public TestISODayOfYearDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISODayOfYearDateTimeField.class);\n+    }\n+    \n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).dayOfYear();\n+    }\n+    protected int[] getDMYDS(long millis) {\n+        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);\n+    }\n+        \n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOHalfdayOfDayDateTimeField extends TestGJHalfdayOfDayDateTimeField {\n+\n+    public TestISOHalfdayOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOHalfdayOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).halfdayOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOHourOfDayDateTimeField extends TestGJHourOfDayDateTimeField {\n+\n+    public TestISOHourOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOHourOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).hourOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOHourOfHalfdayDateTimeField extends TestGJHourOfHalfdayDateTimeField {\n+\n+    public TestISOHourOfHalfdayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOHourOfHalfdayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).hourOfHalfday();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOMillisOfDayDateTimeField extends TestGJMillisOfDayDateTimeField {\n+\n+    public TestISOMillisOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOMillisOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).millisOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOMillisOfSecondDateTimeField extends TestGJMillisOfSecondDateTimeField {\n+\n+    public TestISOMillisOfSecondDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOMillisOfSecondDateTimeField.class);\n+    }\n+    \n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).millisOfSecond();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOMinuteOfDayDateTimeField extends TestGJMinuteOfDayDateTimeField {\n+\n+    public TestISOMinuteOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOMinuteOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).minuteOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOMinuteOfHourDateTimeField extends TestGJMinuteOfHourDateTimeField {\n+\n+    public TestISOMinuteOfHourDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOMinuteOfHourDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).minuteOfHour();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOMonthOfYearDateTimeField extends TestGJMonthOfYearDateTimeField {\n+\n+    public TestISOMonthOfYearDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOMonthOfYearDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).monthOfYear();\n+    }\n+    protected int[] getDMYDS(long millis) {\n+        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOSecondOfDayDateTimeField extends TestGJSecondOfDayDateTimeField {\n+\n+    public TestISOSecondOfDayDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOSecondOfDayDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).secondOfDay();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.iso.ISOChronology;\n+\n+/**\n+ * This class is a Junit unit test for the date time field.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestISOSecondOfMinuteDateTimeField extends TestGJSecondOfMinuteDateTimeField {\n+\n+    public TestISOSecondOfMinuteDateTimeField(String name) {\n+        super(name);\n+    }\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    public static TestSuite suite() {\n+        return new TestSuite(TestISOSecondOfMinuteDateTimeField.class);\n+    }\n+\n+    protected DateTimeField getField() {\n+        return ISOChronology.getInstance(getZone()).secondOfMinute();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/test/time/iso/TestSuiteISO.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-03 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.test.time.iso;\n+\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test suite.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSuiteISO extends TestSuite {\n+\n+    public TestSuiteISO(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+    \n+    public static TestSuite suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(TestISOMillisOfSecondDateTimeField.suite());\n+        suite.addTest(TestISOMillisOfDayDateTimeField.suite());\n+        suite.addTest(TestISOSecondOfMinuteDateTimeField.suite());\n+        suite.addTest(TestISOSecondOfDayDateTimeField.suite());\n+        suite.addTest(TestISOMinuteOfHourDateTimeField.suite());\n+        suite.addTest(TestISOMinuteOfDayDateTimeField.suite());\n+        suite.addTest(TestISOHalfdayOfDayDateTimeField.suite());\n+        suite.addTest(TestISOHourOfDayDateTimeField.suite());\n+        suite.addTest(TestISOHourOfHalfdayDateTimeField.suite());\n+        suite.addTest(TestISOClockhourOfDayDateTimeField.suite());\n+        suite.addTest(TestISOClockhourOfHalfdayDateTimeField.suite());\n+        \n+        suite.addTest(TestISODayOfWeekDateTimeField.suite());\n+        suite.addTest(TestISODayOfMonthDateTimeField.suite());\n+        suite.addTest(TestISODayOfYearDateTimeField.suite());\n+        \n+        suite.addTest(TestISOMonthOfYearDateTimeField.suite());\n+//        suite.addTest(TestISOYearDateTimeField.suite());\n+//        suite.addTest(TestISOYearOfEraDateTimeField.suite());\n+//        suite.addTest(TestISOYearOfCenturyDateTimeField.suite());\n+        return suite;\n+    }\n+    \n+}", "timestamp": 1071610767, "metainfo": ""}