{"sha": "524a3429ae5a7c2e77f468895ae933e4856bd17f", "log": "Remove explicit field array Rework resolve   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n  */\n package org.joda.time.partial;\n \n+import java.io.Serializable;\n import java.util.Arrays;\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.convert.ConverterManager;\n /**\n  * TimeOfDay is an immutable partial instant supporting the hour, minute, second\n  * and millisecond fields.\n+ * <p>\n+ * Calculations on TimeOfDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n  * <p>\n  * Each individual field can be queried in two ways:\n  * <ul>\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class TimeOfDay implements PartialInstant {\n+public final class TimeOfDay implements PartialInstant, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3633353405803318660L;\n \n     /** The index of the hourOfDay field in the field array */\n     private static final int HOUR_OF_DAY = 0;\n     /** The index of the millisOfSecond field in the field array */\n     private static final int MILLIS_OF_SECOND = 3;\n \n-    // TODO: Is chronology needed here?\n     /** The chronology in use */\n     private final Chronology iChronology;\n-    /** The fields supported by this partial instant */\n-    private final DateTimeField[] iFields;\n     /** The values of each field in this partial instant */\n     private final int[] iValues;\n \n-    // TODO serialize\n-\n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs a TimeOfDay with the current time, using ISOChronology in\n      * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n      */\n     public TimeOfDay() {\n         this(DateTimeUtils.currentTimeMillis(), null);\n     /**\n      * Constructs a TimeOfDay with the current time, using the specified chronology\n      * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n      *\n      * @param chronology  the chronology, null means ISOChronology in the default zone\n      */\n     /**\n      * Constructs a TimeOfDay extracting the partial fields from the specified\n      * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n      */\n     /**\n      * Constructs a TimeOfDay extracting the partial fields from the specified\n      * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n      *\n      * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n      * @param chronology  the chronology, null means ISOChronology in the default zone\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        iChronology = chronology;\n-        iFields = initFields(chronology);\n-        iValues = initValues(instant);\n+        iValues = initValues(instant, chronology);\n+        iChronology = chronology.withUTC();\n     }\n \n     /**\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        iChronology = chronology;\n-        iFields = initFields(chronology);\n-        iValues = initValues(converter.getInstantMillis(instant));\n+        iValues = initValues(converter.getInstantMillis(instant), chronology);\n+        iChronology = chronology.withUTC();\n     }\n \n     /**\n      * The recognised object types are defined in\n      * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n      *\n      * @param instant  the datetime object, must not be null\n      * @param chronology  the chronology, null means ISOChronology\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        iChronology = chronology;\n-        iFields = initFields(chronology);\n-        iValues = initValues(converter.getInstantMillis(instant, chronology));\n+        iValues = initValues(converter.getInstantMillis(instant, chronology), chronology);\n+        iChronology = chronology.withUTC();\n     }\n \n     /**\n      * Constructs a TimeOfDay with specified time field values using\n      * <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n      *\n      * @param hourOfDay  the hour of the day\n      * @param minuteOfHour  the minute of the hour\n \n     /**\n      * Constructs a TimeOfDay with specified time field values and chronology.\n-     * \n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n      *\n      * @param hourOfDay  the hour of the day\n      * @param minuteOfHour  the minute of the hour\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n-        iChronology = chronology;\n-        iFields = initFields(chronology);\n         // TODO: Validate\n         iValues = new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond};\n+        iChronology = chronology.withUTC();\n     }\n \n     /**\n     TimeOfDay(TimeOfDay partial, int[] values) {\n         super();\n         iChronology = partial.iChronology;\n-        iFields = partial.iFields;\n         iValues = values;\n     }\n \n     /**\n-     * Initialize the array of fields.\n-     * \n+     * Initialize the array of values.\n+     * \n+     * @param instant  the instant to use\n      * @param chrono  the chronology to use\n      */\n-    private DateTimeField[] initFields(Chronology chrono) {\n-        return new DateTimeField[] {\n-            chrono.hourOfDay(),\n-            chrono.minuteOfHour(),\n-            chrono.secondOfMinute(),\n-            chrono.millisOfSecond(),\n-        };\n-    }\n-\n-    /**\n-     * Initialize the array of values.\n-     * \n-     * @param instant  the instant to use\n-     */\n-    private int[] initValues(long instant) {\n+    private int[] initValues(long instant, Chronology chrono) {\n         return new int[] {\n-            iFields[0].get(instant),\n-            iFields[1].get(instant),\n-            iFields[2].get(instant),\n-            iFields[3].get(instant),\n+            chrono.hourOfDay().get(instant),\n+            chrono.minuteOfHour().get(instant),\n+            chrono.secondOfMinute().get(instant),\n+            chrono.millisOfSecond().get(instant),\n         };\n     }\n \n      * @return the field\n      */\n     protected DateTimeField getField(int index) {\n-        return iFields[index];\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return iChronology.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return iChronology.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return iChronology.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return iChronology.millisOfSecond();\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n     }\n     \n     /**\n      * @return the fields supported, largest to smallest\n      */\n     public DateTimeField[] getSupportedFields() {\n-        return (DateTimeField[]) iFields.clone();\n+        return new DateTimeField[] {\n+            iChronology.hourOfDay(),\n+            iChronology.minuteOfHour(),\n+            iChronology.secondOfMinute(),\n+            iChronology.millisOfSecond(),\n+        };\n     }\n \n     /**\n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n     public int get(DateTimeField field) {\n-        for (int i = 0; i < iFields.length; i++) {\n-            if (iFields[i] == field) {\n-                return iValues[i];\n-            }\n+        if (iChronology.hourOfDay() == field) {\n+            return getValue(HOUR_OF_DAY);\n+        }\n+        if (iChronology.minuteOfHour() == field) {\n+            return getValue(MINUTE_OF_HOUR);\n+        }\n+        if (iChronology.secondOfMinute() == field) {\n+            return getValue(SECOND_OF_MINUTE);\n+        }\n+        if (iChronology.millisOfSecond() == field) {\n+            return getValue(MILLIS_OF_SECOND);\n         }\n         throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported by TimeOfDay\");\n     }\n      * @return true if the field is supported\n      */\n     public boolean isSupported(DateTimeField field) {\n-        for (int i = 0; i < iFields.length; i++) {\n-            if (iFields[i] == field) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return \n+            iChronology.hourOfDay() == field ||\n+            iChronology.minuteOfHour() == field ||\n+            iChronology.secondOfMinute() == field ||\n+            iChronology.millisOfSecond() == field;\n     }\n \n     //-----------------------------------------------------------------------\n      * @param baseMillis  source of missing fields\n      * @return the combined instant in milliseconds\n      */\n-    public long resolve(long baseMillis) {\n+    public long resolve(long baseMillis, DateTimeZone zone) {\n+        Chronology chrono = iChronology.withZone(zone);\n         long millis = baseMillis;\n-        for (int i = 0; i < iFields.length; i++) {\n-            millis = iFields[i].set(millis, iValues[i]);\n-        }\n+        millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY));\n+        millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR));\n+        millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE));\n+        millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND));\n         return millis;\n     }\n \n         }\n         TimeOfDay other = (TimeOfDay) timeOfDay;\n         return Arrays.equals(iValues, other.iValues) &&\n-               Arrays.equals(iFields, other.iFields);\n+               iChronology == other.iChronology;\n     }\n \n     /**\n         int total = 157;\n         for (int i = 0; i < iValues.length; i++) {\n             total = 23 * total + getValue(i);\n-            total += getField(i).hashCode();\n-        }\n+        }\n+        total += iChronology.hashCode();\n         return total;\n     }\n ", "timestamp": 1083540428, "metainfo": ""}