{"sha": "159f5f78a4ee0145e3f124317de67c9e4d0acb54", "log": "Fix period parsing bugs.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormat.java\n     private final PeriodFormatter iDefault;\n \n     private PeriodFormat() {\n+        String[] variants = {\" \", \",\", \",and \", \", and \"};\n         iDefault = new PeriodFormatterBuilder()\n             .appendYears()\n             .appendSuffix(\" year\", \" years\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendMonths()\n             .appendSuffix(\" month\", \" months\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendWeeks()\n             .appendSuffix(\" week\", \" weeks\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendDays()\n             .appendSuffix(\" day\", \" days\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendHours()\n             .appendSuffix(\" hour\", \" hours\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendMinutes()\n             .appendSuffix(\" minute\", \" minutes\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendSeconds()\n             .appendSuffix(\" second\", \" seconds\")\n-            .appendSeparator(\", \", \" and \")\n+            .appendSeparator(\", \", \" and \", variants)\n             .appendMillis()\n             .appendSuffix(\" millisecond\", \" milliseconds\")\n             .toFormatter();\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n import java.io.IOException;\n import java.io.Writer;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.TreeSet;\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DurationFieldType;\n      * @throws IllegalStateException if this separator follows a previous one\n      */\n     public PeriodFormatterBuilder appendSeparator(String text) {\n-        return appendSeparator(text, text, true, true);\n+        return appendSeparator(text, text, null, true, true);\n     }\n \n     /**\n      * Append a separator, which is output only if fields are printed after the separator.\n      * <p>\n-     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * For example,\n+     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n      * will only output the comma if the hours fields is output.\n      * <p>\n      * The text will be parsed case-insensitively.\n      * @throws IllegalStateException if this separator follows a previous one\n      */\n     public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n-        return appendSeparator(text, text, false, true);\n+        return appendSeparator(text, text, null, false, true);\n     }\n \n     /**\n      * Append a separator, which is output only if fields are printed before the separator.\n      * <p>\n-     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * For example,\n+     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n      * will only output the comma if the days fields is output.\n      * <p>\n      * The text will be parsed case-insensitively.\n      * @throws IllegalStateException if this separator follows a previous one\n      */\n     public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n-        return appendSeparator(text, text, true, false);\n+        return appendSeparator(text, text, null, true, false);\n     }\n \n     /**\n      * @throws IllegalStateException if this separator follows a previous one\n      */\n     public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n-        return appendSeparator(text, finalText, true, true);\n-    }\n-\n-    private PeriodFormatterBuilder appendSeparator(String text, String finalText, boolean useBefore, boolean useAfter) {\n+        return appendSeparator(text, finalText, null, true, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * This method changes the separator depending on whether it is the last separator\n+     * to be output.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n+     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n+     * and '1' if just one field is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @param finalText  the text used used if this is the final separator to be printed\n+     * @param variants  set of text values which are also acceptable when parsed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n+                                                  String[] variants) {\n+        return appendSeparator(text, finalText, variants, true, true);\n+    }\n+\n+    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n+                                                   String[] variants,\n+                                                   boolean useBefore, boolean useAfter) {\n         if (text == null || finalText == null) {\n             throw new IllegalArgumentException();\n         }\n         List formatters = iFormatters;\n         if (formatters.size() == 0) {\n             if (useAfter && useBefore == false) {\n-                formatters.add(new Separator(text, finalText, Literal.EMPTY, useBefore, useAfter));\n+                formatters.add\n+                    (new Separator(text, finalText, variants, Literal.EMPTY, useBefore, useAfter));\n             }\n             return this;\n         }\n         } else {\n             BasePeriodFormatter composite = createComposite(formatters);\n             formatters.clear();\n-            formatters.add(new Separator(text, finalText, composite, useBefore, useAfter));\n+            formatters.add\n+                (new Separator(text, finalText, variants, composite, useBefore, useAfter));\n         }\n         \n         return this;\n             implements PeriodFormatter {\n         private final String iText;\n         private final String iFinalText;\n+        private final String[] iParsedForms;\n \n         private final boolean iUseBefore;\n         private final boolean iUseAfter;\n         private BasePeriodFormatter iBefore;\n         private BasePeriodFormatter iAfter;\n \n-        Separator(String text, String finalText, BasePeriodFormatter before, boolean useBefore, boolean useAfter) {\n+        Separator(String text, String finalText, String[] variants,\n+                  BasePeriodFormatter before, boolean useBefore, boolean useAfter) {\n             iText = text;\n             iFinalText = finalText;\n+\n+            if ((finalText == null || text.equals(finalText)) &&\n+                (variants == null || variants.length == 0)) {\n+\n+                iParsedForms = new String[] {text};\n+            } else {\n+                // Filter and reverse sort the parsed forms.\n+                TreeSet parsedSet = new TreeSet(String.CASE_INSENSITIVE_ORDER);\n+                parsedSet.add(text);\n+                parsedSet.add(finalText);\n+                if (variants != null) {\n+                    for (int i=variants.length; --i>=0; ) {\n+                        parsedSet.add(variants[i]);\n+                    }\n+                }\n+                ArrayList parsedList = new ArrayList(parsedSet);\n+                Collections.reverse(parsedList);\n+                iParsedForms = (String[]) parsedList.toArray(new String[parsedList.size()]);\n+            }\n+\n             iBefore = before;\n             iUseBefore = useBefore;\n             iUseAfter = useAfter;\n \n         public int parseInto(ReadWritablePeriod period,\n                              String periodStr, int position) {\n-            final int oldPos = position;\n-\n+            int oldPos = position;\n             position = iBefore.parseInto(period, periodStr, position);\n+\n             if (position < 0) {\n                 return position;\n             }\n+\n+            boolean found = false;\n             if (position > oldPos) {\n-                // Since position advanced, this separator is\n-                // allowed. Optionally parse it.\n-                if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n-                    position += iText.length();\n-                } else if (iText != iFinalText && periodStr.regionMatches\n-                           (true, position, iFinalText, 0, iFinalText.length())) {\n-                    position += iFinalText.length();\n-                }\n-            }\n+                // Consume this separator.\n+                String[] parsedForms = iParsedForms;\n+                int length = parsedForms.length;\n+                for (int i=0; i < length; i++) {\n+                    String parsedForm = parsedForms[i];\n+                    if ((parsedForm == null || parsedForm.length() == 0) ||\n+                        periodStr.regionMatches\n+                        (true, position, parsedForm, 0, parsedForm.length())) {\n+                        \n+                        position += parsedForm.length();\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            oldPos = position;\n             position = iAfter.parseInto(period, periodStr, position);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            if (found && position == oldPos) {\n+                // Separator should not have been supplied.\n+                return ~oldPos;\n+            }\n+\n+            if (position > oldPos && !found && !iUseBefore) {\n+                // Separator was required.\n+                return ~oldPos;\n+            }\n+\n             return position;\n         }\n ", "timestamp": 1101108788, "metainfo": ""}