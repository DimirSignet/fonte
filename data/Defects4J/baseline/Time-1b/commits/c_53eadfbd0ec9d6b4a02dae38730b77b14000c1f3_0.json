{"sha": "53eadfbd0ec9d6b4a02dae38730b77b14000c1f3", "log": "Support parsing of date-time zone IDs like Europe/London", "commit": "\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getZone() == null) {\n+        if (iOffsetParsed && bucket.getOffset() != null) {\n             int parsedOffset = bucket.getOffset();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n             chrono = chrono.withZone(parsedZone);\n+        } else if (bucket.getZone() != null) {\n+            chrono = chrono.withZone(bucket.getZone());\n         }\n         instant.setChronology(chrono);\n+        if (iZone != null) {\n+            instant.setZone(iZone);\n+        }\n         return newPos;\n     }\n \n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\n+                if (bucket.getOffset() != null) {  // treat withOffsetParsed() as being true\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n                 return new LocalDateTime(millis, chrono);\n             }\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getZone() == null) {\n+                if (iOffsetParsed && bucket.getOffset() != null) {\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n-                return new DateTime(millis, chrono);\n+                DateTime dt = new DateTime(millis, chrono);\n+                if (iZone != null) {\n+                    dt = dt.withZone(iZone);\n+                }\n+                return dt;\n             }\n         } else {\n             newPos = ~newPos;\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n-                if (iOffsetParsed && bucket.getZone() == null) {\n+                if (iOffsetParsed && bucket.getOffset() != null) {\n                     int parsedOffset = bucket.getOffset();\n                     DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                     chrono = chrono.withZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    chrono = chrono.withZone(bucket.getZone());\n                 }\n-                return new MutableDateTime(millis, chrono);\n+                MutableDateTime dt = new MutableDateTime(millis, chrono);\n+                if (iZone != null) {\n+                    dt.setZone(iZone);\n+                }\n+                return dt;\n             }\n         } else {\n             newPos = ~newPos;\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     /**\n      * Instructs the printer to emit the identifier of the time zone.\n-     * This field cannot currently be parsed.\n+     * From version 2.0, this field can be parsed.\n      *\n      * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneId() {\n-        return append0(new TimeZoneName(TimeZoneName.ID), null);\n+        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n     }\n \n     /**\n \n         static final int LONG_NAME = 0;\n         static final int SHORT_NAME = 1;\n-        static final int ID = 2;\n \n         private final int iType;\n \n                     return displayZone.getName(instant, locale);\n                 case SHORT_NAME:\n                     return displayZone.getShortName(instant, locale);\n-                case ID:\n-                    return displayZone.getID();\n             }\n             return \"\";\n         }\n \n         public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n             // no zone info\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static enum TimeZoneId\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        INSTANCE;\n+        static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\n+        static final int MAX_LENGTH;\n+        static {\n+            int max = 0;\n+            for (String id : ALL_IDS) {\n+                max = Math.max(max, id.length());\n+            }\n+            MAX_LENGTH = max;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return MAX_LENGTH;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(displayZone != null ? displayZone.getID() : \"\");\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(displayZone != null ? displayZone.getID() : \"\");\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            // no zone info\n+        }\n+\n+        public int estimateParsedLength() {\n+            return MAX_LENGTH;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            String str = text.substring(position);\n+            for (String id : ALL_IDS) {\n+                if (str.startsWith(id)) {\n+                    bucket.setZone(DateTimeZone.forID(id));\n+                    return position + id.length();\n+                }\n+            }\n+            return ~position;\n         }\n     }\n \n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n     \n     // TimeZone to switch to in computeMillis. If null, use offset.\n     private DateTimeZone iZone;\n-    private int iOffset;\n+    private Integer iOffset;\n     /** The locale to use for parsing. */\n     private Locale iLocale;\n     /** Used for parsing two-digit years. */\n         super();\n         chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n+        iZone = chrono.getZone();\n         iChrono = chrono.withUTC();\n         iLocale = (locale == null ? Locale.getDefault() : locale);\n-        setZone(chrono.getZone());\n         iPivotYear = pivotYear;\n         iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the time zone used by computeMillis, or null if an offset is\n-     * used instead.\n+     * Returns the time zone used by computeMillis.\n      */\n     public DateTimeZone getZone() {\n         return iZone;\n     }\n-    \n-    /**\n-     * Set a time zone to be used when computeMillis is called, which\n-     * overrides any set time zone offset.\n-     *\n-     * @param zone the date time zone to operate in, or null if UTC\n+\n+    /**\n+     * Set a time zone to be used when computeMillis is called.\n+     *\n+     * @param zone the date time zone to operate in, not null\n      */\n     public void setZone(DateTimeZone zone) {\n         iSavedState = null;\n-        iZone = zone == DateTimeZone.UTC ? null : zone;\n-        iOffset = 0;\n-    }\n-    \n+        iZone = zone;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the time zone offset in milliseconds used by computeMillis,\n-     * unless getZone doesn't return null.\n-     */\n-    public int getOffset() {\n+     * Returns the time zone offset in milliseconds used by computeMillis.\n+     */\n+    public Integer getOffset() {\n         return iOffset;\n     }\n-    \n-    /**\n-     * Set a time zone offset to be used when computeMillis is called, which\n-     * overrides the time zone.\n-     */\n-    public void setOffset(int offset) {\n+\n+    /**\n+     * Set a time zone offset to be used when computeMillis is called.\n+     */\n+    public void setOffset(Integer offset) {\n         iSavedState = null;\n         iOffset = offset;\n-        iZone = null;\n     }\n \n     //-----------------------------------------------------------------------\n             throw e;\n         }\n         \n-        if (iZone == null) {\n+        if (iOffset != null) {\n             millis -= iOffset;\n-        } else {\n+        } else if (iZone != null) {\n             int offset = iZone.getOffsetFromLocal(millis);\n             millis -= offset;\n             if (offset != iZone.getOffset(millis)) {\n \n     class SavedState {\n         final DateTimeZone iZone;\n-        final int iOffset;\n+        final Integer iOffset;\n         final SavedField[] iSavedFields;\n         final int iSavedFieldsCount;\n         \n--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2011 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n import org.joda.time.DateTime;\n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDateTime;\n \n /**\n  * This class is a Junit unit test for DateTimeFormatterBuilder.\n         } catch (IllegalArgumentException e) {\n         }\n     }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_appendTimeZoneId() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n+        bld.appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        assertEquals(\"Asia/Tokyo\", f.print(new DateTime(2007, 3, 4, 0, 0, 0, zone)));\n+        assertEquals(zone, f.parseDateTime(\"Asia/Tokyo\").getZone());\n+        try {\n+            f.parseDateTime(\"Nonsense\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    public void test_printParseZoneTokyo() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n+        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n+    }\n+\n+    public void test_printParseZoneParis() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 Europe/Paris\", f.print(dt));\n+        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n+        assertEquals(dt, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 Europe/Paris\"));\n+    }\n+\n+    public void test_printParseOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n+        assertEquals(dt.withZone(DateTimeZone.getDefault()), f.parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(dt, f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00\"));\n+    }\n+\n+    public void test_printParseOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n+        assertEquals(dt, f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt.withZone(paris), f.withZone(paris).parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+    }\n+\n+    public void test_parseWrongOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected.withZone(zone), f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+        // parses offset time returning offset zone\n+        assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+        // parses offset time then converts to default zone\n+        assertEquals(expected.withZone(DateTimeZone.getDefault()), f.parseDateTime(\"2007-03-04 12:30 +07:00\"));\n+    }\n+\n+    public void test_parseWrongOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7));\n+        // parses offset time then adjusts to parsed zone\n+        assertEquals(expected.withZone(zone), f.parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected.withZone(zone), f.withZone(zone).parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time returning offset zone (ignores zone)\n+        assertEquals(expected, f.withOffsetParsed().parseDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_localPrintParseZoneTokyo() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n+    }\n+\n+    public void test_localPrintParseOffset() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2);\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 +09:00\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+        assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +09:00\"));\n+    }\n+\n+    public void test_localPrintParseOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, zone);\n+        assertEquals(\"2007-03-04 12:30 +09:00 Asia/Tokyo\", f.print(dt));\n+        \n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+        assertEquals(expected, f.withZone(paris).parseLocalDateTime(\"2007-03-04 12:30 +09:00 Asia/Tokyo\"));\n+    }\n+\n+    public void test_localParseWrongOffsetAndZone() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneOffset(\"Z\", true, 2, 2).appendLiteral(' ').appendTimeZoneId();\n+        DateTimeFormatter f = bld.toFormatter();\n+        \n+        DateTimeZone zone = DateTimeZone.forID(\"Asia/Tokyo\");\n+        LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n+        // parses offset time then adjusts to parsed zone\n+        assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time then adjusts to requested zone\n+        assertEquals(expected, f.withZone(zone).parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+        // parses offset time returning offset zone (ignores zone)\n+        assertEquals(expected, f.withOffsetParsed().parseLocalDateTime(\"2007-03-04 12:30 +07:00 Asia/Tokyo\"));\n+    }\n+\n }", "timestamp": 1312026485, "metainfo": ""}