{"sha": "ab25e10c839a4dd700500ab7e88fdb4aae7862f0", "log": "Fixed definition of ISO century related fields.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n  * <p>\n  * With the exception of century related fields, ISOChronology is exactly the\n  * same as {@link GregorianChronology}. In this chronology, centuries and year\n- * of century are zero based. For CE years, the century is determined by\n- * dropping the last two digits of the year. The year of century is the value\n- * of the last two digits.\n+ * of century are zero based. For all years, the century is determined by\n+ * dropping the last two digits of the year, ignoring sign. The year of century\n+ * is the value of the last two year digits.\n  * <p>\n  * ISOChronology is thread-safe and immutable.\n  *\n         if (getBase().getDateTimeZone() == DateTimeZone.UTC) {\n             // Use zero based century and year of century.\n             fields.centuryOfEra = new DividedDateTimeField\n-                (fields.yearOfEra, \"centuryOfEra\", \"centuries\", 100);\n+                (ISOYearOfEraDateTimeField.INSTANCE, \"centuryOfEra\", \"centuries\", 100);\n             fields.yearOfCentury = new RemainderDateTimeField\n                 ((DividedDateTimeField)fields.centuryOfEra, \"yearOfCentury\");\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * This field is not publicy exposed by ISOChronology, but rather it is used to\n+ * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of\n+ * the year.\n+ *\n+ * @author Brian S O'Neill\n+ * @see GJYearOfEraDateTimeField\n+ */\n+class ISOYearOfEraDateTimeField extends DecoratedDateTimeField {\n+\n+    static final long serialVersionUID = 7037524068969447317L;\n+\n+    /**\n+     * Singleton instance\n+     */\n+    static final DateTimeField INSTANCE = new ISOYearOfEraDateTimeField();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ISOYearOfEraDateTimeField() {\n+        super(GregorianChronology.getInstanceUTC().year(), \"yearOfEra\");\n+    }\n+\n+    public int get(long instant) {\n+        int year = getWrappedField().get(instant);\n+        return year < 0 ? -year : year;\n+    }\n+\n+    public long add(long instant, int years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long addWrapped(long instant, int years) {\n+        return getWrappedField().addWrapped(instant, years);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, year, 0, getMaximumValue());\n+        if (getWrappedField().get(instant) < 0) {\n+            year = -year;\n+        }\n+        return super.set(instant, year);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+}", "timestamp": 1076782128, "metainfo": ""}