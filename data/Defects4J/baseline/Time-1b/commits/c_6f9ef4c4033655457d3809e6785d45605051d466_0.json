{"sha": "6f9ef4c4033655457d3809e6785d45605051d466", "log": "Interval:   Added gap method that returns the gap between two intervals.   Added abuts method that returns true if two intervals abut. DateTimeUtils:   Added getReadableInterval(ReadableInterval) method to handle null intervals   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the interval handling null.\n+     * <p>\n+     * If the interval is <code>null</code>, an interval representing now\n+     * to now in the {@link ISOChronology#getInstance() ISOChronology}\n+     * will be returned. Otherwise, the interval specified is returned.\n+     * \n+     * @param interval  the interval to use, null means now to now\n+     * @return the interval, never null\n+     */\n+    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n+        if (interval == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            interval = new Interval(now, now);\n+        }\n+        return interval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets the chronology handling null.\n      * <p>\n      * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the interval where this interval and that specified overlap.\n-     * \n+     * Gets the overlap where this interval and that specified.\n+     * <p>\n+     * Any two intervals can overlap, abut, or have a gap between them.\n+     * This method returns the amount of the overlap, only if the\n+     * intervals do overlap.\n+     * If the intervals do not overlap, then null is returned.\n+     *\n      * @param interval  the interval to examine, null means now\n      * @return the overlap interval, null if no overlap\n      * @since 1.1\n      */\n     public Interval overlap(ReadableInterval interval) {\n-        if (interval == null) {\n-            long now = DateTimeUtils.currentTimeMillis();\n-            interval = new Interval(now, now);\n-        }\n+        interval = DateTimeUtils.getReadableInterval(interval);\n         if (overlaps(interval) == false) {\n             return null;\n         }\n         long start = Math.max(getStartMillis(), interval.getStartMillis());\n         long end = Math.min(getEndMillis(), interval.getEndMillis());\n         return new Interval(start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the gap between this interval and that specified.\n+     * <p>\n+     * Any two intervals can overlap, abut, or have a gap between them.\n+     * This method returns the amount of the gap only if the\n+     * intervals do actually have a gap between them.\n+     * If the intervals overlap or abut, then null is returned.\n+     *\n+     * @param interval  the interval to examine, null means now\n+     * @return the gap interval, null if no gap\n+     * @since 1.1\n+     */\n+    public Interval gap(ReadableInterval interval) {\n+        interval = DateTimeUtils.getReadableInterval(interval);\n+        if (overlaps(interval) || abuts(interval)) {\n+            return null;\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        if (thisStart >= otherEnd) {\n+            return new Interval(otherEnd, thisStart);\n+        } else {\n+            return new Interval(thisEnd, otherStart);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this interval abut with the interval specified.\n+     * <p>\n+     * An interval abuts if it starts immediately after, or\n+     * ends immediately before this interval without overlap.\n+     *\n+     * @param interval  the interval to examine, null means now\n+     * @return true if the interval abuts\n+     * @since 1.1\n+     */\n+    public boolean abuts(ReadableInterval interval) {\n+        interval = DateTimeUtils.getReadableInterval(interval);\n+        return (interval.getEndMillis() == getStartMillis() ||\n+                getEndMillis() == interval.getStartMillis());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testGetReadableInterval_ReadableInterval() {\n+        ReadableInterval input = new Interval(0, 100L);\n+        assertEquals(input, DateTimeUtils.getReadableInterval(input));\n+        \n+        try {\n+            DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+            assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW), DateTimeUtils.getReadableInterval(null));\n+        } finally {\n+            DateTimeUtils.setCurrentMillisSystem();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testGetChronology_Chronology() {\n         assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getChronology(BuddhistChronology.getInstance()));\n         assertEquals(ISOChronology.getInstance(), DateTimeUtils.getChronology(null));\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testGap_RInterval() {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(\n+                new Interval(TEST_TIME2, TEST_TIME2 + 2),\n+                test.gap(new Interval(TEST_TIME2 + 2, TEST_TIME2 + 4)));\n+        assertEquals(\n+                null,\n+                test.gap(new Interval(TEST_TIME2, TEST_TIME2)));\n+\n+        assertEquals(\n+                new Interval(TEST_TIME1 - 2, TEST_TIME1),\n+                test.gap(new Interval(TEST_TIME1 - 4, TEST_TIME1 - 2)));\n+        assertEquals(\n+                null,\n+                test.gap(new Interval(TEST_TIME1 - 2, TEST_TIME1)));\n+\n+        assertEquals(\n+                null,\n+                test.gap(new Interval(TEST_TIME1, TEST_TIME2)));\n+        assertEquals(\n+                null,\n+                test.gap(new Interval(TEST_TIME1 + 1, TEST_TIME2 - 1)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAbuts_RInterval() {\n+        Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n+        \n+        assertEquals(\n+                false,\n+                test.abuts(new Interval(TEST_TIME2 + 2, TEST_TIME2 + 4)));\n+        assertEquals(\n+                true,\n+                test.abuts(new Interval(TEST_TIME2, TEST_TIME2)));\n+\n+        assertEquals(\n+                false,\n+                test.abuts(new Interval(TEST_TIME1 - 4, TEST_TIME1 - 2)));\n+        assertEquals(\n+                true,\n+                test.abuts(new Interval(TEST_TIME1 - 2, TEST_TIME1)));\n+\n+        assertEquals(\n+                false,\n+                test.abuts(new Interval(TEST_TIME1, TEST_TIME2)));\n+        assertEquals(\n+                false,\n+                test.abuts(new Interval(TEST_TIME1 + 1, TEST_TIME2 - 1)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testIsBefore_long() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         ", "timestamp": 1123104784, "metainfo": ""}