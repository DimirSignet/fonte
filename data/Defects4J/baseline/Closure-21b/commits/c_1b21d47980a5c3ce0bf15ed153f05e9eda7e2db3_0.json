{"sha": "1b21d47980a5c3ce0bf15ed153f05e9eda7e2db3", "log": "Ignore functions like goog.inherits, where we already know what properties they have and how to account for them.  Tested: yes  R=johnlenz   Revision created by MOE tool push_codebase. MOE_MIGRATION=5018   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n class CheckGlobalNames implements CompilerPass {\n \n   private final AbstractCompiler compiler;\n+  private final CodingConvention convention;\n   private final CheckLevel level;\n \n   private GlobalNamespace namespace = null;\n    */\n   CheckGlobalNames(AbstractCompiler compiler, CheckLevel level) {\n     this.compiler = compiler;\n+    this.convention = compiler.getCodingConvention();\n     this.level = level;\n   }\n \n     findPrototypeProps(\"Object\", objectPrototypeProps);\n     findPrototypeProps(\"Function\", functionPrototypeProps);\n     objectPrototypeProps.addAll(\n-        compiler.getCodingConvention().getIndirectlyDeclaredProperties());\n+        convention.getIndirectlyDeclaredProperties());\n \n     for (Name name : namespace.getNameForest()) {\n       // Skip extern names. Externs are often not runnable as real code,\n     // We assume that for global object literals and types (constructors and\n     // interfaces), we can find all the properties inherited from the prototype\n     // chain of functions and objects.\n-    //\n-    // We could improve this check by classifying aliasing gets. For example,\n-    // goog.inherits is an aliasing get that adds a known set of properties.\n-    if (name.parent == null || name.parent.aliasingGets > 0) {\n+    if (name.parent == null) {\n+      return false;\n+    }\n+\n+    boolean parentIsAliased = false;\n+    if (name.parent.aliasingGets > 0) {\n+      for (Ref ref : name.parent.getRefs()) {\n+        if (ref.type == Ref.Type.ALIASING_GET) {\n+          Node aliaser = ref.getNode().getParent();\n+\n+          // We don't need to worry about known aliased, because\n+          // they're already covered by the getIndirectlyDeclaredProperties\n+          // call at the top.\n+          boolean isKnownAlias =\n+              aliaser.isCall() &&\n+              (convention.getClassesDefinedByCall(aliaser) != null ||\n+               convention.getSingletonGetterClassName(aliaser) != null);\n+          if (!isKnownAlias) {\n+            parentIsAliased = true;\n+          }\n+        }\n+      }\n+    }\n+\n+    if (parentIsAliased) {\n       return false;\n     }\n \n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n         \"SubFoo.inherits(Foo);\" +\n         \"SubFoo.superClass_.bar();\");\n   }\n+\n+  public void testGoogInheritsAlias() {\n+    testSame(\n+        \"Function.prototype.inherits = function(ctor) {\" +\n+        \"  this.superClass_ = ctor;\" +\n+        \"};\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() {};\" +\n+        \"/** @constructor */ function SubFoo() {}\" +\n+        \"SubFoo.inherits(Foo);\" +\n+        \"SubFoo.superClass_.bar();\");\n+  }\n+\n+  public void testGoogInheritsAlias2() {\n+    testSame(\n+        CompilerTypeTestCase.CLOSURE_DEFS +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() {};\" +\n+        \"/** @constructor */ function SubFoo() {}\" +\n+        \"goog.inherits(SubFoo, Foo);\" +\n+        \"SubFoo.superClazz();\",\n+         UNDEFINED_NAME_WARNING);\n+  }\n }", "timestamp": 1339778628, "metainfo": ""}