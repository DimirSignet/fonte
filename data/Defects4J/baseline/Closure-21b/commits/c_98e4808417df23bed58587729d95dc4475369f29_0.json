{"sha": "98e4808417df23bed58587729d95dc4475369f29", "log": "Remove properties defined on \"this\" but never read.  R=nicksantos DELTA=336  (307 added, 28 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3701   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     if (options.removeUnusedPrototypeProperties) {\n       passes.add(removeUnusedPrototypeProperties);\n+      passes.add(removeUnusedClassProperties);\n     }\n \n     assertAllLoopablePasses(passes);\n       return new RemoveUnusedPrototypeProperties(\n           compiler, options.removeUnusedPrototypePropertiesInExterns,\n           !options.removeUnusedVars);\n+    }\n+  };\n+\n+  /**\n+   * Remove prototype properties that do not appear to be used.\n+   */\n+  final PassFactory removeUnusedClassProperties =\n+      new PassFactory(\"removeUnusedClassProperties\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RemoveUnusedClassProperties(compiler);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n     t.traverseRoots(roots);\n   }\n \n+  public static void traverseRoots(\n+      AbstractCompiler compiler, Callback cb, Node ... roots) {\n+    NodeTraversal t = new NodeTraversal(compiler, cb);\n+    t.traverseRoots(roots);\n+  }\n+\n   /**\n    * Traverses a branch.\n    */\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n       if (isCall(site)) {\n         Node callNode = useNodeParent;\n         Preconditions.checkState(callNode.isCall());\n-        if (isValueUsed(callNode)) {\n+        if (NodeUtil.isExpressionResultUsed(callNode)) {\n           return true;\n         }\n       } else {\n \n     // No possible use of the definition result\n     return false;\n-  }\n-\n-  /**\n-   * Determines if the name node acts as the function name in a call expression.\n-   */\n-  private static boolean isValueUsed(Node node) {\n-    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n-    Node parent = node.getParent();\n-    switch (parent.getType()) {\n-      case Token.EXPR_RESULT:\n-        return false;\n-      case Token.HOOK:\n-      case Token.AND:\n-      case Token.OR:\n-        return (node == parent.getFirstChild()) ? true : isValueUsed(parent);\n-      case Token.COMMA:\n-        return (node == parent.getFirstChild()) ? false : isValueUsed(parent);\n-      case Token.FOR:\n-        if (NodeUtil.isForIn(parent)) {\n-          return true;\n-        } else {\n-          // Only an expression whose result is in the condition part of the\n-          // expression is used.\n-          return (parent.getChildAtIndex(1) == node);\n-        }\n-      default:\n-        return true;\n-    }\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Look for internal properties set using \"this\" but never read.  Explicitly\n+ * ignored is the possibility that these properties\n+ * may be indirectly referenced using \"for-in\" or \"Object.keys\".  This is the\n+ * same assumption used with RemoveUnusedPrototypeProperties but is by slightly\n+ * wider in scope.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+class RemoveUnusedClassProperties\n+    implements CompilerPass, NodeTraversal.Callback {\n+  final AbstractCompiler compiler;\n+  private boolean inExterns;\n+  private Set<String> used = Sets.newHashSet();\n+  private List<Node> candidates = Lists.newArrayList();\n+\n+  RemoveUnusedClassProperties(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverseRoots(compiler, this, externs, root);\n+    removeUnused();\n+  }\n+\n+  private void removeUnused() {\n+    for (Node n : candidates) {\n+      Preconditions.checkState(n.isGetProp());\n+      if (!used.contains(n.getLastChild().getString())) {\n+        Node parent = n.getParent();\n+        if (NodeUtil.isAssignmentOp(parent)) {\n+          Node assign = parent;\n+          Preconditions.checkState(assign != null\n+              && NodeUtil.isAssignmentOp(assign)\n+              && assign.getFirstChild() == n);\n+          // 'this.x = y' to 'y'\n+          assign.getParent().replaceChild(assign,\n+              assign.getLastChild().detachFromParent());\n+        } else if (parent.isInc() || parent.isDec()) {\n+          parent.getParent().replaceChild(parent, Node.newNumber(0));\n+        } else {\n+          throw new IllegalStateException(\"unexpected: \"+ parent);\n+        }\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+    if (n.isScript()) {\n+      this.inExterns = n.getStaticSourceFile().isExtern();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+     switch (n.getType()) {\n+       case Token.GETPROP:\n+         if (inExterns || isPinningPropertyUse(n)) {\n+           used.add(n.getLastChild().getString());\n+         } else {\n+           // This is a definition of a property but it is only removable\n+           // if it is defined on \"this\".\n+           if (n.getFirstChild().isThis()) {\n+             candidates.add(n);\n+           }\n+         }\n+         break;\n+\n+       case Token.CALL:\n+         // Look for properties referenced through \"JSCompiler_propertyRename\".\n+         Node target = n.getFirstChild();\n+         if (n.hasMoreThanOneChild()\n+             && target.isName()\n+             && target.getString().equals(NodeUtil.JSC_PROPERTY_NAME_FN)) {\n+           Node propName = target.getNext();\n+           if (propName.isString()) {\n+             used.add(propName.getString());\n+           }\n+         }\n+         break;\n+     }\n+  }\n+\n+  /**\n+   * @return Whether the property is used in a way that prevents its removal.\n+   */\n+  private boolean isPinningPropertyUse(Node n) {\n+    // Rather than looking for cases that are uses, we assume all references are\n+    // pinning uses unless they are:\n+    //  - a simple assignment (x.a = 1)\n+    //  - a compound assignment or increment (x++, x += 1) whose result is\n+    //    otherwise unused\n+\n+    Node parent = n.getParent();\n+    if (n == parent.getFirstChild()) {\n+      if (parent.isAssign()) {\n+        // A simple assignment doesn't pin the property.\n+        return false;\n+      } else if (NodeUtil.isAssignmentOp(parent)\n+            || parent.isInc() || parent.isDec()) {\n+        // In general, compound assignments are both reads and writes, but\n+        // if the property is never otherwise read we can consider it simply\n+        // a write.\n+        // However if the assign expression is used as part of a larger\n+        // expression, we much consider it a read. For example:\n+        //    x = (y.a += 1);\n+        return NodeUtil.isExpressionResultUsed(parent);\n+      }\n+    }\n+    return true;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedClassPropertiesTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class RemoveUnusedClassPropertiesTest extends CompilerTestCase {\n+\n+  private static final String EXTERNS =\n+      \"var window;\\n\" +\n+      \"function alert(a) {}\\n\" +\n+      \"var EXT = {};\" +\n+      \"EXT.ext;\";\n+\n+  public RemoveUnusedClassPropertiesTest() {\n+    super(EXTERNS);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new RemoveUnusedClassProperties(compiler);\n+  }\n+\n+  public void testSimple1() {\n+    // A property defined on \"this\" can be removed\n+    test(\"this.a = 2\", \"2\");\n+    test(\"x = (this.a = 2)\", \"x = 2\");\n+    testSame(\"this.a = 2; x = this.a;\");\n+  }\n+\n+  public void testSimple2() {\n+    // A property defined on \"this\" can be removed, even when defined\n+    // as part of an expression\n+    test(\"this.a = 2, f()\", \"2, f()\");\n+    test(\"x = (this.a = 2, f())\", \"x = (2, f())\");\n+    test(\"x = (f(), this.a = 2)\", \"x = (f(), 2)\");\n+  }\n+\n+  public void testSimple3() {\n+    // A property defined on an object other than \"this\" can not be removed.\n+    testSame(\"y.a = 2\");\n+    // but doesn't prevent the removal of the definition on 'this'.\n+    test(\"y.a = 2; this.a = 2\", \"y.a = 2; 2\");\n+    // Some use of the property \"a\" prevents the removal.\n+    testSame(\"y.a = 2; this.a = 1; alert(x.a)\");\n+  }\n+\n+  public void testObjLit() {\n+    // A property defined on an object other than \"this\" can not be removed.\n+    testSame(\"({a:2})\");\n+    // but doesn't prevent the removal of the definition on 'this'.\n+    test(\"({a:0}); this.a = 1;\", \"({a:0});1\");\n+    // Some use of the property \"a\" prevents the removal.\n+    testSame(\"x = ({a:0}); this.a = 1; alert(x.a)\");\n+  }\n+\n+  public void testExtern() {\n+    // A property defined in the externs is can not be removed.\n+    testSame(\"this.ext = 2\");\n+  }\n+\n+  public void testExport() {\n+    // An exported property can not be removed.\n+    testSame(\"this.ext = 2; window['export'] = this.ext;\");\n+    testSame(\"function f() { this.ext = 2; } window['export'] = this.ext;\");\n+  }\n+\n+\n+  public void testAssignOp1() {\n+    // Properties defined using a compound assignment can be removed if the\n+    // result of the assignment expression is not immediately used.\n+    test(\"this.x += 2\", \"2\");\n+    testSame(\"x = (this.x += 2)\");\n+    testSame(\"this.x += 2; x = this.x;\");\n+    // But, of course, a later use prevents its removal.\n+    testSame(\"this.x += 2; x.x;\");\n+  }\n+\n+  public void testAssignOp2() {\n+    // Properties defined using a compound assignment can be removed if the\n+    // result of the assignment expression is not immediately used.\n+    test(\"this.a += 2, f()\", \"2, f()\");\n+    test(\"x = (this.a += 2, f())\", \"x = (2, f())\");\n+    testSame(\"x = (f(), this.a += 2)\");\n+  }\n+\n+  public void testInc1() {\n+    // Increments and Decrements are handled similiarly to compound assignments\n+    // but need a placeholder value when replaced.\n+    test(\"this.x++\", \"0\");\n+    testSame(\"x = (this.x++)\");\n+    testSame(\"this.x++; x = this.x;\");\n+\n+    test(\"--this.x\", \"0\");\n+    testSame(\"x = (--this.x)\");\n+    testSame(\"--this.x; x = this.x;\");\n+  }\n+\n+  public void testInc2() {\n+    // Increments and Decrements are handled similiarly to compound assignments\n+    // but need a placeholder value when replaced.\n+    test(\"this.a++, f()\", \"0, f()\");\n+    test(\"x = (this.a++, f())\", \"x = (0, f())\");\n+    testSame(\"x = (f(), this.a++)\");\n+\n+    test(\"--this.a, f()\", \"0, f()\");\n+    test(\"x = (--this.a, f())\", \"x = (0, f())\");\n+    testSame(\"x = (f(), --this.a)\");\n+  }\n+\n+  public void testJSCompiler_renameProperty() {\n+    // JSCompiler_renameProperty introduces a use of the property\n+    testSame(\"this.a = 2; x[JSCompiler_renameProperty('a')]\");\n+    testSame(\"this.a = 2; JSCompiler_renameProperty('a')\");\n+  }\n+\n+  public void testForIn() {\n+    // This is the basic assumption that this pass makes:\n+    // it can remove properties even when the object is used in a FOR-IN loop\n+    test(\"this.y = 1;for (var a in x) { alert(x[a]) }\",\n+         \"1;for (var a in x) { alert(x[a]) }\");\n+  }\n+\n+  public void testObjectKeys() {\n+    // This is the basic assumption that this pass makes:\n+    // it can remove properties even when the object are referenced\n+    test(\"this.y = 1;alert(Object.keys(this))\",\n+         \"1;alert(Object.keys(this))\");\n+  }\n+}", "timestamp": 1321297390, "metainfo": ""}