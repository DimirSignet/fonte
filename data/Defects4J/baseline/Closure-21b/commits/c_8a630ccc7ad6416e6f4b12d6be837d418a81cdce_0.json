{"sha": "8a630ccc7ad6416e6f4b12d6be837d418a81cdce", "log": "Support removing properties defined using \"this\" as part of RemoveUnusedPrototypeProperties. This requires handling properties assigned expressions containing side-effects properly which was not the case prior to this change.  I expect we got away with it because prototype properties are generally assigned literals or simple variable references.  As part of this change I also change the rules, so that any property write (=, +=, ++) on a prototype or this property is removalable, and other writes to the property don't prevent removal of the candidates. Object property definitions are simply one more write now so don't automatically rescue other definitions unless used in a known method (JSCompiler_renameProperty, goog.reflect.object).  This effective replaces RemoveUnusedClassProperties  R=nicksantos DELTA=1498  (856 added, 514 deleted, 128 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4160   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public abstract class AbstractCompiler implements SourceExcerptProvider {\n+public abstract class AbstractCompiler\n+    implements SourceExcerptProvider, CodeChangeHandler {\n   static final DiagnosticType READ_ERROR = DiagnosticType.error(\n       \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n \n   /**\n    * Report code changes.\n    */\n+  @Override\n   public abstract void reportCodeChange();\n \n   /**\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n  * that code (if it is not needed) or replaces it with smaller code.\n  *\n  */\n-abstract class AbstractPeepholeOptimization {\n+abstract class AbstractPeepholeOptimization implements CodeChangeHandler {\n \n   private NodeTraversal currentTraversal;\n \n    * Helper method for telling the compiler that something has changed.\n    * Subclasses must call these if they have changed the AST.\n    */\n-  protected void reportCodeChange() {\n+  @Override\n+  public void reportCodeChange() {\n     Preconditions.checkNotNull(currentTraversal);\n     currentTraversal.getCompiler().reportCodeChange();\n   }\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.Stack;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Analyzes properties on prototypes.\n   private final SymbolType VAR = SymbolType.VAR;\n \n   private final AbstractCompiler compiler;\n-  private final boolean canModifyExterns;\n+  private final boolean doNotPinExternsPropertiesOnPrototypes;\n+  private final boolean trackThisPropertiesDefinitions;\n   private final boolean anchorUnusedVars;\n+  private final boolean anchorObjectLiteralProperties;\n   private final JSModuleGraph moduleGraph;\n   private final JSModule firstModule;\n \n   private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();\n \n   // All the NameInfo for global functions, hashed by the name of the\n-  // gloval variable that it's assigned to.\n+  // global variable that it's assigned to.\n   private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();\n+\n+  // A list of extern property names that have not been added to the\n+  // symbolGraph.\n+  private final Set<String> deferredExternPropNames = Sets.newHashSet();\n \n   /**\n    * Creates a new pass for analyzing prototype properties.\n    * @param compiler The compiler.\n    * @param moduleGraph The graph for resolving module dependencies. May be\n    *     null if we don't care about module dependencies.\n-   * @param canModifyExterns If true, then we can move prototype\n-   *     properties that are declared in the externs file.\n-   * @param anchorUnusedVars If true, then we must mark all vars as referenced,\n+   * @param doNotPinExternsPropertiesOnPrototypes If true, do not consider\n+   *     externs property definitions when looking for uses of properties\n+   *     defined on prototypes.\n+   * @param anchorUnusedVars If true, mark all vars as referenced,\n    *     even if they are never used.\n+   * @param trackThisPropertiesDefinitions If true, add assignments to\n+   *     properties defined on \"this\" as definitions in the symbolGraph.\n+   * @param pinPropertiesDefinedOnObjectLiterals If true, mark all properties\n+   *     on object literals (that are not otherwise prototype\n+   *     property definitions) as referenced.\n    */\n   AnalyzePrototypeProperties(AbstractCompiler compiler,\n-      JSModuleGraph moduleGraph, boolean canModifyExterns,\n-      boolean anchorUnusedVars) {\n+      JSModuleGraph moduleGraph,\n+      boolean doNotPinExternsPropertiesOnPrototypes,\n+      boolean anchorUnusedVars,\n+      boolean trackThisPropertiesDefinitions,\n+      boolean pinPropertiesDefinedOnObjectLiterals) {\n     this.compiler = compiler;\n     this.moduleGraph = moduleGraph;\n-    this.canModifyExterns = canModifyExterns;\n+    this.doNotPinExternsPropertiesOnPrototypes =\n+         doNotPinExternsPropertiesOnPrototypes;\n+    this.trackThisPropertiesDefinitions = trackThisPropertiesDefinitions;\n     this.anchorUnusedVars = anchorUnusedVars;\n+    this.anchorObjectLiteralProperties = pinPropertiesDefinedOnObjectLiterals;\n \n     if (moduleGraph != null) {\n       firstModule = moduleGraph.getRootModule();\n \n   @Override\n   public void process(Node externRoot, Node root) {\n-    if (!canModifyExterns) {\n-      NodeTraversal.traverse(compiler, externRoot,\n-          new ProcessExternProperties());\n-    }\n+    NodeTraversal.traverse(compiler, externRoot,\n+        new ProcessExternProperties());\n \n     NodeTraversal.traverse(compiler, root, new ProcessProperties());\n \n     //    name are given a special [anonymous] context.\n     // 2) Every assignment of a prototype property of a non-function is\n     //    given a name context. These contexts do not have scopes.\n-    private Stack<NameContext> symbolStack = new Stack<NameContext>();\n+    private ArrayDeque<NameContext> symbolStack = new ArrayDeque<NameContext>();\n+    // When a side-effect is encountered, any dependent value references must\n+    // be associated with the current scope.\n+    private ArrayDeque<NameContext> scopeStack = new ArrayDeque<NameContext>();\n \n     @Override\n     public void enterScope(NodeTraversal t) {\n       Node n = t.getCurrentNode();\n+      NameContext nameContext;\n       if (n.isFunction()) {\n-        String propName = getPrototypePropertyNameFromRValue(n);\n-        if (propName != null) {\n-          symbolStack.push(\n-              new NameContext(\n-                  getNameInfoForName(propName, PROPERTY),\n-                  t.getScope()));\n-        } else if (isGlobalFunctionDeclaration(t, n)) {\n+        if (isGlobalFunctionDeclaration(t, n)) {\n           Node parent = n.getParent();\n           String name = parent.isName() ?\n               parent.getString() /* VAR */ :\n               n.getFirstChild().getString() /* named function */;\n-          symbolStack.push(\n-              new NameContext(getNameInfoForName(name, VAR), t.getScope()));\n+          nameContext =\n+              new NameContext(\n+                  symbolStack.peek(),\n+                  getNameInfoForName(name, VAR), t.getScope(),\n+                  /* chained */ false);\n         } else {\n-          // NOTE(nicksantos): We use the same anonymous node for all\n-          // functions that do not have reasonable names. I can't remember\n-          // at the moment why we do this. I think it's because anonymous\n-          // nodes can never have in-edges. They're just there as a placeholder\n-          // for scope information, and do not matter in the edge propagation.\n-          symbolStack.push(new NameContext(anonymousNode, t.getScope()));\n+          // We use the same anonymous node for all function expressions.\n+          // They're just there as a placeholder for scope information, and\n+          // do not matter in the edge propagation.\n+          nameContext = new NameContext(\n+              symbolStack.peek(), anonymousNode, t.getScope(),\n+              /* chained */ true);\n         }\n       } else {\n         Preconditions.checkState(t.inGlobalScope());\n-        symbolStack.push(new NameContext(globalNode, t.getScope()));\n-      }\n+        nameContext = new NameContext(\n+            null, globalNode, t.getScope(), /* chained */ false);\n+      }\n+\n+      symbolStack.push(nameContext);\n+      scopeStack.push(nameContext);\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n       symbolStack.pop();\n+      scopeStack.pop();\n     }\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      // Process prototype assignments to non-functions.\n-      String propName = processNonFunctionPrototypeAssign(n, parent);\n+      NameContext context = maybeGetContextForNode(n, true);\n+      if (context != null) {\n+        symbolStack.push(context);\n+      }\n+      return true;\n+    }\n+\n+    private NameContext maybeGetContextForNode(\n+        Node n, boolean checkSideEffects) {\n+      NameContext context = null;\n+      // NameInfo dependencies contained in untracked side-effect nodes are\n+      // assigned to the current scope NameContext. At the point in the\n+      // traversal that we detect the side-effect\n+      // conditional NameInfo dependences have already been assigned.  For\n+      // example:  \"x ? f() : g()\".  The covering HOOK node does not have\n+      // side effects, neither does the condition \"x\".  Assuming that \"f()\"\n+      // and \"g()\" have side-effects, the HOOK can not be removed, so \"x\" must\n+      // be rescued.\n+      //\n+      if (n.isHook() || n.isOr() || n.isAnd()) {\n+        if (checkSideEffects && NodeUtil.mayHaveSideEffects(n, compiler)) {\n+          // Any property (or global name) references are add as a dependency\n+          // on the current scope.\n+          context = scopeStack.peek();\n+        } else {\n+          // There aren't any side-effects so continue with the current context.\n+          context = symbolStack.peek();\n+        }\n+      } else if (NodeUtil.nodeTypeMayHaveSideEffects(n, compiler)) {\n+        // Assignments and other contexts\n+        String propName = null;\n+        if (isUnpinnedPropertyUseParent(n)) {\n+          propName = getPrototypePropertyName(n.getFirstChild());\n+        }\n+        context = getContextForPropName(propName,\n+            NodeUtil.isExpressionResultUsed(n));\n+      } else if (NodeUtil.isObjectLitKey(n, n.getParent())) {\n+        // Handle object literal definitions potential property assignment\n+        String propName = getPrototypePropertyName(n);\n+        context = getContextForPropName(propName, false);\n+      }\n+      return context;\n+    }\n+\n+    private boolean isContextIntroducingNode(Node n) {\n+      return maybeGetContextForNode(n, false) != null;\n+    }\n+\n+    private NameContext getContextForPropName(\n+        String propName, boolean resultUsed) {\n+      NameContext context;\n       if (propName != null) {\n-        symbolStack.push(\n-            new NameContext(\n-                getNameInfoForName(propName, PROPERTY), null));\n-      }\n-      return true;\n+        context = new NameContext(\n+            symbolStack.peek(),\n+            getNameInfoForName(propName, PROPERTY), null,\n+            resultUsed);\n+      } else {\n+        // side-effects should be associated with the enclosing scope,\n+        // regardless of any enclosing prop assignment\n+        context = scopeStack.peek();\n+      }\n+      return context;\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-\n-        if (n.isQualifiedName()) {\n-          if (propName.equals(\"prototype\")) {\n-            if (processPrototypeRef(t, n)) {\n+      switch (n.getType()) {\n+        case Token.GETPROP:\n+          // Check for interesting property definitions and references\n+          visitGetProp(t, n);\n+          break;\n+        case Token.OBJECTLIT:\n+          // Check for interesting property definitions\n+          visitObjectLit(t, n);\n+          break;\n+        case Token.NAME:\n+          // Check for interesting variable definitions and references\n+          visitName(t, n);\n+          break;\n+        case Token.CALL:\n+          // Check for special case uses of properties\n+          visitCall(t, n);\n+          break;\n+      }\n+\n+      if (isContextIntroducingNode(n)) {\n+        symbolStack.pop();\n+      }\n+    }\n+\n+    private void visitGetProp(NodeTraversal t, Node n) {\n+      if (n.getFirstChild().isThis()) {\n+        if (processThisRef(t, n.getFirstChild())) {\n+          return;\n+        }\n+      }\n+\n+      String propName = n.getFirstChild().getNext().getString();\n+      boolean isPinningUse = isPinningPropertyUse(n);\n+\n+      if (n.isQualifiedName()) {\n+        if (propName.equals(\"prototype\")) {\n+          if (processPrototypeRef(t, n)) {\n+            return;\n+          }\n+        } else if (compiler.getCodingConvention().isExported(propName)) {\n+          addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+          return;\n+        } else {\n+          // Do not mark prototype prop assigns as a 'use' in the global\n+          // scope.\n+          if (!isPinningUse) {\n+            String lValueName = getPrototypePropertyName(n);\n+            if (lValueName != null) {\n               return;\n             }\n-          } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-            return;\n-          } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            if (n.getParent().isAssign() && n.getNext() != null) {\n-              String rValueName = getPrototypePropertyNameFromRValue(n);\n-              if (rValueName != null) {\n-                return;\n-              }\n-            }\n           }\n         }\n-\n+      }\n+\n+      if (isPinningUse) {\n         addSymbolUse(propName, t.getModule(), PROPERTY);\n-      } else if (n.isObjectLit()) {\n+      }\n+    }\n+\n+    private void visitObjectLit(NodeTraversal t, Node n) {\n+      if (anchorObjectLiteralProperties) {\n         // Make sure that we're not handling object literals being\n         // assigned to a prototype, as in:\n         // Foo.prototype = {bar: 3, baz: 5};\n           return;\n         }\n \n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n-             propNameNode = propNameNode.getNext()) {\n-          // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-          if (!propNameNode.isQuotedString()) {\n-            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-          }\n-        }\n-      } else if (n.isName()) {\n-        String name = n.getString();\n-\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-          // Only process global functions.\n-          if (var.isGlobal()) {\n-            if (var.getInitialValue() != null &&\n-                var.getInitialValue().isFunction()) {\n-              if (t.inGlobalScope()) {\n-                if (!processGlobalFunctionDeclaration(t, n, var)) {\n-                  addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                }\n-              } else {\n-                addSymbolUse(name, t.getModule(), VAR);\n+        pinObjectLiteralProperties(n, t.getModule());\n+      }\n+    }\n+\n+    private void visitName(NodeTraversal t, Node n) {\n+      String name = n.getString();\n+\n+      Var var = t.getScope().getVar(name);\n+      if (var != null) {\n+        // Only process global functions.\n+        if (var.isGlobal()) {\n+          if (var.getInitialValue() != null &&\n+              var.getInitialValue().isFunction()) {\n+            if (t.inGlobalScope()) {\n+              if (!processGlobalFunctionDeclaration(t, n, var)) {\n+                addGlobalUseOfSymbol(name, t.getModule(), VAR);\n               }\n-            }\n-\n-          // If it is not a global, it might be accessing a local of the outer\n-          // scope. If that's the case the functions between the variable's\n-          // declaring scope and the variable reference scope cannot be moved.\n-          } else if (var.getScope() != t.getScope()){\n-            for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-              NameContext context = symbolStack.get(i);\n-              if (context.scope == var.getScope()) {\n-                break;\n-              }\n-\n-              context.name.readClosureVariables = true;\n+            } else {\n+              addSymbolUse(name, t.getModule(), VAR);\n             }\n           }\n-        }\n-      }\n-\n-      // Process prototype assignments to non-functions.\n-      if (processNonFunctionPrototypeAssign(n, parent) != null) {\n-        symbolStack.pop();\n-      }\n+\n+        // If it is not a global, it might be accessing a local of the outer\n+        // scope. If that's the case the functions between the variable's\n+        // declaring scope and the variable reference scope cannot be moved.\n+        } else if (var.getScope() != t.getScope()){\n+          handleScopeReference(var.getScope());\n+        }\n+      }\n+    }\n+\n+    private void visitCall(NodeTraversal t, Node n) {\n+      // Look for properties referenced through \"JSCompiler_propertyRename\".\n+      Node target = n.getFirstChild();\n+      if (n.hasMoreThanOneChild()\n+          && target.isName()\n+          && target.getString().equals(NodeUtil.JSC_PROPERTY_NAME_FN)) {\n+        Node propNode = target.getNext();\n+        if (propNode.isString()) {\n+          String propName = propNode.getString();\n+          addSymbolUse(propName, t.getModule(), PROPERTY);\n+        }\n+      } else {\n+        // ... and for calls to \"goog.reflect.object\" and the ilk.\n+        ObjectLiteralCast cast = compiler.getCodingConvention()\n+            .getObjectLiteralCast(t, n);\n+        if (cast != null) {\n+          pinObjectLiteralProperties(cast.objectNode, t.getModule());\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Handle a reference to a scope from an inner scope.\n+     * @param scope The referenced scope\n+     */\n+    private void handleScopeReference(Scope scope) {\n+      NameContext context = symbolStack.peek();\n+      while (context != null) {\n+        context.name.readClosureVariables = true;\n+        if (context.parent != null && context.parent.scope == scope) {\n+          break;\n+        }\n+        context = context.parent;\n+      }\n+\n+      while (context != null && context.resultUsed) {\n+        context.name.readClosureVariables = true;\n+        // Stop when we would cross into another scope.  Function declarations\n+        // don't chain so there is no need to explicitly check for them here.\n+        if (context.parent == null || context.parent.name == anonymousNode) {\n+          break;\n+        }\n+        context = context.parent;\n+      }\n+    }\n+\n+    /**\n+     * Mark properties in the literal as referenced in the provided module.\n+     * @param n The object literal\n+     * @param module The module\n+     */\n+    private void pinObjectLiteralProperties(Node n, JSModule module) {\n+      Preconditions.checkArgument(n.isObjectLit());\n+\n+      // var x = {a: 1, b: 2}\n+      // should count as a use of property a and b.\n+      for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n+        // May be STRING, GET, or SET, but NUMBER isn't interesting.\n+        if (!key.isQuotedString()) {\n+          addSymbolUse(key.getString(), module, PROPERTY);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * @return Whether the property is used in a way that prevents its removal.\n+     */\n+    private boolean isPinningPropertyUse(Node n) {\n+      // Rather than looking for cases that are uses, we assume all references\n+      // are pinning uses unless they are:\n+      //  - a simple assignment (x.a = 1)\n+      //  - a compound assignment or increment (x++, x += 1) whose result is\n+      //    otherwise unused\n+\n+      Node parent = n.getParent();\n+      if (n == parent.getFirstChild()) {\n+        if (parent.isAssign()) {\n+          // A simple assignment doesn't pin the property.\n+          return false;\n+        } else if (NodeUtil.isAssignmentOp(parent)\n+              || parent.isInc() || parent.isDec()) {\n+          // In general, compound assignments are both reads and writes, but\n+          // if the property is never otherwise read we can consider it simply\n+          // a write.\n+          // However if the assign expression is used as part of a larger\n+          // expression, we much consider it a read. For example:\n+          //    x = (y.a += 1);\n+          return NodeUtil.isExpressionResultUsed(parent);\n+        }\n+      }\n+      return true;\n+    }\n+\n+    /**\n+     * @return Whether any children are unpinned property uses.\n+     */\n+    private boolean isUnpinnedPropertyUseParent(Node n) {\n+      if (n.hasChildren()) {\n+        // Only the first child can be an unpinned use.\n+        return !isPinningPropertyUse(n.getFirstChild());\n+      }\n+      return false;\n     }\n \n     private void addSymbolUse(String name, JSModule module, SymbolType type) {\n       NameInfo info = getNameInfoForName(name, type);\n-      NameInfo def = null;\n-      // Skip all anonymous nodes. We care only about symbols with names.\n-      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-        def = symbolStack.get(i).name;\n-        if (def != anonymousNode) {\n-          break;\n-        }\n-      }\n-      if (!def.equals(info)) {\n-        symbolGraph.connect(def, module, info);\n-      }\n-    }\n-\n-    /**\n-     * If this is a non-function prototype assign, return the prop name.\n-     * Otherwise, return null.\n-     */\n-    private String processNonFunctionPrototypeAssign(Node n, Node parent) {\n-      if (isAssignRValue(n, parent) && !n.isFunction()) {\n-        return getPrototypePropertyNameFromRValue(n);\n-      }\n-      return null;\n+      NameContext context = symbolStack.peek();\n+\n+      context.connect(symbolGraph, module, info);\n     }\n \n     /**\n         return false;\n       }\n \n+      // Looking for: \"function f() {}\" or \"var f = function()\"\n       return NodeUtil.isFunctionDeclaration(n) ||\n           n.isFunction() && n.getParent().isName();\n-    }\n-\n-    /**\n-     * Returns true if this is the r-value of an assignment.\n-     */\n-    private boolean isAssignRValue(Node n, Node parent) {\n-      return parent != null && parent.isAssign() && parent.getFirstChild() != n;\n     }\n \n     /**\n      * the R-value is used in multiple expressions (i.e., if there's\n      * a prototype property assignment in a more complex expression).\n      */\n-    private String getPrototypePropertyNameFromRValue(Node rValue) {\n-      Node lValue = NodeUtil.getBestLValue(rValue);\n-      if (lValue == null ||\n-          lValue.getParent() == null ||\n-          lValue.getParent().getParent() == null ||\n-          !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) ||\n-            NodeUtil.isExprAssign(lValue.getParent().getParent()))) {\n-        return null;\n-      }\n-\n-      String lValueName =\n-          NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));\n+    private String getPrototypePropertyName(Node lValue) {\n+      String lValueName = NodeUtil.getBestLValueName(lValue);\n       if (lValueName == null) {\n         return null;\n       }\n+\n       int lastDot = lValueName.lastIndexOf('.');\n       if (lastDot == -1) {\n         return null;\n       }\n \n       String firstPart = lValueName.substring(0, lastDot);\n-      if (!firstPart.endsWith(\".prototype\")) {\n+      if (!firstPart.endsWith(\".prototype\")\n+          && !(trackThisPropertiesDefinitions && firstPart.equals(\"this\"))) {\n         return null;\n       }\n \n       switch (n.getType()) {\n         // Foo.prototype.getBar = function() { ... }\n         case Token.GETPROP:\n-          Node dest = n.getFirstChild().getNext();\n-          Node parent = n.getParent();\n-          Node grandParent = parent.getParent();\n-\n-          if (dest.isString() &&\n-              NodeUtil.isExprAssign(grandParent) &&\n-              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n-            String name = dest.getString();\n-            Property prop = new AssignmentProperty(\n-                grandParent,\n-                maybeGetVar(t, root),\n-                t.getModule());\n-            getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n-            return true;\n-          }\n-          break;\n+          // NOTE: for properties defined on the prototype we don't ever\n+          // need to check the deferred definitions.  They have either been\n+          // added during the pass over the externs or we are ignoring them\n+          // because canModifyExternsPrototypes is set.\n+          return processGetProp(t, n, root,\n+              /* checkDeferredExterns */ false);\n \n         // Foo.prototype = { \"getBar\" : function() { ... } }\n         case Token.ASSIGN:\n       return false;\n     }\n \n-    private Var maybeGetVar(NodeTraversal t, Node maybeName) {\n-      return maybeName.isName()\n+    /**\n+     * Processes a \"this\" reference, which may be a\n+     * GETPROP (in the case of this.bar).\n+     * under an assignment (in the case of Foo.prototype = ...).\n+     * @return True if a declaration was added.\n+     */\n+    private boolean processThisRef(NodeTraversal t, Node ref) {\n+      if (trackThisPropertiesDefinitions) {\n+        Node n = ref.getParent();\n+        // this.getBar = function() { ... }\n+        if (n.isGetProp()) {\n+          // NOTE: for properties defined on this, we don't ever\n+          // need to check the deferred definitions.  They have either been\n+          // added during the pass over the externs or we are ignoring them\n+          // because canModifyExternsPrototypes is set.\n+          return processGetProp(t, n, null,\n+              /* checkDeferredExterns */ true);\n+        }\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Given a GETPROP, determine if the reference is property write operation.\n+     * @return true if a GETPROP use is a candidate for removal.\n+     */\n+    private boolean processGetProp(NodeTraversal t, Node n, Node rootName,\n+        boolean checkDeferredExterns) {\n+      Node dest = n.getFirstChild().getNext();\n+      Node parent = n.getParent();\n+      Preconditions.checkState(dest.isString());\n+      if (!isPinningPropertyUse(n)) {\n+        String name = dest.getString();\n+        if (!checkDeferredExterns || !deferredExternPropNames.contains(name)) {\n+          Property prop = new AssignmentProperty(\n+              parent,\n+              maybeGetVar(t, rootName),\n+              t.getModule());\n+          getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n+        }\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private Var maybeGetVar(NodeTraversal t, @Nullable Node maybeName) {\n+      return (maybeName != null && maybeName.isName())\n           ? t.getScope().getVar(maybeName.getString()) : null;\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isGetProp()) {\n-        symbolGraph.connect(externNode, firstModule,\n-            getNameInfoForName(n.getLastChild().getString(), PROPERTY));\n-      }\n-    }\n+        if (doNotPinExternsPropertiesOnPrototypes) {\n+          deferredExternPropNames.add(n.getLastChild().getString());\n+        } else {\n+          connectExternProp(n.getLastChild().getString());\n+        }\n+      }\n+    }\n+  }\n+\n+  private void connectExternProp(String propName) {\n+    symbolGraph.connect(externNode, firstModule,\n+        getNameInfoForName(propName, PROPERTY));\n   }\n \n   private class PropagateReferences\n     /**\n      * Remove the declaration from the AST.\n      */\n-    void remove();\n+    void remove(CodeChangeHandler reporter);\n \n     /**\n      * The variable for the root of this symbol.\n   /**\n    * A function initialized as a VAR statement or a function declaration.\n    */\n-  class GlobalFunction implements Symbol {\n+  static class GlobalFunction implements Symbol {\n     private final Node nameNode;\n     private final Var var;\n     private final JSModule module;\n     }\n \n     @Override\n-    public void remove() {\n+    public void remove(CodeChangeHandler reporter) {\n       Node parent = nameNode.getParent();\n       if (parent.isFunction() || parent.hasOneChild()) {\n         NodeUtil.removeChild(parent.getParent(), parent);\n    * Foo.prototype.bar = function() { ... };</pre>\n    */\n   static class AssignmentProperty implements Property {\n-    private final Node exprNode;\n+    private final Node assignNode;\n     private final Var rootVar;\n     private final JSModule module;\n \n      * @param node An EXPR node.\n      */\n     AssignmentProperty(Node node, Var rootVar, JSModule module) {\n-      this.exprNode = node;\n+      this.assignNode = node;\n       this.rootVar = rootVar;\n       this.module = module;\n     }\n     }\n \n     @Override\n-    public void remove() {\n-      NodeUtil.removeChild(exprNode.getParent(), exprNode);\n+    public void remove(CodeChangeHandler reporter) {\n+      // TODO(johnlenz): use trySimplifyUnusedResult\n+      if (NodeUtil.isAssignmentOp(assignNode)) {\n+        Node value = getAssignNode().getLastChild();\n+        Node exprParent = assignNode.getParent();\n+        if (exprParent.isExprResult()\n+            && !NodeUtil.mayHaveSideEffects(value)) {\n+          NodeUtil.removeChild(exprParent.getParent(), exprParent);\n+        } else {\n+          if (!NodeUtil.isExpressionResultUsed(assignNode)) {\n+            Node result = NodeUtil.trySimplifyUnusedResult(value, reporter);\n+            if (result == null) {\n+              // FOR init or increment expressions, the first op of COMMA, etc\n+              // must have a node to be valid, so simple use a literal \"0\" if\n+              // nothing remains after simplification.\n+              value = IR.number(0);\n+            } else {\n+              value = result.detachFromParent();\n+            }\n+          } else {\n+            value.detachFromParent();\n+          }\n+          exprParent.replaceChild(getAssignNode(), value);\n+        }\n+      } else if (assignNode.isInc() || assignNode.isDec()) {\n+        assignNode.getParent().replaceChild(assignNode, IR.number(0));\n+      } else {\n+        throw new IllegalStateException(\"unexpected: \"+ assignNode);\n+      }\n     }\n \n     @Override\n     }\n \n     private Node getAssignNode() {\n-      return exprNode.getFirstChild();\n+      return assignNode;\n     }\n \n     @Override\n     }\n \n     @Override\n-    public void remove() {\n+    public void remove(CodeChangeHandler reporter) {\n       map.removeChild(key);\n     }\n \n    */\n   private class NameContext {\n     final NameInfo name;\n+    final NameContext parent;\n \n     // If this is a function context, then scope will be the scope of the\n     // corresponding function. Otherwise, it will be null.\n     final Scope scope;\n \n-    NameContext(NameInfo name, Scope scope) {\n+    // Whether any dependencies should also be added to the parent context.\n+    // This is the case with assignment expressions such as:\n+    //   a = b = foo;\n+    // or\n+    //   a = function() {}\n+    final boolean resultUsed;\n+\n+    NameContext(\n+        NameContext parent, NameInfo name, Scope scope, boolean resultUsed) {\n+      this.parent = parent;\n       this.name = name;\n       this.scope = scope;\n+      this.resultUsed = resultUsed;\n+    }\n+\n+    void connect(\n+        LinkedDirectedGraph<NameInfo, JSModule> symbolGraph,\n+        JSModule module, NameInfo info) {\n+      NameInfo def = this.name;\n+      // don't add self connections\n+      if (def != anonymousNode && !info.equals(def)) {\n+        symbolGraph.connect(this.name, module, info);\n+      }\n+      if (this.resultUsed) {\n+        this.parent.connect(symbolGraph, module, info);\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CodeChangeHandler.java\n+++ b/src/com/google/javascript/jscomp/CodeChangeHandler.java\n   // change reporting.\n \n   /** Report a change to the AST. */\n-  void reportChange();\n+  void reportCodeChange();\n \n   /**\n    * A trivial change handler that just records whether the code\n     private boolean hasChanged = false;\n \n     @Override\n-    public void reportChange() {\n+    public void reportCodeChange() {\n       hasChanged = true;\n     }\n \n    */\n   static final class ForbiddenChange implements CodeChangeHandler {\n     @Override\n-    public void reportChange() {\n+    public void reportCodeChange() {\n       throw new IllegalStateException(\"Code changes forbidden\");\n     }\n   }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   @Override\n   public void reportCodeChange() {\n     for (CodeChangeHandler handler : codeChangeHandlers) {\n-      handler.reportChange();\n+      handler.reportCodeChange();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n     this.idGenerator = idGenerator;\n     this.moduleGraph = compiler.getModuleGraph();\n     this.analyzer = new AnalyzePrototypeProperties(compiler, moduleGraph,\n-        canModifyExterns, false);\n+        canModifyExterns, false, false, true);\n   }\n \n   @Override\n         // So if we move a prototype method into a deeper module, we must\n         // replace it with a stub function so that it preserves its original\n         // behavior.\n+\n+        // getRootVar will be null if the definition is an expression like\n+        // \"this\" of \"foo()\".\n         if (prop.getRootVar() == null || !prop.getRootVar().isGlobal()) {\n           continue;\n         }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // Extracting prototype properties screws up the heuristic renaming\n     // policies, so never run it when those policies are requested.\n     if (options.extractPrototypeMemberDeclarations &&\n-        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n-         options.propertyRenaming !=\n-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n+        !usingHeuristicRenaming()) {\n       passes.add(extractPrototypeMemberDeclarations);\n     }\n \n     return passes;\n   }\n \n+  private boolean usingHeuristicRenaming() {\n+    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n+        options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n+  }\n+\n   /** Creates the passes for the main optimization loop. */\n   private List<PassFactory> getMainOptimizationLoop() {\n     List<PassFactory> passes = Lists.newArrayList();\n \n     if (options.removeUnusedPrototypeProperties) {\n       passes.add(removeUnusedPrototypeProperties);\n-      passes.add(removeUnusedClassProperties);\n     }\n \n     assertAllLoopablePasses(passes);\n       new PassFactory(\"removeUnusedPrototypeProperties\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      // TODO(johnlenz): make the object literal anchoring an compiler option.\n       return new RemoveUnusedPrototypeProperties(\n           compiler, options.removeUnusedPrototypePropertiesInExterns,\n-          !options.removeUnusedVars);\n-    }\n-  };\n-\n-  /**\n-   * Remove prototype properties that do not appear to be used.\n-   */\n-  final PassFactory removeUnusedClassProperties =\n-      new PassFactory(\"removeUnusedClassProperties\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new RemoveUnusedClassProperties(compiler);\n+          !options.removeUnusedVars,\n+          !usingHeuristicRenaming(), // can remove \"this\" properties\n+          true); // anchor object lit prop\n     }\n   };\n \n    * will ruin the invariants that it depends on.\n    */\n   private boolean isInliningForbidden() {\n-    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n-        options.propertyRenaming ==\n-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n+    return usingHeuristicRenaming();\n   }\n \n   /** Create a compiler pass that runs the given passes in serial. */\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     }\n     return result;\n   }\n+\n+  /**\n+   * General cascading unused operation node removal.\n+   * @param n The root of the expression to simplify.\n+   * @return The replacement node, or null if the node was is not useful.\n+   */\n+  static Node trySimplifyUnusedResult(Node n, CodeChangeHandler reporter) {\n+    return trySimplifyUnusedResult(n, reporter, true);\n+  }\n+\n+  /**\n+   * General cascading unused operation node removal.\n+   * @param n The root of the expression to simplify.\n+   * @param removeUnused If true, the node is removed from the AST if\n+   *     it is not useful, otherwise it replaced with an EMPTY node.\n+   * @return The replacement node, or null if the node was is not useful.\n+   */\n+  static Node trySimplifyUnusedResult(\n+      Node n, CodeChangeHandler reporter, boolean removeUnused) {\n+    Node result = n;\n+\n+    // Simplify the results of conditional expressions\n+    switch (n.getType()) {\n+      case Token.HOOK:\n+        Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext(), reporter);\n+        Node falseNode = trySimplifyUnusedResult(n.getLastChild(), reporter);\n+        // If one or more of the conditional children were removed,\n+        // transform the HOOK to an equivalent operation:\n+        //    x() ? foo() : 1 --> x() && foo()\n+        //    x() ? 1 : foo() --> x() || foo()\n+        //    x() ? 1 : 1 --> x()\n+        //    x ? 1 : 1 --> null\n+        if (trueNode == null && falseNode != null) {\n+          n.setType(Token.OR);\n+          Preconditions.checkState(n.getChildCount() == 2);\n+        } else if (trueNode != null && falseNode == null) {\n+          n.setType(Token.AND);\n+          Preconditions.checkState(n.getChildCount() == 2);\n+        } else if (trueNode == null && falseNode == null) {\n+          result = trySimplifyUnusedResult(n.getFirstChild(), reporter);\n+        } else {\n+          // The structure didn't change.\n+          result = n;\n+        }\n+        break;\n+      case Token.AND:\n+      case Token.OR:\n+        // Try to remove the second operand from a AND or OR operations:\n+        //    x() || f --> x()\n+        //    x() && f --> x()\n+        Node conditionalResultNode = trySimplifyUnusedResult(\n+            n.getLastChild(), reporter);\n+        if (conditionalResultNode == null) {\n+          Preconditions.checkState(n.hasOneChild());\n+          // The conditionally executed code was removed, so\n+          // replace the AND/OR with its LHS or remove it if it isn't useful.\n+          result = trySimplifyUnusedResult(n.getFirstChild(), reporter);\n+        }\n+        break;\n+      case Token.FUNCTION:\n+        // A function expression isn't useful if it isn't used, remove it and\n+        // don't bother to look at its children.\n+        result = null;\n+        break;\n+      case Token.COMMA:\n+        // We rewrite other operations as COMMA expressions (which will later\n+        // get split into individual EXPR_RESULT statement, if possible), so\n+        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n+        // nodes.\n+        Node left = trySimplifyUnusedResult(n.getFirstChild(), reporter);\n+        Node right = trySimplifyUnusedResult(n.getLastChild(), reporter);\n+        if (left == null && right == null) {\n+          result = null;\n+        } else if (left == null) {\n+          result = right;\n+        } else if (right == null){\n+          result = left;\n+        } else {\n+          // The structure didn't change.\n+          result = n;\n+        }\n+        break;\n+      default:\n+        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n+          // This is the meat of this function. The node itself doesn't generate\n+          // any side-effects but preserve any side-effects in the children.\n+          Node resultList = null;\n+          for (Node next, c = n.getFirstChild(); c != null; c = next) {\n+            next = c.getNext();\n+            c = trySimplifyUnusedResult(c, reporter);\n+            if (c != null) {\n+              c.detachFromParent();\n+              if (resultList == null)  {\n+                // The first side-effect can be used stand-alone.\n+                resultList = c;\n+              } else {\n+                // Leave the side-effects in-place, simplifying it to a COMMA\n+                // expression.\n+                resultList = IR.comma(resultList, c).srcref(c);\n+              }\n+            }\n+          }\n+          result = resultList;\n+        }\n+    }\n+\n+    // Fix up the AST, replace or remove the an unused node (if requested).\n+    if (n != result) {\n+      Node parent = n.getParent();\n+      if (result == null) {\n+        if (removeUnused) {\n+          parent.removeChild(n);\n+        } else {\n+          result = IR.empty().srcref(n);\n+          parent.replaceChild(n, result);\n+        }\n+      } else {\n+        // A new COMMA expression may not have an existing parent.\n+        if (result.getParent() != null) {\n+          result.detachFromParent();\n+        }\n+        n.getParent().replaceChild(n, result);\n+      }\n+      reporter.reportCodeChange();\n+    }\n+\n+    return result;\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldExpr(Node subtree) {\n-    Node result = trySimplifyUnusedResult(subtree.getFirstChild());\n+    Node result = NodeUtil.trySimplifyUnusedResult(\n+        subtree.getFirstChild(), this);\n     if (result == null) {\n       Node parent = subtree.getParent();\n       // If the EXPR_RESULT no longer has any children, remove it as well.\n     return subtree;\n   }\n \n-  /**\n-   * General cascading unused operation node removal.\n-   * @param n The root of the expression to simplify.\n-   * @return The replacement node, or null if the node was is not useful.\n-   */\n-  private Node trySimplifyUnusedResult(Node n) {\n-    return trySimplifyUnusedResult(n, true);\n-  }\n-\n-  /**\n-   * General cascading unused operation node removal.\n-   * @param n The root of the expression to simplify.\n-   * @param removeUnused If true, the node is removed from the AST if\n-   *     it is not useful, otherwise it replaced with an EMPTY node.\n-   * @return The replacement node, or null if the node was is not useful.\n-   */\n-  private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n-    Node result = n;\n-\n-    // Simplify the results of conditional expressions\n-    switch (n.getType()) {\n-      case Token.HOOK:\n-        Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext());\n-        Node falseNode = trySimplifyUnusedResult(n.getLastChild());\n-        // If one or more of the conditional children were removed,\n-        // transform the HOOK to an equivalent operation:\n-        //    x() ? foo() : 1 --> x() && foo()\n-        //    x() ? 1 : foo() --> x() || foo()\n-        //    x() ? 1 : 1 --> x()\n-        //    x ? 1 : 1 --> null\n-        if (trueNode == null && falseNode != null) {\n-          n.setType(Token.OR);\n-          Preconditions.checkState(n.getChildCount() == 2);\n-        } else if (trueNode != null && falseNode == null) {\n-          n.setType(Token.AND);\n-          Preconditions.checkState(n.getChildCount() == 2);\n-        } else if (trueNode == null && falseNode == null) {\n-          result = trySimplifyUnusedResult(n.getFirstChild());\n-        } else {\n-          // The structure didn't change.\n-          result = n;\n-        }\n-        break;\n-      case Token.AND:\n-      case Token.OR:\n-        // Try to remove the second operand from a AND or OR operations:\n-        //    x() || f --> x()\n-        //    x() && f --> x()\n-        Node conditionalResultNode = trySimplifyUnusedResult(\n-            n.getLastChild());\n-        if (conditionalResultNode == null) {\n-          Preconditions.checkState(n.hasOneChild());\n-          // The conditionally executed code was removed, so\n-          // replace the AND/OR with its LHS or remove it if it isn't useful.\n-          result = trySimplifyUnusedResult(n.getFirstChild());\n-        }\n-        break;\n-      case Token.FUNCTION:\n-        // A function expression isn't useful if it isn't used, remove it and\n-        // don't bother to look at its children.\n-        result = null;\n-        break;\n-      case Token.COMMA:\n-        // We rewrite other operations as COMMA expressions (which will later\n-        // get split into individual EXPR_RESULT statement, if possible), so\n-        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n-        // nodes.\n-        Node left = trySimplifyUnusedResult(n.getFirstChild());\n-        Node right = trySimplifyUnusedResult(n.getLastChild());\n-        if (left == null && right == null) {\n-          result = null;\n-        } else if (left == null) {\n-          result = right;\n-        } else if (right == null){\n-          result = left;\n-        } else {\n-          // The structure didn't change.\n-          result = n;\n-        }\n-        break;\n-      default:\n-        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n-          // This is the meat of this function. The node itself doesn't generate\n-          // any side-effects but preserve any side-effects in the children.\n-          Node resultList = null;\n-          for (Node next, c = n.getFirstChild(); c != null; c = next) {\n-            next = c.getNext();\n-            c = trySimplifyUnusedResult(c);\n-            if (c != null) {\n-              c.detachFromParent();\n-              if (resultList == null)  {\n-                // The first side-effect can be used stand-alone.\n-                resultList = c;\n-              } else {\n-                // Leave the side-effects in-place, simplifying it to a COMMA\n-                // expression.\n-                resultList = IR.comma(resultList, c).srcref(c);\n-              }\n-            }\n-          }\n-          result = resultList;\n-        }\n-    }\n-\n-    // Fix up the AST, replace or remove the an unused node (if requested).\n-    if (n != result) {\n-      Node parent = n.getParent();\n-      if (result == null) {\n-        if (removeUnused) {\n-          parent.removeChild(n);\n-        } else {\n-          result = IR.empty().srcref(n);\n-          parent.replaceChild(n, result);\n-        }\n-      } else {\n-        // A new COMMA expression may not have an existing parent.\n-        if (result.getParent() != null) {\n-          result.detachFromParent();\n-        }\n-        n.getParent().replaceChild(n, result);\n-      }\n-      reportCodeChange();\n-    }\n-\n-    return result;\n-  }\n \n   /**\n    * Remove useless switches and cases.\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n \n-    left = trySimplifyUnusedResult(left);\n+    left = NodeUtil.trySimplifyUnusedResult(left, this);\n     if (left == null || !mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n     Node increment = cond.getNext();\n \n     if (!init.isEmpty() && !init.isVar()) {\n-      init = trySimplifyUnusedResult(init, false);\n+      init = NodeUtil.trySimplifyUnusedResult(init, this, false);\n     }\n \n     if (!increment.isEmpty()) {\n-      increment = trySimplifyUnusedResult(increment, false);\n+      increment = NodeUtil.trySimplifyUnusedResult(\n+          increment, this, false);\n     }\n \n     // There is an initializer skip it\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n     Logger.getLogger(RemoveUnusedPrototypeProperties.class.getName());\n \n   private final AbstractCompiler compiler;\n-  private final boolean canModifyExterns;\n+  private final boolean canModifyExternsProtypeProps;\n   private final boolean anchorUnusedVars;\n   private SpecializeModule.SpecializationState specializationState;\n+  private final boolean canModifyThisProperties;\n+  private final boolean anchorObjectLiteralProperties;\n \n   /**\n    * Creates a new pass for removing unused prototype properties, based\n    * on the uniqueness of property names.\n    * @param compiler The compiler.\n-   * @param canModifyExterns If true, then we can remove prototype\n+   * @param canModifyExternsProtypeProps If true, then we can remove prototype\n    *     properties that are declared in the externs file.\n    * @param anchorUnusedVars If true, then we must keep unused variables\n    *     and the prototype properties they reference, even if they are\n    *     never used.\n+   * @param canModifyThisProperties\n+   * @param anchorObjectLiteralProperties\n    */\n   RemoveUnusedPrototypeProperties(AbstractCompiler compiler,\n-      boolean canModifyExterns,\n-      boolean anchorUnusedVars) {\n+      boolean canModifyExternsProtypeProps,\n+      boolean anchorUnusedVars, boolean canModifyThisProperties,\n+      boolean anchorObjectLiteralProperties) {\n     this.compiler = compiler;\n-    this.canModifyExterns = canModifyExterns;\n+    this.canModifyExternsProtypeProps = canModifyExternsProtypeProps;\n     this.anchorUnusedVars = anchorUnusedVars;\n+    this.canModifyThisProperties = canModifyThisProperties;\n+    this.anchorObjectLiteralProperties = anchorObjectLiteralProperties;\n   }\n \n   @Override\n   public void process(Node externRoot, Node root) {\n     AnalyzePrototypeProperties analyzer =\n         new AnalyzePrototypeProperties(compiler,\n-            null /* no module graph */, canModifyExterns, anchorUnusedVars);\n+            null /* no module graph */, canModifyExternsProtypeProps,\n+            anchorUnusedVars, canModifyThisProperties,\n+            anchorObjectLiteralProperties);\n     analyzer.process(externRoot, root);\n     removeUnusedSymbols(analyzer.getAllNameInfo());\n   }\n           }\n \n           if (canRemove) {\n-            declaration.remove();\n+            declaration.remove(compiler);\n             changed = true;\n           }\n         }\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n   }\n \n   // An anonymous inner function reading a closure variable is fine.\n-  public void testInnerFunctionClosureVariableReads() {\n+  public void testInnerFunctionClosureVariableReads1() {\n     test(createModuleChain(\n             \"function Foo() {}\" +\n             \"Foo.prototype.baz = function(){var x = 1;\" +\n            \"    0, function(){var x = 1; return function(){x}});\" +\n            \"var y = new Foo(); y.baz();\"\n         });\n+  }\n+\n+  // An anonymous inner function reading a closure variable is fine.\n+  public void testInnerFunctionClosureVariableReads2() {\n+    testSame(createModuleChain(\n+            \"function foo() {var x = 1;\" +\n+            \"  return function(){x}};\",\n+            // Module 2\n+            \"var y = foo(); y.baz();\"));\n   }\n \n   public void testIssue600() {\n             \"this.prototype.foo = function() {};\",\n             \"(new F()).foo();\"));\n   }\n+\n+  public void testThisPropAssign1() {\n+    testSame(\n+        createModuleChain(\n+            \"this.foo = function() {}\",\n+            \"this.foo();\"));\n+  }\n+\n+  public void testThisPropAssign2() {\n+    testSame(\n+        createModuleChain(\n+            \"function f() { this.foo = function() {} }\",\n+            \"x.foo();\"));\n+  }\n+\n+  public void testThisPropAssign3() {\n+    testSame(\n+        createModuleChain(\n+            \"function f() { this.foo = function() {} }\",\n+            \"f();x.foo();\"));\n+  }\n+\n+  public void testMovePrototypeMethodWithThisPropSet1() {\n+    test(createModuleChain(\n+             \"function Foo() {}\" +\n+             \"Foo.prototype.method = function() { this.x = 1 };\",\n+             // Module 2\n+             \"(new Foo).method()\"),\n+         new String[] {\n+             STUB_DECLARATIONS +\n+             \"function Foo() {}\" +\n+             \"Foo.prototype.method = JSCompiler_stubMethod(0);\",\n+             // Module 2\n+             \"Foo.prototype.method = JSCompiler_unstubMethod(0, function() {\" +\n+                 \"this.x = 1 });\" +\n+             \"(new Foo).method()\"\n+         });\n+  }\n+\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n  */\n public class RemoveUnusedPrototypePropertiesTest extends CompilerTestCase {\n   private static final String EXTERNS =\n-      \"IFoo.prototype.bar; var mExtern; mExtern.bExtern; mExtern['cExtern'];\";\n+      \"IFoo.prototype.bar; var mExtern; mExtern.bExtern; mExtern['cExtern'];\" +\n+      \"var window;\\n\" +\n+      \"function alert(a) {}\\n\" +\n+      \"var EXT = {};\" +\n+      \"EXT.ext;\";\n \n   private boolean canRemoveExterns = false;\n   private boolean anchorUnusedVars = false;\n+  private boolean canRemoveThisProps = true;\n+  private boolean anchorObjectLitProps = false;\n \n   public RemoveUnusedPrototypePropertiesTest() {\n     super(EXTERNS);\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new RemoveUnusedPrototypeProperties(compiler,\n-        canRemoveExterns, anchorUnusedVars);\n+        canRemoveExterns, anchorUnusedVars,\n+        canRemoveThisProps, anchorObjectLitProps);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 3;\n   }\n \n   @Override\n   public void setUp() {\n     anchorUnusedVars = false;\n     canRemoveExterns = false;\n+    canRemoveThisProps = true;\n+    anchorObjectLitProps = false;\n   }\n \n   public void testAnalyzePrototypeProperties() {\n            \"e.prototype['alias1'] = e.prototype.method1 = function(){};\" +\n            \"e.prototype['alias2'] = e.prototype.method2 = function(){};\",\n          \"function e(){}\" +\n-           \"e.prototype[\\\"alias1\\\"]=e.prototype.method1=function(){};\" +\n-           \"e.prototype[\\\"alias2\\\"]=e.prototype.method2=function(){};\");\n+           \"e.prototype[\\\"alias1\\\"] = function(){};\" +\n+           \"e.prototype[\\\"alias2\\\"] = function(){};\");\n   }\n \n   public void testAliasing5() {\n   public void testAliasing7() {\n     // An exported alias must preserved any referenced values in the\n     // referenced function.\n-    testSame(\"function e(){}\" +\n-           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n+    test(\"function e(){}\" +\n+         \"e.prototype['alias1'] = e.prototype.method1 = \" +\n+             \"function(){this.method2()};\" +\n+         \"e.prototype.method2 = function(){};\",\n+         \"function e(){}\" +\n+         \"e.prototype['alias1'] = \" +\n+             \"function(){this.method2()};\" +\n+         \"e.prototype.method2 = function(){};\");\n+  }\n+\n+  public void testAliasing8a() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(\"function e(){}\" +\n+         \"e.prototype.alias1 = e.prototype.method1 = \" +\n+             \"function(){this.method2()};\" +\n+         \"e.prototype.method2 = function(){};\" +\n+         \"x.alias1()\",\n+         \"function e(){}\" +\n+         \"e.prototype.alias1 = \" +\n+             \"function(){this.method2()};\" +\n+         \"e.prototype.method2 = function(){};\" +\n+         \"x.alias1()\");\n+  }\n+\n+  public void testAliasing8b() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(  \"function e(){}\" +\n+           \"e.prototype.alias1 = e.prototype.method1 = \" +\n                \"function(){this.method2()};\" +\n-           \"e.prototype.method2 = function(){};\");\n+           \"e.prototype.method2 = function(){};\" +\n+           \"x.method1()\",\n+           \"function e(){}\" +\n+           \"e.prototype.method1 = \" +\n+               \"function(){this.method2()};\" +\n+           \"e.prototype.method2 = function(){};\" +\n+           \"x.method1()\");\n+  }\n+\n+  public void testAliasing9a() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(\"function e(){}; function init() {\" +\n+         \"e.prototype['alias1'] = e.prototype.method1 = \" +\n+             \"function(){this.method2()}; \" +\n+         \"e.prototype.method2 = function(){};\" +\n+         \"}\" +\n+         \"init();\",\n+         \"function e(){}; function init() {\" +\n+         \"e.prototype['alias1'] = \" +\n+             \"function(){this.method2()}; \" +\n+         \"e.prototype.method2 = function(){};\" +\n+         \"}\" +\n+         \"init();\");\n+  }\n+\n+  public void testAliasing9b() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(  \"function e(){}; function init() {\" +\n+           \"e.prototype.alias1 = e.prototype.method1 = \" +\n+               \"function(){this.method2()}; \" +\n+           \"e.prototype.method2 = function(){};\" +\n+           \"}\" +\n+           \"init();\",\n+           \";function init() {\" +\n+           \"}\" +\n+           \"init();\"\n+           );\n   }\n \n   public void testStatementRestriction() {\n            \"var x = e.prototype.method1 = function(){};\" +\n            \"var y = new e; x()\",\n          \"function e(){}\" +\n-           \"var x = e.prototype.method1 = function(){};\" +\n+           \"var x = function(){};\" +\n            \"var y = new e; x()\");\n   }\n \n   public void testUsingAnonymousObjectsToDefeatRemoval() {\n     String constructor = \"function Foo() {}\";\n     String declaration = constructor + \"Foo.prototype.baz = 3;\";\n+\n+    this.anchorObjectLitProps = false;\n+\n     test(declaration, \"\");\n-    testSame(declaration + \"var x = {}; x.baz = 5;\");\n+    test(declaration + \"var x = {}; x.baz = 5;\",\n+        \"var x = {}; x.baz = 5;\");\n+    test(declaration + \"var x = {baz: 5};\",\n+        \"var x = {baz: 5};\");\n+    test(declaration + \"var x = {'baz': 5};\",\n+        \"var x = {'baz': 5};\");\n+\n+    this.anchorObjectLitProps = true;\n+\n+    test(declaration, \"\");\n+    // TODO(johnlenz): is it necessary to support this case?\n+    // testSame(declaration + \"var x = {}; x.baz = 5;\");\n     testSame(declaration + \"var x = {baz: 5};\");\n     test(declaration + \"var x = {'baz': 5};\",\n          \"var x = {'baz': 5};\");\n+\n   }\n \n   public void testGlobalFunctionsInGraph() {\n         \"function x() { (new Foo).methodA; }\");\n   }\n \n-  public void testHook1() throws Exception {\n+  public void testHook1a() throws Exception {\n     test(\n         \"/** @constructor */ function Foo() {}\" +\n         \"Foo.prototype.method1 = Math.random() ?\" +\n+        \"   function() { this.method2(); } : function() { this.method3(); };\" +\n+        \"Foo.prototype.method2 = function() {};\" +\n+        \"Foo.prototype.method3 = function() {};\",\n+        \"Math.random()\");  // preserve side-effect\n+  }\n+\n+  public void testHook1b() throws Exception {\n+    test(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.method1 = externalVar ?\" +\n         \"   function() { this.method2(); } : function() { this.method3(); };\" +\n         \"Foo.prototype.method2 = function() {};\" +\n         \"Foo.prototype.method3 = function() {};\",\n         \"(new Foo()).method1();\");\n   }\n \n+  public void testSimpleExtern1() {\n+    // A property defined in the externs but defined on \"this\" can not\n+    // be safely removed.\n+    testSame(\"this.ext = 2\");\n+  }\n+\n+  public void testSimpleExtern2() {\n+    this.canRemoveExterns = true;\n+    // A property defined in the externs but defined on \"this\" can not\n+    // be safely removed.\n+    testSame(\"this.ext = 2\");\n+  }\n+\n+  public void testSimple1a() {\n+    // A property defined on \"this\" can be removed\n+    test(\"this.a = 2\", \"\");\n+  }\n+\n+  public void testSimple1b() {\n+    this.canRemoveThisProps = false;\n+\n+    // A property defined on \"this\" cannot be removed\n+    testSame(\"this.a = 2\");\n+  }\n+\n+  public void testSimple2() {\n+    // A property defined on \"this\" can be removed\n+    test(\"this.a = function() {}\", \"\");\n+  }\n+\n+  public void testSimple3() {\n+    // A property defined on \"this\" can be removed\n+    test(\"this.a = f()\", \"f()\");\n+  }\n+\n+  public void testSimple4() {\n+    // A property defined on \"this\" can be removed\n+    test(\"var x = (this.a = 2)\", \"var x = 2\");\n+  }\n+\n+  public void testSimple5() {\n+    // A property defined on \"this\" can be removed\n+    test(\"var x;x = (this.a = 2)\", \"var x;x = 2\");\n+  }\n+\n+  public void testSimple6() {\n+    // A property defined on \"this\" can be removed\n+    testSame(\"this.a = 2; x = this.a;\");\n+  }\n+\n+  public void testSimple7() {\n+    // A property defined on \"this\" can be removed, even when defined\n+    // as part of an expression\n+    test(\"this.a = 2, f()\", \"0, f()\");\n+    test(\"x = (this.a = 2, f())\", \"x = (0, f())\");\n+    test(\"x = (f(), this.a = 2)\", \"x = (f(), 2)\");\n+  }\n+\n+  public void testSimple8() {\n+    // A property defined on an object other than \"this\" can not be removed.\n+    testSame(\"y.a = 2\");\n+  }\n+\n+  public void testSimple9() {\n+    // but doesn't prevent the removal of the definition on 'this'.\n+    test(\"y.a = 2; this.a = 2\", \"y.a = 2;\");\n+  }\n+\n+  public void testSimple10() {\n+    // Some use of the property \"a\" prevents the removal.\n+    testSame(\"y.a = 2; this.a = 1; alert(x.a)\");\n+  }\n+\n+  public void testObjLit() {\n+    // A property defined on an object other than \"this\" can not be removed.\n+    testSame(\"({a:2})\");\n+    // but doesn't prevent the removal of the definition on 'this'.\n+    test(\"({a:0}); this.a = 1;\", \"({a:0});\");\n+    // Some use of the property \"a\" prevents the removal.\n+    testSame(\"x = ({a:0}); this.a = 1; alert(x.a)\");\n+  }\n+\n+  public void testExtern() {\n+    // A property defined in the externs is can not be removed.\n+    testSame(\"this.ext = 2\");\n+  }\n+\n+  public void testExport() {\n+    // An exported property can not be removed.\n+    testSame(\"this.ext = 2; window['export'] = this.ext;\");\n+    testSame(\n+        \"function f() { this.ext = 2; } f(); window['export'] = this.ext;\");\n+  }\n+\n+\n+  public void testAssignOp1() {\n+    // Properties defined using a compound assignment can be removed if the\n+    // result of the assignment expression is not immediately used.\n+    test(\"this.x += 2\", \"\");\n+    testSame(\"x = (this.x += 2)\");\n+    testSame(\"this.x += 2; x = this.x;\");\n+    // But, of course, a later use prevents its removal.\n+    testSame(\"this.x += 2; x.x;\");\n+  }\n+\n+  public void testAssignOp2() {\n+    // Properties defined using a compound assignment can be removed if the\n+    // result of the assignment expression is not immediately used.\n+    test(\"this.a += 2, f()\", \"0, f()\");\n+    test(\"x = (this.a += 2, f())\", \"x = (0, f())\");\n+    testSame(\"x = (f(), this.a += 2)\");\n+  }\n+\n+  public void testInc1() {\n+    // Increments and Decrements are handled similiarly to compound assignments\n+    // but need a placeholder value when replaced.\n+    test(\"this.x++\", \"0\");\n+    testSame(\"x = (this.x++)\");\n+    testSame(\"this.x++; x = this.x;\");\n+\n+    test(\"--this.x\", \"0\");\n+    testSame(\"x = (--this.x)\");\n+    testSame(\"--this.x; x = this.x;\");\n+  }\n+\n+  public void testInc2() {\n+    // Increments and Decrements are handled similiarly to compound assignments\n+    // but need a placeholder value when replaced.\n+    test(\"this.a++, f()\", \"0, f()\");\n+    test(\"x = (this.a++, f())\", \"x = (0, f())\");\n+    testSame(\"x = (f(), this.a++)\");\n+\n+    test(\"--this.a, f()\", \"0, f()\");\n+    test(\"x = (--this.a, f())\", \"x = (0, f())\");\n+    testSame(\"x = (f(), --this.a)\");\n+  }\n+\n+  public void testJSCompiler_renameProperty1() {\n+    // JSCompiler_renameProperty introduces a use of the property\n+    testSame(\"this.a = 2; x[JSCompiler_renameProperty('a')]\");\n+    testSame(\"this.a = 2; JSCompiler_renameProperty('a')\");\n+  }\n+\n+  public void testJSCompiler_renameProperty2() {\n+    // JSCompiler_renameProperty introduces a use of the property\n+    testSame(\"x.prototype.a = 2; x[JSCompiler_renameProperty('a')]\");\n+    testSame(\"x.prototype.a = 2; JSCompiler_renameProperty('a')\");\n+  }\n+\n+  public void testGoogReflectObject1() {\n+    // JSCompiler_renameProperty introduces a use of the property\n+    testSame(\"this.a = 2; f(goog.reflect.object(foo, {a:1}));\");\n+    testSame(\"this.a = 2; goog.reflect.object(foo, {a:1});\");\n+  }\n+\n+  public void testGoogReflectObject2() {\n+    // JSCompiler_renameProperty introduces a use of the property\n+    testSame(\"x.prototype.a = 2; f(goog.reflect.object(foo, {a:1}));\");\n+    testSame(\"x.prototype.a = 2; goog.reflect.object(foo, {a:1});\");\n+  }\n+\n+  public void testForIn() {\n+    // This is the basic assumption that this pass makes:\n+    // it can remove properties even when the object is used in a FOR-IN loop\n+    test(\"this.y = 1;for (var a in x) { alert(x[a]) }\",\n+         \"for (var a in x) { alert(x[a]) }\");\n+  }\n+\n+  public void testObjectKeys() {\n+    // This is the basic assumption that this pass makes:\n+    // it can remove properties even when the object are referenced\n+    test(\"this.y = 1;alert(Object.keys(this))\",\n+         \"alert(Object.keys(this))\");\n+  }\n+\n+  public void testConditionalSideEffect1() {\n+     test(\"this.a = 1;\" +\n+          \"this.b = ((this.a) ? f() : g())\",\n+          \"this.a = 1;\" +\n+          \"this.a ? f() : g()\");\n+  }\n+\n+  public void testConditionalSideEffect2() {\n+    test(\"this.a = 1;\" +\n+         \"this.b = ((this.a) ? f() : 1)\",\n+         \"this.a = 1;\" +\n+         \"this.a && f()\");\n+  }\n+\n+  public void testConditionalSideEffect3() {\n+    test(\"this.a = 1;\" +\n+         \"this.b = (this.a) || f()\",\n+         \"this.a = 1;\" +\n+         \"this.a || f()\");\n+  }\n+\n+  public void testConditionalSideEffect4() {\n+    test(\"this.a = 0;\" +\n+         \"this.b = (this.a) && f()\",\n+         \"this.a = 0;\" +\n+         \"this.a && f()\");\n+  }\n+\n }\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n     new PassFactory(\"removeUnusedPrototypeProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new RemoveUnusedPrototypeProperties(compiler, false, false);\n+      return new RemoveUnusedPrototypeProperties(\n+          compiler, false, false, true, false);\n     }\n   };\n ", "timestamp": 1328130557, "metainfo": ""}