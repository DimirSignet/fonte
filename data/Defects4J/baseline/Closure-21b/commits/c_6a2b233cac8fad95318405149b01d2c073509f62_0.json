{"sha": "6a2b233cac8fad95318405149b01d2c073509f62", "log": "Redeclare native types in the externs. This ensures that source links point to the right place  R=acleung DELTA=22  (17 added, 1 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3185   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n    * @param newType The type being applied to the variable. Mostly just here\n    *     for the benefit of the warning.\n    */\n-  void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var,\n-      String variableName, JSType newType) {\n+  void expectUndeclaredVariable(String sourceName, CompilerInput input,\n+      Node n, Node parent, Var var, String variableName, JSType newType) {\n     boolean allowDupe = false;\n     if (n.getType() == Token.GETPROP ||\n         NodeUtil.isObjectLitKey(n, parent)) {\n       // is an error and the second declaration is ignored, except in the\n       // case of native types. A null input type means that the declaration\n       // was made in TypedScopeCreator#createInitialScope and is a\n-      // native type.\n+      // native type. We should redeclare it at the new input site.\n       if (var.input == null) {\n+        Scope s = var.getScope();\n+        s.undeclare(var);\n+        s.declare(variableName, n, varType, input, false);\n+\n         n.setJSType(varType);\n         if (parent.getType() == Token.VAR) {\n           if (n.getFirstChild() != null) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       }\n \n       // declared in closest scope?\n+      CompilerInput input = compiler.getInput(inputId);\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar = scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(\n-            sourceName, n, parent, oldVar, variableName, type);\n+            sourceName, input, n, parent, oldVar, variableName, type);\n       } else {\n         if (!inferred) {\n           setDeferredType(n, type);\n         }\n \n-        CompilerInput input = compiler.getInput(inputId);\n         // The input may be null if we are working with a AST snippet.\n         boolean isExtern = n.isFromExterns();\n         Var newVar =\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         func.getPrototype().getPropertyType(\"apply\").toString());\n   }\n \n+  public void testTypesInExterns() throws Exception {\n+    testSame(\n+        CompilerTypeTestCase.DEFAULT_EXTERNS,\n+        \"\", null);\n+\n+    Var v = globalScope.getVar(\"Object\");\n+    FunctionType obj = (FunctionType) v.getType();\n+    assertEquals(\"function (new:Object, *): ?\", obj.toString());\n+    assertNotNull(v.getNode());\n+    assertNotNull(v.input);\n+  }\n+\n   public void testPropertyDeclarationOnInstanceType() {\n     testSame(\n         \"/** @type {!Object} */ var a = {};\" +", "timestamp": 1315335136, "metainfo": ""}