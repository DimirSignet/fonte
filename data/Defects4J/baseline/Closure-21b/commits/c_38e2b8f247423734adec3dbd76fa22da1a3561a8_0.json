{"sha": "38e2b8f247423734adec3dbd76fa22da1a3561a8", "log": "fixes issue 698  R=acleung DELTA=60  (50 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4545   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    (new NodeTraversal(compiler, this)).traverse(root);\n+    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n \n   @Override\n             }\n \n             Node defNode = reachingDef.getDef(name, cfgNode);\n+            // TODO(nicksantos): We need to add some notion of @const outer\n+            // scope vars. We can inline those just fine.\n             if (defNode != null &&\n                 !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {\n               candidates.add(new Candidate(name, defNode, n, cfgNode));\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n+    private boolean unknownDependencies = false;\n+\n     Definition(Node node) {\n       this.node = node;\n     }\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n-          def.depends.add(jsScope.getVar(n.getString()));\n+        if (n.isName()) {\n+          Var dep = jsScope.getVar(n.getString());\n+          if (dep == null) {\n+            def.unknownDependencies = true;\n+          } else {\n+            def.depends.add(dep);\n+          }\n         }\n       }\n     });\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n+    if (def.unknownDependencies) {\n+      return true;\n+    }\n+\n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {\n         return true;\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {\n \n   public static final String EXTERN_FUNCTIONS = \"\" +\n+      \"var print;\\n\" +\n       \"/** @nosideeffects */ function noSFX() {} \\n\" +\n       \"                      function hasSFX() {} \\n\";\n \n \n   public void testInlineExpression8() {\n     // The same variable inlined twice.\n-    inline(\"var x = a + b; print(x);      x = a - b; print(x)\",\n-           \"var x;         print(a + b);             print(a - b)\");\n+    inline(\n+        \"var a,b;\" +\n+        \"var x = a + b; print(x);      x = a - b; print(x)\",\n+        \"var a,b;\" +\n+        \"var x;         print(a + b);             print(a - b)\");\n   }\n \n   public void testInlineExpression9() {\n     // Check for actual control flow sensitivity.\n-    inline(\"var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)\",\n-           \"var x; if (g) {           print(a + b)}             print(a - b)\");\n+    inline(\n+        \"var a,b;\" +\n+        \"var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)\",\n+        \"var a,b;\" +\n+        \"var x; if (g) {           print(a + b)}             print(a - b)\");\n   }\n \n   public void testInlineExpression10() {\n   }\n \n   public void testInlineAcrossSideEffect1() {\n-    inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n+    // This can't be inlined because print() has side-effects and might change\n+    // the definition of noSFX.\n+    //\n+    // noSFX must be both const and pure in order to inline it.\n+    noInline(\"var y; var x = noSFX(y); print(x)\");\n+    //inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n   }\n \n   public void testInlineAcrossSideEffect2() {\n   }\n \n   public void testCanInlineAcrossNoSideEffect() {\n-    inline(\"var y; var x = noSFX(Y), z = noSFX(); noSFX(); noSFX(), print(x)\",\n-           \"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(Y))\");\n+    // This can't be inlined because print() has side-effects and might change\n+    // the definition of noSFX. We should be able to mark noSFX as const\n+    // in some way.\n+    noInline(\n+        \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\");\n+    //inline(\n+    //    \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\",\n+    //    \"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))\");\n   }\n \n   public void testDependOnOuterScopeVariables() {\n     noInline(\"var x; for(; x = 1;foo(x)) {}\");\n   }\n \n+  public void testIssue698() {\n+    // Most of the flow algorithms operate on Vars. We want to make\n+    // sure the algorithm bails out appropriately if it sees\n+    // a var that it doesn't know about.\n+    inline(\n+        \"var x = ''; \"\n+        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n+        + \"x = x + unknown; \"\n+        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n+        + \"x = x + unknown; \"\n+        + \"return x;\",\n+        \"var x; \"\n+        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n+        + \"x = '' + unknown; \"\n+        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n+        + \"x = x + unknown; \"\n+        + \"return x;\");\n+  }\n+\n   private void noInline(String input) {\n     inline(input, input);\n   }", "timestamp": 1334615323, "metainfo": ""}