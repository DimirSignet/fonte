{"sha": "cd17f34a2da15b08b169cf06e72a4a209cbd6e0c", "log": "-Make RemoveUnusedVars's parameter removal understand goog.inherits and calling functions with .call(). (Attempt #2)  R=nicksantos DELTA=71  (57 added, 4 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=825   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       // Check all the call sites.\n       for (UseSite site : defFinder.getUseSites(definition)) {\n         if (isModifableCallSite(site)) {\n-          Node arg = NodeUtil.getArgumentForCallOrNew(\n-              site.node.getParent(), argIndex);\n+          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n           // TODO(johnlenz): try to remove parameters with side-effects by\n           // decomposing the call expression.\n           if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n \n       for (UseSite site : defFinder.getUseSites(definition)) {\n         if (isModifableCallSite(site)) {\n-          Node arg = NodeUtil.getArgumentForCallOrNew(\n-              site.node.getParent(), argIndex);\n+          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n           if (arg != null) {\n             Node argParent = arg.getParent();\n             // Even if we can't change the signature in general we can always\n         if (!isModifableCallSite(site)) {\n           continue;\n         }\n-\n-        Node arg = NodeUtil.getArgumentForCallOrNew(\n-            site.node.getParent(), argIndex);\n+        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n         while (arg != null) {\n           Node next = arg.getNext();\n           if (next != null && !NodeUtil.mayHaveSideEffects(next)) {\n           }\n         }\n       }\n+    }\n+\n+    /**\n+     * Returns the nth argument node given a usage site for a direct function\n+     * call or for a func.call() node.\n+     */\n+    private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n+        final int argIndex) {\n+      int adjustedArgIndex = argIndex;\n+      Node parent = site.node.getParent();\n+      if (NodeUtil.isFunctionObjectCall(parent)) {\n+        adjustedArgIndex++;\n+      }\n+      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n     }\n \n     /**\n      */\n     private static boolean isModifableCallSite(UseSite site) {\n       return SimpleDefinitionFinder.isCallOrNewSite(site)\n-          && !NodeUtil.isFunctionObjectCallOrApply(site.node.getParent());\n+          && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n     }\n \n     /**\n      */\n     private boolean canChangeSignature(Node function) {\n       Definition definition = getFunctionDefinition(function);\n+      CodingConvention convention = compiler.getCodingConvention();\n \n       Preconditions.checkState(!definition.isExtern());\n \n       Collection<UseSite> useSites = defFinder.getUseSites(definition);\n       for (UseSite site : useSites) {\n+        Node parent = site.node.getParent();\n+\n+        // Check if the reference has already been removed.\n+        if (parent == null) {\n+          continue;\n+        }\n+\n+        // Ignore references within goog.inherits calls.\n+        if (NodeUtil.isCall(parent) &&\n+            convention.getClassesDefinedByCall(parent) != null) {\n+          continue;\n+        }\n+\n         // Accessing the property directly prevents rewrite.\n         if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n-          return false;\n-        }\n-\n-        // TODO(johnlenz): support .call signature changes.\n-        if (NodeUtil.isFunctionObjectCallOrApply(site.node.getParent())) {\n+          if (!(NodeUtil.isGetProp(parent) &&\n+              NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n+            return false;\n+          }\n+        }\n+\n+        if (NodeUtil.isFunctionObjectApply(parent)) {\n           return false;\n         }\n \n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n     testSame(\"var b=function(){return};b()\");\n     testSame(\"var b=function(c){return c};b(1)\");\n     test(\"var b=function(c){};b.call(null, x)\",\n-         \"var b=function(){};b.call(null, x)\");\n+         \"var b=function(){};b.call(null)\");\n     test(\"var b=function(c){};b.apply(null, x)\",\n          \"var b=function(){};b.apply(null, x)\");\n \n     // the call sites are left unmodified for now.\n     test(\"var b=function(c,d){};var b=function(e,f){};b(1,2)\",\n          \"var b=function(){};var b=function(){};b(1,2)\");\n+  }\n+\n+  public void testCallSiteInteraction_contructors() {\n+    this.modifyCallSites = true;\n+    // The third level tests that the functions which have already been looked\n+    // at get re-visited if they are changed by a call site removal.\n+    test(\"var Ctor1=function(a,b){return a};\" +\n+        \"var Ctor2=function(a,b){Ctor1.call(this,a,b)};\" +\n+        \"goog$inherits(Ctor2, Ctor1);\" +\n+        \"new Ctor2(1,2)\",\n+        \"var Ctor1=function(a){return a};\" +\n+        \"var Ctor2=function(a){Ctor1.call(this,a)};\" +\n+        \"goog$inherits(Ctor2, Ctor1);\" +\n+        \"new Ctor2(1)\");\n+  }\n+\n+  public void testFunctionArgRemovalCausingInconsistency() {\n+    this.modifyCallSites = true;\n+    // Test the case where an unused argument is removed and the argument\n+    // contains a call site in its subtree (will cause the call site's parent\n+    // pointer to be null).\n+    test(\"var a=function(x,y){};\" +\n+        \"var b=function(z){};\" +\n+        \"a(new b, b)\",\n+        \"var a=function(){};\" +\n+        \"var b=function(){};\" +\n+        \"a(new b)\");\n   }\n \n   public void testDoNotOptimizeJSCompiler_renameProperty() {", "timestamp": 1299855875, "metainfo": ""}