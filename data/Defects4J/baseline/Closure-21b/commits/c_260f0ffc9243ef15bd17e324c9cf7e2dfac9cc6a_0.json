{"sha": "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a", "log": "Change on 2010/05/13 by nick          add an --output_manifest flag.          R=joey         DELTA=112  (107 added, 0 deleted, 5 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=2002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n \n       // Output the variable and property name maps if requested.\n       outputNameMaps(options);\n+\n+      // Output the manifest if requested.\n+      outputManifest();\n     }\n \n     // return 0 if no errors, the error count otherwise\n       return null;\n     }\n     return expandCommandLinePath(options.sourceMapOutputPath, forModule);\n+  }\n+\n+  /** Expansion function for the manifest. */\n+  @VisibleForTesting\n+  String expandManifest(JSModule forModule) {\n+    if (Strings.isEmpty(config.outputManifest)) {\n+      return null;\n+    }\n+    return expandCommandLinePath(config.outputManifest, forModule);\n   }\n \n   /**\n     }\n   }\n \n+  /**\n+   * Returns true if and only if a manifest should be generated for each\n+   * module, as opposed to one unified manifest.\n+   */\n+  private boolean shouldGenerateManifestPerModule() {\n+    return !config.module.isEmpty()\n+        && config.outputManifest != null\n+        && config.outputManifest.contains(\"%outname%\");\n+  }\n+\n+  /**\n+   * Writes the manifest of all compiler input files that survived\n+   * manage_closure_dependencies, if requested.\n+   */\n+  private void outputManifest() throws IOException {\n+    String outputManifest = config.outputManifest;\n+    if (Strings.isEmpty(outputManifest)) {\n+      return;\n+    }\n+\n+    if (shouldGenerateManifestPerModule()) {\n+      // Generate per-module manifests.\n+      Iterable<JSModule> modules = compiler.getModuleGraph().getAllModules();\n+      for (JSModule module : modules) {\n+        printManifestTo(module.getInputs(), expandManifest(module));\n+      }\n+    } else {\n+      // Generate a single file manifest.\n+      printManifestTo(compiler.getInputsInOrder(), expandManifest(null));\n+    }\n+  }\n+\n+  /**\n+   * Prints a list of input names, delimited by newlines, to the manifest file.\n+   */\n+  private void printManifestTo(Iterable<CompilerInput> inputs, String path)\n+      throws IOException {\n+    List<String> names = Lists.newArrayList();\n+    for (CompilerInput input : inputs) {\n+      names.add(input.getName());\n+    }\n+    String result = Joiner.on(\"\\n\").join(names);\n+    PrintStream out = toPrintStream(path);\n+    out.append(result);\n+    out.close();\n+  }\n+\n   private class RunTimeStats {\n     private long bestRunTime = Long.MAX_VALUE;\n     private long worstRunTime = Long.MIN_VALUE;\n       this.manageClosureDependencies = newVal;\n       return this;\n     }\n+\n+    private String outputManifest = \"\";\n+\n+    /**\n+     * Sets whether to print an output manifest file.\n+     */\n+    CommandLineConfig setOutputManifest(String outputManifest) {\n+      this.outputManifest = outputManifest;\n+      return this;\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n+import java.util.List;\n+\n /**\n  * An abstract compiler, to help remove the circular dependency of\n  * passes on JSCompiler.\n    * modules.\n    */\n   abstract JSModuleGraph getModuleGraph();\n+\n+  /**\n+   * Gets the inputs in the order in which they are being processed.\n+   * Only for use by {@code AbstractCompilerRunner}.\n+   */\n+  abstract List<CompilerInput> getInputsInOrder();\n \n   /**\n    * Gets a central registry of type information from the compiled JS.\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         + \"those symbols are never required, then that input will not \"\n         + \"be included in the compilation.\")\n     private boolean manage_closure_dependencies = false;\n+\n+    @Option(name = \"--output_manifest\",\n+        usage = \"Prints out a list of all the files in the compilation. \"\n+        + \"If --manage_closure_dependencies is on, this will not include \"\n+        + \"files that got dropped because they were not required. \"\n+        + \"The %outname% placeholder expands to the js output file. \"\n+        + \"If you're using modularization, using %outname% will create \"\n+        + \"a manifest for each module.\")\n+    private String output_manifest = \"\";\n \n     // Our own option parser to be backwards-compatible.\n     // It needs to be public because of the crazy reflection that args4j does.\n           .setJscompOff(flags.jscomp_off)\n           .setDefine(flags.define)\n           .setCharset(flags.charset)\n-          .setManageClosureDependencies(flags.manage_closure_dependencies);\n+          .setManageClosureDependencies(flags.manage_closure_dependencies)\n+          .setOutputManifest(flags.output_manifest);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import java.io.IOException;\n import java.io.PrintStream;\n import java.io.Serializable;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n     return errorManager;\n   }\n \n+  @Override\n+  List<CompilerInput> getInputsInOrder() {\n+    return Collections.<CompilerInput>unmodifiableList(inputs);\n+  }\n+\n   /**\n    * Stores the internal compiler state just before optimization is performed.\n    * This can be saved and restored in order to efficiently optimize multiple", "timestamp": 1273797249, "metainfo": ""}