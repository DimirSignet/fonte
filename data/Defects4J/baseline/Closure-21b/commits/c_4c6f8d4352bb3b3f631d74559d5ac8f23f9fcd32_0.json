{"sha": "4c6f8d4352bb3b3f631d74559d5ac8f23f9fcd32", "log": "Change optimize parameters to use the simple definition finder.  R=acleung   Revision created by MOE tool push_codebase. MOE_MIGRATION=1188240   ", "commit": "\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n-import com.google.javascript.jscomp.NameReferenceGraph.Name;\n-import com.google.javascript.jscomp.NameReferenceGraph.Reference;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n+import java.util.Collection;\n import java.util.List;\n \n /**\n  * </ul>\n  *\n  */\n-class OptimizeParameters implements CompilerPass {\n+class OptimizeParameters\n+    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n \n   private final AbstractCompiler compiler;\n-  private NameReferenceGraph nameGraph;\n-\n-  OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph nameGraph) {\n+\n+  OptimizeParameters(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-    this.nameGraph = nameGraph;\n-  }\n-\n-  OptimizeParameters(AbstractCompiler compiler) {\n-    this(compiler, null);\n+  }\n+\n+  // TODO(johnlenz): Remove this.\n+  OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {\n+    this(compiler);\n   }\n \n   @Override\n+  @VisibleForTesting\n   public void process(Node externs, Node root) {\n-    if (nameGraph == null) {\n-      NameReferenceGraphConstruction c =\n-          new NameReferenceGraphConstruction(compiler);\n-      c.process(externs, root);\n-      nameGraph = c.getNameReferenceGraph();\n-    }\n-\n-    for (DiGraphNode<Name, Reference> node :\n-        nameGraph.getDirectedGraphNodes()) {\n-      Name name = node.getValue();\n-      if (name.canChangeSignature()) {\n-        List<DiGraphEdge<Name, Reference>> edges = node.getInEdges();\n-        tryEliminateConstantArgs(name, edges);\n-        tryEliminateOptionalArgs(name, edges);\n-      }\n-    }\n+    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+    defFinder.process(externs, root);\n+    process(defFinder);\n+  }\n+\n+  @Override\n+  public void process(SimpleDefinitionFinder definitions) {\n+    for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n+      if (canChangeSignature(defSite, definitions)) {\n+        tryEliminateConstantArgs(defSite, definitions);\n+        tryEliminateOptionalArgs(defSite, definitions);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the definitionSite represents a function whose call\n+   *      signature can be modified.\n+   */\n+  private boolean canChangeSignature(\n+      DefinitionSite definitionSite, SimpleDefinitionFinder defFinder) {\n+    Definition definition = definitionSite.definition;\n+\n+    if (definitionSite.inExterns) {\n+      return false;\n+    }\n+\n+    // Only functions may be rewritten.\n+    // Functions that access \"arguments\" are not eligible since\n+    // rewrite changes the structure of this object.\n+    Node rValue = definition.getRValue();\n+    if (rValue == null ||\n+        !NodeUtil.isFunction(rValue) ||\n+        NodeUtil.isVarArgsFunction(rValue)) {\n+      return false;\n+    }\n+\n+    // TODO(johnlenz): support rewriting methods defined as part of\n+    // object literals (they are generally problematic because they may be\n+    // maps of functions use in for-in expressions, etc).\n+    // Be conservative, don't try to optimize any declaration that isn't as\n+    // simple function declaration or assignment.\n+    if (!OptimizeReturns.isSimpleFunctionDeclaration(rValue)) {\n+      return false;\n+    }\n+\n+    // Assume an exported method result is used.\n+    if (OptimizeReturns.maybeExported(compiler, definition)) {\n+      return false;\n+    }\n+\n+    Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+\n+    if (useSites.isEmpty()) {\n+      return false;\n+    }\n+\n+    for (UseSite site : useSites) {\n+      // Any non-call reference maybe introducing an alias. Don't try to\n+      // change the function signature, if all the aliases can't also be\n+      // changed.\n+      if (!isCallSite(site.node)) {\n+        return false;\n+      }\n+\n+      // TODO(johnlenz): support specialization\n+\n+      // Multiple definitions prevent rewrite.\n+      // TODO(johnlenz): Allow rewrite all definitions are valid.\n+      Node nameNode = site.node;\n+      Collection<Definition> singleSiteDefinitions =\n+          defFinder.getDefinitionsReferencedAt(nameNode);\n+      if (singleSiteDefinitions.size() > 1) {\n+        return false;\n+      }\n+      Preconditions.checkState(!singleSiteDefinitions.isEmpty());\n+      Preconditions.checkState(singleSiteDefinitions.contains(definition));\n+    }\n+\n+    return true;\n   }\n \n   /**\n    * Removes any optional parameters if no callers specifies it as an argument.\n-   * @param name The name of the function to optimize.\n-   * @param edges All the references to this name.\n-   */\n-  private void tryEliminateOptionalArgs(Name name,\n-      List<DiGraphEdge<Name, Reference>> edges) {\n-\n+   */\n+  private void tryEliminateOptionalArgs(\n+      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {\n     // Count the maximum number of arguments passed into this function all\n     // all points of the program.\n     int maxArgs = -1;\n \n-    for (DiGraphEdge<Name, Reference> refEdge : edges) {\n-      Reference ref = refEdge.getValue();\n-      Node call = ref.parent;\n-\n-      if (isCallSite(ref)) {\n-        int numArgs = call.getChildCount() - 1;\n-        if (numArgs > maxArgs) {\n-          maxArgs = numArgs;\n-        }\n-      } // else this is a definition or a dereference, ignore it.\n-    }\n-\n-    for (Definition definition : name.getDeclarations()) {\n-      eliminateParamsAfter(definition.getRValue(), maxArgs);\n-    }\n+    Definition definition = defSite.definition;\n+    Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+    for (UseSite site : useSites) {\n+      Preconditions.checkState(isCallSite(site.node));\n+      Node call = site.node.getParent();\n+\n+      int numArgs = call.getChildCount() - 1;\n+      if (numArgs > maxArgs) {\n+        maxArgs = numArgs;\n+      }\n+    }\n+\n+    eliminateParamsAfter(definition.getRValue(), maxArgs);\n   }\n \n   /**\n    * function foo(b) { var a = 1 ... }\n    * foo(2);\n    * foo(3);\n-   *\n-   * @param name The name of the function to optimize.\n-   * @param edges All the references to this name.\n-   */\n-  private void tryEliminateConstantArgs(Name name,\n-      List<DiGraphEdge<Name, Reference>> edges) {\n+   */\n+  private void tryEliminateConstantArgs(\n+      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {\n \n     List<Parameter> parameters = Lists.newArrayList();\n     boolean firstCall = true;\n \n     // Build a list of parameters to remove\n-    for (DiGraphEdge<Name, Reference> refEdge : edges) {\n-      Reference ref = refEdge.getValue();\n-      Node call = ref.parent;\n-\n-      if (isCallSite(ref)) {\n-        Node cur = call.getFirstChild();\n-        if (firstCall) {\n-          // Use the first call to construct a list of parameters of the\n-          // function.\n-          buildParameterList(parameters, cur);\n-          firstCall = false;\n-        } else {\n-          findConstantParameters(parameters, cur);\n-        }\n+    Definition definition = defSite.definition;\n+    Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+    for (UseSite site : useSites) {\n+      Preconditions.checkState(isCallSite(site.node));\n+      Node call = site.node.getParent();\n+\n+      Node cur = call.getFirstChild();\n+      if (firstCall) {\n+        // Use the first call to construct a list of parameters of the\n+        // function.\n+        buildParameterList(parameters, cur);\n+        firstCall = false;\n+      } else {\n+        findConstantParameters(parameters, cur);\n       }\n     }\n \n     // Remove the constant parameters in all the calls\n-    for (DiGraphEdge<Name, Reference> refEdge : edges) {\n-      Reference ref = refEdge.getValue();\n-      Node call = ref.parent;\n-\n-      if (isCallSite(ref)) {\n-        optimizeCallSite(parameters, call);\n-      }\n+    for (UseSite site : useSites) {\n+      Preconditions.checkState(isCallSite(site.node));\n+      Node call = site.node.getParent();\n+\n+      optimizeCallSite(parameters, call);\n     }\n \n     // Remove the constant parameters in the definitions and add it as a local\n     // variable.\n-    for (Definition definition : name.getDeclarations()) {\n-      Node function = definition.getRValue();\n-      if (NodeUtil.isFunction(function)) {\n-        optimizeFunctionDefinition(parameters, function);\n-      }\n+    Node function = definition.getRValue();\n+    if (NodeUtil.isFunction(function)) {\n+      optimizeFunctionDefinition(parameters, function);\n     }\n   }\n \n   private void findConstantParameters(List<Parameter> parameters, Node cur) {\n-    for (int index = 0; (cur = cur.getNext()) != null; index++) {\n+    int index = 0;\n+    while ((cur = cur.getNext()) != null) {\n       if (index >= parameters.size()) {\n         parameters.add(new Parameter(cur, false));\n-      } else if (parameters.get(index).shouldRemove()){\n+      } else if (parameters.get(index).shouldRemove()) {\n         Node value = parameters.get(index).getArg();\n         if (!nodesAreEqual(cur, value)) {\n           parameters.get(index).setShouldRemove(false);\n         }\n       }\n+      index++;\n+    }\n+\n+    for (;index < parameters.size(); index++) {\n+      parameters.get(index).setShouldRemove(false);\n     }\n   }\n \n   }\n \n   /**\n-   * @param ref A reference to a function.\n+   * @param fn A function to check.\n    * @return true, if it's safe to optimize this function.\n    */\n-  private boolean isCallSite(Reference ref) {\n-    Node call = ref.parent;\n+  private boolean isCallSite(Node fn) {\n+    Node call = fn.getParent();\n     // We need to make sure we're dealing with a call to the function we're\n     // optimizing. If the the first child of the parent is not the site, this\n     // is a nested call and it's a call to another function.\n-    return isCallOrNew(call) && call.getFirstChild() == ref.site;\n+    return isCallOrNew(call) && call.getFirstChild() == fn;\n   }\n \n   /**\n       argIndex--;\n     }\n \n-    while (formalArgPtr != null) {\n-      Node next = formalArgPtr.getNext();\n-      function.getFirstChild().getNext().removeChild(formalArgPtr);\n-      Node var = new Node(Token.VAR, formalArgPtr);\n-      function.getLastChild().addChildrenToFront(var);\n+    return eliminateParamsAfter(function, formalArgPtr);\n+  }\n+\n+  private boolean eliminateParamsAfter(Node fnNode, Node argNode) {\n+    if (argNode != null) {\n+      // Keep the args in the same order, do the last first.\n+      eliminateParamsAfter(fnNode, argNode.getNext());\n+      argNode.detachFromParent();\n+      Node var = new Node(Token.VAR, argNode).copyInformationFrom(argNode);\n+      fnNode.getLastChild().addChildrenToFront(var);\n       compiler.reportCodeChange();\n-      paramRemoved = true;\n-      formalArgPtr = next;\n-    }\n-\n-    return paramRemoved;\n+      return true;\n+    }\n+    return false;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n     testSame(\"function foo(p1) { } foo(1,2); foo(3,4)\");\n   }\n \n+  public void testSimpleRemoval() {\n+    test(\"function foo(p1) { } foo(); foo()\",\n+         \"function foo() {var p1;} foo(); foo()\");\n+    test(\"function foo(p1) { } foo(1); foo(1)\",\n+         \"function foo() {var p1 = 1;} foo(); foo()\");\n+    test(\"function foo(p1) { } foo(1,2); foo(1,4)\",\n+         \"function foo() {var p1 = 1;} foo(2); foo(4)\");\n+  }\n+\n   public void testNotAFunction() {\n     testSame(\"var x = 1; x; x = 2\");\n   }\n \n   public void testRemoveOneOptionalNamedFunction() {\n     test(\"function foo(p1) { } foo()\", \"function foo() {var p1} foo()\");\n+  }\n+\n+  public void testDifferentScopes() {\n+    test(\"function f(a, b) {} f(1, 2); f(1, 3); \" +\n+        \"function h() {function g(a) {} g(4); g(5);} f(1, 2);\",\n+        \"function f(b) {var a = 1} f(2); f(3); \" +\n+        \"function h() {function g(a) {} g(4); g(5);} f(2);\");\n+  }\n+\n+  public void testOptimizeOnlyImmutableValues() {\n+    test(\"function foo(a) {}; foo(undefined);\",\n+         \"function foo() {var a = undefined}; foo()\");\n+    test(\"function foo(a) {}; foo(null);\",\n+        \"function foo() {var a = null}; foo()\");\n+    test(\"function foo(a) {}; foo(1);\",\n+         \"function foo() {var a = 1}; foo()\");\n+    test(\"function foo(a) {}; foo('abc');\",\n+        \"function foo() {var a = 'abc'}; foo()\");\n+\n+    test(\"var foo = function(a) {}; foo(undefined);\",\n+         \"var foo = function() {var a = undefined}; foo()\");\n+    test(\"var foo = function(a) {}; foo(null);\",\n+         \"var foo = function() {var a = null}; foo()\");\n+    test(\"var foo = function(a) {}; foo(1);\",\n+         \"var foo = function() {var a = 1}; foo()\");\n+    test(\"var foo = function(a) {}; foo('abc');\",\n+         \"var foo = function() {var a = 'abc'}; foo()\");\n   }\n \n   public void testRemoveOneOptionalVarAssignment() {\n         \"var foo = function () {var p1}; foo()\");\n   }\n \n+  public void testDoOptimizeCall() {\n+    testSame(\"var foo = function () {}; foo(); foo.call();\");\n+    testSame(\"var foo = function () {}; foo(); foo.call(this);\");\n+    // TODO(johnlenz): support foo.call\n+    testSame(\"var foo = function (a, b) {}; foo(1); foo.call(this, 1);\");\n+  }\n+\n   public void testRemoveOneOptionalExpressionAssign() {\n-    test(\"var foo; foo = function (p1) { }; foo()\",\n-        \"var foo; foo = function () {var p1}; foo()\");\n+    // TODO(johnlenz): There are two definitions of \"foo\" here, ignore the\n+    // one that can't be called.\n+    testSame(\"var foo; foo = function (p1) { }; foo()\");\n   }\n \n   public void testRemoveOneOptionalOneRequired() {\n         \"goog.foo = function (q1) { var q2 };\" +\n         \"goog.foo = function (r1) { var r2 };\" +\n         \"goog.foo(1); goog.foo(2); goog.foo()\";\n-    test(src, expected);\n+    // TODO(johnlenz): Support multiple valid definitions.\n+    testSame(src);\n   }\n \n   public void testRemoveTwoOptionalMultiplePossibleDefinition() {\n         \"goog.foo = function(q1, q2) { var q4; var q3};\" +\n         \"goog.foo = function(r1, r2) { var r4; var r3};\" +\n         \"goog.foo(1,0); goog.foo(2,1); goog.foo()\";\n-    test(src, expected);\n+    // TODO(johnlenz): Support multiple valid definitions.\n+    testSame(src);\n   }\n \n   public void testConstructorOptArgsNotRemoved() {\n     testSame(src);\n   }\n \n-  public void testUnknown() {\n+  public void testMultipleUnknown() {\n     String src = \"var goog1 = {};\" +\n         \"goog1.foo = function () { };\" +\n         \"var goog2 = {};\" +\n         \"goog2.foo = function () { var p1 };\" +\n         \"var x = getGoog();\" +\n         \"x.foo()\";\n+    // TODO(johnlenz): Support multiple definitions.\n+    testSame(src);\n+  }\n+\n+  public void testSingleUnknown() {\n+    String src =\n+        \"var goog2 = {};\" +\n+        \"goog2.foo = function (p1) { };\" +\n+        \"var x = getGoog();\" +\n+        \"x.foo()\";\n+\n+    String expected =\n+        \"var goog2 = {};\" +\n+        \"goog2.foo = function () { var p1 };\" +\n+        \"var x = getGoog();\" +\n+        \"x.foo()\";\n     test(src, expected);\n   }\n \n         \"baz = function(a) {};\" +\n         \"baz(1);\" +\n         \"foo(baz);\"; // Baz should be aliased.\n+    testSame(src);\n+  }\n+\n+  public void testMethodsDefinedInArraysDontGetOptimized() {\n+    String src =\n+        \"var array = [true, function (a) {}];\" +\n+        \"array[1](1)\";\n+    testSame(src);\n+  }\n+\n+  public void testMethodsDefinedInObjectDontGetOptimized() {\n+    String src =\n+      \"var object = { foo: function bar() {} };\" +\n+      \"object.foo(1)\";\n+    testSame(src);\n+    src =\n+      \"var object = { foo: function bar() {} };\" +\n+      \"object['foo'](1)\";\n     testSame(src);\n   }\n \n   public void testFunctionWithReferenceToArgumentsShouldNotBeOptimize() {\n     testSame(\"function foo(a,b,c) { return arguments.size; };\" +\n              \"foo(1);\");\n+    testSame(\"var foo = function(a,b,c) { return arguments.size }; foo(1);\");\n+    testSame(\"var foo = function bar(a,b,c) { return arguments.size }; \" +\n+             \"foo(2); bar(2);\");\n+  }\n+\n+  public void testFunctionWithTwoNames() {\n+    testSame(\"var foo = function bar(a,b) {};\");\n+    testSame(\"var foo = function bar(a,b) {}; foo(1)\");\n+    testSame(\"var foo = function bar(a,b) {}; bar(1);\");\n+    testSame(\"var foo = function bar(a,b) {}; foo(1); foo(2)\");\n+    testSame(\"var foo = function bar(a,b) {}; foo(1); bar(1)\");\n+    testSame(\"var foo = function bar(a,b) {}; foo(1); bar(2)\");\n+    testSame(\"var foo = function bar(a,b) {}; foo(1,2); bar(2,1)\");\n+  }\n+\n+  public void testRecursion() {\n+    test(\"var foo = function (a,b) {foo(1, b)}; foo(1, 2)\",\n+         \"var foo = function (b) {var a=1; foo(b)}; foo(2)\");\n   }\n \n   public void testConstantArgumentsToConstructorCanBeOptimized() {\n         \"var bar = new Foo(1);\" +\n         \"var baz = new Foo(2);\");\n   }\n+\n+  public void testDoNotOptimizeArrayElements() {\n+    testSame(\"var array = [function (a, b) {}];\");\n+    testSame(\"var array = [function f(a, b) {}]\");\n+\n+    testSame(\"var array = [function (a, b) {}];\" +\n+        \"array[0](1, 2);\" +\n+        \"array[0](1);\");\n+\n+    testSame(\"var array = [];\" +\n+        \"function foo(a, b) {};\" +\n+        \"array[0] = foo;\");\n+  }\n+\n+  public void testOptimizeThis() {\n+    String src = \"function foo() {\" +\n+        \"var bar = function (a, b) {};\" +\n+        \"this.bar = function (a, b) {};\" +\n+        \"this.bar(3);\" +\n+        \"bar(2);}\";\n+    String expected = \"function foo() {\" +\n+        \"var bar = function () {var b; var a = 2;};\" +\n+        \"this.bar = function () {var b; var a = 3;};\" +\n+        \"this.bar();\" +\n+        \"bar();}\";\n+    test(src, expected);\n+  }\n+\n+  public void testDoNotOptimizeWhenArgumentsPassedAsParameter() {\n+    testSame(\"function foo(a) {}; foo(arguments)\");\n+    testSame(\"function foo(a) {}; foo(arguments[0])\");\n+\n+    test(\"function foo(a, b) {}; foo(arguments, 1)\",\n+         \"function foo(a) {var b = 1}; foo(arguments)\");\n+\n+    test(\"function foo(a, b) {}; foo(arguments)\",\n+    \"function foo(a) {var b}; foo(arguments)\");\n+  }\n+\n+  public void testDoNotOptimizeGoogExportFunctions() {\n+    testSame(\"function foo(a, b) {}; foo(); goog.export_function(foo);\");\n+  }\n }", "timestamp": 1289605127, "metainfo": ""}