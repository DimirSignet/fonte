{"sha": "7a1286edcf9328ad70b0afddd552a62d93aad1be", "log": "Fold String::substr and String::stribtring. Contributed by Tim Wintle. Fixes issue 239. Code review at: http://codereview.appspot.com/2240041  Revision created by MOE tool push_codebase.  R=johnlenz DELTA=227  (181 added, 25 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=238142   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   }\n \n   private Node tryFoldKnownMethods(Node subtree) {\n-    // For now we only support .join() and .indexOf()\n-\n-    subtree = tryFoldStringJoin(subtree);\n+    // For now we only support .join(),\n+    // .indexOf(), .substring() and .substr()\n+\n+    subtree = tryFoldArrayJoin(subtree);\n \n     if (subtree.getType() == Token.CALL) {\n-      subtree = tryFoldStringIndexOf(subtree);\n+      subtree = tryFoldKnownStringMethods(subtree);\n     }\n \n     return subtree;\n   }\n+\n+  /**\n+   * Try to eveluate known String methods\n+   *    .indexOf(), .substr(), .substring()\n+   */\n+  private Node tryFoldKnownStringMethods(Node subtree) {\n+    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+\n+    // check if this is a call on a string method\n+    // then dispatch to specific folding method.\n+    Node callTarget = subtree.getFirstChild();\n+    if (callTarget == null) {\n+      return subtree;\n+    }\n+\n+    Node firstArg = callTarget.getNext();\n+    if (firstArg == null) {\n+      return subtree;\n+    }\n+\n+    if (!NodeUtil.isGet(callTarget) ||\n+        !NodeUtil.isImmutableValue(firstArg)) {\n+      return subtree;\n+    }\n+\n+    Node stringNode = callTarget.getFirstChild();\n+    Node functionName = stringNode.getNext();\n+\n+    if ((stringNode.getType() != Token.STRING) || (\n+        (functionName.getType() != Token.STRING))) {\n+      return subtree;\n+    }\n+\n+    String functionNameString = functionName.getString();\n+    if (functionNameString.equals(\"indexOf\") ||\n+        functionNameString.equals(\"lastIndexOf\")) {\n+      subtree = tryFoldStringIndexOf(subtree, functionNameString,\n+          stringNode, firstArg);\n+    } else if (functionNameString.equals(\"substr\")) {\n+      subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n+    } else if (functionNameString.equals(\"substring\")) {\n+      subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n+    }\n+\n+    return subtree;\n+ }\n \n   /**\n    * Try to evaluate String.indexOf/lastIndexOf:\n    *     \"abcdef\".indexOf(\"bc\") -> 1\n    *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n    */\n-  private Node tryFoldStringIndexOf(Node n) {\n+  private Node tryFoldStringIndexOf(\n+      Node n, String functionName, Node lstringNode, Node firstArg) {\n     Preconditions.checkArgument(n.getType() == Token.CALL);\n-\n-    Node left = n.getFirstChild();\n-\n-    if (left == null) {\n-      return n;\n-    }\n-\n-    Node right = left.getNext();\n-\n-    if (right == null) {\n-      return n;\n-    }\n-\n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-      return n;\n-    }\n-\n-    Node lstringNode = left.getFirstChild();\n-    Node functionName = lstringNode.getNext();\n-\n-    if ((lstringNode.getType() != Token.STRING) ||\n-        (!functionName.getString().equals(\"indexOf\") &&\n-        !functionName.getString().equals(\"lastIndexOf\"))) {\n-      return n;\n-    }\n+    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n \n     String lstring = NodeUtil.getStringValue(lstringNode);\n-    boolean isIndexOf = functionName.getString().equals(\"indexOf\");\n-    Node firstArg = right;\n-    Node secondArg = right.getNext();\n+    boolean isIndexOf = functionName.equals(\"indexOf\");\n+    Node secondArg = firstArg.getNext();\n     String searchValue = NodeUtil.getStringValue(firstArg);\n     // searchValue must be a valid string.\n     if (searchValue == null) {\n   /**\n    * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n    */\n-  private Node tryFoldStringJoin(Node n) {\n-    Node left = n.getFirstChild();\n-\n-    if (left == null) {\n-      return n;\n-    }\n-\n-    Node right = left.getNext();\n+  private Node tryFoldArrayJoin(Node n) {\n+    Node callTarget = n.getFirstChild();\n+\n+    if (callTarget == null) {\n+      return n;\n+    }\n+\n+    Node right = callTarget.getNext();\n \n     if (right == null) {\n       return n;\n     }\n \n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-      return n;\n-    }\n-\n-    Node arrayNode = left.getFirstChild();\n+    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n+      return n;\n+    }\n+\n+    Node arrayNode = callTarget.getFirstChild();\n     Node functionName = arrayNode.getNext();\n \n     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n     }\n \n     return n;\n+  }\n+\n+  /**\n+   * Try to fold .substr() calls on strings\n+   */\n+  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int start, length;\n+    String stringAsString = stringNode.getString();\n+\n+    // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n+    // function.\n+    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+      start = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    Node arg2 = arg1.getNext();\n+    if (arg2 != null) {\n+      if (arg2.getType() == Token.NUMBER) {\n+        length = (int) arg2.getDouble();\n+      } else {\n+        return n;\n+      }\n+\n+      if (arg2.getNext() != null) {\n+        // If we got more args than we expected, bail out.\n+        return n;\n+      }\n+    } else {\n+      // parameter 2 not passed\n+      length = stringAsString.length() - start;\n+    }\n+\n+    // Don't handle these cases. The specification actually does\n+    // specify the behavior in some of these cases, but we haven't\n+    // done a thorough investigation that it is correctly implemented\n+    // in all browsers.\n+    if ((start + length) > stringAsString.length() ||\n+        (length < 0) ||\n+        (start < 0)) {\n+      return n;\n+    }\n+\n+    String result = stringAsString.substring(start, start + length);\n+    Node resultNode = Node.newString(result);\n+\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+  }\n+\n+  /**\n+   * Try to fold .substring() calls on strings\n+   */\n+  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int start, end;\n+    String stringAsString = stringNode.getString();\n+\n+    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+      start = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    Node arg2 = arg1.getNext();\n+    if (arg2 != null) {\n+      if (arg2.getType() == Token.NUMBER) {\n+        end = (int) arg2.getDouble();\n+      } else {\n+        return n;\n+      }\n+\n+      if (arg2.getNext() != null) {\n+        // If we got more args than we expected, bail out.\n+        return n;\n+      }\n+    } else {\n+      // parameter 2 not passed\n+      end = stringAsString.length();\n+    }\n+\n+    // Don't handle these cases. The specification actually does\n+    // specify the behavior in some of these cases, but we haven't\n+    // done a thorough investigation that it is correctly implemented\n+    // in all browsers.\n+    if ((end > stringAsString.length()) ||\n+        (start > stringAsString.length()) ||\n+        (end < 0) ||\n+        (start < 0)) {\n+      return n;\n+    }\n+\n+    String result = stringAsString.substring(start, end);\n+    Node resultNode = Node.newString(result);\n+\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"[foo()].join('')\", \"'' + foo()\");\n   }\n \n+  public void testFoldStringSubstr() {\n+    fold(\"x = 'abcde'.substr(0,2)\", \"x = 'ab'\");\n+    fold(\"x = 'abcde'.substr(1,2)\", \"x = 'bc'\");\n+    fold(\"x = 'abcde'['substr'](1,3)\", \"x = 'bcd'\");\n+    fold(\"x = 'abcde'.substr(2)\", \"x = 'cde'\");\n+\n+    // we should be leaving negative indexes alone for now\n+    foldSame(\"x = 'abcde'.substr(-1)\");\n+    foldSame(\"x = 'abcde'.substr(1, -2)\");\n+    foldSame(\"x = 'abcde'.substr(1, 2, 3)\");\n+    foldSame(\"x = 'a'.substr(0, 2)\");\n+  }\n+\n+  public void testFoldStringSubstring() {\n+    fold(\"x = 'abcde'.substring(0,2)\", \"x = 'ab'\");\n+    fold(\"x = 'abcde'.substring(1,2)\", \"x = 'b'\");\n+    fold(\"x = 'abcde'['substring'](1,3)\", \"x = 'bc'\");\n+    fold(\"x = 'abcde'.substring(2)\", \"x = 'cde'\");\n+\n+    // we should be leaving negative indexes alone for now\n+    foldSame(\"x = 'abcde'.substring(-1)\");\n+    foldSame(\"x = 'abcde'.substring(1, -2)\");\n+    foldSame(\"x = 'abcde'.substring(1, 2, 3)\");\n+    foldSame(\"x = 'a'.substring(0, 2)\");\n+  }\n+\n   public void testFoldArithmetic() {\n     fold(\"x = 10 + 20\", \"x = 30\");\n     fold(\"x = 2 / 4\", \"x = 0.5\");", "timestamp": 1285029127, "metainfo": ""}