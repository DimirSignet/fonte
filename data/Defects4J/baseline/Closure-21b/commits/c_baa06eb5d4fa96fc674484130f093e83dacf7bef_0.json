{"sha": "baa06eb5d4fa96fc674484130f093e83dacf7bef", "log": "fix another weird bug in the function type lattice.  R=johnlenz DELTA=28  (25 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=715053   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     return supAndInfHelper(that, false);\n   }\n \n+  /**\n+   * Computes the supremum or infimum of functions with other types.\n+   * Because sup() and inf() share a lot of logic for functions, we use\n+   * a single helper.\n+   * @param leastSuper If true, compute the supremum of {@code this} with\n+   *     {@code that}. Otherwise compute the infimum.\n+   * @return The least supertype or greatest subtype.\n+   */\n   private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n     // NOTE(nicksantos): When we remove the unknown type, the function types\n     // form a lattice with the universal constructor at the top of the lattice,\n           !this.call.hasUnknownParamsOrReturn() &&\n           !other.call.hasUnknownParamsOrReturn()) {\n \n-        // Check for the degenerate case.\n-        if (this.isSubtype(that)) {\n+        // Check for the degenerate case, but double check\n+        // that there's not a cycle.\n+        boolean isSubtypeOfThat = this.isSubtype(that);\n+        boolean isSubtypeOfThis = that.isSubtype(this);\n+        if (isSubtypeOfThat && !isSubtypeOfThis) {\n           return leastSuper ? that : this;\n-        } else if (that.isSubtype(this)) {\n+        } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n           return leastSuper ? this : that;\n         }\n \n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n         \"function (this:NoObject): None\", retString, retNumber);\n   }\n \n+  public void testSupAndInfOfReturnTypesWithNumOfParams() {\n+    FunctionType twoNumbers = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE, NUMBER_TYPE))\n+        .withReturnType(BOOLEAN_TYPE).build();\n+    FunctionType oneNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withReturnType(BOOLEAN_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"Function\", twoNumbers, oneNumber);\n+    assertGreatestSubtype(\n+        \"function (...[*]): None\", twoNumbers, oneNumber);\n+  }\n+\n   private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n     assertEquals(s, t1.getLeastSupertype(t2).toString());\n     assertEquals(s, t2.getLeastSupertype(t1).toString());", "timestamp": 1288035934, "metainfo": ""}