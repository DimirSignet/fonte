{"sha": "616f796f52ee78e1a655e913e0b339d6c5e1347e", "log": "Add better support for generic methods.  R=nicksantos DELTA=1070  (825 added, 186 deleted, 59 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4996   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       returnTypeInferred = false;\n     }\n \n-    if (!templateTypeNames.isEmpty() &&\n-        returnType != null &&\n-        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n-      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n-    }\n     return this;\n   }\n \n         parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n       }\n \n-      if (!templateTypeNames.isEmpty() &&\n-          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n-        if (foundTemplateType) {\n-          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n-        }\n-        foundTemplateType = true;\n-      }\n       warnedAboutArgList |= addParameter(\n           builder, parameterType, warnedAboutArgList,\n           isOptionalParam,\n         builder.newParameterFromNode(oldParameterType);\n         oldParameterType = oldParameterType.getNext();\n       }\n-    }\n-\n-    if (!templateTypeNames.isEmpty() && !foundTemplateType) {\n-      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n \n     for (String inexistentName : allJsDocParams) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ModificationVisitor;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.ParameterizedType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n-\n+import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.UnionType;\n+\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n  */\n class TypeInference\n     extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n-  static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE =\n-      DiagnosticType.warning(\n-      \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\",\n-      \"The template type must be an object type.\\nActual: {0}\");\n-\n-  static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED =\n-      DiagnosticType.warning(\n-      \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\",\n-      \"A function type with the template type as the type of this must be a \" +\n-      \"parameter type\");\n-\n+\n+  // TODO(johnlenz): We no longer make this check, but we should.\n   static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS =\n     DiagnosticType.warning(\n         \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\",\n \n     Node left = n.getFirstChild();\n     JSType functionType = getJSType(left).restrictByNotNullOrUndefined();\n-    if (functionType != null) {\n-      if (functionType.isFunctionType()) {\n-        FunctionType fnType = functionType.toMaybeFunctionType();\n-        n.setJSType(fnType.getReturnType());\n-        backwardsInferenceFromCallSite(n, fnType);\n-      } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n-        n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n-      }\n+    if (functionType.isFunctionType()) {\n+      FunctionType fnType = functionType.toMaybeFunctionType();\n+      n.setJSType(fnType.getReturnType());\n+      backwardsInferenceFromCallSite(n, fnType);\n+    } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n+      n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n     }\n \n     scope = tightenTypesAfterAssertions(scope, n);\n    * JS. Those cases are enumerated here.\n    */\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n+    boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n+    if (updatedFnType) {\n+      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+    }\n     updateTypeOfParameters(n, fnType);\n-    updateTypeOfThisOnClosure(n, fnType);\n     updateBind(n, fnType);\n   }\n \n       JSType iArgumentType = getJSType(iArgument);\n       inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n \n-      if (iParameterType.isFunctionType()) {\n-        FunctionType iParameterFnType = iParameterType.toMaybeFunctionType();\n-\n+      // TODO(johnlenz): Filter out non-function types\n+      // (such as null and undefined) as\n+      // we only care about FUNCTION subtypes here.\n+      JSType restrictedParameter = iParameterType\n+          .restrictByNotNullOrUndefined()\n+          .toMaybeFunctionType();\n+      if (restrictedParameter != null) {\n         if (iArgument.isFunction() &&\n             iArgumentType.isFunctionType() &&\n             iArgument.getJSDocInfo() == null) {\n-          iArgument.setJSType(iParameterFnType);\n+          iArgument.setJSType(restrictedParameter);\n         }\n       }\n       i++;\n+    }\n+  }\n+\n+  private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n+      FunctionType fnType, Node call) {\n+    if (fnType.getTemplateTypeNames().isEmpty()\n+        || !call.hasMoreThanOneChild()) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap();\n+    maybeResolveTemplateTypeFromNodes(\n+        fnType.getParameters(),\n+        call.getChildAtIndex(1).siblings(),\n+        resolvedTypes);\n+    return resolvedTypes;\n+  }\n+\n+  private void maybeResolveTemplatedType(\n+      JSType paramType,\n+      JSType argType,\n+      Map<TemplateType, JSType> resolvedTypes) {\n+    if (paramType.isTemplateType()) {\n+      // @param {T}\n+      resolvedTemplateType(\n+          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n+    } else if (paramType.isUnionType()) {\n+      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n+      UnionType unionType = paramType.toMaybeUnionType();\n+      for (JSType alernative : unionType.getAlternates()) {\n+        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n+      }\n+    } else if (paramType.isFunctionType()) {\n+      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n+      FunctionType argFunctionType = argType\n+          .restrictByNotNullOrUndefined()\n+          .collapseUnion()\n+          .toMaybeFunctionType();\n+      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n+        // infer from return type of the function type\n+        maybeResolveTemplatedType(\n+            paramFunctionType.getReturnType(),\n+            argFunctionType.getReturnType(), resolvedTypes);\n+        // infer from parameter types of the function type\n+        maybeResolveTemplateTypeFromNodes(\n+            paramFunctionType.getParameters(),\n+            argFunctionType.getParameters(), resolvedTypes);\n+      }\n+    } else if (paramType.isParameterizedType()) {\n+      ParameterizedType paramObjectType = paramType.toMaybeParameterizedType();\n+      JSType typeParameter = paramObjectType.getParameterType();\n+      Preconditions.checkNotNull(typeParameter);\n+      if (typeParameter != null) {\n+        // @param {Array.<T>}\n+        ObjectType argObjectType = argType\n+            .restrictByNotNullOrUndefined()\n+            .collapseUnion()\n+            .toMaybeParameterizedType();\n+        if (argObjectType != null && argObjectType.isSubtype(paramType)) {\n+          JSType argTypeParameter = argObjectType.getParameterType();\n+          Preconditions.checkNotNull(argTypeParameter);\n+          maybeResolveTemplatedType(\n+              typeParameter, argTypeParameter, resolvedTypes);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void maybeResolveTemplateTypeFromNodes(\n+      Iterable<Node> declParams,\n+      Iterable<Node> callParams,\n+      Map<TemplateType, JSType> resolvedTypes) {\n+    maybeResolveTemplateTypeFromNodes(\n+        declParams.iterator(), callParams.iterator(), resolvedTypes);\n+  }\n+\n+  private void maybeResolveTemplateTypeFromNodes(\n+      Iterator<Node> declParams,\n+      Iterator<Node> callParams,\n+      Map<TemplateType, JSType> resolvedTypes) {\n+    while (declParams.hasNext() && callParams.hasNext()) {\n+      maybeResolveTemplatedType(\n+          getJSType(declParams.next()),\n+          getJSType(callParams.next()),\n+          resolvedTypes);\n+    }\n+  }\n+\n+  private void resolvedTemplateType(\n+      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n+    JSType previous = map.get(template);\n+    if (!resolved.isUnknownType()) {\n+      if (previous == null) {\n+        map.put(template, resolved);\n+      } else {\n+        JSType join = previous.getLeastSupertype(resolved);\n+        map.put(template, join);\n+      }\n+    }\n+  }\n+\n+  private static class TemplateTypeReplacer extends ModificationVisitor {\n+    private final Map<TemplateType, JSType> replacements;\n+    private final JSTypeRegistry registry;\n+\n+    TemplateTypeReplacer(\n+        JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n+      super(registry);\n+      this.registry = registry;\n+      this.replacements = replacements;\n+    }\n+\n+    @Override\n+    public JSType caseTemplateType(TemplateType type) {\n+      JSType replacement = replacements.get(type);\n+      return replacement != null ?\n+          replacement : registry.getNativeType(UNKNOWN_TYPE);\n     }\n   }\n \n    * inference will set the type of this on a function literal argument to the\n    * the actual type of T.\n    */\n-  private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n-    // TODO(user): Make the template logic more general.\n-\n+  private boolean inferTemplatedTypesForCall(\n+      Node n, FunctionType fnType) {\n     if (fnType.getTemplateTypeNames().isEmpty()) {\n-      return;\n-    }\n-\n-    int i = 0;\n-    int childCount = n.getChildCount();\n-    // Find the parameter whose type is the template type.\n-    for (Node iParameter : fnType.getParameters()) {\n-      JSType iParameterType =\n-          getJSType(iParameter).restrictByNotNullOrUndefined();\n-      if (iParameterType.isTemplateType()) {\n-        // Find the actual type of this argument.\n-        ObjectType iArgumentType = null;\n-        if (i + 1 < childCount) {\n-          Node iArgument = n.getChildAtIndex(i + 1);\n-          iArgumentType = getJSType(iArgument)\n-              .restrictByNotNullOrUndefined()\n-              .collapseUnion()\n-              .toObjectType();\n-          if (iArgumentType == null) {\n-            compiler.report(\n-                JSError.make(NodeUtil.getSourceName(iArgument), iArgument,\n-                    TEMPLATE_TYPE_NOT_OBJECT_TYPE,\n-                    getJSType(iArgument).toString()));\n-            return;\n-          }\n-        }\n-\n-        // Find the parameter whose type is function(this: T, ...)\n-        boolean foundTemplateTypeOfThisParameter = false;\n-        int j = 0;\n-        for (Node jParameter : fnType.getParameters()) {\n-          JSType jParameterType =\n-              getJSType(jParameter).restrictByNotNullOrUndefined();\n-          if (jParameterType.isFunctionType()) {\n-            FunctionType jParameterFnType = jParameterType.toMaybeFunctionType();\n-            if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n-              foundTemplateTypeOfThisParameter = true;\n-              // Find the actual type of the this argument.\n-              if (j + 1 >= childCount) {\n-                // TypeCheck#visitParameterList will warn so we bail.\n-                return;\n-              }\n-              Node jArgument = n.getChildAtIndex(j + 1);\n-              JSType jArgumentType = getJSType(jArgument);\n-              if (jArgument.isFunction() &&\n-                  jArgumentType.isFunctionType()) {\n-                if (iArgumentType != null &&\n-                    // null and undefined get filtered out above.\n-                    !iArgumentType.isNoType()) {\n-                  // If it's an function expression, update the type of this\n-                  // using the actual type of T.\n-                  FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType();\n-                  if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n-                    // The new type will be picked up when we traverse the inner\n-                    // function.\n-                    jArgument.setJSType(\n-                        registry.createFunctionTypeWithNewThisType(\n-                            jArgumentFnType, iArgumentType));\n-                  }\n-                } else {\n-                  // Warn if the anonymous function literal references this.\n-                  if (NodeUtil.referencesThis(\n-                          NodeUtil.getFunctionBody(jArgument))) {\n-                    compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n-                        FUNCTION_LITERAL_UNDEFINED_THIS));\n-                  }\n-                }\n-              }\n-              // TODO(user): Add code to TypeCheck to check that the\n-              // types of the arguments match.\n-            }\n-          }\n-          j++;\n-        }\n-\n-        if (!foundTemplateTypeOfThisParameter) {\n-          compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n-              TEMPLATE_TYPE_OF_THIS_EXPECTED));\n-          return;\n-        }\n-      }\n-      i++;\n-    }\n+      return false;\n+    }\n+\n+    // Try to infer the template types\n+    Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(\n+        fnType, n);\n+    if (inferred.size() > 0) {\n+      // Something useful was found, try to replace it.\n+      TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n+          registry, inferred);\n+      Node callTarget = n.getFirstChild();\n+\n+      FunctionType replacementFnType = fnType.visit(replacer)\n+          .toMaybeFunctionType();\n+      Preconditions.checkNotNull(replacementFnType);\n+\n+      callTarget.setJSType(replacementFnType);\n+      n.setJSType(replacementFnType.getReturnType());\n+\n+      return true;\n+    }\n+    return false;\n   }\n \n   private FlowScope traverseNew(Node n, FlowScope scope) {\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n     // least function type, i.e. (All...) -> NoType\n     FunctionType LEAST_FUNCTION_TYPE =\n-        createFunctionType(NO_TYPE, true, ALL_TYPE);\n+        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n     registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n \n     // the 'this' object in the global scope\n \n     // greatest function type, i.e. (NoType...) -> All\n     FunctionType GREATEST_FUNCTION_TYPE =\n-      createFunctionType(ALL_TYPE, true, NO_TYPE);\n+        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n     registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n         GREATEST_FUNCTION_TYPE);\n \n    * @return the union of the type and the Null type\n    */\n   public JSType createDefaultObjectUnion(JSType type) {\n-    return shouldTolerateUndefinedValues()\n+    if (type.isTemplateType()) {\n+      // Template types represent the substituted type exactly and should\n+      // not be wrapped.\n+      return type;\n+    } else {\n+      return shouldTolerateUndefinedValues()\n         ? createOptionalNullableType(type)\n         : createNullableType(type);\n+    }\n   }\n \n   /**\n   public FunctionType createFunctionTypeWithVarArgs(\n       JSType returnType, JSType... parameterTypes) {\n     return createFunctionType(\n+        returnType, createParametersWithVarArgs(parameterTypes));\n+  }\n+\n+  /**\n+   * Creates a function type. The last parameter type of the function is\n+   * considered a variable length argument.\n+   *\n+   * @param returnType the function's return type\n+   * @param parameterTypes the parameters' types\n+   */\n+  private FunctionType createNativeFunctionTypeWithVarArgs(\n+      JSType returnType, JSType... parameterTypes) {\n+    return createNativeFunctionType(\n         returnType, createParametersWithVarArgs(parameterTypes));\n   }\n \n     return new FunctionBuilder(this)\n         .withParamsNode(parameters)\n         .withReturnType(returnType)\n+        .build();\n+  }\n+\n+  private FunctionType createNativeFunctionType(\n+      JSType returnType, Node parameters) {\n+    return new FunctionBuilder(this)\n+        .withParamsNode(parameters)\n+        .withReturnType(returnType)\n+        .forNativeType()\n         .build();\n   }\n \n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   John Lenz\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * A visitor implementation that enables type substitutions.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class ModificationVisitor implements Visitor<JSType> {\n+\n+  private final JSTypeRegistry registry;\n+\n+  public ModificationVisitor(JSTypeRegistry registry) {\n+    this.registry = registry;\n+  }\n+\n+  @Override\n+  public JSType caseNoType() {\n+    return getNativeType(JSTypeNative.NO_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseEnumElementType(EnumElementType type) {\n+    return type;\n+  }\n+\n+  @Override\n+  public JSType caseAllType() {\n+    return getNativeType(JSTypeNative.ALL_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseBooleanType() {\n+    return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseNoObjectType() {\n+    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseFunctionType(FunctionType type) {\n+    if (isNativeFunctionType(type)) {\n+      return type;\n+    }\n+\n+    // TODO(johnlenz): remove this simplifying assumption...\n+    if (!type.isOrdinaryFunction()) {\n+      return type;\n+    }\n+\n+    boolean changed = false;\n+\n+    ObjectType beforeThis = type.getTypeOfThis();\n+    ObjectType afterThis = coerseToThisType(beforeThis.visit(this));\n+    if (beforeThis != afterThis) {\n+      changed = true;\n+    }\n+\n+    JSType beforeReturn = type.getReturnType();\n+    JSType afterReturn = beforeReturn.visit(this);\n+    if (beforeReturn != afterReturn) {\n+      changed = true;\n+    }\n+\n+    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n+    for (Node paramNode : type.getParameters()) {\n+      JSType beforeParamType = paramNode.getJSType();\n+      JSType afterParamType = beforeParamType.visit(this);\n+      if (beforeParamType != afterParamType) {\n+        changed = true;\n+      }\n+      if (paramNode.isOptionalArg()) {\n+        paramBuilder.addOptionalParams(afterParamType);\n+      } else if (paramNode.isVarArgs()) {\n+        paramBuilder.addVarArgs(afterParamType);\n+      } else {\n+        paramBuilder.addRequiredParams(afterParamType);\n+      }\n+    }\n+\n+    if (changed) {\n+      FunctionBuilder builder = new FunctionBuilder(registry);\n+      builder.withParams(paramBuilder);\n+      builder.withReturnType(afterReturn);\n+      builder.withTypeOfThis(afterThis);\n+      return builder.build();\n+    }\n+\n+    return type;\n+  }\n+\n+  private ObjectType coerseToThisType(JSType type) {\n+    // This isn't quite right, handle autoboxing and \"strict\" mode functions.\n+    ObjectType restricted = type.restrictByNotNullOrUndefined()\n+        .collapseUnion().toObjectType();\n+    return restricted != null ? restricted : registry.getNativeObjectType(\n+        JSTypeNative.UNKNOWN_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseObjectType(ObjectType objType) {\n+    return objType;\n+  }\n+\n+  @Override\n+  public JSType caseParameterizedType(ParameterizedType type) {\n+    ObjectType genericType = ObjectType.cast(\n+        type.getReferencedTypeInternal().visit(this));\n+    JSType paramType = type.getParameterType().visit(this);\n+    if (type.getReferencedTypeInternal() != genericType\n+        || type.getParameterType() != paramType) {\n+      type = registry.createParameterizedType(genericType, paramType);\n+    }\n+    return type;\n+  }\n+\n+  @Override\n+  public JSType caseUnknownType() {\n+    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseNullType() {\n+    return getNativeType(JSTypeNative.NULL_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseNumberType() {\n+    return getNativeType(JSTypeNative.NUMBER_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseStringType() {\n+    return getNativeType(JSTypeNative.STRING_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseVoidType() {\n+    return getNativeType(JSTypeNative.VOID_TYPE);\n+  }\n+\n+  @Override\n+  public JSType caseUnionType(UnionType type) {\n+    boolean changed = false;\n+    List<JSType> results = Lists.newArrayList();\n+    for (JSType alternative : type.getAlternates()) {\n+      JSType replacement = alternative.visit(this);\n+      if (replacement != alternative) {\n+        changed = true;\n+      }\n+      results.add(replacement);\n+    }\n+\n+    if (changed) {\n+      UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n+      for (JSType alternate : results) {\n+        builder.addAlternate(alternate);\n+      }\n+      return builder.build();  // maybe not a union\n+    }\n+\n+    return type;\n+  }\n+\n+  @Override\n+  public JSType caseTemplateType(TemplateType type) {\n+    return type;\n+  }\n+\n+  private JSType getNativeType(JSTypeNative nativeType) {\n+    return registry.getNativeType(nativeType);\n+  }\n+\n+  private boolean isNativeFunctionType(FunctionType type) {\n+    return type.isNativeObjectType();\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n       \"goog.isString = function(x) {};\" +\n       \"goog.isObject = function(x) {};\" +\n       \"goog.isDefAndNotNull = function(x) {};\" +\n+      \"goog.array = {};\" +\n+      // simplified ArrayLike definition\n+      \"/**\\n\" +\n+      \" * @typedef {Array|{length: number}}\\n\" +\n+      \" */\\n\" +\n+      \"goog.array.ArrayLike;\" +\n+      \"/**\\n\" +\n+      \" * @param {Array.<T>|{length:number}} arr\\n\" +\n+      \" * @param {function(this:S, T, number, goog.array.ArrayLike):boolean} f\\n\" +\n+      \" * @param {S=} opt_obj\\n\" +\n+      \" * @return {!Array.<T>}\\n\" +\n+      \" * @template T,S\\n\" +\n+      \" */\" +\n+      \"goog.array.filter = function(arr, f, opt_obj){};\" +\n       \"goog.asserts = {};\" +\n       \"/** @return {*} */ goog.asserts.assert = function(x) { return x; };\";\n \n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         compiler.getWarnings()[0].description);\n   }\n \n-  public void testBadTemplateType1() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \"* @param {T} x\\n\" +\n-        \"* @param {T} y\\n\" +\n-        \"* @param {function(this:T, ...)} z\\n\" +\n-        \"* @template T\\n\" +\n-        \"*/\\n\" +\n-        \"function f(x, y, z) {}\\n\" +\n-        \"f(this, this, function() { this });\",\n-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());\n-  }\n-\n-  public void testBadTemplateType2() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \"* @param {T} x\\n\" +\n-        \"* @param {function(this:T, ...)} y\\n\" +\n-        \"* @template T\\n\" +\n-        \"*/\\n\" +\n-        \"function f(x, y) {}\\n\" +\n-        \"f(0, function() {});\",\n-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(\"number\"));\n-  }\n-\n-  public void testBadTemplateType3() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \" * @param {T} x\\n\" +\n-        \" * @template T\\n\" +\n-        \"*/\\n\" +\n-        \"function f(x) {}\\n\" +\n-        \"f(this);\",\n-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());\n-  }\n-\n-  public void testBadTemplateType4() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \"* @template T\\n\" +\n-        \"*/\\n\" +\n-        \"function f() {}\\n\" +\n-        \"f();\",\n-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());\n-  }\n-\n-  public void testBadTemplateType5() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \"* @template T\\n\" +\n-        \"* @return {T}\\n\" +\n-        \"*/\\n\" +\n-        \"function f() {}\\n\" +\n-        \"f();\",\n-        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());\n-  }\n-\n   private void checkObjectType(ObjectType objectType, String propertyName,\n         JSType expectedType) {\n     assertTrue(\"Expected \" + objectType.getReferenceName() +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         false);\n   }\n \n-  public void testBadTemplateType1() throws Exception {\n+  public void testTemplateType1() throws Exception {\n     testTypes(\n         \"/**\\n\" +\n         \"* @param {T} x\\n\" +\n         \"* @template T\\n\" +\n         \"*/\\n\" +\n         \"function f(x, y, z) {}\\n\" +\n-        \"f(this, this, function() { this });\",\n-        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());\n-  }\n-\n-  public void testBadTemplateType2() throws Exception {\n+        \"f(this, this, function() { this });\");\n+  }\n+\n+  public void testTemplateType2() throws Exception {\n+    // \"this\" types need to be coerced for ES3 style function or left\n+    // allow for ES5-strict methods.\n     testTypes(\n         \"/**\\n\" +\n         \"* @param {T} x\\n\" +\n         \"* @template T\\n\" +\n         \"*/\\n\" +\n         \"function f(x, y) {}\\n\" +\n-        \"f(0, function() {});\",\n-        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(\"number\"));\n-  }\n-\n-  public void testBadTemplateType3() throws Exception {\n-    testTypes(\n-        \"/**\\n\" +\n-        \" * @param {T} x\\n\" +\n-        \" * @template T\\n\" +\n-        \"*/\\n\" +\n-        \"function f(x) {}\\n\" +\n-        \"f(this);\",\n-        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());\n-  }\n-\n-  public void testBadTemplateType4() throws Exception {\n+        \"f(0, function() {});\");\n+  }\n+\n+  public void disable_testBadTemplateType4() throws Exception {\n+    // TODO(johnlenz): Add a check for useless of template types.\n+    // Unless there are at least two references to a Template type in\n+    // a definition it isn't useful.\n     testTypes(\n         \"/**\\n\" +\n         \"* @template T\\n\" +\n         FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());\n   }\n \n-  public void testBadTemplateType5() throws Exception {\n+  public void disable_testBadTemplateType5() throws Exception {\n+    // TODO(johnlenz): Add a check for useless of template types.\n+    // Unless there are at least two references to a Template type in\n+    // a definition it isn't useful.\n     testTypes(\n         \"/**\\n\" +\n         \"* @template T\\n\" +\n         FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());\n   }\n \n-  public void testFunctionLiteralUndefinedThisArgument() throws Exception {\n+  public void disable_testFunctionLiteralUndefinedThisArgument()\n+      throws Exception {\n+    // TODO(johnlenz): this was a weird error.  We should add a general\n+    // restriction on what is accepted for T. Something like:\n+    // \"@template T of {Object|string}\" or some such.\n     testTypes(\"\"\n         + \"/**\\n\"\n         + \" * @param {function(this:T, ...)?} fn\\n\"\n             \" super interfaces Int0 and Int4\"});\n   }\n \n+  public void testGenerics1() throws Exception {\n+    String FN_DECL = \"/** \\n\" +\n+        \" * @param {T} x \\n\" +\n+        \" * @param {function(T):T} y \\n\" +\n+        \" * @template T\\n\" +\n+        \" */ \\n\" +\n+        \"function f(x,y) { return y(x); }\\n\";\n+\n+    testTypes(\n+        FN_DECL +\n+        \"/** @type {string} */\" +\n+        \"var out;\" +\n+        \"/** @type {string} */\" +\n+        \"var result = f('hi', function(x){ out = x; return x; });\");\n+\n+    testTypes(\n+        FN_DECL +\n+        \"/** @type {string} */\" +\n+        \"var out;\" +\n+        \"var result = f(0, function(x){ out = x; return x; });\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+\n+    testTypes(\n+        FN_DECL +\n+        \"var out;\" +\n+        \"/** @type {string} */\" +\n+        \"var result = f(0, function(x){ out = x; return x; });\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void disable_testBackwardsInferenceGoogArrayFilter1()\n+      throws Exception {\n+    // TODO(johnlenz): this doesn't fail because any Array is regarded as\n+    // a subtype of any other array regardless of the type parameter.\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"/** @type {Array.<number>} */\" +\n+        \"var result = goog.array.filter(\" +\n+        \"   arr,\" +\n+        \"   function(item,index,src) {return false;});\",\n+        \"assignment\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBackwardsInferenceGoogArrayFilter2() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {number} */\" +\n+        \"var out;\" +\n+        \"/** @type {Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"var out4 = goog.array.filter(\" +\n+        \"   arr,\" +\n+        \"   function(item,index,src) {out = item;});\",\n+        \"assignment\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBackwardsInferenceGoogArrayFilter3() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string} */\" +\n+        \"var out;\" +\n+        \"/** @type {Array.<string>} */ var arr;\\n\" +\n+        \"var result = goog.array.filter(\" +\n+        \"   arr,\" +\n+        \"   function(item,index,src) {out = index;});\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBackwardsInferenceGoogArrayFilter4() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string} */\" +\n+        \"var out;\" +\n+        \"/** @type {Array.<string>} */ var arr;\\n\" +\n+        \"var out4 = goog.array.filter(\" +\n+        \"   arr,\" +\n+        \"   function(item,index,srcArr) {out = srcArr;});\",\n+        \"assignment\\n\" +\n+        \"found   : (null|{length: number})\\n\" +\n+        \"required: string\");\n+  }\n+\n   private void testTypes(String js) throws Exception {\n     testTypes(js, (String) null);\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         registry.getType(\"goog.FooAlias\"));\n   }\n \n-  public void testTemplateType() {\n+  public void testTemplateType1() {\n     testSame(\n         \"/**\\n\" +\n         \" * @param {function(this:T, ...)} fn\\n\" +\n         \"function Foo() {}\\n\" +\n         \"/** @return {number} */\\n\" +\n         \"Foo.prototype.baz = function() {};\\n\" +\n-        \"bind(function() { var f = this.baz(); }, new Foo());\");\n+        \"bind(function() { var g = this; var f = this.baz(); }, new Foo());\");\n+    assertEquals(\"Foo\", findNameType(\"g\", lastLocalScope).toString());\n+    assertEquals(\"number\", findNameType(\"f\", lastLocalScope).toString());\n+  }\n+\n+  public void testTemplateType2() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @type {string} */\\n\" +\n+        \"var val = 'hi';\\n\" +\n+        \"var result = f(val);\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType2a() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @return {T|undefined}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @type {string} */\\n\" +\n+        \"var val = 'hi';\\n\" +\n+        \"var result = f(val);\");\n+    assertEquals(\"(string|undefined)\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType2b() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @type {string|undefined} */\\n\" +\n+        \"var val = 'hi';\\n\" +\n+        \"var result = f(val);\");\n+    assertEquals(\"(string|undefined)\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType3() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @type {string} */\\n\" +\n+        \"var val1 = 'hi';\\n\" +\n+        \"var result1 = f(val1);\" +\n+        \"/** @type {number} */\\n\" +\n+        \"var val2 = 0;\\n\" +\n+        \"var result2 = f(val2);\");\n+\n+    assertEquals(\"string\", findNameType(\"result1\", globalScope).toString());\n+    assertEquals(\"number\", findNameType(\"result2\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType4() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @type {!Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"(function () {var result = f(arr);})();\");\n+\n+    JSType resultType = findNameType(\"result\", lastLocalScope);\n+    assertEquals(\"Array.<string>\", resultType.toString());\n+  }\n+\n+  public void testTemplateType4a() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {function():T} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @return {string} */\\n\" +\n+        \"var g = function(){return 'hi'};\\n\" +\n+        \"(function () {var result = f(g);})();\");\n+\n+    JSType resultType = findNameType(\"result\", lastLocalScope);\n+    assertEquals(\"string\", resultType.toString());\n+  }\n+\n+  public void testTemplateType4b() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {function(T):void} x\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"  return x;\\n\" +\n+        \"}\" +\n+        \"/** @param {string} x */\\n\" +\n+        \"var g = function(x){};\\n\" +\n+        \"(function () {var result = f(g);})();\");\n+\n+    JSType resultType = findNameType(\"result\", lastLocalScope);\n+    assertEquals(\"string\", resultType.toString());\n+  }\n+\n+  public void testTemplateType5() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>} arr\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(arr) {\\n\" +\n+        \"  return arr;\\n\" +\n+        \"}\" +\n+        \"/** @type {Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"var result = f(arr);\");\n+\n+    assertEquals(\"Array.<string>\", findNameTypeStr(\"result\", globalScope));\n+  }\n+\n+  public void testTemplateType6() {\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>|string|undefined} arr\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function f(arr) {\\n\" +\n+        \"  return arr;\\n\" +\n+        \"}\" +\n+        \"/** @type {Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"var result = f(arr);\");\n+\n+    assertEquals(\"Array.<string>\", findNameTypeStr(\"result\", globalScope));\n+  }\n+\n+\n+  public void testTemplateType7() {\n+    testSame(\n+        \"var goog = {};\\n\" +\n+        \"goog.array = {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>} arr\\n\" +\n+        \" * @param {function(this:S, !T, number, !Array.<!T>):boolean} f\\n\" +\n+        \" * @param {!S=} opt_obj\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T,S\\n\" +\n+        \" */\\n\" +\n+        \"goog.array.filter = function(arr, f, opt_obj) {\\n\" +\n+        \"  var res = [];\\n\" +\n+        \"  for (var i = 0; i < arr.length; i++) {\\n\" +\n+        \"     if (f.call(opt_obj, arr[i], i, arr)) {\\n\" +\n+        \"        res.push(val);\\n\" +\n+        \"     }\\n\" +\n+        \"  }\\n\" +\n+        \"  return res;\\n\" +\n+        \"}\" +\n+        \"/** @constructor */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @type {Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"var result = goog.array.filter(arr,\" +\n+        \"  function(a,b,c) {var self=this;}, new Foo());\");\n+\n+    assertEquals(\"Foo\", findNameType(\"self\", lastLocalScope).toString());\n+    assertEquals(\"string\", findNameType(\"a\", lastLocalScope).toString());\n+    assertEquals(\"number\", findNameType(\"b\", lastLocalScope).toString());\n+    assertEquals(\"Array.<string>\",\n+        findNameType(\"c\", lastLocalScope).toString());\n+    assertEquals(\"Array.<string>\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType7b() {\n+    testSame(\n+        \"var goog = {};\\n\" +\n+        \"goog.array = {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>} arr\\n\" +\n+        \" * @param {function(this:S, !T, number, !Array.<T>):boolean} f\\n\" +\n+        \" * @param {!S=} opt_obj\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T,S\\n\" +\n+        \" */\\n\" +\n+        \"goog.array.filter = function(arr, f, opt_obj) {\\n\" +\n+        \"  var res = [];\\n\" +\n+        \"  for (var i = 0; i < arr.length; i++) {\\n\" +\n+        \"     if (f.call(opt_obj, arr[i], i, arr)) {\\n\" +\n+        \"        res.push(val);\\n\" +\n+        \"     }\\n\" +\n+        \"  }\\n\" +\n+        \"  return res;\\n\" +\n+        \"}\" +\n+        \"/** @constructor */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @type {Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"var result = goog.array.filter(arr,\" +\n+        \"  function(a,b,c) {var self=this;}, new Foo());\");\n+\n+    assertEquals(\"Foo\", findNameType(\"self\", lastLocalScope).toString());\n+    assertEquals(\"string\", findNameType(\"a\", lastLocalScope).toString());\n+    assertEquals(\"number\", findNameType(\"b\", lastLocalScope).toString());\n+    assertEquals(\"Array.<string>\",\n+        findNameType(\"c\", lastLocalScope).toString());\n+    assertEquals(\"Array.<string>\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testTemplateType7c() {\n+    testSame(\n+        \"var goog = {};\\n\" +\n+        \"goog.array = {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>} arr\\n\" +\n+        \" * @param {function(this:S, T, number, Array.<T>):boolean} f\\n\" +\n+        \" * @param {!S=} opt_obj\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T,S\\n\" +\n+        \" */\\n\" +\n+        \"goog.array.filter = function(arr, f, opt_obj) {\\n\" +\n+        \"  var res = [];\\n\" +\n+        \"  for (var i = 0; i < arr.length; i++) {\\n\" +\n+        \"     if (f.call(opt_obj, arr[i], i, arr)) {\\n\" +\n+        \"        res.push(val);\\n\" +\n+        \"     }\\n\" +\n+        \"  }\\n\" +\n+        \"  return res;\\n\" +\n+        \"}\" +\n+        \"/** @constructor */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @type {Array.<string>} */\\n\" +\n+        \"var arr = [];\\n\" +\n+        \"var result = goog.array.filter(arr,\" +\n+        \"  function(a,b,c) {var self=this;}, new Foo());\");\n+\n+    assertEquals(\"Foo\", findNameType(\"self\", lastLocalScope).toString());\n+    assertEquals(\"string\", findNameType(\"a\", lastLocalScope).toString());\n+    assertEquals(\"number\", findNameType(\"b\", lastLocalScope).toString());\n+    assertEquals(\"(Array.<string>|null)\",\n+        findNameType(\"c\", lastLocalScope).toString());\n+    assertEquals(\"Array.<string>\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void disable_testTemplateType8() {\n+    // TODO(johnlenz): somehow allow templated typedefs\n+    testSame(\n+        \"/** @constructor */ NodeList = function() {};\" +\n+        \"/** @constructor */ Arguments = function() {};\" +\n+        \"var goog = {};\" +\n+        \"goog.array = {};\" +\n+        \"/**\\n\" +\n+        \" * @typedef {Array.<T>|NodeList|Arguments|{length: number}}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"goog.array.ArrayLike;\" +\n+        \"/**\\n\" +\n+        \" * @param {function(this:T, ...)} fn\\n\" +\n+        \" * @param {T} thisObj\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function bind(fn, thisObj) {}\" +\n+        \"/** @constructor */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @return {number} */\\n\" +\n+        \"Foo.prototype.baz = function() {};\\n\" +\n+        \"bind(function() { var g = this; var f = this.baz(); }, new Foo());\");\n+    assertEquals(\"T\", findNameType(\"g\", lastLocalScope).toString());\n+    assertTrue(findNameType(\"g\", lastLocalScope).isEquivalentTo(\n+        registry.getType(\"Foo\")));\n     assertEquals(\"number\", findNameType(\"f\", lastLocalScope).toString());\n   }\n \n         return name.equals(n.getQualifiedName());\n       }\n     }, scope);\n+  }\n+\n+  private String findNameTypeStr(final String name, Scope scope) {\n+    return findNameType(name, scope).toString();\n   }\n \n   private JSType findTokenType(final int type, Scope scope) {", "timestamp": 1339530698, "metainfo": ""}