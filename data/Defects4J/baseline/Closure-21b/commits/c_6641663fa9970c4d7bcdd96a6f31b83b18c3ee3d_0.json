{"sha": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d", "log": "Remove unused Token ids.  R=nicksantos DELTA=1258  (4 added, 1244 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3647   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         }\n         break;\n \n-      case Token.GET_REF:\n-        add(first);\n-        break;\n-\n-      case Token.REF_SPECIAL:\n-        Preconditions.checkState(childCount == 1);\n-        add(first);\n-        add(\".\");\n-        add((String) n.getProp(Node.NAME_PROP));\n-        break;\n-\n       case Token.FUNCTION:\n         if (n.getClass() != Node.class) {\n           throw new Error(\"Unexpected Node subclass.\");\n         }\n         cc.endStatement();\n         break;\n-\n-      case Token.EXPR_VOID:\n-        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n \n       case Token.EXPR_RESULT:\n         Preconditions.checkState(childCount == 1);\n             last, getContextForNonEmptyExpression(context), true);\n         break;\n \n-      // This node is auto generated in anonymous functions and should just get\n-      // ignored for our purposes.\n-      case Token.SETNAME:\n-        break;\n-\n       default:\n         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n       switch (n.getType()) {\n         case Token.NAME:\n         case Token.GETPROP:\n-          if (NodeUtil.isGetProp(parent) ||\n-              parent.getType() == Token.REF_SPECIAL) {\n+          if (NodeUtil.isGetProp(parent)) {\n             // We will resolve this when we visit parent later in the traversal.\n             return;\n           } else if (NodeUtil.isFunction(parent)) {\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n    * Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code.\n    */\n   private void normalizeNodeTypes(Node n) {\n-    if (n.getType() == Token.EXPR_VOID) {\n-      n.setType(Token.EXPR_RESULT);\n-      reportChange();\n-    }\n-\n     // Remove unused properties to minimize differences between ASTs\n     // produced by the two parsers.\n     if (n.getType() == Token.FUNCTION) {\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n         case Token.GETELEM:\n           return Lists.newArrayList();\n \n-        case Token.GET_REF:\n-          // We ignore ref specials as their types should not be computed.\n-          if (lhs.getFirstChild().getType() == Token.REF_SPECIAL) {\n-            return Lists.newArrayList();\n-          } else {\n-            throw new AssertionError(\n-                \"Bad LHS for getref: \" + parent.toStringTree());\n-          }\n-\n         default:\n           throw new AssertionError(\n               \"Bad LHS for assignment: \" + parent.toStringTree());\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         ensureTyped(t, n, t.getScope().getTypeOfThis());\n         break;\n \n-      case Token.REF_SPECIAL:\n-        ensureTyped(t, n);\n-        break;\n-\n-      case Token.GET_REF:\n-        ensureTyped(t, n, getJSType(n.getFirstChild()));\n-        break;\n-\n       case Token.NULL:\n         ensureTyped(t, n, NULL_TYPE);\n         break;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         break;\n \n       case Token.LP:\n-      case Token.GET_REF:\n         scope = traverse(n.getFirstChild(), scope);\n         n.setJSType(getJSType(n.getFirstChild()));\n         break;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           n.setJSType(getNativeType(REGEXP_TYPE));\n           break;\n \n-        case Token.REF_SPECIAL:\n-          n.setJSType(getNativeType(UNKNOWN_TYPE));\n-          break;\n-\n         case Token.OBJECTLIT:\n           defineObjectLiteral(t, n);\n           break;\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       if (n == null) return false;\n \n       int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n+      return nType == Token.EXPR_RESULT &&\n           n.getFirstChild().getType() == Token.STRING &&\n           ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n         return Token.TYPEOF;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n         return Token.GETPROP;\n-      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n-        return Token.SETPROP;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n         return Token.GETELEM;\n-      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n-        return Token.SETELEM;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n         return Token.CALL;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       case Token.ERROR:           return \"error\";\n       case Token.EOF:             return \"eof\";\n       case Token.EOL:             return \"eol\";\n-      case Token.ENTERWITH:       return \"enterwith\";\n-      case Token.LEAVEWITH:       return \"leavewith\";\n       case Token.RETURN:          return \"return\";\n-      case Token.GOTO:            return \"goto\";\n-      case Token.IFEQ:            return \"ifeq\";\n-      case Token.IFNE:            return \"ifne\";\n-      case Token.SETNAME:         return \"setname\";\n       case Token.BITOR:           return \"bitor\";\n       case Token.BITXOR:          return \"bitxor\";\n       case Token.BITAND:          return \"bitand\";\n       case Token.DELPROP:         return \"delprop\";\n       case Token.TYPEOF:          return \"typeof\";\n       case Token.GETPROP:         return \"getprop\";\n-      case Token.SETPROP:         return \"setprop\";\n       case Token.GETELEM:         return \"getelem\";\n-      case Token.SETELEM:         return \"setelem\";\n       case Token.CALL:            return \"call\";\n       case Token.NAME:            return \"name\";\n       case Token.NUMBER:          return \"number\";\n       case Token.SHNE:            return \"shne\";\n       case Token.REGEXP:          return \"regexp\";\n       case Token.POS:             return \"pos\";\n-      case Token.BINDNAME:        return \"bindname\";\n       case Token.THROW:           return \"throw\";\n       case Token.IN:              return \"in\";\n       case Token.INSTANCEOF:      return \"instanceof\";\n-      case Token.GETVAR:          return \"getvar\";\n-      case Token.SETVAR:          return \"setvar\";\n       case Token.TRY:             return \"try\";\n-      case Token.TYPEOFNAME:      return \"typeofname\";\n-      case Token.THISFN:          return \"thisfn\";\n-      case Token.SEMI:            return \"semi\";\n-      case Token.LB:              return \"lb\";\n-      case Token.RB:              return \"rb\";\n-      case Token.LC:              return \"lc\";\n-      case Token.RC:              return \"rc\";\n       case Token.LP:              return \"lp\";\n-      case Token.RP:              return \"rp\";\n       case Token.COMMA:           return \"comma\";\n       case Token.ASSIGN:          return \"assign\";\n       case Token.ASSIGN_BITOR:    return \"assign_bitor\";\n       case Token.DEC:             return \"dec\";\n       case Token.DOT:             return \"dot\";\n       case Token.FUNCTION:        return \"function\";\n-      case Token.EXPORT:          return \"export\";\n-      case Token.IMPORT:          return \"import\";\n       case Token.IF:              return \"if\";\n       case Token.ELSE:            return \"else\";\n       case Token.SWITCH:          return \"switch\";\n       case Token.ARRAYLIT:        return \"arraylit\";\n       case Token.OBJECTLIT:       return \"objectlit\";\n       case Token.LABEL:           return \"label\";\n-      case Token.TARGET:          return \"target\";\n-      case Token.LOOP:            return \"loop\";\n-      case Token.EXPR_VOID:       return \"expr_void\";\n       case Token.EXPR_RESULT:     return \"expr_result\";\n-      case Token.JSR:             return \"jsr\";\n       case Token.SCRIPT:          return \"script\";\n       case Token.EMPTY:           return \"empty\";\n-      case Token.GET_REF:         return \"get_ref\";\n-      case Token.REF_SPECIAL:     return \"ref_special\";\n     }\n     return \"<unknown=\"+token+\">\";\n   }\n \n   public boolean hasSideEffects() {\n     switch (type) {\n-      case Token.EXPR_VOID:\n       case Token.COMMA:\n         if (last != null)\n           return last.hasSideEffects();\n       case Token.ASSIGN_LSH:\n       case Token.ASSIGN_RSH:\n       case Token.ASSIGN_URSH:\n-      case Token.ENTERWITH:\n-      case Token.LEAVEWITH:\n       case Token.RETURN:\n-      case Token.GOTO:\n-      case Token.IFEQ:\n-      case Token.IFNE:\n       case Token.NEW:\n       case Token.DELPROP:\n-      case Token.SETNAME:\n-      case Token.SETPROP:\n-      case Token.SETELEM:\n       case Token.CALL:\n       case Token.THROW:\n-      case Token.RETHROW:\n-      case Token.SETVAR:\n-      case Token.CATCH_SCOPE:\n-      case Token.RETURN_RESULT:\n-      case Token.SET_REF:\n-      case Token.DEL_REF:\n-      case Token.REF_CALL:\n       case Token.TRY:\n-      case Token.SEMI:\n       case Token.INC:\n       case Token.DEC:\n-      case Token.EXPORT:\n-      case Token.IMPORT:\n       case Token.IF:\n       case Token.ELSE:\n       case Token.SWITCH:\n       case Token.FINALLY:\n       case Token.BLOCK:\n       case Token.LABEL:\n-      case Token.TARGET:\n-      case Token.LOOP:\n-      case Token.JSR:\n-      case Token.SETPROP_OP:\n-      case Token.SETELEM_OP:\n-      case Token.LOCAL_BLOCK:\n-      case Token.SET_REF_OP:\n         return true;\n \n       default:\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n  * It is based on the C source files jsscan.c and jsscan.h\n  * in the jsref package.\n  *\n- * @see com.google.javascript.rhino.Parser\n- *\n  */\n \n public class Token\n         EOF            = 0,  // end of file token - (not EOF_CHAR)\n         EOL            = 1,  // end of line\n \n-        // Interpreter reuses the following as bytecodes\n-        FIRST_BYTECODE_TOKEN    = 2,\n-\n-        ENTERWITH      = 2,\n-        LEAVEWITH      = 3,\n         RETURN         = 4,\n-        GOTO           = 5,\n-        IFEQ           = 6,\n-        IFNE           = 7,\n-        SETNAME        = 8,\n         BITOR          = 9,\n         BITXOR         = 10,\n         BITAND         = 11,\n         DELPROP        = 31,\n         TYPEOF         = 32,\n         GETPROP        = 33,\n-        SETPROP        = 34,\n         GETELEM        = 35,\n-        SETELEM        = 36,\n         CALL           = 37,\n         NAME           = 38,\n         NUMBER         = 39,\n         SHEQ           = 45,   // shallow equality (===)\n         SHNE           = 46,   // shallow inequality (!==)\n         REGEXP         = 47,\n-        BINDNAME       = 48,\n         THROW          = 49,\n-        RETHROW        = 50, // rethrow caught execetion: catch (e if ) use it\n         IN             = 51,\n         INSTANCEOF     = 52,\n-        LOCAL_LOAD     = 53,\n-        GETVAR         = 54,\n-        SETVAR         = 55,\n-        CATCH_SCOPE    = 56,\n-        ENUM_INIT_KEYS = 57,\n-        ENUM_INIT_VALUES = 58,\n-        ENUM_NEXT      = 59,\n-        ENUM_ID        = 60,\n-        THISFN         = 61,\n-        RETURN_RESULT  = 62, // to return prevoisly stored return result\n         ARRAYLIT       = 63, // array literal\n         OBJECTLIT      = 64, // object literal\n-        GET_REF        = 65, // *reference\n-        SET_REF        = 66, // *reference    = something\n-        DEL_REF        = 67, // delete reference\n-        REF_CALL       = 68, // f(args)    = something or f(args)++\n-        REF_SPECIAL    = 69, // reference for special properties like __proto\n-\n-        // For XML support:\n-        DEFAULTNAMESPACE = 70, // default xml namespace =\n-        ESCXMLATTR     = 71,\n-        ESCXMLTEXT     = 72,\n-        REF_MEMBER     = 73, // Reference for x.@y, x..y etc.\n-        REF_NS_MEMBER  = 74, // Reference for x.ns::y, x..ns::y etc.\n-        REF_NAME       = 75, // Reference for @y, @[y] etc.\n-        REF_NS_NAME    = 76; // Reference for ns::y, @ns::y@[y] etc.\n-\n-        // End of interpreter bytecodes\n-    public final static int\n-        LAST_BYTECODE_TOKEN    = REF_NS_NAME,\n \n         TRY            = 77,\n-        SEMI           = 78,  // semicolon\n-        LB             = 79,  // left and right brackets\n-        RB             = 80,\n-        LC             = 81,  // left and right curlies (braces)\n-        RC             = 82,\n         LP             = 83,  // left and right parentheses\n-        RP             = 84,\n         COMMA          = 85,  // comma operator\n \n         ASSIGN         = 86,  // simple assignment  (=)\n         ASSIGN_SUB     = 94,  // -=\n         ASSIGN_MUL     = 95,  // *=\n         ASSIGN_DIV     = 96,  // /=\n-        ASSIGN_MOD     = 97;  // %=\n-\n-    public final static int\n+        ASSIGN_MOD     = 97,  // %=\n+\n         FIRST_ASSIGN   = ASSIGN,\n         LAST_ASSIGN    = ASSIGN_MOD,\n \n         DEC            = 103,\n         DOT            = 104, // member operator (.)\n         FUNCTION       = 105, // function keyword\n-        EXPORT         = 106, // export keyword\n-        IMPORT         = 107, // import keyword\n         IF             = 108, // if keyword\n         ELSE           = 109, // else keyword\n         SWITCH         = 110, // switch keyword\n \n         EMPTY          = 124,\n \n-        /* types used for the parse tree - these never get returned\n-         * by the scanner.\n-         */\n-\n         BLOCK          = 125, // statement block\n         LABEL          = 126, // label\n-        TARGET         = 127,\n-        LOOP           = 128,\n-        EXPR_VOID      = 129, // expression statement in functions\n         EXPR_RESULT    = 130, // expression statement in scripts\n-        JSR            = 131,\n         SCRIPT         = 132, // top-level node for entire script\n-        TYPEOFNAME     = 133, // for typeof(simple-name)\n-        USE_STACK      = 134,\n-        SETPROP_OP     = 135, // x.y op= something\n-        SETELEM_OP     = 136, // x[y] op= something\n-        LOCAL_BLOCK    = 137,\n-        SET_REF_OP     = 138, // *reference op= something\n-\n-        // For XML support:\n-        DOTDOT         = 139,  // member operator (..)\n-        COLONCOLON     = 140,  // namespace::name\n-        XML            = 141,  // XML type\n-        DOTQUERY       = 142,  // .() -- e.g., x.emps.emp.(name == \"terry\")\n-        XMLATTR        = 143,  // @\n-        XMLEND         = 144,\n-\n-        // Optimizer-only-tokens\n-        TO_OBJECT      = 145,\n-        TO_DOUBLE      = 146,\n \n         GET            = 147,  // JS 1.5 get pseudo keyword\n         SET            = 148,  // JS 1.5 set pseudo keyword\n \n         CONST          = 149,  // JS 1.5 const keyword\n-        SETCONST       = 150,\n-        SETCONSTVAR    = 151,\n         DEBUGGER       = 152,\n \n         // JSCompiler introduced tokens\n         QMARK          = 304,\n         ELLIPSIS       = 305,\n         BANG           = 306,\n-        EQUALS         = 307;\n+        EQUALS         = 307,\n+        LB             = 308,  // left brackets\n+        LC             = 309;  // left curly braces\n \n   public static String name(int token)\n     {\n         }\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n-          case EOF:             return \"EOF\";\n-          case EOL:             return \"EOL\";\n-          case ENTERWITH:       return \"ENTERWITH\";\n-          case LEAVEWITH:       return \"LEAVEWITH\";\n           case RETURN:          return \"RETURN\";\n-          case GOTO:            return \"GOTO\";\n-          case IFEQ:            return \"IFEQ\";\n-          case IFNE:            return \"IFNE\";\n-          case SETNAME:         return \"SETNAME\";\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n           case DELPROP:         return \"DELPROP\";\n           case TYPEOF:          return \"TYPEOF\";\n           case GETPROP:         return \"GETPROP\";\n-          case SETPROP:         return \"SETPROP\";\n           case GETELEM:         return \"GETELEM\";\n-          case SETELEM:         return \"SETELEM\";\n           case CALL:            return \"CALL\";\n           case NAME:            return \"NAME\";\n           case LABEL_NAME:      return \"LABEL_NAME\";\n           case SHEQ:            return \"SHEQ\";\n           case SHNE:            return \"SHNE\";\n           case REGEXP:          return \"REGEXP\";\n-          case BINDNAME:        return \"BINDNAME\";\n           case THROW:           return \"THROW\";\n-          case RETHROW:         return \"RETHROW\";\n           case IN:              return \"IN\";\n           case INSTANCEOF:      return \"INSTANCEOF\";\n-          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n-          case GETVAR:          return \"GETVAR\";\n-          case SETVAR:          return \"SETVAR\";\n-          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n-          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n-          case ENUM_INIT_VALUES:  return \"ENUM_INIT_VALUES\";\n-          case ENUM_NEXT:       return \"ENUM_NEXT\";\n-          case ENUM_ID:         return \"ENUM_ID\";\n-          case THISFN:          return \"THISFN\";\n-          case RETURN_RESULT:   return \"RETURN_RESULT\";\n           case ARRAYLIT:        return \"ARRAYLIT\";\n           case OBJECTLIT:       return \"OBJECTLIT\";\n-          case GET_REF:         return \"GET_REF\";\n-          case SET_REF:         return \"SET_REF\";\n-          case DEL_REF:         return \"DEL_REF\";\n-          case REF_CALL:        return \"REF_CALL\";\n-          case REF_SPECIAL:     return \"REF_SPECIAL\";\n-          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n-          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n-          case ESCXMLATTR:      return \"ESCXMLATTR\";\n-          case REF_MEMBER:      return \"REF_MEMBER\";\n-          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n-          case REF_NAME:        return \"REF_NAME\";\n-          case REF_NS_NAME:     return \"REF_NS_NAME\";\n           case TRY:             return \"TRY\";\n-          case SEMI:            return \"SEMI\";\n-          case LB:              return \"LB\";\n-          case RB:              return \"RB\";\n-          case LC:              return \"LC\";\n-          case RC:              return \"RC\";\n           case LP:              return \"LP\";\n-          case RP:              return \"RP\";\n           case COMMA:           return \"COMMA\";\n           case ASSIGN:          return \"ASSIGN\";\n           case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n           case DEC:             return \"DEC\";\n           case DOT:             return \"DOT\";\n           case FUNCTION:        return \"FUNCTION\";\n-          case EXPORT:          return \"EXPORT\";\n-          case IMPORT:          return \"IMPORT\";\n           case IF:              return \"IF\";\n           case ELSE:            return \"ELSE\";\n           case SWITCH:          return \"SWITCH\";\n           case WITH:            return \"WITH\";\n           case CATCH:           return \"CATCH\";\n           case FINALLY:         return \"FINALLY\";\n-          case RESERVED:        return \"RESERVED\";\n           case EMPTY:           return \"EMPTY\";\n           case BLOCK:           return \"BLOCK\";\n           case LABEL:           return \"LABEL\";\n-          case TARGET:          return \"TARGET\";\n-          case LOOP:            return \"LOOP\";\n-          case EXPR_VOID:       return \"EXPR_VOID\";\n           case EXPR_RESULT:     return \"EXPR_RESULT\";\n-          case JSR:             return \"JSR\";\n           case SCRIPT:          return \"SCRIPT\";\n-          case TYPEOFNAME:      return \"TYPEOFNAME\";\n-          case USE_STACK:       return \"USE_STACK\";\n-          case SETPROP_OP:      return \"SETPROP_OP\";\n-          case SETELEM_OP:      return \"SETELEM_OP\";\n-          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n-          case SET_REF_OP:      return \"SET_REF_OP\";\n-          case DOTDOT:          return \"DOTDOT\";\n-          case COLONCOLON:      return \"COLONCOLON\";\n-          case XML:             return \"XML\";\n-          case DOTQUERY:        return \"DOTQUERY\";\n-          case XMLATTR:         return \"XMLATTR\";\n-          case XMLEND:          return \"XMLEND\";\n-          case TO_OBJECT:       return \"TO_OBJECT\";\n-          case TO_DOUBLE:       return \"TO_DOUBLE\";\n           case GET:             return \"GET\";\n           case SET:             return \"SET\";\n           case CONST:           return \"CONST\";\n-          case SETCONST:        return \"SETCONST\";\n           case DEBUGGER:        return \"DEBUGGER\";\n           case ANNOTATION:      return \"ANNOTATION\";\n           case PIPE:            return \"PIPE\";\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n             Id_delete        = Token.DELPROP,\n             Id_do            = Token.DO,\n             Id_else          = Token.ELSE,\n-            Id_export        = Token.EXPORT,\n             Id_false         = Token.FALSE,\n             Id_for           = Token.FOR,\n             Id_function      = Token.FUNCTION,\n             Id_debugger      = Token.DEBUGGER,\n             Id_double        = Token.RESERVED,\n             Id_enum          = Token.RESERVED,\n+            Id_export        = Token.RESERVED,\n             Id_extends       = Token.RESERVED,\n             Id_final         = Token.RESERVED,\n             Id_finally       = Token.FINALLY,\n             Id_float         = Token.RESERVED,\n             Id_goto          = Token.RESERVED,\n             Id_implements    = Token.RESERVED,\n-            Id_import        = Token.IMPORT,\n+            Id_import        = Token.RESERVED,\n             Id_instanceof    = Token.INSTANCEOF,\n             Id_int           = Token.RESERVED,\n             Id_interface     = Token.RESERVED,\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     otherPass = new CompilerPass() {\n       @Override public void process(Node externs, Node root) {\n         getLastCompiler().reportCodeChange();\n-        root.addChildToBack(new Node(Token.EXPR_VOID, Node.newNumber(0)));\n+        root.getFirstChild().addChildToBack(\n+              new Node(Token.IF, new Node(Token.TRUE), new Node(Token.EMPTY)));\n       }\n     };\n \n     try {\n       test(\"var x = 3;\", \"var x=3;0;0\");\n     } catch (IllegalStateException e) {\n-      assertEquals(\"Expected script but was expr_void Reference node EXPR_VOID\",\n+      assertEquals(\"Expected block but was empty Reference node EMPTY\",\n           e.getMessage());\n       exceptionCaught = true;\n     }", "timestamp": 1320704506, "metainfo": ""}