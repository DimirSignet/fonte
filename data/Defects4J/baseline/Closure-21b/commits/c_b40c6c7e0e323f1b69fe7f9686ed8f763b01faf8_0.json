{"sha": "b40c6c7e0e323f1b69fe7f9686ed8f763b01faf8", "log": "Don't inline a method containing \"eval\" as V8 won't optimize the containing method.  R=nicksantos DELTA=35  (13 added, 0 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=923   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.common.base.Supplier;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n    * inlining.\n    */\n   boolean doesFunctionMeetMinimumRequirements(\n-      String fnName, Node fnNode) {\n+      final String fnName, Node fnNode) {\n     Node block = NodeUtil.getFunctionBody(fnNode);\n \n-    // Don't inline recursive functions, nor functions that contain\n-    // 'this', 'arguments' references.\n-    if (NodeUtil.isNameReferenced(block, fnName)) {\n-      return false;\n-    }\n-\n-    String fnRecursionName = fnNode.getFirstChild().getString();\n-    if (fnRecursionName != null\n-        && !fnRecursionName.isEmpty()\n-        && !fnRecursionName.equals(fnName)\n-        && NodeUtil.isNameReferenced(block, fnRecursionName)) {\n-      return false;\n-    }\n-\n-    // nor functions that contain 'arguments' references.\n-    if (NodeUtil.isNameReferenced(block, \"arguments\")) {\n-      return false;\n-    }\n-\n-    return true;\n+    // Basic restrictions on functions that can be inlined:\n+    // 1) It contains a reference to itself.\n+    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n+    //    handled yet.\n+    // 3) It references \"eval\". Inline a function containing eval can have\n+    //    large performance implications.\n+\n+    final String fnRecursionName = fnNode.getFirstChild().getString();\n+    Preconditions.checkState(fnRecursionName != null);\n+\n+    Predicate<Node> p = new Predicate<Node>(){\n+      public boolean apply(Node n) {\n+        if (n.getType() == Token.NAME) {\n+          return n.getString().equals(\"arguments\")\n+            || n.getString().equals(\"eval\")\n+            || n.getString().equals(fnName)\n+            || (!fnRecursionName.isEmpty()\n+                && n.getString().equals(fnRecursionName));\n+        }\n+        return false;\n+      }\n+    };\n+\n+    return !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n         \"  b: JSCompiler_temp_const$$0,\" +\n         \"  c: JSCompiler_inline_result$$2\" +\n         \"};\");\n+  }\n+\n+  public void testInlineFunctions30() {\n+    // As simple a test as we can get.\n+    testSame(\"function foo(){ return eval() }\" +\n+        \"foo();\");\n   }\n \n   public void testMixedModeInlining1() {\n     test(\"function f(){a=1;return 1} var x = 1; x += f()\",\n         \"var x = 1;\" +\n         \"var JSCompiler_temp_const$$0 = x;\" +\n-        \"{var JSCompiler_inline_result$$1; a=1; JSCompiler_inline_result$$1=1}\" +\n+        \"{var JSCompiler_inline_result$$1; a=1;\" +\n+        \" JSCompiler_inline_result$$1=1}\" +\n         \"x = JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1;\");\n   }\n ", "timestamp": 1300384654, "metainfo": ""}