{"sha": "80fe41fd0173c3eaa56f4abb783031966ea89cef", "log": "Change on 2010/04/09 by john          Part II: Use global RegExp reference information to optimize references when possible.          R=alan         DELTA=231  (173 added, 17 deleted, 41 changed)  Change on 2010/04/09 by nicksantos          Make JsFileLineParser much more efficient for large files         (we were running into problems with it running out of memory.)          R=andrew         DELTA=192  (157 added, 1 deleted, 34 changed)  Change on 2010/04/09 by alan          Fix typed code gen crash when generating typed code.          R=nicksantos         DELTA=35  (24 added, 2 deleted, 9 changed)  Change on 2010/04/09 by alan          Disable method motion on functions that reads closure variables.          R=nicksantos         DELTA=171  (162 added, 1 deleted, 8 changed)  Change on 2010/04/12 by nada          In AmbiguateProperties, invert the related type relationship, by         considering subclasses and implementors (down) instead of superclasses         and implemented interfaces (up). This has two advantages:          - The 'independent of' relationship is simplified, because we only           need to consider whether the related types intersect.          - We can account for 'multiple inheritance', which is a practical           issue because of interfaces.          Note that the 'up' relationship allows us to easily find common         ancestors while the 'down' relationship allows us to easily find         common descendants -- and this is what we care about for ambiguation.           R=moedinger         DELTA=173  (124 added, 15 deleted, 34 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=mwgnge   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n   /** Map from original property name to new name. */\n   private final Map<String, String> renamingMap = Maps.newHashMap();\n \n-  /** Map from color assigned by GraphColoring to new name. */\n-  private final Map<Integer, String> colorMap = Maps.newHashMap();\n-\n   /**\n    * Sorts Property objects by their count, breaking ties alphabetically to\n    * ensure a deterministic total ordering.\n \n     NameGenerator nameGen = new NameGenerator(\n         reservedNames, \"\", reservedCharacters);\n+    Map<Integer, String> colorMap = Maps.newHashMap();\n     for (int i = 0; i < numNewPropertyNames; ++i) {\n       colorMap.put(i, nameGen.generateNextName());\n     }\n     }\n   }\n \n-  /** Add supertypes of the type to its JSTypeBitSet of related types. */\n+  /**\n+   * Adds subtypes - and implementors, in the case of interfaces - of the type\n+   * to its JSTypeBitSet of related types. Union types are decomposed into their\n+   * alternative types.\n+   *\n+   * <p>The 'is related to' relationship is best understood graphically. Draw an\n+   * arrow from each instance type to the prototype of each of its\n+   * subclass. Draw an arrow from each prototype to its instance type. Draw an\n+   * arrow from each interface to its implementors. A type is related to another\n+   * if there is a directed path in the graph from the type to other. Thus, the\n+   * 'is related to' relationship is reflexive and transitive.\n+   *\n+   * <p>Example with Foo extends Bar which extends Baz and Bar implements I:\n+   * <pre>\n+   * Foo -> Bar.prototype -> Bar -> Baz.prototype -> Baz\n+   *                          ^\n+   *                          |\n+   *                          I\n+   * </pre>\n+   *\n+   * <p>Note that we don't need to correctly handle the relationships between\n+   * functions, because the function type is invalidating (i.e. its properties\n+   * won't be ambiguated).\n+   */\n   private void computeRelatedTypes(JSType type) {\n     if (type instanceof UnionType) {\n       type = type.restrictByNotNullOrUndefined();\n \n     JSTypeBitSet related = new JSTypeBitSet(intForType.size());\n     relatedBitsets.put(type, related);\n-\n-    ObjectType parentType = type.toObjectType();\n-    while (parentType != null) {\n-      related.set(getIntForType(parentType));\n-      parentType = parentType.getImplicitPrototype();\n-    }\n-\n-    FunctionType constructor = null;\n-    if (type instanceof FunctionType) {\n-      constructor = (FunctionType) type;\n-    } else if (type instanceof FunctionPrototypeType) {\n-      constructor = ((FunctionPrototypeType) type).getOwnerFunction();\n-    } else {\n-      constructor = type.toObjectType().getConstructor();\n-    }\n-    if (constructor != null) {\n-      for (ObjectType itype : constructor.getAllImplementedInterfaces()) {\n-        related.set(getIntForType(itype));\n-      }\n+    related.set(getIntForType(type));\n+\n+    // A prototype is related to its instance.\n+    if (type instanceof FunctionPrototypeType) {\n+      addRelatedInstance(\n+          ((FunctionPrototypeType) type).getOwnerFunction(), related);\n+      return;\n+    }\n+\n+    // An instance is related to its subclasses.\n+    FunctionType constructor = type.toObjectType().getConstructor();\n+    if (constructor != null && constructor.getSubTypes() != null) {\n+      for (FunctionType subType : constructor.getSubTypes()) {\n+        addRelatedInstance(subType, related);\n+      }\n+    }\n+\n+    // An interface is related to its implementors.\n+    for (FunctionType implementor : compiler.getTypeRegistry()\n+        .getDirectImplementors(type.toObjectType())) {\n+      addRelatedInstance(implementor, related);\n+    }\n+  }\n+\n+  /**\n+   * Adds the instance of the given constructor, its implicit prototype and all\n+   * its related types to the given bit set.\n+   */\n+  private void addRelatedInstance(\n+      FunctionType constructor, JSTypeBitSet related) {\n+    // TODO(user): A constructor which doesn't have an instance type\n+    // (e.g. it's missing the @constructor annotation) should be an invalidating\n+    // type which doesn't reach this code path.\n+    if (constructor.hasInstanceType()) {\n+      ObjectType instanceType = constructor.getInstanceType();\n+      related.set(getIntForType(instanceType.getImplicitPrototype()));\n+      computeRelatedTypes(instanceType);\n+      related.or(relatedBitsets.get(instanceType));\n     }\n   }\n \n   }\n \n   /**\n-   * A {@link SubGraph} that represents properties. The types of the properties\n-   * are used to efficiently calculate adjacency information.\n+   * A {@link SubGraph} that represents properties. The related types of\n+   * the properties are used to efficiently calculate adjacency information.\n    */\n   class PropertySubGraph implements SubGraph<Property, Void> {\n-    /** Types from which properties in this subgraph are referenced. */\n-    JSTypeBitSet typesInSet = new JSTypeBitSet(intForType.size());\n-\n-    /** Types related to types in {@code typesInSet}. */\n-    JSTypeBitSet typesRelatedToSet = new JSTypeBitSet(intForType.size());\n+    /** Types related to properties referenced in this subgraph. */\n+    JSTypeBitSet relatedTypes = new JSTypeBitSet(intForType.size());\n \n     /**\n-     * Returns true if prop is in an independent set from all properties in\n-     * this sub graph.  That is, if none of its types is contained in the\n-     * related types for this sub graph and if none if its related types is one\n-     * of the types in the sub graph.\n+     * Returns true if prop is in an independent set from all properties in this\n+     * sub graph.  That is, if none of its related types intersects with the\n+     * related types for this sub graph.\n      */\n     public boolean isIndependentOf(Property prop) {\n-      if (typesRelatedToSet.intersects(prop.typesSet)) {\n-        return false;\n-      }\n-      return !prop.relatedTypesSet.intersects(typesInSet);\n+      return !relatedTypes.intersects(prop.relatedTypes);\n     }\n \n     /**\n-     * Adds the node to the sub graph, adding all of its types to the set of\n-     * types in the sub graph and all of its related types to the related types\n-     * for the sub graph.\n+     * Adds the node to the sub graph, adding all its related types to the\n+     * related types for the sub graph.\n      */\n     public void addNode(Property prop) {\n-      typesInSet.or(prop.typesSet);\n-      typesRelatedToSet.or(prop.relatedTypesSet);\n+      relatedTypes.or(prop.relatedTypes);\n     }\n   }\n \n     String newName;\n     int numOccurrences;\n     boolean skipAmbiguating;\n-    JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size());\n-    JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size());\n+    JSTypeBitSet relatedTypes = new JSTypeBitSet(intForType.size());\n \n     Property(String name) {\n       this.oldName = name;\n         return;\n       }\n \n-      int typeInt = getIntForType(newType);\n-      if (!typesSet.get(typeInt)) {\n+      if (!relatedTypes.get(getIntForType(newType))) {\n         computeRelatedTypes(newType);\n-        typesSet.set(typeInt);\n-        relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));\n+        relatedTypes.or(getRelatedTypesOnNonUnion(newType));\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n       } else if (n.getType() == Token.NAME) {\n         String name = n.getString();\n \n-        // Only process global functions.\n         Var var = t.getScope().getVar(name);\n-        if (var != null && var.isGlobal() &&\n-            var.getInitialValue() != null &&\n-            var.getInitialValue().getType() == Token.FUNCTION) {\n-          if (t.inGlobalScope()) {\n-            if (!processGlobalFunctionDeclaration(t, n, parent,\n-                    parent.getParent())) {\n-              addGlobalUseOfSymbol(name, t.getModule(), VAR);\n+        if (var != null) {\n+          // Only process global functions.\n+          if (var.isGlobal()) {\n+            if (var.getInitialValue() != null &&\n+                var.getInitialValue().getType() == Token.FUNCTION) {\n+              if (t.inGlobalScope()) {\n+                if (!processGlobalFunctionDeclaration(t, n, parent,\n+                        parent.getParent())) {\n+                  addGlobalUseOfSymbol(name, t.getModule(), VAR);\n+                }\n+              } else {\n+                addSymbolUse(name, t.getModule(), VAR);\n+              }\n             }\n+\n+          // If it is not a global, it might be accessing a local of the outer\n+          // scope. If that's the case the functions between the variable's\n+          // declaring scope and the variable reference scope cannot be moved.\n           } else {\n-            addSymbolUse(name, t.getModule(), VAR);\n+            int level = 0;\n+            for (Scope s = t.getScope(); s != var.getScope();\n+                s = s.getParent()) {\n+              level++;\n+            }\n+            for (level = symbolStack.size() < level ?\n+                symbolStack.size() : level; level != 0; level--) {\n+              symbolStack.get(symbolStack.size() - level)\n+                  .readClosureVariables = true;\n+            }\n           }\n         }\n       }\n     private final Deque<Symbol> declarations = new ArrayDeque<Symbol>();\n     private JSModule deepestCommonModuleRef = null;\n \n+    // True if this property is a function that reads a variable from an\n+    // outer scope which isn't the global scope.\n+    private boolean readClosureVariables = false;\n+\n     /**\n      * Constructs a new NameInfo.\n      * @param name The name of the property that this represents. May be null\n     /** Determines whether we've marked a reference to this property name. */\n     boolean isReferenced() {\n       return referenced;\n+    }\n+\n+    /** Determines whether it reads a closure variable. */\n+    boolean readsClosureVariables() {\n+      return readClosureVariables;\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n       }\n     }\n     if (NodeUtil.isSimpleOperatorType(n.getType()) ||\n-        !NodeUtil.mayHaveSideEffects(n)) {\n+        !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n       if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n         // This no-op statement was there so that JSDoc information could\n         // be attached to the name. This check should not complain about it.\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         // The code below can't do anything with unreferenced name\n         // infos.  They should be skipped to avoid NPE since their\n         // deepestCommonModuleRef is null.\n+        continue;\n+      }\n+      \n+      if (nameInfo.readsClosureVariables()) {\n         continue;\n       }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Rusn type inference. */\n-  private final PassFactory inferTypes =\n+  final PassFactory inferTypes =\n       new PassFactory(\"inferTypes\", false) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.FunctionNode;\n import com.google.javascript.rhino.JSDocInfo;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * NodeUtil contains utilities that get properties from the Node object.\n    * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n    */\n   static boolean mayEffectMutableState(Node n) {\n-    return checkForStateChangeHelper(n, true);\n+    return mayEffectMutableState(n, null);\n+  }\n+\n+  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n+    return checkForStateChangeHelper(n, true, compiler);\n   }\n \n   /**\n    * Returns true if the node which may have side effects when executed.\n    */\n   static boolean mayHaveSideEffects(Node n) {\n-    return checkForStateChangeHelper(n, false);\n+    return mayHaveSideEffects(n, null);\n+  }\n+\n+  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n+    return checkForStateChangeHelper(n, false, compiler);\n   }\n \n   /**\n    * that they have no side effects.\n    */\n   private static boolean checkForStateChangeHelper(\n-      Node n, boolean checkForNewObjects) {\n+      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     // Rather than id which ops may have side effects, id the ones\n     // that we know to be safe\n     switch (n.getType()) {\n         return !isFunctionAnonymous(n);\n \n       case Token.NEW:\n-        {\n-          if (checkForNewObjects) {\n-            return true;\n-          }\n-\n-          // calls to constructors that have no side effects have the\n-          // no side effect property set.\n-          if (n.isNoSideEffectsCall()) {\n-            break;\n-          }\n-\n-          // certain constructors are certified side effect free\n-          Node constructor = n.getFirstChild();\n-          if (Token.NAME == constructor.getType()) {\n-            String className = constructor.getString();\n-            if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n-              // loop below will see if the constructor parameters have\n-              // side-effects\n-              break;\n-            }\n-          } else {\n-            // the constructor could also be an expression like\n-            // new (useArray ? Object : Array)();\n-          }\n+        if (checkForNewObjects) {\n+          return true;\n+        }\n+\n+        if (!constructorCallHasSideEffects(n)) {\n+          // loop below will see if the constructor parameters have\n+          // side-effects\n+          break;\n         }\n         return true;\n \n       case Token.CALL:\n         // calls to functions that have no side effects have the no\n         // side effect property set.\n-        if (n.isNoSideEffectsCall()) {\n+        if (!functionCallHasSideEffects(n, compiler)) {\n           // loop below will see if the function parameters have\n           // side-effects\n           break;\n           // b) The LHS has side effects, or\n           // c) A name on the LHS will exist beyond the life of this statement.\n           if (checkForStateChangeHelper(\n-                  n.getFirstChild(), checkForNewObjects) ||\n+                  n.getFirstChild(), checkForNewObjects, compiler) ||\n               checkForStateChangeHelper(\n-                  n.getLastChild(), checkForNewObjects)) {\n+                  n.getLastChild(), checkForNewObjects, compiler)) {\n             return true;\n           }\n \n     }\n \n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (checkForStateChangeHelper(c, checkForNewObjects)) {\n+      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n         return true;\n       }\n     }\n     return true;\n   }\n \n+  private static final Set<String> REGEXP_METHODS =\n+      ImmutableSet.of(\"test\", \"exec\");\n+  private static final Set<String> STRING_REGEXP_METHODS =\n+      ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\");\n+\n   /**\n    * Returns true if calls to this function have side effects.\n    *\n    * @param callNode - function call node\n    */\n-  static boolean functionCallHasSideEffects(Node callNode) {\n+  static boolean functionCallHasSideEffects(\n+      Node callNode) {\n+    return functionCallHasSideEffects(callNode, null);\n+  }\n+\n+  /**\n+   * Returns true if calls to this function have side effects.\n+   *\n+   * @param callNode The call node to inspected.\n+   * @param compiler A compiler object to provide program state changing\n+   *     context information. Can be null.\n+   */\n+  static boolean functionCallHasSideEffects(\n+      Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(\n         callNode.getType() == Token.CALL,\n         \"Expected CALL node, got \" + Token.name(callNode.getType()));\n       if (name.equals(\"String\")) {\n         return false;\n       }\n-    }\n-\n-    // Functions in the \"Math\" namespace have no side effects.\n-    if (nameNode.getType() == Token.GETPROP &&\n-        nameNode.getFirstChild().getType() == Token.NAME) {\n-      String namespaceName = nameNode.getFirstChild().getString();\n-      if (namespaceName.equals(\"Math\")) {\n-        return false;\n+    } else if (nameNode.getType() == Token.GETPROP) {\n+      // Functions in the \"Math\" namespace have no side effects.\n+      if (nameNode.getFirstChild().getType() == Token.NAME) {\n+        String namespaceName = nameNode.getFirstChild().getString();\n+        if (namespaceName.equals(\"Math\")) {\n+          return false;\n+        }\n+      }\n+\n+      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n+        if (nameNode.getFirstChild().getType() == Token.REGEXP\n+            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+          return false;\n+        } else if (nameNode.getFirstChild().getType() == Token.STRING\n+            && STRING_REGEXP_METHODS.contains(\n+                nameNode.getLastChild().getString())) {\n+          Node param = nameNode.getNext();\n+          if (param != null &&\n+              (param.getType() == Token.STRING\n+                  || param.getType() == Token.REGEXP))\n+          return false;\n+        }\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       Node name = callNode.getFirstChild();\n       Collection<Definition> defs =\n           getCallableDefinitions(definitionProvider, name);\n-      if (defs == null) {\n-        continue;\n-      }\n-\n-      boolean hasSideEffects = false;\n-      for (Definition def : defs) {\n-        FunctionInformation functionInfo =\n-            functionSideEffectMap.get(def.getRValue());\n-        Preconditions.checkNotNull(functionInfo);\n-\n-        if ((NodeUtil.isCall(callNode) && functionInfo.mayHaveSideEffects()) ||\n-            (NodeUtil.isNew(callNode) && (functionInfo.mutatesGlobalState() ||\n-                                          functionInfo.functionThrows()))) {\n-          hasSideEffects = true;\n-          break;\n+      boolean hasSideEffects = true;\n+      if (defs != null) {\n+        hasSideEffects = false;\n+        for (Definition def : defs) {\n+          FunctionInformation functionInfo =\n+              functionSideEffectMap.get(def.getRValue());\n+          Preconditions.checkNotNull(functionInfo);\n+\n+          if ((NodeUtil.isCall(callNode)\n+                  && functionInfo.mayHaveSideEffects())\n+               || (NodeUtil.isNew(callNode)\n+                      && (functionInfo.mutatesGlobalState()\n+                          || functionInfo.functionThrows()))) {\n+            hasSideEffects = true;\n+            break;\n+          }\n+        }\n+      }\n+\n+      // Handle special cases (Math, RegEx)\n+      if (NodeUtil.isCall(callNode)) {\n+        Preconditions.checkState(compiler != null);\n+        if (!NodeUtil.functionCallHasSideEffects(callNode, compiler)) {\n+          hasSideEffects = false;\n+        }\n+      } else if (NodeUtil.isNew(callNode)) {\n+        // Handle known cases now (Object, Date, RegExp, etc)\n+        if (!NodeUtil.constructorCallHasSideEffects(callNode)) {\n+          hasSideEffects = false;\n         }\n       }\n \n      * Record information about a call site.\n      */\n     private void visitCall(FunctionInformation sideEffectInfo, Node node) {\n+      // Handle special cases (Math, RegEx)\n+      if (NodeUtil.isCall(node)\n+          && !NodeUtil.functionCallHasSideEffects(node, compiler)) {\n+        return;\n+      }\n+\n+      // Handle known cases now (Object, Date, RegExp, etc)\n+      if (NodeUtil.isNew(node)\n+          && !NodeUtil.constructorCallHasSideEffects(node)) {\n+        return;\n+      }\n+\n       sideEffectInfo.appendCall(node);\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n \n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n     super.add(n, context);\n   }\n \n-\n   private String getTypeAnnotation(Node node) {\n     JSType type = node.getJSType();\n     if (type instanceof FunctionType) {\n       return getFunctionAnnotation(node);\n     } else if (type != null && !type.isUnknownType()\n-        && !type.isEmptyType() && !type.isVoidType()) {\n+        && !type.isEmptyType() && !type.isVoidType() &&\n+        !type.isFunctionPrototypeType()) {\n       return \"/** @type {\" + node.getJSType() + \"} */\\n\";\n     } else {\n       return \"\";\n   private String getFunctionAnnotation(Node node) {\n     StringBuilder sb = new StringBuilder(\"/**\\n\");\n \n-    if (node.getJSType().isUnknownType()) {\n+    JSType type = node.getJSType();\n+\n+    if (type == null || type.isUnknownType()) {\n       return \"\";\n     }\n+\n     FunctionType funType = (FunctionType) node.getJSType();\n \n     // We need to use the child nodes of the function as the nodes for the\n \n     // Constructor/interface\n     if (funType.isConstructor() || funType.isInterface()) {\n-      ObjectType superInstance =\n+      \n+      FunctionType superConstructor = funType.getSuperClassConstructor();\n+      \n+      if (superConstructor != null) {\n+        ObjectType superInstance =\n           funType.getSuperClassConstructor().getInstanceType();\n-      if (!superInstance.toString().equals(\"Object\")) {\n-        sb.append(\" * @extends {\"  + superInstance + \"}\\n\");\n+        if (!superInstance.toString().equals(\"Object\")) {\n+          sb.append(\" * @extends {\"  + superInstance + \"}\\n\");\n+        }\n       }\n \n       for (ObjectType interfaze : funType.getImplementedInterfaces()) {\n--- a/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n import com.google.javascript.jscomp.ErrorManager;\n import com.google.javascript.jscomp.JSError;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n   /**\n    * Thrown by base classes to signify a problem parsing a line.\n    */\n-  protected static class ParseException extends Exception {\n+  static class ParseException extends Exception {\n     public static final long serialVersionUID = 1L;\n     private boolean fatal;\n \n     }\n   }\n \n-  /** Pattern for stripping JavaScript comments from source files. */\n-  private static final Pattern STRIP_COMMENTS_PATTERN =\n-      Pattern.compile(\"/\\\\*.*?\\\\*/\" + // Multi-line comments\n-          \"|//.*?$\" // Single-line comments.\n-          , Pattern.DOTALL | Pattern.MULTILINE);\n+  /** Patterns for stripping JavaScript comments from source files. */\n+  private static final Pattern COMMENT = Pattern.compile(\n+      \"//.*\" + // single-line comment\n+      \"|/\\\\*([^\\\\*]*(\\\\*+[^/\\\\*])?)*(\\\\*+/)?\" // start of multi-line comment\n+      );\n+  private static final Pattern END_MULTILINE_COMMENT =\n+      Pattern.compile(\".*?\\\\*/\");\n \n   /** Pattern for matching JavaScript string literals. */\n   private static final Pattern STRING_LITERAL_PATTERN = Pattern.compile(\n       \"\\\\s*(?:'((?:\\\\\\\\'|[^'])*?)'|\\\"((?:\\\\\\\\\\\"|[^\\\"])*?)\\\")\\\\s*\");\n \n-  /** Matcher used in the parsing comments. */\n-  private Matcher stripCommentsMatcher = STRIP_COMMENTS_PATTERN.matcher(\"\");\n+  /** Matchers for comments. */\n+  private Matcher commentMatcher = COMMENT.matcher(\"\");\n+\n+  private Matcher endMultilineCommentMatcher =\n+      END_MULTILINE_COMMENT.matcher(\"\");\n+\n   /** Matcher used in the parsing string literals. */\n   private Matcher valueMatcher = STRING_LITERAL_PATTERN.matcher(\"\");\n \n   /** Path of the file currently being parsed. */\n-  protected String filePath;\n+  String filePath;\n   /** The line number of the line currently being parsed. */\n-  protected int lineNum;\n+  int lineNum;\n   /** Handles error messages. */\n-  protected ErrorManager errorManager;\n+  ErrorManager errorManager;\n   /** Did our parse succeed. */\n-  protected boolean parseSucceeded;\n+  boolean parseSucceeded;\n \n   /**\n    * Constructor.\n \n   public boolean didParseSucceed() {\n     return parseSucceeded;\n+  }\n+\n+  /**\n+   * @see parseLine(String, Reader)\n+   */\n+  void doParse(String filePath, String fileContents) {\n+    doParse(filePath, new StringReader(fileContents));\n   }\n \n   /**\n    *\n    * @param filePath The path to the file being parsed. Used for reporting parse\n    *     exceptions.\n-   * @param fileContents The contents of the file.\n-   */\n-  protected void doParse(String filePath, String fileContents) {\n+   * @param fileContents A reader for the contents of the file.\n+   */\n+  void doParse(String filePath, Reader fileContents) {\n     this.filePath = filePath;\n     parseSucceeded = true;\n \n-    // Strip all comments.\n-    stripCommentsMatcher.reset(fileContents);\n-    // TODO(agrieve): Multi-line comments will be removed, causing line-number reporting\n-    // to be wrong.\n-    fileContents = stripCommentsMatcher.replaceAll(\"\");\n+    BufferedReader lineBuffer = new BufferedReader(fileContents);\n+\n+    // Parse all lines.\n+    String line = null;\n     lineNum = 0;\n-    // Parse all lines.\n-    for (String line : fileContents.split(\"\\n\")) {\n-      ++lineNum;\n-      try {\n-        parseLine(line);\n-      } catch (ParseException e) {\n-        // Inform the error handler of the exception.\n-        errorManager.report(\n-            e.isFatal() ? CheckLevel.ERROR : CheckLevel.WARNING,\n-            JSError.make(filePath, lineNum, 0 /* char offset */,\n-                e.isFatal() ? PARSE_ERROR : PARSE_WARNING,\n-                e.getMessage(), line));\n-        parseSucceeded = parseSucceeded && !e.isFatal();\n+    boolean inMultilineComment = false;\n+\n+    try {\n+      while (null != (line = lineBuffer.readLine())) {\n+        ++lineNum;\n+        try {\n+          String revisedLine = line;\n+          if (inMultilineComment) {\n+            endMultilineCommentMatcher.reset(line);\n+            if (endMultilineCommentMatcher.lookingAt()) {\n+              revisedLine = endMultilineCommentMatcher.replaceFirst(\"\");\n+              inMultilineComment = false;\n+            } else {\n+              revisedLine = \"\";\n+            }\n+          }\n+\n+          if (!inMultilineComment) {\n+            commentMatcher.reset(line);\n+            if (commentMatcher.find()) {\n+              do {\n+                if (// The last match hit a /**-style comment.\n+                    commentMatcher.group(1) != null &&\n+                    // The /**-style comment didn't close.\n+                    commentMatcher.group(3) == null) {\n+                  inMultilineComment = true;\n+                }\n+              } while (commentMatcher.find());\n+\n+              revisedLine = commentMatcher.replaceAll(\"\");\n+            }\n+          }\n+\n+          if (!revisedLine.isEmpty()) {\n+            parseLine(revisedLine);\n+          }\n+        } catch (ParseException e) {\n+          // Inform the error handler of the exception.\n+          errorManager.report(\n+              e.isFatal() ? CheckLevel.ERROR : CheckLevel.WARNING,\n+              JSError.make(filePath, lineNum, 0 /* char offset */,\n+                  e.isFatal() ? PARSE_ERROR : PARSE_WARNING,\n+                  e.getMessage(), line));\n+          parseSucceeded = parseSucceeded && !e.isFatal();\n+        }\n       }\n+    } catch (IOException e) {\n+      errorManager.report(CheckLevel.ERROR,\n+          JSError.make(filePath, 0, 0 /* char offset */,\n+              PARSE_ERROR, \"Error reading file: \" + filePath));\n+      parseSucceeded = false;\n     }\n   }\n \n    * @param line The line to parse.\n    * @throws ParseException Should be thrown to signify a problem with the line.\n    */\n-  protected abstract void parseLine(String line) throws ParseException;\n+  abstract void parseLine(String line) throws ParseException;\n \n   /**\n    * Parses a JS string literal.\n    * @throws ParseException Thrown if there is a string literal that cannot be\n    *     parsed.\n    */\n-  protected String parseJsString(String jsStringLiteral) throws ParseException {\n+  String parseJsString(String jsStringLiteral) throws ParseException {\n     valueMatcher.reset(jsStringLiteral);\n     if (!valueMatcher.matches()) {\n       throw new ParseException(\"Syntax error in JS String literal\", true /* fatal */);\n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n          \"Bar.prototype.a = function(){};\");\n   }\n \n+  public void testStaticAndSubInstanceProperties() {\n+    String js = \"\"\n+        + \"/** @constructor */ var Foo = function(){};\\n\"\n+        + \"Foo.x=0;\\n\"\n+        + \"/** @constructor \\n @extends Foo */ var Bar = function(){};\\n\"\n+        + \"goog.inherits(Bar, Foo);\\n\"\n+        + \"Bar.y=0;\\n\"\n+        + \"Bar.prototype.z=0;\\n\";\n+    String output = \"\"\n+        + \"/** @constructor */ var Foo = function(){};\\n\"\n+        + \"Foo.a=0;\\n\"\n+        + \"/** @constructor \\n @extends Foo */ var Bar = function(){};\\n\"\n+        + \"goog.inherits(Bar, Foo);\\n\"\n+        + \"Bar.a=0;\\n\"\n+        + \"Bar.prototype.a=0;\\n\";\n+    test(js, output);\n+  }\n+\n   public void testTypeMismatch() {\n     testSame(EXTERNS, \"/** @constructor */var Foo = function(){};\\n\"\n              + \"/** @constructor */var Bar = function(){};\\n\"\n         + \"function g(x) { x.a = 3; }\";\n     test(js, output);\n   }\n+\n+  public void testImplementsAndExtends2() {\n+    String js = \"\"\n+        + \"/** @interface */ function A() {}\\n\"\n+        + \"/**\\n\"\n+        + \" * @constructor\\n\"\n+        + \" */\\n\"\n+        + \"function C1(){}\\n\"\n+        + \"/**\\n\"\n+        + \" * @constructor\\n\"\n+        + \" * @extends {C1}\\n\"\n+        + \" * @implements {A}\\n\"\n+        + \" */\\n\"\n+        + \"function C2(){}\\n\"\n+        + \"/** @param {C1} x */ function f(x) { x.y = 3; }\\n\"\n+        + \"/** @param {A} x */ function g(x) { x.z = 3; }\\n\";\n+    String output = \"\"\n+        + \"function A(){}\\n\"\n+        + \"function C1(){}\\n\"\n+        + \"function C2(){}\\n\"\n+        + \"function f(x) { x.a = 3; }\\n\"\n+        + \"function g(x) { x.b = 3; }\\n\";\n+    test(js, output);\n+  }\n+\n+  public void testExtendsInterface() {\n+    String js = \"\"\n+        + \"/** @interface */ function A() {}\\n\"\n+        + \"/** @interface \\n @extends {A} */ function B() {}\\n\"\n+        + \"/** @param {A} x */ function f(x) { x.y = 3; }\\n\"\n+        + \"/** @param {B} x */ function g(x) { x.z = 3; }\\n\";\n+    String output = \"\"\n+        + \"function A(){}\\n\"\n+        + \"function B(){}\\n\"\n+        + \"function f(x) { x.a = 3; }\\n\"\n+        + \"function g(x) { x.b = 3; }\\n\";\n+    test(js, output);\n+  }\n+\n+  public void testFunctionSubType() {\n+    String js = \"\"\n+        + \"Function.prototype.a = 1;\\n\"\n+        + \"function f() {}\\n\"\n+        + \"f.y = 2;\\n\";\n+    String output = \"\"\n+        + \"Function.prototype.a = 1;\\n\"\n+        + \"function f() {}\\n\"\n+        + \"f.b = 2;\\n\";\n+    test(js, output);\n+  }\n+\n+  public void testFunctionSubType2() {\n+    String js = \"\"\n+        + \"Function.prototype.a = 1;\\n\"\n+        + \"/** @constructor */ function F() {}\\n\"\n+        + \"F.y = 2;\\n\";\n+    String output = \"\"\n+        + \"Function.prototype.a = 1;\\n\"\n+        + \"function F() {}\\n\"\n+        + \"F.b = 2;\\n\";\n+    test(js, output);\n+  }\n+\n }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     Node n = compiler.parseTestCode(js);\n \n     if (checkTypes) {\n-      CompilerPass typeResolver = new DefaultPassConfig(null)\n-          .resolveTypes.create(compiler);\n+      DefaultPassConfig passConfig = new DefaultPassConfig(null);\n+      CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);\n       Node externs = new Node(Token.SCRIPT);\n       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n       externAndJsRoot.setIsSyntheticBlock(true);\n       typeResolver.process(externs, n);\n+      CompilerPass inferTypes = passConfig.inferTypes.create(compiler);\n+      inferTypes.process(externs, n);\n     }\n \n     assertEquals(\"Errors for: \" + js, 0, compiler.getErrorCount());\n             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n   }\n \n-\n   public void testPrettyPrinter() {\n     // Ensure that the pretty printer inserts line breaks at appropriate\n     // places.\n         + \" * @return {number}\\n\"\n         + \" */\\n\"\n         + \"a.Foo.prototype.foo = function(foo) {\\n};\\n\"\n-        + \"/** @type {(string|undefined)} */\\n\"\n+        + \"/** @type {string} */\\n\"\n         + \"a.Foo.prototype.bar = \\\"\\\"\");\n   }\n \n     assertTypeAnnotations(\n         \"/** @type {!Function} */ var x = function() {}\",\n         \"/**\\n * @constructor\\n */\\nvar x = function() {\\n}\");\n+  }\n+\n+  public void testTempConstructor() {\n+    assertTypeAnnotations(\n+        \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n+        \" /**\\n * @constructor\\n */\\nfunction t2() {}\\n\" +\n+        \" t1.prototype = t2.prototype}\",\n+        \"/**\\n */\\nvar x = function() {\\n\" +\n+        \"  /**\\n * @constructor\\n */\\nfunction t1() {\\n  }\\n\" +\n+        \"  /**\\n * @constructor\\n */\\nfunction t2() {\\n  }\\n\" +\n+        \"  t1.prototype = t2.prototype\\n}\"\n+    );\n   }\n \n   private void assertPrettyPrint(String js, String expected) {\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n           \"x();\"\n         });\n   }\n+  \n+  // Read of closure variable disables method motions.\n+  public void testClosureVariableReads1() {\n+    testSame(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"(function() {\" +\n+            \"var x = 'x';\" +\n+            \"Foo.prototype.baz = function() {x};\" +\n+            \"})();\",\n+            // Module 2\n+            \"var y = new Foo(); y.baz();\"));\n+  }\n+  \n+  // Read of global variable is fine.\n+  public void testClosureVariableReads2() {\n+    test(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"Foo.prototype.b1 = function() {\" +\n+            \"  var x = 1;\" +\n+            \"  Foo.prototype.b2 = function() {\" +\n+            \"    Foo.prototype.b3 = function() {\" +\n+            \"      x;\" +\n+            \"    }\" +\n+            \"  }\" +\n+            \"};\",\n+            // Module 2\n+            \"var y = new Foo(); y.b1();\",\n+            // Module 3\n+            \"y = new Foo(); z.b2();\",\n+            // Module 4\n+            \"y = new Foo(); z.b3();\"\n+            ),\n+         new String[] {\n+           STUB_DECLARATIONS +\n+           \"function Foo() {}\" +\n+           \"Foo.prototype.b1 = JSCompiler_stubMethod(0);\",\n+           // Module 2\n+           \"Foo.prototype.b1 = JSCompiler_unstubMethod(0, function() {\" +\n+           \"  var x = 1;\" +\n+           \"  Foo.prototype.b2 = function() {\" +\n+           \"    Foo.prototype.b3 = function() {\" +\n+           \"      x;\" +\n+           \"    }\" +\n+           \"  }\" +\n+           \"});\" +\n+           \"var y = new Foo(); y.b1();\",\n+           // Module 3\n+           \"y = new Foo(); z.b2();\",\n+           // Module 4\n+           \"y = new Foo(); z.b3();\"\n+        });\n+  }\n+  \n+  public void testClosureVariableReads3() {\n+    test(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"Foo.prototype.b1 = function() {\" +\n+            \"  Foo.prototype.b2 = function() {\" +\n+            \"    var x = 1;\" +\n+            \"    Foo.prototype.b3 = function() {\" +\n+            \"      x;\" +\n+            \"    }\" +\n+            \"  }\" +\n+            \"};\",\n+            // Module 2\n+            \"var y = new Foo(); y.b1();\",\n+            // Module 3\n+            \"y = new Foo(); z.b2();\",\n+            // Module 4\n+            \"y = new Foo(); z.b3();\"\n+            ),\n+         new String[] {\n+           STUB_DECLARATIONS +\n+           \"function Foo() {}\" +\n+           \"Foo.prototype.b1 = JSCompiler_stubMethod(0);\",\n+           // Module 2\n+           \"Foo.prototype.b1 = JSCompiler_unstubMethod(0, function() {\" +\n+           \"  Foo.prototype.b2 = JSCompiler_stubMethod(1);\" +\n+           \"});\" +\n+           \"var y = new Foo(); y.b1();\",\n+           // Module 3\n+           \"Foo.prototype.b2 = JSCompiler_unstubMethod(1, function() {\" +\n+           \"  var x = 1;\" +\n+           \"  Foo.prototype.b3 = function() {\" +\n+           \"    x;\" +\n+           \"  }\" +\n+           \"});\" +\n+           \"y = new Foo(); z.b2();\",\n+           // Module 4\n+           \"y = new Foo(); z.b3();\"\n+        });\n+  }\n+  \n+  // Read of global variable is fine.\n+  public void testNoClosureVariableReads1() {\n+    test(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"var x = 'x';\" +\n+            \"Foo.prototype.baz = function(){x};\",\n+            // Module 2\n+            \"var y = new Foo(); y.baz();\"),\n+         new String[] {\n+           STUB_DECLARATIONS +\n+           \"function Foo() {}\" +\n+           \"var x = 'x';\" +\n+           \"Foo.prototype.baz = JSCompiler_stubMethod(0);\",\n+           // Module 2             \n+           \"Foo.prototype.baz = JSCompiler_unstubMethod(0, function(){x});\" +\n+           \"var y = new Foo(); y.baz();\"\n+        });\n+  }\n+  \n+  // Read of a local is fine.\n+  public void testNoClosureVariableReads2() {\n+    test(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"Foo.prototype.baz = function(){var x = 1;x};\",\n+            // Module 2\n+            \"var y = new Foo(); y.baz();\"),\n+         new String[] {\n+           STUB_DECLARATIONS +\n+           \"function Foo() {}\" +\n+           \"Foo.prototype.baz = JSCompiler_stubMethod(0);\",\n+           // Module 2             \n+           \"Foo.prototype.baz = JSCompiler_unstubMethod(\" + \n+           \"    0, function(){var x = 1; x});\" +\n+           \"var y = new Foo(); y.baz();\"\n+        });\n+  }\n }\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n   }\n \n+  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n+    Node n = parse(js);\n+    Compiler compiler = new Compiler();\n+    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n+    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n+  }\n+\n   public void testMayHaveSideEffects() {\n     assertSideEffect(true, \"i++\");\n     assertSideEffect(true, \"[b, [a, i++]]\");\n     assertSideEffect(true, \"a.foo = 4\");\n     assertSideEffect(true, \"(function() { return n; })().foo = 4\");\n     assertSideEffect(true, \"([]).foo = bar()\");\n+  }\n+\n+  public void testRegExpSideEffect() {\n+    // A RegExp Object by itself doesn't have any side-effects\n+    assertSideEffect(false, \"/abc/gi\", true);\n+    assertSideEffect(false, \"/abc/gi\", false);\n+\n+    // RegExp instance methods have global side-effects, so whether they are\n+    // considered side-effect free depends on whether the global properties\n+    // are referenced.\n+    assertSideEffect(true, \"(/abc/gi).test('')\", true);\n+    assertSideEffect(false, \"(/abc/gi).test('')\", false);\n+    assertSideEffect(true, \"(/abc/gi).test(a)\", true);\n+    assertSideEffect(false, \"(/abc/gi).test(b)\", false);\n+\n+    assertSideEffect(true, \"(/abc/gi).exec('')\", true);\n+    assertSideEffect(false, \"(/abc/gi).exec('')\", false);\n+\n+    // Some RegExp object method that may have side-effects.\n+    assertSideEffect(true, \"(/abc/gi).foo('')\", true);\n+    assertSideEffect(true, \"(/abc/gi).foo('')\", false);\n+\n+    // Try the string RegExp ops.\n+    assertSideEffect(true, \"''.match('a')\", true);\n+    assertSideEffect(false, \"''.match('a')\", false);\n+    assertSideEffect(true, \"''.match(/(a)/)\", true);\n+    assertSideEffect(false, \"''.match(/(a)/)\", false);\n+\n+    assertSideEffect(true, \"''.replace('a')\", true);\n+    assertSideEffect(false, \"''.replace('a')\", false);\n+\n+    assertSideEffect(true, \"''.search('a')\", true);\n+    assertSideEffect(false, \"''.search('a')\", false);\n+\n+    assertSideEffect(true, \"''.split('a')\", true);\n+    assertSideEffect(false, \"''.split('a')\", false);\n+\n+    // Some non-RegExp string op that may have side-effects.\n+    assertSideEffect(true, \"''.foo('a')\", true);\n+    assertSideEffect(true, \"''.foo('a')\", false);\n+\n+    // 'a' might be a RegExp object with the 'g' flag, in which case \n+    // the state might change by running any of the string ops.\n+    // Specifically, using these methods resets the \"lastIndex\" if used\n+    // in combination with a RegExp instance \"exec\" method.\n+    assertSideEffect(true, \"''.match(a)\", true);\n+    assertSideEffect(true, \"''.match(a)\", false);\n   }\n \n   private void assertMutableState(boolean se, String js) {\n     assertFalse(secondBreak.hasChildren());\n     assertFalse(NodeUtil.isLabelName(secondBreak.getFirstChild()));\n   }\n-\n }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n  */\n public class PureFunctionIdentifierTest extends CompilerTestCase {\n   List<String> noSideEffectCalls = Lists.newArrayList();\n+  \n+  boolean regExpHaveSideEffects = true;\n \n   private static String kExterns =\n       CompilerTypeTestCase.DEFAULT_EXTERNS +\n   protected void tearDown() throws Exception {\n     super.tearDown();\n     noSideEffectCalls.clear();\n+    boolean regExpHaveSideEffects = true;\n   }\n \n   public void testAnnotationInExterns1() throws Exception {\n     checkMarkedCalls(source, ImmutableList.<String>of(\"(g : g)\", \"k\"));\n   }\n \n+  public void testCallRegExpWithSideEffects() throws Exception {\n+    String source = \"var x = 0;\\n\" +\n+        \"function k(){(/a/).exec('')}\\n\" +\n+        \"k()\";\n+\n+    regExpHaveSideEffects = true;\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+    regExpHaveSideEffects = false;\n+    checkMarkedCalls(source, ImmutableList.<String>of(\n+        \"REGEXP STRING exec\", \"k\"));\n+  }\n+\n   public void testInvalidAnnotation1() throws Exception {\n     test(\"/** @nosideeffects */ function foo() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n \n     @Override\n     public void process(Node externs, Node root) {\n+      compiler.setHasRegExpGlobalReferences(regExpHaveSideEffects);\n       SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n       defFinder.process(externs, root);\n       PureFunctionIdentifier passUnderTest =\n         return \"(\" + generateNameString(node.getFirstChild().getNext()) +\n             \" : \" + generateNameString(node.getLastChild()) + \")\";\n       } else {\n-        return node.getQualifiedName();\n+        String result = node.getQualifiedName();\n+        if (result == null) {\n+          result = node.getFirstChild().toString(false, false, false);\n+          result += \" \" + node.getLastChild().toString(false, false, false);\n+        }\n+        return result;\n       }\n     }\n   }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.PrintStreamErrorManager;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Tests for {@link JsFileLineParser}.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class JsFileLineParserTest extends TestCase {\n+\n+  TestParser parser;\n+  private ErrorManager errorManager;\n+\n+  @Override\n+  public void setUp() {\n+    errorManager = new PrintStreamErrorManager(System.err);\n+    parser = new TestParser(errorManager);\n+  }\n+\n+  public void testSingleLine1() {\n+    assertStrip(\"2\", \"// 1\\n2\");\n+  }\n+\n+  public void testSingleLine2() {\n+    assertStrip(\"2 \", \"// 1\\n2 // 3 // 4 \\n\");\n+  }\n+\n+  public void testMultiLine1() {\n+    assertStrip(\"1\", \"/* hi */\\n1\");\n+  }\n+\n+  public void testMultiLine2() {\n+    assertStrip(\"123\", \"1/* hi */2\\n3\");\n+  }\n+\n+  public void testMultiLine3() {\n+    assertStrip(\"14\", \"1/* hi 2\\n3*/4\");\n+  }\n+\n+  public void testMultiLine4() {\n+    assertStrip(\"15\", \"1/* hi x\\ny\\nz*/5\");\n+  }\n+\n+  public void testMultiLine5() {\n+    assertStrip(\"1234\", \"1/* hi */2/**/3/*\\n/** bye */4\");\n+  }\n+\n+  public void testMultiLine6() {\n+    assertStrip(\"12\", \"1/*** hi *** 3 **/2\");\n+  }\n+\n+  public void testMixedLine1() {\n+    assertStrip(\"14\", \"1// /** 2 **/ 3\\n4\");\n+  }\n+\n+  public void testMixedLine2() {\n+    assertStrip(\"1 34\", \"1/** // 2 **/ 3\\n4\");\n+  }\n+\n+  private void assertStrip(String expected, String input) {\n+    parser.doParse(\"file\", input);\n+    assertEquals(expected, parser.toString());\n+  }\n+\n+  private static class TestParser extends JsFileLineParser {\n+    StringBuffer sb = new StringBuffer();\n+\n+    TestParser(ErrorManager errorManager) {\n+      super(errorManager);\n+    }\n+\n+    void parseLine(String line) {\n+      sb.append(line);\n+    }\n+\n+    public String toString() {\n+      return sb.toString();\n+    }\n+  }\n+}", "timestamp": 1271084379, "metainfo": ""}