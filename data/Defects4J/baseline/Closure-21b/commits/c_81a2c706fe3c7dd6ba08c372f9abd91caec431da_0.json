{"sha": "81a2c706fe3c7dd6ba08c372f9abd91caec431da", "log": "Experimental: type-based constant property inlining.  This pass uses type information to invalidate candidates and find candidate property references. Candidate properties must meet these requirements: * they must be assigned to a known, named, and valid type (those not invalidated by the type checker) * they must be only be defined unconditional either in the constructor or on the prototype * they must be assigned an immuatable constant  References to these properties will only be replaced if referencing type is known, not invalidated by the type checker, and an inclusive subtype of the defining type.  R=nicksantos DELTA=580  (577 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4680   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** Inlines constants (symbols that are all CAPS) */\n   public boolean inlineConstantVars;\n \n-  /** Inlines short functions */\n+  /** Inlines global functions */\n   public boolean inlineFunctions;\n \n-  /** Enhanced function inlining */\n+  /** Inlines functions defined in local scopes */\n   public boolean inlineLocalFunctions;\n \n+  /** More aggressive function inlining */\n   boolean assumeClosuresOnlyCaptureReferences;\n+\n+  /** Inlines properties */\n+  boolean inlineProperties;\n \n   /** Move code to a deeper module */\n   public boolean crossModuleCodeMotion;\n     inlineLocalFunctions = false;\n     assumeStrictThis = false;\n     assumeClosuresOnlyCaptureReferences = false;\n+    inlineProperties = false;\n     crossModuleCodeMotion = false;\n     crossModuleMethodMotion = false;\n     inlineGetters = false;\n   }\n \n   /**\n+   * Set the function inlining policy for the compiler.\n+   */\n+  public void setInlineProperties(boolean enable) {\n+    inlineProperties = enable;\n+  }\n+\n+  /**\n    * Set the variable removal policy for the compiler.\n    */\n   @Deprecated\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(inlineFunctions);\n     }\n \n+    if (options.inlineProperties) {\n+      passes.add(inlineProperties);\n+    }\n+\n     boolean runOptimizeCalls = options.optimizeCalls\n         || options.optimizeParameters\n         || options.optimizeReturns;\n           options.assumeStrictThis()\n               || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT,\n           options.assumeClosuresOnlyCaptureReferences);\n+    }\n+  };\n+\n+  /** Inlines constant properties. */\n+  final PassFactory inlineProperties =\n+      new PassFactory(\"inlineProperties\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new InlineProperties(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/InlineProperties.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.TypeValidator.TypeMismatch;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * InlineProperties attempts to find references to properties that are known to\n+ * be constants and inline the known value.\n+ *\n+ * This pass relies on type information to find these property references and\n+ * properties are assumed to be constant if either:\n+ *   - the property is assigned unconditionally in the instance constructor\n+ *   - the property is assigned unconditionally to the type's prototype\n+ *\n+ * The current implementation only inlines immutable values (as defined by\n+ * NodeUtil.isImmutableValue).\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class InlineProperties implements CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+\n+  static class PropertyInfo {\n+    PropertyInfo(JSType type, Node value) {\n+      this.type = type;\n+      this.value = value;\n+    }\n+    final JSType type;\n+    final Node value;\n+  }\n+\n+  private static final PropertyInfo INVALIDATED = new PropertyInfo(\n+      null, null);\n+\n+  private final Map<String, PropertyInfo> props = Maps.newHashMap();\n+\n+  private Set<JSType> invalidatingTypes;\n+\n+  InlineProperties(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+    buildInvalidatingTypeSet();\n+  }\n+\n+  // TODO(johnlenz): this is a direct copy of the invalidation code\n+  // from AmbiguateProperties, if in the end we don't need to modify it\n+  // we should move it to a common location.\n+  private void buildInvalidatingTypeSet() {\n+    JSTypeRegistry registry = compiler.getTypeRegistry();\n+    invalidatingTypes = Sets.newHashSet(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE),\n+        registry.getNativeType(JSTypeNative.NULL_TYPE),\n+        registry.getNativeType(JSTypeNative.VOID_TYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.GLOBAL_THIS),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),\n+        registry.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n+\n+    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n+      addInvalidatingType(mis.typeA);\n+      addInvalidatingType(mis.typeB);\n+    }\n+  }\n+\n+  /**\n+   * Invalidates the given type, so that no properties on it will be renamed.\n+   */\n+  private void addInvalidatingType(JSType type) {\n+    type = type.restrictByNotNullOrUndefined();\n+    if (type.isUnionType()) {\n+      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n+        addInvalidatingType(alt);\n+      }\n+    }\n+\n+    invalidatingTypes.add(type);\n+    ObjectType objType = ObjectType.cast(type);\n+    if (objType != null && objType.isInstanceType()) {\n+      invalidatingTypes.add(objType.getImplicitPrototype());\n+    }\n+  }\n+\n+  /** Returns true if properties on this type should not be renamed. */\n+  private boolean isInvalidatingType(JSType type) {\n+    if (type.isUnionType()) {\n+      type = type.restrictByNotNullOrUndefined();\n+      if (type.isUnionType()) {\n+        for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n+          if (isInvalidatingType(alt)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+    }\n+    ObjectType objType = ObjectType.cast(type);\n+    return objType == null\n+        || invalidatingTypes.contains(objType)\n+        || !objType.hasReferenceName()\n+        || objType.isUnknownType()\n+        || objType.isEmptyType() /* unresolved types */\n+        || objType.isEnumType()\n+        || objType.autoboxesTo() != null;\n+  }\n+\n+  /**\n+   * This method gets the JSType from the Node argument and verifies that it is\n+   * present.\n+   */\n+  private JSType getJSType(Node n) {\n+    JSType jsType = n.getJSType();\n+    if (jsType == null) {\n+      return compiler.getTypeRegistry().getNativeType(\n+          JSTypeNative.UNKNOWN_TYPE);\n+    } else {\n+      return jsType;\n+    }\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverseRoots(\n+        compiler, new GatherCandidates(), externs, root);\n+    NodeTraversal.traverseRoots(\n+        compiler, new ReplaceCandidates(), externs, root);\n+  }\n+\n+  class GatherCandidates extends AbstractPostOrderCallback {\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      boolean invalidatingPropRef = false;\n+      String propName = null;\n+      if (n.isGetProp()) {\n+        propName = n.getLastChild().getString();\n+        if (t.getInput().isExtern()) {\n+          // Any extern reference invalidates\n+          invalidatingPropRef = true;\n+        } else if (parent.isAssign()) {\n+          invalidatingPropRef = !maybeCandidateDefinition(t, n, parent);\n+        } else if (NodeUtil.isLValue(n)) {\n+          // Other LValue references invalidate\n+          invalidatingPropRef = true;\n+        } else if (parent.isDelProp()) {\n+          // Deletes invalidate\n+          invalidatingPropRef = true;\n+        } else {\n+          // A property read doesn't invalidate\n+          invalidatingPropRef = false;\n+        }\n+      } else if (n.isStringKey()) {\n+        propName = n.getString();\n+        if (t.getInput().isExtern()) {\n+          // Any extern reference invalidates\n+          invalidatingPropRef = true;\n+        } else {\n+          // For now, any object literal key invalidates\n+          // TODO(johnlenz): support prototype properties like:\n+          //   foo.prototype = { a: 1, b: 2 };\n+          invalidatingPropRef = true;\n+        }\n+      }\n+\n+      if (invalidatingPropRef) {\n+        Preconditions.checkNotNull(propName);\n+        invalidateProperty(propName);\n+      }\n+    }\n+\n+    /**\n+     * @return Whether this is a valid definition for a candidate property.\n+     */\n+    private boolean maybeCandidateDefinition(\n+        NodeTraversal t, Node n, Node parent) {\n+      Preconditions.checkState(n.isGetProp() && parent.isAssign());\n+      boolean isCandidate = false;\n+      Node src = n.getFirstChild();\n+      String propName = n.getLastChild().getString();\n+\n+      Node value = parent.getLastChild();\n+      if (src.isThis()) {\n+        // This is a simple assignment like:\n+        //    this.foo = 1;\n+        if (inContructor(t)) {\n+          // This maybe a valid assignment.\n+          isCandidate = maybeStoreCandidateValue(\n+              getJSType(src), propName, value);\n+        }\n+      } else if (t.inGlobalScope()\n+          && src.isGetProp()\n+          && src.getLastChild().getString().equals(\"prototype\")) {\n+        // This is a prototype assignment like:\n+        //    x.prototype.foo = 1;\n+        JSType instanceType = maybeGetInstanceTypeFromPrototypeRef(src);\n+        if (instanceType != null) {\n+          isCandidate = maybeStoreCandidateValue(\n+              instanceType, propName, value);\n+        }\n+      }\n+      return isCandidate;\n+    }\n+\n+    private JSType maybeGetInstanceTypeFromPrototypeRef(Node src) {\n+      JSType ownerType = getJSType(src.getFirstChild());\n+      if (ownerType.isFunctionType() && ownerType.isConstructor()) {\n+        FunctionType functionType = ((FunctionType) ownerType);\n+        return functionType.getInstanceType();\n+      }\n+      return null;\n+    }\n+\n+    private void invalidateProperty(String propName) {\n+      props.put(propName, INVALIDATED);\n+    }\n+\n+    private boolean maybeStoreCandidateValue(\n+        JSType type, String propName, Node value) {\n+      Preconditions.checkNotNull(value);\n+      if (!props.containsKey(propName)\n+          && !isInvalidatingType(type)\n+          && NodeUtil.isImmutableValue(value)\n+          && NodeUtil.isExpressionUnconditionallyExecuted(value)) {\n+        props.put(propName, new PropertyInfo(type, value));\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean inContructor(NodeTraversal t) {\n+      Node root = t.getScopeRoot();\n+      JSDocInfo info = NodeUtil.getBestJSDocInfo(root);\n+      return info != null && info.isConstructor();\n+    }\n+  }\n+\n+  class ReplaceCandidates extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isGetProp() && !NodeUtil.isLValue(n)) {\n+        Node target = n.getFirstChild();\n+        String propName = n.getLastChild().getString();\n+        PropertyInfo info = props.get(propName);\n+        if (info != null\n+            && info != INVALIDATED\n+            && isMatchingType(target, info.type)) {\n+          Node replacement = info.value.cloneTree();\n+          if (NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler)) {\n+            replacement = IR.comma(n.removeFirstChild(), replacement).srcref(n);\n+          }\n+          parent.replaceChild(n, replacement);\n+          compiler.reportCodeChange();\n+        }\n+      }\n+    }\n+\n+    private boolean isMatchingType(Node n, JSType src) {\n+      src = src.restrictByNotNullOrUndefined();\n+      JSType dest = getJSType(n).restrictByNotNullOrUndefined();\n+      if (!isInvalidatingType(dest)\n+          && dest.isSubtype(src)) {\n+        return true;\n+      }\n+      return false;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     return true;\n   }\n \n+  /**\n+   * @param n The expression to check.\n+   * @return Whether the expression is unconditionally executed in the\n+   *     containing execution scope.\n+   */\n+  static boolean isExpressionUnconditionallyExecuted(Node n) {\n+    inspect: do {\n+      Node parent = n.getParent();\n+      switch (parent.getType()) {\n+        case Token.IF:\n+        case Token.HOOK:\n+        case Token.AND:\n+        case Token.OR:\n+          if (parent.getFirstChild() != n) {\n+            return false;\n+          }\n+          // other ancestors may be conditional\n+          continue inspect;\n+        case Token.FOR:\n+          if (parent.getFirstChild() != n) {\n+            return false;\n+          }\n+          // other ancestors may be conditional\n+          continue inspect;\n+        case Token.WHILE:\n+        case Token.DO:\n+          return false;\n+        case Token.TRY:\n+          // Consider all code under a try/catch to be conditionally executed.\n+          return false;\n+        case Token.CASE:\n+        case Token.DEFAULT_CASE:\n+          return false;\n+        case Token.SCRIPT:\n+        case Token.FUNCTION:\n+          // Done, we've reached the scope root.\n+          break inspect;\n+      }\n+    } while ((n = n.getParent()) != null);\n+    return true;\n+  }\n+\n   static Node booleanNode(boolean value) {\n     return value ? IR.trueNode() : IR.falseNode();\n   }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/InlinePropertiesTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class InlinePropertiesTest  extends CompilerTestCase {\n+\n+  private static final String EXTERNS =\n+      \"Function.prototype.call=function(){};\" +\n+      \"Function.prototype.inherits=function(){};\" +\n+      \"prop.toString;\" +\n+      \"var google = { gears: { factory: {}, workerPool: {} } };\";\n+\n+  public InlinePropertiesTest() {\n+    super(EXTERNS);\n+    enableNormalize();\n+    enableTypeCheck(CheckLevel.WARNING);\n+    enableClosurePass();\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new InlineProperties(compiler);\n+  }\n+\n+  public void testConstInstanceProp1() {\n+    // Replace a reference to known constant property.\n+    test(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"new C().foo;\",\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"new C(), 1;\");\n+  }\n+\n+  public void testConstInstanceProp2() {\n+    // Replace a constant reference\n+    test(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"x.foo;\",\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1\\n\" +\n+        \"}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"1;\\n\");\n+  }\n+\n+\n+  public void testConstInstanceProp3() {\n+    // Replace a constant reference\n+    test(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"/** @type {C} */\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"x.foo;\",\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1\\n\" +\n+        \"}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"1;\\n\");\n+  }\n+\n+  public void testConstInstanceProp4() {\n+    // This pass replies on DisambiguateProperties to distinguish like named\n+    // properties so it doesn't handle this case.\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"/** @constructor */\\n\" +\n+        \"function B() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"new C().foo;\\n\");\n+  }\n+\n+\n+  public void testConstClassProps1() {\n+    // For now, don't inline constant class properties,\n+    // CollapseProperties should handle this in most cases.\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"}\\n\" +\n+        \"C.foo = 1;\\n\" +\n+        \"C.foo;\");\n+  }\n+\n+  public void testConstClassProps2() {\n+    // Don't confuse, class properties with instance properties\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"C.foo;\");\n+  }\n+\n+  public void testConstClassProps3() {\n+    // Don't confuse, class properties with prototype properties\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {}\\n\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"c.foo;\\n\");\n+  }\n+\n+  public void testNonConstClassProp1() {\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"alert(x.foo);\\n\" +\n+        \"delete x.foo;\");\n+  }\n+\n+  public void testNonConstClassProp2() {\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"alert(x.foo);\\n\" +\n+        \"x.foo = 2;\");\n+  }\n+\n+  public void testNonConstructorClassProp1() {\n+    testSame(\n+        \"function C() {\\n\" +\n+        \"  this.foo = 1;\\n\" +\n+        \"  return this;\\n\" +\n+        \"}\\n\" +\n+        \"C().foo;\");\n+  }\n+\n+  public void testConditionalClassProp1() {\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  if (false) this.foo = 1;\\n\" +\n+        \"}\\n\" +\n+        \"new C().foo;\");\n+  }\n+\n+  public void testConstPrototypeProp1() {\n+    test(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {}\\n\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"new C().foo;\\n\",\n+        \"function C() {}\\n\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"new C(), 1;\\n\");\n+  }\n+\n+  public void testConstPrototypeProp2() {\n+    test(\n+        \"/** @constructor */\\n\" +\n+        \"function C() {}\\n\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"x.foo;\\n\",\n+        \"function C() {}\\n\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"1;\\n\");\n+  }\n+}", "timestamp": 1336065493, "metainfo": ""}