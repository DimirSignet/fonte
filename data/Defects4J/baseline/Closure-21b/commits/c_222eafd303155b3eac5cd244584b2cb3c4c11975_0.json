{"sha": "222eafd303155b3eac5cd244584b2cb3c4c11975", "log": "tighten up some types. (Nick) R=alan DELTA=4  (2 added, 0 deleted, 2 changed)  Don't use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don't distinguish between label names and variable names appropriately. (John) R=robert  Remove now unneeded checks for label names when inspecting NAME nodes. (John) R=robert  Tweak code generator to break after blocks for better pretty printing. (John) R=robert DELTA=196  (160 added, 0 deleted, 36 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=ktmses   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n     endBlock(false);\n   }\n \n-  void endBlock(boolean statementContext) {\n+  void endBlock(boolean shouldEndLine) {\n     appendBlockEnd();\n-    if (statementContext) {\n+    if (shouldEndLine) {\n       endLine();\n     }\n     statementNeedsEnded = false;\n   boolean shouldPreserveExtraBlocks() {\n     return false;\n   }\n+\n+  /**\n+   * @return Whether the a line break can be added after the specified BLOCK.\n+   */\n+  boolean breakAfterBlockFor(Node n, boolean statementContext) {\n+    return statementContext;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n *\n  */\n class CodeGenerator {\n-  \n+\n   private static final char[] HEX_CHARS\n       = { '0', '1', '2', '3', '4', '5', '6', '7',\n           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n   private final CharsetEncoder outputCharsetEncoder;\n \n   /** Whether to perform basic checks for obviously incorrect AST structure. */\n-  // NOTE: This exists to support a few extern legacy parsers that don't \n+  // NOTE: This exists to support a few extern legacy parsers that don't\n   // properly normalize the AST (JsMinimizer).\n   private final boolean validation;\n \n           add(\"var \");\n           addList(first, false, getContextForNoInOperator(context));\n         }\n+        break;\n+\n+      case Token.LABEL_NAME:\n+        Preconditions.checkState(!n.getString().isEmpty());\n+        addIdentifier(n.getString());\n         break;\n \n       case Token.NAME:\n             addExpr(first, 0, getContextForNoInOperator(context));\n           }\n         }\n-\n         break;\n \n       case Token.ARRAYLIT:\n           }\n         }\n         if (!stripBlock) {\n-          cc.endBlock(context == Context.STATEMENT);\n+          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n         }\n         break;\n       }\n         Preconditions.checkState(childCount <= 1);\n         add(\"continue\");\n         if (childCount == 1) {\n+          if (first.getType() != Token.LABEL_NAME && validation) {\n+            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+          }\n           add(\" \");\n           add(first);\n         }\n         Preconditions.checkState(childCount <= 1);\n         add(\"break\");\n         if (childCount == 1) {\n+          if (first.getType() != Token.LABEL_NAME && validation) {\n+            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+          }\n           add(\" \");\n           add(first);\n         }\n \n       case Token.LABEL:\n         Preconditions.checkState(childCount == 2);\n+        if (first.getType() != Token.LABEL_NAME && validation) {\n+          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+        }\n         add(first);\n         add(\":\");\n         addNonEmptyExpression(\n           cc.beginBlock();\n           add(firstAndOnlyChild, Context.STATEMENT);\n           cc.maybeLineBreak();\n-          cc.endBlock(context == Context.STATEMENT);\n+          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n           return;\n         } else {\n           // Continue with the only child.\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n       // When pretty-printing, always place the statement in its own block\n       // so it is printed on a separate line.  This allows breakpoints to be\n       // placed on the statement.\n+      return true;\n+    }\n+\n+    /**\n+     * @return The TRY node for the specified CATCH node.\n+     */\n+    private Node getTryForCatch(Node n) {\n+      return n.getParent().getParent();\n+    }\n+\n+    /**\n+     * @return Whether the a line break should be added after the specified\n+     * BLOCK.\n+     */\n+    @Override\n+    boolean breakAfterBlockFor(Node n,  boolean isStatementContext) {\n+      Preconditions.checkState(n.getType() == Token.BLOCK);\n+      Node parent = n.getParent();\n+      if (parent != null) {\n+        int type = parent.getType();\n+        switch (type) {\n+          case Token.DO:\n+            // Don't break before 'while' in DO-WHILE statements.\n+            return false;\n+          case Token.FUNCTION:\n+            // FUNCTIONs are handled separately, don't break here.\n+            return false;\n+          case Token.TRY:\n+            // Don't break before catch\n+            return n != parent.getFirstChild();\n+          case Token.CATCH:\n+            // Don't break before finally\n+            return !NodeUtil.hasFinally(getTryForCatch(parent));\n+          case Token.IF:\n+            // Don't break before else\n+            return n == parent.getLastChild();\n+        }\n+      }\n       return true;\n     }\n   }\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n \n         // Add label\n         Node label = new Node(Token.LABEL);\n-        Node name = Node.newString(Token.NAME, labelName);\n+        Node name = Node.newString(Token.LABEL_NAME, labelName);\n         label.addChildToFront(name);\n         label.addChildToBack(block);\n \n       Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n \n       Node resultNode = getReplacementReturnStatement(current, resultName);\n-      Node name = Node.newString(Token.NAME, labelName);\n+      Node name = Node.newString(Token.LABEL_NAME, labelName);\n       Node breakNode = new Node(Token.BREAK, name);\n \n       // Replace the node in parent, and reset current to the first new child.\n--- a/src/com/google/javascript/jscomp/GatherRawExports.java\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n   private boolean isGlobalThisObject(NodeTraversal t, Node n) {\n     if (n.getType() == Token.THIS) {\n       return t.inGlobalScope();\n-    } else if (n.getType() == Token.NAME && !NodeUtil.isLabelName(n)) {\n+    } else if (n.getType() == Token.NAME) {\n       String varName = n.getString();\n       if (varName.equals(GLOBAL_THIS_NAME)) {\n         return true;\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    *       function parameter (not a label or a empty anonymous function name).\n    */\n   static boolean isReferenceName(Node n) {\n-    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);\n+    return isName(n) && !n.getString().isEmpty();\n   }\n \n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\n-    if (n != null && n.getType() == Token.NAME) {\n-      Node parent = n.getParent();\n-      switch (parent.getType()) {\n-        case Token.LABEL:\n-        case Token.BREAK:\n-        case Token.CONTINUE:\n-          if (n == parent.getFirstChild()) {\n-            return true;\n-          }\n-      }\n-    }\n-    return false;\n+    return (n != null && n.getType() == Token.LABEL_NAME);\n   }\n \n   /** Whether the child node is the FINALLY block of a try. */\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n     if (n.getType() == Token.WITH) {\n       t.report(n, WITH_DISALLOWED);\n     } else if (n.getType() == Token.NAME) {\n-      if (!NodeUtil.isLabelName(n) && !isDeclaration(n)) {\n+      if (!isDeclaration(n)) {\n         checkNameUse(t, n);\n       }\n     } else if (n.getType() == Token.ASSIGN) {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n \n       // These nodes have no interesting type behavior.\n       case Token.LABEL:\n+      case Token.LABEL_NAME:\n       case Token.SWITCH:\n       case Token.BREAK:\n       case Token.CATCH:\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n   /** {@inheritDoc} */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() != Token.NAME) {\n-      return;\n-    }\n-\n-    if (NodeUtil.isLabelName(n)) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     Node processBreakStatement(BreakStatement statementNode) {\n       Node node = new Node(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n-        node.addChildToBack(transform(statementNode.getBreakLabel()));\n+        Node labelName = transform(statementNode.getBreakLabel());\n+        // Change the NAME to LABEL_NAME\n+        labelName.setType(Token.LABEL_NAME);\n+        node.addChildToBack(labelName);\n       }\n       return node;\n     }\n     Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = new Node(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n-        node.addChildToBack(transform(statementNode.getLabel()));\n+        Node labelName = transform(statementNode.getLabel());\n+        // Change the NAME to LABEL_NAME\n+        labelName.setType(Token.LABEL_NAME);\n+        node.addChildToBack(labelName);\n       }\n       return node;\n     }\n \n     @Override\n     Node processLabel(Label labelNode) {\n-      return Node.newString(Token.NAME, labelNode.getName());\n+      return Node.newString(Token.LABEL_NAME, labelNode.getName());\n     }\n \n     @Override\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         SETCONST       = 150,\n         SETCONSTVAR    = 151,\n         DEBUGGER       = 152,\n-        LAST_TOKEN     = 152,\n+        \n+        // JSCompiler introduced tokens\n+        LABEL_NAME     = 153,\n+        \n+        LAST_TOKEN     = 153,\n \n         // JSDoc-only tokens\n         ANNOTATION     = 300,\n           case SETELEM:         return \"SETELEM\";\n           case CALL:            return \"CALL\";\n           case NAME:            return \"NAME\";\n+          case LABEL_NAME:      return \"LABEL_NAME\";\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case NULL:            return \"NULL\";\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrettyPrint(\"if (1) {alert(\\\"\\\");}\",\n         \"if(1) {\\n\" +\n         \"  alert(\\\"\\\")\\n\" +\n-        \"}\");\n+        \"}\\n\");\n     assertPrettyPrint(\"if (1)alert(\\\"\\\");\",\n         \"if(1) {\\n\" +\n         \"  alert(\\\"\\\")\\n\" +\n-        \"}\");\n+        \"}\\n\");\n     assertPrettyPrint(\"if (1) {alert();alert();}\",\n         \"if(1) {\\n\" +\n         \"  alert();\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     // Don't add blocks if they weren't there already.\n     assertPrettyPrint(\"label: alert();\",\n     assertPrettyPrint(\"if (1) alert();\",\n         \"if(1) {\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n     assertPrettyPrint(\"for (;;) alert();\",\n         \"for(;;) {\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     assertPrettyPrint(\"while (1) alert();\",\n         \"while(1) {\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     // Do we put else clauses in blocks?\n     assertPrettyPrint(\"if (1) {} else {alert(a);}\",\n-        \"if(1);else {\\n  alert(a)\\n}\");\n+        \"if(1);else {\\n  alert(a)\\n}\\n\");\n \n     // Do we add blocks to else clauses?\n     assertPrettyPrint(\"if (1) alert(a); else alert(b);\",\n         \"  alert(a)\\n\" +\n         \"}else {\\n\" +\n         \"  alert(b)\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     // Do we put for bodies in blocks?\n     assertPrettyPrint(\"for(;;) { alert();}\",\n         \"for(;;) {\\n\" +\n          \"  alert()\\n\" +\n-         \"}\");\n+         \"}\\n\");\n     assertPrettyPrint(\"for(;;) {}\",\n         \"for(;;);\");\n     assertPrettyPrint(\"for(;;) { alert(); alert(); }\",\n         \"for(;;) {\\n\" +\n         \"  alert();\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     // How about do loops?\n     assertPrettyPrint(\"do { alert(); } while(true);\",\n     assertPrettyPrint(\"myLabel: { alert();}\",\n         \"myLabel: {\\n\" +\n         \"  alert()\\n\" +\n-        \"}\");\n+        \"}\\n\");\n \n     // Don't move the label on a loop, because then break {label} and\n     // continue {label} won't work.\n     assertPrettyPrint(\"myLabel: for(;;) continue myLabel;\",\n         \"myLabel:for(;;) {\\n\" +\n         \"  continue myLabel\\n\" +\n-        \"}\");\n+        \"}\\n\");\n+  }\n+\n+  public void testPrettyPrinter2() {\n+    assertPrettyPrint(\n+        \"if(true) f();\",\n+        \"if(true) {\\n\" +\n+        \"  f()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"if (true) { f() } else { g() }\",\n+        \"if(true) {\\n\" +\n+        \"  f()\\n\" +\n+        \"}else {\\n\" +\n+        \"  g()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"if(true) f(); for(;;) g();\",\n+        \"if(true) {\\n\" +\n+        \"  f()\\n\" +\n+        \"}\\n\" +\n+        \"for(;;) {\\n\" +\n+        \"  g()\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testPrettyPrinter3() {\n+    assertPrettyPrint(\n+        \"try {} catch(e) {}if (1) {alert();alert();}\",\n+        \"try {\\n\" +\n+        \"}catch(e) {\\n\" +\n+        \"}\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert();\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"try {} finally {}if (1) {alert();alert();}\",\n+        \"try {\\n\" +\n+        \"}finally {\\n\" +\n+        \"}\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert();\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"try {} catch(e) {} finally {} if (1) {alert();alert();}\",\n+        \"try {\\n\" +\n+        \"}catch(e) {\\n\" +\n+        \"}finally {\\n\" +\n+        \"}\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert();\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testPrettyPrinter4() {\n+    assertPrettyPrint(\n+        \"function f() {}if (1) {alert();}\",\n+        \"function f() {\\n\" +\n+        \"}\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"var f = function() {};if (1) {alert();}\",\n+        \"var f = function() {\\n\" +\n+        \"};\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"(function() {})();if (1) {alert();}\",\n+        \"(function() {\\n\" +\n+        \"})();\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");\n+\n+    assertPrettyPrint(\n+        \"(function() {alert();alert();})();if (1) {alert();}\",\n+        \"(function() {\\n\" +\n+        \"  alert();\\n\" +\n+        \"  alert()\\n\" +\n+        \"})();\\n\" +\n+        \"if(1) {\\n\" +\n+        \"  alert()\\n\" +\n+        \"}\\n\");    \n   }\n \n   public void testTypeAnnotations() {\n         \"a.Foo.prototype.foo = function() {\\n\" +\n         \"}\");\n   }\n-  \n+\n   public void testU2UFunctionTypeAnnotation() {\n     assertTypeAnnotations(\n         \"/** @type {!Function} */ var x = function() {}\",\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     parse(\"do { a() } while (b());\");\n   }\n \n-  public void testLabel() {\n+  // The old and new parser produce different results now with labels, and\n+  // named breaks and continues, so disable these tests.\n+  public void disable_testLabel() {\n     parse(\"foo: bar\");\n   }\n \n-  public void testLabel2() {\n+  public void disable_testLabel2() {\n     parse(\"l: while (f()) { if (g()) { continue l; } }\");\n   }\n \n-  public void testLabel3() {\n+  public void disable_testLabel3() {\n     parse(\"Foo:Bar:X:{ break Bar; }\");\n   }\n ", "timestamp": 1270495823, "metainfo": ""}