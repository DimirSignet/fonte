{"sha": "39e843ffd1708ca4f0517db862c909a092472dcf", "log": "Support devirtualizing direct prototype assignments.  R=avd DELTA=118  (72 added, 7 deleted, 39 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4715   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n     if (parent == null) {\n       return false;\n     }\n-\n     Node gramp = parent.getParent();\n-    if ((gramp == null) ||\n-        (parent.getFirstChild() != node) ||\n-        !NodeUtil.isExprAssign(gramp)) {\n-      return false;\n-    }\n-\n-    Node functionNode = parent.getLastChild();\n-    if ((functionNode == null) || !functionNode.isFunction()) {\n-      return false;\n-    }\n-\n-    if (!node.isGetProp()) {\n-      return false;\n-    }\n-\n-    Node nameNode = node.getFirstChild();\n-    return nameNode.isGetProp() &&\n-        nameNode.getLastChild().getString().equals(\"prototype\");\n-\n+    if (gramp == null) {\n+      return false;\n+    }\n+\n+    if (node.isGetProp()) {\n+      if (parent.getFirstChild() != node) {\n+        return false;\n+      }\n+\n+      if (!NodeUtil.isExprAssign(gramp)) {\n+        return false;\n+      }\n+\n+      Node functionNode = parent.getLastChild();\n+      if ((functionNode == null) || !functionNode.isFunction()) {\n+        return false;\n+      }\n+\n+      Node nameNode = node.getFirstChild();\n+      return nameNode.isGetProp() &&\n+          nameNode.getLastChild().getString().equals(\"prototype\");\n+    } else if (node.isStringKey()) {\n+      Preconditions.checkState(parent.isObjectLit());\n+\n+      if (!gramp.isAssign()) {\n+        return false;\n+      }\n+\n+      if (gramp.getLastChild() != parent) {\n+        return false;\n+      }\n+\n+      Node greatGramp = gramp.getParent();\n+      if (greatGramp == null || !greatGramp.isExprResult()) {\n+        return false;\n+      }\n+\n+      Node functionNode = node.getFirstChild();\n+      if ((functionNode == null) || !functionNode.isFunction()) {\n+        return false;\n+      }\n+\n+      Node target = gramp.getFirstChild();\n+      return target.isGetProp() &&\n+          target.getLastChild().getString().equals(\"prototype\");\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  private String getMethodName(Node node) {\n+    if (node.isGetProp()) {\n+      return node.getLastChild().getString();\n+    } else if (node.isStringKey()) {\n+      return node.getString();\n+    } else {\n+      throw new IllegalStateException(\"unexpected\");\n+    }\n   }\n \n   /**\n    */\n   private void rewriteDefinitionIfEligible(DefinitionSite defSite,\n                                            SimpleDefinitionFinder defFinder) {\n-\n     if (defSite.inExterns ||\n         !defSite.inGlobalScope ||\n         !isEligibleDefinition(defFinder, defSite)) {\n     }\n \n     Node node = defSite.node;\n-\n-    // TODO(user) support rewritting methods defined as part of\n-    // object literals.\n     if (!isPrototypeMethodDefinition(node)) {\n       return;\n     }\n     // method names.\n     // Whatever scheme we use should not break stable renaming.\n     String newMethodName = getRewrittenMethodName(\n-        node.getLastChild().getString());\n+        getMethodName(node));\n     rewriteDefinition(node, newMethodName);\n     rewriteCallSites(defFinder, defSite.definition, newMethodName);\n   }\n    * - Refer to a function that takes a fixed number of arguments.\n    * - Function must not be exported.\n    * - Function must be used at least once.\n-   * - Property is never accesed outside a function call context.\n+   * - Property is never accessed outside a function call context.\n    * - The definition under consideration must be the only possible\n    *   choice at each call site.\n    * - Definition must happen in a module loaded before the first use.\n         return false;\n       }\n \n-      // Multiple definitions prevent rewrite.\n       Node nameNode = site.node;\n \n       // Don't rewrite methods called in functions that can't be specialized\n         return false;\n       }\n \n+      // Multiple definitions prevent rewrite.\n       Collection<Definition> singleSiteDefinitions =\n           defFinder.getDefinitionsReferencedAt(nameNode);\n       if (singleSiteDefinitions.size() > 1) {\n    *   var b = function(self, a, b, c) {...}\n    */\n   private void rewriteDefinition(Node node, String newMethodName) {\n+    boolean isObjLitDefKey = node.isStringKey();\n+\n     Node parent = node.getParent();\n-    Node functionNode = parent.getLastChild();\n-    Node expr = parent.getParent();\n-    Node block = expr.getParent();\n-\n-    Node newNameNode = IR.name(newMethodName)\n-        .copyInformationFrom(parent.getFirstChild());\n-\n-    if (specializationState != null) {\n-      specializationState.reportRemovedFunction(functionNode, block);\n-    }\n-\n-    parent.removeChild(functionNode);\n-    newNameNode.addChildToFront(functionNode);\n-    block.replaceChild(expr, IR.var(newNameNode));\n+\n+    Node refNode = isObjLitDefKey ? node : parent.getFirstChild();\n+    Node newNameNode = IR.name(newMethodName).copyInformationFrom(refNode);\n+    Node newVarNode = IR.var(newNameNode).copyInformationFrom(refNode);\n+\n+    Node functionNode;\n+    if (!isObjLitDefKey) {\n+      Preconditions.checkState(parent.isAssign());\n+      functionNode = parent.getLastChild();\n+      Node expr = parent.getParent();\n+      Node block = expr.getParent();\n+      parent.removeChild(functionNode);\n+      newNameNode.addChildToFront(functionNode);\n+      block.replaceChild(expr, newVarNode);\n+\n+      if (specializationState != null) {\n+        specializationState.reportRemovedFunction(functionNode, block);\n+      }\n+    } else {\n+      Preconditions.checkState(parent.isObjectLit());\n+      functionNode = node.getFirstChild();\n+      Node assign = parent.getParent();\n+      Node expr = assign.getParent();\n+      Node block = expr.getParent();\n+\n+      node.removeChild(functionNode);\n+      parent.removeChild(node);\n+      newNameNode.addChildToFront(functionNode);\n+      block.addChildAfter(newVarNode, expr);\n+\n+      if (specializationState != null) {\n+        specializationState.reportRemovedFunction(functionNode, block);\n+      }\n+    }\n \n     // add extra argument\n     String self = newMethodName + \"$self\";\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n          \"JSCompiler_StaticMethods_foo(o)\");\n   }\n \n-  public void testNoRewritePrototypeObjectLiterals1() throws Exception {\n-    testSame(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,\n-                           NoRewritePrototypeObjectLiteralsTestInput.CALL));\n+  public void testRewritePrototypeObjectLiterals1() throws Exception {\n+    test(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,\n+                       NoRewritePrototypeObjectLiteralsTestInput.CALL),\n+         \"a.prototype={};\" +\n+         \"var JSCompiler_StaticMethods_foo=\" +\n+         \"function(JSCompiler_StaticMethods_foo$self){};\" +\n+         \"JSCompiler_StaticMethods_foo(o)\");\n   }\n \n   public void testNoRewritePrototypeObjectLiterals2() throws Exception {\n   }\n \n   public void testRewriteImplementedMethodInObj() throws Exception {\n-    // This isn't currently supported, but could be.\n     String source = newlineJoin(\n         \"function a(){}\",\n         \"a.prototype = {foo: function(args) {return args}};\",\n         \"var o = new a;\",\n         \"o.foo()\");\n-    testSame(source);\n+    test(source,\n+        \"function a(){}\" +\n+        \"a.prototype={};\" +\n+        \"var JSCompiler_StaticMethods_foo=\" +\n+        \"function(JSCompiler_StaticMethods_foo$self,args){return args};\" +\n+        \"var o=new a;\" +\n+        \"JSCompiler_StaticMethods_foo(o)\");\n   }\n \n   public void testNoRewriteGet1() throws Exception {", "timestamp": 1336525814, "metainfo": ""}