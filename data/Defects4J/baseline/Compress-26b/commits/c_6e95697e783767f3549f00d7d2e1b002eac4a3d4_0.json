{"sha": "6e95697e783767f3549f00d7d2e1b002eac4a3d4", "log": "Move data that is used for sorting only to BlockSort class  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n      * All memory intensive stuff.\n      */\n     private Data data;\n+    private BlockSort blockSorter;\n \n     private OutputStream out;\n \n             } finally {\n                 this.out = null;\n                 this.data = null;\n+                this.blockSorter = null;\n             }\n         }\n     }\n         bsPutUByte('Z');\n \n         this.data = new Data(this.blockSize100k);\n+        this.blockSorter = new BlockSort(this.data);\n \n         // huffmanised magic bytes\n         bsPutUByte('h');\n     }\n \n     private boolean blockSort() {\n-        return new BlockSort().blockSort(data, last);\n+        return blockSorter.blockSort(data, last);\n     }\n \n     private void generateMTFValues() {\n         final byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte\n         final boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte\n \n-        final int[] stack_ll = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n-        final int[] stack_hh = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n-        final int[] stack_dd = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n-\n-        final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n-        final int[] mainSort_copy = new int[256]; // 1024 byte\n-        final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\n-\n         final int[] heap = new int[MAX_ALPHA_SIZE + 2]; // 1040 byte\n         final int[] weight = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\n         final int[] parent = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\n \n-        final int[] ftab = new int[65537]; // 262148 byte\n         // ------------\n         // 333408 byte\n \n         // ============\n \n         /**\n-         * Array instance identical to sfmap, both are used only\n-         * temporarily and indepently, so we do not need to allocate\n-         * additional memory.\n-         */\n-        final char[] quadrant;\n-\n-        /**\n          * Index in fmap[] of original string after sorting.\n          */\n         int origPtr;\n             this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\n             this.fmap = new int[n];\n             this.sfmap = new char[2 * n];\n-            this.quadrant = this.sfmap;\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n      * try again. In practice I have never seen the stack go above 27\n      * elems, so the following limit seems very generous.  </p>\n      */\n-    static final int QSORT_STACK_SIZE = 1000;\n+    private static final int QSORT_STACK_SIZE = 1000;\n \n     /**\n      * Knuth's increments seem to work better than Incerpi-Sedgewick here.\n     private int workDone;\n     private int workLimit;\n     private boolean firstAttempt;\n+\n+    private final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n+    private final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n+    private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n+\n+    private final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n+    private final int[] mainSort_copy = new int[256]; // 1024 byte\n+    private final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\n+\n+    private final int[] ftab = new int[65537]; // 262148 byte\n+\n+    /**\n+     * Array instance identical to Data's sfmap, both are used only\n+     * temporarily and indepently, so we do not need to allocate\n+     * additional memory.\n+     */\n+    private final char[] quadrant;\n+\n+    BlockSort(final BZip2CompressorOutputStream.Data data) {\n+        this.quadrant = data.sfmap;\n+    }\n \n     /**\n      * This is the most hammered method of this class.\n         }\n \n         final int[] fmap = dataShadow.fmap;\n-        final char[] quadrant = dataShadow.quadrant;\n+        final char[] quadrant = this.quadrant;\n         final byte[] block = dataShadow.block;\n         final int lastPlus1 = lastShadow + 1;\n         final boolean firstAttemptShadow = this.firstAttempt;\n     private void mainQSort3(final BZip2CompressorOutputStream.Data dataShadow,\n                             final int loSt, final int hiSt, final int dSt,\n                             final int last) {\n-        final int[] stack_ll = dataShadow.stack_ll;\n-        final int[] stack_hh = dataShadow.stack_hh;\n-        final int[] stack_dd = dataShadow.stack_dd;\n+        final int[] stack_ll = this.stack_ll;\n+        final int[] stack_hh = this.stack_hh;\n+        final int[] stack_dd = this.stack_dd;\n         final int[] fmap = dataShadow.fmap;\n         final byte[] block = dataShadow.block;\n \n \n     private void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                           final int lastShadow) {\n-        final int[] runningOrder = dataShadow.mainSort_runningOrder;\n-        final int[] copy = dataShadow.mainSort_copy;\n-        final boolean[] bigDone = dataShadow.mainSort_bigDone;\n-        final int[] ftab = dataShadow.ftab;\n+        final int[] runningOrder = this.mainSort_runningOrder;\n+        final int[] copy = this.mainSort_copy;\n+        final boolean[] bigDone = this.mainSort_bigDone;\n+        final int[] ftab = this.ftab;\n         final byte[] block = dataShadow.block;\n         final int[] fmap = dataShadow.fmap;\n-        final char[] quadrant = dataShadow.quadrant;\n+        final char[] quadrant = this.quadrant;\n         final int workLimitShadow = this.workLimit;\n         final boolean firstAttemptShadow = this.firstAttempt;\n ", "timestamp": 1335857589, "metainfo": ""}