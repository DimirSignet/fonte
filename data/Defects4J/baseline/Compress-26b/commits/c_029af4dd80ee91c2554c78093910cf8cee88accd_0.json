{"sha": "029af4dd80ee91c2554c78093910cf8cee88accd", "log": "extract the old encoding/decoding methods into a ZipEncoding implementation and use ZipEncoding consistently  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n     static final ZipEncoding DEFAULT_ENCODING =\n         ZipEncodingHelper.getZipEncoding(null);\n \n+    /**\n+     * Encapsulates the algorithms used up to Commons Compress 1.3 as\n+     * ZipEncoding.\n+     */\n+    private static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n+            public boolean canEncode(String name) { return true; }\n+\n+            public ByteBuffer encode(String name) {\n+                final int length = name.length();\n+                byte[] buf = new byte[length];\n+\n+                // copy until end of input or output is reached.\n+                for (int i = 0; i < length; ++i) {\n+                    buf[i] = (byte) name.charAt(i);\n+                }\n+                return ByteBuffer.wrap(buf);\n+            }\n+\n+            public String decode(byte[] buffer) {\n+                final int length = buffer.length;\n+                StringBuffer result = new StringBuffer(length);\n+\n+                for (int i = 0; i < length; ++i) {\n+                    byte b = buffer[i];\n+                    if (b == 0) { // Trailing null\n+                        break;\n+                    }\n+                    result.append((char) (b & 0xFF)); // Allow for sign-extension\n+                }\n+\n+                return result.toString();\n+            }\n+        };\n+\n     /** Private constructor to prevent instantiation of this utility class. */\n     private TarUtils(){    \n     }\n         try {\n             return parseName(buffer, offset, length, DEFAULT_ENCODING);\n         } catch (IOException ex) {\n-            return parseNameFallback(buffer, offset, length);\n-        }\n-    }\n-\n-    /*\n-     * Used if default encoding cannot encode name and no explicit\n-     * encoding has been specified.\n-     */\n-    private static String parseNameFallback(byte[] buffer, final int offset,\n-                                            final int length) {\n-        StringBuffer result = new StringBuffer(length);\n-        int          end = offset + length;\n-\n-        for (int i = offset; i < end; ++i) {\n-            byte b = buffer[i];\n-            if (b == 0) { // Trailing null\n-                break;\n-            }\n-            result.append((char) (b & 0xFF)); // Allow for sign-extension\n-        }\n-\n-        return result.toString();\n+            try {\n+                return parseName(buffer, offset, length, FALLBACK_ENCODING);\n+            } catch (IOException ex2) {\n+                // impossible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n     }\n \n     /**\n         try {\n             return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n         } catch (IOException ex) {\n-            return formatNameBytesFallback(name, buf, offset, length);\n-        }\n-    }\n-\n-    /*\n-     * Used if default encoding cannot format name and no explicit encoding\n-     * has been specified.\n-     */\n-    private static int formatNameBytesFallback(String name, byte[] buf,\n-                                               final int offset,\n-                                               final int length) {\n-        int i;\n-\n-        // copy until end of input or output is reached.\n-        for (i = 0; i < length && i < name.length(); ++i) {\n-            buf[offset + i] = (byte) name.charAt(i);\n-        }\n-\n-        // Pad any remaining output bytes with NUL\n-        for (; i < length; ++i) {\n-            buf[offset + i] = 0;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Copy a name (StringBuffer) into a buffer.\n+            try {\n+                return formatNameBytes(name, buf, offset, length,\n+                                       FALLBACK_ENCODING);\n+            } catch (IOException ex2) {\n+                // impossible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy a name into a buffer.\n      * Copies characters from the name into the buffer\n      * starting at the specified offset. \n      * If the buffer is longer than the name, the buffer\n \n         return sum;\n     }\n+\n }", "timestamp": 1332274129, "metainfo": ""}