{"sha": "ae3c158e05af20843fb5ea72deb5b7fb1fefbd54", "log": "Attempt at Javadoc - needs refining...  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n     private static final int BYTE_MASK = 255;\n \n     /**\n-     * Parse an octal string from a header buffer. This is used for the\n-     * file permission mode value.\n-     *\n-     * @param header The header buffer from which to parse.\n+     * Parse an octal string from a buffer.\n+     * Leading spaces are ignored.\n+     * Parsing stops when a NUL is found, or a trailing space,\n+     * or the buffer length is reached.\n+     *\n+     * @param buffer The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n+     * @param length The maximum number of bytes to parse.\n      * @return The long value of the octal string.\n      */\n-    public static long parseOctal(byte[] header, int offset, int length) {\n+    public static long parseOctal(byte[] buffer, int offset, int length) {\n         long    result = 0;\n         boolean stillPadding = true;\n         int     end = offset + length;\n \n         for (int i = offset; i < end; ++i) {\n-            if (header[i] == 0) {\n+            if (buffer[i] == 0) { // Found trailing null\n                 break;\n             }\n \n-            if (header[i] == (byte) ' ' || header[i] == '0') {\n+            // Ignore leading spaces ('0' can be ignored anyway)\n+            if (buffer[i] == (byte) ' ' || buffer[i] == '0') {\n                 if (stillPadding) {\n                     continue;\n                 }\n \n-                if (header[i] == (byte) ' ') {\n+                if (buffer[i] == (byte) ' ') { // Found trailing space\n                     break;\n                 }\n             }\n \n             stillPadding = false;\n             // CheckStyle:MagicNumber OFF\n-            result = (result << 3) + (header[i] - '0');\n+            result = (result << 3) + (buffer[i] - '0');// TODO needs to reject invalid bytes\n             // CheckStyle:MagicNumber ON\n         }\n \n     }\n \n     /**\n-     * Parse an entry name from a header buffer.\n-     *\n-     * @param header The header buffer from which to parse.\n+     * Parse an entry name from a buffer.\n+     * Parsing stops when a NUL is found\n+     * or the buffer length is reached.\n+     *\n+     * @param buffer The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The header's entry name.\n-     */\n-    public static StringBuffer parseName(byte[] header, int offset, int length) {\n+     * @param length The maximum number of bytes to parse.\n+     * @return The entry name.\n+     */\n+    public static StringBuffer parseName(byte[] buffer, int offset, int length) {\n         StringBuffer result = new StringBuffer(length);\n         int          end = offset + length;\n \n         for (int i = offset; i < end; ++i) {\n-            if (header[i] == 0) {\n+            if (buffer[i] == 0) { // Trailing null\n                 break;\n             }\n \n-            result.append((char) header[i]);\n+            result.append((char) buffer[i]);\n         }\n \n         return result;\n     }\n \n     /**\n-     * Determine the number of bytes in an entry name.\n-     *\n-     * @param name The header name from which to parse.\n-     * @param buf The buffer from which to parse.\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The number of bytes in a header's entry name.\n+     * Copy a name (StringBuffer) into a buffer.\n+     * Copies characters from the name into the buffer\n+     * starting at the specified offset. \n+     * If the buffer is longer than the name, the buffer\n+     * is filled with trailing NULs.\n+     * If the name is longer than the buffer,\n+     * the output is truncated.\n+     *\n+     * @param name The header name from which to copy the characters.\n+     * @param buf The buffer where the name is to be stored.\n+     * @param offset The starting offset into the buffer\n+     * @param length The maximum number of header bytes to copy.\n+     * @return The updated offset, i.e. offset + length\n      */\n     public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {\n         int i;\n \n+        // copy until end of input or output is reached.\n         for (i = 0; i < length && i < name.length(); ++i) {\n             buf[offset + i] = (byte) name.charAt(i);\n         }\n \n+        // Pad any remaining output bytes with NUL\n         for (; i < length; ++i) {\n             buf[offset + i] = 0;\n         }\n     }\n \n     /**\n-     * Parse an octal integer from a header buffer.\n-     *\n-     * @param value The header value\n-     * @param buf The buffer from which to parse.\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The integer value of the octal bytes.\n+     * Write an octal integer into a buffer.\n+     *\n+     * Adds a trailing space and NUL to end of the buffer.\n+     * Converts the long value (assumed positive) to the buffer.\n+     * Adds leading spaces to the buffer.\n+     * \n+     * @param value The value to write\n+     * @param buf The buffer to receive the output\n+     * @param offset The starting offset into the buffer\n+     * @param length The size of the output buffer\n+     * @return The updated offset, i.e offset+length\n      */\n     public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n         int    idx = length - 1;\n \n-        buf[offset + idx] = 0;\n+        buf[offset + idx] = 0; // Trailing null\n         --idx;\n-        buf[offset + idx] = (byte) ' ';\n+        buf[offset + idx] = (byte) ' '; // Trailing space TODO - why??\n         --idx;\n \n         if (value == 0) {\n             }\n         }\n \n-        for (; idx >= 0; --idx) {\n+        for (; idx >= 0; --idx) { // leading spaces\n             buf[offset + idx] = (byte) ' ';\n         }\n \n     }\n \n     /**\n-     * Parse an octal long integer from a header buffer.\n-     *\n-     * @param value The header value\n-     * @param buf The buffer from which to parse.\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The long value of the octal bytes.\n+     * Write an octal long integer into a buffer.\n+     *\n+     * @param value The value to write as octal\n+     * @param buf The destinationbuffer.\n+     * @param offset The starting offset into the buffer.\n+     * @param length The length of the buffer\n+     * @return The updated offset\n      */\n     public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n         byte[] temp = new byte[length + 1];\n     }\n \n     /**\n-     * Parse the checksum octal integer from a header buffer.\n-     *\n-     * @param value The header value\n-     * @param buf The buffer from which to parse.\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The integer value of the entry's checksum.\n+     * Writes an octal value into a buffer.\n+     *\n+     * TODO document fully. How does it differ from getOctalBytes?\n+     *\n+     * @param value The value to convert\n+     * @param buf The destination buffer\n+     * @param offset The starting offset into the buffer.\n+     * @param length The size of the buffer.\n+     * @return The updated value of offset, i.e. offset+length\n      */\n     public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n         getOctalBytes(value, buf, offset, length);", "timestamp": 1238516668, "metainfo": ""}