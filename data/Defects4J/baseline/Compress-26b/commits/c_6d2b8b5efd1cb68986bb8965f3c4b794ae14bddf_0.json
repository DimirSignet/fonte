{"sha": "6d2b8b5efd1cb68986bb8965f3c4b794ae14bddf", "log": "ZIP64 support for writing big archive entries in the most simple of the seven possible permutations: no compression + stream + size known upfront.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private static final byte[] LZERO = {0, 0, 0, 0};\n \n     /**\n-     * Helper, a 0 as ZipEightByteInteger.\n-     */\n-    private static final byte[] DLZERO = {0, 0, 0, 0, 0, 0, 0, 0};\n-\n-    /**\n      * Holds the offsets of the LFH starts for each entry.\n      */\n     private final Map<ZipArchiveEntry, Long> offsets =\n                                        + \" method when not writing to a file\");\n             }\n             entry.setCompressedSize(entry.getSize());\n+        }\n+\n+        // add a ZIP64 extended information extra field if we already\n+        // know it is going to be needed\n+        if (entry.getSize() >= ZIP64_MAGIC\n+            || entry.getCompressedSize() >= ZIP64_MAGIC) {\n+\n+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry);\n+            if (entry.getMethod() == STORED) {\n+                ZipEightByteInteger size =\n+                    new ZipEightByteInteger(entry.getSize());\n+                z64.setSize(size);\n+                z64.setCompressedSize(size);\n+            } else {\n+                // just a placeholder, real data will be in data\n+                // descriptor or inserted later via RandomAccessFile\n+                z64.setSize(ZipEightByteInteger.ZERO);\n+                z64.setCompressedSize(ZipEightByteInteger.ZERO);\n+            }\n+            entry.setExtra();\n         }\n \n         if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n                                                          && fallbackToUTF8,\n-                                                         false);\n+                                                         hasZip64Extra(ze));\n         written += WORD;\n \n         // compression method\n             writeOut(LZERO);\n         } else {\n             writeOut(ZipLong.getBytes(ze.getCrc()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n+            byte[] size = ZipLong.getBytes(Math.min(ze.getSize(), ZIP64_MAGIC));\n+            writeOut(size);\n+            writeOut(size);\n         }\n         // CheckStyle:MagicNumber OFF\n         written += 12;\n             ze.getExtraField(Zip64ExtendedInformationExtraField\n                              .HEADER_ID);\n         if (z64 == null) {\n+            /*\n+            System.err.println(\"Adding z64 for \" + ze.getName()\n+                               + \", method: \" + ze.getMethod()\n+                               + \" (\" + (ze.getMethod() == STORED) + \")\"\n+                               + \", raf: \" + (raf != null));\n+            */\n             z64 = new Zip64ExtendedInformationExtraField();\n-            ze.addExtraField(z64);\n+            ze.addAsFirstExtraField(z64);\n         }\n         return z64;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n     private static final byte LEFTMOST_BIT = (byte) 0x80;\n \n     private final BigInteger value;\n+\n+    public static ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n \n     /**\n      * Create instance from a number.\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n                     a.close();\n                 }\n             }\n-\n         };\n \n     @Ignore\n     @Test public void write3EntriesCreatingBigArchiveStream() throws Throwable {\n         withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\",\n                              write3EntriesCreatingBigArchive,\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written without\n+     * compression to a stream.\n+     *\n+     * No Compression + Stream => sizes must be known before data is\n+     * written and are stored directly inside the LFH.  No Data\n+     * Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */\n+    @Test public void writeBigStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStream\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     byte[] buf = new byte[1000 * 1000];\n+                                     ZipArchiveEntry zae =\n+                                         new ZipArchiveEntry(\"0\");\n+                                     zae.setSize(FIVE_BILLION);\n+                                     zae.setMethod(ZipArchiveEntry.STORED);\n+                                     zae.setCrc(0x5c316f50L);\n+                                     zos.putArchiveEntry(zae);\n+                                     for (int j = 0;\n+                                          j < FIVE_BILLION / 1000 / 1000;\n+                                          j++) {\n+                                         zos.write(buf);\n+                                     }\n+                                     zos.closeArchiveEntry();\n+                                     zos.close();\n+\n+                                     RandomAccessFile a =\n+                                         new RandomAccessFile(f, \"r\");\n+                                     try {\n+                                         final long end = a.length();\n+                                         long cdOffsetLoc = end - 22\n+                                             - 20\n+                                             - 56\n+                                             + 48;\n+                                         // seek to central directory\n+                                         a.seek(cdOffsetLoc);\n+                                         byte[] cdOffset = new byte[8];\n+                                         a.readFully(cdOffset);\n+                                         a.seek(ZipEightByteInteger\n+                                                .getLongValue(cdOffset));\n+\n+                                         // grab first entry, verify\n+                                         // sizes are 0xFFFFFFFF and\n+                                         // it has a ZIP64 extended\n+                                         // information extra field\n+                                         byte[] header = new byte[8];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                                 // version made by\n+                                                 45, 0,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                             }, header);\n+                                         // ignore GPB, method, timestamp\n+                                         a.skipBytes(8);\n+                                         byte[] rest = new byte[31];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // comment length\n+                                                 0, 0,\n+                                                 // disk number\n+                                                 0, 0,\n+                                                 // attributes\n+                                                 0, 0,\n+                                                 0, 0, 0, 0,\n+                                                 // offset\n+                                                 0, 0, 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         byte[] extra = new byte[20];\n+                                         a.readFully(extra);\n+                                         // 5e9 == 0x12A05F200\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                                 // compressed size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                             }, extra);\n+\n+                                         // and now validate local file header\n+                                         a.seek(0);\n+                                         header = new byte[6];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                             }, header);\n+                                         // ignore GPB, method, timestamp\n+                                         a.skipBytes(8);\n+                                         rest = new byte[17];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         a.readFully(extra);\n+                                         // 5e9 == 0x12A05F200\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                                 // compressed size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                             }, extra);\n+                                     } finally {\n+                                         a.close();\n+                                     }\n+                                 }\n+                             },\n                              false);\n     }\n ", "timestamp": 1312006644, "metainfo": ""}