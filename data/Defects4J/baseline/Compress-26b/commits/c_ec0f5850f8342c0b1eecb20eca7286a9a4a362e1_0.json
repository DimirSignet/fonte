{"sha": "ec0f5850f8342c0b1eecb20eca7286a9a4a362e1", "log": "COMPRESS-159 make ChangeSetPerformer work on ZipFiles as well  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.util.Enumeration;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Set;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipFile;\n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n      */\n     public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n             throws IOException {\n+        return perform(new ArchiveInputStreamIterator(in), out);\n+    }\n+\n+    /**\n+     * Performs all changes collected in this ChangeSet on the ZipFile and\n+     * streams the result to the output stream. Perform may be called more than once.\n+     * \n+     * This method finishes the stream, no other entries should be added\n+     * after that.\n+     * \n+     * @param in\n+     *            the ZipFile to perform the changes on\n+     * @param out\n+     *            the resulting OutputStream with all modifications\n+     * @throws IOException\n+     *             if an read/write error occurs\n+     * @return the results of this operation\n+     */\n+    public ChangeSetResults perform(ZipFile in, ArchiveOutputStream out)\n+            throws IOException {\n+        return perform(new ZipFileIterator(in), out);\n+    }\n+\n+    /**\n+     * Performs all changes collected in this ChangeSet on the input entries and\n+     * streams the result to the output stream.\n+     * \n+     * This method finishes the stream, no other entries should be added\n+     * after that.\n+     * \n+     * @param entryIterator\n+     *            the entries to perform the changes on\n+     * @param out\n+     *            the resulting OutputStream with all modifications\n+     * @throws IOException\n+     *             if an read/write error occurs\n+     * @return the results of this operation\n+     */\n+    private ChangeSetResults perform(ArchiveEntryIterator entryIterator,\n+                                     ArchiveOutputStream out)\n+            throws IOException {\n         ChangeSetResults results = new ChangeSetResults();\n \n         Set<Change> workingSet = new LinkedHashSet<Change>(changes);\n             }\n         }\n \n-        ArchiveEntry entry = null;\n-        while ((entry = in.getNextEntry()) != null) {\n+        while (entryIterator.hasNext()) {\n+            ArchiveEntry entry = entryIterator.next();\n             boolean copy = true;\n \n             for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n             if (copy\n                 && !isDeletedLater(workingSet, entry)\n                 && !results.hasBeenAdded(entry.getName())) {\n-                copyStream(in, out, entry);\n+                copyStream(entryIterator.getInputStream(), out, entry);\n                 results.addedFromStream(entry.getName());\n             }\n         }\n         IOUtils.copy(in, out);\n         out.closeArchiveEntry();\n     }\n+\n+    /**\n+     * Used in perform to abstract out getting entries and streams for\n+     * those entries.\n+     *\n+     * <p>Iterator#hasNext is not allowed to throw exceptions that's\n+     * why we can't use Iterator&lt;ArchiveEntry&gt; directly -\n+     * otherwise we'd need to convert exceptions thrown in\n+     * ArchiveInputStream#getNextEntry.</p>\n+     */\n+    interface ArchiveEntryIterator {\n+        boolean hasNext() throws IOException;\n+        ArchiveEntry next();\n+        InputStream getInputStream() throws IOException;\n+    }\n+\n+    private static class ArchiveInputStreamIterator\n+        implements ArchiveEntryIterator {\n+        private final ArchiveInputStream in;\n+        private ArchiveEntry next;\n+        ArchiveInputStreamIterator(ArchiveInputStream in) {\n+            this.in = in;\n+        }\n+        public boolean hasNext() throws IOException {\n+            return (next = in.getNextEntry()) != null;\n+        }\n+        public ArchiveEntry next() {\n+            return next;\n+        }\n+        public InputStream getInputStream() {\n+            return in;\n+        }\n+    }\n+\n+    private static class ZipFileIterator\n+        implements ArchiveEntryIterator {\n+        private final ZipFile in;\n+        private final Enumeration<ZipArchiveEntry> nestedEnum;\n+        private ZipArchiveEntry current;\n+        ZipFileIterator(ZipFile in) throws IOException {\n+            this.in = in;\n+            nestedEnum = in.getEntriesInPhysicalOrder();\n+        }\n+        public boolean hasNext() {\n+            return nestedEnum.hasMoreElements();\n+        }\n+        public ArchiveEntry next() {\n+            return (current = nestedEnum.nextElement());\n+        }\n+        public InputStream getInputStream() throws IOException {\n+            return in.getInputStream(current);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n import org.apache.commons.compress.archivers.jar.JarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipFile;\n \n /**\n  * Checks several ChangeSet business logics.\n             ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+\n+        this.checkArchiveContent(result, archiveList);\n+    }\n+\n+    /**\n+     * Adds a file to a zip archive. Deletes an other file.\n+     * \n+     * @throws Exception\n+     */\n+    public void testDeleteFromAndAddToZipUsingZipFilePerform() throws Exception {\n+        final String archivename = \"zip\";\n+        File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ZipFile ais = null;\n+        File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            ais = new ZipFile(input);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            ChangeSet changes = new ChangeSet();\n+\n+            final File file1 = getFile(\"test.txt\");\n+            ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\n+            changes.add(entry, new FileInputStream(file1));\n+            archiveList.add(\"blub/test.txt\");\n+\n+            changes.delete(\"testdata/test1.xml\");\n+            archiveListDelete(\"testdata/test1.xml\");\n+\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n \n         } finally {\n             if (out != null) {", "timestamp": 1357065213, "metainfo": ""}