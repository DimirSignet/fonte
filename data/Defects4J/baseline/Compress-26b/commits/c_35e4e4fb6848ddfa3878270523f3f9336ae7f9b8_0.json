{"sha": "35e4e4fb6848ddfa3878270523f3f9336ae7f9b8", "log": "COMPRESS-113:  TarArchiveEntry.parseTarHeader() includes the trailing space/NUL when parsing the octal size  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n     /**\n      * Parse an octal string from a buffer.\n      * Leading spaces are ignored.\n-     * Parsing stops when a NUL is found, or a trailing space,\n-     * or the buffer length is reached.\n-     *\n-     * Behaviour with non-octal input is currently undefined.\n-     * \n+     * The buffer must contain a trailing space or NUL,\n+     * and may contain an additional trailing space or NUL.\n+     *\n+     * The input buffer is allowed to contain all NULs,\n+     * in which case the method returns 0L\n+     * (this allows for missing fields).\n+     *\n      * @param buffer The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n-     * @param length The maximum number of bytes to parse.\n+     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n      * @return The long value of the octal string.\n-     */\n-    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n+     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n+     */\n+    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n         long    result = 0;\n-        boolean stillPadding = true;\n         int     end = offset + length;\n-\n-        for (int i = offset; i < end; ++i) {\n-            final byte currentByte = buffer[i];\n-            if (currentByte == 0) { // Found trailing null\n+        int     start = offset;\n+\n+        if (length < 2){\n+            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n+        }\n+\n+        boolean allNUL = true;\n+        for (int i = start; i < end; i++){\n+            if (buffer[i] != 0){\n+                allNUL = false;\n                 break;\n             }\n-\n-            // Ignore leading spaces ('0' can be ignored anyway)\n-            if (currentByte == (byte) ' ' || currentByte == '0') {\n-                if (stillPadding) {\n-                    continue;\n-                }\n-\n-                if (currentByte == (byte) ' ') { // Found trailing space\n-                    break;\n-                }\n-            }\n-\n-            stillPadding = false;\n+        }\n+        if (allNUL) {\n+            return 0L;\n+        }\n+\n+        // Skip leading spaces\n+        while (start < end){\n+            if (buffer[start] == ' '){\n+                start++;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        // Must have trailing NUL or space\n+        byte trailer;\n+        trailer = buffer[end-1];\n+        if (trailer == 0 || trailer == ' '){\n+            end--;\n+        } else {\n+            throw new IllegalArgumentException(\n+                    exceptionMessage(buffer, offset, length, end-1, trailer));\n+        }\n+        // May have additional NUL or space\n+        trailer = buffer[end-1];\n+        if (trailer == 0 || trailer == ' '){\n+            end--;\n+        }\n+\n+        for ( ;start < end; start++) {\n+            final byte currentByte = buffer[start];\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException(\n-                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n-            }\n-            result = (result << 3) + (currentByte - '0');// TODO needs to reject invalid bytes\n+                        exceptionMessage(buffer, offset, length, start, currentByte));\n+            }\n+            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n             // CheckStyle:MagicNumber ON\n         }\n \n         return result;\n+    }\n+\n+    // Helper method to generate the exception message\n+    private static String exceptionMessage(byte[] buffer, final int offset,\n+            final int length, int current, final byte currentByte) {\n+        String string = new String(buffer, offset, length);\n+        string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\n+        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n+        return s;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n         buffer[buffer.length-1]=0;\n         value = TarUtils.parseOctal(buffer,0, buffer.length);\n         assertEquals(MAX_OCTAL, value);\n+        buffer=new byte[]{0,0};\n+        value = TarUtils.parseOctal(buffer,0, buffer.length);\n+        assertEquals(0, value);        \n+        buffer=new byte[]{0,' '};\n+        value = TarUtils.parseOctal(buffer,0, buffer.length);\n+        assertEquals(0, value);        \n+    }\n+\n+    public void testParseOctalInvalid() throws Exception{\n+        byte [] buffer;\n+        buffer=new byte[0]; // empty byte array\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        buffer=new byte[]{0}; // 1-byte array\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        buffer=new byte[]{0,0,' '}; // not all NULs\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - not all NULs\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        buffer=new byte[]{' ',0,0,0}; // not all NULs\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - not all NULs\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n         buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException\");\n         } catch (IllegalArgumentException expected) {\n         }\n-        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input\n+        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n-            fail(\"Expected IllegalArgumentException\");\n+            fail(\"Expected IllegalArgumentException - no trailer\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - embedded space\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n+        buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n+        try {\n+            TarUtils.parseOctal(buffer,0, buffer.length);\n+            fail(\"Expected IllegalArgumentException - embedded NUL\");\n         } catch (IllegalArgumentException expected) {\n         }\n     }\n-    \n+\n     private void checkRoundTripOctal(final long value) {\n         byte [] buffer = new byte[12];\n         long parseValue;", "timestamp": 1275476425, "metainfo": ""}