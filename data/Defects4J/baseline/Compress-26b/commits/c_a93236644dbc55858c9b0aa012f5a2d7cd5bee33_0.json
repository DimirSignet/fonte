{"sha": "a93236644dbc55858c9b0aa012f5a2d7cd5bee33", "log": "add dump to ArchiveStreamFactory  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n+import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n      */\n     public static final String CPIO = \"cpio\";\n     /**\n+     * Constant used to identify the Unix DUMP archive format.\n+     * @since Commons Compress 1.3\n+     */\n+    public static final String DUMP = \"dump\";\n+    /**\n      * Constant used to identify the JAR archive format.\n      * @since Commons Compress 1.1\n      */\n     /**\n      * Create an archive input stream from an archiver name and an input stream.\n      * \n-     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\" or \"cpio\"\n+     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n      * @param in the input stream\n      * @return the archive input stream\n      * @throws ArchiveException if the archiver name is not known\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n             return new CpioArchiveInputStream(in);\n+        }\n+        if (DUMP.equalsIgnoreCase(archiverName)) {\n+            return new DumpArchiveInputStream(in);\n         }\n         \n         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                 return new CpioArchiveInputStream(in);\n             }\n-            // Tar needs a bigger buffer to check the signature; read the first block\n+\n+            // Dump needs a bigger buffer to check the signature;\n+            final byte[] dumpsig = new byte[32];\n+            in.mark(dumpsig.length);\n+            signatureLength = in.read(dumpsig);\n+            in.reset();\n+            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+                return new DumpArchiveInputStream(in);\n+            }\n+\n+            // Tar needs an even bigger buffer to check the signature; read the first block\n             final byte[] tarheader = new byte[512];\n             in.mark(tarheader.length);\n             signatureLength = in.read(tarheader);\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n+import org.apache.commons.compress.archivers.ArchiveException;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n import java.io.IOException;\n      * @param is\n      * @throws Exception\n      */\n-    public DumpArchiveInputStream(InputStream is) throws IOException {\n+    public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n         this.raw = new TapeInputStream(is);\n         this.hasHitEOF = false;\n \n+        try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n \n         // skip past CLRI and BITS segments since we don't handle them yet.\n         readCLRI();\n         readBITS();\n+        } catch (IOException ex) {\n+            throw new ArchiveException(ex.getMessage(), ex);\n+        }\n \n         // put in a dummy record for the root node.\n         Dirent root = new Dirent(2, 2, 4, \".\");", "timestamp": 1313406898, "metainfo": ""}