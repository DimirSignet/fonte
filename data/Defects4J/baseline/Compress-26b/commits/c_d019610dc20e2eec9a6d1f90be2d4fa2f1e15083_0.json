{"sha": "d019610dc20e2eec9a6d1f90be2d4fa2f1e15083", "log": "If the entry has a ZIP64 extra field, sizes inside the data descriptor must be eight bytes long.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private static final byte[] LZERO = {0, 0, 0, 0};\n \n     /**\n+     * Helper, a 0 as ZipEightByteInteger.\n+     */\n+    private static final byte[] DLZERO = {0, 0, 0, 0, 0, 0, 0, 0};\n+\n+    /**\n      * Holds the offsets of the LFH starts for each entry.\n      */\n     private final Map<ZipArchiveEntry, Long> offsets =\n \n         // Size/CRC not required if RandomAccessFile is used\n         if (entry.getMethod() == STORED && raf == null) {\n-            if (entry.getSize() == -1) {\n+            if (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                 throw new ZipException(\"uncompressed size is required for\"\n                                        + \" STORED method when not writing to a\"\n                                        + \" file\");\n         }\n         writeOut(DD_SIG);\n         writeOut(ZipLong.getBytes(entry.getCrc()));\n-        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n-        writeOut(ZipLong.getBytes(entry.getSize()));\n-        // CheckStyle:MagicNumber OFF\n-        written += 16;\n-        // CheckStyle:MagicNumber ON\n+        int sizeFieldSize = WORD;\n+        if (!hasZip64Extra(ze)) {\n+            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(entry.getSize()));\n+        } else {\n+            sizeFieldSize = DWORD;\n+            writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n+            writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n+        }\n+        written += 2 * WORD + 2 * sizeFieldSize;\n     }\n \n     /**\n             || lfhOffset >= ZIP64_MAGIC;\n \n         if (needsZip64Extra) {\n-            hasUsedZip64 = true;\n-            Zip64ExtendedInformationExtraField z64 =  \n-                (Zip64ExtendedInformationExtraField)\n-                ze.getExtraField(Zip64ExtendedInformationExtraField\n-                                 .HEADER_ID);\n-            if (z64 == null) {\n-                z64 = new Zip64ExtendedInformationExtraField();\n-                ze.addExtraField(z64);\n-            }\n-            if (ze.getCompressedSize() >= ZIP64_MAGIC) {\n+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n+            if (ze.getCompressedSize() >= ZIP64_MAGIC) { \n                 z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+            } else {\n+                // reset value that may have been set for LFH\n+                z64.setCompressedSize(null);\n             }\n             if (ze.getSize() >= ZIP64_MAGIC) {\n                 z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            } else {\n+                // reset value that may have been set for LFH\n+                z64.setSize(null);\n             }\n             if (lfhOffset >= ZIP64_MAGIC) {\n                 z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n         }\n         return new ZipArchiveEntry(inputFile, entryName);\n     }\n+\n+    /**\n+     * Get the existing ZIP64 extended information extra field or\n+     * create a new one and add it to the entry.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private Zip64ExtendedInformationExtraField\n+        getZip64Extra(ZipArchiveEntry ze) {\n+        hasUsedZip64 = true;\n+        Zip64ExtendedInformationExtraField z64 =  \n+            (Zip64ExtendedInformationExtraField)\n+            ze.getExtraField(Zip64ExtendedInformationExtraField\n+                             .HEADER_ID);\n+        if (z64 == null) {\n+            z64 = new Zip64ExtendedInformationExtraField();\n+            ze.addExtraField(z64);\n+        }\n+        return z64;\n+    }\n+\n+    /**\n+     * Is there a ZIP64 extended information extra field for the\n+     * entry?\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean hasZip64Extra(ZipArchiveEntry ze) {\n+        return ze.getExtraField(Zip64ExtendedInformationExtraField\n+                                .HEADER_ID)\n+            != null;\n+    }\n }", "timestamp": 1311967368, "metainfo": ""}