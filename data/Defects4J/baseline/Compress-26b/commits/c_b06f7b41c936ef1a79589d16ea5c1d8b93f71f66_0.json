{"sha": "b06f7b41c936ef1a79589d16ea5c1d8b93f71f66", "log": "split sorting out of BZip2CompressorOutputStream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n      */\n     public static final int MAX_BLOCKSIZE = 9;\n \n-    private static final int SETMASK = (1 << 21);\n-    private static final int CLEARMASK = (~SETMASK);\n     private static final int GREATER_ICOST = 15;\n     private static final int LESSER_ICOST = 0;\n-    private static final int SMALL_THRESH = 20;\n-    private static final int DEPTH_THRESH = 10;\n-    private static final int WORK_FACTOR = 30;\n-\n-    /*\n-     * <p> If you are ever unlucky/improbable enough to get a stack\n-     * overflow whilst sorting, increase the following constant and\n-     * try again. In practice I have never seen the stack go above 27\n-     * elems, so the following limit seems very generous.  </p>\n-     */\n-    private static final int QSORT_STACK_SIZE = 1000;\n-\n-    /**\n-     * Knuth's increments seem to work better than Incerpi-Sedgewick here.\n-     * Possibly because the number of elems to sort is usually small, typically\n-     * &lt;= 20.\n-     */\n-    private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n-                                        9841, 29524, 88573, 265720, 797161,\n-                                        2391484 };\n \n     private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n                                           final Data dat, final int alphaSize,\n     private int last;\n \n     /**\n-     * Index in fmap[] of original string after sorting.\n-     */\n-    private int origPtr;\n-\n-    /**\n      * Always: in the range 0 .. 9. The current block size is 100000 * this\n      * number.\n      */\n     private final int blockSize100k;\n \n-    private boolean blockRandomised;\n-\n     private int bsBuff;\n     private int bsLive;\n     private final CRC crc = new CRC();\n     private int nInUse;\n \n     private int nMTF;\n-\n-    /*\n-     * Used when sorting. If too many long comparisons happen, we stop sorting,\n-     * randomise the block slightly, and try again.\n-     */\n-    private int workDone;\n-    private int workLimit;\n-    private boolean firstAttempt;\n \n     private int currentChar = -1;\n     private int runLength = 0;\n         }\n \n         /* sort the block and establish posn of original string */\n-        blockSort();\n+        final boolean blockRandomised = blockSort();\n \n         /*\n          * A 6-byte block header, the value chosen arbitrarily as 0x314159265359\n         bsPutInt(this.blockCRC);\n \n         /* Now a single bit indicating randomisation. */\n-        if (this.blockRandomised) {\n+        if (blockRandomised) {\n             bsW(1, 1);\n         } else {\n             bsW(1, 0);\n     }\n \n     private void moveToFrontCodeAndSend() throws IOException {\n-        bsW(24, this.origPtr);\n+        bsW(24, this.data.origPtr);\n         generateMTFValues();\n         sendMTFValues();\n     }\n \n-    /**\n-     * This is the most hammered method of this class.\n-     *\n-     * <p>\n-     * This is the version using unrolled loops. Normally I never use such ones\n-     * in Java code. The unrolling has shown a noticable performance improvement\n-     * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the\n-     * JIT compiler of the vm.\n-     * </p>\n-     */\n-    private boolean mainSimpleSort(final Data dataShadow, final int lo,\n-                                   final int hi, final int d) {\n-        final int bigN = hi - lo + 1;\n-        if (bigN < 2) {\n-            return this.firstAttempt && (this.workDone > this.workLimit);\n-        }\n-\n-        int hp = 0;\n-        while (INCS[hp] < bigN) {\n-            hp++;\n-        }\n-\n-        final int[] fmap = dataShadow.fmap;\n-        final char[] quadrant = dataShadow.quadrant;\n-        final byte[] block = dataShadow.block;\n-        final int lastShadow = this.last;\n-        final int lastPlus1 = lastShadow + 1;\n-        final boolean firstAttemptShadow = this.firstAttempt;\n-        final int workLimitShadow = this.workLimit;\n-        int workDoneShadow = this.workDone;\n-\n-        // Following block contains unrolled code which could be shortened by\n-        // coding it in additional loops.\n-\n-        HP: while (--hp >= 0) {\n-            final int h = INCS[hp];\n-            final int mj = lo + h - 1;\n-\n-            for (int i = lo + h; i <= hi;) {\n-                // copy\n-                for (int k = 3; (i <= hi) && (--k >= 0); i++) {\n-                    final int v = fmap[i];\n-                    final int vd = v + d;\n-                    int j = i;\n-\n-                    // for (int a;\n-                    // (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,\n-                    // block, quadrant, lastShadow);\n-                    // j -= h) {\n-                    // fmap[j] = a;\n-                    // }\n-                    //\n-                    // unrolled version:\n-\n-                    // start inline mainGTU\n-                    boolean onceRunned = false;\n-                    int a = 0;\n-\n-                    HAMMER: while (true) {\n-                        if (onceRunned) {\n-                            fmap[j] = a;\n-                            if ((j -= h) <= mj) {\n-                                break HAMMER;\n-                            }\n-                        } else {\n-                            onceRunned = true;\n-                        }\n-\n-                        a = fmap[j - h];\n-                        int i1 = a + d;\n-                        int i2 = vd;\n-\n-                        // following could be done in a loop, but\n-                        // unrolled it for performance:\n-                        if (block[i1 + 1] == block[i2 + 1]) {\n-                            if (block[i1 + 2] == block[i2 + 2]) {\n-                                if (block[i1 + 3] == block[i2 + 3]) {\n-                                    if (block[i1 + 4] == block[i2 + 4]) {\n-                                        if (block[i1 + 5] == block[i2 + 5]) {\n-                                            if (block[(i1 += 6)] == block[(i2 += 6)]) {\n-                                                int x = lastShadow;\n-                                                X: while (x > 0) {\n-                                                    x -= 4;\n-\n-                                                    if (block[i1 + 1] == block[i2 + 1]) {\n-                                                        if (quadrant[i1] == quadrant[i2]) {\n-                                                            if (block[i1 + 2] == block[i2 + 2]) {\n-                                                                if (quadrant[i1 + 1] == quadrant[i2 + 1]) {\n-                                                                    if (block[i1 + 3] == block[i2 + 3]) {\n-                                                                        if (quadrant[i1 + 2] == quadrant[i2 + 2]) {\n-                                                                            if (block[i1 + 4] == block[i2 + 4]) {\n-                                                                                if (quadrant[i1 + 3] == quadrant[i2 + 3]) {\n-                                                                                    if ((i1 += 4) >= lastPlus1) {\n-                                                                                        i1 -= lastPlus1;\n-                                                                                    }\n-                                                                                    if ((i2 += 4) >= lastPlus1) {\n-                                                                                        i2 -= lastPlus1;\n-                                                                                    }\n-                                                                                    workDoneShadow++;\n-                                                                                    continue X;\n-                                                                                } else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {\n-                                                                                    continue HAMMER;\n-                                                                                } else {\n-                                                                                    break HAMMER;\n-                                                                                }\n-                                                                            } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n-                                                                                continue HAMMER;\n-                                                                            } else {\n-                                                                                break HAMMER;\n-                                                                            }\n-                                                                        } else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {\n-                                                                            continue HAMMER;\n-                                                                        } else {\n-                                                                            break HAMMER;\n-                                                                        }\n-                                                                    } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n-                                                                        continue HAMMER;\n-                                                                    } else {\n-                                                                        break HAMMER;\n-                                                                    }\n-                                                                } else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {\n-                                                                    continue HAMMER;\n-                                                                } else {\n-                                                                    break HAMMER;\n-                                                                }\n-                                                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n-                                                                continue HAMMER;\n-                                                            } else {\n-                                                                break HAMMER;\n-                                                            }\n-                                                        } else if ((quadrant[i1] > quadrant[i2])) {\n-                                                            continue HAMMER;\n-                                                        } else {\n-                                                            break HAMMER;\n-                                                        }\n-                                                    } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n-                                                        continue HAMMER;\n-                                                    } else {\n-                                                        break HAMMER;\n-                                                    }\n-\n-                                                }\n-                                                break HAMMER;\n-                                            } // while x > 0\n-                                            else {\n-                                                if ((block[i1] & 0xff) > (block[i2] & 0xff)) {\n-                                                    continue HAMMER;\n-                                                } else {\n-                                                    break HAMMER;\n-                                                }\n-                                            }\n-                                        } else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {\n-                                            continue HAMMER;\n-                                        } else {\n-                                            break HAMMER;\n-                                        }\n-                                    } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n-                                        continue HAMMER;\n-                                    } else {\n-                                        break HAMMER;\n-                                    }\n-                                } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n-                                    continue HAMMER;\n-                                } else {\n-                                    break HAMMER;\n-                                }\n-                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n-                                continue HAMMER;\n-                            } else {\n-                                break HAMMER;\n-                            }\n-                        } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n-                            continue HAMMER;\n-                        } else {\n-                            break HAMMER;\n-                        }\n-\n-                    } // HAMMER\n-                    // end inline mainGTU\n-\n-                    fmap[j] = v;\n-                }\n-\n-                if (firstAttemptShadow && (i <= hi)\n-                    && (workDoneShadow > workLimitShadow)) {\n-                    break HP;\n-                }\n-            }\n-        }\n-\n-        this.workDone = workDoneShadow;\n-        return firstAttemptShadow && (workDoneShadow > workLimitShadow);\n-    }\n-\n-    private static void vswap(int[] fmap, int p1, int p2, int n) {\n-        n += p1;\n-        while (p1 < n) {\n-            int t = fmap[p1];\n-            fmap[p1++] = fmap[p2];\n-            fmap[p2++] = t;\n-        }\n-    }\n-\n-    private static byte med3(byte a, byte b, byte c) {\n-        return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n-                                                        : a);\n-    }\n-\n-    private void blockSort() {\n-        this.workLimit = WORK_FACTOR * this.last;\n-        this.workDone = 0;\n-        this.blockRandomised = false;\n-        this.firstAttempt = true;\n-        mainSort();\n-\n-        if (this.firstAttempt && (this.workDone > this.workLimit)) {\n-            randomiseBlock();\n-            this.workLimit = this.workDone = 0;\n-            this.firstAttempt = false;\n-            mainSort();\n-        }\n-\n-        int[] fmap = this.data.fmap;\n-        this.origPtr = -1;\n-        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\n-            if (fmap[i] == 0) {\n-                this.origPtr = i;\n-                break;\n-            }\n-        }\n-\n-        // assert (this.origPtr != -1) : this.origPtr;\n-    }\n-\n-    /**\n-     * Method \"mainQSort3\", file \"blocksort.c\", BZip2 1.0.2\n-     */\n-    private void mainQSort3(final Data dataShadow, final int loSt,\n-                            final int hiSt, final int dSt) {\n-        final int[] stack_ll = dataShadow.stack_ll;\n-        final int[] stack_hh = dataShadow.stack_hh;\n-        final int[] stack_dd = dataShadow.stack_dd;\n-        final int[] fmap = dataShadow.fmap;\n-        final byte[] block = dataShadow.block;\n-\n-        stack_ll[0] = loSt;\n-        stack_hh[0] = hiSt;\n-        stack_dd[0] = dSt;\n-\n-        for (int sp = 1; --sp >= 0;) {\n-            final int lo = stack_ll[sp];\n-            final int hi = stack_hh[sp];\n-            final int d = stack_dd[sp];\n-\n-            if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {\n-                if (mainSimpleSort(dataShadow, lo, hi, d)) {\n-                    return;\n-                }\n-            } else {\n-                final int d1 = d + 1;\n-                final int med = med3(block[fmap[lo] + d1],\n-                                     block[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;\n-\n-                int unLo = lo;\n-                int unHi = hi;\n-                int ltLo = lo;\n-                int gtHi = hi;\n-\n-                while (true) {\n-                    while (unLo <= unHi) {\n-                        final int n = (block[fmap[unLo] + d1] & 0xff)\n-                            - med;\n-                        if (n == 0) {\n-                            final int temp = fmap[unLo];\n-                            fmap[unLo++] = fmap[ltLo];\n-                            fmap[ltLo++] = temp;\n-                        } else if (n < 0) {\n-                            unLo++;\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-\n-                    while (unLo <= unHi) {\n-                        final int n = (block[fmap[unHi] + d1] & 0xff)\n-                            - med;\n-                        if (n == 0) {\n-                            final int temp = fmap[unHi];\n-                            fmap[unHi--] = fmap[gtHi];\n-                            fmap[gtHi--] = temp;\n-                        } else if (n > 0) {\n-                            unHi--;\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-\n-                    if (unLo <= unHi) {\n-                        final int temp = fmap[unLo];\n-                        fmap[unLo++] = fmap[unHi];\n-                        fmap[unHi--] = temp;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-\n-                if (gtHi < ltLo) {\n-                    stack_ll[sp] = lo;\n-                    stack_hh[sp] = hi;\n-                    stack_dd[sp] = d1;\n-                    sp++;\n-                } else {\n-                    int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)\n-                        : (unLo - ltLo);\n-                    vswap(fmap, lo, unLo - n, n);\n-                    int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)\n-                        : (gtHi - unHi);\n-                    vswap(fmap, unLo, hi - m + 1, m);\n-\n-                    n = lo + unLo - ltLo - 1;\n-                    m = hi - (gtHi - unHi) + 1;\n-\n-                    stack_ll[sp] = lo;\n-                    stack_hh[sp] = n;\n-                    stack_dd[sp] = d;\n-                    sp++;\n-\n-                    stack_ll[sp] = n + 1;\n-                    stack_hh[sp] = m - 1;\n-                    stack_dd[sp] = d1;\n-                    sp++;\n-\n-                    stack_ll[sp] = m;\n-                    stack_hh[sp] = hi;\n-                    stack_dd[sp] = d;\n-                    sp++;\n-                }\n-            }\n-        }\n-    }\n-\n-    private void mainSort() {\n-        final Data dataShadow = this.data;\n-        final int[] runningOrder = dataShadow.mainSort_runningOrder;\n-        final int[] copy = dataShadow.mainSort_copy;\n-        final boolean[] bigDone = dataShadow.mainSort_bigDone;\n-        final int[] ftab = dataShadow.ftab;\n-        final byte[] block = dataShadow.block;\n-        final int[] fmap = dataShadow.fmap;\n-        final char[] quadrant = dataShadow.quadrant;\n-        final int lastShadow = this.last;\n-        final int workLimitShadow = this.workLimit;\n-        final boolean firstAttemptShadow = this.firstAttempt;\n-\n-        // Set up the 2-byte frequency table\n-        for (int i = 65537; --i >= 0;) {\n-            ftab[i] = 0;\n-        }\n-\n-        /*\n-         * In the various block-sized structures, live data runs from 0 to\n-         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n-         * for block.\n-         */\n-        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\n-            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n-        }\n-        for (int i = lastShadow + NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\n-            quadrant[i] = 0;\n-        }\n-        block[0] = block[lastShadow + 1];\n-\n-        // Complete the initial radix sort:\n-\n-        int c1 = block[0] & 0xff;\n-        for (int i = 0; i <= lastShadow; i++) {\n-            final int c2 = block[i + 1] & 0xff;\n-            ftab[(c1 << 8) + c2]++;\n-            c1 = c2;\n-        }\n-\n-        for (int i = 1; i <= 65536; i++) {\n-            ftab[i] += ftab[i - 1];\n-        }\n-\n-        c1 = block[1] & 0xff;\n-        for (int i = 0; i < lastShadow; i++) {\n-            final int c2 = block[i + 2] & 0xff;\n-            fmap[--ftab[(c1 << 8) + c2]] = i;\n-            c1 = c2;\n-        }\n-\n-        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n-\n-        /*\n-         * Now ftab contains the first loc of every small bucket. Calculate the\n-         * running order, from smallest to largest big bucket.\n-         */\n-        for (int i = 256; --i >= 0;) {\n-            bigDone[i] = false;\n-            runningOrder[i] = i;\n-        }\n-\n-        for (int h = 364; h != 1;) {\n-            h /= 3;\n-            for (int i = h; i <= 255; i++) {\n-                final int vv = runningOrder[i];\n-                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n-                final int b = h - 1;\n-                int j = i;\n-                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n-                                                                                                                - h]) {\n-                    runningOrder[j] = ro;\n-                    j -= h;\n-                    if (j <= b) {\n-                        break;\n-                    }\n-                }\n-                runningOrder[j] = vv;\n-            }\n-        }\n-\n-        /*\n-         * The main sorting loop.\n-         */\n-        for (int i = 0; i <= 255; i++) {\n-            /*\n-             * Process big buckets, starting with the least full.\n-             */\n-            final int ss = runningOrder[i];\n-\n-            // Step 1:\n-            /*\n-             * Complete the big bucket [ss] by quicksorting any unsorted small\n-             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n-             * already completed many of the small buckets [ss, j], so we don't\n-             * have to sort them at all.\n-             */\n-            for (int j = 0; j <= 255; j++) {\n-                final int sb = (ss << 8) + j;\n-                final int ftab_sb = ftab[sb];\n-                if ((ftab_sb & SETMASK) != SETMASK) {\n-                    final int lo = ftab_sb & CLEARMASK;\n-                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n-                    if (hi > lo) {\n-                        mainQSort3(dataShadow, lo, hi, 2);\n-                        if (firstAttemptShadow\n-                            && (this.workDone > workLimitShadow)) {\n-                            return;\n-                        }\n-                    }\n-                    ftab[sb] = ftab_sb | SETMASK;\n-                }\n-            }\n-\n-            // Step 2:\n-            // Now scan this big bucket so as to synthesise the\n-            // sorted order for small buckets [t, ss] for all t != ss.\n-\n-            for (int j = 0; j <= 255; j++) {\n-                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n-            }\n-\n-            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n-                final int fmap_j = fmap[j];\n-                c1 = block[fmap_j] & 0xff;\n-                if (!bigDone[c1]) {\n-                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n-                    copy[c1]++;\n-                }\n-            }\n-\n-            for (int j = 256; --j >= 0;) {\n-                ftab[(j << 8) + ss] |= SETMASK;\n-            }\n-\n-            // Step 3:\n-            /*\n-             * The ss big bucket is now done. Record this fact, and update the\n-             * quadrant descriptors. Remember to update quadrants in the\n-             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n-             * skips this updating for the last bucket processed, since updating\n-             * for the last bucket is pointless.\n-             */\n-            bigDone[ss] = true;\n-\n-            if (i < 255) {\n-                final int bbStart = ftab[ss << 8] & CLEARMASK;\n-                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n-                int shifts = 0;\n-\n-                while ((bbSize >> shifts) > 65534) {\n-                    shifts++;\n-                }\n-\n-                for (int j = 0; j < bbSize; j++) {\n-                    final int a2update = fmap[bbStart + j];\n-                    final char qVal = (char) (j >> shifts);\n-                    quadrant[a2update] = qVal;\n-                    if (a2update < NUM_OVERSHOOT_BYTES) {\n-                        quadrant[a2update + lastShadow + 1] = qVal;\n-                    }\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    private void randomiseBlock() {\n-        final boolean[] inUse = this.data.inUse;\n-        final byte[] block = this.data.block;\n-        final int lastShadow = this.last;\n-\n-        for (int i = 256; --i >= 0;) {\n-            inUse[i] = false;\n-        }\n-\n-        int rNToGo = 0;\n-        int rTPos = 0;\n-        for (int i = 0, j = 1; i <= lastShadow; i = j, j++) {\n-            if (rNToGo == 0) {\n-                rNToGo = (char) Rand.rNums(rTPos);\n-                if (++rTPos == 512) {\n-                    rTPos = 0;\n-                }\n-            }\n-\n-            rNToGo--;\n-            block[j] ^= ((rNToGo == 1) ? 1 : 0);\n-\n-            // handle 16 bit signed numbers\n-            inUse[block[j] & 0xff] = true;\n-        }\n-\n-        this.blockRandomised = true;\n+    private boolean blockSort() {\n+        return new BlockSort().blockSort(data, last);\n     }\n \n     private void generateMTFValues() {\n         this.nMTF = wr + 1;\n     }\n \n-    private static final class Data extends Object {\n+    static final class Data extends Object {\n \n         // with blockSize 900k\n         final boolean[] inUse = new boolean[256]; // 256 byte\n         final byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte\n         final boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte\n \n-        final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n-        final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n-        final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n+        final int[] stack_ll = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n+        final int[] stack_hh = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n+        final int[] stack_dd = new int[BlockSort.QSORT_STACK_SIZE]; // 4000 byte\n \n         final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n         final int[] mainSort_copy = new int[256]; // 1024 byte\n          */\n         final char[] quadrant;\n \n+        /**\n+         * Index in fmap[] of original string after sorting.\n+         */\n+        int origPtr;\n+\n         Data(int blockSize100k) {\n             super();\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+/**\n+ * Encapsulates the sorting algorithms needed by {@link BZip2CompressorOutputStream}.\n+ *\n+ * @NotThreadSafe\n+ */\n+class BlockSort {\n+\n+    private static final int SETMASK = (1 << 21);\n+    private static final int CLEARMASK = (~SETMASK);\n+    private static final int SMALL_THRESH = 20;\n+    private static final int DEPTH_THRESH = 10;\n+    private static final int WORK_FACTOR = 30;\n+\n+    /*\n+     * <p> If you are ever unlucky/improbable enough to get a stack\n+     * overflow whilst sorting, increase the following constant and\n+     * try again. In practice I have never seen the stack go above 27\n+     * elems, so the following limit seems very generous.  </p>\n+     */\n+    static final int QSORT_STACK_SIZE = 1000;\n+\n+    /**\n+     * Knuth's increments seem to work better than Incerpi-Sedgewick here.\n+     * Possibly because the number of elems to sort is usually small, typically\n+     * &lt;= 20.\n+     */\n+    private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n+                                        9841, 29524, 88573, 265720, 797161,\n+                                        2391484 };\n+\n+    private boolean blockRandomised;\n+\n+    /*\n+     * Used when sorting. If too many long comparisons happen, we stop sorting,\n+     * randomise the block slightly, and try again.\n+     */\n+    private int workDone;\n+    private int workLimit;\n+    private boolean firstAttempt;\n+\n+    /**\n+     * This is the most hammered method of this class.\n+     *\n+     * <p>\n+     * This is the version using unrolled loops. Normally I never use such ones\n+     * in Java code. The unrolling has shown a noticable performance improvement\n+     * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the\n+     * JIT compiler of the vm.\n+     * </p>\n+     */\n+    private boolean mainSimpleSort(final BZip2CompressorOutputStream.Data dataShadow,\n+                                   final int lo, final int hi, final int d,\n+                                   final int lastShadow) {\n+        final int bigN = hi - lo + 1;\n+        if (bigN < 2) {\n+            return this.firstAttempt && (this.workDone > this.workLimit);\n+        }\n+\n+        int hp = 0;\n+        while (INCS[hp] < bigN) {\n+            hp++;\n+        }\n+\n+        final int[] fmap = dataShadow.fmap;\n+        final char[] quadrant = dataShadow.quadrant;\n+        final byte[] block = dataShadow.block;\n+        final int lastPlus1 = lastShadow + 1;\n+        final boolean firstAttemptShadow = this.firstAttempt;\n+        final int workLimitShadow = this.workLimit;\n+        int workDoneShadow = this.workDone;\n+\n+        // Following block contains unrolled code which could be shortened by\n+        // coding it in additional loops.\n+\n+        HP: while (--hp >= 0) {\n+            final int h = INCS[hp];\n+            final int mj = lo + h - 1;\n+\n+            for (int i = lo + h; i <= hi;) {\n+                // copy\n+                for (int k = 3; (i <= hi) && (--k >= 0); i++) {\n+                    final int v = fmap[i];\n+                    final int vd = v + d;\n+                    int j = i;\n+\n+                    // for (int a;\n+                    // (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,\n+                    // block, quadrant, lastShadow);\n+                    // j -= h) {\n+                    // fmap[j] = a;\n+                    // }\n+                    //\n+                    // unrolled version:\n+\n+                    // start inline mainGTU\n+                    boolean onceRunned = false;\n+                    int a = 0;\n+\n+                    HAMMER: while (true) {\n+                        if (onceRunned) {\n+                            fmap[j] = a;\n+                            if ((j -= h) <= mj) {\n+                                break HAMMER;\n+                            }\n+                        } else {\n+                            onceRunned = true;\n+                        }\n+\n+                        a = fmap[j - h];\n+                        int i1 = a + d;\n+                        int i2 = vd;\n+\n+                        // following could be done in a loop, but\n+                        // unrolled it for performance:\n+                        if (block[i1 + 1] == block[i2 + 1]) {\n+                            if (block[i1 + 2] == block[i2 + 2]) {\n+                                if (block[i1 + 3] == block[i2 + 3]) {\n+                                    if (block[i1 + 4] == block[i2 + 4]) {\n+                                        if (block[i1 + 5] == block[i2 + 5]) {\n+                                            if (block[(i1 += 6)] == block[(i2 += 6)]) {\n+                                                int x = lastShadow;\n+                                                X: while (x > 0) {\n+                                                    x -= 4;\n+\n+                                                    if (block[i1 + 1] == block[i2 + 1]) {\n+                                                        if (quadrant[i1] == quadrant[i2]) {\n+                                                            if (block[i1 + 2] == block[i2 + 2]) {\n+                                                                if (quadrant[i1 + 1] == quadrant[i2 + 1]) {\n+                                                                    if (block[i1 + 3] == block[i2 + 3]) {\n+                                                                        if (quadrant[i1 + 2] == quadrant[i2 + 2]) {\n+                                                                            if (block[i1 + 4] == block[i2 + 4]) {\n+                                                                                if (quadrant[i1 + 3] == quadrant[i2 + 3]) {\n+                                                                                    if ((i1 += 4) >= lastPlus1) {\n+                                                                                        i1 -= lastPlus1;\n+                                                                                    }\n+                                                                                    if ((i2 += 4) >= lastPlus1) {\n+                                                                                        i2 -= lastPlus1;\n+                                                                                    }\n+                                                                                    workDoneShadow++;\n+                                                                                    continue X;\n+                                                                                } else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {\n+                                                                                    continue HAMMER;\n+                                                                                } else {\n+                                                                                    break HAMMER;\n+                                                                                }\n+                                                                            } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n+                                                                                continue HAMMER;\n+                                                                            } else {\n+                                                                                break HAMMER;\n+                                                                            }\n+                                                                        } else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {\n+                                                                            continue HAMMER;\n+                                                                        } else {\n+                                                                            break HAMMER;\n+                                                                        }\n+                                                                    } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n+                                                                        continue HAMMER;\n+                                                                    } else {\n+                                                                        break HAMMER;\n+                                                                    }\n+                                                                } else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {\n+                                                                    continue HAMMER;\n+                                                                } else {\n+                                                                    break HAMMER;\n+                                                                }\n+                                                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n+                                                                continue HAMMER;\n+                                                            } else {\n+                                                                break HAMMER;\n+                                                            }\n+                                                        } else if ((quadrant[i1] > quadrant[i2])) {\n+                                                            continue HAMMER;\n+                                                        } else {\n+                                                            break HAMMER;\n+                                                        }\n+                                                    } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n+                                                        continue HAMMER;\n+                                                    } else {\n+                                                        break HAMMER;\n+                                                    }\n+\n+                                                }\n+                                                break HAMMER;\n+                                            } // while x > 0\n+                                            else {\n+                                                if ((block[i1] & 0xff) > (block[i2] & 0xff)) {\n+                                                    continue HAMMER;\n+                                                } else {\n+                                                    break HAMMER;\n+                                                }\n+                                            }\n+                                        } else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {\n+                                            continue HAMMER;\n+                                        } else {\n+                                            break HAMMER;\n+                                        }\n+                                    } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n+                                        continue HAMMER;\n+                                    } else {\n+                                        break HAMMER;\n+                                    }\n+                                } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n+                                    continue HAMMER;\n+                                } else {\n+                                    break HAMMER;\n+                                }\n+                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n+                                continue HAMMER;\n+                            } else {\n+                                break HAMMER;\n+                            }\n+                        } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n+                            continue HAMMER;\n+                        } else {\n+                            break HAMMER;\n+                        }\n+\n+                    } // HAMMER\n+                    // end inline mainGTU\n+\n+                    fmap[j] = v;\n+                }\n+\n+                if (firstAttemptShadow && (i <= hi)\n+                    && (workDoneShadow > workLimitShadow)) {\n+                    break HP;\n+                }\n+            }\n+        }\n+\n+        this.workDone = workDoneShadow;\n+        return firstAttemptShadow && (workDoneShadow > workLimitShadow);\n+    }\n+\n+    private static void vswap(int[] fmap, int p1, int p2, int n) {\n+        n += p1;\n+        while (p1 < n) {\n+            int t = fmap[p1];\n+            fmap[p1++] = fmap[p2];\n+            fmap[p2++] = t;\n+        }\n+    }\n+\n+    private static byte med3(byte a, byte b, byte c) {\n+        return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n+                                                        : a);\n+    }\n+\n+    boolean blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\n+        this.workLimit = WORK_FACTOR * last;\n+        this.workDone = 0;\n+        this.blockRandomised = false;\n+        this.firstAttempt = true;\n+        mainSort(data, last);\n+\n+        if (this.firstAttempt && (this.workDone > this.workLimit)) {\n+            randomiseBlock(data, last);\n+            this.workLimit = this.workDone = 0;\n+            this.firstAttempt = false;\n+            mainSort(data, last);\n+        }\n+\n+        int[] fmap = data.fmap;\n+        data.origPtr = -1;\n+        for (int i = 0; i <= last; i++) {\n+            if (fmap[i] == 0) {\n+                data.origPtr = i;\n+                break;\n+            }\n+        }\n+\n+        // assert (data.origPtr != -1) : data.origPtr;\n+        return blockRandomised;\n+    }\n+\n+    /**\n+     * Method \"mainQSort3\", file \"blocksort.c\", BZip2 1.0.2\n+     */\n+    private void mainQSort3(final BZip2CompressorOutputStream.Data dataShadow,\n+                            final int loSt, final int hiSt, final int dSt,\n+                            final int last) {\n+        final int[] stack_ll = dataShadow.stack_ll;\n+        final int[] stack_hh = dataShadow.stack_hh;\n+        final int[] stack_dd = dataShadow.stack_dd;\n+        final int[] fmap = dataShadow.fmap;\n+        final byte[] block = dataShadow.block;\n+\n+        stack_ll[0] = loSt;\n+        stack_hh[0] = hiSt;\n+        stack_dd[0] = dSt;\n+\n+        for (int sp = 1; --sp >= 0;) {\n+            final int lo = stack_ll[sp];\n+            final int hi = stack_hh[sp];\n+            final int d = stack_dd[sp];\n+\n+            if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {\n+                if (mainSimpleSort(dataShadow, lo, hi, d, last)) {\n+                    return;\n+                }\n+            } else {\n+                final int d1 = d + 1;\n+                final int med = med3(block[fmap[lo] + d1],\n+                                     block[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;\n+\n+                int unLo = lo;\n+                int unHi = hi;\n+                int ltLo = lo;\n+                int gtHi = hi;\n+\n+                while (true) {\n+                    while (unLo <= unHi) {\n+                        final int n = (block[fmap[unLo] + d1] & 0xff)\n+                            - med;\n+                        if (n == 0) {\n+                            final int temp = fmap[unLo];\n+                            fmap[unLo++] = fmap[ltLo];\n+                            fmap[ltLo++] = temp;\n+                        } else if (n < 0) {\n+                            unLo++;\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+\n+                    while (unLo <= unHi) {\n+                        final int n = (block[fmap[unHi] + d1] & 0xff)\n+                            - med;\n+                        if (n == 0) {\n+                            final int temp = fmap[unHi];\n+                            fmap[unHi--] = fmap[gtHi];\n+                            fmap[gtHi--] = temp;\n+                        } else if (n > 0) {\n+                            unHi--;\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+\n+                    if (unLo <= unHi) {\n+                        final int temp = fmap[unLo];\n+                        fmap[unLo++] = fmap[unHi];\n+                        fmap[unHi--] = temp;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+\n+                if (gtHi < ltLo) {\n+                    stack_ll[sp] = lo;\n+                    stack_hh[sp] = hi;\n+                    stack_dd[sp] = d1;\n+                    sp++;\n+                } else {\n+                    int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)\n+                        : (unLo - ltLo);\n+                    vswap(fmap, lo, unLo - n, n);\n+                    int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)\n+                        : (gtHi - unHi);\n+                    vswap(fmap, unLo, hi - m + 1, m);\n+\n+                    n = lo + unLo - ltLo - 1;\n+                    m = hi - (gtHi - unHi) + 1;\n+\n+                    stack_ll[sp] = lo;\n+                    stack_hh[sp] = n;\n+                    stack_dd[sp] = d;\n+                    sp++;\n+\n+                    stack_ll[sp] = n + 1;\n+                    stack_hh[sp] = m - 1;\n+                    stack_dd[sp] = d1;\n+                    sp++;\n+\n+                    stack_ll[sp] = m;\n+                    stack_hh[sp] = hi;\n+                    stack_dd[sp] = d;\n+                    sp++;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n+                          final int lastShadow) {\n+        final int[] runningOrder = dataShadow.mainSort_runningOrder;\n+        final int[] copy = dataShadow.mainSort_copy;\n+        final boolean[] bigDone = dataShadow.mainSort_bigDone;\n+        final int[] ftab = dataShadow.ftab;\n+        final byte[] block = dataShadow.block;\n+        final int[] fmap = dataShadow.fmap;\n+        final char[] quadrant = dataShadow.quadrant;\n+        final int workLimitShadow = this.workLimit;\n+        final boolean firstAttemptShadow = this.firstAttempt;\n+\n+        // Set up the 2-byte frequency table\n+        for (int i = 65537; --i >= 0;) {\n+            ftab[i] = 0;\n+        }\n+\n+        /*\n+         * In the various block-sized structures, live data runs from 0 to\n+         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n+         * for block.\n+         */\n+        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n+            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n+        }\n+        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\n+            quadrant[i] = 0;\n+        }\n+        block[0] = block[lastShadow + 1];\n+\n+        // Complete the initial radix sort:\n+\n+        int c1 = block[0] & 0xff;\n+        for (int i = 0; i <= lastShadow; i++) {\n+            final int c2 = block[i + 1] & 0xff;\n+            ftab[(c1 << 8) + c2]++;\n+            c1 = c2;\n+        }\n+\n+        for (int i = 1; i <= 65536; i++) {\n+            ftab[i] += ftab[i - 1];\n+        }\n+\n+        c1 = block[1] & 0xff;\n+        for (int i = 0; i < lastShadow; i++) {\n+            final int c2 = block[i + 2] & 0xff;\n+            fmap[--ftab[(c1 << 8) + c2]] = i;\n+            c1 = c2;\n+        }\n+\n+        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n+\n+        /*\n+         * Now ftab contains the first loc of every small bucket. Calculate the\n+         * running order, from smallest to largest big bucket.\n+         */\n+        for (int i = 256; --i >= 0;) {\n+            bigDone[i] = false;\n+            runningOrder[i] = i;\n+        }\n+\n+        for (int h = 364; h != 1;) {\n+            h /= 3;\n+            for (int i = h; i <= 255; i++) {\n+                final int vv = runningOrder[i];\n+                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n+                final int b = h - 1;\n+                int j = i;\n+                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n+                                                                                                                - h]) {\n+                    runningOrder[j] = ro;\n+                    j -= h;\n+                    if (j <= b) {\n+                        break;\n+                    }\n+                }\n+                runningOrder[j] = vv;\n+            }\n+        }\n+\n+        /*\n+         * The main sorting loop.\n+         */\n+        for (int i = 0; i <= 255; i++) {\n+            /*\n+             * Process big buckets, starting with the least full.\n+             */\n+            final int ss = runningOrder[i];\n+\n+            // Step 1:\n+            /*\n+             * Complete the big bucket [ss] by quicksorting any unsorted small\n+             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n+             * already completed many of the small buckets [ss, j], so we don't\n+             * have to sort them at all.\n+             */\n+            for (int j = 0; j <= 255; j++) {\n+                final int sb = (ss << 8) + j;\n+                final int ftab_sb = ftab[sb];\n+                if ((ftab_sb & SETMASK) != SETMASK) {\n+                    final int lo = ftab_sb & CLEARMASK;\n+                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n+                    if (hi > lo) {\n+                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n+                        if (firstAttemptShadow\n+                            && (this.workDone > workLimitShadow)) {\n+                            return;\n+                        }\n+                    }\n+                    ftab[sb] = ftab_sb | SETMASK;\n+                }\n+            }\n+\n+            // Step 2:\n+            // Now scan this big bucket so as to synthesise the\n+            // sorted order for small buckets [t, ss] for all t != ss.\n+\n+            for (int j = 0; j <= 255; j++) {\n+                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n+            }\n+\n+            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n+                final int fmap_j = fmap[j];\n+                c1 = block[fmap_j] & 0xff;\n+                if (!bigDone[c1]) {\n+                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n+                    copy[c1]++;\n+                }\n+            }\n+\n+            for (int j = 256; --j >= 0;) {\n+                ftab[(j << 8) + ss] |= SETMASK;\n+            }\n+\n+            // Step 3:\n+            /*\n+             * The ss big bucket is now done. Record this fact, and update the\n+             * quadrant descriptors. Remember to update quadrants in the\n+             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n+             * skips this updating for the last bucket processed, since updating\n+             * for the last bucket is pointless.\n+             */\n+            bigDone[ss] = true;\n+\n+            if (i < 255) {\n+                final int bbStart = ftab[ss << 8] & CLEARMASK;\n+                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n+                int shifts = 0;\n+\n+                while ((bbSize >> shifts) > 65534) {\n+                    shifts++;\n+                }\n+\n+                for (int j = 0; j < bbSize; j++) {\n+                    final int a2update = fmap[bbStart + j];\n+                    final char qVal = (char) (j >> shifts);\n+                    quadrant[a2update] = qVal;\n+                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n+                        quadrant[a2update + lastShadow + 1] = qVal;\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    private void randomiseBlock(final BZip2CompressorOutputStream.Data data,\n+                                final int lastShadow) {\n+        final boolean[] inUse = data.inUse;\n+        final byte[] block = data.block;\n+\n+        for (int i = 256; --i >= 0;) {\n+            inUse[i] = false;\n+        }\n+\n+        int rNToGo = 0;\n+        int rTPos = 0;\n+        for (int i = 0, j = 1; i <= lastShadow; i = j, j++) {\n+            if (rNToGo == 0) {\n+                rNToGo = (char) Rand.rNums(rTPos);\n+                if (++rTPos == 512) {\n+                    rTPos = 0;\n+                }\n+            }\n+\n+            rNToGo--;\n+            block[j] ^= ((rNToGo == 1) ? 1 : 0);\n+\n+            // handle 16 bit signed numbers\n+            inUse[block[j] & 0xff] = true;\n+        }\n+\n+        this.blockRandomised = true;\n+    }\n+\n+}", "timestamp": 1335855985, "metainfo": ""}