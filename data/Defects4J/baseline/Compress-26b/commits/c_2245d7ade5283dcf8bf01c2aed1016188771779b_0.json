{"sha": "2245d7ade5283dcf8bf01c2aed1016188771779b", "log": "COMPRESS-211 - handle zip extra field 0x7875 - Info Zip New Unix Extra Field  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     static {\n         implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n         register(AsiExtraField.class);\n+        register(X7875_NewUnix.class);\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+import java.util.zip.ZipException;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipUtil.reverse;\n+import static org.apache.commons.compress.archivers.zip.ZipUtil.signedByteToUnsignedInt;\n+import static org.apache.commons.compress.archivers.zip.ZipUtil.unsignedIntToSignedByte;\n+\n+/**\n+ * An extra field that stores UNIX UID/GID data (owner & group ownership) for a given\n+ * zip entry.  We're using the field definition given in Info-Zip's source archive:\n+ * zip-3.0.tar.gz/proginfo/extrafld.txt\n+ * <p/>\n+ * <pre>\n+ * Value         Size        Description\n+ * -----         ----        -----------\n+ * 0x7875        Short       tag for this extra block type (\"ux\")\n+ * TSize         Short       total data size for this block\n+ * Version       1 byte      version of this extra field, currently 1\n+ * UIDSize       1 byte      Size of UID field\n+ * UID           Variable    UID for this entry (little endian)\n+ * GIDSize       1 byte      Size of GID field\n+ * GID           Variable    GID for this entry (little endian)\n+ * </pre>\n+ */\n+public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n+    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n+    private static final long serialVersionUID = 1L;\n+\n+    private int version = 1; // always '1' according to current info-zip spec.\n+\n+    // BigInteger helps us with little-endian / big-endian conversions.\n+    // (thanks to BigInteger.toByteArray() and a reverse() method we created).\n+    // Also, the spec theoretically allows UID/GID up to 255 bytes long!\n+    private BigInteger uid;\n+    private BigInteger gid;\n+\n+    /**\n+     * Constructor for X7875_NewUnix.\n+     */\n+    public X7875_NewUnix() {\n+        reset();\n+    }\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return the value for the header id for this extrafield\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Gets the UID as a long.  UID is typically a 32 bit unsigned\n+     * value on most UNIX systems, so we return a long to avoid\n+     * integer overflow into the negatives in case values above\n+     * and including 2^31 are being used.\n+     *\n+     * @return the UID value.\n+     */\n+    public long getUID() { return ZipUtil.bigToLong(uid); }\n+\n+    /**\n+     * Gets the GID as a long.  GID is typically a 32 bit unsigned\n+     * value on most UNIX systems, so we return a long to avoid\n+     * integer overflow into the negatives in case values above\n+     * and including 2^31 are being used.\n+     *\n+     * @return the GID value.\n+     */\n+    public long getGID() { return ZipUtil.bigToLong(gid); }\n+\n+    /**\n+     * Sets the UID.\n+     *\n+     * @param l UID value to set on this extra field.\n+     */\n+    public void setUID(long l) {\n+        this.uid = ZipUtil.longToBig(l);\n+    }\n+\n+    /**\n+     * Sets the GID.\n+     *\n+     * @param l GID value to set on this extra field.\n+     */\n+    public void setGID(long l) {\n+        this.gid = ZipUtil.longToBig(l);\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n+        int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n+\n+        // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n+        return new ZipShort(3 + uidSize + gidSize);\n+    }\n+\n+    /**\n+     * Length of the extra field in the central directory data - without\n+     * Header-ID or length specifier.\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return getLocalFileDataLength();  // No different than local version.\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return get the data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        byte[] uidBytes = uid.toByteArray();\n+        byte[] gidBytes = gid.toByteArray();\n+\n+        // BigInteger might prepend a leading-zero to force a positive representation\n+        // (e.g., so that the sign-bit is set to zero).  We need to remove that\n+        // before sending the number over the wire.\n+        uidBytes = trimLeadingZeroesForceMinLength(uidBytes);\n+        gidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n+\n+        // Couldn't bring myself to just call getLocalFileDataLength() when we've\n+        // already got the arrays right here.  Yeah, yeah, I know, premature\n+        // optimization is the root of all...\n+        //\n+        // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n+        byte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n+\n+        // reverse() switches byte array from big-endian to little-endian.\n+        reverse(uidBytes);\n+        reverse(gidBytes);\n+\n+        int pos = 0;\n+        data[pos++] = unsignedIntToSignedByte(version);\n+        data[pos++] = unsignedIntToSignedByte(uidBytes.length);\n+        System.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\n+        pos += uidBytes.length;\n+        data[pos++] = unsignedIntToSignedByte(gidBytes.length);\n+        System.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\n+        return data;\n+    }\n+\n+    /**\n+     * The actual data to put into central directory data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return get the data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param data   an array of bytes\n+     * @param offset the start offset\n+     * @param length the number of bytes in the array from offset\n+     * @throws java.util.zip.ZipException on error\n+     */\n+    public void parseFromLocalFileData(\n+            byte[] data, int offset, int length\n+    ) throws ZipException {\n+        reset();\n+        this.version = signedByteToUnsignedInt(data[offset++]);\n+        int uidSize = signedByteToUnsignedInt(data[offset++]);\n+        byte[] uidBytes = new byte[uidSize];\n+        System.arraycopy(data, offset, uidBytes, 0, uidSize);\n+        offset += uidSize;\n+        this.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n+\n+        int gidSize = signedByteToUnsignedInt(data[offset++]);\n+        byte[] gidBytes = new byte[gidSize];\n+        System.arraycopy(data, offset, gidBytes, 0, gidSize);\n+        this.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n+    }\n+\n+    /**\n+     * Doesn't do anything special since this class always uses the\n+     * same data in central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(\n+            byte[] buffer, int offset, int length\n+    ) throws ZipException {\n+        reset();\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n+\n+    /**\n+     * Reset state back to newly constructed state.  Helps us make sure\n+     * parse() calls always generate clean results.\n+     */\n+    private void reset() {\n+        // Typical UID/GID of the first non-root user created on a unix system.\n+        uid = ONE_THOUSAND;\n+        gid = ONE_THOUSAND;\n+    }\n+\n+    /**\n+     * Returns a String representation of this class useful for\n+     * debugging purposes.\n+     *\n+     * @return A String representation of this class useful for\n+     *         debugging purposes.\n+     */\n+    public String toString() {\n+        return \"0x7875 Zip Extra Field: UID=\" + uid + \" GID=\" + gid;\n+    }\n+\n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o instanceof X7875_NewUnix) {\n+            X7875_NewUnix xf = (X7875_NewUnix) o;\n+            if (version == xf.version) {\n+                // The BigInteger==BigInteger clause handles the case where both are null.\n+                if (uid == xf.uid || (uid != null && uid.equals(xf.uid))) {\n+                    return gid == xf.gid || (gid != null && gid.equals(xf.gid));\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hc = (-1234567 * version);\n+        if (uid != null) {\n+            hc ^= uid.hashCode();\n+        }\n+        if (gid != null) {\n+            hc ^= gid.hashCode();\n+        }\n+        return hc;\n+    }\n+\n+    /**\n+     * Not really for external usage, but marked \"package\" visibility\n+     * to help us JUnit it.   Trims a byte array of leading zeroes while\n+     * also enforcing a minimum length, and thus it really trims AND pads\n+     * at the same time.\n+     *\n+     * @param array byte[] array to trim & pad.\n+     * @return trimmed & padded byte[] array.\n+     */\n+    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n+        if (array == null) {\n+            return array;\n+        }\n+\n+        int pos = 0;\n+        for (byte b : array) {\n+            if (b == 0) {\n+                pos++;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        /*\n+\n+        I agonized over my choice of MIN_LENGTH=1.  Here's the situation:\n+        InfoZip (the tool I am using to test interop) always sets these\n+        to length=4.  And so a UID of 0 (typically root) for example is\n+        encoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\n+        as easily be encoded as {1,0} (len=1, 8 bits of zero) according to\n+        the spec.\n+\n+        In the end I decided on MIN_LENGTH=1 for four reasons:\n+\n+        1.)  We are adhering to the spec as far as I can tell, and so\n+             a consumer that cannot parse this is broken.\n+\n+        2.)  Fundamentally, zip files are about shrinking things, so\n+             let's save a few bytes per entry while we can.\n+\n+        3.)  Of all the people creating zip files using commons-\n+             compress, how many care about UNIX UID/GID attributes\n+             of the files they store?   (e.g., I am probably thinking\n+             way too hard about this and no one cares!)\n+\n+        4.)  InfoZip's tool, even though it carefully stores every UID/GID\n+             for every file zipped on a unix machine (by default) currently\n+             appears unable to ever restore UID/GID.\n+             unzip -X has no effect on my machine, even when run as root!!!!\n+\n+        And thus it is decided:  MIN_LENGTH=1.\n+\n+        If anyone runs into interop problems from this, feel free to set\n+        it to MIN_LENGTH=4 at some future time, and then we will behave\n+        exactly like InfoZip (requires changes to unit tests, though).\n+\n+        And I am sorry that the time you spent reading this comment is now\n+        gone and you can never have it back.\n+\n+        */\n+        final int MIN_LENGTH = 1;\n+\n+        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n+        int startPos = trimmedArray.length - (array.length - pos);\n+        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n+        return trimmedArray;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.io.IOException;\n+import java.math.BigInteger;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.zip.CRC32;\n      * Assumes a negative integer really is a positive integer that\n      * has wrapped around and re-creates the original value.\n      *\n-     * <p>This methods is no longer used as of Apache Commons Compress\n-     * 1.3</p>\n-     *\n      * @param i the value to treat as unsigned int.\n      * @return the unsigned int as a long.\n      */\n             return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n         } else {\n             return i;\n+        }\n+    }\n+\n+    /**\n+     * Reverses a byte[] array.  Reverses in-place (thus provided array is\n+     * mutated), but also returns same for convenience.\n+     *\n+     * @param array to reverse (mutated in-place, but also returned for\n+     *        convenience).\n+     *\n+     * @return the reversed array (mutated in-place, but also returned for\n+     *        convenience).\n+     */\n+    public static byte[] reverse(final byte[] array) {\n+        final int z = array.length - 1; // position of last element\n+        for (int i = 0; i < array.length / 2; i++) {\n+            byte x = array[i];\n+            array[i] = array[z - i];\n+            array[z - i] = x;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Converts a BigInteger into a long, and blows up\n+     * (NumberFormatException) if the BigInteger is too big.\n+     *\n+     * @param big BigInteger to convert.\n+     * @return long representation of the BigInteger.\n+     */\n+    static long bigToLong(BigInteger big) {\n+        if (big.bitLength() <= 63) { // bitLength() doesn't count the sign bit.\n+            return big.longValue();\n+        } else {\n+            throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + big + \"]\");\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into a BigInteger.  Negative numbers between -1 and\n+     * -2^31 are treated as unsigned 32 bit (e.g., positive) integers.\n+     * Negative numbers below -2^31 cause an IllegalArgumentException\n+     * to be thrown.\n+     * </p>\n+     *\n+     * @param l long to convert to BigInteger.\n+     * @return BigInteger representation of the provided long.\n+     */\n+    static BigInteger longToBig(long l) {\n+        if (l < Integer.MIN_VALUE) {\n+            throw new IllegalArgumentException(\"Negative longs < -2^31 not permitted: [\" + l + \"]\");\n+        } else if (l < 0 && l >= Integer.MIN_VALUE) {\n+            // If someone passes in a -2, they probably mean 4294967294\n+            // (For example, Unix UID/GID's are 32 bit unsigned.)\n+            l = ZipUtil.adjustToLong((int) l);\n+        }\n+        return BigInteger.valueOf(l);\n+    }\n+\n+    /**\n+     * Converts a signed byte into an unsigned integer representation\n+     * (e.g., -1 becomes 255).\n+     *\n+     * @param b byte to convert to int\n+     * @return int representation of the provided byte\n+     */\n+    public static int signedByteToUnsignedInt(byte b) {\n+        if (b >= 0) {\n+            return b;\n+        } else {\n+            return 256 + b;\n+        }\n+    }\n+\n+    /**\n+     * Converts an unsigned integer to a signed byte (e.g., 255 becomes -1).\n+     *\n+     * @param i integer to convert to byte\n+     * @return byte representation of the provided int\n+     * @throws IllegalArgumentException if the provided integer is not inside the range [0,255].\n+     */\n+    public static byte unsignedIntToSignedByte(int i) {\n+        if (i > 255 || i < 0) {\n+            throw new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n+        }\n+        if (i < 128) {\n+            return (byte) i;\n+        } else {\n+            return (byte) (i - 256);\n         }\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.zip.ZipException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class X7875_NewUnixTest {\n+\n+    private final static ZipShort X7875 = new ZipShort(0x7875);\n+\n+    private X7875_NewUnix xf;\n+\n+    @Before\n+    public void before() {\n+        xf = new X7875_NewUnix();\n+    }\n+\n+\n+    @Test\n+    public void testSampleFile() throws Exception {\n+        URL zip = getClass().getResource(\"/COMPRESS-211_uid_gid_zip_test.zip\");\n+        File archive = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+\n+        try {\n+            zf = new ZipFile(archive);\n+            Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+\n+            // We expect EVERY entry of this zip file (dir & file) to\n+            // contain extra field 0x7875.\n+            while (en.hasMoreElements()) {\n+\n+                ZipArchiveEntry zae = en.nextElement();\n+                String name = zae.getName();\n+                X7875_NewUnix xf = (X7875_NewUnix) zae.getExtraField(X7875);\n+\n+                // The directory entry in the test zip file is uid/gid 1000.\n+                long expected = 1000;\n+                if (name.contains(\"uid555_gid555\")) {\n+                    expected = 555;\n+                } else if (name.contains(\"uid5555_gid5555\")) {\n+                    expected = 5555;\n+                } else if (name.contains(\"uid55555_gid55555\")) {\n+                    expected = 55555;\n+                } else if (name.contains(\"uid555555_gid555555\")) {\n+                    expected = 555555;\n+                } else if (name.contains(\"min_unix\")) {\n+                    expected = 0;\n+                } else if (name.contains(\"max_unix\")) {\n+                    // 2^32-2 was the biggest UID/GID I could create on my linux!\n+                    // (December 2012, linux kernel 3.4)\n+                    expected = 0x100000000L - 2;\n+                }\n+                assertEquals(expected, xf.getUID());\n+                assertEquals(expected, xf.getGID());\n+            }\n+        } finally {\n+            if (zf != null) {\n+                zf.close();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetHeaderId() {\n+        assertEquals(X7875, xf.getHeaderId());\n+    }\n+\n+    @Test\n+    public void testMisc() throws Exception {\n+        assertTrue(xf.toString().startsWith(\"0x7875 Zip Extra Field\"));\n+        Object o = xf.clone();\n+        assertEquals(o.hashCode(), xf.hashCode());\n+        assertTrue(xf.equals(o));\n+    }\n+\n+    @Test\n+    public void testTrimLeadingZeroesForceMinLength4() throws ZipException {\n+        final byte[] NULL = null;\n+        final byte[] EMPTY = new byte[0];\n+        final byte[] ONE_ZERO = {0};\n+        final byte[] TWO_ZEROES = {0, 0};\n+        final byte[] FOUR_ZEROES = {0, 0, 0, 0};\n+        final byte[] SEQUENCE = {1, 2, 3};\n+        final byte[] SEQUENCE_LEADING_ZERO = {0, 1, 2, 3};\n+        final byte[] SEQUENCE_LEADING_ZEROES = {0, 0, 0, 0, 0, 0, 0, 1, 2, 3};\n+        final byte[] TRAILING_ZERO = {1, 2, 3, 0};\n+        final byte[] PADDING_ZERO = {0, 1, 2, 3, 0};\n+        final byte[] SEQUENCE6 = {1, 2, 3, 4, 5, 6};\n+        final byte[] SEQUENCE6_LEADING_ZERO = {0, 1, 2, 3, 4, 5, 6};\n+\n+        assertTrue(NULL == trimTest(NULL));\n+        assertTrue(Arrays.equals(ONE_ZERO, trimTest(EMPTY)));\n+        assertTrue(Arrays.equals(ONE_ZERO, trimTest(ONE_ZERO)));\n+        assertTrue(Arrays.equals(ONE_ZERO, trimTest(TWO_ZEROES)));\n+        assertTrue(Arrays.equals(ONE_ZERO, trimTest(FOUR_ZEROES)));\n+        assertTrue(Arrays.equals(SEQUENCE, trimTest(SEQUENCE)));\n+        assertTrue(Arrays.equals(SEQUENCE, trimTest(SEQUENCE_LEADING_ZERO)));\n+        assertTrue(Arrays.equals(SEQUENCE, trimTest(SEQUENCE_LEADING_ZEROES)));\n+        assertTrue(Arrays.equals(TRAILING_ZERO, trimTest(TRAILING_ZERO)));\n+        assertTrue(Arrays.equals(TRAILING_ZERO, trimTest(PADDING_ZERO)));\n+        assertTrue(Arrays.equals(SEQUENCE6, trimTest(SEQUENCE6)));\n+        assertTrue(Arrays.equals(SEQUENCE6, trimTest(SEQUENCE6_LEADING_ZERO)));\n+    }\n+\n+    private static byte[] trimTest(byte[] b) { return X7875_NewUnix.trimLeadingZeroesForceMinLength(b); }\n+\n+    @Test\n+    public void testParseReparse() throws ZipException {\n+\n+        // Version=1, Len=1, zero, Len=1, zero.\n+        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n+\n+        // Version=1, Len=1, one, Len=1, one\n+        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n+\n+        // Version=1, Len=2, one thousand, Len=2, one thousand\n+        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n+\n+        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n+        // two's complement, and -1 often has a special meaning.\n+        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n+\n+        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n+        // Esoteric test:  can we handle 40 bit numbers?\n+        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n+\n+        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n+        // Esoteric test:  can we handle 64 bit numbers?\n+        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n+\n+        final long TWO_TO_32 = 0x100000000L;\n+        final long MAX = TWO_TO_32 - 2;\n+\n+        parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n+        parseReparse(1, 1, ONE_UID_GID, 1, 1);\n+        parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n+        parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n+        parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n+        parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n+        parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n+\n+        // We never emit this, but we should be able to parse it:\n+        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n+        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n+        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n+\n+        assertEquals(255, xf.getUID());\n+        assertEquals(128, xf.getGID());\n+        assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n+\n+        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n+        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n+        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n+\n+        assertEquals(65535, xf.getUID());\n+        assertEquals(513, xf.getGID());\n+        assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n+    }\n+\n+\n+    private void parseReparse(\n+            final long uid,\n+            final long gid,\n+            final byte[] expected,\n+            final long expectedUID,\n+            final long expectedGID\n+    ) throws ZipException {\n+        xf.setUID(uid);\n+        xf.setGID(gid);\n+        assertEquals(expected.length, xf.getLocalFileDataLength().getValue());\n+        byte[] result = xf.getLocalFileDataData();\n+        assertTrue(Arrays.equals(expected, result));\n+\n+        // And now we re-parse:\n+        xf.parseFromLocalFileData(result, 0, result.length);\n+\n+        // Did uid/gid change from re-parse?  They shouldn't!\n+        assertEquals(expectedUID, xf.getUID());\n+        assertEquals(expectedGID, xf.getGID());\n+\n+        // Do the same as above, but with Central Directory data:\n+        xf.setUID(uid);\n+        xf.setGID(gid);\n+        assertEquals(expected.length, xf.getCentralDirectoryLength().getValue());\n+        result = xf.getCentralDirectoryData();\n+        assertTrue(Arrays.equals(expected, result));\n+\n+        // And now we re-parse:\n+        xf.parseFromCentralDirectoryData(result, 0, result.length);\n+\n+        // Did uid/gid change from 2nd re-parse?  They shouldn't!\n+        assertEquals(expectedUID, xf.getUID());\n+        assertEquals(expectedGID, xf.getGID());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import junit.framework.TestCase;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n-\n-import junit.framework.TestCase;\n \n public class ZipUtilTest extends TestCase {\n \n         byte[] b2 = ZipUtil.toDosTime(0); // get the same time\n         assertEquals(b10,b2[0]); // first byte should still be the same\n     }\n+\n+    public void testReverse() {\n+        byte[][] bTest = new byte[6][];\n+        bTest[0] = new byte[]{};\n+        bTest[1] = new byte[]{1};\n+        bTest[2] = new byte[]{1, 2};\n+        bTest[3] = new byte[]{1, 2, 3};\n+        bTest[4] = new byte[]{1, 2, 3, 4};\n+        bTest[5] = new byte[]{1, 2, 3, 4, 5};\n+\n+        byte[][] rTest = new byte[6][];\n+        rTest[0] = new byte[]{};\n+        rTest[1] = new byte[]{1};\n+        rTest[2] = new byte[]{2, 1};\n+        rTest[3] = new byte[]{3, 2, 1};\n+        rTest[4] = new byte[]{4, 3, 2, 1};\n+        rTest[5] = new byte[]{5, 4, 3, 2, 1};\n+\n+        assertEquals(\"test and result arrays are same length\", bTest.length, rTest.length);\n+\n+        for (int i = 0; i < bTest.length; i++) {\n+            byte[] result = ZipUtil.reverse(bTest[i]);\n+            assertTrue(\"reverse mutates in-place\", bTest[i] == result);\n+            assertTrue(\"reverse actually reverses\", Arrays.equals(rTest[i], result));\n+        }\n+    }\n+\n+    public void testBigToLong() {\n+        BigInteger big1 = BigInteger.valueOf(1);\n+        BigInteger big2 = BigInteger.valueOf(Long.MAX_VALUE);\n+        BigInteger big3 = BigInteger.valueOf(Long.MIN_VALUE);\n+\n+        assertEquals(1L, ZipUtil.bigToLong(big1));\n+        assertEquals(Long.MAX_VALUE, ZipUtil.bigToLong(big2));\n+        assertEquals(Long.MIN_VALUE, ZipUtil.bigToLong(big3));\n+\n+        BigInteger big4 = big2.add(big1);\n+        try {\n+            ZipUtil.bigToLong(big4);\n+            fail(\"Should have thrown IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+\n+        BigInteger big5 = big3.subtract(big1);\n+        try {\n+            ZipUtil.bigToLong(big5);\n+            fail(\"ZipUtil.bigToLong(BigInteger) should have thrown IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+    }\n+\n+    public void testLongToBig() {\n+        long l0 = 0;\n+        long l1 = 1;\n+        long l2 = -1;\n+        long l3 = Integer.MIN_VALUE;\n+        long l4 = Long.MAX_VALUE;\n+        long l5 = Long.MIN_VALUE;\n+\n+        BigInteger big0 = ZipUtil.longToBig(l0);\n+        BigInteger big1 = ZipUtil.longToBig(l1);\n+        BigInteger big2 = ZipUtil.longToBig(l2);\n+        BigInteger big3 = ZipUtil.longToBig(l3);\n+        BigInteger big4 = ZipUtil.longToBig(l4);\n+\n+        assertEquals(0, big0.longValue());\n+        assertEquals(1, big1.longValue());\n+        assertEquals(0xFFFFFFFFL, big2.longValue());\n+        assertEquals(0x80000000L, big3.longValue());\n+        assertEquals(Long.MAX_VALUE, big4.longValue());\n+\n+        try {\n+            ZipUtil.longToBig(l5);\n+            fail(\"ZipUtil.longToBig(long) should have thrown IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+\n+        }\n+    }\n+\n+    public void testSignedByteToUnsignedInt() {\n+        // Yay, we can completely test all possible input values in this case!\n+        int expectedVal = 128;\n+        for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\n+            byte b = (byte) i;\n+            assertEquals(expectedVal, ZipUtil.signedByteToUnsignedInt(b));\n+            expectedVal++;\n+            if (expectedVal == 256) {\n+                expectedVal = 0;\n+            }\n+        }\n+    }\n+\n+    public void testUnsignedIntToSignedByte() {\n+        int unsignedVal = 128;\n+        for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\n+            byte expectedVal = (byte) i;\n+            assertEquals(expectedVal, ZipUtil.unsignedIntToSignedByte(unsignedVal));\n+            unsignedVal++;\n+            if (unsignedVal == 256) {\n+                unsignedVal = 0;\n+            }\n+        }\n+\n+        try {\n+            ZipUtil.unsignedIntToSignedByte(-1);\n+            fail(\"ZipUtil.unsignedIntToSignedByte(-1) should have thrown IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+\n+        try {\n+            ZipUtil.unsignedIntToSignedByte(256);\n+            fail(\"ZipUtil.unsignedIntToSignedByte(256) should have thrown IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+\n+    }\n+\n+\n }", "timestamp": 1357603998, "metainfo": ""}