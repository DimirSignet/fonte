{"sha": "b64aa8a7bc99fbc4a97e09af83429d5d289fe510", "log": "address issues detected by FindBugs and PMD  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n \n package org.apache.commons.compress.archivers.tar;\n \n-import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Map.Entry;\n     }\n \n     private void paxHeaders() throws IOException{\n-        BufferedReader br = new BufferedReader(new InputStreamReader(this, \"UTF-8\"));\n+        Reader br = new InputStreamReader(this, \"UTF-8\") {\n+                public void close() {\n+                    // make sure GC doesn't close \"this\" before we are done\n+                }\n+            };\n         Map<String, String> headers = new HashMap<String, String>();\n         // Format is \"length keyword=value\\n\";\n+        try {\n         while(true){ // get length\n             int ch;\n             int len=0;\n                 break;\n             }\n         }\n+        } finally {\n+            // NO-OP but makes FindBugs happy\n+            br.close();\n+        }\n+\n         getNextEntry(); // Get the actual file entry\n         /*\n          * The following headers are defined for Pax.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n-import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.DATA_DESCRIPTOR_MIN_VERSION;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.INITIAL_VERSION;\n             if (_raf != null) {\n                 try {\n                     _raf.close();\n-                } catch (IOException inner) {\n+                } catch (IOException inner) { // NOPMD\n                     // ignore\n                 }\n                 _raf = null;\n             return;\n         }\n \n-        if (!hasUsedZip64) {\n-            if (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n-                || entries.size() >= ZIP64_MAGIC_SHORT) {\n+        if (!hasUsedZip64\n+            && (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n+                || entries.size() >= ZIP64_MAGIC_SHORT)) {\n                 // actually \"will use\"\n                 hasUsedZip64 = true;\n-            }\n         }\n \n         if (!hasUsedZip64) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.EOFException;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n      */\n     private void positionAtCentralDirectory64()\n         throws IOException {\n-        archive.skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n+        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n         byte[] zip64EocdOffset = new byte[DWORD];\n         archive.readFully(zip64EocdOffset);\n         archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n             throw new ZipException(\"archive's ZIP64 end of central \"\n                                    + \"directory locator is corrupt.\");\n         }\n-        archive.skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n-                          - WORD /* signature has already been read */);\n+        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n+                  - WORD /* signature has already been read */);\n         byte[] cfdOffset = new byte[DWORD];\n         archive.readFully(cfdOffset);\n         archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n         if (!found) {\n             throw new ZipException(\"archive is not a ZIP archive\");\n         }\n-        archive.skipBytes(CFD_LOCATOR_OFFSET);\n+        skipBytes(CFD_LOCATOR_OFFSET);\n         byte[] cfdOffset = new byte[WORD];\n         archive.readFully(cfdOffset);\n         archive.seek(ZipLong.getValue(cfdOffset));\n     }\n \n     /**\n+     * Skips the given number of bytes or throws an EOFException if\n+     * skipping failed.\n+     */ \n+    private void skipBytes(final int count) throws IOException {\n+        int totalSkipped = 0;\n+        while (totalSkipped < count) {\n+            int skippedNow = archive.skipBytes(count - totalSkipped);\n+            if (skippedNow <= 0) {\n+                throw new EOFException();\n+            }\n+            totalSkipped += skippedNow;\n+        }\n+    }\n+\n+    /**\n      * Number of bytes in local file header up to the &quot;length of\n      * filename&quot; entry.\n      */", "timestamp": 1313300393, "metainfo": ""}