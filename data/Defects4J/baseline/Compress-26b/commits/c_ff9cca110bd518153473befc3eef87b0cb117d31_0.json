{"sha": "ff9cca110bd518153473befc3eef87b0cb117d31", "log": "Always use blocks for conditional statements  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n             throws IOException {\n         // Mark support is strictly needed for concatenated files only,\n         // but it's simpler if it is always available.\n-        if (inputStream.markSupported())\n+        if (inputStream.markSupported()) {\n             in = inputStream;\n-        else\n+        } else {\n             in = new BufferedInputStream(inputStream);\n+        }\n \n         this.decompressConcatenated = decompressConcatenated;\n         init(true);\n \n         // If end of input was reached after decompressing at least\n         // one .gz member, we have reached the end of the file successfully.\n-        if (magic0 == -1 && !isFirstMember)\n+        if (magic0 == -1 && !isFirstMember) {\n             return false;\n-\n-        if (magic0 != 31 || magic1 != 139)\n+        }\n+\n+        if (magic0 != 31 || magic1 != 139) {\n             throw new IOException(isFirstMember\n                                   ? \"Input is not in the .gz format\"\n                                   : \"Garbage after a valid .gz stream\");\n+        }\n \n         // Parsing the rest of the header may throw EOFException.\n         DataInputStream inData = new DataInputStream(in);\n         int method = inData.readUnsignedByte();\n-        if (method != 8)\n+        if (method != 8) {\n             throw new IOException(\"Unsupported compression method \"\n                                   + method + \" in the .gz header\");\n+        }\n \n         int flg = inData.readUnsignedByte();\n-        if ((flg & FRESERVED) != 0)\n+        if ((flg & FRESERVED) != 0) {\n             throw new IOException(\n                     \"Reserved flags are set in the .gz header\");\n+        }\n \n         inData.readInt(); // mtime, ignored\n         inData.readUnsignedByte(); // extra flags, ignored\n             // This isn't as efficient as calling in.skip would be,\n             // but it's lazier to handle unexpected end of input this way.\n             // Most files don't have an extra field anyway.\n-            while (xlen-- > 0)\n+            while (xlen-- > 0) {\n                 inData.readUnsignedByte();\n+            }\n         }\n \n         // Original file name, ignored\n-        if ((flg & FNAME) != 0)\n+        if ((flg & FNAME) != 0) {\n             while (inData.readUnsignedByte() != 0x00) {}\n+        }\n \n         // Comment, ignored\n-        if ((flg & FCOMMENT) != 0)\n+        if ((flg & FCOMMENT) != 0) {\n             while (inData.readUnsignedByte() != 0x00) {}\n+        }\n \n         // Header \"CRC16\" which is actually a truncated CRC32 (which isn't\n         // as good as real CRC16). I don't know if any encoder implementation\n         // sets this, so it's not worth trying to verify it. GNU gzip 1.4\n         // doesn't support this field, but zlib seems to be able to at least\n         // skip over it.\n-        if ((flg & FHCRC) != 0)\n+        if ((flg & FHCRC) != 0) {\n             inData.readShort();\n+        }\n \n         // Reset\n         inf.reset();\n      */\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-        if (endReached)\n+        if (endReached) {\n             return -1;\n+        }\n \n         int size = 0;\n \n                 in.mark(buf.length);\n \n                 bufUsed = in.read(buf);\n-                if (bufUsed == -1)\n+                if (bufUsed == -1) {\n                     throw new EOFException();\n+                }\n \n                 inf.setInput(buf, 0, bufUsed);\n             }\n                 in.reset();\n \n                 int skipAmount = bufUsed - inf.getRemaining();\n-                if (in.skip(skipAmount) != skipAmount)\n+                if (in.skip(skipAmount) != skipAmount) {\n                     throw new IOException();\n+                }\n \n                 bufUsed = 0;\n \n \n                 // CRC32\n                 long crcStored = 0;\n-                for (int i = 0; i < 4; ++i)\n+                for (int i = 0; i < 4; ++i) {\n                     crcStored |= (long)inData.readUnsignedByte() << (i * 8);\n-\n-                if (crcStored != crc.getValue())\n+                }\n+\n+                if (crcStored != crc.getValue()) {\n                     throw new IOException(\"Gzip-compressed data is corrupt \"\n                                           + \"(CRC32 error)\");\n+                }\n \n                 // Uncompressed size modulo 2^32 (ISIZE in the spec)\n                 int isize = 0;\n-                for (int i = 0; i < 4; ++i)\n+                for (int i = 0; i < 4; ++i) {\n                     isize |= inData.readUnsignedByte() << (i * 8);\n-\n-                if (isize != memberSize)\n+                }\n+\n+                if (isize != memberSize) {\n                     throw new IOException(\"Gzip-compressed data is corrupt\"\n                                           + \"(uncompressed size mismatch)\");\n+                }\n \n                 // See if this is the end of the file.\n                 if (!decompressConcatenated || !init(false)) {", "timestamp": 1333190686, "metainfo": ""}