{"sha": "429462a14d4f87846adf3e9a7109d8afdf3d5195", "log": "Formatting  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n  */\n public class ZipArchiveInputStream extends ArchiveInputStream {\n \n-    /**\n-     * The zip encoding to use for filenames and the file comment.\n-     */\n+    /** The zip encoding to use for filenames and the file comment. */\n     private final ZipEncoding zipEncoding;\n \n-    /**\n-     * Whether to look for and use Unicode extra fields.\n-     */\n+    /** Whether to look for and use Unicode extra fields. */\n     private final boolean useUnicodeExtraFields;\n \n-    /**\n-     * Wrapped stream, will always be a PushbackInputStream.\n-     */\n+    /** Wrapped stream, will always be a PushbackInputStream. */\n     private final InputStream in;\n \n-    /**\n-     * Inflater used for all deflated entries.\n-     */\n+    /** Inflater used for all deflated entries. */\n     private final Inflater inf = new Inflater(true);\n \n-    /**\n-     * Buffer used to read from the wrapped stream.\n-     */\n+    /** Buffer used to read from the wrapped stream. */\n     private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n-    /**\n-     * The entry that is currently being read.\n-     */\n+\n+    /** The entry that is currently being read. */\n     private CurrentEntry current = null;\n-    /**\n-     * Whether the stream has been closed.\n-     */\n+\n+    /** Whether the stream has been closed. */\n     private boolean closed = false;\n-    /**\n-     * Whether the stream has reached the central directory - and thus\n-     * found all entries.\n-     */\n+\n+    /** Whether the stream has reached the central directory - and thus found all entries. */\n     private boolean hitCentralDirectory = false;\n+\n     /**\n      * When reading a stored entry that uses the data descriptor this\n      * stream has to read the full entry and caches it.  This is the\n      */\n     private ByteArrayInputStream lastStoredEntry = null;\n \n-    /**\n-     * Whether the stream will try to read STORED entries that use a\n-     * data descriptor.\n-     */\n+    /** Whether the stream will try to read STORED entries that use a data descriptor. */\n     private boolean allowStoredEntriesWithDataDescriptor = false;\n \n     private static final int LFH_LEN = 30;\n      * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n      * Extra Fields (if present) to set the file names.\n      */\n-    public ZipArchiveInputStream(InputStream inputStream,\n-                                 String encoding,\n-                                 boolean useUnicodeExtraFields) {\n+    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n         this(inputStream, encoding, useUnicodeExtraFields, false);\n     }\n \n \n         int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n         off += SHORT;\n-        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n-                                  & ZipFile.NIBLET_MASK);\n+        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n \n         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n-        final ZipEncoding entryEncoding =\n-            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n         current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n         current.entry.setGeneralPurposeBit(gpFlag);\n \n         current.entry.setExtra(extraData);\n \n         if (!hasUTF8Flag && useUnicodeExtraFields) {\n-            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\n-                                                     null);\n+            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n         }\n \n         processZip64Extra(size, cSize);\n         readFully(lfh);\n         ZipLong sig = new ZipLong(lfh);\n         if (sig.equals(ZipLong.DD_SIG)) {\n-            throw new\n-                UnsupportedZipFeatureException(UnsupportedZipFeatureException\n-                                               .Feature.SPLITTING);\n-        }\n+            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n+        }\n+\n         if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n             // The archive is not really split as only one segment was\n             // needed in the end.  Just skip over the marker.\n      */\n     private void processZip64Extra(ZipLong size, ZipLong cSize) {\n         Zip64ExtendedInformationExtraField z64 =\n-            (Zip64ExtendedInformationExtraField)\n-            current.entry.getExtraField(Zip64ExtendedInformationExtraField\n-                                        .HEADER_ID);\n+            (Zip64ExtendedInformationExtraField) \n+            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         current.usesZip64 = z64 != null;\n         if (!current.hasDataDescriptor) {\n             if (z64 != null // same as current.usesZip64 but avoids NPE warning\n-                    && (cSize.equals(ZipLong.ZIP64_MAGIC)\n-                                      || size.equals(ZipLong.ZIP64_MAGIC))\n-                ) {\n-                current.entry.setCompressedSize(z64.getCompressedSize()\n-                                                .getLongValue());\n+                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n+                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                 current.entry.setSize(z64.getSize().getLongValue());\n             } else {\n                 current.entry.setCompressedSize(cSize.getValue());\n     /**\n      * Implementation of read for STORED entries.\n      */\n-    private int readStored(byte[] buffer, int offset, int length)\n-        throws IOException {\n+    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n \n         if (current.hasDataDescriptor) {\n             if (lastStoredEntry == null) {\n     /**\n      * Implementation of read for DEFLATED entries.\n      */\n-    private int readDeflated(byte[] buffer, int offset, int length)\n-        throws IOException {\n+    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n         int read = readFromInflater(buffer, offset, length);\n         if (read <= 0) {\n             if (inf.finished()) {\n      * Potentially reads more bytes to fill the inflater's buffer and\n      * reads from it.\n      */\n-    private int readFromInflater(byte[] buffer, int offset, int length)\n-        throws IOException {\n+    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n         int read = 0;\n         do {\n             if (inf.needsInput()) {\n             long skipped = 0;\n             while (skipped < value) {\n                 long rem = value - skipped;\n-                int x = read(SKIP_BUF, 0,\n-                             (int) (SKIP_BUF.length > rem ? rem\n-                                    : SKIP_BUF.length));\n+                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                 if (x == -1) {\n                     return skipped;\n                 }\n      * Does not currently handle self-extracting zips which may have arbitrary\n      * leading content.\n      *\n-     * @param signature\n-     *            the bytes to check\n-     * @param length\n-     *            the number of bytes to check\n+     * @param signature the bytes to check\n+     * @param length    the number of bytes to check\n      * @return true, if this stream is a zip archive stream, false otherwise\n      */\n     public static boolean matches(byte[] signature, int length) {\n         return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n             || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n             || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n-            || checksig(signature,\n-                        ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n-    }\n-\n-    private static boolean checksig(byte[] signature, byte[] expected){\n+            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n+    }\n+\n+    private static boolean checksig(byte[] signature, byte[] expected) {\n         for (int i = 0; i < expected.length; i++) {\n             if (signature[i] != expected[i]) {\n                 return false;\n \n         // Ensure all entry bytes are read\n         if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n-            && !current.hasDataDescriptor) {\n+                && !current.hasDataDescriptor) {\n             drainCurrentEntryData();\n         } else {\n             skip(Long.MAX_VALUE);\n \n-            long inB =\n-                current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n-                ? getBytesInflated() : current.bytesRead;\n+            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n+                       ? getBytesInflated() : current.bytesRead;\n \n             // this is at most a single read() operation and can't\n             // exceed the range of int\n      * that hasn't been read, yet.\n      */\n     private void drainCurrentEntryData() throws IOException {\n-        long remaining = current.entry.getCompressedSize()\n-            - current.bytesReadFromStream;\n+        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n         while (remaining > 0) {\n             long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n-                throw new EOFException(\n-                                       \"Truncated ZIP entry: \" + current.entry.getName());\n+                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n             } else {\n                 count(n);\n                 remaining -= n;\n         // bytes, otherwise sizes are eight bytes each.\n         readFully(TWO_DWORD_BUF);\n         ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n-        if (potentialSig.equals(ZipLong.CFH_SIG)\n-            || potentialSig.equals(ZipLong.LFH_SIG)) {\n+        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n             pushback(TWO_DWORD_BUF, DWORD, DWORD);\n             current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n             current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n         } else {\n-            current.entry\n-                .setCompressedSize(ZipEightByteInteger\n-                                   .getLongValue(TWO_DWORD_BUF));\n-            current.entry.setSize(ZipEightByteInteger\n-                                  .getLongValue(TWO_DWORD_BUF, DWORD));\n+            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n+            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n         }\n     }\n \n      * <p>If it contains such a signature, reads the data descriptor\n      * and positions the stream right after the data descriptor.</p>\n      */\n-    private boolean bufferContainsSignature(ByteArrayOutputStream bos,\n-                                            int offset, int lastRead,\n-                                            int expectedDDLen)\n-        throws IOException {\n+    private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\n+            throws IOException {\n+\n         boolean done = false;\n         int readTooMuch = 0;\n         for (int i = 0; !done && i < lastRead - 4; i++) {\n      * <p>Data descriptor plus incomplete signature (3 bytes in the\n      * worst case) can be 20 bytes max.</p>\n      */\n-    private int cacheBytesRead(ByteArrayOutputStream bos, int offset,\n-                               int lastRead, int expecteDDLen) {\n+    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n         final int cacheable = offset + lastRead - expecteDDLen - 3;\n         if (cacheable > 0) {\n             bos.write(buf.array(), 0, cacheable);\n         return offset;\n     }\n \n-    private void pushback(byte[] buf, int offset, int length)\n-        throws IOException {\n+    private void pushback(byte[] buf, int offset, int length) throws IOException {\n         ((PushbackInputStream) in).unread(buf, offset, length);\n         pushedBackBytes(length);\n     }\n         // data so it will be too short.\n         realSkip(entriesRead * CFH_LEN - LFH_LEN);\n         findEocdRecord();\n-        realSkip(ZipFile.MIN_EOCD_SIZE\n-                 - WORD /* signature */ - SHORT /* comment len */);\n+        realSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n         readFully(SHORT_BUF);\n         // file comment\n         realSkip(ZipShort.getValue(SHORT_BUF));\n \n     /**\n      * Reads forward until the signature of the &quot;End of central\n-     * directory&quot; recod is found.\n+     * directory&quot; record is found.\n      */\n     private void findEocdRecord() throws IOException {\n         int currentByte = -1;\n             long skipped = 0;\n             while (skipped < value) {\n                 long rem = value - skipped;\n-                int x = in.read(SKIP_BUF, 0,\n-                                (int) (SKIP_BUF.length > rem ? rem\n-                                       : SKIP_BUF.length));\n+                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                 if (x == -1) {\n                     return;\n                 }\n \n     /**\n      * Reads bytes by reading from the underlying stream rather than\n-     * the (potentially inflating) archive stream - which {@link\n-     * #read} would do.\n+     * the (potentially inflating) archive stream - which {@link #read} would do.\n      *\n      * Also updates bytes-read counter.\n      */", "timestamp": 1387446797, "metainfo": ""}