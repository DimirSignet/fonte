{"sha": "425ea1a025fa4469e831760de8ae6f68572d4eae", "log": "COMPRESS-147 incomplete InputStreams for Snappy  missing (among other things):  * tests with more than 32k of data * CRC handling * other chunk types   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PushbackInputStream;\n+import java.util.Arrays;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.BoundedInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+/**\n+ * CompressorInputStream for the framing Snappy format.\n+ *\n+ * @see \"http://code.google.com/p/snappy/source/browse/trunk/framing_format.txt\"\n+ * @since 1.7\n+ */\n+public class FramedSnappyCompressorInputStream extends CompressorInputStream {\n+    private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n+    private static final int COMPRESSED_CHUNK_TYPE = 0;\n+    private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n+    private static final int PADDING_CHUNK_TYPE = 0xfe;\n+    private static final int MIN_UNSKIPPABLE_TYPE = 2;\n+    private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n+    private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n+\n+    /** The underlying stream to read compressed data from */\n+    private final PushbackInputStream in;\n+\n+    private SnappyCompressorInputStream currentCompressedChunk;\n+\n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private boolean endReached, inUncompressedChunk;\n+\n+    private int uncompressedBytesRemaining;\n+\n+    /**\n+     * Constructs a new input stream that decompresses snappy-framed-compressed data\n+     * from the specified input stream.\n+     * @param in  the InputStream from which to read the compressed data\n+     */\n+    public FramedSnappyCompressorInputStream(InputStream in) throws IOException {\n+        this.in = new PushbackInputStream(in, 1);\n+        readStreamIdentifier();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return read(oneByte, 0, 1) == -1 ? -1 : (oneByte[0] & 0xFF);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int read = readOnce(b, off, len);\n+        if (read == -1) {\n+            readNextBlock();\n+            if (endReached) {\n+                return -1;\n+            }\n+            read = readOnce(b, off, len);\n+        }\n+        return read;\n+    }\n+\n+    /**\n+     * Read from the current chunk into the given array.\n+     *\n+     * @return -1 if there is no current chunk or the number of bytes\n+     * read from the current chunk (which may be -1 if the end od the\n+     * chunk is reached.\n+     */\n+    private int readOnce(byte[] b, int off, int len) throws IOException {\n+        int read = -1;\n+        if (inUncompressedChunk) {\n+            int amount = Math.min(uncompressedBytesRemaining, len);\n+            read = in.read(b, off, amount);\n+            if (read != -1) {\n+                uncompressedBytesRemaining -= read;\n+                count(read);\n+            }\n+        } else if (currentCompressedChunk != null) {\n+            long before = currentCompressedChunk.getBytesRead();\n+            read = currentCompressedChunk.read(b, off, len);\n+            if (read == -1) {\n+                currentCompressedChunk = null;\n+            } else {\n+                count(currentCompressedChunk.getBytesRead() - before);\n+            }\n+        }\n+        return read;\n+    }\n+\n+    private void readNextBlock() throws IOException {\n+        int type = readOneByte();\n+        if (type == -1) {\n+            endReached = true;\n+        } else if (type == STREAM_IDENTIFIER_TYPE) {\n+            in.unread(type);\n+            count(-1);\n+            readStreamIdentifier();\n+            readNextBlock();\n+        } else if (type == PADDING_CHUNK_TYPE\n+                   || (type > MAX_UNSKIPPABLE_TYPE && type <= MAX_SKIPPABLE_TYPE)) {\n+            skipBlock();\n+            readNextBlock();\n+        } else if (type >= MIN_UNSKIPPABLE_TYPE && type <= MAX_UNSKIPPABLE_TYPE) {\n+            throw new IOException(\"unskippable chunk with type \" + type\n+                                  + \" detected.\");\n+        } else if (type == UNCOMPRESSED_CHUNK_TYPE) {\n+            uncompressedBytesRemaining = readSize();\n+            readCrc();\n+        } else if (type == COMPRESSED_CHUNK_TYPE) {\n+            int size = readSize();\n+            readCrc();\n+            currentCompressedChunk =\n+                new SnappyCompressorInputStream(new BoundedInputStream(in, size));\n+        } else {\n+            // impossible as all potential byte values have been covered\n+            throw new IOException(\"unknown chunk type \" + type\n+                                  + \" detected.\");\n+        }\n+    }\n+\n+    private void readCrc() throws IOException {\n+        byte[] b = new byte[4];\n+        if (IOUtils.readFully(in, b) != 4) {\n+            throw new IOException(\"premature end of stream\");\n+        }\n+        count(4);\n+    }\n+\n+    private int readSize() throws IOException {\n+        int b = 0;\n+        int sz = 0;\n+        for (int i = 0; i < 3; i++) {\n+            b = readOneByte();\n+            if (b == -1) {\n+                throw new IOException(\"premature end of stream\");\n+            }\n+            sz |= (b << (i * 8));\n+        }\n+        return sz;\n+    }\n+\n+    private void skipBlock() throws IOException {\n+        int size = readSize();\n+        if (IOUtils.skip(in, size) != size) {\n+            throw new IOException(\"premature end of stream\");\n+        }\n+        count(size);\n+    }\n+\n+    private void readStreamIdentifier() throws IOException {\n+        byte[] b = new byte[10];\n+        if (10 != IOUtils.readFully(in, b) || !matches(b, 10)) {\n+            throw new IOException(\"Not a framed Snappy stream\");\n+        }\n+        count(10);\n+    }\n+\n+    private int readOneByte() throws IOException {\n+        int b = in.read();\n+        if (b != -1) {\n+            count(1);\n+            return b & 0xFF;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Checks if the signature matches what is expected for a .sz file.\n+     *\n+     * <p>.sz files start with a chuck with tag 0xff and content sNaPpY.\n+     * \n+     * @param signature the bytes to check\n+     * @param length    the number of bytes to check\n+     * @return          true if this is a .sz stream, false otherwise\n+     */\n+    public static boolean matches(byte[] signature, int length) {\n+\n+        if (length < 10) {\n+            return false;\n+        }\n+\n+        byte[] shortenedSig = signature;\n+        if (signature.length > 10) {\n+            shortenedSig = new byte[10];\n+            System.arraycopy(signature, 0, shortenedSig, 0, 10);\n+        }\n+\n+        return Arrays.equals(shortenedSig, new byte[] {\n+                (byte) STREAM_IDENTIFIER_TYPE, // tag\n+                6, 0, 0, // length\n+                's', 'N', 'a', 'P', 'p', 'Y'\n+            });\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * CompressorInputStream for the raw Snappy format.\n+ *\n+ * <p>This implementation uses an internal buffer in order to handle\n+ * the back-references that are at the heart of the LZ77 algorithm.\n+ * The size of the buffer must be at least as big as the biggest\n+ * offset used in the compressed stream.  The current version of the\n+ * Snappy algorithm as defined by Google works on 32k blocks and\n+ * doesn't contain offsets bigger than 32k which is the default block\n+ * size used by this class.</p>\n+ *\n+ * @see \"http://code.google.com/p/snappy/source/browse/trunk/format_description.txt\"\n+ * @since 1.7\n+ */\n+public class SnappyCompressorInputStream extends CompressorInputStream {\n+\n+    /** Mask used to determine the type of \"tag\" is being processed */\n+    private static final int TAG_MASK = 0x03;\n+\n+    /** Default block size */\n+    public static final int DEFAULT_BLOCK_SIZE = 32768;\n+\n+    /** Buffer to write decompressed bytes to for back-references */\n+    private final byte[] decompressBuf;\n+\n+    /** \n+     * One behind the index of the last byte in the buffer that was\n+     * written\n+     */\n+    private int writeIndex;\n+\n+    /**\n+     * Index of the next byte to be read.\n+     */\n+    private int readIndex;\n+\n+    /** The actual block size specified */\n+    private final int blockSize;\n+\n+    /** The underlying stream to read compressed data from */\n+    private final InputStream in;\n+\n+    /** The size of the uncompressed data */\n+    private final int size;\n+\n+    /**\n+     * Number of uncompressed bytes still to be read.\n+     */\n+    private int uncompressedBytesRemaining;\n+\n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private boolean endReached = false;\n+\n+    /**\n+     * Constructor using the default buffer size of 32k.\n+     * \n+     * @param is\n+     *            An InputStream to read compressed data from\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyCompressorInputStream(final InputStream is) throws IOException {\n+        this(is, DEFAULT_BLOCK_SIZE);\n+    }\n+\n+    /**\n+     * Constructor using a configurable buffer size.\n+     * \n+     * @param is\n+     *            An InputStream to read compressed data from\n+     * @param blockSize\n+     *            The block size used in compression\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyCompressorInputStream(final InputStream is, final int blockSize)\n+            throws IOException {\n+        this.in = is;\n+        this.blockSize = blockSize;\n+        this.decompressBuf = new byte[blockSize * 3];\n+        this.writeIndex = readIndex = 0;\n+        uncompressedBytesRemaining = size = (int) readSize();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return read(oneByte, 0, 1) == -1 ? -1 : (oneByte[0] & 0xFF);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() {\n+        return writeIndex - readIndex;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (endReached) {\n+            return -1;\n+        }\n+        if (len > available()) {\n+            fill(len - available());\n+        }\n+\n+        int readable = Math.min(len, available());\n+        System.arraycopy(decompressBuf, readIndex, b, off, readable);\n+        readIndex += readable;\n+        if (readIndex > blockSize) {\n+            slideBuffer();\n+        }\n+        return readable;\n+    }\n+\n+    /**\n+     * Try to fill the buffer with enoug bytes to satisfy the current read request.\n+     *\n+     * @param len the number of uncompressed bytes to read\n+     */\n+    private void fill(int len) throws IOException {\n+        if (uncompressedBytesRemaining == 0) {\n+            endReached = true;\n+        }\n+        int readNow = Math.min(len, uncompressedBytesRemaining);\n+\n+        while (readNow > 0) {\n+            final int b = readOneByte();\n+            int length = 0;\n+            int offset = 0;\n+\n+            switch (b & TAG_MASK) {\n+\n+            case 0x00:\n+\n+                length = readLiteralLength(b);\n+\n+                if (expandLiteral(length)) {\n+                    return;\n+                }\n+                break;\n+\n+            case 0x01:\n+\n+                /*\n+                 * These elements can encode lengths between [4..11] bytes and\n+                 * offsets between [0..2047] bytes. (len-4) occupies three bits\n+                 * and is stored in bits [2..4] of the tag byte. The offset\n+                 * occupies 11 bits, of which the upper three are stored in the\n+                 * upper three bits ([5..7]) of the tag byte, and the lower\n+                 * eight are stored in a byte following the tag byte.\n+                 */\n+\n+                length = 4 + ((b >> 2) & 0x07);\n+                offset = (b & 0xE0) << 3;\n+                offset |= readOneByte();\n+\n+                if (expandCopy(offset, length)) {\n+                    return;\n+                }\n+                break;\n+\n+            case 0x02:\n+\n+                /*\n+                 * These elements can encode lengths between [1..64] and offsets\n+                 * from [0..65535]. (len-1) occupies six bits and is stored in\n+                 * the upper six bits ([2..7]) of the tag byte. The offset is\n+                 * stored as a little-endian 16-bit integer in the two bytes\n+                 * following the tag byte.\n+                 */\n+\n+                length = (b >> 2) + 1;\n+\n+                offset = readOneByte();\n+                offset |= readOneByte() << 8;\n+\n+                if (expandCopy(offset, length)) {\n+                    return;\n+                }\n+                break;\n+\n+            case 0x03:\n+\n+                /*\n+                 * These are like the copies with 2-byte offsets (see previous\n+                 * subsection), except that the offset is stored as a 32-bit\n+                 * integer instead of a 16-bit integer (and thus will occupy\n+                 * four bytes).\n+                 */\n+\n+                length = (b >> 2) + 1;\n+\n+                offset = readOneByte();\n+                offset |= readOneByte() << 8;\n+                offset |= readOneByte() << 16;\n+                offset |= readOneByte() << 24;\n+\n+                if (expandCopy(offset, length)) {\n+                    return;\n+                }\n+                break;\n+            }\n+\n+            readNow -= length;\n+            uncompressedBytesRemaining -= length;\n+        }\n+    }\n+\n+    /**\n+     * Slide buffer.\n+     *\n+     * <p>Move all bytes of the buffer after the first block down\n+     * tothe beginning of the buffer.</p>\n+     */\n+    private void slideBuffer() {\n+        System.arraycopy(decompressBuf, blockSize, decompressBuf, 0,\n+                blockSize);\n+        writeIndex -= blockSize;\n+        readIndex -= blockSize;\n+    }\n+\n+\n+    /*\n+     * For literals up to and including 60 bytes in length, the\n+     * upper six bits of the tag byte contain (len-1). The literal\n+     * follows immediately thereafter in the bytestream. - For\n+     * longer literals, the (len-1) value is stored after the tag\n+     * byte, little-endian. The upper six bits of the tag byte\n+     * describe how many bytes are used for the length; 60, 61, 62\n+     * or 63 for 1-4 bytes, respectively. The literal itself follows\n+     * after the length.\n+     */\n+    private int readLiteralLength(int b) throws IOException {\n+        int length;\n+        switch (b >> 2) {\n+        case 60:\n+            length = readOneByte();\n+            break;\n+        case 61:\n+            length = readOneByte();\n+            length |= (readOneByte() << 8);\n+            break;\n+        case 62:\n+            length = readOneByte();\n+            length |= (readOneByte() << 8);\n+            length |= (readOneByte() << 16);\n+            break;\n+        case 63:\n+            length = readOneByte();\n+            length |= (readOneByte() << 8);\n+            length |= (readOneByte() << 16);\n+            length |= (readOneByte() << 24);\n+            break;\n+        default:\n+            length = b >> 2;\n+            break;\n+        }\n+\n+        return length + 1;\n+    }\n+\n+    /**\n+     * Literals are uncompressed data stored directly in the byte stream.\n+     * \n+     * @param length\n+     *            The number of bytes to read from the underlying stream\n+     * \n+     * @throws IOException\n+     *             If the first byte cannot be read for any reason other than\n+     *             end of file, or if the input stream has been closed, or if\n+     *             some other I/O error occurs.\n+     * @return True if the decompressed data should be flushed\n+     */\n+    private boolean expandLiteral(final int length) throws IOException {\n+        int bytesRead = in.read(decompressBuf, writeIndex, length);\n+        count(bytesRead);\n+        if (length != bytesRead) {\n+            throw new IOException(\"Premature end of stream\");\n+        }\n+\n+        writeIndex += length;\n+        return (writeIndex >= (2 * this.blockSize));\n+    }\n+\n+    /**\n+     * Copies are references back into previous decompressed data, telling the\n+     * decompressor to reuse data it has previously decoded. They encode two\n+     * values: The offset, saying how many bytes back from the current position\n+     * to read, and the length, how many bytes to copy. Offsets of zero can be\n+     * encoded, but are not legal; similarly, it is possible to encode\n+     * backreferences that would go past the end of the block (offset > current\n+     * decompressed position), which is also nonsensical and thus not allowed.\n+     * \n+     * @param offset\n+     *            The offset from the backward from the end of expanded stream\n+     * @param length\n+     *            The number of bytes to copy\n+     * \n+     * @throws IOException\n+     *             An the offset expands past the front of the decompression\n+     *             buffer\n+     * @return True if the decompressed data should be flushed\n+     */\n+    private boolean expandCopy(final int offset, int length) throws IOException {\n+        if (offset > blockSize) {\n+            throw new IOException(\"Offset is larger than block size\");\n+        }\n+\n+        if (offset == 1) {\n+            byte lastChar = decompressBuf[writeIndex - 1];\n+            for (int i = 0; i < length; i++) {\n+                decompressBuf[writeIndex++] = lastChar;\n+            }\n+        } else if (length < offset) {\n+            System.arraycopy(decompressBuf, writeIndex - offset,\n+                    decompressBuf, writeIndex, length);\n+            writeIndex += length;\n+        } else {\n+            int fullRotations = length / offset;\n+            int pad = length - (offset * fullRotations);\n+\n+            while (fullRotations-- != 0) {\n+                System.arraycopy(decompressBuf, writeIndex - offset,\n+                        decompressBuf, writeIndex, offset);\n+                writeIndex += offset;\n+            }\n+\n+            if (pad > 0) {\n+                System.arraycopy(decompressBuf, writeIndex - offset,\n+                        decompressBuf, writeIndex, pad);\n+\n+                writeIndex += pad;\n+            }\n+        }\n+        return (writeIndex >= (2 * this.blockSize));\n+    }\n+\n+    /**\n+     * This helper method reads the next byte of data from the input stream. The\n+     * value byte is returned as an <code>int</code> in the range <code>0</code>\n+     * to <code>255</code>. If no byte is available because the end of the\n+     * stream has been reached, an Exception is thrown.\n+     * \n+     * @return The next byte of data\n+     * @throws IOException\n+     *             EOF is reached or error reading the stream\n+     */\n+    private int readOneByte() throws IOException {\n+        int b = in.read();\n+        if (b == -1) {\n+            throw new IOException(\"Premature end of stream\");\n+        }\n+        count(1);\n+        return b & 0xFF;\n+    }\n+\n+    /**\n+     * The stream starts with the uncompressed length (up to a maximum of 2^32 -\n+     * 1), stored as a little-endian varint. Varints consist of a series of\n+     * bytes, where the lower 7 bits are data and the upper bit is set iff there\n+     * are more bytes to be read. In other words, an uncompressed length of 64\n+     * would be stored as 0x40, and an uncompressed length of 2097150 (0x1FFFFE)\n+     * would be stored as 0xFE 0xFF 0x7F.\n+     * \n+     * @return The size of the uncompressed data\n+     * \n+     * @throws IOException\n+     *             Could not read a byte\n+     */\n+    private long readSize() throws IOException {\n+        int index = 0;\n+        long sz = 0;\n+        int b = 0;\n+\n+        do {\n+            b = readOneByte();\n+            sz |= (b & 0x7f) << (index++ * 7);\n+        } while (0 != (b & 0x80));\n+        return sz;\n+    }\n+\n+    /**\n+     * Get the uncompressed size of the stream\n+     * \n+     * @return the uncompressed size\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class FramedSnappyTestCase\n+    extends AbstractTestCase {\n+\n+    public void testMatches() throws IOException {\n+        assertFalse(FramedSnappyCompressorInputStream.matches(new byte[10], 10));\n+        byte[] b = new byte[12];\n+        final File input = getFile(\"bla.tar.sz\");\n+        FileInputStream in = new FileInputStream(input);\n+        try {\n+            IOUtils.readFully(in, b);\n+        } finally {\n+            in.close();\n+        }\n+        assertFalse(FramedSnappyCompressorInputStream.matches(b, 9));\n+        assertTrue(FramedSnappyCompressorInputStream.matches(b, 10));\n+        assertTrue(FramedSnappyCompressorInputStream.matches(b, 12));\n+    }\n+\n+    public void testDefaultExtraction() throws IOException {\n+        final File input = getFile(\"bla.tar.sz\");\n+        final File output = new File(dir, \"bla.tar\");\n+        final FileInputStream is = new FileInputStream(input);\n+        try {\n+            final CompressorInputStream in =\n+                new FramedSnappyCompressorInputStream(is);\n+            FileOutputStream out = null;\n+            try {\n+                out = new FileOutputStream(output);\n+                IOUtils.copy(in, out);\n+            } finally {\n+                if (out != null) {\n+                    out.close();\n+                }\n+                in.close();\n+            }\n+        } finally {\n+            is.close();\n+        }\n+        final File original = getFile(\"bla.tar\");\n+        final FileInputStream written = new FileInputStream(output);\n+        try {\n+            FileInputStream orig = new FileInputStream(original);\n+            try {\n+                assertTrue(Arrays.equals(IOUtils.toByteArray(written),\n+                                         IOUtils.toByteArray(orig)));\n+            } finally {\n+                orig.close();\n+            }\n+        } finally {\n+            written.close();\n+        }\n+    }\n+}", "timestamp": 1384033012, "metainfo": ""}