{"sha": "463d6ebdebb2ea194254f1c3fab0a0f63ee212ce", "log": "rename ZipEntry to ZipArchiveEntry  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n import java.security.cert.Certificate;\n import java.util.jar.Attributes;\n import java.util.jar.JarEntry;\n+import java.util.zip.ZipEntry;\n import java.util.zip.ZipException;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n \n-public class JarArchiveEntry extends ZipEntry implements ArchiveEntry {\n+public class JarArchiveEntry extends ZipArchiveEntry implements ArchiveEntry {\n \n \tprivate Attributes manifestAttributes = null;\n \tprivate Certificate[] certificates = null; \n \t\n-\tpublic JarArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n+\tpublic JarArchiveEntry(ZipEntry entry) throws ZipException {\n \t\tsuper(entry);\n \t}\n \n \t\tsuper(name);\n \t}\n \n-\tpublic JarArchiveEntry(ZipEntry entry) throws ZipException {\n+\tpublic JarArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n \t\tsuper(entry);\n \t}\n \n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n import java.io.InputStream;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n \n public class JarArchiveInputStream extends ZipArchiveInputStream {\n     }\n         \n     public ArchiveEntry getNextEntry() throws IOException {\n-        ZipEntry entry = (ZipEntry)super.getNextEntry();\n+        ZipArchiveEntry entry = (ZipArchiveEntry)super.getNextEntry();\n         if(entry == null) {\n             return null;\n         } else {\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n import java.io.OutputStream;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n \n public class JarArchiveOutputStream extends ZipArchiveOutputStream {\n \n \tpublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n \t\t// TODO special jar stuff\n-\t\tsuper.putArchiveEntry((ZipEntry) entry);\n+\t\tsuper.putArchiveEntry((ZipArchiveEntry) entry);\n \t}\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.LinkedHashMap;\n+import java.util.zip.ZipException;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+\n+/**\n+ * Extension that adds better handling of extra fields and provides\n+ * access to the internal and external file attributes.\n+ *\n+ */\n+public class ZipArchiveEntry extends java.util.zip.ZipEntry\n+    implements ArchiveEntry, Cloneable {\n+\n+    public static final int PLATFORM_UNIX = 3;\n+    public static final int PLATFORM_FAT  = 0;\n+    private static final int SHORT_MASK = 0xFFFF;\n+    private static final int SHORT_SHIFT = 16;\n+\n+    private int internalAttributes = 0;\n+    private int platform = PLATFORM_FAT;\n+    private long externalAttributes = 0;\n+    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n+    private String name = null;\n+\n+    /**\n+     * Creates a new zip entry with the specified name.\n+     * @param name the name of the entry\n+     * @since 1.1\n+     */\n+    public ZipArchiveEntry(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     * @param entry the entry to get fields from\n+     * @since 1.1\n+     * @throws ZipException on error\n+     */\n+    public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n+        super(entry);\n+        byte[] extra = entry.getExtra();\n+        if (extra != null) {\n+            setExtraFields(ExtraFieldUtils.parse(extra));\n+        } else {\n+            // initializes extra data to an empty byte array\n+            setExtra();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     * @param entry the entry to get fields from\n+     * @throws ZipException on error\n+     * @since 1.1\n+     */\n+    public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n+        this((java.util.zip.ZipEntry) entry);\n+        setInternalAttributes(entry.getInternalAttributes());\n+        setExternalAttributes(entry.getExternalAttributes());\n+        setExtraFields(entry.getExtraFields());\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected ZipArchiveEntry() {\n+        super(\"\");\n+    }\n+\n+    /**\n+     * Overwrite clone.\n+     * @return a cloned copy of this ZipArchiveEntry\n+     * @since 1.1\n+     */\n+    public Object clone() {\n+        ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n+\n+        e.extraFields = extraFields != null ? (LinkedHashMap) extraFields.clone() : null;\n+        e.setInternalAttributes(getInternalAttributes());\n+        e.setExternalAttributes(getExternalAttributes());\n+        e.setExtraFields(getExtraFields());\n+        return e;\n+    }\n+\n+    /**\n+     * Retrieves the internal file attributes.\n+     *\n+     * @return the internal file attributes\n+     * @since 1.1\n+     */\n+    public int getInternalAttributes() {\n+        return internalAttributes;\n+    }\n+\n+    /**\n+     * Sets the internal file attributes.\n+     * @param value an <code>int</code> value\n+     * @since 1.1\n+     */\n+    public void setInternalAttributes(int value) {\n+        internalAttributes = value;\n+    }\n+\n+    /**\n+     * Retrieves the external file attributes.\n+     * @return the external file attributes\n+     * @since 1.1\n+     */\n+    public long getExternalAttributes() {\n+        return externalAttributes;\n+    }\n+\n+    /**\n+     * Sets the external file attributes.\n+     * @param value an <code>long</code> value\n+     * @since 1.1\n+     */\n+    public void setExternalAttributes(long value) {\n+        externalAttributes = value;\n+    }\n+\n+    /**\n+     * Sets Unix permissions in a way that is understood by Info-Zip's\n+     * unzip command.\n+     * @param mode an <code>int</code> value\n+     * @since Ant 1.5.2\n+     */\n+    public void setUnixMode(int mode) {\n+        // CheckStyle:MagicNumberCheck OFF - no point\n+        setExternalAttributes((mode << SHORT_SHIFT)\n+                              // MS-DOS read-only attribute\n+                              | ((mode & 0200) == 0 ? 1 : 0)\n+                              // MS-DOS directory flag\n+                              | (isDirectory() ? 0x10 : 0));\n+        // CheckStyle:MagicNumberCheck ON\n+        platform = PLATFORM_UNIX;\n+    }\n+\n+    /**\n+     * Unix permission.\n+     * @return the unix permissions\n+     * @since Ant 1.6\n+     */\n+    public int getUnixMode() {\n+        return platform != PLATFORM_UNIX ? 0 :\n+            (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n+    }\n+\n+    /**\n+     * Platform specification to put into the &quot;version made\n+     * by&quot; part of the central file header.\n+     *\n+     * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}\n+     * has been called, in which case PLATORM_UNIX will be returned.\n+     *\n+     * @since Ant 1.5.2\n+     */\n+    public int getPlatform() {\n+        return platform;\n+    }\n+\n+    /**\n+     * Set the platform (UNIX or FAT).\n+     * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX\n+     * @since 1.9\n+     */\n+    protected void setPlatform(int platform) {\n+        this.platform = platform;\n+    }\n+\n+    /**\n+     * Replaces all currently attached extra fields with the new array.\n+     * @param fields an array of extra fields\n+     * @since 1.1\n+     */\n+    public void setExtraFields(ZipExtraField[] fields) {\n+        extraFields = new LinkedHashMap();\n+        for (int i = 0; i < fields.length; i++) {\n+            extraFields.put(fields[i].getHeaderId(), fields[i]);\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Retrieves extra fields.\n+     * @return an array of the extra fields\n+     * @since 1.1\n+     */\n+    public ZipExtraField[] getExtraFields() {\n+        if (extraFields == null) {\n+            return new ZipExtraField[0];\n+        }\n+        ZipExtraField[] result = new ZipExtraField[extraFields.size()];\n+        return (ZipExtraField[]) extraFields.values().toArray(result);\n+    }\n+\n+    /**\n+     * Adds an extra fields - replacing an already present extra field\n+     * of the same type.\n+     * @param ze an extra field\n+     * @since 1.1\n+     */\n+    public void addExtraField(ZipExtraField ze) {\n+        if (extraFields == null) {\n+            extraFields = new LinkedHashMap();\n+        }\n+        extraFields.put(ze.getHeaderId(), ze);\n+        setExtra();\n+    }\n+\n+    /**\n+     * Remove an extra fields.\n+     * @param type the type of extra field to remove\n+     * @since 1.1\n+     */\n+    public void removeExtraField(ZipShort type) {\n+        if (extraFields == null) {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        if (extraFields.remove(type) == null) {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Throws an Exception if extra data cannot be parsed into extra fields.\n+     * @param extra an array of bytes to be parsed into extra fields\n+     * @throws RuntimeException if the bytes cannot be parsed\n+     * @since 1.1\n+     * @throws RuntimeException on error\n+     */\n+    public void setExtra(byte[] extra) throws RuntimeException {\n+        try {\n+            setExtraFields(ExtraFieldUtils.parse(extra));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Unfortunately {@link java.util.zip.ZipOutputStream\n+     * java.util.zip.ZipOutputStream} seems to access the extra data\n+     * directly, so overriding getExtra doesn't help - we need to\n+     * modify super's data directly.\n+     *\n+     * @since 1.1\n+     */\n+    protected void setExtra() {\n+        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the local file data.\n+     * @return the extra data for local file\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataExtra() {\n+        byte[] extra = getExtra();\n+        return extra != null ? extra : new byte[0];\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the central directory.\n+     * @return the central directory extra data\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryExtra() {\n+        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n+    }\n+\n+    /**\n+     * Make this class work in JDK 1.1 like a 1.2 class.\n+     *\n+     * <p>This either stores the size for later usage or invokes\n+     * setCompressedSize via reflection.</p>\n+     * @param size the size to use\n+     * @deprecated since 1.7.\n+     *             Use setCompressedSize directly.\n+     * @since 1.2\n+     */\n+    public void setComprSize(long size) {\n+        setCompressedSize(size);\n+    }\n+\n+    /**\n+     * Get the name of the entry.\n+     * @return the entry name\n+     * @since 1.9\n+     */\n+    public String getName() {\n+        return name == null ? super.getName() : name;\n+    }\n+\n+    /**\n+     * Is this entry a directory?\n+     * @return true if the entry is a directory\n+     * @since 1.10\n+     */\n+    public boolean isDirectory() {\n+        return getName().endsWith(\"/\");\n+    }\n+\n+    /**\n+     * Set the name of the entry.\n+     * @param name the name to use\n+     */\n+    protected void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Get the hashCode of the entry.\n+     * This uses the name as the hashcode.\n+     * @return a hashcode.\n+     * @since Ant 1.7\n+     */\n+    public int hashCode() {\n+        // this method has severe consequences on performance. We cannot rely\n+        // on the super.hashCode() method since super.getName() always return\n+        // the empty string in the current implemention (there's no setter)\n+        // so it is basically draining the performance of a hashmap lookup\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * The equality method. In this case, the implementation returns 'this == o'\n+     * which is basically the equals method of the Object class.\n+     * @param o the object to compare to\n+     * @return true if this object is the same as <code>o</code>\n+     * @since Ant 1.7\n+     */\n+    public boolean equals(Object o) {\n+        return (this == o);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         if(entry == null) {\n             return null;\n         }\n-        return (ArchiveEntry)new ZipEntry(entry);\n+        return (ArchiveEntry)new ZipArchiveEntry(entry);\n     }\n \n     public int read(byte[] b, int off, int len) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     }\n     \n     public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        zipOut.putNextEntry((ZipEntry) entry);\n+        zipOut.putNextEntry((ZipArchiveEntry) entry);\n     }\n \n     public void close() throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  * (which is required to work on ZIP files created by native zip tools\n  * and is able to skip a preamble like the one found in self\n  * extracting archives.  Furthermore it returns instances of\n- * <code>org.apache.tools.zip.ZipEntry</code> instead of\n+ * <code>org.apache.tools.zip.ZipArchiveEntry</code> instead of\n  * <code>java.util.zip.ZipEntry</code>.</p>\n  *\n  * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n  *   <li>There is no getName method.</li>\n  *   <li>entries has been renamed to getEntries.</li>\n  *   <li>getEntries and getEntry return\n- *   <code>org.apache.tools.zip.ZipEntry</code> instances.</li>\n+ *   <code>org.apache.tools.zip.ZipArchiveEntry</code> instances.</li>\n  *   <li>close is allowed to throw IOException.</li>\n  * </ul>\n  *\n     private static final int POS_3 = 3;\n \n     /**\n-     * Maps ZipEntrys to Longs, recording the offsets of the local\n+     * Maps ZipArchiveEntrys to Longs, recording the offsets of the local\n      * file headers.\n      */\n     private final Map entries = new HashMap(HASH_SIZE);\n \n     /**\n-     * Maps String to ZipEntrys, name -> actual entry.\n+     * Maps String to ZipArchiveEntrys, name -> actual entry.\n      */\n     private final Map nameMap = new HashMap(HASH_SIZE);\n \n \n     /**\n      * Returns all entries.\n-     * @return all entries as {@link ZipEntry} instances\n+     * @return all entries as {@link ZipArchiveEntry} instances\n      */\n     public Enumeration getEntries() {\n         return Collections.enumeration(entries.keySet());\n      * Returns a named entry - or <code>null</code> if no entry by\n      * that name exists.\n      * @param name name of the entry.\n-     * @return the ZipEntry corresponding to the given name - or\n+     * @return the ZipArchiveEntry corresponding to the given name - or\n      * <code>null</code> if not present.\n      */\n-    public ZipEntry getEntry(String name) {\n-        return (ZipEntry) nameMap.get(name);\n+    public ZipArchiveEntry getEntry(String name) {\n+        return (ZipArchiveEntry) nameMap.get(name);\n     }\n \n     /**\n      * @throws IOException if unable to create an input stream from the zipenty\n      * @throws ZipException if the zipentry has an unsupported compression method\n      */\n-    public InputStream getInputStream(ZipEntry ze)\n+    public InputStream getInputStream(ZipArchiveEntry ze)\n         throws IOException, ZipException {\n         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n         if (offsetEntry == null) {\n         BoundedInputStream bis =\n             new BoundedInputStream(start, ze.getCompressedSize());\n         switch (ze.getMethod()) {\n-            case ZipEntry.STORED:\n+            case ZipArchiveEntry.STORED:\n                 return bis;\n-            case ZipEntry.DEFLATED:\n+            case ZipArchiveEntry.DEFLATED:\n                 bis.addDummy();\n                 return new InflaterInputStream(bis, new Inflater(true));\n             default:\n \n     /**\n      * Reads the central directory of the given archive and populates\n-     * the internal tables with ZipEntry instances.\n-     *\n-     * <p>The ZipEntrys will know all data that can be obtained from\n+     * the internal tables with ZipArchiveEntry instances.\n+     *\n+     * <p>The ZipArchiveEntrys will know all data that can be obtained from\n      * the central directory alone, but not the data that requires the\n      * local file header or additional data to be read.</p>\n      */\n         while (sig == cfhSig) {\n             archive.readFully(cfh);\n             int off = 0;\n-            ZipEntry ze = new ZipEntry();\n+            ZipArchiveEntry ze = new ZipArchiveEntry();\n \n             int versionMadeBy = ZipShort.getValue(cfh, off);\n             off += SHORT;\n         throws IOException {\n         Enumeration e = getEntries();\n         while (e.hasMoreElements()) {\n-            ZipEntry ze = (ZipEntry) e.nextElement();\n+            ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement();\n             OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n             long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n      *\n      * @since 1.1\n      */\n-    private ZipEntry entry;\n+    private ZipArchiveEntry entry;\n \n     /**\n      * The file comment.\n         closeEntry();\n         cdOffset = written;\n         for (Iterator i = entries.iterator(); i.hasNext(); ) {\n-            writeCentralFileHeader((ZipEntry) i.next());\n+            writeCentralFileHeader((ZipArchiveEntry) i.next());\n         }\n         cdLength = written - cdOffset;\n         writeCentralDirectoryEnd();\n      * @since 1.1\n      * @throws IOException on error\n      */\n-    public void putNextEntry(ZipEntry ze) throws IOException {\n+    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n         closeEntry();\n \n         entry = ze;\n      *\n      * @since 1.1\n      */\n-    protected void writeLocalFileHeader(ZipEntry ze) throws IOException {\n+    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n         offsets.put(ze, ZipLong.getBytes(written));\n \n         writeOut(LFH_SIG);\n      *\n      * @since 1.1\n      */\n-    protected void writeDataDescriptor(ZipEntry ze) throws IOException {\n+    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n         if (ze.getMethod() != DEFLATED || raf != null) {\n             return;\n         }\n      *\n      * @since 1.1\n      */\n-    protected void writeCentralFileHeader(ZipEntry ze) throws IOException {\n+    protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n         writeOut(CFH_SIG);\n         written += WORD;\n \n--- a/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n import java.io.InputStream;\n import java.io.OutputStream;\n \n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.utils.IOUtils;\n \n import org.apache.commons.compress.AbstractTestCase;\n         \n         final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"jar\", out);\n \n-        os.putArchiveEntry(new ZipEntry(\"testdata/test1.xml\"));\n+        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n         IOUtils.copy(new FileInputStream(file1), os);\n         os.closeArchiveEntry();\n         \n-        os.putArchiveEntry(new ZipEntry(\"testdata/test2.xml\"));\n+        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n         IOUtils.copy(new FileInputStream(file2), os);\n         os.closeArchiveEntry();\n \n         final InputStream is = new FileInputStream(input);\n         final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"jar\", is);\n         \n-        ZipEntry entry = (ZipEntry)in.getNextEntry();\n+        ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n         File o = new File(dir, entry.getName());\n         o.getParentFile().mkdirs();\n         OutputStream out = new FileOutputStream(o);\n         IOUtils.copy(in, out);\n         out.close();\n         \n-        entry = (ZipEntry)in.getNextEntry();\n+        entry = (ZipArchiveEntry)in.getNextEntry();\n         o = new File(dir, entry.getName());\n         o.getParentFile().mkdirs();\n         out = new FileOutputStream(o);\n         IOUtils.copy(in, out);\n         out.close();\n         \n-        entry = (ZipEntry)in.getNextEntry();\n+        entry = (ZipArchiveEntry)in.getNextEntry();\n         o = new File(dir, entry.getName());\n         o.getParentFile().mkdirs();\n         out = new FileOutputStream(o);\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n import java.io.InputStream;\n import java.io.OutputStream;\n \n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.utils.IOUtils;\n \n import org.apache.commons.compress.AbstractTestCase;\n         \n         final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"zip\", out);\n \n-        os.putArchiveEntry(new ZipEntry(\"testdata/test1.xml\"));\n+        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n         IOUtils.copy(new FileInputStream(file1), os);\n         os.closeArchiveEntry();\n         \n-        os.putArchiveEntry(new ZipEntry(\"testdata/test2.xml\"));\n+        os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n         IOUtils.copy(new FileInputStream(file2), os);\n         os.closeArchiveEntry();\n         \n         final InputStream is = new FileInputStream(input);\n         final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n  \n-        final ZipEntry entry = (ZipEntry)in.getNextEntry();\n+        final ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n         final OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n         \n         IOUtils.copy(in, out);\n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n import org.apache.commons.compress.archivers.ar.ArArchiveEntry;\n import org.apache.commons.compress.archivers.jar.JarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n \n public final class ChangeSetTestCase extends AbstractTestCase {\n \n \t\t\t\n \t\t\t\n \t\t\tfinal File file1 = getFile(\"test.txt\");\n-\t\t\tZipEntry entry = new ZipEntry(\"testdata/test.txt\");\n+\t\t\tZipArchiveEntry entry = new ZipArchiveEntry(\"testdata/test.txt\");\n \t        changes.add(entry, new FileInputStream(file1));\n \t\t\t\n \t\t\tfinal File input = getFile(\"bla.zip\");", "timestamp": 1233940300, "metainfo": ""}