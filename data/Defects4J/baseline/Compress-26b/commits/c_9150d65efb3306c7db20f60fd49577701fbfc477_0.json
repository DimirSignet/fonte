{"sha": "9150d65efb3306c7db20f60fd49577701fbfc477", "log": "reduce code duplication in the two LZW input streams  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.compressors.z.AbstractLZWInputStream;\n \n /**\n  * Input stream that decompresses ZIP method 1 (unshrinking). A variation of the LZW algorithm, with some twists.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-class UnshrinkingInputStream extends CompressorInputStream {\n-    private final InputStream in;\n-    private final int clearCode;\n-    private final int MAX_CODE_SIZE = 13;\n-    private int codeSize = 9;\n-    private int bitsCached = 0;\n-    private int bitsCachedSize = 0;\n-    private int previousCode = -1;\n-    private int tableSize = 0;\n-    private final int[] prefixes;\n-    private final byte[] characters;\n+class UnshrinkingInputStream extends AbstractLZWInputStream {\n+    private static final int MAX_CODE_SIZE = 13;\n+    private static final int MAX_TABLE_SIZE = 1 << MAX_CODE_SIZE;\n     private final boolean[] isUsed;\n-    private final byte[] outputStack;\n-    private int outputStackLocation;\n     \n     public UnshrinkingInputStream(InputStream inputStream) throws IOException {\n-        this.in = inputStream;\n-        clearCode = (1 << (codeSize - 1));\n-        final int maxTableSize = 1 << MAX_CODE_SIZE;\n-        prefixes = new int[maxTableSize];\n-        characters = new byte[maxTableSize];\n-        isUsed = new boolean[maxTableSize];\n-        outputStack = new byte[maxTableSize];\n-        outputStackLocation = maxTableSize;\n+        super(inputStream);\n+        setClearCode(codeSize);\n+        initializeTables(MAX_CODE_SIZE);\n+        isUsed = new boolean[prefixes.length];\n         for (int i = 0; i < (1 << 8); i++) {\n-            prefixes[i] = -1;\n-            characters[i] = (byte)i;\n             isUsed[i] = true;\n         }\n         tableSize = clearCode + 1;\n     }\n-    \n-    public void close() throws IOException {\n-        in.close();\n-    }\n-    \n-    private int readNextCode() throws IOException {\n-        while (bitsCachedSize < codeSize) {\n-            final int nextByte = in.read();\n-            if (nextByte < 0) {\n-                return nextByte;\n-            }\n-            bitsCached |= (nextByte << bitsCachedSize);\n-            bitsCachedSize += 8;\n-        }\n-        final int mask = (1 << codeSize) - 1;\n-        final int code = (bitsCached & mask);\n-        bitsCached >>>= codeSize;\n-        bitsCachedSize -= codeSize;\n-        return code;\n-    }\n-    \n-    private int addEntry(int previousCode, byte character) throws IOException {\n-        final int maxTableSize = 1 << MAX_CODE_SIZE;\n-        while ((tableSize < maxTableSize) && isUsed[tableSize]) {\n+\n+    @Override\n+    protected int addEntry(int previousCode, byte character) throws IOException {\n+        while ((tableSize < MAX_TABLE_SIZE) && isUsed[tableSize]) {\n             tableSize++;\n         }\n-        if (tableSize < maxTableSize) {\n-            final int index = tableSize;\n-            prefixes[tableSize] = previousCode;\n-            characters[tableSize] = character;\n-            isUsed[tableSize] = true;\n-            tableSize++;\n-            return index;\n-        } else {\n-            return -1;\n+        int idx = addEntry(previousCode, character, MAX_TABLE_SIZE);\n+        if (idx >= 0) {\n+            isUsed[idx] = true;\n         }\n+        return idx;\n     }\n     \n     private void partialClear() throws IOException {\n-        final boolean[] isParent = new boolean[1 << MAX_CODE_SIZE];\n+        final boolean[] isParent = new boolean[MAX_TABLE_SIZE];\n         for (int i = 0; i < isUsed.length; i++) {\n             if (isUsed[i] && prefixes[i] != -1) {\n                 isParent[prefixes[i]] = true;\n         }\n     }\n \n-    private int decompressNextSymbol() throws IOException {\n+    @Override\n+    protected int decompressNextSymbol() throws IOException {\n         //\n         //                   table entry    table entry\n         //                  _____________   _____\n             return 0;\n         } else {\n             boolean addedUnfinishedEntry = false;\n-            final int effectiveCode;\n-            if (isUsed[code]) {\n-                effectiveCode = code;\n-            } else {\n-                // must be a repeat of the previous entry we haven't added yet\n-                if (previousCode == -1) {\n-                    // ... which isn't possible for the very first code\n-                    throw new IOException(\"The first code can't be a reference to its preceding code\");\n-                }\n-                byte firstCharacter = 0;\n-                for (int last = previousCode; last >= 0; last = prefixes[last]) {\n-                    firstCharacter = characters[last];\n-                }\n-                effectiveCode = addEntry(previousCode, firstCharacter);\n+            int effectiveCode = code;\n+            if (!isUsed[code]) {\n+                effectiveCode = addRepeatOfPreviousCode();\n                 addedUnfinishedEntry = true;\n             }\n-            for (int entry = effectiveCode; entry >= 0; entry = prefixes[entry]) {\n-                outputStack[--outputStackLocation] = characters[entry];\n-            }\n-            if (previousCode != -1 && !addedUnfinishedEntry) {\n-                addEntry(previousCode, outputStack[outputStackLocation]);\n-            }\n-            previousCode = code;\n-            return outputStackLocation;\n+            return expandCodeToOutputStack(effectiveCode, addedUnfinishedEntry);\n         }\n     }\n-    \n-    public int read() throws IOException {\n-        byte[] b = new byte[1];\n-        int ret;\n-        while ((ret = read(b)) == 0) {\n-        }\n-        if (ret < 0) {\n-            return ret;\n-        }\n-        return 0xff & b[0];\n-    }\n-    \n-    public int read(byte[] b, int off, int len) throws IOException {\n-        int bytesRead = 0;\n-        int remainingInStack = outputStack.length - outputStackLocation;\n-        if (remainingInStack > 0) {\n-            int maxLength = Math.min(remainingInStack, len);\n-            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n-            outputStackLocation += maxLength;\n-            off += maxLength;\n-            len -= maxLength;\n-            bytesRead += maxLength;\n-        }\n-        while (len > 0) {\n-            int result = decompressNextSymbol();\n-            if (result < 0) {\n-                if (bytesRead > 0) {\n-                    count(bytesRead);\n-                    return bytesRead;\n-                } else {\n-                    return result;\n-                }\n-            }\n-            remainingInStack = outputStack.length - outputStackLocation;\n-            if (remainingInStack > 0) {\n-                int maxLength = Math.min(remainingInStack, len);\n-                System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n-                outputStackLocation += maxLength;\n-                off += maxLength;\n-                len -= maxLength;\n-                bytesRead += maxLength;\n-            }\n-        }\n-        count(bytesRead);\n-        return bytesRead;\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/AbstractLZWInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.z;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * Base-class for traditional Unix \".Z\" compression and the\n+ * Unshrinking method of ZIP archive.\n+ * @NotThreadSafe\n+ * @since 1.7\n+ */\n+public abstract class AbstractLZWInputStream extends CompressorInputStream {\n+    private final byte[] oneByte = new byte[1];\n+\n+    protected final InputStream in;\n+    protected int clearCode = -1;\n+    protected int codeSize = 9;\n+    protected int bitsCached = 0;\n+    protected int bitsCachedSize = 0;\n+    protected int previousCode = -1;\n+    protected int tableSize = 0;\n+    protected int[] prefixes;\n+    protected byte[] characters;\n+    private byte[] outputStack;\n+    private int outputStackLocation;\n+\n+    public AbstractLZWInputStream(InputStream inputStream) throws IOException {\n+        this.in = inputStream;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        int ret;\n+        while ((ret = read(oneByte)) == 0) { // NOPMD\n+        }\n+        if (ret < 0) {\n+            return ret;\n+        }\n+        return 0xff & oneByte[0];\n+    }\n+    \n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int bytesRead = 0;\n+        int remainingInStack = outputStack.length - outputStackLocation;\n+        if (remainingInStack > 0) {\n+            int maxLength = Math.min(remainingInStack, len);\n+            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+            outputStackLocation += maxLength;\n+            off += maxLength;\n+            len -= maxLength;\n+            bytesRead += maxLength;\n+        }\n+        while (len > 0) {\n+            int result = decompressNextSymbol();\n+            if (result < 0) {\n+                if (bytesRead > 0) {\n+                    count(bytesRead);\n+                    return bytesRead;\n+                } else {\n+                    return result;\n+                }\n+            }\n+            remainingInStack = outputStack.length - outputStackLocation;\n+            if (remainingInStack > 0) {\n+                int maxLength = Math.min(remainingInStack, len);\n+                System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+                outputStackLocation += maxLength;\n+                off += maxLength;\n+                len -= maxLength;\n+                bytesRead += maxLength;\n+            }\n+        }\n+        count(bytesRead);\n+        return bytesRead;\n+    }\n+\n+    /**\n+     * Read the next code and expand it.\n+     */\n+    protected abstract int decompressNextSymbol() throws IOException;\n+\n+    /**\n+     * Add a new entry to the dictionary.\n+     */\n+    protected abstract int addEntry(int previousCode, byte character)\n+        throws IOException;\n+\n+    /**\n+     * Sets the clear code based on the code size.\n+     */\n+    protected void setClearCode(int codeSize) {\n+        clearCode = (1 << (codeSize - 1));\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n+     */\n+    protected void initializeTables(int maxCodeSize) {\n+        final int maxTableSize = 1 << maxCodeSize;\n+        prefixes = new int[maxTableSize];\n+        characters = new byte[maxTableSize];\n+        outputStack = new byte[maxTableSize];\n+        outputStackLocation = maxTableSize;\n+        final int max = 1 << 8;\n+        for (int i = 0; i < max; i++) {\n+            prefixes[i] = -1;\n+            characters[i] = (byte) i;\n+        }\n+    }\n+\n+    /**\n+     * Reads the next code from the stream.\n+     */\n+    protected int readNextCode() throws IOException {\n+        while (bitsCachedSize < codeSize) {\n+            final int nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            bitsCached |= (nextByte << bitsCachedSize);\n+            bitsCachedSize += 8;\n+        }\n+        final int mask = (1 << codeSize) - 1;\n+        final int code = (bitsCached & mask);\n+        bitsCached >>>= codeSize;\n+        bitsCachedSize -= codeSize;\n+        return code;\n+    }\n+    \n+    /**\n+     * Adds a new entry if the maximum table size hasn't been exceeded\n+     * and returns the new index.\n+     */\n+    protected int addEntry(int previousCode, byte character, int maxTableSize) {\n+        if (tableSize < maxTableSize) {\n+            final int index = tableSize;\n+            prefixes[tableSize] = previousCode;\n+            characters[tableSize] = character;\n+            tableSize++;\n+            return index;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Add entry for repeat of previousCode we haven't added, yet.\n+     */\n+    protected int addRepeatOfPreviousCode() throws IOException {\n+        if (previousCode == -1) {\n+            // can't have a repeat for the very first code\n+            throw new IOException(\"The first code can't be a reference to its preceding code\");\n+        }\n+        byte firstCharacter = 0;\n+        for (int last = previousCode; last >= 0; last = prefixes[last]) {\n+            firstCharacter = characters[last];\n+        }\n+        return addEntry(previousCode, firstCharacter);\n+    }\n+\n+    /**\n+     * Expands the entry with index code to the output stack and may\n+     * create a new entry\n+     */\n+    protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry)\n+        throws IOException {\n+        for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n+            outputStack[--outputStackLocation] = characters[entry];\n+        }\n+        if (previousCode != -1 && !addedUnfinishedEntry) {\n+            addEntry(previousCode, outputStack[outputStackLocation]);\n+        }\n+        previousCode = code;\n+        return outputStackLocation;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.compressors.CompressorInputStream;\n-\n /**\n  * Input stream that decompresses .Z files.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-public class ZCompressorInputStream extends CompressorInputStream {\n+public class ZCompressorInputStream extends AbstractLZWInputStream {\n     private static final int MAGIC_1 = 0x1f;\n     private static final int MAGIC_2 = 0x9d;\n     private static final int BLOCK_MODE_MASK = 0x80;\n     private static final int MAX_CODE_SIZE_MASK = 0x1f;\n-    private final InputStream in;\n     private final boolean blockMode;\n-    private final int clearCode;\n     private final int maxCodeSize;\n-    private int codeSize = 9;\n-    private int bitsCached = 0;\n-    private int bitsCachedSize = 0;\n     private long totalCodesRead = 0;\n-    private int previousCode = -1;\n-    private int tableSize = 0;\n-    private final int[] prefixes;\n-    private final byte[] characters;\n-    private final byte[] outputStack;\n-    private int outputStackLocation;\n     \n     public ZCompressorInputStream(InputStream inputStream) throws IOException {\n-        this.in = inputStream;\n+        super(inputStream);\n         int firstByte = in.read();\n         int secondByte = in.read();\n         int thirdByte = in.read();\n         blockMode = ((thirdByte & BLOCK_MODE_MASK) != 0);\n         maxCodeSize = thirdByte & MAX_CODE_SIZE_MASK;\n         if (blockMode) {\n-            clearCode = (1 << (codeSize - 1));\n-        } else {\n-            clearCode = -1; // unused\n+            setClearCode(codeSize);\n         }\n-        final int maxTableSize = 1 << maxCodeSize;\n-        prefixes = new int[maxTableSize];\n-        characters = new byte[maxTableSize];\n-        outputStack = new byte[maxTableSize];\n-        outputStackLocation = maxTableSize;\n-        for (int i = 0; i < (1 << 8); i++) {\n-            prefixes[i] = -1;\n-            characters[i] = (byte)i;\n-        }\n+        initializeTables(maxCodeSize);\n         clearEntries();\n-    }\n-    \n-    public void close() throws IOException {\n-        in.close();\n     }\n     \n     private void clearEntries() {\n         }\n     }\n \n-    private int readNextCode() throws IOException {\n-        while (bitsCachedSize < codeSize) {\n-            final int nextByte = in.read();\n-            if (nextByte < 0) {\n-                return nextByte;\n-            }\n-            bitsCached |= (nextByte << bitsCachedSize);\n-            bitsCachedSize += 8;\n+    @Override\n+    protected int readNextCode() throws IOException {\n+        int code = super.readNextCode();\n+        if (code >= 0) {\n+            ++totalCodesRead;\n         }\n-        final int mask = (1 << codeSize) - 1;\n-        final int code = (bitsCached & mask);\n-        bitsCached >>>= codeSize;\n-        bitsCachedSize -= codeSize;\n-        ++totalCodesRead;\n         return code;\n     }\n     \n         bitsCachedSize = 0;\n     }\n     \n-    private void addEntry(int previousCode, byte character) throws IOException {\n+    @Override\n+    protected int addEntry(int previousCode, byte character) throws IOException {\n         final int maxTableSize = 1 << codeSize;\n-        if (tableSize < maxTableSize) {\n-            prefixes[tableSize] = previousCode;\n-            characters[tableSize] = character;\n-            tableSize++;\n+        int r = addEntry(previousCode, character, maxTableSize);\n+        if (tableSize == maxTableSize && codeSize < maxCodeSize) {\n+            reAlignReading();\n+            codeSize++;\n         }\n-        if (tableSize == maxTableSize) {\n-            if (codeSize < maxCodeSize) {\n-                reAlignReading();\n-                codeSize++;\n-            }\n-        }\n+        return r;\n     }\n \n-    private int decompressNextSymbol() throws IOException {\n+    @Override\n+    protected int decompressNextSymbol() throws IOException {\n         //\n         //                   table entry    table entry\n         //                  _____________   _____\n         } else {\n             boolean addedUnfinishedEntry = false;\n             if (code == tableSize) {\n-                // must be a repeat of the previous entry we haven't added yet\n-                if (previousCode == -1) {\n-                    // ... which isn't possible for the very first code\n-                    throw new IOException(\"The first code can't be a reference to its preceding code\");\n-                }\n-                byte firstCharacter = 0;\n-                for (int last = previousCode; last >= 0; last = prefixes[last]) {\n-                    firstCharacter = characters[last];\n-                }\n-                addEntry(previousCode, firstCharacter);\n+                addRepeatOfPreviousCode();\n                 addedUnfinishedEntry = true;\n             } else if (code > tableSize) {\n                 throw new IOException(String.format(\"Invalid %d bit code 0x%x\", codeSize, code));\n             }\n-            for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n-                outputStack[--outputStackLocation] = characters[entry];\n-            }\n-            if (previousCode != -1 && !addedUnfinishedEntry) {\n-                addEntry(previousCode, outputStack[outputStackLocation]);\n-            }\n-            previousCode = code;\n-            return outputStackLocation;\n+            return expandCodeToOutputStack(code, addedUnfinishedEntry);\n         }\n     }\n     \n-    public int read() throws IOException {\n-        byte[] b = new byte[1];\n-        int ret;\n-        while ((ret = read(b)) == 0) {\n-        }\n-        if (ret < 0) {\n-            return ret;\n-        }\n-        return 0xff & b[0];\n-    }\n-    \n-    public int read(byte[] b, int off, int len) throws IOException {\n-        int bytesRead = 0;\n-        int remainingInStack = outputStack.length - outputStackLocation;\n-        if (remainingInStack > 0) {\n-            int maxLength = Math.min(remainingInStack, len);\n-            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n-            outputStackLocation += maxLength;\n-            off += maxLength;\n-            len -= maxLength;\n-            bytesRead += maxLength;\n-        }\n-        while (len > 0) {\n-            int result = decompressNextSymbol();\n-            if (result < 0) {\n-                if (bytesRead > 0) {\n-                    count(bytesRead);\n-                    return bytesRead;\n-                } else {\n-                    return result;\n-                }\n-            }\n-            remainingInStack = outputStack.length - outputStackLocation;\n-            if (remainingInStack > 0) {\n-                int maxLength = Math.min(remainingInStack, len);\n-                System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n-                outputStackLocation += maxLength;\n-                off += maxLength;\n-                len -= maxLength;\n-                bytesRead += maxLength;\n-            }\n-        }\n-        count(bytesRead);\n-        return bytesRead;\n-    }\n }", "timestamp": 1387121015, "metainfo": ""}