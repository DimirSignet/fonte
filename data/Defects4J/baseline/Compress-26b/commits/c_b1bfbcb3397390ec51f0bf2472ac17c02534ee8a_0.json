{"sha": "b1bfbcb3397390ec51f0bf2472ac17c02534ee8a", "log": "Improve bzip2 creation speed, submitted by Rodrigo Schmidt to Ant, COMPRESS-58  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n \n /**\n  * An output stream that compresses into the BZip2 format (without the file\n- * header chars) into another stream. TODO: Update to BZip2 1.0.1\n+ * header chars) into another stream.\n+ *\n+ * <p>\n+ * The compression requires large amounts of memory. Thus you should call the\n+ * {@link #close() close()} method as soon as possible, to force\n+ * <tt>CBZip2OutputStream</tt> to release the allocated memory.\n+ * </p>\n+ *\n+ * <p> You can shrink the amount of allocated memory and maybe raise\n+ * the compression speed by choosing a lower blocksize, which in turn\n+ * may cause a lower compression ratio. You can avoid unnecessary\n+ * memory allocation by avoiding using a blocksize which is bigger\n+ * than the size of the input.  </p>\n+ *\n+ * <p> You can compute the memory usage for compressing by the\n+ * following formula: </p>\n+ *\n+ * <pre>\n+ * &lt;code&gt;400k + (9 * blocksize)&lt;/code&gt;.\n+ * </pre>\n+ *\n+ * <p> To get the memory required for decompression by {@link\n+ * CBZip2InputStream CBZip2InputStream} use </p>\n+ *\n+ * <pre>\n+ * &lt;code&gt;65k + (5 * blocksize)&lt;/code&gt;.\n+ * </pre>\n+ *\n+ * <table width=\"100%\" border=\"1\">\n+ * <colgroup> <col width=\"33%\" /> <col width=\"33%\" /> <col width=\"33%\" />\n+ * </colgroup>\n+ * <tr>\n+ * <th colspan=\"3\">Memory usage by blocksize</th>\n+ * </tr>\n+ * <tr>\n+ * <th align=\"right\">Blocksize</th> <th align=\"right\">Compression<br>\n+ * memory usage</th> <th align=\"right\">Decompression<br>\n+ * memory usage</th>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">100k</td>\n+ * <td align=\"right\">1300k</td>\n+ * <td align=\"right\">565k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">200k</td>\n+ * <td align=\"right\">2200k</td>\n+ * <td align=\"right\">1065k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">300k</td>\n+ * <td align=\"right\">3100k</td>\n+ * <td align=\"right\">1565k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">400k</td>\n+ * <td align=\"right\">4000k</td>\n+ * <td align=\"right\">2065k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">500k</td>\n+ * <td align=\"right\">4900k</td>\n+ * <td align=\"right\">2565k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">600k</td>\n+ * <td align=\"right\">5800k</td>\n+ * <td align=\"right\">3065k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">700k</td>\n+ * <td align=\"right\">6700k</td>\n+ * <td align=\"right\">3565k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">800k</td>\n+ * <td align=\"right\">7600k</td>\n+ * <td align=\"right\">4065k</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"right\">900k</td>\n+ * <td align=\"right\">8500k</td>\n+ * <td align=\"right\">4565k</td>\n+ * </tr>\n+ * </table>\n+ *\n+ * <p>\n+ * For decompression <tt>CBZip2InputStream</tt> allocates less memory if the\n+ * bzipped input is smaller than one block.\n+ * </p>\n+ *\n+ * <p>\n+ * Instances of this class are not threadsafe.\n+ * </p>\n+ *\n+ * <p>\n+ * TODO: Update to BZip2 1.0.1\n+ * </p>\n+ *\n  */\n-public class BZip2CompressorOutputStream extends CompressorOutputStream implements BZip2Constants {\n-    protected static final int SETMASK = (1 << 21);\n-    protected static final int CLEARMASK = (~SETMASK);\n-    protected static final int GREATER_ICOST = 15;\n-    protected static final int LESSER_ICOST = 0;\n-    protected static final int SMALL_THRESH = 20;\n-    protected static final int DEPTH_THRESH = 10;\n+public class BZip2CompressorOutputStream extends CompressorOutputStream\n+    implements BZip2Constants {\n+\n+    /**\n+     * The minimum supported blocksize <tt> == 1</tt>.\n+     */\n+    public static final int MIN_BLOCKSIZE = 1;\n+\n+    /**\n+     * The maximum supported blocksize <tt> == 9</tt>.\n+     */\n+    public static final int MAX_BLOCKSIZE = 9;\n+\n+    private static final int SETMASK = (1 << 21);\n+    private static final int CLEARMASK = (~SETMASK);\n+    private static final int GREATER_ICOST = 15;\n+    private static final int LESSER_ICOST = 0;\n+    private static final int SMALL_THRESH = 20;\n+    private static final int DEPTH_THRESH = 10;\n+    private static final int WORK_FACTOR = 30;\n \n     /*\n-      If you are ever unlucky/improbable enough\n-      to get a stack overflow whilst sorting,\n-      increase the following constant and try\n-      again.  In practice I have never seen the\n-      stack go above 27 elems, so the following\n-      limit seems very generous.\n-    */\n-    protected static final int QSORT_STACK_SIZE = 1000;\n-\n-    private static void panic() {\n-        System.out.println(\"panic\");\n-        //throw new CError();\n-    }\n-\n-    private void makeMaps() {\n-        int i;\n-        nInUse = 0;\n-        for (i = 0; i < 256; i++) {\n-            if (inUse[i]) {\n-                seqToUnseq[nInUse] = (char) i;\n-                unseqToSeq[i] = (char) nInUse;\n-                nInUse++;\n-            }\n-        }\n-    }\n-\n+     * <p> If you are ever unlucky/improbable enough to get a stack\n+     * overflow whilst sorting, increase the following constant and\n+     * try again. In practice I have never seen the stack go above 27\n+     * elems, so the following limit seems very generous.  </p>\n+     */\n+    private static final int QSORT_STACK_SIZE = 1000;\n+\n+    /**\n+     * Knuth's increments seem to work better than Incerpi-Sedgewick here.\n+     * Possibly because the number of elems to sort is usually small, typically\n+     * &lt;= 20.\n+     */\n+    private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n+                                        9841, 29524, 88573, 265720, 797161,\n+                                        2391484 };\n+\n+    /**\n+     * This method is accessible by subclasses for historical\n+     * purposes. If you don't know what it does then you don't need\n+     * it.\n+     */\n     protected static void hbMakeCodeLengths(char[] len, int[] freq,\n                                             int alphaSize, int maxLen) {\n         /*\n-          Nodes and heap entries run from 1.  Entry 0\n-          for both the heap and nodes is a sentinel.\n-        */\n-        int nNodes, nHeap, n1, n2, i, j, k;\n-        boolean  tooLong;\n-\n-        int[] heap = new int[MAX_ALPHA_SIZE + 2];\n-        int[] weight = new int[MAX_ALPHA_SIZE * 2];\n-        int[] parent = new int[MAX_ALPHA_SIZE * 2];\n-\n-        for (i = 0; i < alphaSize; i++) {\n+         * Nodes and heap entries run from 1. Entry 0 for both the heap and\n+         * nodes is a sentinel.\n+         */\n+        final int[] heap = new int[MAX_ALPHA_SIZE * 2];\n+        final int[] weight = new int[MAX_ALPHA_SIZE * 2];\n+        final int[] parent = new int[MAX_ALPHA_SIZE * 2];\n+\n+        for (int i = alphaSize; --i >= 0;) {\n             weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n         }\n \n-        while (true) {\n-            nNodes = alphaSize;\n-            nHeap = 0;\n-\n+        for (boolean tooLong = true; tooLong;) {\n+            tooLong = false;\n+\n+            int nNodes = alphaSize;\n+            int nHeap = 0;\n             heap[0] = 0;\n             weight[0] = 0;\n             parent[0] = -2;\n \n-            for (i = 1; i <= alphaSize; i++) {\n+            for (int i = 1; i <= alphaSize; i++) {\n                 parent[i] = -1;\n                 nHeap++;\n                 heap[nHeap] = i;\n-                {\n-                    int zz, tmp;\n-                    zz = nHeap;\n-                    tmp = heap[zz];\n-                    while (weight[tmp] < weight[heap[zz >> 1]]) {\n-                        heap[zz] = heap[zz >> 1];\n-                        zz >>= 1;\n-                    }\n-                    heap[zz] = tmp;\n-                }\n-            }\n-            if (!(nHeap < (MAX_ALPHA_SIZE + 2))) {\n-                panic();\n-            }\n+\n+                int zz = nHeap;\n+                int tmp = heap[zz];\n+                while (weight[tmp] < weight[heap[zz >> 1]]) {\n+                    heap[zz] = heap[zz >> 1];\n+                    zz >>= 1;\n+                }\n+                heap[zz] = tmp;\n+            }\n+\n+            // assert (nHeap < (MAX_ALPHA_SIZE + 2)) : nHeap;\n \n             while (nHeap > 1) {\n-                n1 = heap[1];\n+                int n1 = heap[1];\n                 heap[1] = heap[nHeap];\n                 nHeap--;\n-                {\n-                    int zz = 0, yy = 0, tmp = 0;\n-                    zz = 1;\n-                    tmp = heap[zz];\n-                    while (true) {\n-                        yy = zz << 1;\n-                        if (yy > nHeap) {\n-                            break;\n-                        }\n-                        if (yy < nHeap\n-                            && weight[heap[yy + 1]] < weight[heap[yy]]) {\n-                            yy++;\n-                        }\n-                        if (weight[tmp] < weight[heap[yy]]) {\n-                            break;\n-                        }\n-                        heap[zz] = heap[yy];\n-                        zz = yy;\n-                    }\n-                    heap[zz] = tmp;\n-                }\n-                n2 = heap[1];\n+\n+                int yy = 0;\n+                int zz = 1;\n+                int tmp = heap[1];\n+\n+                while (true) {\n+                    yy = zz << 1;\n+\n+                    if (yy > nHeap) {\n+                        break;\n+                    }\n+\n+                    if ((yy < nHeap)\n+                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n+                        yy++;\n+                    }\n+\n+                    if (weight[tmp] < weight[heap[yy]]) {\n+                        break;\n+                    }\n+\n+                    heap[zz] = heap[yy];\n+                    zz = yy;\n+                }\n+\n+                heap[zz] = tmp;\n+\n+                int n2 = heap[1];\n                 heap[1] = heap[nHeap];\n                 nHeap--;\n-                {\n-                    int zz = 0, yy = 0, tmp = 0;\n-                    zz = 1;\n-                    tmp = heap[zz];\n-                    while (true) {\n-                        yy = zz << 1;\n-                        if (yy > nHeap) {\n-                            break;\n-                        }\n-                        if (yy < nHeap\n-                            && weight[heap[yy + 1]] < weight[heap[yy]]) {\n-                            yy++;\n-                        }\n-                        if (weight[tmp] < weight[heap[yy]]) {\n-                            break;\n-                        }\n-                        heap[zz] = heap[yy];\n-                        zz = yy;\n-                    }\n-                    heap[zz] = tmp;\n-                }\n+\n+                yy = 0;\n+                zz = 1;\n+                tmp = heap[1];\n+\n+                while (true) {\n+                    yy = zz << 1;\n+\n+                    if (yy > nHeap) {\n+                        break;\n+                    }\n+\n+                    if ((yy < nHeap)\n+                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n+                        yy++;\n+                    }\n+\n+                    if (weight[tmp] < weight[heap[yy]]) {\n+                        break;\n+                    }\n+\n+                    heap[zz] = heap[yy];\n+                    zz = yy;\n+                }\n+\n+                heap[zz] = tmp;\n                 nNodes++;\n                 parent[n1] = parent[n2] = nNodes;\n \n-                weight[nNodes] = ((weight[n1] & 0xffffff00)\n-                                  + (weight[n2] & 0xffffff00))\n-                    | (1 + (((weight[n1] & 0x000000ff)\n-                             > (weight[n2] & 0x000000ff))\n-                            ? (weight[n1] & 0x000000ff)\n-                            : (weight[n2] & 0x000000ff)));\n+                final int weight_n1 = weight[n1];\n+                final int weight_n2 = weight[n2];\n+                weight[nNodes] = (((weight_n1 & 0xffffff00)\n+                                   + (weight_n2 & 0xffffff00))\n+                                  |\n+                                  (1 + (((weight_n1 & 0x000000ff)\n+                                         > (weight_n2 & 0x000000ff))\n+                                        ? (weight_n1 & 0x000000ff)\n+                                        : (weight_n2 & 0x000000ff))\n+                                   ));\n \n                 parent[nNodes] = -1;\n                 nHeap++;\n                 heap[nHeap] = nNodes;\n-                {\n-                    int zz = 0, tmp = 0;\n-                    zz = nHeap;\n-                    tmp = heap[zz];\n-                    while (weight[tmp] < weight[heap[zz >> 1]]) {\n-                        heap[zz] = heap[zz >> 1];\n-                        zz >>= 1;\n-                    }\n-                    heap[zz] = tmp;\n-                }\n-            }\n-            if (!(nNodes < (MAX_ALPHA_SIZE * 2))) {\n-                panic();\n-            }\n-\n-            tooLong = false;\n-            for (i = 1; i <= alphaSize; i++) {\n-                j = 0;\n-                k = i;\n-                while (parent[k] >= 0) {\n-                    k = parent[k];\n+\n+                tmp = 0;\n+                zz = nHeap;\n+                tmp = heap[zz];\n+                final int weight_tmp = weight[tmp];\n+                while (weight_tmp < weight[heap[zz >> 1]]) {\n+                    heap[zz] = heap[zz >> 1];\n+                    zz >>= 1;\n+                }\n+                heap[zz] = tmp;\n+\n+            }\n+\n+            // assert (nNodes < (MAX_ALPHA_SIZE * 2)) : nNodes;\n+\n+            for (int i = 1; i <= alphaSize; i++) {\n+                int j = 0;\n+                int k = i;\n+\n+                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n+                    k = parent_k;\n                     j++;\n                 }\n+\n                 len[i - 1] = (char) j;\n                 if (j > maxLen) {\n                     tooLong = true;\n                 }\n             }\n \n-            if (!tooLong) {\n-                break;\n-            }\n-\n-            for (i = 1; i < alphaSize; i++) {\n-                j = weight[i] >> 8;\n-                j = 1 + (j / 2);\n-                weight[i] = j << 8;\n-            }\n-        }\n-    }\n-\n-    /*\n-      index of the last char in the block, so\n-      the block size == last + 1.\n-    */\n+            if (tooLong) {\n+                for (int i = 1; i < alphaSize; i++) {\n+                    int j = weight[i] >> 8;\n+                    j = 1 + (j >> 1);\n+                    weight[i] = j << 8;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\n+                                          final Data dat, final int alphaSize,\n+                                          final int maxLen) {\n+        /*\n+         * Nodes and heap entries run from 1. Entry 0 for both the heap and\n+         * nodes is a sentinel.\n+         */\n+        final int[] heap = dat.heap;\n+        final int[] weight = dat.weight;\n+        final int[] parent = dat.parent;\n+\n+        for (int i = alphaSize; --i >= 0;) {\n+            weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n+        }\n+\n+        for (boolean tooLong = true; tooLong;) {\n+            tooLong = false;\n+\n+            int nNodes = alphaSize;\n+            int nHeap = 0;\n+            heap[0] = 0;\n+            weight[0] = 0;\n+            parent[0] = -2;\n+\n+            for (int i = 1; i <= alphaSize; i++) {\n+                parent[i] = -1;\n+                nHeap++;\n+                heap[nHeap] = i;\n+\n+                int zz = nHeap;\n+                int tmp = heap[zz];\n+                while (weight[tmp] < weight[heap[zz >> 1]]) {\n+                    heap[zz] = heap[zz >> 1];\n+                    zz >>= 1;\n+                }\n+                heap[zz] = tmp;\n+            }\n+\n+            while (nHeap > 1) {\n+                int n1 = heap[1];\n+                heap[1] = heap[nHeap];\n+                nHeap--;\n+\n+                int yy = 0;\n+                int zz = 1;\n+                int tmp = heap[1];\n+\n+                while (true) {\n+                    yy = zz << 1;\n+\n+                    if (yy > nHeap) {\n+                        break;\n+                    }\n+\n+                    if ((yy < nHeap)\n+                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n+                        yy++;\n+                    }\n+\n+                    if (weight[tmp] < weight[heap[yy]]) {\n+                        break;\n+                    }\n+\n+                    heap[zz] = heap[yy];\n+                    zz = yy;\n+                }\n+\n+                heap[zz] = tmp;\n+\n+                int n2 = heap[1];\n+                heap[1] = heap[nHeap];\n+                nHeap--;\n+\n+                yy = 0;\n+                zz = 1;\n+                tmp = heap[1];\n+\n+                while (true) {\n+                    yy = zz << 1;\n+\n+                    if (yy > nHeap) {\n+                        break;\n+                    }\n+\n+                    if ((yy < nHeap)\n+                        && (weight[heap[yy + 1]] < weight[heap[yy]])) {\n+                        yy++;\n+                    }\n+\n+                    if (weight[tmp] < weight[heap[yy]]) {\n+                        break;\n+                    }\n+\n+                    heap[zz] = heap[yy];\n+                    zz = yy;\n+                }\n+\n+                heap[zz] = tmp;\n+                nNodes++;\n+                parent[n1] = parent[n2] = nNodes;\n+\n+                final int weight_n1 = weight[n1];\n+                final int weight_n2 = weight[n2];\n+                weight[nNodes] = ((weight_n1 & 0xffffff00)\n+                                  + (weight_n2 & 0xffffff00))\n+                    | (1 + (((weight_n1 & 0x000000ff)\n+                             > (weight_n2 & 0x000000ff))\n+                            ? (weight_n1 & 0x000000ff)\n+                            : (weight_n2 & 0x000000ff)));\n+\n+                parent[nNodes] = -1;\n+                nHeap++;\n+                heap[nHeap] = nNodes;\n+\n+                tmp = 0;\n+                zz = nHeap;\n+                tmp = heap[zz];\n+                final int weight_tmp = weight[tmp];\n+                while (weight_tmp < weight[heap[zz >> 1]]) {\n+                    heap[zz] = heap[zz >> 1];\n+                    zz >>= 1;\n+                }\n+                heap[zz] = tmp;\n+\n+            }\n+\n+            for (int i = 1; i <= alphaSize; i++) {\n+                int j = 0;\n+                int k = i;\n+\n+                for (int parent_k; (parent_k = parent[k]) >= 0;) {\n+                    k = parent_k;\n+                    j++;\n+                }\n+\n+                len[i - 1] = (byte) j;\n+                if (j > maxLen) {\n+                    tooLong = true;\n+                }\n+            }\n+\n+            if (tooLong) {\n+                for (int i = 1; i < alphaSize; i++) {\n+                    int j = weight[i] >> 8;\n+                    j = 1 + (j >> 1);\n+                    weight[i] = j << 8;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Index of the last char in the block, so the block size == last + 1.\n+     */\n     private int last;\n \n-    /*\n-      index in zptr[] of original string after sorting.\n-    */\n+    /**\n+     * Index in fmap[] of original string after sorting.\n+     */\n     private int origPtr;\n \n-    /*\n-      always: in the range 0 .. 9.\n-      The current block size is 100000 * this number.\n-    */\n-    private int blockSize100k;\n+    /**\n+     * Always: in the range 0 .. 9. The current block size is 100000 * this\n+     * number.\n+     */\n+    private final int blockSize100k;\n \n     private boolean blockRandomised;\n \n-    private int bytesOut;\n     private int bsBuff;\n     private int bsLive;\n-    private final CRC mCrc = new CRC();\n-\n-    private boolean[] inUse = new boolean[256];\n+    private final CRC crc = new CRC();\n+\n     private int nInUse;\n \n-    private char[] seqToUnseq = new char[256];\n-    private char[] unseqToSeq = new char[256];\n-\n-    private char[] selector = new char[MAX_SELECTORS];\n-    private char[] selectorMtf = new char[MAX_SELECTORS];\n-\n-    private char[] block;\n-    private int[] quadrant;\n-    private int[] zptr;\n-    private short[] szptr;\n-    private int[] ftab;\n-\n     private int nMTF;\n \n-    private int[] mtfFreq = new int[MAX_ALPHA_SIZE];\n-\n     /*\n-     * Used when sorting.  If too many long comparisons\n-     * happen, we stop sorting, randomise the block\n-     * slightly, and try again.\n+     * Used when sorting. If too many long comparisons happen, we stop sorting,\n+     * randomise the block slightly, and try again.\n      */\n-    private int workFactor;\n     private int workDone;\n     private int workLimit;\n     private boolean firstAttempt;\n-    private int nBlocksRandomised;\n \n     private int currentChar = -1;\n     private int runLength = 0;\n \n-    public BZip2CompressorOutputStream(OutputStream inStream) throws IOException {\n-        this(inStream, 9);\n-    }\n-\n-    public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize)\n+    private int blockCRC;\n+    private int combinedCRC;\n+    private int allowableBlockSize;\n+\n+    /**\n+     * All memory intensive stuff.\n+     */\n+    private Data data;\n+\n+    private OutputStream out;\n+\n+    /**\n+     * Chooses a blocksize based on the given length of the data to compress.\n+     *\n+     * @return The blocksize, between {@link #MIN_BLOCKSIZE} and\n+     *         {@link #MAX_BLOCKSIZE} both inclusive. For a negative\n+     *         <tt>inputLength</tt> this method returns <tt>MAX_BLOCKSIZE</tt>\n+     *         always.\n+     *\n+     * @param inputLength\n+     *            The length of the data which will be compressed by\n+     *            <tt>CBZip2OutputStream</tt>.\n+     */\n+    public static int chooseBlockSize(long inputLength) {\n+        return (inputLength > 0) ? (int) Math\n+            .min((inputLength / 132000) + 1, 9) : MAX_BLOCKSIZE;\n+    }\n+\n+    /**\n+     * Constructs a new <tt>CBZip2OutputStream</tt> with a blocksize of 900k.\n+     *\n+     * <p>\n+     * <b>Attention: </b>The caller is resonsible to write the two BZip2 magic\n+     * bytes <tt>\"BZ\"</tt> to the specified stream prior to calling this\n+     * constructor.\n+     * </p>\n+     *\n+     * @param out *\n+     *            the destination stream.\n+     *\n+     * @throws IOException\n+     *             if an I/O error occurs in the specified stream.\n+     * @throws NullPointerException\n+     *             if <code>out == null</code>.\n+     */\n+    public BZip2CompressorOutputStream(final OutputStream out)\n         throws IOException {\n-        block = null;\n-        quadrant = null;\n-        zptr = null;\n-        ftab = null;\n-\n-        bsSetStream(inStream);\n-\n-        workFactor = 50;\n-        if (inBlockSize > 9) {\n-            inBlockSize = 9;\n-        }\n-        if (inBlockSize < 1) {\n-            inBlockSize = 1;\n-        }\n-        blockSize100k = inBlockSize;\n-        allocateCompressStructures();\n-        initialize();\n-        initBlock();\n+        this(out, MAX_BLOCKSIZE);\n     }\n \n     /**\n+     * Constructs a new <tt>CBZip2OutputStream</tt> with specified blocksize.\n      *\n-     * modified by Oliver Merkel, 010128\n+     * <p>\n+     * <b>Attention: </b>The caller is resonsible to write the two BZip2 magic\n+     * bytes <tt>\"BZ\"</tt> to the specified stream prior to calling this\n+     * constructor.\n+     * </p>\n      *\n+     *\n+     * @param out\n+     *            the destination stream.\n+     * @param blockSize\n+     *            the blockSize as 100k units.\n+     *\n+     * @throws IOException\n+     *             if an I/O error occurs in the specified stream.\n+     * @throws IllegalArgumentException\n+     *             if <code>(blockSize < 1) || (blockSize > 9)</code>.\n+     * @throws NullPointerException\n+     *             if <code>out == null</code>.\n+     *\n+     * @see #MIN_BLOCKSIZE\n+     * @see #MAX_BLOCKSIZE\n      */\n-    public void write(int bv) throws IOException {\n-        int b = (256 + bv) % 256;\n-        if (currentChar != -1) {\n-            if (currentChar == b) {\n-                runLength++;\n-                if (runLength > 254) {\n-                    writeRun();\n-                    currentChar = -1;\n-                    runLength = 0;\n-                }\n-            } else {\n-                writeRun();\n-                runLength = 1;\n-                currentChar = b;\n-            }\n+    public BZip2CompressorOutputStream(final OutputStream out,\n+                                       final int blockSize)\n+        throws IOException {\n+        super();\n+\n+        if (blockSize < 1) {\n+            throw new IllegalArgumentException(\"blockSize(\" + blockSize\n+                                               + \") < 1\");\n+        }\n+        if (blockSize > 9) {\n+            throw new IllegalArgumentException(\"blockSize(\" + blockSize\n+                                               + \") > 9\");\n+        }\n+\n+        this.blockSize100k = blockSize;\n+        this.out = out;\n+        init();\n+    }\n+\n+    public void write(final int b) throws IOException {\n+        if (this.out != null) {\n+            write0(b);\n         } else {\n-            currentChar = b;\n-            runLength++;\n+            throw new IOException(\"closed\");\n         }\n     }\n \n     private void writeRun() throws IOException {\n-        if (last < allowableBlockSize) {\n-            inUse[currentChar] = true;\n-            for (int i = 0; i < runLength; i++) {\n-                mCrc.updateCRC((char) currentChar);\n-            }\n-            switch (runLength) {\n+        final int lastShadow = this.last;\n+\n+        if (lastShadow < this.allowableBlockSize) {\n+            final int currentCharShadow = this.currentChar;\n+            final Data dataShadow = this.data;\n+            dataShadow.inUse[currentCharShadow] = true;\n+            final byte ch = (byte) currentCharShadow;\n+\n+            int runLengthShadow = this.runLength;\n+            this.crc.updateCRC(currentCharShadow, runLengthShadow);\n+\n+            switch (runLengthShadow) {\n             case 1:\n-                last++;\n-                block[last + 1] = (char) currentChar;\n+                dataShadow.block[lastShadow + 2] = ch;\n+                this.last = lastShadow + 1;\n                 break;\n+\n             case 2:\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n+                dataShadow.block[lastShadow + 2] = ch;\n+                dataShadow.block[lastShadow + 3] = ch;\n+                this.last = lastShadow + 2;\n                 break;\n-            case 3:\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n+\n+            case 3: {\n+                final byte[] block = dataShadow.block;\n+                block[lastShadow + 2] = ch;\n+                block[lastShadow + 3] = ch;\n+                block[lastShadow + 4] = ch;\n+                this.last = lastShadow + 3;\n+            }\n                 break;\n-            default:\n-                inUse[runLength - 4] = true;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) currentChar;\n-                last++;\n-                block[last + 1] = (char) (runLength - 4);\n+\n+            default: {\n+                runLengthShadow -= 4;\n+                dataShadow.inUse[runLengthShadow] = true;\n+                final byte[] block = dataShadow.block;\n+                block[lastShadow + 2] = ch;\n+                block[lastShadow + 3] = ch;\n+                block[lastShadow + 4] = ch;\n+                block[lastShadow + 5] = ch;\n+                block[lastShadow + 6] = (byte) runLengthShadow;\n+                this.last = lastShadow + 5;\n+            }\n                 break;\n+\n             }\n         } else {\n             endBlock();\n         }\n     }\n \n-    private boolean closed = false;\n-\n+    /**\n+     * Overriden to close the stream.\n+     */\n     protected void finalize() throws Throwable {\n-        close();\n+        finish();\n         super.finalize();\n     }\n \n+\n+    public void finish() throws IOException {\n+        if (out != null) {\n+            try {\n+                if (this.runLength > 0) {\n+                    writeRun();\n+                }\n+                this.currentChar = -1;\n+                endBlock();\n+                endCompression();\n+            } finally {\n+                this.out = null;\n+                this.data = null;\n+            }\n+        }\n+    }\n+\n     public void close() throws IOException {\n-        if (closed) {\n+        if (out != null) {\n+            OutputStream outShadow = this.out;\n+            finish();\n+            outShadow.close();\n+        }\n+    }\n+\n+    public void flush() throws IOException {\n+        OutputStream outShadow = this.out;\n+        if (outShadow != null) {\n+            outShadow.flush();\n+        }\n+    }\n+\n+    private void init() throws IOException {\n+        // write magic: done by caller who created this stream\n+        // this.out.write('B');\n+        // this.out.write('Z');\n+\n+        this.data = new Data(this.blockSize100k);\n+\n+        /*\n+         * Write `magic' bytes h indicating file-format == huffmanised, followed\n+         * by a digit indicating blockSize100k.\n+         */\n+        bsPutUByte('h');\n+        bsPutUByte('0' + this.blockSize100k);\n+\n+        this.combinedCRC = 0;\n+        initBlock();\n+    }\n+\n+    private void initBlock() {\n+        // blockNo++;\n+        this.crc.initialiseCRC();\n+        this.last = -1;\n+        // ch = 0;\n+\n+        boolean[] inUse = this.data.inUse;\n+        for (int i = 256; --i >= 0;) {\n+            inUse[i] = false;\n+        }\n+\n+        /* 20 is just a paranoia constant */\n+        this.allowableBlockSize = (this.blockSize100k * BZip2Constants.baseBlockSize) - 20;\n+    }\n+\n+    private void endBlock() throws IOException {\n+        this.blockCRC = this.crc.getFinalCRC();\n+        this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\n+        this.combinedCRC ^= this.blockCRC;\n+\n+        // empty block at end of file\n+        if (this.last == -1) {\n             return;\n         }\n-        finish();\n-        super.close();\n-        bsStream.close();\n-        closed = true;\n-    }\n-\n-    protected void finish() throws IOException {\n-        if (closed) {\n-            return;\n-        }\n-\n-        if (runLength > 0) {\n-            writeRun();\n-        }\n-        currentChar = -1;\n-        endBlock();\n-        endCompression();\n-    }\n-\n-    public void flush() throws IOException {\n-        super.flush();\n-        bsStream.flush();\n-    }\n-\n-    private int blockCRC, combinedCRC;\n-\n-    private void initialize() throws IOException {\n-        bytesOut = 0;\n-        nBlocksRandomised = 0;\n-\n-        bsPutUChar('B');\n-        bsPutUChar('Z');\n-        /* Write `magic' bytes h indicating file-format == huffmanised,\n-           followed by a digit indicating blockSize100k.\n-        */\n-        bsPutUChar('h');\n-        bsPutUChar('0' + blockSize100k);\n-\n-        combinedCRC = 0;\n-    }\n-\n-    private int allowableBlockSize;\n-\n-    private void initBlock() {\n-        //        blockNo++;\n-        mCrc.initialiseCRC();\n-        last = -1;\n-        //        ch = 0;\n-\n-        for (int i = 0; i < 256; i++) {\n-            inUse[i] = false;\n-        }\n-\n-        /* 20 is just a paranoia constant */\n-        allowableBlockSize = baseBlockSize * blockSize100k - 20;\n-    }\n-\n-    private void endBlock() throws IOException {\n-        blockCRC = mCrc.getFinalCRC();\n-        combinedCRC = (combinedCRC << 1) | (combinedCRC >>> 31);\n-        combinedCRC ^= blockCRC;\n-\n-        // If the stream was empty we must skip the rest of this method.\n-        // See bug#32200.\n-        if (last == -1) {\n-            return;\n-        }\n \n         /* sort the block and establish posn of original string */\n-        doReversibleTransformation();\n+        blockSort();\n \n         /*\n-          A 6-byte block header, the value chosen arbitrarily\n-          as 0x314159265359 :-).  A 32 bit value does not really\n-          give a strong enough guarantee that the value will not\n-          appear by chance in the compressed datastream.  Worst-case\n-          probability of this event, for a 900k block, is about\n-          2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.\n-          For a compressed file of size 100Gb -- about 100000 blocks --\n-          only a 48-bit marker will do.  NB: normal compression/\n-          decompression do *not* rely on these statistical properties.\n-          They are only important when trying to recover blocks from\n-          damaged files.\n-        */\n-        bsPutUChar(0x31);\n-        bsPutUChar(0x41);\n-        bsPutUChar(0x59);\n-        bsPutUChar(0x26);\n-        bsPutUChar(0x53);\n-        bsPutUChar(0x59);\n+         * A 6-byte block header, the value chosen arbitrarily as 0x314159265359\n+         * :-). A 32 bit value does not really give a strong enough guarantee\n+         * that the value will not appear by chance in the compressed\n+         * datastream. Worst-case probability of this event, for a 900k block,\n+         * is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48\n+         * bits. For a compressed file of size 100Gb -- about 100000 blocks --\n+         * only a 48-bit marker will do. NB: normal compression/ decompression\n+         * donot rely on these statistical properties. They are only important\n+         * when trying to recover blocks from damaged files.\n+         */\n+        bsPutUByte(0x31);\n+        bsPutUByte(0x41);\n+        bsPutUByte(0x59);\n+        bsPutUByte(0x26);\n+        bsPutUByte(0x53);\n+        bsPutUByte(0x59);\n \n         /* Now the block's CRC, so it is in a known place. */\n-        bsPutint(blockCRC);\n+        bsPutInt(this.blockCRC);\n \n         /* Now a single bit indicating randomisation. */\n-        if (blockRandomised) {\n+        if (this.blockRandomised) {\n             bsW(1, 1);\n-            nBlocksRandomised++;\n         } else {\n             bsW(1, 0);\n         }\n \n     private void endCompression() throws IOException {\n         /*\n-          Now another magic 48-bit number, 0x177245385090, to\n-          indicate the end of the last block.  (sqrt(pi), if\n-          you want to know.  I did want to use e, but it contains\n-          too much repetition -- 27 18 28 18 28 46 -- for me\n-          to feel statistically comfortable.  Call me paranoid.)\n-        */\n-        bsPutUChar(0x17);\n-        bsPutUChar(0x72);\n-        bsPutUChar(0x45);\n-        bsPutUChar(0x38);\n-        bsPutUChar(0x50);\n-        bsPutUChar(0x90);\n-\n-        bsPutint(combinedCRC);\n-\n+         * Now another magic 48-bit number, 0x177245385090, to indicate the end\n+         * of the last block. (sqrt(pi), if you want to know. I did want to use\n+         * e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me\n+         * to feel statistically comfortable. Call me paranoid.)\n+         */\n+        bsPutUByte(0x17);\n+        bsPutUByte(0x72);\n+        bsPutUByte(0x45);\n+        bsPutUByte(0x38);\n+        bsPutUByte(0x50);\n+        bsPutUByte(0x90);\n+\n+        bsPutInt(this.combinedCRC);\n         bsFinishedWithStream();\n     }\n \n-    private void hbAssignCodes (int[] code, char[] length, int minLen,\n-                                int maxLen, int alphaSize) {\n-        int n, vec, i;\n-\n-        vec = 0;\n-        for (n = minLen; n <= maxLen; n++) {\n-            for (i = 0; i < alphaSize; i++) {\n-                if (length[i] == n) {\n+    /**\n+     * Returns the blocksize parameter specified at construction time.\n+     */\n+    public final int getBlockSize() {\n+        return this.blockSize100k;\n+    }\n+\n+    public void write(final byte[] buf, int offs, final int len)\n+        throws IOException {\n+        if (offs < 0) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n+        }\n+        if (len < 0) {\n+            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n+        }\n+        if (offs + len > buf.length) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+                                                + len + \") > buf.length(\"\n+                                                + buf.length + \").\");\n+        }\n+        if (this.out == null) {\n+            throw new IOException(\"stream closed\");\n+        }\n+\n+        for (int hi = offs + len; offs < hi;) {\n+            write0(buf[offs++]);\n+        }\n+    }\n+\n+    private void write0(int b) throws IOException {\n+        if (this.currentChar != -1) {\n+            b &= 0xff;\n+            if (this.currentChar == b) {\n+                if (++this.runLength > 254) {\n+                    writeRun();\n+                    this.currentChar = -1;\n+                    this.runLength = 0;\n+                }\n+                // else nothing to do\n+            } else {\n+                writeRun();\n+                this.runLength = 1;\n+                this.currentChar = b;\n+            }\n+        } else {\n+            this.currentChar = b & 0xff;\n+            this.runLength++;\n+        }\n+    }\n+\n+    private static void hbAssignCodes(final int[] code, final byte[] length,\n+                                      final int minLen, final int maxLen,\n+                                      final int alphaSize) {\n+        int vec = 0;\n+        for (int n = minLen; n <= maxLen; n++) {\n+            for (int i = 0; i < alphaSize; i++) {\n+                if ((length[i] & 0xff) == n) {\n                     code[i] = vec;\n                     vec++;\n                 }\n         }\n     }\n \n-    private void bsSetStream(OutputStream f) {\n-        bsStream = f;\n-        bsLive = 0;\n-        bsBuff = 0;\n-        bytesOut = 0;\n-    }\n-\n     private void bsFinishedWithStream() throws IOException {\n-        while (bsLive > 0) {\n-            int ch = (bsBuff >> 24);\n-            try {\n-                bsStream.write(ch); // write 8-bit\n-            } catch (IOException e) {\n-                throw  e;\n-            }\n-            bsBuff <<= 8;\n-            bsLive -= 8;\n-            bytesOut++;\n-        }\n-    }\n-\n-    private void bsW(int n, int v) throws IOException {\n-        while (bsLive >= 8) {\n-            int ch = (bsBuff >> 24);\n-            try {\n-                bsStream.write(ch); // write 8-bit\n-            } catch (IOException e) {\n-                throw e;\n-            }\n-            bsBuff <<= 8;\n-            bsLive -= 8;\n-            bytesOut++;\n-        }\n-        bsBuff |= (v << (32 - bsLive - n));\n-        bsLive += n;\n-    }\n-\n-    private void bsPutUChar(int c) throws IOException {\n+        while (this.bsLive > 0) {\n+            int ch = this.bsBuff >> 24;\n+            this.out.write(ch); // write 8-bit\n+            this.bsBuff <<= 8;\n+            this.bsLive -= 8;\n+        }\n+    }\n+\n+    private void bsW(final int n, final int v) throws IOException {\n+        final OutputStream outShadow = this.out;\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        while (bsLiveShadow >= 8) {\n+            outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+            bsBuffShadow <<= 8;\n+            bsLiveShadow -= 8;\n+        }\n+\n+        this.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\n+        this.bsLive = bsLiveShadow + n;\n+    }\n+\n+    private void bsPutUByte(final int c) throws IOException {\n         bsW(8, c);\n     }\n \n-    private void bsPutint(int u) throws IOException {\n+    private void bsPutInt(final int u) throws IOException {\n         bsW(8, (u >> 24) & 0xff);\n         bsW(8, (u >> 16) & 0xff);\n-        bsW(8, (u >>  8) & 0xff);\n-        bsW(8,  u        & 0xff);\n-    }\n-\n-    private void bsPutIntVS(int numBits, int c) throws IOException {\n-        bsW(numBits, c);\n+        bsW(8, (u >> 8) & 0xff);\n+        bsW(8, u & 0xff);\n     }\n \n     private void sendMTFValues() throws IOException {\n-        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n-\n-        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n-        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n-        int nGroups; //, nBytes;\n-\n-        alphaSize = nInUse + 2;\n-        for (t = 0; t < N_GROUPS; t++) {\n-            for (v = 0; v < alphaSize; v++) {\n-                len[t][v] = (char) GREATER_ICOST;\n+        final byte[][] len = this.data.sendMTFValues_len;\n+        final int alphaSize = this.nInUse + 2;\n+\n+        for (int t = N_GROUPS; --t >= 0;) {\n+            byte[] len_t = len[t];\n+            for (int v = alphaSize; --v >= 0;) {\n+                len_t[v] = GREATER_ICOST;\n             }\n         }\n \n         /* Decide how many coding tables to use */\n-        if (nMTF <= 0) {\n-            panic();\n-        }\n-\n-        if (nMTF < 200) {\n-            nGroups = 2;\n-        } else if (nMTF < 600) {\n-            nGroups = 3;\n-        } else if (nMTF < 1200) {\n-            nGroups = 4;\n-        } else if (nMTF < 2400) {\n-            nGroups = 5;\n-        } else {\n-            nGroups = 6;\n-        }\n-\n-        /* Generate an initial set of coding tables */ {\n-            int nPart, remF, tFreq, aFreq;\n-\n-            nPart = nGroups;\n-            remF  = nMTF;\n-            gs = 0;\n-            while (nPart > 0) {\n-                tFreq = remF / nPart;\n-                ge = gs - 1;\n-                aFreq = 0;\n-                while (aFreq < tFreq && ge < alphaSize - 1) {\n-                    ge++;\n-                    aFreq += mtfFreq[ge];\n-                }\n-\n-                if (ge > gs && nPart != nGroups && nPart != 1\n-                    && ((nGroups - nPart) % 2 != 0)) {\n-                    aFreq -= mtfFreq[ge];\n-                    ge--;\n-                }\n-\n-                for (v = 0; v < alphaSize; v++) {\n-                    if (v >= gs && v <= ge) {\n-                        len[nPart - 1][v] = (char) LESSER_ICOST;\n-                    } else {\n-                        len[nPart - 1][v] = (char) GREATER_ICOST;\n-                    }\n-                }\n-\n-                nPart--;\n-                gs = ge + 1;\n-                remF -= aFreq;\n-            }\n-        }\n-\n-        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n-        int[] fave = new int[N_GROUPS];\n-        short[] cost = new short[N_GROUPS];\n+        // assert (this.nMTF > 0) : this.nMTF;\n+        final int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\n+            : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;\n+\n+        /* Generate an initial set of coding tables */\n+        sendMTFValues0(nGroups, alphaSize);\n+\n         /*\n-          Iterate up to N_ITERS times to improve the tables.\n-        */\n-        for (iter = 0; iter < N_ITERS; iter++) {\n-            for (t = 0; t < nGroups; t++) {\n+         * Iterate up to N_ITERS times to improve the tables.\n+         */\n+        final int nSelectors = sendMTFValues1(nGroups, alphaSize);\n+\n+        /* Compute MTF values for the selectors. */\n+        sendMTFValues2(nGroups, nSelectors);\n+\n+        /* Assign actual codes for the tables. */\n+        sendMTFValues3(nGroups, alphaSize);\n+\n+        /* Transmit the mapping table. */\n+        sendMTFValues4();\n+\n+        /* Now the selectors. */\n+        sendMTFValues5(nGroups, nSelectors);\n+\n+        /* Now the coding tables. */\n+        sendMTFValues6(nGroups, alphaSize);\n+\n+        /* And finally, the block data proper */\n+        sendMTFValues7(nSelectors);\n+    }\n+\n+    private void sendMTFValues0(final int nGroups, final int alphaSize) {\n+        final byte[][] len = this.data.sendMTFValues_len;\n+        final int[] mtfFreq = this.data.mtfFreq;\n+\n+        int remF = this.nMTF;\n+        int gs = 0;\n+\n+        for (int nPart = nGroups; nPart > 0; nPart--) {\n+            final int tFreq = remF / nPart;\n+            int ge = gs - 1;\n+            int aFreq = 0;\n+\n+            for (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\n+                aFreq += mtfFreq[++ge];\n+            }\n+\n+            if ((ge > gs) && (nPart != nGroups) && (nPart != 1)\n+                && (((nGroups - nPart) & 1) != 0)) {\n+                aFreq -= mtfFreq[ge--];\n+            }\n+\n+            final byte[] len_np = len[nPart - 1];\n+            for (int v = alphaSize; --v >= 0;) {\n+                if ((v >= gs) && (v <= ge)) {\n+                    len_np[v] = LESSER_ICOST;\n+                } else {\n+                    len_np[v] = GREATER_ICOST;\n+                }\n+            }\n+\n+            gs = ge + 1;\n+            remF -= aFreq;\n+        }\n+    }\n+\n+    private int sendMTFValues1(final int nGroups, final int alphaSize) {\n+        final Data dataShadow = this.data;\n+        final int[][] rfreq = dataShadow.sendMTFValues_rfreq;\n+        final int[] fave = dataShadow.sendMTFValues_fave;\n+        final short[] cost = dataShadow.sendMTFValues_cost;\n+        final char[] sfmap = dataShadow.sfmap;\n+        final byte[] selector = dataShadow.selector;\n+        final byte[][] len = dataShadow.sendMTFValues_len;\n+        final byte[] len_0 = len[0];\n+        final byte[] len_1 = len[1];\n+        final byte[] len_2 = len[2];\n+        final byte[] len_3 = len[3];\n+        final byte[] len_4 = len[4];\n+        final byte[] len_5 = len[5];\n+        final int nMTFShadow = this.nMTF;\n+\n+        int nSelectors = 0;\n+\n+        for (int iter = 0; iter < N_ITERS; iter++) {\n+            for (int t = nGroups; --t >= 0;) {\n                 fave[t] = 0;\n-            }\n-\n-            for (t = 0; t < nGroups; t++) {\n-                for (v = 0; v < alphaSize; v++) {\n-                    rfreq[t][v] = 0;\n+                int[] rfreqt = rfreq[t];\n+                for (int i = alphaSize; --i >= 0;) {\n+                    rfreqt[i] = 0;\n                 }\n             }\n \n             nSelectors = 0;\n-            totc = 0;\n-            gs = 0;\n-            while (true) {\n-\n+\n+            for (int gs = 0; gs < this.nMTF;) {\n                 /* Set group start & end marks. */\n-                if (gs >= nMTF) {\n-                    break;\n-                }\n-                ge = gs + G_SIZE - 1;\n-                if (ge >= nMTF) {\n-                    ge = nMTF - 1;\n-                }\n \n                 /*\n-                  Calculate the cost of this group as coded\n-                  by each of the coding tables.\n-                */\n-                for (t = 0; t < nGroups; t++) {\n-                    cost[t] = 0;\n-                }\n-\n-                if (nGroups == 6) {\n-                    short cost0, cost1, cost2, cost3, cost4, cost5;\n-                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n-                    for (i = gs; i <= ge; i++) {\n-                        short icv = szptr[i];\n-                        cost0 += len[0][icv];\n-                        cost1 += len[1][icv];\n-                        cost2 += len[2][icv];\n-                        cost3 += len[3][icv];\n-                        cost4 += len[4][icv];\n-                        cost5 += len[5][icv];\n-                    }\n+                 * Calculate the cost of this group as coded by each of the\n+                 * coding tables.\n+                 */\n+\n+                final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\n+\n+                if (nGroups == N_GROUPS) {\n+                    // unrolled version of the else-block\n+\n+                    short cost0 = 0;\n+                    short cost1 = 0;\n+                    short cost2 = 0;\n+                    short cost3 = 0;\n+                    short cost4 = 0;\n+                    short cost5 = 0;\n+\n+                    for (int i = gs; i <= ge; i++) {\n+                        final int icv = sfmap[i];\n+                        cost0 += len_0[icv] & 0xff;\n+                        cost1 += len_1[icv] & 0xff;\n+                        cost2 += len_2[icv] & 0xff;\n+                        cost3 += len_3[icv] & 0xff;\n+                        cost4 += len_4[icv] & 0xff;\n+                        cost5 += len_5[icv] & 0xff;\n+                    }\n+\n                     cost[0] = cost0;\n                     cost[1] = cost1;\n                     cost[2] = cost2;\n                     cost[3] = cost3;\n                     cost[4] = cost4;\n                     cost[5] = cost5;\n+\n                 } else {\n-                    for (i = gs; i <= ge; i++) {\n-                        short icv = szptr[i];\n-                        for (t = 0; t < nGroups; t++) {\n-                            cost[t] += len[t][icv];\n+                    for (int t = nGroups; --t >= 0;) {\n+                        cost[t] = 0;\n+                    }\n+\n+                    for (int i = gs; i <= ge; i++) {\n+                        final int icv = sfmap[i];\n+                        for (int t = nGroups; --t >= 0;) {\n+                            cost[t] += len[t][icv] & 0xff;\n                         }\n                     }\n                 }\n \n                 /*\n-                  Find the coding table which is best for this group,\n-                  and record its identity in the selector table.\n-                */\n-                bc = 999999999;\n-                bt = -1;\n-                for (t = 0; t < nGroups; t++) {\n-                    if (cost[t] < bc) {\n-                        bc = cost[t];\n+                 * Find the coding table which is best for this group, and\n+                 * record its identity in the selector table.\n+                 */\n+                int bt = -1;\n+                for (int t = nGroups, bc = 999999999; --t >= 0;) {\n+                    final int cost_t = cost[t];\n+                    if (cost_t < bc) {\n+                        bc = cost_t;\n                         bt = t;\n                     }\n                 }\n-                totc += bc;\n+\n                 fave[bt]++;\n-                selector[nSelectors] = (char) bt;\n+                selector[nSelectors] = (byte) bt;\n                 nSelectors++;\n \n                 /*\n-                  Increment the symbol frequencies for the selected table.\n-                */\n-                for (i = gs; i <= ge; i++) {\n-                    rfreq[bt][szptr[i]]++;\n+                 * Increment the symbol frequencies for the selected table.\n+                 */\n+                final int[] rfreq_bt = rfreq[bt];\n+                for (int i = gs; i <= ge; i++) {\n+                    rfreq_bt[sfmap[i]]++;\n                 }\n \n                 gs = ge + 1;\n             }\n \n             /*\n-              Recompute the tables based on the accumulated frequencies.\n-            */\n-            for (t = 0; t < nGroups; t++) {\n-                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n-            }\n-        }\n-\n-        rfreq = null;\n-        fave = null;\n-        cost = null;\n-\n-        if (!(nGroups < 8)) {\n-            panic();\n-        }\n-        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n-            panic();\n-        }\n-\n-\n-        /* Compute MTF values for the selectors. */\n-        {\n-            char[] pos = new char[N_GROUPS];\n-            char ll_i, tmp2, tmp;\n-            for (i = 0; i < nGroups; i++) {\n-                pos[i] = (char) i;\n-            }\n-            for (i = 0; i < nSelectors; i++) {\n-                ll_i = selector[i];\n-                j = 0;\n+             * Recompute the tables based on the accumulated frequencies.\n+             */\n+            for (int t = 0; t < nGroups; t++) {\n+                hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\n+            }\n+        }\n+\n+        return nSelectors;\n+    }\n+\n+    private void sendMTFValues2(final int nGroups, final int nSelectors) {\n+        // assert (nGroups < 8) : nGroups;\n+\n+        final Data dataShadow = this.data;\n+        byte[] pos = dataShadow.sendMTFValues2_pos;\n+\n+        for (int i = nGroups; --i >= 0;) {\n+            pos[i] = (byte) i;\n+        }\n+\n+        for (int i = 0; i < nSelectors; i++) {\n+            final byte ll_i = dataShadow.selector[i];\n+            byte tmp = pos[0];\n+            int j = 0;\n+\n+            while (ll_i != tmp) {\n+                j++;\n+                byte tmp2 = tmp;\n                 tmp = pos[j];\n-                while (ll_i != tmp) {\n-                    j++;\n-                    tmp2 = tmp;\n-                    tmp = pos[j];\n-                    pos[j] = tmp2;\n-                }\n-                pos[0] = tmp;\n-                selectorMtf[i] = (char) j;\n-            }\n-        }\n-\n-        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n-\n-        /* Assign actual codes for the tables. */\n-        for (t = 0; t < nGroups; t++) {\n-            minLen = 32;\n-            maxLen = 0;\n-            for (i = 0; i < alphaSize; i++) {\n-                if (len[t][i] > maxLen) {\n-                    maxLen = len[t][i];\n-                }\n-                if (len[t][i] < minLen) {\n-                    minLen = len[t][i];\n-                }\n-            }\n-            if (maxLen > 20) {\n-                panic();\n-            }\n-            if (minLen < 1) {\n-                panic();\n-            }\n+                pos[j] = tmp2;\n+            }\n+\n+            pos[0] = tmp;\n+            dataShadow.selectorMtf[i] = (byte) j;\n+        }\n+    }\n+\n+    private void sendMTFValues3(final int nGroups, final int alphaSize) {\n+        int[][] code = this.data.sendMTFValues_code;\n+        byte[][] len = this.data.sendMTFValues_len;\n+\n+        for (int t = 0; t < nGroups; t++) {\n+            int minLen = 32;\n+            int maxLen = 0;\n+            final byte[] len_t = len[t];\n+            for (int i = alphaSize; --i >= 0;) {\n+                final int l = len_t[i] & 0xff;\n+                if (l > maxLen) {\n+                    maxLen = l;\n+                }\n+                if (l < minLen) {\n+                    minLen = l;\n+                }\n+            }\n+\n+            // assert (maxLen <= 20) : maxLen;\n+            // assert (minLen >= 1) : minLen;\n+\n             hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n         }\n-\n-        /* Transmit the mapping table. */\n-        {\n-            boolean[] inUse16 = new boolean[16];\n-            for (i = 0; i < 16; i++) {\n-                inUse16[i] = false;\n-                for (j = 0; j < 16; j++) {\n-                    if (inUse[i * 16 + j]) {\n-                        inUse16[i] = true;\n-                    }\n-                }\n-            }\n-\n-            //nBytes = bytesOut;\n-            for (i = 0; i < 16; i++) {\n-                if (inUse16[i]) {\n-                    bsW(1, 1);\n-                } else {\n-                    bsW(1, 0);\n-                }\n-            }\n-\n-            for (i = 0; i < 16; i++) {\n-                if (inUse16[i]) {\n-                    for (j = 0; j < 16; j++) {\n-                        if (inUse[i * 16 + j]) {\n-                            bsW(1, 1);\n-                        } else {\n-                            bsW(1, 0);\n-                        }\n-                    }\n-                }\n-            }\n-\n-        }\n-\n-        /* Now the selectors. */\n-        //nBytes = bytesOut;\n-        bsW (3, nGroups);\n-        bsW (15, nSelectors);\n-        for (i = 0; i < nSelectors; i++) {\n-            for (j = 0; j < selectorMtf[i]; j++) {\n-                bsW(1, 1);\n-            }\n-            bsW(1, 0);\n-        }\n-\n-        /* Now the coding tables. */\n-        //nBytes = bytesOut;\n-\n-        for (t = 0; t < nGroups; t++) {\n-            int curr = len[t][0];\n-            bsW(5, curr);\n-            for (i = 0; i < alphaSize; i++) {\n-                while (curr < len[t][i]) {\n-                    bsW(2, 2);\n+    }\n+\n+    private void sendMTFValues4() throws IOException {\n+        final boolean[] inUse = this.data.inUse;\n+        final boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\n+\n+        for (int i = 16; --i >= 0;) {\n+            inUse16[i] = false;\n+            final int i16 = i * 16;\n+            for (int j = 16; --j >= 0;) {\n+                if (inUse[i16 + j]) {\n+                    inUse16[i] = true;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < 16; i++) {\n+            bsW(1, inUse16[i] ? 1 : 0);\n+        }\n+\n+        final OutputStream outShadow = this.out;\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        for (int i = 0; i < 16; i++) {\n+            if (inUse16[i]) {\n+                final int i16 = i * 16;\n+                for (int j = 0; j < 16; j++) {\n+                    // inlined: bsW(1, inUse[i16 + j] ? 1 : 0);\n+                    while (bsLiveShadow >= 8) {\n+                        outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+                        bsBuffShadow <<= 8;\n+                        bsLiveShadow -= 8;\n+                    }\n+                    if (inUse[i16 + j]) {\n+                        bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\n+                    }\n+                    bsLiveShadow++;\n+                }\n+            }\n+        }\n+\n+        this.bsBuff = bsBuffShadow;\n+        this.bsLive = bsLiveShadow;\n+    }\n+\n+    private void sendMTFValues5(final int nGroups, final int nSelectors)\n+        throws IOException {\n+        bsW(3, nGroups);\n+        bsW(15, nSelectors);\n+\n+        final OutputStream outShadow = this.out;\n+        final byte[] selectorMtf = this.data.selectorMtf;\n+\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        for (int i = 0; i < nSelectors; i++) {\n+            for (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\n+                // inlined: bsW(1, 1);\n+                while (bsLiveShadow >= 8) {\n+                    outShadow.write(bsBuffShadow >> 24);\n+                    bsBuffShadow <<= 8;\n+                    bsLiveShadow -= 8;\n+                }\n+                bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\n+                bsLiveShadow++;\n+            }\n+\n+            // inlined: bsW(1, 0);\n+            while (bsLiveShadow >= 8) {\n+                outShadow.write(bsBuffShadow >> 24);\n+                bsBuffShadow <<= 8;\n+                bsLiveShadow -= 8;\n+            }\n+            // bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\n+            bsLiveShadow++;\n+        }\n+\n+        this.bsBuff = bsBuffShadow;\n+        this.bsLive = bsLiveShadow;\n+    }\n+\n+    private void sendMTFValues6(final int nGroups, final int alphaSize)\n+        throws IOException {\n+        final byte[][] len = this.data.sendMTFValues_len;\n+        final OutputStream outShadow = this.out;\n+\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        for (int t = 0; t < nGroups; t++) {\n+            byte[] len_t = len[t];\n+            int curr = len_t[0] & 0xff;\n+\n+            // inlined: bsW(5, curr);\n+            while (bsLiveShadow >= 8) {\n+                outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+                bsBuffShadow <<= 8;\n+                bsLiveShadow -= 8;\n+            }\n+            bsBuffShadow |= curr << (32 - bsLiveShadow - 5);\n+            bsLiveShadow += 5;\n+\n+            for (int i = 0; i < alphaSize; i++) {\n+                int lti = len_t[i] & 0xff;\n+                while (curr < lti) {\n+                    // inlined: bsW(2, 2);\n+                    while (bsLiveShadow >= 8) {\n+                        outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+                        bsBuffShadow <<= 8;\n+                        bsLiveShadow -= 8;\n+                    }\n+                    bsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\n+                    bsLiveShadow += 2;\n+\n                     curr++; /* 10 */\n                 }\n-                while (curr > len[t][i]) {\n-                    bsW(2, 3);\n+\n+                while (curr > lti) {\n+                    // inlined: bsW(2, 3);\n+                    while (bsLiveShadow >= 8) {\n+                        outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+                        bsBuffShadow <<= 8;\n+                        bsLiveShadow -= 8;\n+                    }\n+                    bsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\n+                    bsLiveShadow += 2;\n+\n                     curr--; /* 11 */\n                 }\n-                bsW (1, 0);\n-            }\n-        }\n-\n-        /* And finally, the block data proper */\n-        //nBytes = bytesOut;\n-        selCtr = 0;\n-        gs = 0;\n-        while (true) {\n-            if (gs >= nMTF) {\n-                break;\n-            }\n-            ge = gs + G_SIZE - 1;\n-            if (ge >= nMTF) {\n-                ge = nMTF - 1;\n-            }\n-            for (i = gs; i <= ge; i++) {\n-                bsW(len[selector[selCtr]][szptr[i]],\n-                    code[selector[selCtr]][szptr[i]]);\n+\n+                // inlined: bsW(1, 0);\n+                while (bsLiveShadow >= 8) {\n+                    outShadow.write(bsBuffShadow >> 24); // write 8-bit\n+                    bsBuffShadow <<= 8;\n+                    bsLiveShadow -= 8;\n+                }\n+                // bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\n+                bsLiveShadow++;\n+            }\n+        }\n+\n+        this.bsBuff = bsBuffShadow;\n+        this.bsLive = bsLiveShadow;\n+    }\n+\n+    private void sendMTFValues7(final int nSelectors) throws IOException {\n+        final Data dataShadow = this.data;\n+        final byte[][] len = dataShadow.sendMTFValues_len;\n+        final int[][] code = dataShadow.sendMTFValues_code;\n+        final OutputStream outShadow = this.out;\n+        final byte[] selector = dataShadow.selector;\n+        final char[] sfmap = dataShadow.sfmap;\n+        final int nMTFShadow = this.nMTF;\n+\n+        int selCtr = 0;\n+\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        for (int gs = 0; gs < nMTFShadow;) {\n+            final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\n+            final int selector_selCtr = selector[selCtr] & 0xff;\n+            final int[] code_selCtr = code[selector_selCtr];\n+            final byte[] len_selCtr = len[selector_selCtr];\n+\n+            while (gs <= ge) {\n+                final int sfmap_i = sfmap[gs];\n+\n+                //\n+                // inlined: bsW(len_selCtr[sfmap_i] & 0xff,\n+                // code_selCtr[sfmap_i]);\n+                //\n+                while (bsLiveShadow >= 8) {\n+                    outShadow.write(bsBuffShadow >> 24);\n+                    bsBuffShadow <<= 8;\n+                    bsLiveShadow -= 8;\n+                }\n+                final int n = len_selCtr[sfmap_i] & 0xFF;\n+                bsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\n+                bsLiveShadow += n;\n+\n+                gs++;\n             }\n \n             gs = ge + 1;\n             selCtr++;\n         }\n-        if (!(selCtr == nSelectors)) {\n-            panic();\n-        }\n-    }\n-\n-    private void moveToFrontCodeAndSend () throws IOException {\n-        bsPutIntVS(24, origPtr);\n+\n+        this.bsBuff = bsBuffShadow;\n+        this.bsLive = bsLiveShadow;\n+    }\n+\n+    private void moveToFrontCodeAndSend() throws IOException {\n+        bsW(24, this.origPtr);\n         generateMTFValues();\n         sendMTFValues();\n     }\n \n-    private OutputStream bsStream;\n-\n-    private void simpleSort(int lo, int hi, int d) {\n-        int i, j, h, bigN, hp;\n-        int v;\n-\n-        bigN = hi - lo + 1;\n+    /**\n+     * This is the most hammered method of this class.\n+     *\n+     * <p>\n+     * This is the version using unrolled loops. Normally I never use such ones\n+     * in Java code. The unrolling has shown a noticable performance improvement\n+     * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the\n+     * JIT compiler of the vm.\n+     * </p>\n+     */\n+    private boolean mainSimpleSort(final Data dataShadow, final int lo,\n+                                   final int hi, final int d) {\n+        final int bigN = hi - lo + 1;\n         if (bigN < 2) {\n-            return;\n-        }\n-\n-        hp = 0;\n-        while (incs[hp] < bigN) {\n+            return this.firstAttempt && (this.workDone > this.workLimit);\n+        }\n+\n+        int hp = 0;\n+        while (INCS[hp] < bigN) {\n             hp++;\n         }\n-        hp--;\n-\n-        for (; hp >= 0; hp--) {\n-            h = incs[hp];\n-\n-            i = lo + h;\n-            while (true) {\n-                /* copy 1 */\n-                if (i > hi) {\n-                    break;\n-                }\n-                v = zptr[i];\n-                j = i;\n-                while (fullGtU(zptr[j - h] + d, v + d)) {\n-                    zptr[j] = zptr[j - h];\n-                    j = j - h;\n-                    if (j <= (lo + h - 1)) {\n+\n+        final int[] fmap = dataShadow.fmap;\n+        final char[] quadrant = dataShadow.quadrant;\n+        final byte[] block = dataShadow.block;\n+        final int lastShadow = this.last;\n+        final int lastPlus1 = lastShadow + 1;\n+        final boolean firstAttemptShadow = this.firstAttempt;\n+        final int workLimitShadow = this.workLimit;\n+        int workDoneShadow = this.workDone;\n+\n+        // Following block contains unrolled code which could be shortened by\n+        // coding it in additional loops.\n+\n+        HP: while (--hp >= 0) {\n+            final int h = INCS[hp];\n+            final int mj = lo + h - 1;\n+\n+            for (int i = lo + h; i <= hi;) {\n+                // copy\n+                for (int k = 3; (i <= hi) && (--k >= 0); i++) {\n+                    final int v = fmap[i];\n+                    final int vd = v + d;\n+                    int j = i;\n+\n+                    // for (int a;\n+                    // (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,\n+                    // block, quadrant, lastShadow);\n+                    // j -= h) {\n+                    // fmap[j] = a;\n+                    // }\n+                    //\n+                    // unrolled version:\n+\n+                    // start inline mainGTU\n+                    boolean onceRunned = false;\n+                    int a = 0;\n+\n+                    HAMMER: while (true) {\n+                        if (onceRunned) {\n+                            fmap[j] = a;\n+                            if ((j -= h) <= mj) {\n+                                break HAMMER;\n+                            }\n+                        } else {\n+                            onceRunned = true;\n+                        }\n+\n+                        a = fmap[j - h];\n+                        int i1 = a + d;\n+                        int i2 = vd;\n+\n+                        // following could be done in a loop, but\n+                        // unrolled it for performance:\n+                        if (block[i1 + 1] == block[i2 + 1]) {\n+                            if (block[i1 + 2] == block[i2 + 2]) {\n+                                if (block[i1 + 3] == block[i2 + 3]) {\n+                                    if (block[i1 + 4] == block[i2 + 4]) {\n+                                        if (block[i1 + 5] == block[i2 + 5]) {\n+                                            if (block[(i1 += 6)] == block[(i2 += 6)]) {\n+                                                int x = lastShadow;\n+                                                X: while (x > 0) {\n+                                                    x -= 4;\n+\n+                                                    if (block[i1 + 1] == block[i2 + 1]) {\n+                                                        if (quadrant[i1] == quadrant[i2]) {\n+                                                            if (block[i1 + 2] == block[i2 + 2]) {\n+                                                                if (quadrant[i1 + 1] == quadrant[i2 + 1]) {\n+                                                                    if (block[i1 + 3] == block[i2 + 3]) {\n+                                                                        if (quadrant[i1 + 2] == quadrant[i2 + 2]) {\n+                                                                            if (block[i1 + 4] == block[i2 + 4]) {\n+                                                                                if (quadrant[i1 + 3] == quadrant[i2 + 3]) {\n+                                                                                    if ((i1 += 4) >= lastPlus1) {\n+                                                                                        i1 -= lastPlus1;\n+                                                                                    }\n+                                                                                    if ((i2 += 4) >= lastPlus1) {\n+                                                                                        i2 -= lastPlus1;\n+                                                                                    }\n+                                                                                    workDoneShadow++;\n+                                                                                    continue X;\n+                                                                                } else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {\n+                                                                                    continue HAMMER;\n+                                                                                } else {\n+                                                                                    break HAMMER;\n+                                                                                }\n+                                                                            } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n+                                                                                continue HAMMER;\n+                                                                            } else {\n+                                                                                break HAMMER;\n+                                                                            }\n+                                                                        } else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {\n+                                                                            continue HAMMER;\n+                                                                        } else {\n+                                                                            break HAMMER;\n+                                                                        }\n+                                                                    } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n+                                                                        continue HAMMER;\n+                                                                    } else {\n+                                                                        break HAMMER;\n+                                                                    }\n+                                                                } else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {\n+                                                                    continue HAMMER;\n+                                                                } else {\n+                                                                    break HAMMER;\n+                                                                }\n+                                                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n+                                                                continue HAMMER;\n+                                                            } else {\n+                                                                break HAMMER;\n+                                                            }\n+                                                        } else if ((quadrant[i1] > quadrant[i2])) {\n+                                                            continue HAMMER;\n+                                                        } else {\n+                                                            break HAMMER;\n+                                                        }\n+                                                    } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n+                                                        continue HAMMER;\n+                                                    } else {\n+                                                        break HAMMER;\n+                                                    }\n+\n+                                                }\n+                                                break HAMMER;\n+                                            } // while x > 0\n+                                            else {\n+                                                if ((block[i1] & 0xff) > (block[i2] & 0xff)) {\n+                                                    continue HAMMER;\n+                                                } else {\n+                                                    break HAMMER;\n+                                                }\n+                                            }\n+                                        } else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {\n+                                            continue HAMMER;\n+                                        } else {\n+                                            break HAMMER;\n+                                        }\n+                                    } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {\n+                                        continue HAMMER;\n+                                    } else {\n+                                        break HAMMER;\n+                                    }\n+                                } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {\n+                                    continue HAMMER;\n+                                } else {\n+                                    break HAMMER;\n+                                }\n+                            } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {\n+                                continue HAMMER;\n+                            } else {\n+                                break HAMMER;\n+                            }\n+                        } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {\n+                            continue HAMMER;\n+                        } else {\n+                            break HAMMER;\n+                        }\n+\n+                    } // HAMMER\n+                    // end inline mainGTU\n+\n+                    fmap[j] = v;\n+                }\n+\n+                if (firstAttemptShadow && (i <= hi)\n+                    && (workDoneShadow > workLimitShadow)) {\n+                    break HP;\n+                }\n+            }\n+        }\n+\n+        this.workDone = workDoneShadow;\n+        return firstAttemptShadow && (workDoneShadow > workLimitShadow);\n+    }\n+\n+    private static void vswap(int[] fmap, int p1, int p2, int n) {\n+        n += p1;\n+        while (p1 < n) {\n+            int t = fmap[p1];\n+            fmap[p1++] = fmap[p2];\n+            fmap[p2++] = t;\n+        }\n+    }\n+\n+    private static byte med3(byte a, byte b, byte c) {\n+        return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n+                                                        : a);\n+    }\n+\n+    private void blockSort() {\n+        this.workLimit = WORK_FACTOR * this.last;\n+        this.workDone = 0;\n+        this.blockRandomised = false;\n+        this.firstAttempt = true;\n+        mainSort();\n+\n+        if (this.firstAttempt && (this.workDone > this.workLimit)) {\n+            randomiseBlock();\n+            this.workLimit = this.workDone = 0;\n+            this.firstAttempt = false;\n+            mainSort();\n+        }\n+\n+        int[] fmap = this.data.fmap;\n+        this.origPtr = -1;\n+        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\n+            if (fmap[i] == 0) {\n+                this.origPtr = i;\n+                break;\n+            }\n+        }\n+\n+        // assert (this.origPtr != -1) : this.origPtr;\n+    }\n+\n+    /**\n+     * Method \"mainQSort3\", file \"blocksort.c\", BZip2 1.0.2\n+     */\n+    private void mainQSort3(final Data dataShadow, final int loSt,\n+                            final int hiSt, final int dSt) {\n+        final int[] stack_ll = dataShadow.stack_ll;\n+        final int[] stack_hh = dataShadow.stack_hh;\n+        final int[] stack_dd = dataShadow.stack_dd;\n+        final int[] fmap = dataShadow.fmap;\n+        final byte[] block = dataShadow.block;\n+\n+        stack_ll[0] = loSt;\n+        stack_hh[0] = hiSt;\n+        stack_dd[0] = dSt;\n+\n+        for (int sp = 1; --sp >= 0;) {\n+            final int lo = stack_ll[sp];\n+            final int hi = stack_hh[sp];\n+            final int d = stack_dd[sp];\n+\n+            if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {\n+                if (mainSimpleSort(dataShadow, lo, hi, d)) {\n+                    return;\n+                }\n+            } else {\n+                final int d1 = d + 1;\n+                final int med = med3(block[fmap[lo] + d1],\n+                                     block[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;\n+\n+                int unLo = lo;\n+                int unHi = hi;\n+                int ltLo = lo;\n+                int gtHi = hi;\n+\n+                while (true) {\n+                    while (unLo <= unHi) {\n+                        final int n = ((int) block[fmap[unLo] + d1] & 0xff)\n+                            - med;\n+                        if (n == 0) {\n+                            final int temp = fmap[unLo];\n+                            fmap[unLo++] = fmap[ltLo];\n+                            fmap[ltLo++] = temp;\n+                        } else if (n < 0) {\n+                            unLo++;\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+\n+                    while (unLo <= unHi) {\n+                        final int n = ((int) block[fmap[unHi] + d1] & 0xff)\n+                            - med;\n+                        if (n == 0) {\n+                            final int temp = fmap[unHi];\n+                            fmap[unHi--] = fmap[gtHi];\n+                            fmap[gtHi--] = temp;\n+                        } else if (n > 0) {\n+                            unHi--;\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+\n+                    if (unLo <= unHi) {\n+                        final int temp = fmap[unLo];\n+                        fmap[unLo++] = fmap[unHi];\n+                        fmap[unHi--] = temp;\n+                    } else {\n                         break;\n                     }\n                 }\n-                zptr[j] = v;\n-                i++;\n-\n-                /* copy 2 */\n-                if (i > hi) {\n-                    break;\n-                }\n-                v = zptr[i];\n-                j = i;\n-                while (fullGtU(zptr[j - h] + d, v + d)) {\n-                    zptr[j] = zptr[j - h];\n-                    j = j - h;\n-                    if (j <= (lo + h - 1)) {\n+\n+                if (gtHi < ltLo) {\n+                    stack_ll[sp] = lo;\n+                    stack_hh[sp] = hi;\n+                    stack_dd[sp] = d1;\n+                    sp++;\n+                } else {\n+                    int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)\n+                        : (unLo - ltLo);\n+                    vswap(fmap, lo, unLo - n, n);\n+                    int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)\n+                        : (gtHi - unHi);\n+                    vswap(fmap, unLo, hi - m + 1, m);\n+\n+                    n = lo + unLo - ltLo - 1;\n+                    m = hi - (gtHi - unHi) + 1;\n+\n+                    stack_ll[sp] = lo;\n+                    stack_hh[sp] = n;\n+                    stack_dd[sp] = d;\n+                    sp++;\n+\n+                    stack_ll[sp] = n + 1;\n+                    stack_hh[sp] = m - 1;\n+                    stack_dd[sp] = d1;\n+                    sp++;\n+\n+                    stack_ll[sp] = m;\n+                    stack_hh[sp] = hi;\n+                    stack_dd[sp] = d;\n+                    sp++;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void mainSort() {\n+        final Data dataShadow = this.data;\n+        final int[] runningOrder = dataShadow.mainSort_runningOrder;\n+        final int[] copy = dataShadow.mainSort_copy;\n+        final boolean[] bigDone = dataShadow.mainSort_bigDone;\n+        final int[] ftab = dataShadow.ftab;\n+        final byte[] block = dataShadow.block;\n+        final int[] fmap = dataShadow.fmap;\n+        final char[] quadrant = dataShadow.quadrant;\n+        final int lastShadow = this.last;\n+        final int workLimitShadow = this.workLimit;\n+        final boolean firstAttemptShadow = this.firstAttempt;\n+\n+        // Set up the 2-byte frequency table\n+        for (int i = 65537; --i >= 0;) {\n+            ftab[i] = 0;\n+        }\n+\n+        /*\n+         * In the various block-sized structures, live data runs from 0 to\n+         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n+         * for block.\n+         */\n+        for (int i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\n+            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n+        }\n+        for (int i = lastShadow + NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\n+            quadrant[i] = 0;\n+        }\n+        block[0] = block[lastShadow + 1];\n+\n+        // Complete the initial radix sort:\n+\n+        int c1 = block[0] & 0xff;\n+        for (int i = 0; i <= lastShadow; i++) {\n+            final int c2 = block[i + 1] & 0xff;\n+            ftab[(c1 << 8) + c2]++;\n+            c1 = c2;\n+        }\n+\n+        for (int i = 1; i <= 65536; i++)\n+            ftab[i] += ftab[i - 1];\n+\n+        c1 = block[1] & 0xff;\n+        for (int i = 0; i < lastShadow; i++) {\n+            final int c2 = block[i + 2] & 0xff;\n+            fmap[--ftab[(c1 << 8) + c2]] = i;\n+            c1 = c2;\n+        }\n+\n+        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n+\n+        /*\n+         * Now ftab contains the first loc of every small bucket. Calculate the\n+         * running order, from smallest to largest big bucket.\n+         */\n+        for (int i = 256; --i >= 0;) {\n+            bigDone[i] = false;\n+            runningOrder[i] = i;\n+        }\n+\n+        for (int h = 364; h != 1;) {\n+            h /= 3;\n+            for (int i = h; i <= 255; i++) {\n+                final int vv = runningOrder[i];\n+                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n+                final int b = h - 1;\n+                int j = i;\n+                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n+                                                                                                                - h]) {\n+                    runningOrder[j] = ro;\n+                    j -= h;\n+                    if (j <= b) {\n                         break;\n                     }\n                 }\n-                zptr[j] = v;\n-                i++;\n-\n-                /* copy 3 */\n-                if (i > hi) {\n-                    break;\n-                }\n-                v = zptr[i];\n-                j = i;\n-                while (fullGtU(zptr[j - h] + d, v + d)) {\n-                    zptr[j] = zptr[j - h];\n-                    j = j - h;\n-                    if (j <= (lo + h - 1)) {\n-                        break;\n-                    }\n-                }\n-                zptr[j] = v;\n-                i++;\n-\n-                if (workDone > workLimit && firstAttempt) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    private void vswap(int p1, int p2, int n) {\n-        int temp = 0;\n-        while (n > 0) {\n-            temp = zptr[p1];\n-            zptr[p1] = zptr[p2];\n-            zptr[p2] = temp;\n-            p1++;\n-            p2++;\n-            n--;\n-        }\n-    }\n-\n-    private char med3(char a, char b, char c) {\n-        char t;\n-        if (a > b) {\n-            t = a;\n-            a = b;\n-            b = t;\n-        }\n-        if (b > c) {\n-            b = c;\n-        }\n-        if (a > b) {\n-            b = a;\n-        }\n-        return b;\n-    }\n-\n-    private static class StackElem {\n-        int ll;\n-        int hh;\n-        int dd;\n-    }\n-\n-    private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack) {\n-        int unLo, unHi, ltLo, gtHi, med, n, m;\n-        int sp, lo, hi, d;\n-\n-        sp = 0;\n-\n-        stack[sp].ll = loSt;\n-        stack[sp].hh = hiSt;\n-        stack[sp].dd = dSt;\n-        sp++;\n-\n-        while (sp > 0) {\n-            if (sp >= QSORT_STACK_SIZE) {\n-                panic();\n-            }\n-\n-            sp--;\n-            lo = stack[sp].ll;\n-            hi = stack[sp].hh;\n-            d = stack[sp].dd;\n-\n-            if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {\n-                simpleSort(lo, hi, d);\n-                if (workDone > workLimit && firstAttempt) {\n-                    return;\n-                }\n-                continue;\n-            }\n-\n-            med = med3(block[zptr[lo] + d + 1],\n-                       block[zptr[hi            ] + d  + 1],\n-                       block[zptr[(lo + hi) >>> 1] + d + 1]);\n-\n-            unLo = ltLo = lo;\n-            unHi = gtHi = hi;\n-\n-            while (true) {\n-                while (true) {\n-                    if (unLo > unHi) {\n-                        break;\n-                    }\n-                    n = block[zptr[unLo] + d + 1] - med;\n-                    if (n == 0) {\n-                        int temp = 0;\n-                        temp = zptr[unLo];\n-                        zptr[unLo] = zptr[ltLo];\n-                        zptr[ltLo] = temp;\n-                        ltLo++;\n-                        unLo++;\n-                        continue;\n-                    }\n-                    if (n >  0) {\n-                        break;\n-                    }\n-                    unLo++;\n-                }\n-                while (true) {\n-                    if (unLo > unHi) {\n-                        break;\n-                    }\n-                    n = block[zptr[unHi] + d + 1] - med;\n-                    if (n == 0) {\n-                        int temp = 0;\n-                        temp = zptr[unHi];\n-                        zptr[unHi] = zptr[gtHi];\n-                        zptr[gtHi] = temp;\n-                        gtHi--;\n-                        unHi--;\n-                        continue;\n-                    }\n-                    if (n <  0) {\n-                        break;\n-                    }\n-                    unHi--;\n-                }\n-                if (unLo > unHi) {\n-                    break;\n-                }\n-                int temp = 0;\n-                temp = zptr[unLo];\n-                zptr[unLo] = zptr[unHi];\n-                zptr[unHi] = temp;\n-                unLo++;\n-                unHi--;\n-            }\n-\n-            if (gtHi < ltLo) {\n-                stack[sp].ll = lo;\n-                stack[sp].hh = hi;\n-                stack[sp].dd = d + 1;\n-                sp++;\n-                continue;\n-            }\n-\n-            n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);\n-            vswap(lo, unLo - n, n);\n-            m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);\n-            vswap(unLo, hi - m + 1, m);\n-\n-            n = lo + unLo - ltLo - 1;\n-            m = hi - (gtHi - unHi) + 1;\n-\n-            stack[sp].ll = lo;\n-            stack[sp].hh = n;\n-            stack[sp].dd = d;\n-            sp++;\n-\n-            stack[sp].ll = n + 1;\n-            stack[sp].hh = m - 1;\n-            stack[sp].dd = d + 1;\n-            sp++;\n-\n-            stack[sp].ll = m;\n-            stack[sp].hh = hi;\n-            stack[sp].dd = d;\n-            sp++;\n-        }\n-    }\n-\n-    private void mainSort() {\n-        int i, j, ss, sb;\n-        int[] runningOrder = new int[256];\n-        int[] copy = new int[256];\n-        boolean[] bigDone = new boolean[256];\n-        int c1, c2;\n-        int numQSorted;\n+                runningOrder[j] = vv;\n+            }\n+        }\n \n         /*\n-          In the various block-sized structures, live data runs\n-          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n-          set up the overshoot area for block.\n-        */\n-\n-        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n-\n-        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\n-            block[last + i + 2] = block[(i % (last + 1)) + 1];\n-        }\n-        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n-            quadrant[i] = 0;\n-        }\n-\n-        block[0] = block[last + 1];\n-\n-        if (last < 4000) {\n+         * The main sorting loop.\n+         */\n+        for (int i = 0; i <= 255; i++) {\n             /*\n-              Use simpleSort(), since the full sorting mechanism\n-              has quite a large constant overhead.\n-            */\n-            for (i = 0; i <= last; i++) {\n-                zptr[i] = i;\n-            }\n-            firstAttempt = false;\n-            workDone = workLimit = 0;\n-            simpleSort(0, last, 0);\n-        } else {\n-            numQSorted = 0;\n-            for (i = 0; i <= 255; i++) {\n-                bigDone[i] = false;\n-            }\n-\n-            for (i = 0; i <= 65536; i++) {\n-                ftab[i] = 0;\n-            }\n-\n-            c1 = block[0];\n-            for (i = 0; i <= last; i++) {\n-                c2 = block[i + 1];\n-                ftab[(c1 << 8) + c2]++;\n-                c1 = c2;\n-            }\n-\n-            for (i = 1; i <= 65536; i++) {\n-                ftab[i] += ftab[i - 1];\n-            }\n-\n-            c1 = block[1];\n-            for (i = 0; i < last; i++) {\n-                c2 = block[i + 2];\n-                j = (c1 << 8) + c2;\n-                c1 = c2;\n-                ftab[j]--;\n-                zptr[ftab[j]] = i;\n-            }\n-\n-            j = ((block[last + 1]) << 8) + (block[1]);\n-            ftab[j]--;\n-            zptr[ftab[j]] = last;\n-\n+             * Process big buckets, starting with the least full.\n+             */\n+            final int ss = runningOrder[i];\n+\n+            // Step 1:\n             /*\n-              Now ftab contains the first loc of every small bucket.\n-              Calculate the running order, from smallest to largest\n-              big bucket.\n-            */\n-\n-            for (i = 0; i <= 255; i++) {\n-                runningOrder[i] = i;\n-            }\n-\n-            {\n-                int vv;\n-                int h = 1;\n-                do {\n-                    h = 3 * h + 1;\n-                }\n-                while (h <= 256);\n-                do {\n-                    h = h / 3;\n-                    for (i = h; i <= 255; i++) {\n-                        vv = runningOrder[i];\n-                        j = i;\n-                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n-                                - ftab[(runningOrder[j - h]) << 8])\n-                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n-                            runningOrder[j] = runningOrder[j - h];\n-                            j = j - h;\n-                            if (j <= (h - 1)) {\n-                                break;\n-                            }\n+             * Complete the big bucket [ss] by quicksorting any unsorted small\n+             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n+             * already completed many of the small buckets [ss, j], so we don't\n+             * have to sort them at all.\n+             */\n+            for (int j = 0; j <= 255; j++) {\n+                final int sb = (ss << 8) + j;\n+                final int ftab_sb = ftab[sb];\n+                if ((ftab_sb & SETMASK) != SETMASK) {\n+                    final int lo = ftab_sb & CLEARMASK;\n+                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n+                    if (hi > lo) {\n+                        mainQSort3(dataShadow, lo, hi, 2);\n+                        if (firstAttemptShadow\n+                            && (this.workDone > workLimitShadow)) {\n+                            return;\n                         }\n-                        runningOrder[j] = vv;\n-                    }\n-                } while (h != 1);\n-            }\n-\n-            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n-            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n-                stack[count] = new StackElem();\n-            }\n-\n+                    }\n+                    ftab[sb] = ftab_sb | SETMASK;\n+                }\n+            }\n+\n+            // Step 2:\n+            // Now scan this big bucket so as to synthesise the\n+            // sorted order for small buckets [t, ss] for all t != ss.\n+\n+            for (int j = 0; j <= 255; j++) {\n+                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n+            }\n+\n+            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n+                final int fmap_j = fmap[j];\n+                c1 = block[fmap_j] & 0xff;\n+                if (!bigDone[c1]) {\n+                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n+                    copy[c1]++;\n+                }\n+            }\n+\n+            for (int j = 256; --j >= 0;)\n+                ftab[(j << 8) + ss] |= SETMASK;\n+\n+            // Step 3:\n             /*\n-              The main sorting loop.\n-            */\n-            for (i = 0; i <= 255; i++) {\n-\n-                /*\n-                  Process big buckets, starting with the least full.\n-                */\n-                ss = runningOrder[i];\n-\n-                /*\n-                  Complete the big bucket [ss] by quicksorting\n-                  any unsorted small buckets [ss, j].  Hopefully\n-                  previous pointer-scanning phases have already\n-                  completed many of the small buckets [ss, j], so\n-                  we don't have to sort them at all.\n-                */\n-                for (j = 0; j <= 255; j++) {\n-                    sb = (ss << 8) + j;\n-                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n-                        int lo = ftab[sb] & CLEARMASK;\n-                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n-                        if (hi > lo) {\n-                            qSort3(lo, hi, 2, stack);\n-                            numQSorted += (hi - lo + 1);\n-                            if (workDone > workLimit && firstAttempt) {\n-                                return;\n-                            }\n-                        }\n-                        ftab[sb] |= SETMASK;\n-                    }\n-                }\n-\n-                /*\n-                  The ss big bucket is now done.  Record this fact,\n-                  and update the quadrant descriptors.  Remember to\n-                  update quadrants in the overshoot area too, if\n-                  necessary.  The \"if (i < 255)\" test merely skips\n-                  this updating for the last bucket processed, since\n-                  updating for the last bucket is pointless.\n-                */\n-                bigDone[ss] = true;\n-\n-                if (i < 255) {\n-                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n-                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n-                    int shifts   = 0;\n-\n-                    while ((bbSize >> shifts) > 65534) {\n-                        shifts++;\n-                    }\n-\n-                    for (j = 0; j < bbSize; j++) {\n-                        int a2update = zptr[bbStart + j];\n-                        int qVal = (j >> shifts);\n-                        quadrant[a2update] = qVal;\n-                        if (a2update < NUM_OVERSHOOT_BYTES) {\n-                            quadrant[a2update + last + 1] = qVal;\n-                        }\n-                    }\n-\n-                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n-                        panic();\n-                    }\n-                }\n-\n-                /*\n-                  Now scan this big bucket so as to synthesise the\n-                  sorted order for small buckets [t, ss] for all t != ss.\n-                */\n-                for (j = 0; j <= 255; j++) {\n-                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n-                }\n-\n-                for (j = ftab[ss << 8] & CLEARMASK;\n-                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n-                    c1 = block[zptr[j]];\n-                    if (!bigDone[c1]) {\n-                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n-                        copy[c1]++;\n-                    }\n-                }\n-\n-                for (j = 0; j <= 255; j++) {\n-                    ftab[(j << 8) + ss] |= SETMASK;\n-                }\n-            }\n+             * The ss big bucket is now done. Record this fact, and update the\n+             * quadrant descriptors. Remember to update quadrants in the\n+             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n+             * skips this updating for the last bucket processed, since updating\n+             * for the last bucket is pointless.\n+             */\n+            bigDone[ss] = true;\n+\n+            if (i < 255) {\n+                final int bbStart = ftab[ss << 8] & CLEARMASK;\n+                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n+                int shifts = 0;\n+\n+                while ((bbSize >> shifts) > 65534) {\n+                    shifts++;\n+                }\n+\n+                for (int j = 0; j < bbSize; j++) {\n+                    final int a2update = fmap[bbStart + j];\n+                    final char qVal = (char) (j >> shifts);\n+                    quadrant[a2update] = qVal;\n+                    if (a2update < NUM_OVERSHOOT_BYTES) {\n+                        quadrant[a2update + lastShadow + 1] = qVal;\n+                    }\n+                }\n+            }\n+\n         }\n     }\n \n     private void randomiseBlock() {\n-        int i;\n+        final boolean[] inUse = this.data.inUse;\n+        final byte[] block = this.data.block;\n+        final int lastShadow = this.last;\n+\n+        for (int i = 256; --i >= 0;)\n+            inUse[i] = false;\n+\n         int rNToGo = 0;\n-        int rTPos  = 0;\n-        for (i = 0; i < 256; i++) {\n-            inUse[i] = false;\n-        }\n-\n-        for (i = 0; i <= last; i++) {\n+        int rTPos = 0;\n+        for (int i = 0, j = 1; i <= lastShadow; i = j, j++) {\n             if (rNToGo == 0) {\n-                rNToGo = (char) rNums[rTPos];\n-                rTPos++;\n-                if (rTPos == 512) {\n+                rNToGo = (char) BZip2Constants.rNums[rTPos];\n+                if (++rTPos == 512) {\n                     rTPos = 0;\n                 }\n             }\n+\n             rNToGo--;\n-            block[i + 1] ^= ((rNToGo == 1) ? 1 : 0);\n+            block[j] ^= ((rNToGo == 1) ? 1 : 0);\n+\n             // handle 16 bit signed numbers\n-            block[i + 1] &= 0xFF;\n-\n-            inUse[block[i + 1]] = true;\n-        }\n-    }\n-\n-    private void doReversibleTransformation() {\n-        int i;\n-\n-        workLimit = workFactor * last;\n-        workDone = 0;\n-        blockRandomised = false;\n-        firstAttempt = true;\n-\n-        mainSort();\n-\n-        if (workDone > workLimit && firstAttempt) {\n-            randomiseBlock();\n-            workLimit = workDone = 0;\n-            blockRandomised = true;\n-            firstAttempt = false;\n-            mainSort();\n-        }\n-\n-        origPtr = -1;\n-        for (i = 0; i <= last; i++) {\n-            if (zptr[i] == 0) {\n-                origPtr = i;\n-                break;\n-            }\n-        }\n-\n-        if (origPtr == -1) {\n-            panic();\n-        }\n-    }\n-\n-    private boolean fullGtU(int i1, int i2) {\n-        int k;\n-        char c1, c2;\n-        int s1, s2;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        c1 = block[i1 + 1];\n-        c2 = block[i2 + 1];\n-        if (c1 != c2) {\n-            return (c1 > c2);\n-        }\n-        i1++;\n-        i2++;\n-\n-        k = last + 1;\n-\n-        do {\n-            c1 = block[i1 + 1];\n-            c2 = block[i2 + 1];\n-            if (c1 != c2) {\n-                return (c1 > c2);\n-            }\n-            s1 = quadrant[i1];\n-            s2 = quadrant[i2];\n-            if (s1 != s2) {\n-                return (s1 > s2);\n-            }\n-            i1++;\n-            i2++;\n-\n-            c1 = block[i1 + 1];\n-            c2 = block[i2 + 1];\n-            if (c1 != c2) {\n-                return (c1 > c2);\n-            }\n-            s1 = quadrant[i1];\n-            s2 = quadrant[i2];\n-            if (s1 != s2) {\n-                return (s1 > s2);\n-            }\n-            i1++;\n-            i2++;\n-\n-            c1 = block[i1 + 1];\n-            c2 = block[i2 + 1];\n-            if (c1 != c2) {\n-                return (c1 > c2);\n-            }\n-            s1 = quadrant[i1];\n-            s2 = quadrant[i2];\n-            if (s1 != s2) {\n-                return (s1 > s2);\n-            }\n-            i1++;\n-            i2++;\n-\n-            c1 = block[i1 + 1];\n-            c2 = block[i2 + 1];\n-            if (c1 != c2) {\n-                return (c1 > c2);\n-            }\n-            s1 = quadrant[i1];\n-            s2 = quadrant[i2];\n-            if (s1 != s2) {\n-                return (s1 > s2);\n-            }\n-            i1++;\n-            i2++;\n-\n-            if (i1 > last) {\n-                i1 -= last;\n-                i1--;\n-            }\n-            if (i2 > last) {\n-                i2 -= last;\n-                i2--;\n-            }\n-\n-            k -= 4;\n-            workDone++;\n-        } while (k >= 0);\n-\n-        return false;\n-    }\n-\n-    /*\n-      Knuth's increments seem to work better\n-      than Incerpi-Sedgewick here.  Possibly\n-      because the number of elems to sort is\n-      usually small, typically <= 20.\n-    */\n-    private int[] incs = {1, 4, 13, 40, 121, 364, 1093, 3280,\n-                          9841, 29524, 88573, 265720,\n-                          797161, 2391484};\n-\n-    private void allocateCompressStructures () {\n-        int n = baseBlockSize * blockSize100k;\n-        block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)];\n-        quadrant = new int[(n + NUM_OVERSHOOT_BYTES)];\n-        zptr = new int[n];\n-        ftab = new int[65537];\n-\n-        if (block == null || quadrant == null || zptr == null\n-            || ftab == null) {\n-            //int totalDraw = (n + 1 + NUM_OVERSHOOT_BYTES) + (n + NUM_OVERSHOOT_BYTES) + n + 65537;\n-            //compressOutOfMemory ( totalDraw, n );\n-        }\n-\n-        /*\n-          The back end needs a place to store the MTF values\n-          whilst it calculates the coding tables.  We could\n-          put them in the zptr array.  However, these values\n-          will fit in a short, so we overlay szptr at the\n-          start of zptr, in the hope of reducing the number\n-          of cache misses induced by the multiple traversals\n-          of the MTF values when calculating coding tables.\n-          Seems to improve compression speed by about 1%.\n-        */\n-        //    szptr = zptr;\n-\n-\n-        szptr = new short[2 * n];\n+            inUse[block[j] & 0xff] = true;\n+        }\n+\n+        this.blockRandomised = true;\n     }\n \n     private void generateMTFValues() {\n-        char[] yy = new char[256];\n-        int  i, j;\n-        char tmp;\n-        char tmp2;\n-        int zPend;\n-        int wr;\n-        int EOB;\n-\n-        makeMaps();\n-        EOB = nInUse + 1;\n-\n-        for (i = 0; i <= EOB; i++) {\n+        final int lastShadow = this.last;\n+        final Data dataShadow = this.data;\n+        final boolean[] inUse = dataShadow.inUse;\n+        final byte[] block = dataShadow.block;\n+        final int[] fmap = dataShadow.fmap;\n+        final char[] sfmap = dataShadow.sfmap;\n+        final int[] mtfFreq = dataShadow.mtfFreq;\n+        final byte[] unseqToSeq = dataShadow.unseqToSeq;\n+        final byte[] yy = dataShadow.generateMTFValues_yy;\n+\n+        // make maps\n+        int nInUseShadow = 0;\n+        for (int i = 0; i < 256; i++) {\n+            if (inUse[i]) {\n+                unseqToSeq[i] = (byte) nInUseShadow;\n+                nInUseShadow++;\n+            }\n+        }\n+        this.nInUse = nInUseShadow;\n+\n+        final int eob = nInUseShadow + 1;\n+\n+        for (int i = eob; i >= 0; i--) {\n             mtfFreq[i] = 0;\n         }\n \n-        wr = 0;\n-        zPend = 0;\n-        for (i = 0; i < nInUse; i++) {\n-            yy[i] = (char) i;\n-        }\n-\n-\n-        for (i = 0; i <= last; i++) {\n-            char ll_i;\n-\n-            ll_i = unseqToSeq[block[zptr[i]]];\n-\n-            j = 0;\n-            tmp = yy[j];\n+        for (int i = nInUseShadow; --i >= 0;) {\n+            yy[i] = (byte) i;\n+        }\n+\n+        int wr = 0;\n+        int zPend = 0;\n+\n+        for (int i = 0; i <= lastShadow; i++) {\n+            final byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\n+            byte tmp = yy[0];\n+            int j = 0;\n+\n             while (ll_i != tmp) {\n                 j++;\n-                tmp2 = tmp;\n+                byte tmp2 = tmp;\n                 tmp = yy[j];\n                 yy[j] = tmp2;\n             }\n                 if (zPend > 0) {\n                     zPend--;\n                     while (true) {\n-                        switch (zPend % 2) {\n-                        case 0:\n-                            szptr[wr] = (short) RUNA;\n+                        if ((zPend & 1) == 0) {\n+                            sfmap[wr] = RUNA;\n                             wr++;\n                             mtfFreq[RUNA]++;\n-                            break;\n-                        case 1:\n-                            szptr[wr] = (short) RUNB;\n+                        } else {\n+                            sfmap[wr] = RUNB;\n                             wr++;\n                             mtfFreq[RUNB]++;\n+                        }\n+\n+                        if (zPend >= 2) {\n+                            zPend = (zPend - 2) >> 1;\n+                        } else {\n                             break;\n                         }\n-                        if (zPend < 2) {\n-                            break;\n-                        }\n-                        zPend = (zPend - 2) / 2;\n                     }\n                     zPend = 0;\n                 }\n-                szptr[wr] = (short) (j + 1);\n+                sfmap[wr] = (char) (j + 1);\n                 wr++;\n                 mtfFreq[j + 1]++;\n             }\n         if (zPend > 0) {\n             zPend--;\n             while (true) {\n-                switch (zPend % 2) {\n-                case 0:\n-                    szptr[wr] = (short) RUNA;\n+                if ((zPend & 1) == 0) {\n+                    sfmap[wr] = RUNA;\n                     wr++;\n                     mtfFreq[RUNA]++;\n-                    break;\n-                case 1:\n-                    szptr[wr] = (short) RUNB;\n+                } else {\n+                    sfmap[wr] = RUNB;\n                     wr++;\n                     mtfFreq[RUNB]++;\n+                }\n+\n+                if (zPend >= 2) {\n+                    zPend = (zPend - 2) >> 1;\n+                } else {\n                     break;\n                 }\n-                if (zPend < 2) {\n-                    break;\n-                }\n-                zPend = (zPend - 2) / 2;\n-            }\n-        }\n-\n-        szptr[wr] = (short) EOB;\n-        wr++;\n-        mtfFreq[EOB]++;\n-\n-        nMTF = wr;\n-    }\n+            }\n+        }\n+\n+        sfmap[wr] = (char) eob;\n+        mtfFreq[eob]++;\n+        this.nMTF = wr + 1;\n+    }\n+\n+    private static final class Data extends Object {\n+\n+        // with blockSize 900k\n+        final boolean[] inUse = new boolean[256]; // 256 byte\n+        final byte[] unseqToSeq = new byte[256]; // 256 byte\n+        final int[] mtfFreq = new int[MAX_ALPHA_SIZE]; // 1032 byte\n+        final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\n+        final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\n+\n+        final byte[] generateMTFValues_yy = new byte[256]; // 256 byte\n+        final byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE]; // 1548\n+        // byte\n+        final int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\n+        // byte\n+        final int[] sendMTFValues_fave = new int[N_GROUPS]; // 24 byte\n+        final short[] sendMTFValues_cost = new short[N_GROUPS]; // 12 byte\n+        final int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192\n+        // byte\n+        final byte[] sendMTFValues2_pos = new byte[N_GROUPS]; // 6 byte\n+        final boolean[] sentMTFValues4_inUse16 = new boolean[16]; // 16 byte\n+\n+        final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n+        final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n+        final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n+\n+        final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n+        final int[] mainSort_copy = new int[256]; // 1024 byte\n+        final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte\n+\n+        final int[] heap = new int[MAX_ALPHA_SIZE + 2]; // 1040 byte\n+        final int[] weight = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\n+        final int[] parent = new int[MAX_ALPHA_SIZE * 2]; // 2064 byte\n+\n+        final int[] ftab = new int[65537]; // 262148 byte\n+        // ------------\n+        // 333408 byte\n+\n+        final byte[] block; // 900021 byte\n+        final int[] fmap; // 3600000 byte\n+        final char[] sfmap; // 3600000 byte\n+        // ------------\n+        // 8433529 byte\n+        // ============\n+\n+        /**\n+         * Array instance identical to sfmap, both are used only\n+         * temporarily and indepently, so we do not need to allocate\n+         * additional memory.\n+         */\n+        final char[] quadrant;\n+\n+        Data(int blockSize100k) {\n+            super();\n+\n+            final int n = blockSize100k * BZip2Constants.baseBlockSize;\n+            this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\n+            this.fmap = new int[n];\n+            this.sfmap = new char[2 * n];\n+            this.quadrant = this.sfmap;\n+        }\n+\n+    }\n+\n }", "timestamp": 1238163247, "metainfo": ""}