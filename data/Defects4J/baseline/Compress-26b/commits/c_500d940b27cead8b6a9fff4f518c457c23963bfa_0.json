{"sha": "500d940b27cead8b6a9fff4f518c457c23963bfa", "log": "Move ZIP64 (integration) tests to a separate run-it profile as suggested by Mark Struberg  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.Random;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeNotNull;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class Zip64SupportIT {\n+\n+    private static final long FIVE_BILLION = 5000000000l;\n+    private static final int ONE_MILLION = 1000000;\n+    private static final int ONE_HUNDRED_THOUSAND = 100000;\n+\n+    @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n+        read5GBOfZerosImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read5GBOfZerosGeneratedBy7ZIPUsingInputStream()\n+        throws Throwable {\n+        read5GBOfZerosImpl(get5GBZerosFileGeneratedBy7ZIP(), \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read5GBOfZerosGeneratedByJava7JarUsingInputStream()\n+        throws Throwable {\n+        read5GBOfZerosImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read100KFilesUsingInputStream() throws Throwable {\n+        read100KFilesImpl(get100KFileFile());\n+    }\n+\n+    @Test public void read100KFilesGeneratedBy7ZIPUsingInputStream()\n+        throws Throwable {\n+        read100KFilesImpl(get100KFileFileGeneratedBy7ZIP());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByWinCFUsingInputStream()\n+        throws Throwable {\n+        read100KFilesImpl(get100KFileFileGeneratedByWinCF());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByJava7JarUsingInputStream()\n+        throws Throwable {\n+        read100KFilesImpl(get100KFileFileGeneratedByJava7Jar());\n+    }\n+\n+    @Test public void read5GBOfZerosUsingZipFile() throws Throwable {\n+        read5GBOfZerosUsingZipFileImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read5GBOfZerosGeneratedBy7ZIPUsingZipFile()\n+        throws Throwable {\n+        read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedBy7ZIP(),\n+                                       \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read5GBOfZerosGeneratedByJava7JarUsingZipFile()\n+        throws Throwable {\n+        read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedByJava7Jar(),\n+                                       \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read100KFilesUsingZipFile() throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFile());\n+    }\n+\n+    @Test public void read100KFilesGeneratedBy7ZIPUsingZipFile()\n+        throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedBy7ZIP());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByWinCFUsingZipFile()\n+        throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByWinCF());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByJava7JarUsingZipFile()\n+        throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByJava7Jar());\n+    }\n+\n+    private static ZipOutputTest write100KFiles() {\n+        return write100KFiles(Zip64Mode.AsNeeded);\n+    }\n+\n+    private static ZipOutputTest write100KFiles(final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                write100KFilesToStream(zos);\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = a.length();\n+\n+                    // validate \"end of central directory\" is at\n+                    // the end of the file and contains the magic\n+                    // value 0xFFFF as \"number of entries\".\n+                    a.seek(end\n+                           - 22 /* length of EOCD without file comment */);\n+                    byte[] eocd = new byte[12];\n+                    a.readFully(eocd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 5, 6,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // entries\n+                            (byte) 0xff, (byte) 0xff,\n+                            (byte) 0xff, (byte) 0xff,\n+                        }, eocd); \n+\n+                    // validate \"Zip64 end of central directory\n+                    // locator\" is right in front of the EOCD and\n+                    // the location of the \"Zip64 end of central\n+                    // directory record\" seems correct\n+                    long expectedZ64EocdOffset = end - 22 /* eocd.length */\n+                        - 20 /* z64 eocd locator.length */\n+                        - 56 /* z64 eocd without extensible data sector */;\n+                    byte[] loc =\n+                        ZipEightByteInteger.getBytes(expectedZ64EocdOffset);\n+                    a.seek(end - 22 - 20);\n+                    byte[] z64EocdLoc = new byte[20];\n+                    a.readFully(z64EocdLoc);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 7,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // location of Zip64 EOCD,\n+                            loc[0], loc[1], loc[2], loc[3],\n+                            loc[4], loc[5], loc[6], loc[7],\n+                            // total number of disks\n+                            1, 0, 0, 0,\n+                        }, z64EocdLoc);\n+\n+                    // validate \"Zip64 end of central directory\n+                    // record\" is where it is supposed to be, the\n+                    // known values are fine and read the location\n+                    // of the central directory from it\n+                    a.seek(expectedZ64EocdOffset);\n+                    byte[] z64EocdStart = new byte[40];\n+                    a.readFully(z64EocdStart);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 6,\n+                            // size of z64 EOCD\n+                            44, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // number of entries 100k = 0x186A0\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                        }, z64EocdStart);\n+                    a.seek(expectedZ64EocdOffset + 48 /* skip size */);\n+                    byte[] cdOffset = new byte[8];\n+                    a.readFully(cdOffset);\n+                    long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n+\n+                    // finally verify there really is a central\n+                    // directory entry where the Zip64 EOCD claims\n+                    a.seek(cdLoc);\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void write100KFilesFile() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesFile\", write100KFiles(), true);\n+    }\n+\n+    @Test public void write100KFilesStream() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesStream\", write100KFiles(), false);\n+    }\n+\n+    @Test public void write100KFilesFileModeAlways() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesFileModeAlways\",\n+                             write100KFiles(Zip64Mode.Always), true);\n+    }\n+\n+    @Test public void write100KFilesStreamModeAlways() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesStreamModeAlways\",\n+                             write100KFiles(Zip64Mode.Always), false);\n+    }\n+\n+    private static final ZipOutputTest write100KFilesModeNever =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    write100KFilesToStream(zos);\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertEquals(Zip64RequiredException.TOO_MANY_ENTRIES_MESSAGE,\n+                                 ex.getMessage());\n+                }\n+            }\n+        };\n+\n+    @Test public void write100KFilesFileModeNever() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesFileModeNever\",\n+                             write100KFilesModeNever, true);\n+    }\n+\n+    @Test public void write100KFilesStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesStreamModeNever\",\n+                             write100KFilesModeNever, false);\n+    }\n+\n+    @Test public void readSelfGenerated100KFilesUsingZipFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     write100KFilesToStream(zos);\n+                                     read100KFilesUsingZipFileImpl(f);\n+                                 }\n+                             },\n+                             true);\n+    }\n+\n+    private static ZipOutputTest write3EntriesCreatingBigArchive() {\n+        return write3EntriesCreatingBigArchive(Zip64Mode.AsNeeded);\n+    }\n+\n+    /*\n+     * Individual sizes don't require ZIP64 but the offset of the\n+     * third entry is bigger than 0xFFFFFFFF so a ZIP64 extended\n+     * information is needed inside the central directory.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */\n+    private static ZipOutputTest\n+        write3EntriesCreatingBigArchive(final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                write3EntriesCreatingBigArchiveToStream(zos);\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+                    // skip first two entries\n+                    a.skipBytes(2 * 47 /* CD entry of file with\n+                                          file name length 1 and no\n+                                          extra data */);\n+\n+                    // grab third entry, verify offset is\n+                    // 0xFFFFFFFF and it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp, CRC, compressed size\n+                    a.skipBytes(12);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            1, 0, 0, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            12, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            // file name\n+                            (byte) '2'\n+                        }, rest);\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size\n+                            8, 0\n+                        }, extra);\n+\n+                    // read offset of LFH\n+                    byte[] offset = new byte[8];\n+                    a.readFully(offset);\n+                    // verify there is a LFH where the CD claims it\n+                    a.seek(ZipEightByteInteger.getLongValue(offset));\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveFile() throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveFile\",\n+                             write3EntriesCreatingBigArchive(),\n+                             true);\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveStream() throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\",\n+                             write3EntriesCreatingBigArchive(),\n+                             false);\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveFileModeAlways\",\n+                             write3EntriesCreatingBigArchive(Zip64Mode.Always),\n+                             true);\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveStreamModeAlways\",\n+                             write3EntriesCreatingBigArchive(Zip64Mode.Always),\n+                             false);\n+    }\n+\n+    private static final ZipOutputTest write3EntriesCreatingBigArchiveModeNever =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    write3EntriesCreatingBigArchiveToStream(zos);\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertEquals(Zip64RequiredException.ARCHIVE_TOO_BIG_MESSAGE,\n+                                 ex.getMessage());\n+                }\n+            }\n+        };\n+\n+    @Test public void write3EntriesCreatingBigArchiveFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveFileModeNever\",\n+                             write3EntriesCreatingBigArchiveModeNever,\n+                             true);\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveStreamModeNever\",\n+                             write3EntriesCreatingBigArchiveModeNever,\n+                             false);\n+    }\n+\n+    @Test public void read3EntriesCreatingBigArchiveFileUsingZipFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"read3EntriesCreatingBigArchiveFileUsingZipFile\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     write3EntriesCreatingBigArchiveToStream(zos);\n+                                     ZipFile zf = null;\n+                                     try {\n+                                         zf = new ZipFile(f);\n+                                         int idx = 0;\n+                                         for (Enumeration e =\n+                                                  zf.getEntriesInPhysicalOrder();\n+                                              e.hasMoreElements(); ) {\n+                                             ZipArchiveEntry zae =\n+                                                 (ZipArchiveEntry)\n+                                                 e.nextElement();\n+                                             assertEquals(String.valueOf(idx),\n+                                                          zae.getName());\n+                                             if (idx++ < 2) {\n+                                                 assertEquals(FIVE_BILLION / 2,\n+                                                              zae.getSize());\n+                                             } else {\n+                                                 assertEquals(1,\n+                                                              zae.getSize());\n+                                                 InputStream i =\n+                                                     zf.getInputStream(zae);\n+                                                 try {\n+                                                     assertNotNull(i);\n+                                                     assertEquals(42, i.read());\n+                                                 } finally {\n+                                                     i.close();\n+                                                 }\n+                                             }\n+                                         }\n+                                     } finally {\n+                                         ZipFile.closeQuietly(zf);\n+                                     }\n+                                 }\n+                             },\n+                             true);\n+    }\n+\n+    private static ZipOutputTest writeBigStoredEntry(final boolean knownSize) {\n+        return writeBigStoredEntry(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written without\n+     * compression.\n+     *\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */\n+    private static ZipOutputTest writeBigStoredEntry(final boolean knownSize,\n+                                                     final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(FIVE_BILLION);\n+                    zae.setCrc(0x5c316f50L);\n+                }\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zos.putArchiveEntry(zae);\n+                for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                    zos.write(buf);\n+                }\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    // grab first entry, verify sizes are 0xFFFFFFFF\n+                    // and it has a ZIP64 extended information extra\n+                    // field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                        }, extra);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    /*\n+     * No Compression + Stream => sizes must be known before data is\n+     * written.\n+     */\n+    @Test public void writeBigStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStream\",\n+                             writeBigStoredEntry(true),\n+                             false);\n+    }\n+\n+    @Test public void writeBigStoredEntryKnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFile\",\n+                             writeBigStoredEntry(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigStoredEntryUnnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n+                             writeBigStoredEntry(false),\n+                             true);\n+    }\n+\n+    @Test public void writeBigStoredEntryToStreamModeAlways() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStreamModeAlways\",\n+                             writeBigStoredEntry(true, Zip64Mode.Always),\n+                             false);\n+    }\n+\n+    @Test public void writeBigStoredEntryKnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFileModeAlways\",\n+                             writeBigStoredEntry(true, Zip64Mode.Always),\n+                             true);\n+    }\n+\n+    @Test public void writeBigStoredEntryUnnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFileModeAlways\",\n+                             writeBigStoredEntry(false, Zip64Mode.Always),\n+                             true);\n+    }\n+\n+    private static ZipOutputTest\n+        writeBigStoredEntryModeNever(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    byte[] buf = new byte[ONE_MILLION];\n+                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    if (knownSize) {\n+                        zae.setSize(FIVE_BILLION);\n+                        zae.setCrc(0x5c316f50L);\n+                    }\n+                    zae.setMethod(ZipArchiveEntry.STORED);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertTrue(ex.getMessage().startsWith(\"0's size\"));\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigStoredEntryToStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStreamModeNever\",\n+                             writeBigStoredEntryModeNever(true),\n+                             false);\n+    }\n+\n+    @Test public void writeBigStoredEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFileModeNever\",\n+                             writeBigStoredEntryModeNever(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigStoredEntryUnnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFileModeNever\",\n+                             writeBigStoredEntryModeNever(false),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH and ZIP64\n+     * entry, real values are inside the data descriptor.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    private static ZipOutputTest\n+        writeBigDeflatedEntryToStream(final boolean knownSize,\n+                                      final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f,\n+                             ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(FIVE_BILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                    zos.write(buf);\n+                }\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a =\n+                    new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify\n+                    // sizes are 0xFFFFFFFF and\n+                    // it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            (byte) 0x68, (byte) 0x27, (byte) 0x4A, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+\n+                    // validate data descriptor\n+                    a.seek(cfhPos - 24);\n+                    byte[] dd = new byte[8];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 7, 8,\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                        }, dd);\n+                    dd = new byte[16];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // compressed size\n+                            (byte) 0x68, (byte) 0x27, (byte) 0x4A, 0,\n+                            0, 0, 0, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                        }, dd);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            0, 0, 0, 0,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // compressed size\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\",\n+                             writeBigDeflatedEntryToStream(true,\n+                                                           Zip64Mode.AsNeeded),\n+                             false);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeAlways\",\n+                             writeBigDeflatedEntryToStream(true,\n+                                                           Zip64Mode.Always),\n+                             false);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStreamModeAlways\",\n+                             writeBigDeflatedEntryToStream(false,\n+                                                           Zip64Mode.Always),\n+                             false);\n+    }\n+\n+    private static ZipOutputTest\n+        writeBigDeflatedEntryUnknownSizeToStream(final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                try {\n+                    if (mode != Zip64Mode.AsNeeded) {\n+                        zos.setUseZip64(mode);\n+                    }\n+                    byte[] buf = new byte[ONE_MILLION];\n+                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertTrue(ex.getMessage().startsWith(\"0's size\"));\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStream\",\n+                             writeBigDeflatedEntryUnknownSizeToStream(Zip64Mode\n+                                                                      .AsNeeded),\n+                             false);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToStreamModeNever\",\n+                             writeBigDeflatedEntryUnknownSizeToStream(Zip64Mode\n+                                                                      .Never),\n+                             false);\n+    }\n+\n+    private static ZipOutputTest\n+        writeBigDeflatedEntryToFile(final boolean knownSize) {\n+        return writeBigDeflatedEntryToFile(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    private static ZipOutputTest\n+        writeBigDeflatedEntryToFile(final boolean knownSize,\n+                                    final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(FIVE_BILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                for (int j = 0;\n+                     j < FIVE_BILLION / 1000 / 1000;\n+                     j++) {\n+                    zos.write(buf);\n+                }\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify\n+                    // sizes are 0xFFFFFFFF and\n+                    // it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS + *no* Data Descriptor)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            (byte) 0x68, (byte) 0x27, (byte) 0x4A, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit, no DD)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    extra = new byte[20];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            (byte) 0x68, (byte) 0x27, (byte) 0x4A, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\",\n+                             writeBigDeflatedEntryToFile(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFile\",\n+                             writeBigDeflatedEntryToFile(false),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFileModeAlways\",\n+                             writeBigDeflatedEntryToFile(true, Zip64Mode.Always),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFileModeAlways\",\n+                             writeBigDeflatedEntryToFile(false,\n+                                                         Zip64Mode.Always),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeNever\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     zos.setUseZip64(Zip64Mode.Never);\n+                                     try {\n+                                         byte[] buf = new byte[ONE_MILLION];\n+                                         ZipArchiveEntry zae =\n+                                             new ZipArchiveEntry(\"0\");\n+                                         zae.setSize(FIVE_BILLION);\n+                                         zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                         zos.putArchiveEntry(zae);\n+                                         fail(\"expected a\"\n+                                              + \" Zip64RequiredException\");\n+                                     } catch (Zip64RequiredException ex) {\n+                                         assertTrue(ex.getMessage()\n+                                                    .startsWith(\"0's size\"));\n+                                     }\n+                                 }\n+                             },\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    private static ZipOutputTest\n+        writeBigDeflatedEntryToFileModeNever(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    byte[] buf = new byte[ONE_MILLION];\n+                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    if (knownSize) {\n+                        zae.setSize(FIVE_BILLION);\n+                    }\n+                    zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0;\n+                         j < FIVE_BILLION / 1000 / 1000;\n+                         j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertTrue(ex.getMessage().startsWith(\"0's size\"));\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFileModeNever\",\n+                             writeBigDeflatedEntryToFileModeNever(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFileModeNever\",\n+                             writeBigDeflatedEntryToFileModeNever(false),\n+                             true);\n+    }\n+\n+    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize) {\n+        return writeSmallStoredEntry(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written without compression.\n+     *\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n+     * field if size was known.\n+     *\n+     * Creates a temporary archive of approx 1MB in size\n+     */\n+    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize,\n+                                                       final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                    zae.setCrc(0x1279CB9EL);\n+                }\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    // grab first CF entry, verify sizes are 1e6 and it\n+                    // has no ZIP64 extended information extra field\n+                    // at all\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header: this one\n+                    // has a ZIP64 extra field if and only if size was\n+                    // unknown and mode was not Never or the mode was\n+                    // Always (regardless of size)\n+                    boolean hasExtra = mode == Zip64Mode.Always\n+                        || (mode == Zip64Mode.AsNeeded && !knownSize);\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            (byte) (!hasExtra ? 0 : 20), 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    if (hasExtra) {\n+                        byte[] extra = new byte[20];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size of extra\n+                                16, 0,\n+                                // original size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                                // compressed size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                            }, extra);\n+                    }\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryToStream\",\n+                             writeSmallStoredEntry(true),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallStoredEntryKnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFile\",\n+                             writeSmallStoredEntry(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryUnnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFile\",\n+                             writeSmallStoredEntry(false),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryToStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryToStreamModeNever\",\n+                             writeSmallStoredEntry(true, Zip64Mode.Never),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallStoredEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFileModeNever\",\n+                             writeSmallStoredEntry(true, Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryUnnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFileModeNever\",\n+                             writeSmallStoredEntry(false, Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written without compression.\n+     *\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all. Contains ZIP64 extra fields because\n+     * mode is Always\n+     *\n+     * Creates a temporary archive of approx 1MB in size\n+     */\n+    private static ZipOutputTest\n+        writeSmallStoredEntryModeAlways(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Always);\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                    zae.setCrc(0x1279CB9EL);\n+                }\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    // grab first CF entry, verify sizes are 1e6 and it\n+                    // has no ZIP64 extended information extra field\n+                    // at all\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header: this one\n+                    // has a ZIP64 extra field as the mode was\n+                    // Always\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            0, 0, 0, 0,\n+                            // compressed size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallStoredEntryToStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryToStreamModeAlways\",\n+                             writeSmallStoredEntryModeAlways(true),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallStoredEntryKnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFileModeAlways\",\n+                             writeSmallStoredEntryModeAlways(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryUnnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFileModeAlways\",\n+                             writeSmallStoredEntryModeAlways(false),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH, real values\n+     * are inside the data descriptor.  No ZIP64 extra field at all.\n+     */\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryToStream(final boolean knownSize,\n+                                        final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify sizes are not\n+                    // 0xFFFFFFF and it has no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            20, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42,\n+                            (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // validate data descriptor\n+                    a.seek(cfhPos - 16);\n+                    byte[] dd = new byte[8];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 7, 8,\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                        }, dd);\n+                    // skip uncompressed size\n+                    a.skipBytes(4);\n+                    dd = new byte[4];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // original size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                        }, dd);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            20, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            0, 0, 0, 0,\n+                            // Compressed Size\n+                            0, 0, 0, 0,\n+                            // Original Size\n+                            0, 0, 0, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\",\n+                             writeSmallDeflatedEntryToStream(true,\n+                                                             Zip64Mode.AsNeeded),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStreamModeNever\",\n+                             writeSmallDeflatedEntryToStream(true,\n+                                                             Zip64Mode.Never),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStream\",\n+                             writeSmallDeflatedEntryToStream(false,\n+                                                             Zip64Mode.AsNeeded),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStreamModeNever\",\n+                             writeSmallDeflatedEntryToStream(false,\n+                                                             Zip64Mode.Never),\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH, real values\n+     * are inside the data descriptor.  ZIP64 extra field as mode is Always.\n+     */\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryToStreamModeAlways(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Always);\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify sizes are not\n+                    // 0xFFFFFFF and it has no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            20, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42,\n+                            (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // validate data descriptor\n+                    a.seek(cfhPos - 24);\n+                    byte[] dd = new byte[8];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 7, 8,\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                        }, dd);\n+                    // skip compressed size\n+                    a.skipBytes(8);\n+                    dd = new byte[8];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // original size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            0, 0, 0, 0\n+                        }, dd);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            0, 0, 0, 0,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // compressed size\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStreamModeAlways\",\n+                             writeSmallDeflatedEntryToStreamModeAlways(true),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToStreamModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToStreamModeAlways\",\n+                             writeSmallDeflatedEntryToStreamModeAlways(false),\n+                             false);\n+    }\n+\n+    private static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize) {\n+        return writeSmallDeflatedEntryToFile(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n+     * field if size was known.\n+     */\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryToFile(final boolean knownSize,\n+                                      final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first CD entry, verify sizes are not\n+                    // 0xFFFFFFFF and it has a no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS + *no* Data Descriptor)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit, no DD)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    rest = new byte[9];\n+                    a.readFully(rest);\n+\n+                    boolean hasExtra = \n+                        mode == Zip64Mode.AsNeeded && !knownSize;\n+\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            (byte) (!hasExtra ? 0 : 20), 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    if (hasExtra) {\n+                        byte[] extra = new byte[12];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size of extra\n+                                16, 0,\n+                                // original size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                                // don't know the\n+                                // compressed size,\n+                                // don't want to\n+                                // hard-code it\n+                            }, extra);\n+                    }\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFile\",\n+                             writeSmallDeflatedEntryToFile(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFile\",\n+                             writeSmallDeflatedEntryToFile(false),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFileModeNever\",\n+                             writeSmallDeflatedEntryToFile(true,\n+                                                           Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFileModeNever\",\n+                             writeSmallDeflatedEntryToFile(false,\n+                                                           Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.  Must contain ZIP64 extra field as\n+     * mode is Always.\n+     */\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryToFileModeAlways(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Always);\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first CD entry, verify sizes are not\n+                    // 0xFFFFFFFF and it has a no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS + *no* Data Descriptor)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit, no DD)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    rest = new byte[13];\n+                    a.readFully(rest);\n+\n+                    assertArrayEquals(new byte[] {\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    byte[] extra = new byte[12];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            0, 0, 0, 0,\n+                            // don't know the\n+                            // compressed size,\n+                            // don't want to\n+                            // hard-code it\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFileModeAlways\",\n+                             writeSmallDeflatedEntryToFileModeAlways(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToFileModeAlways()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFileModeAlways\",\n+                             writeSmallDeflatedEntryToFileModeAlways(false),\n+                             true);\n+    }\n+\n+    static interface ZipOutputTest {\n+        void test(File f, ZipArchiveOutputStream zos) throws IOException;\n+    }\n+\n+    private static void withTemporaryArchive(String testName,\n+                                             ZipOutputTest test,\n+                                             boolean useRandomAccessFile)\n+        throws Throwable {\n+        File f = getTempFile(testName);\n+        BufferedOutputStream os = null;\n+        ZipArchiveOutputStream zos = useRandomAccessFile\n+            ? new ZipArchiveOutputStream(f)\n+            : new ZipArchiveOutputStream(os = new BufferedOutputStream(new FileOutputStream(f)));\n+        try {\n+            test.test(f, zos);\n+        } catch (IOException ex) {\n+            System.err.println(\"Failed to write archive because of: \"\n+                               + ex.getMessage()\n+                               + \" - likely not enough disk space.\");\n+            assumeTrue(false);\n+        } finally {\n+            try {\n+                zos.destroy();\n+            } finally {\n+                if (os != null) {\n+                    os.close();\n+                }\n+                f.delete();\n+            }\n+        }\n+    }\n+\n+    private static File getFile(String name) throws Throwable {\n+        URL url = Zip64SupportIT.class.getResource(name);\n+        assumeNotNull(url);\n+        File file = new File(new URI(url.toString()));\n+        assumeTrue(file.exists());\n+        return file;\n+    }\n+\n+    private static File get5GBZerosFile() throws Throwable {\n+        return getFile(\"/5GB_of_Zeros.zip\");\n+    }\n+\n+    private static File get5GBZerosFileGeneratedBy7ZIP() throws Throwable {\n+        return getFile(\"/5GB_of_Zeros_7ZIP.zip\");\n+    }\n+\n+    private static File get5GBZerosFileGeneratedByJava7Jar() throws Throwable {\n+        return getFile(\"/5GB_of_Zeros_jar.zip\");\n+    }\n+\n+    private static File get100KFileFile() throws Throwable {\n+        return getFile(\"/100k_Files.zip\");\n+    }\n+\n+    private static File get100KFileFileGeneratedBy7ZIP() throws Throwable {\n+        return getFile(\"/100k_Files_7ZIP.zip\");\n+    }\n+\n+    private static File get100KFileFileGeneratedByWinCF() throws Throwable {\n+        return getFile(\"/100k_Files_WindowsCompressedFolders.zip\");\n+    }\n+\n+    private static File get100KFileFileGeneratedByJava7Jar() throws Throwable {\n+        return getFile(\"/100k_Files_jar.zip\");\n+    }\n+\n+    private static File getTempFile(String testName) throws Throwable {\n+        File f = File.createTempFile(\"commons-compress-\" + testName, \".zip\");\n+        f.deleteOnExit();\n+        return f;\n+    }\n+\n+    private static void read5GBOfZerosImpl(File f, String expectedName)\n+        throws IOException {\n+        FileInputStream fin = new FileInputStream(f);\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(fin);\n+            ZipArchiveEntry zae = zin.getNextZipEntry();\n+            assertEquals(expectedName, zae.getName());\n+            byte[] buf = new byte[1024 * 1024];\n+            long read = 0;\n+            Random r = new Random(System.currentTimeMillis());\n+            int readNow;\n+            while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n+                // testing all bytes for a value of 0 is going to take\n+                // too long, just pick a few ones randomly\n+                for (int i = 0; i < 1024; i++) {\n+                    int idx = r.nextInt(readNow);\n+                    assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n+                }\n+                read += readNow;\n+            }\n+            assertEquals(FIVE_BILLION, read);\n+            assertNull(zin.getNextZipEntry());\n+            assertEquals(FIVE_BILLION, zae.getSize());\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+            if (fin != null) {\n+                fin.close();\n+            }\n+        }\n+    }\n+\n+    private static void read5GBOfZerosUsingZipFileImpl(File f,\n+                                                       String expectedName)\n+        throws IOException {\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(f);\n+            Enumeration e = zf.getEntries();\n+            assertTrue(e.hasMoreElements());\n+            ZipArchiveEntry zae = (ZipArchiveEntry) e.nextElement();\n+            assertEquals(expectedName, zae.getName());\n+            assertEquals(FIVE_BILLION, zae.getSize());\n+            byte[] buf = new byte[1024 * 1024];\n+            long read = 0;\n+            Random r = new Random(System.currentTimeMillis());\n+            int readNow;\n+            InputStream zin = zf.getInputStream(zae);\n+            try {\n+                while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n+                    // testing all bytes for a value of 0 is going to take\n+                    // too long, just pick a few ones randomly\n+                    for (int i = 0; i < 1024; i++) {\n+                        int idx = r.nextInt(readNow);\n+                        assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n+                    }\n+                    read += readNow;\n+                }\n+            } finally {\n+                zin.close();\n+            }\n+            assertEquals(FIVE_BILLION, read);\n+            assertFalse(e.hasMoreElements());\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n+    private static void read100KFilesImpl(File f) throws IOException {\n+        FileInputStream fin = new FileInputStream(f);\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(fin);\n+            int files = 0;\n+            ZipArchiveEntry zae = null;\n+            while ((zae = zin.getNextZipEntry()) != null) {\n+                if (!zae.isDirectory()) {\n+                    files++;\n+                    assertEquals(0, zae.getSize());\n+                }\n+            }\n+            assertEquals(ONE_HUNDRED_THOUSAND, files);\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+            fin.close();\n+        }\n+    }\n+\n+    private static void read100KFilesUsingZipFileImpl(File f)\n+        throws IOException {\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(f);\n+            int files = 0;\n+            for (Enumeration e = zf.getEntries(); e.hasMoreElements(); ) {\n+                ZipArchiveEntry zae = (ZipArchiveEntry) e.nextElement();\n+                if (!zae.isDirectory()) {\n+                    files++;\n+                    assertEquals(0, zae.getSize());\n+                }\n+            }\n+            assertEquals(ONE_HUNDRED_THOUSAND, files);\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n+    private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n+        throws IOException {\n+        final long end = a.length();\n+        a.seek(end - 22 - 20);\n+        byte[] sig = new byte[4];\n+        a.readFully(sig);\n+        if (sig[0] != (byte) 0x50 || sig[1] != (byte) 0x4b\n+            || sig[2] != 6 || sig[3] != 7) {\n+            // not a ZIP64 archive\n+            return getLengthAndPositionAtCentralDirectory32(a, end);\n+        }\n+\n+        long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n+        // seek to central directory locator\n+        a.seek(cdOffsetLoc);\n+        byte[] cdOffset = new byte[8];\n+        a.readFully(cdOffset);\n+        a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+        return end;\n+    }\n+\n+    private static long getLengthAndPositionAtCentralDirectory32(RandomAccessFile a, final long end)\n+        throws IOException {\n+        a.seek(end - 22 + 16);\n+        byte[] cdOffset = new byte[4];\n+        a.readFully(cdOffset);\n+        a.seek(ZipLong.getValue(cdOffset));\n+        return end;\n+    }\n+\n+    private static void write100KFilesToStream(ZipArchiveOutputStream zos)\n+        throws IOException {\n+        for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n+            ZipArchiveEntry zae = new ZipArchiveEntry(String.valueOf(i));\n+            zae.setSize(0);\n+            zos.putArchiveEntry(zae);\n+            zos.closeArchiveEntry();\n+        }\n+        zos.close();\n+    }\n+\n+    private static void\n+        write3EntriesCreatingBigArchiveToStream(ZipArchiveOutputStream zos)\n+        throws IOException {\n+        byte[] buf = new byte[ONE_MILLION];\n+        ZipArchiveEntry zae = null;\n+        for (int i = 0; i < 2; i++) {\n+            zae = new ZipArchiveEntry(String.valueOf(i));\n+            zae.setSize(FIVE_BILLION / 2);\n+            zae.setMethod(ZipArchiveEntry.STORED);\n+            zae.setCrc(0x8a408f16L);\n+            zos.putArchiveEntry(zae);\n+            for (int j = 0; j < FIVE_BILLION / 2 / 1000 / 1000;\n+                 j++) {\n+                zos.write(buf);\n+            }\n+            zos.closeArchiveEntry();\n+        }\n+        zae = new ZipArchiveEntry(String.valueOf(2));\n+        zae.setSize(1);\n+        zae.setMethod(ZipArchiveEntry.STORED);\n+        zae.setCrc(0x9b9265bL);\n+        zos.putArchiveEntry(zae);\n+        zos.write(new byte[] { 42 });\n+        zos.closeArchiveEntry();\n+        zos.close();\n+    }\n+}", "timestamp": 1313123779, "metainfo": ""}