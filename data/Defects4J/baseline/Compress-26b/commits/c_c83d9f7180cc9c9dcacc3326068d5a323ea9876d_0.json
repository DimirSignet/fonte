{"sha": "c83d9f7180cc9c9dcacc3326068d5a323ea9876d", "log": "COMPRESS-112 ArArchiveInputStream does not handle GNU extended filename records (//)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n      */\n     private ArArchiveEntry currentEntry = null;\n     \n+    // Storage area for extra long names (GNU ar)\n+    private byte[] namebuffer = null;\n+    \n     /*\n      * The offset where the current entry started. -1 if no entry has been\n      * called\n             final byte[] realized = new byte[expected.length];\n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read entry header. Occured at byte: \" + getBytesRead());\n+                throw new IOException(\"failed to read entry trailer. Occured at byte: \" + getBytesRead());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid entry header. not read the content? Occured at byte: \" + getBytesRead());\n+                    throw new IOException(\"invalid entry trailer. not read the content? Occured at byte: \" + getBytesRead());\n                 }\n             }\n         }\n \n         entryOffset = offset;\n \n-        // SVR4/GNU adds a trailing \"/\" to names\n+//        GNU ar stores multiple extended filenames in the data section of a file with the name \"//\", this record is referred to by future headers. A header references an extended filename by storing a \"/\" followed by a decimal offset to the start of the filename in the extended filename data section. The format of this \"//\" file itself is simply a list of the long filenames, each separated by one or more LF characters. Note that the decimal offsets are number of characters, not line or string number within the \"//\" file.\n+//\n+//        GNU ar uses a '/' to mark the end of the filename; this allows for the use of spaces without the use of an extended filename.\n+\n         // entry name is stored as ASCII string\n         String temp = ArchiveUtils.toAsciiString(name).trim();\n-        if (temp.endsWith(\"/\")) {\n+        \n+        if (temp.equals(\"//\")){ // GNU extended filenames entry\n+            int bufflen = asInt(length); // Assume length will fit in an int\n+            namebuffer = new byte[bufflen];\n+            int read = read(namebuffer, 0, bufflen);\n+            if (read != bufflen){\n+                throw new IOException(\"Failed to read complete // record: expected=\"+bufflen+\" read=\"+read);\n+            }\n+            currentEntry = new ArArchiveEntry(temp, bufflen);\n+            return getNextArEntry();\n+        } else if (temp.endsWith(\"/\")) { // GNU terminator\n             temp = temp.substring(0, temp.length() - 1);\n+        } else if (temp.matches(\"^/\\\\d+\")) {// GNU long filename ref.\n+            int offset = Integer.parseInt(temp.substring(1));// get the offset\n+            temp = getExtendedName(offset); // convert to the long name\n         }\n         currentEntry = new ArArchiveEntry(temp, asLong(length), asInt(userid),\n                                           asInt(groupid), asInt(filemode, 8),\n         return currentEntry;\n     }\n \n+    /**\n+     * Get an extended name from the GNU extended name buffer.\n+     * \n+     * @param offset pointer to entry within the buffer\n+     * @return the extended file name; without trailing \"/\" if present.\n+     * @throws IOException if name not found or buffer not set up\n+     */\n+    private String getExtendedName(int offset) throws IOException{\n+        if (namebuffer == null) {\n+            throw new IOException(\"Cannot process GNU long filename as no // record was found\");\n+        }\n+        for(int i=offset; i < namebuffer.length; i++){\n+            if (namebuffer[i]=='\\012'){\n+                if (namebuffer[i-1]=='/') {\n+                    i--; // drop trailing /\n+                }\n+                return ArchiveUtils.toAsciiString(namebuffer, offset, i-offset);\n+            }\n+        }\n+        throw new IOException(\"Failed to read entry: \"+offset);\n+    }\n     private long asLong(byte[] input) {\n         return Long.parseLong(new String(input).trim());\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n                     expected.set(i, ent.substring(0, ent.length()-1));\n                 }\n             }\n+        } else if (name.endsWith(\".ar\")){\n+            assertTrue(ais instanceof ArArchiveInputStream);\n+            // CPIO does not store directories or directory names\n+            expected.clear();\n+            for(int i=0; i < fileList.size(); i++){\n+                String ent = (String) fileList.get(i);\n+                if (!ent.endsWith(\"/\")){// not a directory\n+                    final int lastSlash = ent.lastIndexOf('/');\n+                    if (lastSlash >= 0) { // extract path name\n+                        expected.add(ent.substring(lastSlash+1, ent.length()));                        \n+                    } else {\n+                        expected.add(ent);\n+                    }\n+                }\n+            }\n         } else {\n             fail(\"Unexpected file type: \"+name);\n         }", "timestamp": 1273746315, "metainfo": ""}