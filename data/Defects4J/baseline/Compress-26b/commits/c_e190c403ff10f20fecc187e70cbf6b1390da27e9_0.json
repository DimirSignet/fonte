{"sha": "e190c403ff10f20fecc187e70cbf6b1390da27e9", "log": "applied patch by Christian Grobmeier  updated zip support  https://issues.apache.org/jira/browse/SANDBOX-248    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.ZipException;\n+\n+/**\n+ * If this extra field is added as the very first extra field of the\n+ * archive, Solaris will consider it an executable jar file.\n+ *\n+ * @since Ant 1.6.3\n+ */\n+public final class JarMarker implements ZipExtraField {\n+\n+    private static final ZipShort ID = new ZipShort(0xCAFE);\n+    private static final ZipShort NULL = new ZipShort(0);\n+    private static final byte[] NO_BYTES = new byte[0];\n+    private static final JarMarker DEFAULT = new JarMarker();\n+\n+    /** No-arg constructor */\n+    public JarMarker() {\n+        // empty\n+    }\n+\n+    /**\n+     * Since JarMarker is stateless we can always use the same instance.\n+     * @return the DEFAULT jarmaker.\n+     */\n+    public static JarMarker getInstance() {\n+        return DEFAULT;\n+    }\n+\n+    /**\n+     * The Header-ID.\n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return ID;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     * @return 0\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return NULL;\n+    }\n+\n+    /**\n+     * Length of the extra field in the central directory - without\n+     * Header-ID or length specifier.\n+     * @return 0\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return NULL;\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     * @return the data\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return NO_BYTES;\n+    }\n+\n+    /**\n+     * The actual data to put central directory - without Header-ID or\n+     * length specifier.\n+     * @return the data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        return NO_BYTES;\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     * @param data an array of bytes\n+     * @param offset the start offset\n+     * @param length the number of bytes in the array from offset\n+     *\n+     * @throws ZipException on error\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length)\n+        throws ZipException {\n+        if (length != 0) {\n+            throw new ZipException(\"JarMarker doesn't expect any data\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Replacement for <code>java.util.ZipFile</code>.\n+ *\n+ * <p>This class adds support for file name encodings other than UTF-8\n+ * (which is required to work on ZIP files created by native zip tools\n+ * and is able to skip a preamble like the one found in self\n+ * extracting archives.  Furthermore it returns instances of\n+ * <code>org.apache.tools.zip.ZipEntry</code> instead of\n+ * <code>java.util.zip.ZipEntry</code>.</p>\n+ *\n+ * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n+ * have to reimplement all methods anyway.  Like\n+ * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n+ * covers and supports compressed and uncompressed entries.</p>\n+ *\n+ * <p>The method signatures mimic the ones of\n+ * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n+ *\n+ * <ul>\n+ *   <li>There is no getName method.</li>\n+ *   <li>entries has been renamed to getEntries.</li>\n+ *   <li>getEntries and getEntry return\n+ *   <code>org.apache.tools.zip.ZipEntry</code> instances.</li>\n+ *   <li>close is allowed to throw IOException.</li>\n+ * </ul>\n+ *\n+ */\n+public class ZipFile {\n+    private static final int HASH_SIZE = 509;\n+    private static final int SHORT     =   2;\n+    private static final int WORD      =   4;\n+    private static final int NIBLET_MASK = 0x0f;\n+    private static final int BYTE_SHIFT = 8;\n+    private static final int POS_0 = 0;\n+    private static final int POS_1 = 1;\n+    private static final int POS_2 = 2;\n+    private static final int POS_3 = 3;\n+\n+    /**\n+     * Maps ZipEntrys to Longs, recording the offsets of the local\n+     * file headers.\n+     */\n+    private Hashtable entries = new Hashtable(HASH_SIZE);\n+\n+    /**\n+     * Maps String to ZipEntrys, name -> actual entry.\n+     */\n+    private Hashtable nameMap = new Hashtable(HASH_SIZE);\n+\n+    private static final class OffsetEntry {\n+        private long headerOffset = -1;\n+        private long dataOffset = -1;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to the platform's default character encoding.</p>\n+     */\n+    private String encoding = null;\n+\n+    /**\n+     * The actual data source.\n+     */\n+    private RandomAccessFile archive;\n+\n+    /**\n+     * Opens the given file for reading, assuming the platform's\n+     * native encoding for file names.\n+     *\n+     * @param f the archive.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(File f) throws IOException {\n+        this(f, null);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the platform's\n+     * native encoding for file names.\n+     *\n+     * @param name name of the archive.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(String name) throws IOException {\n+        this(new File(name), null);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * @param name name of the archive.\n+     * @param encoding the encoding to use for file names\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(String name, String encoding) throws IOException {\n+        this(new File(name), encoding);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * @param f the archive.\n+     * @param encoding the encoding to use for file names\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(File f, String encoding) throws IOException {\n+        this.encoding = encoding;\n+        archive = new RandomAccessFile(f, \"r\");\n+        try {\n+            populateFromCentralDirectory();\n+            resolveLocalFileHeaderData();\n+        } catch (IOException e) {\n+            try {\n+                archive.close();\n+            } catch (IOException e2) {\n+                // swallow, throw the original exception instead\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     */\n+    public String getEncoding() {\n+        return encoding;\n+    }\n+\n+    /**\n+     * Closes the archive.\n+     * @throws IOException if an error occurs closing the archive.\n+     */\n+    public void close() throws IOException {\n+        archive.close();\n+    }\n+\n+    /**\n+     * close a zipfile quietly; throw no io fault, do nothing\n+     * on a null parameter\n+     * @param zipfile file to close, can be null\n+     */\n+    public static void closeQuietly(ZipFile zipfile) {\n+        if (zipfile != null) {\n+            try {\n+                zipfile.close();\n+            } catch (IOException e) {\n+                //ignore\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns all entries.\n+     * @return all entries as {@link ZipEntry} instances\n+     */\n+    public Enumeration getEntries() {\n+        return entries.keys();\n+    }\n+\n+    /**\n+     * Returns a named entry - or <code>null</code> if no entry by\n+     * that name exists.\n+     * @param name name of the entry.\n+     * @return the ZipEntry corresponding to the given name - or\n+     * <code>null</code> if not present.\n+     */\n+    public ZipEntry getEntry(String name) {\n+        return (ZipEntry) nameMap.get(name);\n+    }\n+\n+    /**\n+     * Returns an InputStream for reading the contents of the given entry.\n+     * @param ze the entry to get the stream for.\n+     * @return a stream to read the entry from.\n+     * @throws IOException if unable to create an input stream from the zipenty\n+     * @throws ZipException if the zipentry has an unsupported compression method\n+     */\n+    public InputStream getInputStream(ZipEntry ze)\n+        throws IOException, ZipException {\n+        OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n+        if (offsetEntry == null) {\n+            return null;\n+        }\n+        long start = offsetEntry.dataOffset;\n+        BoundedInputStream bis =\n+            new BoundedInputStream(start, ze.getCompressedSize());\n+        switch (ze.getMethod()) {\n+            case ZipEntry.STORED:\n+                return bis;\n+            case ZipEntry.DEFLATED:\n+                bis.addDummy();\n+                return new InflaterInputStream(bis, new Inflater(true));\n+            default:\n+                throw new ZipException(\"Found unsupported compression method \"\n+                                       + ze.getMethod());\n+        }\n+    }\n+\n+    private static final int CFH_LEN =\n+        /* version made by                 */ SHORT\n+        /* version needed to extract       */ + SHORT\n+        /* general purpose bit flag        */ + SHORT\n+        /* compression method              */ + SHORT\n+        /* last mod file time              */ + SHORT\n+        /* last mod file date              */ + SHORT\n+        /* crc-32                          */ + WORD\n+        /* compressed size                 */ + WORD\n+        /* uncompressed size               */ + WORD\n+        /* filename length                 */ + SHORT\n+        /* extra field length              */ + SHORT\n+        /* file comment length             */ + SHORT\n+        /* disk number start               */ + SHORT\n+        /* internal file attributes        */ + SHORT\n+        /* external file attributes        */ + WORD\n+        /* relative offset of local header */ + WORD;\n+\n+    /**\n+     * Reads the central directory of the given archive and populates\n+     * the internal tables with ZipEntry instances.\n+     *\n+     * <p>The ZipEntrys will know all data that can be obtained from\n+     * the central directory alone, but not the data that requires the\n+     * local file header or additional data to be read.</p>\n+     */\n+    private void populateFromCentralDirectory()\n+        throws IOException {\n+        positionAtCentralDirectory();\n+\n+        byte[] cfh = new byte[CFH_LEN];\n+\n+        byte[] signatureBytes = new byte[WORD];\n+        archive.readFully(signatureBytes);\n+        long sig = ZipLong.getValue(signatureBytes);\n+        final long cfhSig = ZipLong.getValue(ZipOutputStream.CFH_SIG);\n+        if (sig != cfhSig && startsWithLocalFileHeader()) {\n+            throw new IOException(\"central directory is empty, can't expand\"\n+                                  + \" corrupt archive.\");\n+        }\n+        while (sig == cfhSig) {\n+            archive.readFully(cfh);\n+            int off = 0;\n+            ZipEntry ze = new ZipEntry();\n+\n+            int versionMadeBy = ZipShort.getValue(cfh, off);\n+            off += SHORT;\n+            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n+\n+            off += WORD; // skip version info and general purpose byte\n+\n+            ze.setMethod(ZipShort.getValue(cfh, off));\n+            off += SHORT;\n+\n+            // FIXME this is actually not very cpu cycles friendly as we are converting from\n+            // dos to java while the underlying Sun implementation will convert\n+            // from java to dos time for internal storage...\n+            long time = dosToJavaTime(ZipLong.getValue(cfh, off));\n+            ze.setTime(time);\n+            off += WORD;\n+\n+            ze.setCrc(ZipLong.getValue(cfh, off));\n+            off += WORD;\n+\n+            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n+            off += WORD;\n+\n+            ze.setSize(ZipLong.getValue(cfh, off));\n+            off += WORD;\n+\n+            int fileNameLen = ZipShort.getValue(cfh, off);\n+            off += SHORT;\n+\n+            int extraLen = ZipShort.getValue(cfh, off);\n+            off += SHORT;\n+\n+            int commentLen = ZipShort.getValue(cfh, off);\n+            off += SHORT;\n+\n+            off += SHORT; // disk number\n+\n+            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n+            off += SHORT;\n+\n+            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n+            off += WORD;\n+\n+            byte[] fileName = new byte[fileNameLen];\n+            archive.readFully(fileName);\n+            ze.setName(getString(fileName));\n+\n+\n+            // LFH offset,\n+            OffsetEntry offset = new OffsetEntry();\n+            offset.headerOffset = ZipLong.getValue(cfh, off);\n+            // data offset will be filled later\n+            entries.put(ze, offset);\n+\n+            nameMap.put(ze.getName(), ze);\n+\n+            archive.skipBytes(extraLen);\n+\n+            byte[] comment = new byte[commentLen];\n+            archive.readFully(comment);\n+            ze.setComment(getString(comment));\n+\n+            archive.readFully(signatureBytes);\n+            sig = ZipLong.getValue(signatureBytes);\n+        }\n+    }\n+\n+    private static final int MIN_EOCD_SIZE =\n+        /* end of central dir signature    */ WORD\n+        /* number of this disk             */ + SHORT\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir on this disk    */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir                 */ + SHORT\n+        /* size of the central directory   */ + WORD\n+        /* offset of start of central      */\n+        /* directory with respect to       */\n+        /* the starting disk number        */ + WORD\n+        /* zipfile comment length          */ + SHORT;\n+\n+    private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE\n+        /* maximum length of zipfile comment */ + 0xFFFF;\n+\n+    private static final int CFD_LOCATOR_OFFSET =\n+        /* end of central dir signature    */ WORD\n+        /* number of this disk             */ + SHORT\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir on this disk    */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir                 */ + SHORT\n+        /* size of the central directory   */ + WORD;\n+\n+    /**\n+     * Searches for the &quot;End of central dir record&quot;, parses\n+     * it and positions the stream at the first central directory\n+     * record.\n+     */\n+    private void positionAtCentralDirectory()\n+        throws IOException {\n+        boolean found = false;\n+        long off = archive.length() - MIN_EOCD_SIZE;\n+        long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\n+        if (off >= 0) {\n+            archive.seek(off);\n+            byte[] sig = ZipOutputStream.EOCD_SIG;\n+            int curr = archive.read();\n+            while (off >= stopSearching && curr != -1) {\n+                if (curr == sig[POS_0]) {\n+                    curr = archive.read();\n+                    if (curr == sig[POS_1]) {\n+                        curr = archive.read();\n+                        if (curr == sig[POS_2]) {\n+                            curr = archive.read();\n+                            if (curr == sig[POS_3]) {\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                archive.seek(--off);\n+                curr = archive.read();\n+            }\n+        }\n+        if (!found) {\n+            throw new ZipException(\"archive is not a ZIP archive\");\n+        }\n+        archive.seek(off + CFD_LOCATOR_OFFSET);\n+        byte[] cfdOffset = new byte[WORD];\n+        archive.readFully(cfdOffset);\n+        archive.seek(ZipLong.getValue(cfdOffset));\n+    }\n+\n+    /**\n+     * Number of bytes in local file header up to the &quot;length of\n+     * filename&quot; entry.\n+     */\n+    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH =\n+        /* local file header signature     */ WORD\n+        /* version needed to extract       */ + SHORT\n+        /* general purpose bit flag        */ + SHORT\n+        /* compression method              */ + SHORT\n+        /* last mod file time              */ + SHORT\n+        /* last mod file date              */ + SHORT\n+        /* crc-32                          */ + WORD\n+        /* compressed size                 */ + WORD\n+        /* uncompressed size               */ + WORD;\n+\n+    /**\n+     * Walks through all recorded entries and adds the data available\n+     * from the local file header.\n+     *\n+     * <p>Also records the offsets for the data to read from the\n+     * entries.</p>\n+     */\n+    private void resolveLocalFileHeaderData()\n+        throws IOException {\n+        Enumeration e = getEntries();\n+        while (e.hasMoreElements()) {\n+            ZipEntry ze = (ZipEntry) e.nextElement();\n+            OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n+            long offset = offsetEntry.headerOffset;\n+            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n+            byte[] b = new byte[SHORT];\n+            archive.readFully(b);\n+            int fileNameLen = ZipShort.getValue(b);\n+            archive.readFully(b);\n+            int extraFieldLen = ZipShort.getValue(b);\n+            archive.skipBytes(fileNameLen);\n+            byte[] localExtraData = new byte[extraFieldLen];\n+            archive.readFully(localExtraData);\n+            ze.setExtra(localExtraData);\n+            /*dataOffsets.put(ze,\n+                            new Long(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+                                     + SHORT + SHORT + fileNameLen + extraFieldLen));\n+            */\n+            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+                                     + SHORT + SHORT + fileNameLen + extraFieldLen;\n+        }\n+    }\n+\n+    /**\n+     * Convert a DOS date/time field to a Date object.\n+     *\n+     * @param zipDosTime contains the stored DOS time.\n+     * @return a Date instance corresponding to the given time.\n+     */\n+    protected static Date fromDosTime(ZipLong zipDosTime) {\n+        long dosTime = zipDosTime.getValue();\n+        return new Date(dosToJavaTime(dosTime));\n+    }\n+\n+    /*\n+     * Converts DOS time to Java time (number of milliseconds since epoch).\n+     */\n+    private static long dosToJavaTime(long dosTime) {\n+        Calendar cal = Calendar.getInstance();\n+        // CheckStyle:MagicNumberCheck OFF - no point\n+        cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\n+        cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\n+        cal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\n+        cal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\n+        cal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\n+        cal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n+        // CheckStyle:MagicNumberCheck ON\n+        return cal.getTime().getTime();\n+    }\n+\n+\n+    /**\n+     * Retrieve a String from the given bytes using the encoding set\n+     * for this ZipFile.\n+     *\n+     * @param bytes the byte array to transform\n+     * @return String obtained by using the given encoding\n+     * @throws ZipException if the encoding cannot be recognized.\n+     */\n+    protected String getString(byte[] bytes) throws ZipException {\n+        if (encoding == null) {\n+            return new String(bytes);\n+        } else {\n+            try {\n+                return new String(bytes, encoding);\n+            } catch (UnsupportedEncodingException uee) {\n+                throw new ZipException(uee.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the archive starts with a LFH.  If it doesn't,\n+     * it may be an empty archive.\n+     */\n+    private boolean startsWithLocalFileHeader() throws IOException {\n+        archive.seek(0);\n+        final byte[] start = new byte[WORD];\n+        archive.readFully(start);\n+        for (int i = 0; i < start.length; i++) {\n+            if (start[i] != ZipOutputStream.LFH_SIG[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * InputStream that delegates requests to the underlying\n+     * RandomAccessFile, making sure that only bytes from a certain\n+     * range can be read.\n+     */\n+    private class BoundedInputStream extends InputStream {\n+        private long remaining;\n+        private long loc;\n+        private boolean addDummyByte = false;\n+\n+        BoundedInputStream(long start, long remaining) {\n+            this.remaining = remaining;\n+            loc = start;\n+        }\n+\n+        public int read() throws IOException {\n+            if (remaining-- <= 0) {\n+                if (addDummyByte) {\n+                    addDummyByte = false;\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            synchronized (archive) {\n+                archive.seek(loc++);\n+                return archive.read();\n+            }\n+        }\n+\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (remaining <= 0) {\n+                if (addDummyByte) {\n+                    addDummyByte = false;\n+                    b[off] = 0;\n+                    return 1;\n+                }\n+                return -1;\n+            }\n+\n+            if (len <= 0) {\n+                return 0;\n+            }\n+\n+            if (len > remaining) {\n+                len = (int) remaining;\n+            }\n+            int ret = -1;\n+            synchronized (archive) {\n+                archive.seek(loc);\n+                ret = archive.read(b, off, len);\n+            }\n+            if (ret > 0) {\n+                loc += ret;\n+                remaining -= ret;\n+            }\n+            return ret;\n+        }\n+\n+        /**\n+         * Inflater needs an extra dummy byte for nowrap - see\n+         * Inflater's javadocs.\n+         */\n+        void addDummy() {\n+            addDummyByte = true;\n+        }\n+    }\n+\n+}", "timestamp": 1231759793, "metainfo": ""}