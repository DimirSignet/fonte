{"sha": "0600296ab8f8a0bbdfedd483f51b38005eb8e34e", "log": "[CVE-2012-2098] Integrate fallback sort into the rest, add some more tests and fix bug in bucket boundary calculation  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n  * Compress\" you'd get:</p>\n  *\n  * <pre>\n+ *  CompressCommons\n  * Commons Compress\n  * CompressCommons \n  * essCommons Compr\n  * ssCommons Compre\n  * </pre>\n  *\n- * <p>Which results in a new text \"s romooCCmmpnse\", in adition the\n+ * <p>Which results in a new text \"ss romooCCmmpnse\", in adition the\n  * index of the first line that contained the original text is kept -\n- * in this case it is 0.  The idea is that in a long English text all\n+ * in this case it is 1.  The idea is that in a long English text all\n  * permutations that start with \"he\" are likely suffixes of a \"the\" and\n  * thus they end in \"t\" leading to a larger block of \"t\"s that can\n  * better be compressed by the subsequent Move-to-Front, run-length\n      * been dropped after 0.9.0 and replaced by a fallback sorting\n      * algorithm.\n      *\n-     * I've added the fallbackSort function of 1.0.6.\n+     * I've added the fallbackSort function of 1.0.6 and tried to\n+     * integrate it with the existing code without touching too much.\n      */\n \n     /*\n         this.workDone = 0;\n         this.blockRandomised = false;\n         this.firstAttempt = true;\n+\n+        if (last + 1 < 10000) {\n+            fallbackSort(data, last);\n+        } else {\n+\n         mainSort(data, last);\n \n         if (this.firstAttempt && (this.workDone > this.workLimit)) {\n-            randomiseBlock(data, last);\n-            this.workLimit = this.workDone = 0;\n-            this.firstAttempt = false;\n-            mainSort(data, last);\n+                fallbackSort(data, last);\n+        }\n         }\n \n         final int[] fmap = data.fmap;\n         }\n \n         // assert (data.origPtr != -1) : data.origPtr;\n-        return blockRandomised;\n+        return false;\n+    }\n+\n+    /**\n+     * Adapt fallbackSort to the expected interface of the rest of the\n+     * code, in particular deal with the fact that block starts at\n+     * offset 1 (in libbzip2 1.0.6 it starts at 0).\n+     */\n+    final void fallbackSort(final BZip2CompressorOutputStream.Data data,\n+                            final int last) {\n+        data.block[0] = data.block[last + 1];\n+        fallbackSort(data.fmap, data.block, last + 1);\n+        for (int i = 0; i < last + 1; i++) {\n+            --data.fmap[i];\n+        }\n+        for (int i = 0; i < last + 1; i++) {\n+            if (data.fmap[i] == -1) {\n+                data.fmap[i] = last;\n+                break;\n+            }\n+        }\n     }\n \n /*---------------------------------------------*/\n     }\n \n     /*\n-     * The C code uses an array of ints to represents the bucket-start\n-     * flags (bhtab).  It also contains optimizations to skip over 32\n-     * consecutively set or consecutively unset bits on word\n-     * boundaries at once.  For now I've chosen to use the simpler but\n-     * potentially slower code using BitSet - also in the hope that\n-     * using the BitSet#nextXXX methods may be fast enough.\n+     * The C code uses an array of ints (each int holding 32 flags) to\n+     * represents the bucket-start flags (bhtab).  It also contains\n+     * optimizations to skip over 32 consecutively set or\n+     * consecutively unset bits on word boundaries at once.  For now\n+     * I've chosen to use the simpler but potentially slower code\n+     * using BitSet - also in the hope that using the BitSet#nextXXX\n+     * methods may be fast enough.\n      */\n \n     /**\n      * @param off offset of first byte to sort in block\n      */\n     final void fallbackSort(int[] fmap, byte[] block, int nblock) {\n-        int[] ftab = new int[257];\n+        final int[] ftab = new int[257];\n         int H, i, j, k, l, r, cc, cc1;\n         int nNotDone;\n         int nBhtab;\n-\n+        final int[] eclass = getEclass();\n+\n+        for (i = 0; i < nblock; i++) {\n+            eclass[i] = 0;\n+        }\n         /*--\n           LBZ2: Initial 1-char radix sort to generate\n           initial fmap and initial BH bits.\n           --*/\n-        for (i = 0; i < nblock; i++) ftab[block[i] & 0xff]++;\n+        for (i = 0; i < nblock; i++) {\n+            ftab[block[i] & 0xff]++;\n+        }\n         for (i = 1; i < 257;    i++) ftab[i] += ftab[i - 1];\n \n         for (i = 0; i < nblock; i++) {\n             bhtab.clear(nblock + 2 * i + 1);\n         }\n \n-        eclass = getEclass();\n-\n         /*-- LBZ2: the log(N) loop --*/\n         H = 1;\n         while (true) {\n \n                 /*-- LBZ2: find the next non-singleton bucket --*/\n                 k = r + 1;\n-                k = bhtab.nextSetBit(k);\n+                k = bhtab.nextClearBit(k);\n                 l = k - 1;\n                 if (l >= nblock) break;\n-                k = bhtab.nextClearBit(k);\n+                k = bhtab.nextSetBit(k + 1);\n                 r = k - 1;\n                 if (r >= nblock) break;\n \n     private static final int SETMASK = (1 << 21);\n     private static final int CLEARMASK = (~SETMASK);\n \n-    private void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n-                          final int lastShadow) {\n+    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n+                        final int lastShadow) {\n         final int[] runningOrder = this.mainSort_runningOrder;\n         final int[] copy = this.mainSort_copy;\n         final boolean[] bigDone = this.mainSort_bigDone;\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n         0, 1, 7, 6, 8, 2, 3, 5, 4\n     };\n \n+    private static final byte[] FIXTURE2 = { \n+        'C', 'o', 'm', 'm', 'o', 'n', 's', ' ', 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', \n+    };\n+\n+    private static final byte[] FIXTURE2_BWT = {\n+        's', 's', ' ', 'r', 'o', 'm', 'o', 'o', 'C', 'C', 'm', 'm', 'p', 'n', 's', 'e', \n+    };\n+\n     @Test\n     public void testSortFixture() {\n-        BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n-        System.arraycopy(FIXTURE, 0, data.block, 1, FIXTURE.length);\n-        BlockSort s = new BlockSort(data);\n-        assertFalse(s.blockSort(data, FIXTURE.length - 1));\n-        assertEquals(FIXTURE[FIXTURE.length - 1], data.block[0]);\n-        for (int i = 0; i < FIXTURE.length; i++) {\n-            assertEquals(FIXTURE_BWT[i], data.block[data.fmap[i]]);\n-        }\n-        assertEquals(0, data.origPtr);\n+        DS ds = setUpFixture();\n+        assertFalse(ds.s.blockSort(ds.data, FIXTURE.length - 1));\n+        assertFixtureSorted(ds.data);\n+        assertEquals(0, ds.data.origPtr);\n+    }\n+\n+    @Test\n+    public void testSortFixtureMainSort() {\n+        DS ds = setUpFixture();\n+        ds.s.mainSort(ds.data, FIXTURE.length - 1);\n+        assertFixtureSorted(ds.data);\n+    }\n+\n+    @Test\n+    public void testSortFixtureFallbackSort() {\n+        DS ds = setUpFixture();\n+        ds.s.fallbackSort(ds.data, FIXTURE.length - 1);\n+        assertFixtureSorted(ds.data);\n+    }\n+\n+    @Test\n+    public void testSortFixture2() {\n+        DS ds = setUpFixture2();\n+        assertFalse(ds.s.blockSort(ds.data, FIXTURE2.length - 1));\n+        assertFixture2Sorted(ds.data);\n+        assertEquals(1, ds.data.origPtr);\n+    }\n+\n+    @Test\n+    public void testSortFixture2MainSort() {\n+        DS ds = setUpFixture2();\n+        ds.s.mainSort(ds.data, FIXTURE2.length - 1);\n+        assertFixture2Sorted(ds.data);\n+    }\n+\n+    @Test\n+    public void testSortFixture2FallbackSort() {\n+        DS ds = setUpFixture2();\n+        ds.s.fallbackSort(ds.data, FIXTURE2.length - 1);\n+        assertFixture2Sorted(ds.data);\n     }\n \n     @Test\n         s.fallbackSort(fmap, FIXTURE, FIXTURE.length);\n         assertArrayEquals(FIXTURE_SORTED, fmap);\n     }\n+\n+    private DS setUpFixture() {\n+        return setUpFixture(FIXTURE);\n+    }\n+\n+    private void assertFixtureSorted(BZip2CompressorOutputStream.Data data) {\n+        assertFixtureSorted(data, FIXTURE, FIXTURE_BWT);\n+    }\n+\n+    private DS setUpFixture2() {\n+        return setUpFixture(FIXTURE2);\n+    }\n+\n+    private void assertFixture2Sorted(BZip2CompressorOutputStream.Data data) {\n+        assertFixtureSorted(data, FIXTURE2, FIXTURE2_BWT);\n+    }\n+\n+    private DS setUpFixture(byte[] fixture) {\n+        BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n+        System.arraycopy(fixture, 0, data.block, 1, fixture.length);\n+        return new DS(data, new BlockSort(data));\n+    }\n+\n+    private void assertFixtureSorted(BZip2CompressorOutputStream.Data data,\n+                                     byte[] fixture, byte[] fixtureBwt) {\n+        assertEquals(fixture[fixture.length - 1], data.block[0]);\n+        for (int i = 0; i < fixture.length; i++) {\n+            assertEquals(fixtureBwt[i], data.block[data.fmap[i]]);\n+        }\n+    }\n+\n+    private static class DS {\n+        private final BZip2CompressorOutputStream.Data data;\n+        private final BlockSort s;\n+        DS(BZip2CompressorOutputStream.Data data, BlockSort s) {\n+            this.data = data;\n+            this.s = s;\n+        }\n+    }\n }", "timestamp": 1337537076, "metainfo": ""}