{"sha": "2916d38e0135a8ddaedc2b319587078d7baa52d5", "log": "merge collected changes from trunk  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n  * \n  * This specifies that an ar archive entry header contains 60 bytes.\n  * \n- * Due to the limitation of the file name length to 16 bytes GNU and BSD has\n- * their own variants of this format. This formats are currently not supported\n- * and file names with a bigger size than 16 bytes are not possible at the\n- * moment.\n+ * Due to the limitation of the file name length to 16 bytes GNU and\n+ * BSD has their own variants of this format. Currently Commons\n+ * Compress can read but not write the GNU variant and doesn't support\n+ * the BSD variant at all.\n  * \n  * @see http://www.freebsd.org/cgi/man.cgi?query=ar&sektion=5\n  *\n     /**\n      * SVR4/GNU adds a trailing / to names; BSD does not.\n      * They also vary in how names longer than 16 characters are represented.\n-     * (Not yet supported by this implementation)\n+     * (Not yet fully supported by this implementation)\n      */\n     private final String name;\n     private final int userId;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n package org.apache.commons.compress.archivers.tar;\n \n import java.io.File;\n+import java.nio.ByteBuffer;\n import java.util.Date;\n import java.util.Locale;\n \n  * New-style GNU tar files are slightly different from the above.\n  * </pre>\n  * \n+ * <p>\n+ * The C structure for a old GNU Tar Entry's header is:\n+ * <pre>\n+ * struct oldgnu_header {\n+ * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n+ * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n+ * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n+ * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n+ * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n+ * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n+ * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n+ * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n+ * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n+ * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ *\n  * @NotThreadSafe\n  */\n \n \n     /** The entry's minor device number. */\n     private int devMinor;\n+\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /** The entry's real size in case of a sparse file. */\n+    private long realSize;\n \n     /** The entry's file reference */\n     private File file;\n     public TarArchiveEntry(File file) {\n         this(file, normalizeFileName(file.getPath(), false));\n     }\n-    \n+\n     /**\n      * Construct an entry for a file. File is set to file, and the\n      * header is constructed from information from the file.\n             if (nameLength == 0 || fileName.charAt(nameLength - 1) != '/') {\n                 this.name = fileName + \"/\";\n             } else {\n-                this.name = fileName;                \n+                this.name = fileName;\n             }\n             this.size = 0;\n         } else {\n         this.size = size;\n     }\n \n+    /**\n+     * Indicates in case of a sparse file if an extension sparse header\n+     * follows.\n+     *\n+     * @return true if an extension sparse header follows.\n+     */\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+\n+    /**\n+     * Get this entry's real file size in case of a sparse file.\n+     *\n+     * @return This entry's real file size.\n+     */\n+    public long getRealSize() {\n+        return realSize;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU sparse block \n+     *\n+     * @return true if this is a sparse extension provided by GNU tar\n+     */\n+    public boolean isGNUSparse() {\n+        return linkFlag == LF_GNUTYPE_SPARSE;\n+    }\n \n     /**\n      * Indicate if this entry is a GNU long name block\n         offset += DEVLEN;\n         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n         offset += DEVLEN;\n-        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n-        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n-        if (isDirectory() && !name.endsWith(\"/\")){\n-            name = name + \"/\";\n-        }\n-        if (prefix.length() >0){\n-            name = prefix + \"/\" + name;\n+\n+        int type = evaluateType(header);\n+        switch (type) {\n+        case FORMAT_OLDGNU: {\n+            offset += ATIMELEN_GNU;\n+            offset += CTIMELEN_GNU;\n+            offset += OFFSETLEN_GNU;\n+            offset += LONGNAMESLEN_GNU;\n+            offset += PAD2LEN_GNU;\n+            offset += SPARSELEN_GNU;\n+            isExtended = TarUtils.parseBoolean(header, offset);\n+            offset += ISEXTENDEDLEN_GNU;\n+            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n+            offset += REALSIZELEN_GNU;\n+            break;\n+        }\n+        case FORMAT_POSIX:\n+        default: {\n+            String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n+            // SunOS tar -E does not add / to directory names, so fix\n+            // up to be consistent\n+            if (isDirectory() && !name.endsWith(\"/\")){\n+                name = name + \"/\";\n+            }\n+            if (prefix.length() > 0){\n+                name = prefix + \"/\" + name;\n+            }\n+        }\n         }\n     }\n \n         }\n         return fileName;\n     }\n+\n+    /**\n+     * Evaluate an entry's header format from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to evaluate the format for.\n+     * @return format type\n+     */\n+    private int evaluateType(byte[] header) {\n+        final ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\n+        if (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\n+            return FORMAT_OLDGNU;\n+        if (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\n+            return FORMAT_POSIX;\n+        return 0;\n+    }\n }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             readBuf = null;\n         }\n \n-        byte[] headerBuf = buffer.readRecord();\n-\n-        if (headerBuf == null) {\n-            hasHitEOF = true;\n-        } else if (buffer.isEOFRecord(headerBuf)) {\n-            hasHitEOF = true;\n-        }\n+        byte[] headerBuf = getRecord();\n \n         if (hasHitEOF) {\n             currEntry = null;\n-        } else {\n-            currEntry = new TarArchiveEntry(headerBuf);\n-            entryOffset = 0;\n-            entrySize = currEntry.getSize();\n-        }\n-\n-        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n+            return null;\n+        }\n+\n+        currEntry = new TarArchiveEntry(headerBuf);\n+        entryOffset = 0;\n+        entrySize = currEntry.getSize();\n+\n+        if (currEntry.isGNULongNameEntry()) {\n             // read in the name\n             StringBuffer longName = new StringBuffer();\n             byte[] buf = new byte[SMALL_BUFFER_SIZE];\n             currEntry.setName(longName.toString());\n         }\n \n-        if (currEntry != null && currEntry.isPaxHeader()){ // Process Pax headers\n+        if (currEntry.isPaxHeader()){ // Process Pax headers\n             paxHeaders();\n         }\n \n+        if (currEntry.isGNUSparse()){ // Process sparse files\n+            readGNUSparse();\n+        }\n+\n         return currEntry;\n+    }\n+\n+    /**\n+     * Get the next record in this tar archive. This will skip\n+     * over any remaining data in the current entry, if there\n+     * is one, and place the input stream at the header of the\n+     * next entry.\n+     * If there are no more entries in the archive, null will\n+     * be returned to indicate that the end of the archive has\n+     * been reached.\n+     *\n+     * @return The next header in the archive, or null.\n+     * @throws IOException on error\n+     */\n+    private byte[] getRecord() throws IOException {\n+        if (hasHitEOF) {\n+            return null;\n+        }\n+\n+        byte[] headerBuf = buffer.readRecord();\n+\n+        if (headerBuf == null) {\n+            hasHitEOF = true;\n+        } else if (buffer.isEOFRecord(headerBuf)) {\n+            hasHitEOF = true;\n+        }\n+\n+        return hasHitEOF ? null : headerBuf;\n     }\n \n     private void paxHeaders() throws IOException{\n         }\n     }\n \n+    /**\n+     * Adds the sparse chunks from the current entry to the sparse chunks,\n+     * including any additional sparse entries following the current entry.\n+     * \n+     * @throws IOException on error \n+     * \n+     * @todo Sparse files get not yet really processed. \n+     */\n+    private void readGNUSparse() throws IOException {\n+        /* we do not really process sparse files yet\n+        sparses = new ArrayList();\n+        sparses.addAll(currEntry.getSparses());\n+        */\n+        if (currEntry.isExtended()) {\n+            TarArchiveSparseEntry entry;\n+            do {\n+                byte[] headerBuf = getRecord();\n+                if (hasHitEOF) {\n+                    currEntry = null;\n+                    break;\n+                }\n+                entry = new TarArchiveSparseEntry(headerBuf);\n+                /* we do not really process sparse files yet\n+                sparses.addAll(entry.getSparses());\n+                */\n+            } while (entry.isExtended());\n+        }\n+    }\n+\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextTarEntry();\n     }\n         entryOffset += totalRead;\n \n         return totalRead;\n+    }\n+\n+    /**\n+     * Whether this class is able to read the given entry.\n+     *\n+     * <p>May return false if the current entry is a sparse file.</p>\n+     */\n+    public boolean canReadEntryData(ArchiveEntry ae) {\n+        if (ae instanceof TarArchiveEntry) {\n+            TarArchiveEntry te = (TarArchiveEntry) ae;\n+            return !te.isGNUSparse();\n+        }\n+        return false;\n     }\n \n     protected final TarArchiveEntry getCurrentEntry() {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class represents a sparse entry in a Tar archive.\n+ *\n+ * <p>\n+ * The C structure for a sparse entry is:\n+ * <pre>\n+ * struct posix_header {\n+ * struct sparse sp[21]; // TarConstants.SPARSELEN_GNU_SPARSE     - offset 0\n+ * char isextended;      // TarConstants.ISEXTENDEDLEN_GNU_SPARSE - offset 504\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ */\n+\n+public class TarArchiveSparseEntry implements TarConstants {\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @throws IOException on unknown format\n+     */\n+    public TarArchiveSparseEntry(byte[] headerBuf) throws IOException {\n+        int offset = 0;\n+        offset += SPARSELEN_GNU_SPARSE;\n+        isExtended = TarUtils.parseBoolean(headerBuf, offset);\n+    }\n+\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n /**\n  * This interface contains all the definitions used in the package.\n  *\n+ * For tar formats (FORMAT_OLDGNU, FORMAT_POSIX, etc.) see GNU tar\n+ * <I>tar.h</I> type <I>enum archive_format</I>\n  */\n // CheckStyle:InterfaceIsTypeCheck OFF (bc)\n public interface TarConstants {\n \n     /**\n+     * GNU format as per before tar 1.12.\n+     */\n+    int    FORMAT_OLDGNU = 2;\n+\n+    /**\n+     * Pure Posix format.\n+     */\n+    int    FORMAT_POSIX = 3;\n+\n+    /**\n      * The length of the name field in a header buffer.\n      */\n     int    NAMELEN = 100;\n     int    PREFIXLEN = 155;\n \n     /**\n+     * The length of the access time field in an old GNU header buffer.\n+     * \n+     */\n+    int    ATIMELEN_GNU = 12;\n+\n+    /**\n+     * The length of the created time field in an old GNU header buffer.\n+     * \n+     */\n+    int    CTIMELEN_GNU = 12;\n+\n+    /**\n+     * The length of the multivolume start offset field in an old GNU header buffer. \n+     * \n+     */\n+    int    OFFSETLEN_GNU = 12;\n+\n+    /**\n+     * The length of the long names field in an old GNU header buffer. \n+     * \n+     */\n+    int    LONGNAMESLEN_GNU = 4;\n+\n+    /**\n+     * The length of the padding field in an old GNU header buffer. \n+     * \n+     */\n+    int    PAD2LEN_GNU = 1;\n+\n+    /**\n+     * The sum of the length of all sparse headers in an old GNU header buffer. \n+     * \n+     */\n+    int    SPARSELEN_GNU = 96;\n+\n+    /**\n+     * The length of the is extension field in an old GNU header buffer. \n+     * \n+     */\n+    int    ISEXTENDEDLEN_GNU = 1;\n+\n+    /**\n+     * The length of the real size field in an old GNU header buffer. \n+     * \n+     */\n+    int    REALSIZELEN_GNU = 12;\n+\n+    /**\n+     * The sum of the length of all sparse headers in a sparse header buffer. \n+     * \n+     */\n+    int    SPARSELEN_GNU_SPARSE = 504;\n+\n+    /**\n+     * The length of the is extension field in a sparse header buffer. \n+     * \n+     */\n+    int    ISEXTENDEDLEN_GNU_SPARSE = 1;\n+\n+    /**\n      * LF_ constants represent the \"link flag\" of an entry, or more commonly,\n      * the \"entry type\". This is the \"old way\" of indicating a normal file.\n      */\n      * Identifies the *next* file on the tape as having a long name.\n      */\n     byte LF_GNUTYPE_LONGNAME = (byte) 'L';\n+\n+    /**\n+     * Sparse file type.\n+     * @since Apache Commons Compress 1.1.1\n+     */\n+    byte LF_GNUTYPE_SPARSE = (byte) 'S';\n \n     // See \"http://www.opengroup.org/onlinepubs/009695399/utilities/pax.html#tag_04_100_13_02\"\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n         return result;\n     }\n \n+    /**\n+     * Parse a boolean byte from a buffer.\n+     * Leading spaces and NUL are ignored.\n+     * The buffer may contain trailing spaces or NULs.\n+     *\n+     * @param buffer The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The maximum number of bytes to parse - must be at least 1 byte.\n+     * @return The boolean value of the bytes.\n+     * @throws IllegalArgumentException if an invalid byte is detected.\n+     */\n+    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n+        return (buffer[offset] == 1);\n+    }\n+\n     // Helper method to generate the exception message\n     private static String exceptionMessage(byte[] buffer, final int offset,\n             final int length, int current, final byte currentByte) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n+    private byte[] rawName = null;\n     private GeneralPurposeBit gpb = new GeneralPurposeBit();\n \n     /**\n             throw new IllegalArgumentException(\"invalid entry size\");\n         }\n         this.size = size;\n+    }\n+\n+    /**\n+     * Package private setter that sets the name using the raw bytes\n+     * and the string created from it by guessing or suing the\n+     * configured encoding.\n+     */\n+    void setName(String name, byte[] rawName) {\n+        setName(name);\n+        this.rawName = rawName;\n+    }\n+\n+    /**\n+     * Returns the raw bytes that made up the name before it has been\n+     * converted using the configured or guessed encoding.\n+     *\n+     * <p>This method will return null if this instance has not been\n+     * read from an archive.</p>\n+     *\n+     * @since Apache Commons Compress 1.2\n+     */\n+    public byte[] getRawName() {\n+        if (rawName != null) {\n+            byte[] b = new byte[rawName.length];\n+            System.arraycopy(rawName, 0, b, 0, rawName.length);\n+            return b;\n+        }\n+        return null;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n \n         byte[] fileName = new byte[fileNameLen];\n         readFully(fileName);\n-        current.setName(entryEncoding.decode(fileName));\n+        current.setName(entryEncoding.decode(fileName), fileName);\n \n         byte[] extraData = new byte[extraLen];\n         readFully(extraData);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n \n             byte[] fileName = new byte[fileNameLen];\n             archive.readFully(fileName);\n-            ze.setName(entryEncoding.decode(fileName));\n+            ze.setName(entryEncoding.decode(fileName), fileName);\n \n             // LFH offset,\n             OffsetEntry offset = new OffsetEntry();\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n         }\n     }\n \n+    public void testRawNameReadFromZipFile()\n+        throws IOException, URISyntaxException {\n+        URL zip = getClass().getResource(\"/utf8-7zip-test.zip\");\n+        File archive = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(archive, CP437, false);\n+            assertRawNameOfAcsiiTxt(zf.getEntry(ASCII_TXT));\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n+    public void testRawNameReadFromStream()\n+        throws IOException, URISyntaxException {\n+        URL zip = getClass().getResource(\"/utf8-7zip-test.zip\");\n+        FileInputStream archive =\n+            new FileInputStream(new File(new URI(zip.toString())));\n+        ZipArchiveInputStream zi = null;\n+        try {\n+            zi = new ZipArchiveInputStream(archive, CP437, false);\n+            assertRawNameOfAcsiiTxt((ZipArchiveEntry) zi.getNextEntry());\n+        } finally {\n+            if (zi != null) {\n+                zi.close();\n+            }\n+        }\n+    }\n+\n     private static void testFileRoundtrip(String encoding, boolean withEFS,\n                                           boolean withExplicitUnicodeExtra)\n         throws IOException {\n \n     }\n \n+    private static void assertRawNameOfAcsiiTxt(ZipArchiveEntry ze) {\n+        byte[] b = ze.getRawName();\n+        assertNotNull(b);\n+        final int len = ASCII_TXT.length();\n+        assertEquals(len, b.length);\n+        for (int i = 0; i < len; i++) {\n+            assertEquals(\"Byte \" + i, (byte) ASCII_TXT.charAt(i), b[i]);\n+        }\n+        assertNotSame(b, ze.getRawName());\n+    }\n }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     private int method = -1;\n \n+    /**\n+     * The {@link java.util.zip.ZipEntry#setSize} method in the base\n+     * class throws an IllegalArgumentException if the size is bigger\n+     * than 2GB for Java versions < 7.  Need to keep our own size\n+     * information for Zip64 support.\n+     */\n+    private long size = SIZE_UNKNOWN;\n+\n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n             setExtra();\n         }\n         setMethod(entry.getMethod());\n+        this.size = entry.getSize();\n     }\n \n     /**\n      */\n     protected void setName(String name) {\n         this.name = name;\n+    }\n+\n+    /**\n+     * Gets the uncompressed size of the entry data.\n+     * @return the entry size\n+     */\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Sets the uncompressed size of the entry data.\n+     * @param size the uncompressed size in bytes\n+     * @exception IllegalArgumentException if the specified size is less\n+     *            than 0\n+     */\n+    public void setSize(long size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"invalid entry size\");\n+        }\n+        this.size = size;\n     }\n \n     /**", "timestamp": 1311398457, "metainfo": ""}