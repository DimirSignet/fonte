{"sha": "04e132b74b62cac7bb2d171825d5975e4fbfc155", "log": "separate state of stream from state of entry current being read from state of temporary buffer data is read into.  Document a few fields  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n      */\n     private final boolean useUnicodeExtraFields;\n \n+    /**\n+     * Wrapped stream, will always be a PushbackInputStream.\n+     */\n     private final InputStream in;\n \n+    /**\n+     * Inflater used for all deflated entries.\n+     */\n     private final Inflater inf = new Inflater(true);\n+\n+    /**\n+     * Calculates checkusms for all entries.\n+     */\n     private final CRC32 crc = new CRC32();\n \n-    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n-\n-    private ZipArchiveEntry current = null;\n+    /**\n+     * Buffer used to read from the wrapped stream.\n+     */\n+    private final Buffer buf = new Buffer();\n+    /**\n+     * The entry that is currently being read.\n+     */\n+    private CurrentEntry current = null;\n+    /**\n+     * Whether the stream has been closed.\n+     */\n     private boolean closed = false;\n+    /**\n+     * Whether the stream has reached the central directory - and thus\n+     * found all entries.\n+     */\n     private boolean hitCentralDirectory = false;\n-    private int offsetInBuffer = 0;\n-    private long readBytesOfEntry = 0, bytesReadFromStream = 0;\n-    private int lengthOfLastRead = 0;\n-    private boolean hasDataDescriptor = false;\n-    private boolean usesZip64 = false;\n+    /**\n+     * When reading a stored entry that uses the data descriptor this\n+     * stream has to read the full entry and caches it.  This is the\n+     * cache.\n+     */\n     private ByteArrayInputStream lastStoredEntry = null;\n \n+    /**\n+     * Whether the stream will try to read STORED entries that use a\n+     * data descriptor.\n+     */\n     private boolean allowStoredEntriesWithDataDescriptor = false;\n \n     private static final int LFH_LEN = 30;\n                                  boolean allowStoredEntriesWithDataDescriptor) {\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        in = new PushbackInputStream(inputStream, buf.length);\n+        in = new PushbackInputStream(inputStream, buf.buf.length);\n         this.allowStoredEntriesWithDataDescriptor =\n             allowStoredEntriesWithDataDescriptor;\n     }\n         }\n \n         int off = WORD;\n-        current = new ZipArchiveEntry();\n+        current = new CurrentEntry();\n \n         int versionMadeBy = ZipShort.getValue(lfh, off);\n         off += SHORT;\n-        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n-                            & ZipFile.NIBLET_MASK);\n+        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n+                                  & ZipFile.NIBLET_MASK);\n \n         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-        hasDataDescriptor = gpFlag.usesDataDescriptor();\n-        current.setGeneralPurposeBit(gpFlag);\n+        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n+        current.entry.setGeneralPurposeBit(gpFlag);\n \n         off += SHORT;\n \n-        current.setMethod(ZipShort.getValue(lfh, off));\n+        current.entry.setMethod(ZipShort.getValue(lfh, off));\n         off += SHORT;\n \n         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n-        current.setTime(time);\n+        current.entry.setTime(time);\n         off += WORD;\n \n         ZipLong size = null, cSize = null;\n-        if (!hasDataDescriptor) {\n-            current.setCrc(ZipLong.getValue(lfh, off));\n+        if (!current.hasDataDescriptor) {\n+            current.entry.setCrc(ZipLong.getValue(lfh, off));\n             off += WORD;\n \n             cSize = new ZipLong(lfh, off);\n \n         byte[] fileName = new byte[fileNameLen];\n         readFully(fileName);\n-        current.setName(entryEncoding.decode(fileName), fileName);\n+        current.entry.setName(entryEncoding.decode(fileName), fileName);\n \n         byte[] extraData = new byte[extraLen];\n         readFully(extraData);\n-        current.setExtra(extraData);\n+        current.entry.setExtra(extraData);\n \n         if (!hasUTF8Flag && useUnicodeExtraFields) {\n-            ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n+            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\n+                                                     null);\n         }\n \n         Zip64ExtendedInformationExtraField z64 =  \n             (Zip64ExtendedInformationExtraField)\n-            current.getExtraField(Zip64ExtendedInformationExtraField\n-                                  .HEADER_ID);\n-        usesZip64 = z64 != null;\n-        if (!hasDataDescriptor) {\n-            if (usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\n-                              || size.equals(ZipLong.ZIP64_MAGIC))\n+            current.entry.getExtraField(Zip64ExtendedInformationExtraField\n+                                        .HEADER_ID);\n+        current.usesZip64 = z64 != null;\n+        if (!current.hasDataDescriptor) {\n+            if (current.usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\n+                                      || size.equals(ZipLong.ZIP64_MAGIC))\n                 ) {\n-                current.setCompressedSize(z64.getCompressedSize()\n-                                          .getLongValue());\n-                current.setSize(z64.getSize().getLongValue());\n+                current.entry.setCompressedSize(z64.getCompressedSize()\n+                                                .getLongValue());\n+                current.entry.setSize(z64.getSize().getLongValue());\n             } else {\n-                current.setCompressedSize(cSize.getValue());\n-                current.setSize(size.getValue());\n-            }\n-        }\n-        return current;\n+                current.entry.setCompressedSize(cSize.getValue());\n+                current.entry.setSize(size.getValue());\n+            }\n+        }\n+        return current.entry;\n     }\n \n     /** {@inheritDoc} */\n         // avoid int overflow, check null buffer\n         if (start <= buffer.length && length >= 0 && start >= 0\n             && buffer.length - start >= length) {\n-            ZipUtil.checkRequestedFeatures(current);\n-            if (!supportsDataDescriptorFor(current)) {\n+            ZipUtil.checkRequestedFeatures(current.entry);\n+            if (!supportsDataDescriptorFor(current.entry)) {\n                 throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException\n                                                          .Feature\n                                                          .DATA_DESCRIPTOR,\n-                                                         current);\n-            }\n-\n-            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n-                if (hasDataDescriptor) {\n+                                                         current.entry);\n+            }\n+\n+            if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+                if (current.hasDataDescriptor) {\n                     if (lastStoredEntry == null) {\n                         readStoredEntry();\n                     }\n                     return lastStoredEntry.read(buffer, start, length);\n                 }\n \n-                long csize = current.getSize();\n-                if (readBytesOfEntry >= csize) {\n+                long csize = current.entry.getSize();\n+                if (current.bytesRead >= csize) {\n                     return -1;\n                 }\n-                if (offsetInBuffer >= lengthOfLastRead) {\n-                    offsetInBuffer = 0;\n-                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n+                if (buf.offsetInBuffer >= buf.lengthOfLastRead) {\n+                    buf.offsetInBuffer = 0;\n+                    if ((buf.lengthOfLastRead = in.read(buf.buf)) == -1) {\n                         return -1;\n                     }\n-                    count(lengthOfLastRead);\n-                    bytesReadFromStream += lengthOfLastRead;\n-                }\n-                int toRead = length > lengthOfLastRead\n-                    ? lengthOfLastRead - offsetInBuffer\n+                    count(buf.lengthOfLastRead);\n+                    current.bytesReadFromStream += buf.lengthOfLastRead;\n+                }\n+                int toRead = length > buf.lengthOfLastRead\n+                    ? buf.lengthOfLastRead - buf.offsetInBuffer\n                     : length;\n-                if ((csize - readBytesOfEntry) < toRead) {\n+                if ((csize - current.bytesRead) < toRead) {\n                     // if it is smaller than toRead then it fits into an int\n-                    toRead = (int) (csize - readBytesOfEntry);\n-                }\n-                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n-                offsetInBuffer += toRead;\n-                readBytesOfEntry += toRead;\n+                    toRead = (int) (csize - current.bytesRead);\n+                }\n+                System.arraycopy(buf.buf, buf.offsetInBuffer, buffer, start,\n+                                 toRead);\n+                buf.offsetInBuffer += toRead;\n+                current.bytesRead += toRead;\n                 crc.update(buffer, start, toRead);\n                 return toRead;\n             }\n \n             if (inf.needsInput()) {\n                 fill();\n-                if (lengthOfLastRead > 0) {\n-                    bytesReadFromStream += lengthOfLastRead;\n+                if (buf.lengthOfLastRead > 0) {\n+                    current.bytesReadFromStream += buf.lengthOfLastRead;\n                 }\n             }\n             int read = 0;\n             if (read == 0) {\n                 if (inf.finished()) {\n                     return -1;\n-                } else if (lengthOfLastRead == -1) {\n+                } else if (buf.lengthOfLastRead == -1) {\n                     throw new IOException(\"Truncated ZIP file\");\n                 }\n             }\n         }\n \n         // Ensure all entry bytes are read\n-        if (bytesReadFromStream <= current.getCompressedSize()\n-                && !hasDataDescriptor) {\n-            long remaining = current.getCompressedSize() - bytesReadFromStream;\n+        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n+                && !current.hasDataDescriptor) {\n+            long remaining = current.entry.getCompressedSize()\n+                - current.bytesReadFromStream;\n             while (remaining > 0) {\n-                long n = in.read(buf, 0, (int) Math.min(buf.length, remaining));\n+                long n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\n+                                                            remaining));\n                 if (n < 0) {\n                     throw new EOFException(\n-                            \"Truncated ZIP entry: \" + current.getName());\n+                            \"Truncated ZIP entry: \" + current.entry.getName());\n                 } else {\n                     count(n);\n                     remaining -= n;\n             skip(Long.MAX_VALUE);\n \n             long inB;\n-            if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+            if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n                 inB = inf.getBytesRead();\n             } else {\n-                inB = readBytesOfEntry;\n+                inB = current.bytesRead;\n             }\n \n             // this is at most a single read() operation and can't\n             // exceed the range of int\n-            int diff = (int) (bytesReadFromStream - inB);\n+            int diff = (int) (current.bytesReadFromStream - inB);\n \n             // Pushback any required bytes\n             if (diff > 0) {\n-                pushback(buf, lengthOfLastRead - diff, diff);\n-            }\n-        }\n-\n-        if (lastStoredEntry == null && hasDataDescriptor) {\n+                pushback(buf.buf, buf.lengthOfLastRead - diff, diff);\n+            }\n+        }\n+\n+        if (lastStoredEntry == null && current.hasDataDescriptor) {\n             readDataDescriptor();\n         }\n \n         inf.reset();\n-        readBytesOfEntry = bytesReadFromStream = 0L;\n-        offsetInBuffer = lengthOfLastRead = 0;\n+        buf.reset();\n         crc.reset();\n         current = null;\n         lastStoredEntry = null;\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        if ((lengthOfLastRead = in.read(buf)) > 0) {\n-            count(lengthOfLastRead);\n-            inf.setInput(buf, 0, lengthOfLastRead);\n+        if ((buf.lengthOfLastRead = in.read(buf.buf)) > 0) {\n+            count(buf.lengthOfLastRead);\n+            inf.setInput(buf.buf, 0, buf.lengthOfLastRead);\n         }\n     }\n \n             readFully(b);\n             val = new ZipLong(b);\n         }\n-        current.setCrc(val.getValue());\n+        current.entry.setCrc(val.getValue());\n \n         // if there is a ZIP64 extra field, sizes are eight bytes\n         // each, otherwise four bytes each.  Unfortunately some\n         if (potentialSig.equals(ZipLong.CFH_SIG)\n             || potentialSig.equals(ZipLong.LFH_SIG)) {\n             pushback(b, DWORD, DWORD);\n-            current.setCompressedSize(ZipLong.getValue(b));\n-            current.setSize(ZipLong.getValue(b, WORD));\n+            current.entry.setCompressedSize(ZipLong.getValue(b));\n+            current.entry.setSize(ZipLong.getValue(b, WORD));\n         } else {\n-            current.setCompressedSize(ZipEightByteInteger.getLongValue(b));\n-            current.setSize(ZipEightByteInteger.getLongValue(b, DWORD));\n+            current.entry\n+                .setCompressedSize(ZipEightByteInteger.getLongValue(b));\n+            current.entry.setSize(ZipEightByteInteger.getLongValue(b, DWORD));\n         }\n     }\n \n         boolean done = false;\n \n         // length of DD without signature\n-        int ddLen = usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n+        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n \n         while (!done) {\n-            int r = in.read(buf, off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n+            int r = in.read(buf.buf, off,\n+                            ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                 // read the whole archive without ever finding a\n                 // central directory\n \n             int readTooMuch = 0;\n             for (int i = 0; !done && i < r - 4; i++) {\n-                if (buf[i] == LFH[0] && buf[i + 1] == LFH[1]) {\n-                    if ((buf[i + 2] == LFH[2] && buf[i + 3] == LFH[3])\n-                        || (buf[i] == CFH[2] && buf[i + 3] == CFH[3])) {\n+                if (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\n+                    if ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n+                        || (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n                         // found a LFH or CFH:\n                         readTooMuch = off + r - i - ddLen;\n                         done = true;\n                     }\n-                    else if (buf[i + 2] == DD[2] && buf[i + 3] == DD[3]) {\n+                    else if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n                         // found DD:\n                         readTooMuch = off + r - i;\n                         done = true;\n                         //   descriptor\n                         // * copy the remaining bytes to cache\n                         // * read data descriptor\n-                        pushback(buf, off + r - readTooMuch, readTooMuch);\n-                        bos.write(buf, 0, i);\n+                        pushback(buf.buf, off + r - readTooMuch, readTooMuch);\n+                        bos.write(buf.buf, 0, i);\n                         readDataDescriptor();\n                     }\n                 }\n                 // save the last ddLen + 3 bytes in the buffer, cache\n                 // anything in front of that, read on\n                 if (off + r > ddLen + 3) {\n-                    bos.write(buf, 0, off + r - ddLen - 3);\n-                    System.arraycopy(buf, off + r - ddLen - 3, buf, 0,\n+                    bos.write(buf.buf, 0, off + r - ddLen - 3);\n+                    System.arraycopy(buf.buf, off + r - ddLen - 3, buf.buf, 0,\n                                      ddLen + 3);\n                     off = ddLen + 3;\n                 } else {\n         ((PushbackInputStream) in).unread(buf, offset, length);\n         pushedBackBytes(length);\n     }\n+\n+    /**\n+     * Structure collecting information for the entry that is\n+     * currently being read.\n+     */\n+    private static final class CurrentEntry {\n+        /**\n+         * Current ZIP entry.\n+         */\n+        private final ZipArchiveEntry entry = new ZipArchiveEntry();\n+        /**\n+         * Does the entry use a data descriptor?\n+         */\n+        private boolean hasDataDescriptor;\n+        /**\n+         * Does the entry have a ZIP64 extended information extra field.\n+         */\n+        private boolean usesZip64;\n+        /**\n+         * Number of bytes of entry content read by the client if the\n+         * entry is STORED.\n+         */\n+        private long bytesRead;\n+        /**\n+         * Number of bytes of entry content read so from the stream.\n+         *\n+         * <p>This may be more than the actual entry's length as some\n+         * stuff gets buffered up and needs to be pushed back when the\n+         * end of the entry has been reached.</p>\n+         */\n+        private long bytesReadFromStream;\n+    }\n+\n+    /**\n+     * Contains a temporary buffer used to read from the wrapped\n+     * stream together with some information needed for internal\n+     * housekeeping.\n+     */\n+    private static final class Buffer {\n+        /**\n+         * Buffer used as temporary buffer when reading from the stream.\n+         */\n+        private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n+        /**\n+         * {@link #buf buf} may contain data the client hasnt read, yet,\n+         * this is the first byte that hasn't been read so far.\n+         */\n+        private int offsetInBuffer = 0;\n+        /**\n+         * Number of bytes read from the wrapped stream into {@link #buf\n+         * buf} with the last read operation.\n+         */\n+        private int lengthOfLastRead = 0;\n+        /**\n+         * Reset internal housekeeping.\n+         */\n+        private void reset() {\n+            offsetInBuffer = lengthOfLastRead = 0;\n+        }\n+    }\n }", "timestamp": 1312376913, "metainfo": ""}