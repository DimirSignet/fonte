{"sha": "80447398e04dee000215c458b88e467ac41d8c16", "log": "infrastructure that is going to be needed by ZipFile in order to correctly parse ZIP64 data from the central directory.  COMPRESS-149  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n     private ZipLong diskStart;\n \n     /**\n+     * Stored in {@link #parseFromCentralDirectoryData\n+     * parseFromCentralDirectoryData} so it can be reused when ZipFile\n+     * calls {@link #reparseCentralDirectoryData\n+     * reparseCentralDirectoryData}.\n+     *\n+     * <p>Not used for anything else</p>\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private byte[] rawCentralDirectoryData;\n+\n+    /**\n      * This constructor should only be used by the code that reads\n      * archives inside of Commons Compress.\n      */\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length)\n         throws ZipException {\n+        // store for processing in reparseCentralDirectoryData\n+        rawCentralDirectoryData = new byte[length];\n+        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n+\n         // if there is no size information in here, we are screwed and\n         // can only hope things will get resolved by LFH data later\n         // But there are some cases that can be detected\n     }\n \n     /**\n+     * Parses the raw bytes read from the central directory extra\n+     * field with knowledge which fields are expected to be there.\n+     *\n+     * <p>All four fields inside the zip64 extended information extra\n+     * field are optional and only present if their corresponding\n+     * entry inside the central directory contains the correct magic\n+     * value.</p>\n+     */\n+    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n+                                            boolean hasCompressedSize,\n+                                            boolean hasRelativeHeaderOffset,\n+                                            boolean hasDiskStart)\n+        throws ZipException {\n+        if (rawCentralDirectoryData != null) {\n+            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n+                + (hasCompressedSize ? DWORD : 0)\n+                + (hasRelativeHeaderOffset ? DWORD : 0)\n+                + (hasDiskStart ? WORD : 0);\n+            if (rawCentralDirectoryData.length != expectedLength) {\n+                throw new ZipException(\"central directory zip64 extended\"\n+                                       + \" information extra field's length\"\n+                                       + \" doesn't match central directory\"\n+                                       + \" data.  Expected length \"\n+                                       + expectedLength + \" but is \"\n+                                       + rawCentralDirectoryData.length);\n+            }\n+            int offset = 0;\n+            if (hasUncompressedSize) {\n+                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n+                offset += DWORD;\n+            }\n+            if (hasCompressedSize) {\n+                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n+                                                         offset);\n+                offset += DWORD;\n+            }\n+            if (hasRelativeHeaderOffset) {\n+                relativeHeaderOffset =\n+                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n+                offset += DWORD;\n+            }\n+            if (hasDiskStart) {\n+                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n+                offset += WORD;\n+            }\n+        }\n+    }\n+\n+    /**\n      * The uncompressed size stored in this extra field.\n      */\n     public ZipEightByteInteger getSize() {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n         assertEquals(DISK, f.getDiskStartNumber());\n     }\n \n+    public void testReparseCDSingleEightByteData() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[8];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        f.parseFromCentralDirectoryData(b, 0, b.length);\n+        f.reparseCentralDirectoryData(true, false, false, false);\n+        assertEquals(SIZE, f.getSize());\n+        assertNull(f.getCompressedSize());\n+        assertNull(f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+        f.setSize(null);\n+        f.reparseCentralDirectoryData(false, true, false, false);\n+        assertNull(f.getSize());\n+        assertEquals(SIZE, f.getCompressedSize());\n+        assertNull(f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+        f.setCompressedSize(null);\n+        f.reparseCentralDirectoryData(false, false, true, false);\n+        assertNull(f.getSize());\n+        assertNull(f.getCompressedSize());\n+        assertEquals(SIZE, f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+    }\n+\n     private static void checkSizes(byte[] b) {\n         assertEquals(0x78, b[0]);\n         assertEquals(0x56, b[1]);", "timestamp": 1312435528, "metainfo": ""}