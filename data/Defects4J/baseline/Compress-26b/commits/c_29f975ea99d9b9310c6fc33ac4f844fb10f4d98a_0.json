{"sha": "29f975ea99d9b9310c6fc33ac4f844fb10f4d98a", "log": "Replaced ZipArchiveInputStream.Buffer with a ByteBuffer  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.PushbackInputStream;\n+import java.nio.ByteBuffer;\n import java.util.zip.CRC32;\n import java.util.zip.DataFormatException;\n import java.util.zip.Inflater;\n     /**\n      * Buffer used to read from the wrapped stream.\n      */\n-    private final Buffer buf = new Buffer();\n+    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n     /**\n      * The entry that is currently being read.\n      */\n             return -1;\n         }\n \n-        if (buf.position >= buf.limit) {\n-            buf.position = 0;\n-            if ((buf.limit = in.read(buf.array)) == -1) {\n+        if (buf.position() >= buf.limit()) {\n+            buf.position(0);\n+            int l = in.read(buf.array());\n+            if (l == -1) {\n                 return -1;\n             }\n-            count(buf.limit);\n-            current.bytesReadFromStream += buf.limit;\n+            buf.limit(l);\n+\n+            count(buf.limit());\n+            current.bytesReadFromStream += buf.limit();\n         }\n \n         int toRead = Math.min(buf.remaining(), length);\n             // if it is smaller than toRead then it fits into an int\n             toRead = (int) (csize - current.bytesRead);\n         }\n-        System.arraycopy(buf.array, buf.position, buffer, start, toRead);\n-        buf.position += toRead;\n+        buf.get(buffer, start, toRead);\n         current.bytesRead += toRead;\n         crc.update(buffer, start, toRead);\n         return toRead;\n     private int readDeflated(byte[] buffer, int start, int length)\n         throws IOException {\n         int read = readFromInflater(buffer, start, length);\n-        if (read == 0) {\n+        if (read <= 0) {\n             if (inf.finished()) {\n                 return -1;\n             } else if (inf.needsDictionary()) {\n                 throw new ZipException(\"This archive needs a preset dictionary\"\n                                        + \" which is not supported by Commons\"\n                                        + \" Compress.\");\n-            } else if (buf.limit == -1) {\n+            } else if (read == -1) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n         }\n         int read = 0;\n         do {\n             if (inf.needsInput()) {\n-                fill();\n-                if (buf.limit > 0) {\n-                    current.bytesReadFromStream += buf.limit;\n+                int l = fill();\n+                if (l > 0) {\n+                    current.bytesReadFromStream += buf.limit();\n+                } else if (l == -1) {\n+                    return -1;\n                 } else {\n                     break;\n                 }\n \n             // Pushback any required bytes\n             if (diff > 0) {\n-                pushback(buf.array, buf.limit - diff, diff);\n+                pushback(buf.array(), buf.limit() - diff, diff);\n             }\n         }\n \n         }\n \n         inf.reset();\n-        buf.reset();\n+        buf.clear().flip();\n         crc.reset();\n         current = null;\n         lastStoredEntry = null;\n         long remaining = current.entry.getCompressedSize()\n             - current.bytesReadFromStream;\n         while (remaining > 0) {\n-            long n = in.read(buf.array, 0, (int) Math.min(buf.capacity(), remaining));\n+            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n                 throw new EOFException(\n                                        \"Truncated ZIP entry: \" + current.entry.getName());\n         return inB;\n     }\n \n-    private void fill() throws IOException {\n+    private int fill() throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        if ((buf.limit = in.read(buf.array)) > 0) {\n-            count(buf.limit);\n-            inf.setInput(buf.array, 0, buf.limit);\n-        }\n+        int length = in.read(buf.array());\n+        if (length > 0) {\n+            buf.limit(length);\n+            count(buf.limit());\n+            inf.setInput(buf.array(), 0, buf.limit());\n+        }\n+        return length;\n     }\n \n     private void readFully(byte[] b) throws IOException {\n         int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n \n         while (!done) {\n-            int r = in.read(buf.array, off,\n-                            ZipArchiveOutputStream.BUFFER_SIZE - off);\n+            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                 // read the whole archive without ever finding a\n                 // central directory\n         boolean done = false;\n         int readTooMuch = 0;\n         for (int i = 0; !done && i < lastRead - 4; i++) {\n-            if (buf.array[i] == LFH[0] && buf.array[i + 1] == LFH[1]) {\n-                if ((buf.array[i + 2] == LFH[2] && buf.array[i + 3] == LFH[3])\n-                    || (buf.array[i] == CFH[2] && buf.array[i + 3] == CFH[3])) {\n+            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n+                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n+                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                     // found a LFH or CFH:\n                     readTooMuch = offset + lastRead - i - expectedDDLen;\n                     done = true;\n                 }\n-                else if (buf.array[i + 2] == DD[2] && buf.array[i + 3] == DD[3]) {\n+                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                     // found DD:\n                     readTooMuch = offset + lastRead - i;\n                     done = true;\n                     //   descriptor\n                     // * copy the remaining bytes to cache\n                     // * read data descriptor\n-                    pushback(buf.array, offset + lastRead - readTooMuch,\n-                             readTooMuch);\n-                    bos.write(buf.array, 0, i);\n+                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n+                    bos.write(buf.array(), 0, i);\n                     readDataDescriptor();\n                 }\n             }\n                                int lastRead, int expecteDDLen) {\n         final int cacheable = offset + lastRead - expecteDDLen - 3;\n         if (cacheable > 0) {\n-            bos.write(buf.array, 0, cacheable);\n-            System.arraycopy(buf.array, cacheable, buf.array, 0,\n-                             expecteDDLen + 3);\n+            bos.write(buf.array(), 0, cacheable);\n+            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n             offset = expecteDDLen + 3;\n         } else {\n             offset += lastRead;\n          */\n         private long bytesReadFromStream;\n     }\n-\n-    /**\n-     * Contains a temporary buffer used to read from the wrapped\n-     * stream together with some information needed for internal\n-     * housekeeping.\n-     * \n-     * This class is similar to a java.nio.ByteBuffer but can't be replaced,\n-     * because the limit contains the length of the last read operation and\n-     * when the end of the stream is reached the limit is thus set to -1.\n-     * This is not allowed for a ByteBuffer.\n-     */\n-    private static final class Buffer {\n-        /**\n-         * Buffer used as temporary buffer when reading from the stream.\n-         */\n-        private final byte[] array = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n-\n-        /**\n-         * {@link #array array} may contain data the client hasnt read, yet,\n-         * this is the first byte that hasn't been read so far.\n-         */\n-        private int position = 0;\n-\n-        /**\n-         * Number of bytes read from the wrapped stream into {@link #array\n-         * array} with the last read operation.\n-         */\n-        private int limit = 0;\n-\n-        /**\n-         * Reset internal housekeeping.\n-         */\n-        private void reset() {\n-            position = limit = 0;\n-        }\n-\n-        /**\n-         * Returns the number of bytes left to read.\n-         */\n-        private int remaining() {\n-            return limit - position;\n-        }\n-\n-        /**\n-         * Returns the length of the buffer.\n-         */\n-        private int capacity() {\n-            return array.length;\n-        }\n-    }\n }", "timestamp": 1387408466, "metainfo": ""}