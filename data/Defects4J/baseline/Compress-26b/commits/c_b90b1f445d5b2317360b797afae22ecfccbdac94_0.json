{"sha": "b90b1f445d5b2317360b797afae22ecfccbdac94", "log": "Our parser for STAR-encoded binary values was wrong, STAR only uses 7 or 11 bytes and can encode negative values as twos complement signaled by the first byte being 0xff rather than 0x80.  COMPRESS-182  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n  */\n package org.apache.commons.compress.archivers.tar;\n \n+import java.math.BigInteger;\n+\n /**\n  * This class provides static utility methods to work with byte streams.\n  *\n         if ((buffer[offset] & 0x80) == 0) {\n             return parseOctal(buffer, offset, length);\n         }\n-\n-        long val = buffer[offset] & 0x7f;\n+        final boolean negative = buffer[offset] == (byte) 0xff;\n+        if (length < 9) {\n+            return parseBinaryLong(buffer, offset, length, negative);\n+        }\n+        return parseBinaryBigInteger(buffer, offset, length, negative);\n+    }\n+\n+    private static long parseBinaryLong(final byte[] buffer, final int offset,\n+                                        final int length,\n+                                        final boolean negative) {\n+        if (length >= 9) {\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n+                                               + length + \" byte binary number\"\n+                                               + \" exceeds maximum signed long\"\n+                                               + \" value\");\n+        }\n+        long val = 0;\n         for (int i = 1; i < length; i++) {\n-            if (val >= (1L << (63 - 8))) {\n-                throw new IllegalArgumentException(\n-                    \"At offset \" + offset + \", \" + length + \" byte \" +\n-                    \"binary number exceeds maximum signed long value\");\n-            }\n             val = (val << 8) + (buffer[offset + i] & 0xff);\n         }\n-        return val;\n+        if (negative) {\n+            // 2's complement\n+            val--;\n+            val ^= ((long) Math.pow(2, (length - 1) * 8) - 1);\n+        }\n+        return negative ? -val : val;\n+    }\n+\n+    private static long parseBinaryBigInteger(final byte[] buffer,\n+                                              final int offset,\n+                                              final int length,\n+                                              final boolean negative) {\n+        byte[] remainder = new byte[length - 1];\n+        System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n+        BigInteger val = new BigInteger(remainder);\n+        if (negative) {\n+            // 2's complement\n+            val = val.add(BigInteger.valueOf(-1)).not();\n+        }\n+        if (val.bitLength() > 63) {\n+            throw new IllegalArgumentException(\"At offset \" + offset + \", \"\n+                                               + length + \" byte binary number\"\n+                                               + \" exceeds maximum signed long\"\n+                                               + \" value\");\n+        }\n+        return negative ? -val.longValue() : val.longValue();\n     }\n \n     /**\n         // Check whether we are dealing with UID/GID or SIZE field\n         final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n \n-        if (value <= maxAsOctalChar) { // OK to store as octal chars\n+        final boolean negative = value < 0;\n+        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n             return formatLongOctalBytes(value, buf, offset, length);\n         }\n \n-        long val = value;\n+        if (length < 9) {\n+            formatLongBinary(value, buf, offset, length, negative);\n+        }\n+        formatBigIntegerBinary(value, buf, offset, length, negative);\n+\n+        buf[offset] = (byte) (negative ? 0xff : 0x80);\n+        return offset + length;\n+    }\n+\n+    private static void formatLongBinary(final long value, byte[] buf,\n+                                         final int offset, final int length,\n+                                         final boolean negative) {\n+        final int bits = (length - 1) * 8;\n+        final long max = (long) Math.pow(2, bits);\n+        long val = Math.abs(value);\n+        if (val >= max) {\n+            throw new IllegalArgumentException(\"Value \" + value +\n+                \" is too large for \" + length + \" byte field.\");\n+        }\n+        if (negative) {\n+            val ^= max - 1;\n+            val |= 0xff << bits;\n+            val++;\n+        }\n         for (int i = offset + length - 1; i >= offset; i--) {\n             buf[i] = (byte) val;\n             val >>= 8;\n         }\n-\n-        if (val != 0 || (buf[offset] & 0x80) != 0) {\n-            throw new IllegalArgumentException(\"Value \" + value +\n-                \" is too large for \" + length + \" byte field.\");\n-        }\n-\n-        buf[offset] |= 0x80;\n-        return offset + length;\n+    }\n+\n+    private static void formatBigIntegerBinary(final long value, byte[] buf,\n+                                               final int offset,\n+                                               final int length,\n+                                               final boolean negative) {\n+        BigInteger val = BigInteger.valueOf(value);\n+        final byte[] b = val.toByteArray();\n+        final int len = b.length;\n+        final int off = offset + length - len;\n+        System.arraycopy(b, 0, buf, off, len);\n+        final byte fill = (byte) (negative ? 0xff : 0);\n+        for (int i = offset + 1; i < off; i++) {\n+            buf[i] = fill;\n+        }\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n         assertEquals(value,parseValue);\n     }\n \n-    public void testRoundTripOctalOrBinary() {\n-        checkRoundTripOctalOrBinary(0, 8);\n-        checkRoundTripOctalOrBinary(1, 8);\n-        checkRoundTripOctalOrBinary(Long.MAX_VALUE, 8); // [0x7f ff ff ff ff ff ff ff\n-        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, 8); // will need binary format\n+    public void testRoundTripOctalOrBinary8() {\n+        testRoundTripOctalOrBinary(8);\n+    }\n+    public void testRoundTripOctalOrBinary12() {\n+        testRoundTripOctalOrBinary(12);\n+    }\n+    private void testRoundTripOctalOrBinary(int length) {\n+        checkRoundTripOctalOrBinary(0, length);\n+        checkRoundTripOctalOrBinary(1, length);\n+        checkRoundTripOctalOrBinary(Long.MAX_VALUE >> 7, length); // [0x00 ff ff ff ff ff ff ff\n+        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, length); // will need binary format\n+        checkRoundTripOctalOrBinary(-1, length); // will need binary format\n     }\n     \n     // Check correct trailing bytes are generated\n         int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n         assertEquals(string, TarUtils.parseName(buff, 0, len));\n     }\n+\n+    public void testReadNegativeBinary8Byte() {\n+        byte[] b = new byte[] {\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n+        };\n+        assertEquals(-3601l, TarUtils.parseOctalOrBinary(b, 0, 8));\n+    }\n+\n+    public void testReadNegativeBinary12Byte() {\n+        byte[] b = new byte[] {\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n+        };\n+        assertEquals(-3601l, TarUtils.parseOctalOrBinary(b, 0, 12));\n+    }\n+\n+\n+    public void testWriteNegativeBinary8Byte() {\n+        byte[] b = new byte[] {\n+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n+            (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n+        };\n+        assertEquals(-3601l, TarUtils.parseOctalOrBinary(b, 0, 8));\n+    }\n+\n }", "timestamp": 1330752535, "metainfo": ""}