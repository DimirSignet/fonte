{"sha": "a2f978e97f13697e7adfddc3f96a9131803db679", "log": "COMPRESS-172 reuse temporary byte-arrays in several places to reduce garbage collection pressure - inspired by a patch by Thomas Mair  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n      */\n     private long entryOffset = -1;\n \n+    // cached buffers\n+    private final byte[] NAME_BUF = new byte[16];\n+    private final byte[] LAST_MODIFIED_BUF = new byte[12];\n+    private final byte[] ID_BUF = new byte[6];\n+    private final byte[] FILE_MODE_BUF = new byte[8];\n+    private final byte[] LENGTH_BUF = new byte[10];\n+\n     /**\n      * Constructs an Ar input stream with the referenced stream\n      * \n             return null;\n         }\n \n-        final byte[] name = new byte[16];\n-        final byte[] lastmodified = new byte[12];\n-        final byte[] userid = new byte[6];\n-        final byte[] groupid = new byte[6];\n-        final byte[] filemode = new byte[8];\n-        final byte[] length = new byte[10];\n-\n-        read(name);\n-        read(lastmodified);\n-        read(userid);\n-        read(groupid);\n-        read(filemode);\n-        read(length);\n+        read(NAME_BUF);\n+        read(LAST_MODIFIED_BUF);\n+        read(ID_BUF);\n+        int userId = asInt(ID_BUF, true);\n+        read(ID_BUF);\n+        read(FILE_MODE_BUF);\n+        read(LENGTH_BUF);\n \n         {\n             final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\n //        GNU ar uses a '/' to mark the end of the filename; this allows for the use of spaces without the use of an extended filename.\n \n         // entry name is stored as ASCII string\n-        String temp = ArchiveUtils.toAsciiString(name).trim();\n-        long len = asLong(length);\n-\n+        String temp = ArchiveUtils.toAsciiString(NAME_BUF).trim();\n         if (isGNUStringTable(temp)) { // GNU extended filenames entry\n-            currentEntry = readGNUStringTable(length);\n+            currentEntry = readGNUStringTable(LENGTH_BUF);\n             return getNextArEntry();\n-        } else if (temp.endsWith(\"/\")) { // GNU terminator\n+        }\n+\n+        long len = asLong(LENGTH_BUF);\n+        if (temp.endsWith(\"/\")) { // GNU terminator\n             temp = temp.substring(0, temp.length() - 1);\n         } else if (isGNULongName(temp)) {\n             int offset = Integer.parseInt(temp.substring(1));// get the offset\n             entryOffset += nameLen;\n         }\n \n-        currentEntry = new ArArchiveEntry(temp, len, asInt(userid, true),\n-                                          asInt(groupid, true), asInt(filemode, 8),\n-                                          asLong(lastmodified));\n+        currentEntry = new ArArchiveEntry(temp, len, userId,\n+                                          asInt(ID_BUF, true),\n+                                          asInt(FILE_MODE_BUF, 8),\n+                                          asLong(LAST_MODIFIED_BUF));\n         return currentEntry;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n \n     private final InputStream in;\n \n+    // cached buffers\n+    private final byte[] TWO_BYTES_BUF = new byte[2];\n+    private final byte[] FOUR_BYTES_BUF = new byte[4];\n+    private final byte[] SIX_BYTES_BUF = new byte[6];\n+\n     /**\n      * Construct the cpio input stream\n      * \n         if (this.entry != null) {\n             closeEntry();\n         }\n-        byte magic[] = new byte[2];\n-        readFully(magic, 0, magic.length);\n-        if (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\n+        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n+        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(false);\n-        } else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\n+        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n+                   == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(true);\n         } else {\n-            byte more_magic[] = new byte[4];\n-            readFully(more_magic, 0, more_magic.length);\n-            byte tmp[] = new byte[6];\n-            System.arraycopy(magic, 0, tmp, 0, magic.length);\n-            System.arraycopy(more_magic, 0, tmp, magic.length,\n-                    more_magic.length);\n-            String magicString = ArchiveUtils.toAsciiString(tmp);\n+            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n+                             TWO_BYTES_BUF.length);\n+            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n+                      FOUR_BYTES_BUF.length);\n+            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n             if (magicString.equals(MAGIC_NEW)) {\n                 this.entry = readNewEntry(false);\n             } else if (magicString.equals(MAGIC_NEW_CRC)) {\n     }\n \n     private void skip(int bytes) throws IOException{\n-        final byte[] buff = new byte[4]; // Cannot be more than 3 bytes\n+        // bytes cannot be more than 3 bytes\n         if (bytes > 0) {\n-            readFully(buff, 0, bytes);\n+            readFully(FOUR_BYTES_BUF, 0, bytes);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n     private static final int SMALL_BUFFER_SIZE = 256;\n     private static final int BUFFER_SIZE = 8 * 1024;\n \n+    private final byte[] SKIP_BUF = new byte[BUFFER_SIZE];\n+    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n+\n     private boolean hasHitEOF;\n     private long entrySize;\n     private long entryOffset;\n         // This is horribly inefficient, but it ensures that we\n         // properly skip over bytes via the TarBuffer...\n         //\n-        byte[] skipBuf = new byte[BUFFER_SIZE];\n         long skip = numToSkip;\n         while (skip > 0) {\n-            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n-            int numRead = read(skipBuf, 0, realSkip);\n+            int realSkip = (int) (skip > SKIP_BUF.length\n+                                  ? SKIP_BUF.length : skip);\n+            int numRead = read(SKIP_BUF, 0, realSkip);\n             if (numRead == -1) {\n                 break;\n             }\n         if (currEntry.isGNULongNameEntry()) {\n             // read in the name\n             ByteArrayOutputStream longName = new ByteArrayOutputStream();\n-            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n             int length = 0;\n-            while ((length = read(buf)) >= 0) {\n-                longName.write(buf, 0, length);\n+            while ((length = read(SMALL_BUF)) >= 0) {\n+                longName.write(SMALL_BUF, 0, length);\n             }\n             getNextEntry();\n             if (currEntry == null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n     private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n         \"Zip64 extended information must contain\"\n         + \" both size values in the local file header.\";\n+    private static final byte[] EMPTY = new byte[0];\n \n     private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n     private ZipLong diskStart;\n             addSizes(data);\n             return data;\n         }\n-        return new byte[0];\n+        return EMPTY;\n     }\n \n     /** {@inheritDoc} */\n         }\n         return off;\n     }\n-}\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     public static final int PLATFORM_FAT  = 0;\n     private static final int SHORT_MASK = 0xFFFF;\n     private static final int SHORT_SHIFT = 16;\n+    private static final byte[] EMPTY = new byte[0];\n \n     /**\n      * The {@link java.util.zip.ZipEntry} base class only supports\n      */\n     public byte[] getLocalFileDataExtra() {\n         byte[] extra = getExtra();\n-        return extra != null ? extra : new byte[0];\n+        return extra != null ? extra : EMPTY;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n \n     private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n \n+    // cached buffers\n+    private final byte[] LFH_BUF = new byte[LFH_LEN];\n+    private final byte[] SKIP_BUF = new byte[1024];\n+    private final byte[] WORD_BUF = new byte[WORD];\n+    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n+\n     public ZipArchiveInputStream(InputStream inputStream) {\n         this(inputStream, ZipEncodingHelper.UTF8);\n     }\n             firstEntry = false;\n         }\n \n-        byte[] lfh = new byte[LFH_LEN];\n         try {\n             if (firstEntry) {\n                 // split archives have a special signature before the\n                 // first local file header - look for it and fail with\n                 // the appropriate error message if this is a split\n                 // archive.\n-                readFirstLocalFileHeader(lfh);\n+                readFirstLocalFileHeader(LFH_BUF);\n             } else {\n-                readFully(lfh);\n+                readFully(LFH_BUF);\n             }\n         } catch (EOFException e) {\n             return null;\n         }\n             \n-        ZipLong sig = new ZipLong(lfh);\n+        ZipLong sig = new ZipLong(LFH_BUF);\n         if (sig.equals(ZipLong.CFH_SIG)) {\n             hitCentralDirectory = true;\n             return null;\n         int off = WORD;\n         current = new CurrentEntry();\n \n-        int versionMadeBy = ZipShort.getValue(lfh, off);\n+        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n         off += SHORT;\n         current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                                   & ZipFile.NIBLET_MASK);\n \n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n \n         off += SHORT;\n \n-        current.entry.setMethod(ZipShort.getValue(lfh, off));\n+        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n         off += SHORT;\n \n-        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n+        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n         current.entry.setTime(time);\n         off += WORD;\n \n         ZipLong size = null, cSize = null;\n         if (!current.hasDataDescriptor) {\n-            current.entry.setCrc(ZipLong.getValue(lfh, off));\n+            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n             off += WORD;\n \n-            cSize = new ZipLong(lfh, off);\n+            cSize = new ZipLong(LFH_BUF, off);\n             off += WORD;\n \n-            size = new ZipLong(lfh, off);\n+            size = new ZipLong(LFH_BUF, off);\n             off += WORD;\n         } else {\n             off += 3 * WORD;\n         }\n \n-        int fileNameLen = ZipShort.getValue(lfh, off);\n+        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n \n         off += SHORT;\n \n-        int extraLen = ZipShort.getValue(lfh, off);\n+        int extraLen = ZipShort.getValue(LFH_BUF, off);\n         off += SHORT;\n \n         byte[] fileName = new byte[fileNameLen];\n     public long skip(long value) throws IOException {\n         if (value >= 0) {\n             long skipped = 0;\n-            byte[] b = new byte[1024];\n             while (skipped < value) {\n                 long rem = value - skipped;\n-                int x = read(b, 0, (int) (b.length > rem ? rem : b.length));\n+                int x = read(SKIP_BUF, 0,\n+                             (int) (SKIP_BUF.length > rem ? rem\n+                                    : SKIP_BUF.length));\n                 if (x == -1) {\n                     return skipped;\n                 }\n     }\n \n     private void readDataDescriptor() throws IOException {\n-        byte[] b = new byte[WORD];\n-        readFully(b);\n-        ZipLong val = new ZipLong(b);\n+        readFully(WORD_BUF);\n+        ZipLong val = new ZipLong(WORD_BUF);\n         if (ZipLong.DD_SIG.equals(val)) {\n             // data descriptor with signature, skip sig\n-            readFully(b);\n-            val = new ZipLong(b);\n+            readFully(WORD_BUF);\n+            val = new ZipLong(WORD_BUF);\n         }\n         current.entry.setCrc(val.getValue());\n \n         // descriptor (ignoring archive decryption headers for now).\n         // If so, push back eight bytes and assume sizes are four\n         // bytes, otherwise sizes are eight bytes each.\n-        b = new byte[2 * DWORD];\n-        readFully(b);\n-        ZipLong potentialSig = new ZipLong(b, DWORD);\n+        readFully(TWO_DWORD_BUF);\n+        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n         if (potentialSig.equals(ZipLong.CFH_SIG)\n             || potentialSig.equals(ZipLong.LFH_SIG)) {\n-            pushback(b, DWORD, DWORD);\n-            current.entry.setCompressedSize(ZipLong.getValue(b));\n-            current.entry.setSize(ZipLong.getValue(b, WORD));\n+            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n+            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n+            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n         } else {\n             current.entry\n-                .setCompressedSize(ZipEightByteInteger.getLongValue(b));\n-            current.entry.setSize(ZipEightByteInteger.getLongValue(b, DWORD));\n+                .setCompressedSize(ZipEightByteInteger\n+                                   .getLongValue(TWO_DWORD_BUF));\n+            current.entry.setSize(ZipEightByteInteger\n+                                  .getLongValue(TWO_DWORD_BUF, DWORD));\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     @Deprecated\n     public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n \n+    private static final byte[] EMPTY = new byte[0];\n+\n     /**\n      * Current entry.\n      */\n         }\n \n         if (!entry.hasWritten) {\n-            write(new byte[0], 0, 0);\n+            write(EMPTY, 0, 0);\n         }\n \n         flushDeflater();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      */\n     private boolean closed;\n \n+    // cached buffers\n+    private final byte[] DWORD_BUF = new byte[DWORD];\n+    private final byte[] WORD_BUF = new byte[WORD];\n+    private final byte[] CFH_BUF = new byte[CFH_LEN];\n+    private final byte[] SHORT_BUF = new byte[SHORT];\n+\n     /**\n      * Opens the given file for reading, assuming \"UTF8\" for file names.\n      *\n \n         positionAtCentralDirectory();\n \n-        byte[] signatureBytes = new byte[WORD];\n-        archive.readFully(signatureBytes);\n-        long sig = ZipLong.getValue(signatureBytes);\n+        archive.readFully(WORD_BUF);\n+        long sig = ZipLong.getValue(WORD_BUF);\n \n         if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n             throw new IOException(\"central directory is empty, can't expand\"\n \n         while (sig == CFH_SIG) {\n             readCentralDirectoryEntry(noUTF8Flag);\n-            archive.readFully(signatureBytes);\n-            sig = ZipLong.getValue(signatureBytes);\n+            archive.readFully(WORD_BUF);\n+            sig = ZipLong.getValue(WORD_BUF);\n         }\n         return noUTF8Flag;\n     }\n     private void\n         readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n         throws IOException {\n-        byte[] cfh = new byte[CFH_LEN];\n-\n-        archive.readFully(cfh);\n+        archive.readFully(CFH_BUF);\n         int off = 0;\n         ZipArchiveEntry ze = new ZipArchiveEntry();\n \n-        int versionMadeBy = ZipShort.getValue(cfh, off);\n+        int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n \n         off += SHORT; // skip version info\n \n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n \n         off += SHORT;\n \n-        ze.setMethod(ZipShort.getValue(cfh, off));\n+        ze.setMethod(ZipShort.getValue(CFH_BUF, off));\n         off += SHORT;\n \n-        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n+        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n         ze.setTime(time);\n         off += WORD;\n \n-        ze.setCrc(ZipLong.getValue(cfh, off));\n+        ze.setCrc(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n-        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n+        ze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n-        ze.setSize(ZipLong.getValue(cfh, off));\n+        ze.setSize(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n-        int fileNameLen = ZipShort.getValue(cfh, off);\n+        int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int extraLen = ZipShort.getValue(cfh, off);\n+        int extraLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int commentLen = ZipShort.getValue(cfh, off);\n+        int commentLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int diskStart = ZipShort.getValue(cfh, off);\n+        int diskStart = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n+        ze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\n         off += SHORT;\n \n-        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n+        ze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n         byte[] fileName = new byte[fileNameLen];\n \n         // LFH offset,\n         OffsetEntry offset = new OffsetEntry();\n-        offset.headerOffset = ZipLong.getValue(cfh, off);\n+        offset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n         // data offset will be filled later\n         entries.put(ze, offset);\n \n     private void positionAtCentralDirectory64()\n         throws IOException {\n         skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n-        byte[] zip64EocdOffset = new byte[DWORD];\n-        archive.readFully(zip64EocdOffset);\n-        archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n-        byte[] sig = new byte[WORD];\n-        archive.readFully(sig);\n-        if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n-            || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n-            || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n-            || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n-            ) {\n+        archive.readFully(DWORD_BUF);\n+        archive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+        archive.readFully(WORD_BUF);\n+        if (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n             throw new ZipException(\"archive's ZIP64 end of central \"\n                                    + \"directory locator is corrupt.\");\n         }\n         skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                   - WORD /* signature has already been read */);\n-        byte[] cfdOffset = new byte[DWORD];\n-        archive.readFully(cfdOffset);\n-        archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n+        archive.readFully(DWORD_BUF);\n+        archive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n     }\n \n     /**\n             throw new ZipException(\"archive is not a ZIP archive\");\n         }\n         skipBytes(CFD_LOCATOR_OFFSET);\n-        byte[] cfdOffset = new byte[WORD];\n-        archive.readFully(cfdOffset);\n-        archive.seek(ZipLong.getValue(cfdOffset));\n+        archive.readFully(WORD_BUF);\n+        archive.seek(ZipLong.getValue(WORD_BUF));\n     }\n \n     /**\n             OffsetEntry offsetEntry = ent.getValue();\n             long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n-            byte[] b = new byte[SHORT];\n-            archive.readFully(b);\n-            int fileNameLen = ZipShort.getValue(b);\n-            archive.readFully(b);\n-            int extraFieldLen = ZipShort.getValue(b);\n+            archive.readFully(SHORT_BUF);\n+            int fileNameLen = ZipShort.getValue(SHORT_BUF);\n+            archive.readFully(SHORT_BUF);\n+            int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n             int lenToSkip = fileNameLen;\n             while (lenToSkip > 0) {\n                 int skipped = archive.skipBytes(lenToSkip);\n      */\n     private boolean startsWithLocalFileHeader() throws IOException {\n         archive.seek(0);\n-        final byte[] start = new byte[WORD];\n-        archive.readFully(start);\n-        for (int i = 0; i < start.length; i++) {\n-            if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        archive.readFully(WORD_BUF);\n+        return Arrays.equals(WORD_BUF, ZipArchiveOutputStream.LFH_SIG);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n     // True once everything has been decompressed\n     private boolean endReached = false;\n \n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n     /**\n      * Constructs a new input stream that decompresses gzip-compressed data\n      * from the specified input stream.\n     /** {@inheritDoc} */\n     @Override\n     public int read() throws IOException {\n-        byte[] buf = new byte[1];\n-        return read(buf, 0, 1) == -1 ? -1 : (buf[0] & 0xFF);\n+        return read(oneByte, 0, 1) == -1 ? -1 : (oneByte[0] & 0xFF);\n     }\n \n     /**", "timestamp": 1357414122, "metainfo": ""}