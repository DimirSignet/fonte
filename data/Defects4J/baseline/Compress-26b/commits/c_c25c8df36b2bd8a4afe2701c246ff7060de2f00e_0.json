{"sha": "c25c8df36b2bd8a4afe2701c246ff7060de2f00e", "log": "Decrypt lazily, on the first read(), otherwise the password strengthening calculations only allow us to traverse 7z archives using getNextEntry() at a rate of about 1 per second with 100% CPU usage.  Go back to extending InputStream after all, its semantics are necessary.    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n     static class AES256SHA256Decoder extends CoderBase {\n         @Override\n         InputStream decode(final InputStream in, final Coder coder,\n-                String password) throws IOException {\n-            final int byte0 = 0xff & coder.properties[0];\n-            final int numCyclesPower = byte0 & 0x3f;\n-            final int byte1 = 0xff & coder.properties[1];\n-            final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n-            final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n-            //debug(\"numCyclesPower=\" + numCyclesPower + \", saltSize=\" + saltSize + \", ivSize=\" + ivSize);\n-            if (2 + saltSize + ivSize > coder.properties.length) {\n-                throw new IOException(\"Salt size + IV size too long\");\n-            }\n-            final byte[] salt = new byte[saltSize];\n-            System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n-            final byte[] iv = new byte[16];\n-            System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n-            \n-            if (password == null) {\n-                throw new IOException(\"Cannot read encrypted files without a password\");\n-            }\n-            final byte[] passwordBytes = password.getBytes(\"UTF-16LE\");\n-            final byte[] aesKeyBytes;\n-            if (numCyclesPower == 0x3f) {\n-                aesKeyBytes = new byte[32];\n-                System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n-                System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n-                        Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n-            } else {\n-                final MessageDigest digest;\n-                try {\n-                    digest = MessageDigest.getInstance(\"SHA-256\");\n-                } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n-                    IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n-                    ioe.initCause(noSuchAlgorithmException);\n-                    throw ioe;\n-// TODO: simplify when Compress requires Java 1.6                \n-//                    throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n-//                            noSuchAlgorithmException);\n-                }\n-                final byte[] extra = new byte[8];\n-                for (long j = 0; j < (1L << numCyclesPower); j++) {\n-                    digest.update(salt);\n-                    digest.update(passwordBytes);\n-                    digest.update(extra);\n-                    for (int k = 0; k < extra.length; k++) {\n-                        ++extra[k];\n-                        if (extra[k] != 0) {\n-                            break;\n+                final String password) throws IOException {\n+            return new InputStream() {\n+                private boolean isInitialized = false;\n+                private CipherInputStream cipherInputStream = null;\n+                \n+                private CipherInputStream init() throws IOException {\n+                    if (isInitialized) {\n+                        return cipherInputStream;\n+                    }\n+                    final int byte0 = 0xff & coder.properties[0];\n+                    final int numCyclesPower = byte0 & 0x3f;\n+                    final int byte1 = 0xff & coder.properties[1];\n+                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n+                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n+                    //debug(\"numCyclesPower=\" + numCyclesPower + \", saltSize=\" + saltSize + \", ivSize=\" + ivSize);\n+                    if (2 + saltSize + ivSize > coder.properties.length) {\n+                        throw new IOException(\"Salt size + IV size too long\");\n+                    }\n+                    final byte[] salt = new byte[saltSize];\n+                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n+                    final byte[] iv = new byte[16];\n+                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n+                    \n+                    if (password == null) {\n+                        throw new IOException(\"Cannot read encrypted files without a password\");\n+                    }\n+                    final byte[] passwordBytes = password.getBytes(\"UTF-16LE\");\n+                    final byte[] aesKeyBytes;\n+                    if (numCyclesPower == 0x3f) {\n+                        aesKeyBytes = new byte[32];\n+                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n+                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n+                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n+                    } else {\n+                        final MessageDigest digest;\n+                        try {\n+                            digest = MessageDigest.getInstance(\"SHA-256\");\n+                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n+                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n+                            ioe.initCause(noSuchAlgorithmException);\n+                            throw ioe;\n+        // TODO: simplify when Compress requires Java 1.6                \n+//                            throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n+//                                    noSuchAlgorithmException);\n                         }\n-                    }\n-                }\n-                aesKeyBytes = digest.digest();\n-            }\n-            \n-            final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n-            try {\n-                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n-                cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n-                return new CipherInputStream(in, cipher);\n-            } catch (GeneralSecurityException generalSecurityException) {\n-                IOException ioe = new IOException(\"Decryption error \" +\n-                        \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n-                ioe.initCause(generalSecurityException);\n-                throw ioe;\n-// TODO: simplify when Compress requires Java 1.6                \n-//                throw new IOException(\"Decryption error \" +\n-//                        \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n-//                        generalSecurityException);\n-            }\n+                        final byte[] extra = new byte[8];\n+                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n+                            digest.update(salt);\n+                            digest.update(passwordBytes);\n+                            digest.update(extra);\n+                            for (int k = 0; k < extra.length; k++) {\n+                                ++extra[k];\n+                                if (extra[k] != 0) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        aesKeyBytes = digest.digest();\n+                    }\n+                    \n+                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n+                    try {\n+                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n+                        cipherInputStream = new CipherInputStream(in, cipher);\n+                        isInitialized = true;\n+                        return cipherInputStream;\n+                    } catch (GeneralSecurityException generalSecurityException) {\n+                        IOException ioe = new IOException(\"Decryption error \" +\n+                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n+                        ioe.initCause(generalSecurityException);\n+                        throw ioe;\n+        // TODO: simplify when Compress requires Java 1.6                \n+//                        throw new IOException(\"Decryption error \" +\n+//                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n+//                                generalSecurityException);\n+                    }\n+                }\n+                \n+                @Override\n+                public int read() throws IOException {\n+                    return init().read();\n+                }\n+                \n+                @Override\n+                public int read(byte[] b, int off, int len) throws IOException {\n+                    return init().read();\n+                }\n+                \n+                @Override\n+                public void close() {\n+                }\n+            };\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.io.DataInput;\n import java.io.DataInputStream;\n import java.io.File;\n-import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.RandomAccessFile;\n         return value;\n     }\n     \n-    private static class BoundedInputStream extends FilterInputStream {\n+    private static class BoundedInputStream extends InputStream {\n+        private final InputStream in;\n         private long bytesRemaining;\n         \n         public BoundedInputStream(final InputStream in, final long size) {\n-            super(in);\n+            this.in = in;\n             bytesRemaining = size;\n         }\n         \n--- a/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n  */\n package org.apache.commons.compress.utils;\n \n-import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.zip.CRC32;\n \n-public class CRC32VerifyingInputStream extends FilterInputStream {\n+public class CRC32VerifyingInputStream extends InputStream {\n+    private final InputStream in;\n     private long bytesRemaining;\n     private final int expectedCrc32;\n     private final CRC32 crc32 = new CRC32();\n     \n     public CRC32VerifyingInputStream(final InputStream in, final long size, final int expectedCrc32) {\n-        super(in);\n+        this.in = in;\n         this.expectedCrc32 = expectedCrc32;\n         this.bytesRemaining = size;\n     }", "timestamp": 1368733546, "metainfo": ""}