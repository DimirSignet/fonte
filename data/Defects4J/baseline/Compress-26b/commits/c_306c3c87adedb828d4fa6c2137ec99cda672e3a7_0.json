{"sha": "306c3c87adedb828d4fa6c2137ec99cda672e3a7", "log": "typos  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n \n     /**\n      * Assemble as unicode extension from the name/comment and\n-     * encoding of the orginal zip entry.\n+     * encoding of the original zip entry.\n      * \n      * @param text The file name or comment.\n      * @param bytes The encoded of the filename or comment in the zip\n \n     /**\n      * Assemble as unicode extension from the name/comment and\n-     * encoding of the orginal zip entry.\n+     * encoding of the original zip entry.\n      * \n      * @param text The file name or comment.\n      * @param bytes The encoded of the filename or comment in the zip\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     }\n \n     /**\n-     * Create an instance of the approriate ExtraField, falls back to\n+     * Create an instance of the appropriate ExtraField, falls back to\n      * {@link UnrecognizedExtraField UnrecognizedExtraField}.\n      * @param headerId the header identifier\n-     * @return an instance of the appropiate ExtraField\n+     * @return an instance of the appropriate ExtraField\n      * @exception InstantiationException if unable to instantiate the class\n-     * @exception IllegalAccessException if not allowed to instatiate the class\n+     * @exception IllegalAccessException if not allowed to instantiate the class\n      */\n     public static ZipExtraField createExtraField(ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n /**\n  * Constants from stat.h on Unix systems.\n  */\n-public interface UnixStat\n-{\n+// CheckStyle:InterfaceIsTypeCheck OFF - backward compatible\n+public interface UnixStat {\n+\n     /**\n      * Bits used for permissions (and sticky bit)\n      */\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n  * </pre></p>\n  *\n  * <p>Currently Commons Compress doesn't support encrypting the\n- * central directory so the not about masking doesn't apply.</p>\n+ * central directory so the note about masking doesn't apply.</p>\n  *\n  * <p>The implementation relies on data being read from the local file\n  * header and assumes that both size values are always present.</p>\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      * by&quot; part of the central file header.\n      *\n      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}\n-     * has been called, in which case PLATORM_UNIX will be returned.\n+     * has been called, in which case PLATFORM_UNIX will be returned.\n      */\n     public int getPlatform() {\n         return platform;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n  * uncompressed size information is required before {@link\n  * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n  *\n- * <p>As of Apache Commons Compress it transparently supports Zip64\n+ * <p>As of Apache Commons Compress 1.3 it transparently supports Zip64\n  * extensions and thus individual entries and archives larger than 4\n  * GB or with more than 65536 entries in most cases but explicit\n  * control is provided via {@link #setUseZip64}.  If the stream can not\n     protected final Deflater def = new Deflater(level, true);\n \n     /**\n-     * This buffer servers as a Deflater.\n+     * This buffer serves as a Deflater.\n      *\n      */\n     private final byte[] buf = new byte[BUFFER_SIZE];\n         }\n \n         if (entry != null) {\n-            throw new IOException(\"This archives contains unclosed entries.\");\n+            throw new IOException(\"This archive contains unclosed entries.\");\n         }\n \n         cdOffset = written;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n import java.util.zip.ZipException;\n \n /**\n- * General format of extra field data. <p>\n+ * General format of extra field data.\n  *\n- * Extra fields usually appear twice per file, once in the local file data and\n- * once in the central directory. Usually they are the same, but they don't have\n- * to be. {@link java.util.zip.ZipOutputStream java.util.zip.ZipOutputStream}\n- * will only use the local file data in both places.</p>\n+ * <p>Extra fields usually appear twice per file, once in the local\n+ * file data and once in the central directory.  Usually they are the\n+ * same, but they don't have to be.  {@link\n+ * java.util.zip.ZipOutputStream java.util.zip.ZipOutputStream} will\n+ * only use the local file data in both places.</p>\n+ *\n  */\n public interface ZipExtraField {\n     /**\n     ZipShort getHeaderId();\n \n     /**\n-     * Length of the extra field in the local file data - without Header-ID or\n-     * length specifier.\n-     *\n-     * @return The LocalFileDataLength value\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     * @return the length of the field in the local file data\n      */\n     ZipShort getLocalFileDataLength();\n \n     /**\n-     * Length of the extra field in the central directory - without Header-ID or\n-     * length specifier.\n-     *\n-     * @return The CentralDirectoryLength value\n+     * Length of the extra field in the central directory - without\n+     * Header-ID or length specifier.\n+     * @return the length of the field in the central directory\n      */\n     ZipShort getCentralDirectoryLength();\n \n     /**\n-     * The actual data to put into local file data - without Header-ID or length\n-     * specifier.\n-     *\n-     * @return The LocalFileDataData value\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     * @return the data\n      */\n     byte[] getLocalFileDataData();\n \n     /**\n      * The actual data to put into central directory - without Header-ID or\n      * length specifier.\n-     *\n-     * @return The CentralDirectoryData value\n+     * @return the data\n      */\n     byte[] getCentralDirectoryData();\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  * have to reimplement all methods anyway.  Like\n  * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n  * covers and supports compressed and uncompressed entries.  As of\n- * Apache Commons Compress it also transparently supports Zip64\n+ * Apache Commons Compress 1.3 it also transparently supports Zip64\n  * extensions and thus individual entries and archives larger than 4\n  * GB or with more than 65536 entries.</p>\n  *\n      *\n      * @param ze the entry to get the stream for.\n      * @return a stream to read the entry from.\n-     * @throws IOException if unable to create an input stream from the zipenty\n+     * @throws IOException if unable to create an input stream from the zipentry\n      * @throws ZipException if the zipentry uses an unsupported feature\n      */\n     public InputStream getInputStream(ZipArchiveEntry ze)", "timestamp": 1338784981, "metainfo": ""}