{"sha": "1d5567004306b3c6019b4e828f811220fc3fe990", "log": "Rename TarUtils.getXXX methods as formatXXX Update Javadoc Throw IllegalArgumentException if value won't fit in buffer Treat long values as unsigned Use String instead of StringBuffer for names etc  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n \n public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n     /** The entry's name. */\n-    private StringBuffer name;\n+    private String name;\n \n     /** The entry's permission mode. */\n     private int mode;\n     private byte linkFlag;\n \n     /** The entry's link name. */\n-    private StringBuffer linkName;\n+    private String linkName;\n \n     /** The entry's magic tag. */\n-    private StringBuffer magic;\n+    private String magic;\n \n     /** The entry's user name. */\n-    private StringBuffer userName;\n+    private String userName;\n \n     /** The entry's group name. */\n-    private StringBuffer groupName;\n+    private String groupName;\n \n     /** The entry's major device number. */\n     private int devMajor;\n      * Construct an empty entry and prepares the header values.\n      */\n     private TarArchiveEntry () {\n-        this.magic = new StringBuffer(MAGIC_POSIX);\n-        this.name = new StringBuffer();\n-        this.linkName = new StringBuffer();\n+        this.magic = MAGIC_POSIX;\n+        this.name = \"\";\n+        this.linkName = \"\";\n \n         String user = System.getProperty(\"user.name\", \"\");\n \n \n         this.userId = 0;\n         this.groupId = 0;\n-        this.userName = new StringBuffer(user);\n-        this.groupName = new StringBuffer(\"\");\n+        this.userName = user;\n+        this.groupName = \"\";\n         this.file = null;\n     }\n \n \n         this.devMajor = 0;\n         this.devMinor = 0;\n-        this.name = new StringBuffer(name);\n+        this.name = name;\n         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n         this.userId = 0;\n         this.groupId = 0;\n         this.size = 0;\n         this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\n-        this.linkName = new StringBuffer(\"\");\n-        this.userName = new StringBuffer(\"\");\n-        this.groupName = new StringBuffer(\"\");\n+        this.linkName = \"\";\n+        this.userName = \"\";\n+        this.groupName = \"\";\n         this.devMajor = 0;\n         this.devMinor = 0;\n \n \n         this.file = file;\n \n-        this.linkName = new StringBuffer(\"\");\n-        this.name = new StringBuffer(fileName);\n+        this.linkName = \"\";\n \n         if (file.isDirectory()) {\n             this.mode = DEFAULT_DIR_MODE;\n             this.linkFlag = LF_DIR;\n \n-            int nameLength = name.length();\n+            int nameLength = fileName.length();\n             if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {\n-                this.name.append(\"/\");\n+                this.name = fileName + \"/\";\n+            } else {\n+                this.name = fileName;                \n             }\n             this.size = 0;\n         } else {\n             this.mode = DEFAULT_FILE_MODE;\n             this.linkFlag = LF_NORMAL;\n             this.size = file.length();\n+            this.name = fileName;\n         }\n \n         this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n      * @param name This entry's new name.\n      */\n     public void setName(String name) {\n-        this.name = new StringBuffer(normalizeFileName(name));\n+        this.name = normalizeFileName(name);\n     }\n \n     /**\n      * @param userName This entry's new user name.\n      */\n     public void setUserName(String userName) {\n-        this.userName = new StringBuffer(userName);\n+        this.userName = userName;\n     }\n \n     /**\n      * @param groupName This entry's new group name.\n      */\n     public void setGroupName(String groupName) {\n-        this.groupName = new StringBuffer(groupName);\n+        this.groupName = groupName;\n     }\n \n     /**\n     public void writeEntryHeader(byte[] outbuf) {\n         int offset = 0;\n \n-        offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);\n-        offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);\n-        offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);\n-        offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);\n-        offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);\n-        offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n+        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\n+        offset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\n+        offset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\n+        offset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\n+        offset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\n+        offset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n \n         int csOffset = offset;\n \n         }\n \n         outbuf[offset++] = linkFlag;\n-        offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);\n-        offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);\n-        offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);\n-        offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);\n-        offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);\n-        offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);\n+        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\n+        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n+        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\n+        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\n+        offset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\n+        offset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\n \n         while (offset < outbuf.length) {\n             outbuf[offset++] = 0;\n \n         long chk = TarUtils.computeCheckSum(outbuf);\n \n-        TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n+        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * @param length The maximum number of bytes to parse.\n      * @return The long value of the octal string.\n      */\n-    public static long parseOctal(byte[] buffer, int offset, int length) {\n+    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n         long    result = 0;\n         boolean stillPadding = true;\n         int     end = offset + length;\n \n         for (int i = offset; i < end; ++i) {\n-            if (buffer[i] == 0) { // Found trailing null\n+            final byte currentByte = buffer[i];\n+            if (currentByte == 0) { // Found trailing null\n                 break;\n             }\n \n             // Ignore leading spaces ('0' can be ignored anyway)\n-            if (buffer[i] == (byte) ' ' || buffer[i] == '0') {\n+            if (currentByte == (byte) ' ' || currentByte == '0') {\n                 if (stillPadding) {\n                     continue;\n                 }\n \n-                if (buffer[i] == (byte) ' ') { // Found trailing space\n+                if (currentByte == (byte) ' ') { // Found trailing space\n                     break;\n                 }\n             }\n \n             stillPadding = false;\n             // CheckStyle:MagicNumber OFF\n-            result = (result << 3) + (buffer[i] - '0');// TODO needs to reject invalid bytes\n+            if (currentByte < '0' || currentByte > '7'){\n+                throw new IllegalArgumentException(\n+                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n+            }\n+            result = (result << 3) + (currentByte - '0');// TODO needs to reject invalid bytes\n             // CheckStyle:MagicNumber ON\n         }\n \n      * @param length The maximum number of bytes to parse.\n      * @return The entry name.\n      */\n-    public static StringBuffer parseName(byte[] buffer, int offset, int length) {\n+    public static String parseName(byte[] buffer, final int offset, final int length) {\n         StringBuffer result = new StringBuffer(length);\n         int          end = offset + length;\n \n             result.append((char) buffer[i]);\n         }\n \n-        return result;\n+        return result.toString();\n     }\n \n     /**\n      * @param length The maximum number of header bytes to copy.\n      * @return The updated offset, i.e. offset + length\n      */\n-    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {\n+    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n         int i;\n \n         // copy until end of input or output is reached.\n     }\n \n     /**\n-     * Fill buffer with octal number, with leading zeroes\n-     * \n-     * The output for negative numbers is not specified,\n-     * but currently the method returns a buffer filled with zeros.\n-     * This may change.\n-     * \n-     * @param value number to convert to octal (assumed >=0)\n+     * Fill buffer with unsigned octal number, padded with leading zeroes.\n+     * \n+     * @param value number to convert to octal - treated as unsigned\n      * @param buffer destination buffer\n      * @param offset starting offset in buffer\n      * @param length length of buffer to fill\n-     */\n-    public static void formatUnsignedOctalString(long value, byte[] buffer,\n-            int offset, int length) {\n-        length--;\n+     * @throws IllegalArgumentException if the value will not fit in the buffer\n+     */\n+    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n+            final int offset, final int length) {\n+        int remaining = length;\n+        remaining--;\n         if (value == 0) {\n-            buffer[offset + length--] = (byte) '0';\n+            buffer[offset + remaining--] = (byte) '0';\n         } else {\n-            for (long val = value; length >= 0 && val > 0; --length) {\n+            long val = value;\n+            for (; remaining >= 0 && val != 0; --remaining) {\n                 // CheckStyle:MagicNumber OFF\n-                buffer[offset + length] = (byte) ((byte) '0' + (byte) (val & 7));\n-                val = val >> 3;\n+                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n+                val = val >>> 3;\n                 // CheckStyle:MagicNumber ON\n             }\n-        }\n-\n-        for (; length >= 0; --length) { // leading zeros\n-            buffer[offset + length] = (byte) '0';\n+            if (val != 0){\n+                throw new IllegalArgumentException\n+                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n+            }\n+        }\n+\n+        for (; remaining >= 0; --remaining) { // leading zeros\n+            buffer[offset + remaining] = (byte) '0';\n         }\n     }\n \n     /**\n      * Write an octal integer into a buffer.\n      *\n-     * Adds a trailing space and NUL to end of the buffer.\n-     * [Appears to be standard for V7 Unix BSD]\n-     * Converts the long value (assumed positive) to the buffer.\n-     * Adds leading zeros to the buffer.\n+     * Uses {@link #formatUnsignedOctalString} to format\n+     * the value as an octal string with leading zeros.\n+     * The converted number is followed by space and NUL\n      * \n      * @param value The value to write\n      * @param buf The buffer to receive the output\n      * @param offset The starting offset into the buffer\n      * @param length The size of the output buffer\n      * @return The updated offset, i.e offset+length\n-     */\n-    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n+     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n+     */\n+    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n \n         int idx=length-2; // For space and trailing null\n         formatUnsignedOctalString(value, buf, offset, idx);\n \n     /**\n      * Write an octal long integer into a buffer.\n-     * Converts the long value (assumed positive) to the buffer.\n-     * Adds leading zeros to the buffer.\n-     * The buffer is terminated with a space.\n+     * \n+     * Uses {@link #formatUnsignedOctalString} to format\n+     * the value as an octal string with leading zeros.\n+     * The converted number is followed by a space.\n      * \n      * @param value The value to write as octal\n      * @param buf The destinationbuffer.\n      * @param offset The starting offset into the buffer.\n      * @param length The length of the buffer\n      * @return The updated offset\n-     */\n-    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n+     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n+     */\n+    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n \n         int idx=length-1; // For space\n         \n \n     /**\n      * Writes an octal value into a buffer.\n-     *\n-     * Converts the long value (assumed positive) to the buffer.\n-     * Adds leading zeros to the buffer.\n-     * Checksum is followed by NUL and then space.\n+     * \n+     * Uses {@link #formatUnsignedOctalString} to format\n+     * the value as an octal string with leading zeros.\n+     * The converted number is followed by NUL and then space.\n      *\n      * @param value The value to convert\n      * @param buf The destination buffer\n      * @param offset The starting offset into the buffer.\n      * @param length The size of the buffer.\n      * @return The updated value of offset, i.e. offset+length\n-     */\n-    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n+     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n+     */\n+    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n \n         int idx=length-2; // for NUL and space\n         formatUnsignedOctalString(value, buf, offset, idx);\n      * @param buf The tar entry's header buffer.\n      * @return The computed checksum.\n      */\n-    public static long computeCheckSum(byte[] buf) {\n+    public static long computeCheckSum(final byte[] buf) {\n         long sum = 0;\n \n         for (int i = 0; i < buf.length; ++i) {\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n     \n     public void testName(){\n         byte [] buff = new byte[20];\n-        StringBuffer sb1 = new StringBuffer(\"abcdefghijklmnopqrstuvwxyz\");\n-        int off = TarUtils.getNameBytes(sb1, buff, 1, buff.length-1);\n+        String sb1 = \"abcdefghijklmnopqrstuvwxyz\";\n+        int off = TarUtils.formatNameBytes(sb1, buff, 1, buff.length-1);\n         assertEquals(off, 20);\n-        StringBuffer sb2 = TarUtils.parseName(buff, 1, 10);\n-        assertEquals(sb2.toString(),sb1.substring(0,10));\n+        String sb2 = TarUtils.parseName(buff, 1, 10);\n+        assertEquals(sb2,sb1.substring(0,10));\n         sb2 = TarUtils.parseName(buff, 1, 19);\n-        assertEquals(sb2.toString(),sb1.substring(0,19));\n+        assertEquals(sb2,sb1.substring(0,19));\n         buff = new byte[30];\n-        off = TarUtils.getNameBytes(sb1, buff, 1, buff.length-1);\n+        off = TarUtils.formatNameBytes(sb1, buff, 1, buff.length-1);\n         assertEquals(off, 30);\n         sb2 = TarUtils.parseName(buff, 1, buff.length-1);\n-        assertEquals(sb1.toString(), sb2.toString());\n+        assertEquals(sb1, sb2);\n     }\n     \n     private void fillBuff(byte []buffer, String input){\n         value = TarUtils.parseOctal(buffer,0, 11);\n         assertEquals(077777777777L, value);\n         fillBuff(buffer, \"abcdef\"); // Invalid input\n-        value = TarUtils.parseOctal(buffer,0, 11);\n-//        assertEquals(0, value); // Or perhaps an Exception?\n+        try {\n+            value = TarUtils.parseOctal(buffer,0, 11);\n+            fail(\"Expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n     }\n     \n     private void checkRoundTripOctal(final long value) {\n         byte [] buffer = new byte[12];\n         long parseValue;\n-        TarUtils.getLongOctalBytes(value, buffer, 0, buffer.length);\n+        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n         parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n         assertEquals(value,parseValue);\n     }\n     // Check correct trailing bytes are generated\n     public void testTrailers() {\n         byte [] buffer = new byte[12];\n-        TarUtils.getLongOctalBytes(123, buffer, 0, buffer.length);\n+        TarUtils.formatLongOctalBytes(123, buffer, 0, buffer.length);\n         assertEquals(' ', buffer[buffer.length-1]);\n         assertEquals('3', buffer[buffer.length-2]); // end of number\n-        TarUtils.getOctalBytes(123, buffer, 0, buffer.length);\n+        TarUtils.formatOctalBytes(123, buffer, 0, buffer.length);\n         assertEquals(0  , buffer[buffer.length-1]);\n         assertEquals(' ', buffer[buffer.length-2]);\n         assertEquals('3', buffer[buffer.length-3]); // end of number\n-        TarUtils.getCheckSumOctalBytes(123, buffer, 0, buffer.length);\n+        TarUtils.formatCheckSumOctalBytes(123, buffer, 0, buffer.length);\n         assertEquals(' ', buffer[buffer.length-1]);\n         assertEquals(0  , buffer[buffer.length-2]);\n         assertEquals('3', buffer[buffer.length-3]); // end of number\n     }\n     \n     public void testNegative() {\n-        byte [] buffer = new byte[10];\n+        byte [] buffer = new byte[22];\n         TarUtils.formatUnsignedOctalString(-1, buffer, 0, buffer.length);\n-        // Currently negative numbers generate all zero buffer. This may need to change.\n-        assertEquals(\"0000000000\", new String(buffer));\n-        \n+        assertEquals(\"1777777777777777777777\", new String(buffer));\n+    }\n+\n+    public void testOverflow() {\n+        byte [] buffer = new byte[8-1]; // a lot of the numbers have 8-byte buffers (nul term)\n+        TarUtils.formatUnsignedOctalString(07777777L, buffer, 0, buffer.length);\n+        assertEquals(\"7777777\", new String(buffer));        \n+        try {\n+            TarUtils.formatUnsignedOctalString(017777777L, buffer, 0, buffer.length);\n+            fail(\"Should have cause IllegalArgumentException\");\n+        } catch (IllegalArgumentException expected) {\n+        }\n     }\n }", "timestamp": 1238697902, "metainfo": ""}