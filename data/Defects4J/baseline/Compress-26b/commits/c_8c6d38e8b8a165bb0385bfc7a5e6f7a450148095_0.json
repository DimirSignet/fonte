{"sha": "8c6d38e8b8a165bb0385bfc7a5e6f7a450148095", "log": "COMPRESS-147 some cleanup, fix counting, simple available implementation  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n         return read;\n     }\n \n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() throws IOException {\n+        if (inUncompressedChunk) {\n+            return Math.min(uncompressedBytesRemaining,\n+                            in.available());\n+        } else if (currentCompressedChunk != null) {\n+            return currentCompressedChunk.available();\n+        }\n+        return 0;\n+    }\n+\n     /**\n      * Read from the current chunk into the given array.\n      *\n      * @return -1 if there is no current chunk or the number of bytes\n-     * read from the current chunk (which may be -1 if the end od the\n-     * chunk is reached.\n+     * read from the current chunk (which may be -1 if the end of the\n+     * chunk is reached).\n      */\n     private int readOnce(byte[] b, int off, int len) throws IOException {\n         int read = -1;\n             readCrc();\n             currentCompressedChunk =\n                 new SnappyCompressorInputStream(new BoundedInputStream(in, size));\n+            // constructor reads uncompressed size\n+            count(currentCompressedChunk.getBytesRead());\n         } else {\n             // impossible as all potential byte values have been covered\n             throw new IOException(\"unknown chunk type \" + type\n \n     private void readCrc() throws IOException {\n         byte[] b = new byte[4];\n-        if (IOUtils.readFully(in, b) != 4) {\n+        int read = IOUtils.readFully(in, b);\n+        if (read > 0) {\n+            count(read);\n+        }\n+        if (read != 4) {\n             throw new IOException(\"premature end of stream\");\n         }\n-        count(4);\n     }\n \n     private int readSize() throws IOException {\n \n     private void skipBlock() throws IOException {\n         int size = readSize();\n-        if (IOUtils.skip(in, size) != size) {\n+        long read = IOUtils.skip(in, size);\n+        if (read > 0) {\n+            count(read);\n+        }\n+        if (read != size) {\n             throw new IOException(\"premature end of stream\");\n         }\n-        count(size);\n     }\n \n     private void readStreamIdentifier() throws IOException {\n         byte[] b = new byte[10];\n-        if (10 != IOUtils.readFully(in, b) || !matches(b, 10)) {\n+        int read = IOUtils.readFully(in, b);\n+        if (read > 0) {\n+            count(read);\n+        }\n+        if (10 != read || !matches(b, 10)) {\n             throw new IOException(\"Not a framed Snappy stream\");\n         }\n-        count(10);\n     }\n \n     private int readOneByte() throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n         if (endReached) {\n             return -1;\n         }\n-        if (len > available()) {\n-            fill(len - available());\n+        final int avail = available();\n+        if (len > avail) {\n+            fill(len - avail);\n         }\n \n         int readable = Math.min(len, available());\n     }\n \n     /**\n-     * Try to fill the buffer with enoug bytes to satisfy the current read request.\n+     * Try to fill the buffer with enough bytes to satisfy the current\n+     * read request.\n      *\n      * @param len the number of uncompressed bytes to read\n      */\n     /**\n      * Slide buffer.\n      *\n-     * <p>Move all bytes of the buffer after the first block down\n-     * tothe beginning of the buffer.</p>\n+     * <p>Move all bytes of the buffer after the first block down to\n+     * the beginning of the buffer.</p>\n      */\n     private void slideBuffer() {\n         System.arraycopy(decompressBuf, blockSize, decompressBuf, 0,\n-                blockSize);\n+                         blockSize * 2);\n         writeIndex -= blockSize;\n         readIndex -= blockSize;\n     }\n      */\n     private boolean expandLiteral(final int length) throws IOException {\n         int bytesRead = in.read(decompressBuf, writeIndex, length);\n-        count(bytesRead);\n+        if (bytesRead != -1) {\n+            count(bytesRead);\n+        }\n         if (length != bytesRead) {\n             throw new IOException(\"Premature end of stream\");\n         }\n--- a/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n             try {\n                 out = new FileOutputStream(output);\n                 IOUtils.copy(in, out);\n+                assertEquals(995, in.getBytesRead());\n             } finally {\n                 if (out != null) {\n                     out.close();", "timestamp": 1384078490, "metainfo": ""}