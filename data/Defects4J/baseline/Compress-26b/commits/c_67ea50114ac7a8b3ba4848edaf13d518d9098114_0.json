{"sha": "67ea50114ac7a8b3ba4848edaf13d518d9098114", "log": "Add preliminary support for writing 7z archives.    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n  */\n public class SevenZFile {\n     private static final boolean DEBUG = false;\n-    private static final int SIGNATURE_HEADER_SIZE = 32;\n+    static final int SIGNATURE_HEADER_SIZE = 32;\n     private RandomAccessFile file;\n     private final Archive archive;\n     private int currentEntryIndex = -1;\n     private InputStream currentEntryInputStream = null;\n     private String password;\n         \n-    private static final byte[] sevenZSignature = {\n+    static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n     \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+\n+/**\n+ * Writes a 7z file.\n+ */\n+public class SevenZOutputFile {\n+    private final RandomAccessFile file;\n+    private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\n+    private int numNonEmptyStreams = 0;\n+    private CRC32 crc32 = new CRC32();\n+    private long fileBytesWritten = 0;\n+    private boolean finished = false;\n+    \n+    public SevenZOutputFile(final File filename) throws IOException {\n+        file = new RandomAccessFile(filename, \"rw\");\n+        file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n+    }\n+    \n+    public void close() {\n+        try {\n+            if (!finished) {\n+                finish();\n+            }\n+            file.close();\n+        } catch (IOException ioEx) { // NOPMD\n+        }\n+    }\n+    \n+    public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n+            final String entryName) throws IOException {\n+        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+        entry.setDirectory(inputFile.isDirectory());\n+        entry.setName(entryName);\n+        entry.setHasLastModifiedDate(true);\n+        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n+        return entry;\n+    }\n+\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n+        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n+        files.add(entry);\n+    }\n+    \n+    public void closeArchiveEntry() throws IOException {\n+        final SevenZArchiveEntry entry = files.get(files.size() - 1);\n+        if (fileBytesWritten > 0) {\n+            entry.setHasStream(true);\n+            ++numNonEmptyStreams;\n+            entry.setSize(fileBytesWritten);\n+            entry.setCrc((int) crc32.getValue());\n+            entry.setHasCrc(true);\n+        } else {\n+            entry.setHasStream(false);\n+            entry.setSize(0);\n+            entry.setHasCrc(false);\n+        }\n+        crc32.reset();\n+        fileBytesWritten = 0;\n+    }\n+    \n+    public void write(final int b) throws IOException {\n+        file.write(b);\n+        crc32.update(b);\n+        fileBytesWritten++;\n+    }\n+    \n+    public void write(final byte[] b) throws IOException {\n+        write(b, 0, b.length);\n+    }\n+    \n+    public void write(final byte[] b, final int off, final int len) throws IOException {\n+        file.write(b, off, len);\n+        crc32.update(b, off, len);\n+        fileBytesWritten += len;\n+    }\n+    \n+    public void finish() throws IOException {\n+        if (finished) {\n+            throw new IOException(\"This archive has already been finished\");\n+        }\n+        finished = true;\n+        \n+        final long headerPosition = file.getFilePointer();\n+        \n+        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n+        final DataOutputStream header = new DataOutputStream(headerBaos);\n+        \n+        writeHeader(header);\n+        header.flush();\n+        final byte[] headerBytes = headerBaos.toByteArray();\n+        file.write(headerBytes);\n+        \n+        final CRC32 crc32 = new CRC32();\n+        \n+        // signature header\n+        file.seek(0);\n+        file.write(SevenZFile.sevenZSignature);\n+        // version\n+        file.write(0);\n+        file.write(2);\n+        \n+        // start header\n+        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n+        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n+        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n+        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n+        crc32.reset();\n+        crc32.update(headerBytes);\n+        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n+        startHeaderStream.flush();\n+        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n+        crc32.reset();\n+        crc32.update(startHeaderBytes);\n+        file.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n+        file.write(startHeaderBytes);\n+    }\n+    \n+    private void writeHeader(final DataOutput header) throws IOException {\n+        header.write(NID.kHeader);\n+        \n+        header.write(NID.kMainStreamsInfo);\n+        writeStreamsInfo(header);\n+        writeFilesInfo(header);\n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeStreamsInfo(final DataOutput header) throws IOException {\n+        if (numNonEmptyStreams > 0) {\n+            writePackInfo(header);\n+            writeUnpackInfo(header);\n+        }\n+        \n+        writeSubStreamsInfo(header);\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writePackInfo(final DataOutput header) throws IOException {\n+        // FIXME: this needs to use the compressed sizes/CRCs when we start supporting compression.\n+        header.write(NID.kPackInfo);\n+        \n+        writeUint64(header, 0);\n+        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n+        \n+        header.write(NID.kSize);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                writeUint64(header, entry.getSize());\n+            }\n+        }\n+        \n+        header.write(NID.kCRC);\n+        header.write(1);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+            }\n+        }\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeUnpackInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kUnpackInfo);\n+        \n+        header.write(NID.kFolder);\n+        // FIXME: add real support for solid compression, and actual compression methods\n+        writeUint64(header, numNonEmptyStreams);\n+        header.write(0);\n+        for (int i = 0; i < numNonEmptyStreams; i++) {\n+            writeFolder(header);\n+        }\n+        \n+        header.write(NID.kCodersUnpackSize);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                writeUint64(header, entry.getSize());\n+            }\n+        }\n+        \n+        header.write(NID.kCRC);\n+        header.write(1);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+            }\n+        }\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeFolder(final DataOutput header) throws IOException {\n+        writeUint64(header, 1);\n+        header.write(1);\n+        header.write(0);\n+    }\n+    \n+    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kSubStreamsInfo);\n+//        \n+//        header.write(NID.kCRC);\n+//        header.write(1);\n+//        for (final SevenZArchiveEntry entry : files) {\n+//            if (entry.getHasCrc()) {\n+//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+//            }\n+//        }\n+//        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeFilesInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kFilesInfo);\n+        \n+        writeUint64(header, files.size());\n+\n+        writeFileEmptyStreams(header);\n+        writeFileEmptyFiles(header);\n+        writeFileAntiItems(header);\n+        writeFileNames(header);\n+        writeFileCTimes(header);\n+        writeFileATimes(header);\n+        writeFileMTimes(header);\n+        writeFileWindowsAttributes(header);\n+        header.write(0);\n+    }\n+    \n+    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n+        boolean hasEmptyStreams = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (!entry.hasStream()) {\n+                hasEmptyStreams = true;\n+                break;\n+            }\n+        }\n+        if (hasEmptyStreams) {\n+            header.write(NID.kEmptyStream);\n+            final BitSet emptyStreams = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                emptyStreams.set(i, !files.get(i).hasStream());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, emptyStreams, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n+        boolean hasEmptyFiles = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (!entry.hasStream() && !entry.isDirectory()) {\n+                hasEmptyFiles = true;\n+                break;\n+            }\n+        }\n+        if (hasEmptyFiles) {\n+            header.write(NID.kEmptyFile);\n+            final BitSet emptyFiles = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                emptyFiles.set(i, !files.get(i).hasStream() && !files.get(i).isDirectory());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, emptyFiles, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileAntiItems(final DataOutput header) throws IOException {\n+        boolean hasAntiItems = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.isAntiItem()) {\n+                hasAntiItems = true;\n+                break;\n+            }\n+        }\n+        if (hasAntiItems) {\n+            header.write(NID.kAnti);\n+            final BitSet antiItems = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                antiItems.set(i, files.get(i).isAntiItem());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, antiItems, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileNames(final DataOutput header) throws IOException {\n+        header.write(NID.kName);\n+        \n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final DataOutputStream out = new DataOutputStream(baos);\n+        out.write(0);\n+        for (final SevenZArchiveEntry entry : files) {\n+            out.write(entry.getName().getBytes(\"UTF-16LE\"));\n+            out.writeShort(0);\n+        }\n+        out.flush();\n+        final byte[] contents = baos.toByteArray();\n+        writeUint64(header, contents.length);\n+        header.write(contents);\n+    }\n+\n+    private void writeFileCTimes(final DataOutput header) throws IOException {\n+        int numCreationDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasCreationDate()) {\n+                ++numCreationDates;\n+            }\n+        }\n+        if (numCreationDates > 0) {\n+            header.write(NID.kCTime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numCreationDates != files.size()) {\n+                out.write(0);\n+                final BitSet cTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    cTimes.set(i, files.get(i).getHasCreationDate());\n+                }\n+                writeBits(out, cTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasCreationDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileATimes(final DataOutput header) throws IOException {\n+        int numAccessDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasAccessDate()) {\n+                ++numAccessDates;\n+            }\n+        }\n+        if (numAccessDates > 0) {\n+            header.write(NID.kATime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numAccessDates != files.size()) {\n+                out.write(0);\n+                final BitSet aTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    aTimes.set(i, files.get(i).getHasAccessDate());\n+                }\n+                writeBits(out, aTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasAccessDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileMTimes(final DataOutput header) throws IOException {\n+        int numLastModifiedDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasLastModifiedDate()) {\n+                ++numLastModifiedDates;\n+            }\n+        }\n+        if (numLastModifiedDates > 0) {\n+            header.write(NID.kMTime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numLastModifiedDates != files.size()) {\n+                out.write(0);\n+                final BitSet mTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    mTimes.set(i, files.get(i).getHasLastModifiedDate());\n+                }\n+                writeBits(out, mTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasLastModifiedDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n+        int numWindowsAttributes = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasWindowsAttributes()) {\n+                ++numWindowsAttributes;\n+            }\n+        }\n+        if (numWindowsAttributes > 0) {\n+            header.write(NID.kWinAttributes);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numWindowsAttributes != files.size()) {\n+                out.write(0);\n+                final BitSet attributes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    attributes.set(i, files.get(i).getHasWindowsAttributes());\n+                }\n+                writeBits(out, attributes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasWindowsAttributes()) {\n+                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeUint64(final DataOutput header, long value) throws IOException {\n+        int firstByte = 0;\n+        int mask = 0x80;\n+        int i;\n+        for (i = 0; i < 8; i++) {\n+            if (value < ((1L << ( 7  * (i + 1))))) {\n+                firstByte |= (value >>> (8 * i));\n+                break;\n+            }\n+            firstByte |= mask;\n+            mask >>>= 1;\n+        }\n+        header.write(firstByte);\n+        for (; i > 0; i--) {\n+            header.write((int) (0xff & value));\n+            value >>>= 8;\n+        }\n+    }\n+\n+    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n+        int cache = 0;\n+        int shift = 7;\n+        for (int i = 0; i < length; i++) {\n+            cache |= ((bits.get(i) ? 1 : 0) << shift);\n+            --shift;\n+            if (shift == 0) {\n+                header.write(cache);\n+                shift = 7;\n+                cache = 0;\n+            }\n+        }\n+        if (length > 0 && shift > 0) {\n+            header.write(cache);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/SevenZTestCase.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry;\n+import org.apache.commons.compress.archivers.sevenz.SevenZFile;\n+import org.apache.commons.compress.archivers.sevenz.SevenZOutputFile;\n+\n+public class SevenZTestCase extends AbstractTestCase {\n+    public void testSevenZArchiveCreation() throws Exception {\n+        final File output = new File(dir, \"bla.7z\");\n+        final File file1 = getFile(\"test1.xml\");\n+        final File file2 = getFile(\"test2.xml\");\n+\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        try {\n+            SevenZArchiveEntry entry;\n+            \n+            entry = outArchive.createArchiveEntry(file1, file1.getName());\n+            outArchive.putArchiveEntry(entry);\n+            copy(file1, outArchive);\n+            outArchive.closeArchiveEntry();\n+            \n+            entry = outArchive.createArchiveEntry(file2, file2.getName());\n+            outArchive.putArchiveEntry(entry);\n+            copy(file2, outArchive);\n+            outArchive.closeArchiveEntry();\n+        } finally {\n+            outArchive.close();\n+        }\n+        \n+        final SevenZFile archive = new SevenZFile(output);\n+        try {\n+            SevenZArchiveEntry entry;\n+            \n+            entry = archive.getNextEntry();\n+            assert(entry != null);\n+            assertEquals(entry.getName(), file1.getName());\n+            \n+            entry = archive.getNextEntry();\n+            assert(entry != null);\n+            assertEquals(entry.getName(), file2.getName());\n+            \n+            assert(archive.getNextEntry() == null);\n+        } finally {\n+            archive.close();\n+        }\n+    }\n+    \n+    private void copy(final File src, final SevenZOutputFile dst) throws IOException { \n+        FileInputStream fis = null;\n+        try {\n+            fis = new FileInputStream(src);\n+            final byte[] buffer = new byte[8*1024];\n+            int bytesRead;\n+            while ((bytesRead = fis.read(buffer)) >= 0) {\n+                dst.write(buffer, 0, bytesRead);\n+            }\n+        } finally {\n+            if (fis != null) {\n+                fis.close();\n+            }\n+        }\n+    }\n+}", "timestamp": 1370877734, "metainfo": ""}