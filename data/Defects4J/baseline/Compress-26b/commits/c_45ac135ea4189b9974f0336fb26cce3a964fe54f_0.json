{"sha": "45ac135ea4189b9974f0336fb26cce3a964fe54f", "log": "sync with trunk  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     }\n \n     /**\n-     * Package private setter that sets the name using the raw bytes\n-     * and the string created from it by guessing or suing the\n-     * configured encoding.\n-     */\n-    void setName(String name, byte[] rawName) {\n+     * Sets the name using the raw bytes and the string created from\n+     * it by guessing or using the configured encoding.\n+     * @param name the name to use created from the raw bytes using\n+     * the guessed or configured encoding\n+     * @param rawName the bytes originally read as name from the\n+     * archive\n+     * @since Apache Commons Compress 1.2\n+     */\n+    protected void setName(String name, byte[] rawName) {\n         setName(name);\n         this.rawName = rawName;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     /**\n      * Static registry of known extra fields.\n      */\n-    private static final Map implementations;\n+    private static final Map<ZipShort, Class<?>> implementations;\n \n     static {\n-        implementations = new HashMap();\n+        implementations = new HashMap<ZipShort, Class<?>>();\n         register(AsiExtraField.class);\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n     }\n \n     /**\n      * the {@link ZipExtraField ZipExtraField interface}.</p>\n      * @param c the class to register\n      */\n-    public static void register(Class c) {\n+    public static void register(Class<?> c) {\n         try {\n             ZipExtraField ze = (ZipExtraField) c.newInstance();\n             implementations.put(ze.getHeaderId(), c);\n      */\n     public static ZipExtraField createExtraField(ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n-        Class c = (Class) implementations.get(headerId);\n+        Class<?> c = implementations.get(headerId);\n         if (c != null) {\n             return (ZipExtraField) c.newInstance();\n         }\n     public static ZipExtraField[] parse(byte[] data, boolean local,\n                                         UnparseableExtraField onUnparseableData)\n         throws ZipException {\n-        List v = new ArrayList();\n+        List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n         int start = 0;\n         LOOP:\n         while (start <= data.length - WORD) {\n         }\n \n         ZipExtraField[] result = new ZipExtraField[v.size()];\n-        return (ZipExtraField[]) v.toArray(result);\n+        return v.toArray(result);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n         return b;\n     }\n \n+    @Override\n     public int hashCode() {\n         return 3 * (7 * (13 * (17 * (encryptionFlag ? 1 : 0)\n                                + (strongEncryptionFlag ? 1 : 0))\n                     + (dataDescriptorFlag ? 1 : 0));\n     }\n \n+    @Override\n     public boolean equals(Object o) {\n         if (!(o instanceof GeneralPurposeBit)) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n      * field.  This list is used to binary search reverse mapping of\n      * unicode characters with a character code greater than 127.\n      */\n-    private final List reverseMapping;\n+    private final List<Simple8BitChar> reverseMapping;\n \n     /**\n      * @param highChars The characters for byte values of 128 to 255\n      */\n     public Simple8BitZipEncoding(char[] highChars) {\n         this.highChars = (char[]) highChars.clone();\n-        List temp = new ArrayList(this.highChars.length);\n+        List temp = new ArrayList<Simple8BitChar>(this.highChars.length);\n \n         byte code = 127;\n \n \n             int i = i0 + (i1 - i0) / 2;\n \n-            Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n+            Simple8BitChar m = this.reverseMapping.get(i);\n \n             if (m.unicode == c) {\n                 return m;\n             return null;\n         }\n \n-        Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n+        Simple8BitChar r = this.reverseMapping.get(i0);\n \n         if (r.unicode != c) {\n             return null;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     private int method = -1;\n \n+    /**\n+     * The {@link java.util.zip.ZipEntry#setSize} method in the base\n+     * class throws an IllegalArgumentException if the size is bigger\n+     * than 2GB for Java versions < 7.  Need to keep our own size\n+     * information for Zip64 support.\n+     */\n+    private long size = SIZE_UNKNOWN;\n+\n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n-    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n+    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n     private byte[] rawName = null;\n             setExtra();\n         }\n         setMethod(entry.getMethod());\n+        this.size = entry.getSize();\n     }\n \n     /**\n      * Overwrite clone.\n      * @return a cloned copy of this ZipArchiveEntry\n      */\n+    @Override\n     public Object clone() {\n         ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n \n      * @param fields an array of extra fields\n      */\n     public void setExtraFields(ZipExtraField[] fields) {\n-        extraFields = new LinkedHashMap();\n+        extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] instanceof UnparseableExtraFieldData) {\n                 unparseableExtra = (UnparseableExtraFieldData) fields[i];\n                 ? new ZipExtraField[0]\n                 : new ZipExtraField[] { unparseableExtra };\n         }\n-        List result = new ArrayList(extraFields.values());\n+        List<ZipExtraField> result =\n+            new ArrayList<ZipExtraField>(extraFields.values());\n         if (includeUnparseable && unparseableExtra != null) {\n             result.add(unparseableExtra);\n         }\n-        return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);\n+        return result.toArray(new ZipExtraField[0]);\n     }\n \n     /**\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n             if (extraFields == null) {\n-                extraFields = new LinkedHashMap();\n+                extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n             }\n             extraFields.put(ze.getHeaderId(), ze);\n         }\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n             LinkedHashMap copy = extraFields;\n-            extraFields = new LinkedHashMap();\n+            extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n             extraFields.put(ze.getHeaderId(), ze);\n             if (copy != null) {\n                 copy.remove(ze.getHeaderId());\n      */\n     public ZipExtraField getExtraField(ZipShort type) {\n         if (extraFields != null) {\n-            return (ZipExtraField) extraFields.get(type);\n+            return extraFields.get(type);\n         }\n         return null;\n     }\n      * @throws RuntimeException if the bytes cannot be parsed\n      * @throws RuntimeException on error\n      */\n+    @Override\n     public void setExtra(byte[] extra) throws RuntimeException {\n         try {\n             ZipExtraField[] local =\n                                       ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(local, true);\n         } catch (ZipException e) {\n-            // actually this is not be possible as of Commons Compress 1.1\n+            // actually this is not possible as of Commons Compress 1.1\n             throw new RuntimeException(\"Error parsing extra fields for entry: \"\n                                        + getName() + \" - \" + e.getMessage(), e);\n         }\n      * Get the name of the entry.\n      * @return the entry name\n      */\n+    @Override\n     public String getName() {\n         return name == null ? super.getName() : name;\n     }\n      */\n     protected void setName(String name) {\n         this.name = name;\n+    }\n+\n+    /**\n+     * Gets the uncompressed size of the entry data.\n+     * @return the entry size\n+     */\n+    @Override\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Sets the uncompressed size of the entry data.\n+     * @param size the uncompressed size in bytes\n+     * @exception IllegalArgumentException if the specified size is less\n+     *            than 0\n+     */\n+    @Override\n+    public void setSize(long size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"invalid entry size\");\n+        }\n+        this.size = size;\n     }\n \n     /**\n      * This uses the name as the hashcode.\n      * @return a hashcode.\n      */\n+    @Override\n     public int hashCode() {\n         // this method has severe consequences on performance. We cannot rely\n         // on the super.hashCode() method since super.getName() always return\n     /* (non-Javadoc)\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n+    @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+\n /**\n  * Implements an input stream that can read Zip archives.\n  * <p>\n  * @NotThreadSafe\n  */\n public class ZipArchiveInputStream extends ArchiveInputStream {\n-\n-    private static final int SHORT = 2;\n-    private static final int WORD = 4;\n \n     /**\n      * The zip encoding to use for filenames and the file comment.\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextZipEntry();\n     }\n      * compression method that hasn't been implemented yet.</p>\n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public boolean canReadEntryData(ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n         return false;\n     }\n \n+    @Override\n     public int read(byte[] buffer, int start, int length) throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         throw new ArrayIndexOutOfBoundsException();\n     }\n \n+    @Override\n     public void close() throws IOException {\n         if (!closed) {\n             closed = true;\n      * @throws IOException - if an I/O error occurs.\n      * @throws IllegalArgumentException - if value is negative.\n      */\n+    @Override\n     public long skip(long value) throws IOException {\n         if (value >= 0) {\n             long skipped = 0;\n \n             long inB;\n             if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n-                inB = inf.getTotalIn();\n+                inB = inf.getBytesRead();\n             } else {\n                 inB = readBytesOfEntry;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n                 deflate();\n             }\n \n-            entry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\n-            entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\n+            entry.setSize(def.getBytesRead());\n+            entry.setCompressedSize(def.getBytesWritten());\n             entry.setCrc(realCrc);\n \n             def.reset();\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Various constants used throughout the package.\n+ *\n+ * @since Apache Commons Compress 1.3\n+ */\n+final class ZipConstants {\n+    private ZipConstants() { }\n+\n+    /** Masks last eight bits */\n+    static final int BYTE_MASK = 0xFF;\n+\n+    /** length of a ZipShort in bytes */\n+    static final int SHORT = 2;\n+\n+    /** length of a ZipLong in bytes */\n+    static final int WORD = 4;\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n \n import java.math.BigInteger;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+\n /**\n  * Utility class that represents an eight byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  * @since Apache Commons Compress 1.2\n  */\n public final class ZipEightByteInteger {\n-\n-    private static final int BYTE_MASK = 0xFF;\n \n     private static final int BYTE_1 = 1;\n     private static final int BYTE_1_MASK = 0xFF00;\n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipEightByteInteger)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the hashCode of the value stored in the ZipEightByteInteger\n      */\n+    @Override\n     public int hashCode() {\n         return value.hashCode();\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipEightByteInteger value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n         }\n     }\n \n-    private static final Map simpleEncodings;\n+    private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n \n     static {\n-        simpleEncodings = new HashMap();\n+        simpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n \n         char[] cp437_high_chars =\n             new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n             return new FallbackZipEncoding();\n         }\n \n-        SimpleEncodingHolder h =\n-            (SimpleEncodingHolder) simpleEncodings.get(name);\n+        SimpleEncodingHolder h = simpleEncodings.get(name);\n \n         if (h!=null) {\n             return h.getEncoding();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+\n /**\n  * Utility class that represents a four byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  */\n public final class ZipLong implements Cloneable {\n \n-    private static final int WORD = 4;\n     //private static final int BYTE_BIT_SIZE = 8;\n-    private static final int BYTE_MASK = 0xFF;\n \n     private static final int BYTE_1 = 1;\n     private static final int BYTE_1_MASK = 0xFF00;\n      * @since Apache Commons Compress 1.1\n      */\n     public static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n+\n+    /**\n+     * Value stored in size and similar fields if ZIP64 extensions are\n+     * used.\n+     * @since Apache Commons Compress 1.3\n+     */\n+    static final ZipLong ZIP64_MAGIC = new ZipLong(0xFFFFFFFFL);\n \n     /**\n      * Create instance from a number.\n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipLong)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipLong\n      */\n+    @Override\n     public int hashCode() {\n         return (int) value;\n     }\n \n+    @Override\n     public Object clone() {\n         try {\n             return super.clone();\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipLong value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+\n /**\n  * Utility class that represents a two byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  * @Immutable\n  */\n public final class ZipShort implements Cloneable {\n-    private static final int BYTE_MASK = 0xFF;\n     private static final int BYTE_1_MASK = 0xFF00;\n     private static final int BYTE_1_SHIFT = 8;\n \n     private final int value;\n+\n+    /**\n+     * Value stored in size and similar fields if ZIP64 extensions are\n+     * used.\n+     * @since Apache Commons Compress 1.3\n+     */\n+    static final ZipShort ZIP64_MAGIC = new ZipShort(0xFFFF);\n \n     /**\n      * Create instance from a number.\n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipShort)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipShort\n      */\n+    @Override\n     public int hashCode() {\n         return value;\n     }\n \n+    @Override\n     public Object clone() {\n         try {\n             return super.clone();\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipShort value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n     /**\n      * Assumes a negative integer really is a positive integer that\n      * has wrapped around and re-creates the original value.\n+     *\n+     * <p>This methods is no longer used as of Apache Commons Compress\n+     * 1.3</p>\n+     *\n      * @param i the value to treat as unsigned int.\n      * @return the unsigned int as a long.\n      */", "timestamp": 1311622628, "metainfo": ""}