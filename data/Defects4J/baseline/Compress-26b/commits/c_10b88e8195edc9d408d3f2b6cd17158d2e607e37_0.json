{"sha": "10b88e8195edc9d408d3f2b6cd17158d2e607e37", "log": "move bzip2 implementation to compress component   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/bzip2/BZip2Constants.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/bzip2/BZip2Constants.java,v 1.1 2003/12/02 20:43:04 dirkv Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/12/02 20:43:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.compress.bzip2;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * Base class for both the compress and decompress classes. Holds common arrays,\n+ * and static data.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+interface BZip2Constants\n+{\n+    int BASE_BLOCK_SIZE = 100000;\n+    int MAX_ALPHA_SIZE = 258;\n+    int MAX_CODE_LEN = 23;\n+    int RUNA = 0;\n+    int RUNB = 1;\n+    int N_GROUPS = 6;\n+    int G_SIZE = 50;\n+    int N_ITERS = 4;\n+    int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) );\n+    int NUM_OVERSHOOT_BYTES = 20;\n+\n+    int[] RAND_NUMS = new int[]\n+    {\n+        619, 720, 127, 481, 931, 816, 813, 233, 566, 247,\n+        985, 724, 205, 454, 863, 491, 741, 242, 949, 214,\n+        733, 859, 335, 708, 621, 574, 73, 654, 730, 472,\n+        419, 436, 278, 496, 867, 210, 399, 680, 480, 51,\n+        878, 465, 811, 169, 869, 675, 611, 697, 867, 561,\n+        862, 687, 507, 283, 482, 129, 807, 591, 733, 623,\n+        150, 238, 59, 379, 684, 877, 625, 169, 643, 105,\n+        170, 607, 520, 932, 727, 476, 693, 425, 174, 647,\n+        73, 122, 335, 530, 442, 853, 695, 249, 445, 515,\n+        909, 545, 703, 919, 874, 474, 882, 500, 594, 612,\n+        641, 801, 220, 162, 819, 984, 589, 513, 495, 799,\n+        161, 604, 958, 533, 221, 400, 386, 867, 600, 782,\n+        382, 596, 414, 171, 516, 375, 682, 485, 911, 276,\n+        98, 553, 163, 354, 666, 933, 424, 341, 533, 870,\n+        227, 730, 475, 186, 263, 647, 537, 686, 600, 224,\n+        469, 68, 770, 919, 190, 373, 294, 822, 808, 206,\n+        184, 943, 795, 384, 383, 461, 404, 758, 839, 887,\n+        715, 67, 618, 276, 204, 918, 873, 777, 604, 560,\n+        951, 160, 578, 722, 79, 804, 96, 409, 713, 940,\n+        652, 934, 970, 447, 318, 353, 859, 672, 112, 785,\n+        645, 863, 803, 350, 139, 93, 354, 99, 820, 908,\n+        609, 772, 154, 274, 580, 184, 79, 626, 630, 742,\n+        653, 282, 762, 623, 680, 81, 927, 626, 789, 125,\n+        411, 521, 938, 300, 821, 78, 343, 175, 128, 250,\n+        170, 774, 972, 275, 999, 639, 495, 78, 352, 126,\n+        857, 956, 358, 619, 580, 124, 737, 594, 701, 612,\n+        669, 112, 134, 694, 363, 992, 809, 743, 168, 974,\n+        944, 375, 748, 52, 600, 747, 642, 182, 862, 81,\n+        344, 805, 988, 739, 511, 655, 814, 334, 249, 515,\n+        897, 955, 664, 981, 649, 113, 974, 459, 893, 228,\n+        433, 837, 553, 268, 926, 240, 102, 654, 459, 51,\n+        686, 754, 806, 760, 493, 403, 415, 394, 687, 700,\n+        946, 670, 656, 610, 738, 392, 760, 799, 887, 653,\n+        978, 321, 576, 617, 626, 502, 894, 679, 243, 440,\n+        680, 879, 194, 572, 640, 724, 926, 56, 204, 700,\n+        707, 151, 457, 449, 797, 195, 791, 558, 945, 679,\n+        297, 59, 87, 824, 713, 663, 412, 693, 342, 606,\n+        134, 108, 571, 364, 631, 212, 174, 643, 304, 329,\n+        343, 97, 430, 751, 497, 314, 983, 374, 822, 928,\n+        140, 206, 73, 263, 980, 736, 876, 478, 430, 305,\n+        170, 514, 364, 692, 829, 82, 855, 953, 676, 246,\n+        369, 970, 294, 750, 807, 827, 150, 790, 288, 923,\n+        804, 378, 215, 828, 592, 281, 565, 555, 710, 82,\n+        896, 831, 547, 261, 524, 462, 293, 465, 502, 56,\n+        661, 821, 976, 991, 658, 869, 905, 758, 745, 193,\n+        768, 550, 608, 933, 378, 286, 215, 979, 792, 961,\n+        61, 688, 793, 644, 986, 403, 106, 366, 905, 644,\n+        372, 567, 466, 434, 645, 210, 389, 550, 919, 135,\n+        780, 773, 635, 389, 707, 100, 626, 958, 165, 504,\n+        920, 176, 193, 713, 857, 265, 203, 50, 668, 108,\n+        645, 990, 626, 197, 510, 357, 358, 850, 858, 364,\n+        936, 638\n+    };\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/bzip2/CBZip2InputStream.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/bzip2/CBZip2InputStream.java,v 1.1 2003/12/02 20:43:04 dirkv Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/12/02 20:43:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.bzip2;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * An input stream that decompresses from the BZip2 format (without the file\n+ * header chars) to be read as any other stream.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+public class CBZip2InputStream\n+    extends InputStream\n+    implements BZip2Constants\n+{\n+    private static final int START_BLOCK_STATE = 1;\n+    private static final int RAND_PART_A_STATE = 2;\n+    private static final int RAND_PART_B_STATE = 3;\n+    private static final int RAND_PART_C_STATE = 4;\n+    private static final int NO_RAND_PART_A_STATE = 5;\n+    private static final int NO_RAND_PART_B_STATE = 6;\n+    private static final int NO_RAND_PART_C_STATE = 7;\n+\n+    private CRC m_crc = new CRC();\n+    private boolean[] m_inUse = new boolean[ 256 ];\n+    private char[] m_seqToUnseq = new char[ 256 ];\n+    private char[] m_unseqToSeq = new char[ 256 ];\n+    private char[] m_selector = new char[ MAX_SELECTORS ];\n+    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];\n+\n+    /*\n+     * freq table collected to save a pass over the data\n+     * during decompression.\n+     */\n+    private int[] m_unzftab = new int[ 256 ];\n+\n+    private int[][] m_limit = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[][] m_base = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[][] m_perm = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[] m_minLens = new int[ N_GROUPS ];\n+\n+    private boolean m_streamEnd;\n+    private int m_currentChar = -1;\n+\n+    private int m_currentState = START_BLOCK_STATE;\n+    private int m_rNToGo;\n+    private int m_rTPos;\n+    private int m_tPos;\n+\n+    private int i2;\n+    private int count;\n+    private int chPrev;\n+    private int ch2;\n+    private int j2;\n+    private char z;\n+\n+    private boolean m_blockRandomised;\n+\n+    /*\n+     * always: in the range 0 .. 9.\n+     * The current block size is 100000 * this number.\n+     */\n+    private int m_blockSize100k;\n+    private int m_bsBuff;\n+    private int m_bsLive;\n+\n+    private InputStream m_input;\n+\n+    private int m_computedBlockCRC;\n+    private int m_computedCombinedCRC;\n+\n+    /*\n+     * index of the last char in the block, so\n+     * the block size == last + 1.\n+     */\n+    private int m_last;\n+    private char[] m_ll8;\n+    private int m_nInUse;\n+\n+    /*\n+     * index in zptr[] of original string after sorting.\n+     */\n+    private int m_origPtr;\n+\n+    private int m_storedBlockCRC;\n+    private int m_storedCombinedCRC;\n+    private int[] m_tt;\n+\n+    public CBZip2InputStream( final InputStream input )\n+    {\n+        bsSetStream( input );\n+        initialize();\n+        initBlock();\n+        setupBlock();\n+    }\n+\n+    private static void badBlockHeader()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void blockOverrun()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void cadvise()\n+    {\n+        System.out.println( \"CRC Error\" );\n+        //throw new CCoruptionError();\n+    }\n+\n+    private static void compressedStreamEOF()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void crcError()\n+    {\n+        cadvise();\n+    }\n+\n+    public int read()\n+    {\n+        if( m_streamEnd )\n+        {\n+            return -1;\n+        }\n+        else\n+        {\n+            int retChar = m_currentChar;\n+            switch( m_currentState )\n+            {\n+                case START_BLOCK_STATE:\n+                    break;\n+                case RAND_PART_A_STATE:\n+                    break;\n+                case RAND_PART_B_STATE:\n+                    setupRandPartB();\n+                    break;\n+                case RAND_PART_C_STATE:\n+                    setupRandPartC();\n+                    break;\n+                case NO_RAND_PART_A_STATE:\n+                    break;\n+                case NO_RAND_PART_B_STATE:\n+                    setupNoRandPartB();\n+                    break;\n+                case NO_RAND_PART_C_STATE:\n+                    setupNoRandPartC();\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return retChar;\n+        }\n+    }\n+\n+    private void setDecompressStructureSizes( int newSize100k )\n+    {\n+        if( !( 0 <= newSize100k && newSize100k <= 9 && 0 <= m_blockSize100k\n+            && m_blockSize100k <= 9 ) )\n+        {\n+            // throw new IOException(\"Invalid block size\");\n+        }\n+\n+        m_blockSize100k = newSize100k;\n+\n+        if( newSize100k == 0 )\n+        {\n+            return;\n+        }\n+\n+        int n = BASE_BLOCK_SIZE * newSize100k;\n+        m_ll8 = new char[ n ];\n+        m_tt = new int[ n ];\n+    }\n+\n+    private void setupBlock()\n+    {\n+        int[] cftab = new int[ 257 ];\n+        char ch;\n+\n+        cftab[ 0 ] = 0;\n+        for( int i = 1; i <= 256; i++ )\n+        {\n+            cftab[ i ] = m_unzftab[ i - 1 ];\n+        }\n+        for( int i = 1; i <= 256; i++ )\n+        {\n+            cftab[ i ] += cftab[ i - 1 ];\n+        }\n+\n+        for( int i = 0; i <= m_last; i++ )\n+        {\n+            ch = m_ll8[ i ];\n+            m_tt[ cftab[ ch ] ] = i;\n+            cftab[ ch ]++;\n+        }\n+        cftab = null;\n+\n+        m_tPos = m_tt[ m_origPtr ];\n+\n+        count = 0;\n+        i2 = 0;\n+        ch2 = 256;\n+        /*\n+         * not a char and not EOF\n+         */\n+        if( m_blockRandomised )\n+        {\n+            m_rNToGo = 0;\n+            m_rTPos = 0;\n+            setupRandPartA();\n+        }\n+        else\n+        {\n+            setupNoRandPartA();\n+        }\n+    }\n+\n+    private void setupNoRandPartA()\n+    {\n+        if( i2 <= m_last )\n+        {\n+            chPrev = ch2;\n+            ch2 = m_ll8[ m_tPos ];\n+            m_tPos = m_tt[ m_tPos ];\n+            i2++;\n+\n+            m_currentChar = ch2;\n+            m_currentState = NO_RAND_PART_B_STATE;\n+            m_crc.updateCRC( ch2 );\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            setupBlock();\n+        }\n+    }\n+\n+    private void setupNoRandPartB()\n+    {\n+        if( ch2 != chPrev )\n+        {\n+            m_currentState = NO_RAND_PART_A_STATE;\n+            count = 1;\n+            setupNoRandPartA();\n+        }\n+        else\n+        {\n+            count++;\n+            if( count >= 4 )\n+            {\n+                z = m_ll8[ m_tPos ];\n+                m_tPos = m_tt[ m_tPos ];\n+                m_currentState = NO_RAND_PART_C_STATE;\n+                j2 = 0;\n+                setupNoRandPartC();\n+            }\n+            else\n+            {\n+                m_currentState = NO_RAND_PART_A_STATE;\n+                setupNoRandPartA();\n+            }\n+        }\n+    }\n+\n+    private void setupNoRandPartC()\n+    {\n+        if( j2 < z )\n+        {\n+            m_currentChar = ch2;\n+            m_crc.updateCRC( ch2 );\n+            j2++;\n+        }\n+        else\n+        {\n+            m_currentState = NO_RAND_PART_A_STATE;\n+            i2++;\n+            count = 0;\n+            setupNoRandPartA();\n+        }\n+    }\n+\n+    private void setupRandPartA()\n+    {\n+        if( i2 <= m_last )\n+        {\n+            chPrev = ch2;\n+            ch2 = m_ll8[ m_tPos ];\n+            m_tPos = m_tt[ m_tPos ];\n+            if( m_rNToGo == 0 )\n+            {\n+                m_rNToGo = RAND_NUMS[ m_rTPos ];\n+                m_rTPos++;\n+                if( m_rTPos == 512 )\n+                {\n+                    m_rTPos = 0;\n+                }\n+            }\n+            m_rNToGo--;\n+            ch2 ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );\n+            i2++;\n+\n+            m_currentChar = ch2;\n+            m_currentState = RAND_PART_B_STATE;\n+            m_crc.updateCRC( ch2 );\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            setupBlock();\n+        }\n+    }\n+\n+    private void setupRandPartB()\n+    {\n+        if( ch2 != chPrev )\n+        {\n+            m_currentState = RAND_PART_A_STATE;\n+            count = 1;\n+            setupRandPartA();\n+        }\n+        else\n+        {\n+            count++;\n+            if( count >= 4 )\n+            {\n+                z = m_ll8[ m_tPos ];\n+                m_tPos = m_tt[ m_tPos ];\n+                if( m_rNToGo == 0 )\n+                {\n+                    m_rNToGo = RAND_NUMS[ m_rTPos ];\n+                    m_rTPos++;\n+                    if( m_rTPos == 512 )\n+                    {\n+                        m_rTPos = 0;\n+                    }\n+                }\n+                m_rNToGo--;\n+                z ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );\n+                j2 = 0;\n+                m_currentState = RAND_PART_C_STATE;\n+                setupRandPartC();\n+            }\n+            else\n+            {\n+                m_currentState = RAND_PART_A_STATE;\n+                setupRandPartA();\n+            }\n+        }\n+    }\n+\n+    private void setupRandPartC()\n+    {\n+        if( j2 < z )\n+        {\n+            m_currentChar = ch2;\n+            m_crc.updateCRC( ch2 );\n+            j2++;\n+        }\n+        else\n+        {\n+            m_currentState = RAND_PART_A_STATE;\n+            i2++;\n+            count = 0;\n+            setupRandPartA();\n+        }\n+    }\n+\n+    private void getAndMoveToFrontDecode()\n+    {\n+        int nextSym;\n+\n+        int limitLast = BASE_BLOCK_SIZE * m_blockSize100k;\n+        m_origPtr = readVariableSizedInt( 24 );\n+\n+        recvDecodingTables();\n+        int EOB = m_nInUse + 1;\n+        int groupNo = -1;\n+        int groupPos = 0;\n+\n+        /*\n+         * Setting up the unzftab entries here is not strictly\n+         * necessary, but it does save having to do it later\n+         * in a separate pass, and so saves a block's worth of\n+         * cache misses.\n+         */\n+        for( int i = 0; i <= 255; i++ )\n+        {\n+            m_unzftab[ i ] = 0;\n+        }\n+\n+        final char[] yy = new char[ 256 ];\n+        for( int i = 0; i <= 255; i++ )\n+        {\n+            yy[ i ] = (char)i;\n+        }\n+\n+        m_last = -1;\n+        int zt;\n+        int zn;\n+        int zvec;\n+        int zj;\n+        groupNo++;\n+        groupPos = G_SIZE - 1;\n+\n+        zt = m_selector[ groupNo ];\n+        zn = m_minLens[ zt ];\n+        zvec = bsR( zn );\n+        while( zvec > m_limit[ zt ][ zn ] )\n+        {\n+            zn++;\n+\n+            while( m_bsLive < 1 )\n+            {\n+                int zzi;\n+                char thech = 0;\n+                try\n+                {\n+                    thech = (char)m_input.read();\n+                }\n+                catch( IOException e )\n+                {\n+                    compressedStreamEOF();\n+                }\n+                if( thech == -1 )\n+                {\n+                    compressedStreamEOF();\n+                }\n+                zzi = thech;\n+                m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );\n+                m_bsLive += 8;\n+            }\n+\n+            zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+            m_bsLive--;\n+\n+            zvec = ( zvec << 1 ) | zj;\n+        }\n+        nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+        while( true )\n+        {\n+            if( nextSym == EOB )\n+            {\n+                break;\n+            }\n+\n+            if( nextSym == RUNA || nextSym == RUNB )\n+            {\n+                char ch;\n+                int s = -1;\n+                int N = 1;\n+                do\n+                {\n+                    if( nextSym == RUNA )\n+                    {\n+                        s = s + ( 0 + 1 ) * N;\n+                    }\n+                    else// if( nextSym == RUNB )\n+                    {\n+                        s = s + ( 1 + 1 ) * N;\n+                    }\n+                    N = N * 2;\n+\n+                    if( groupPos == 0 )\n+                    {\n+                        groupNo++;\n+                        groupPos = G_SIZE;\n+                    }\n+                    groupPos--;\n+                    zt = m_selector[ groupNo ];\n+                    zn = m_minLens[ zt ];\n+                    zvec = bsR( zn );\n+                    while( zvec > m_limit[ zt ][ zn ] )\n+                    {\n+                        zn++;\n+\n+                        while( m_bsLive < 1 )\n+                        {\n+                            int zzi;\n+                            char thech = 0;\n+                            try\n+                            {\n+                                thech = (char)m_input.read();\n+                            }\n+                            catch( IOException e )\n+                            {\n+                                compressedStreamEOF();\n+                            }\n+                            if( thech == -1 )\n+                            {\n+                                compressedStreamEOF();\n+                            }\n+                            zzi = thech;\n+                            m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );\n+                            m_bsLive += 8;\n+                        }\n+\n+                        zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+                        m_bsLive--;\n+                        zvec = ( zvec << 1 ) | zj;\n+                    }\n+\n+                    nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+                } while( nextSym == RUNA || nextSym == RUNB );\n+\n+                s++;\n+                ch = m_seqToUnseq[ yy[ 0 ] ];\n+                m_unzftab[ ch ] += s;\n+\n+                while( s > 0 )\n+                {\n+                    m_last++;\n+                    m_ll8[ m_last ] = ch;\n+                    s--;\n+                }\n+\n+                if( m_last >= limitLast )\n+                {\n+                    blockOverrun();\n+                }\n+                continue;\n+            }\n+            else\n+            {\n+                char tmp;\n+                m_last++;\n+                if( m_last >= limitLast )\n+                {\n+                    blockOverrun();\n+                }\n+\n+                tmp = yy[ nextSym - 1 ];\n+                m_unzftab[ m_seqToUnseq[ tmp ] ]++;\n+                m_ll8[ m_last ] = m_seqToUnseq[ tmp ];\n+\n+                /*\n+                 * This loop is hammered during decompression,\n+                 * hence the unrolling.\n+                 * for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];\n+                 */\n+                int j = nextSym - 1;\n+                for( ; j > 3; j -= 4 )\n+                {\n+                    yy[ j ] = yy[ j - 1 ];\n+                    yy[ j - 1 ] = yy[ j - 2 ];\n+                    yy[ j - 2 ] = yy[ j - 3 ];\n+                    yy[ j - 3 ] = yy[ j - 4 ];\n+                }\n+                for( ; j > 0; j-- )\n+                {\n+                    yy[ j ] = yy[ j - 1 ];\n+                }\n+\n+                yy[ 0 ] = tmp;\n+\n+                if( groupPos == 0 )\n+                {\n+                    groupNo++;\n+                    groupPos = G_SIZE;\n+                }\n+                groupPos--;\n+                zt = m_selector[ groupNo ];\n+                zn = m_minLens[ zt ];\n+                zvec = bsR( zn );\n+                while( zvec > m_limit[ zt ][ zn ] )\n+                {\n+                    zn++;\n+\n+                    while( m_bsLive < 1 )\n+                    {\n+                        char ch = 0;\n+                        try\n+                        {\n+                            ch = (char)m_input.read();\n+                        }\n+                        catch( IOException e )\n+                        {\n+                            compressedStreamEOF();\n+                        }\n+\n+                        m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );\n+                        m_bsLive += 8;\n+                    }\n+\n+                    zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+                    m_bsLive--;\n+\n+                    zvec = ( zvec << 1 ) | zj;\n+                }\n+                nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+                continue;\n+            }\n+        }\n+    }\n+\n+    private void bsFinishedWithStream()\n+    {\n+        m_input = null;\n+    }\n+\n+    private int readVariableSizedInt( final int numBits )\n+    {\n+        return bsR( numBits );\n+    }\n+\n+    private char readUnsignedChar()\n+    {\n+        return (char)bsR( 8 );\n+    }\n+\n+    private int readInt()\n+    {\n+        int u = 0;\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        return u;\n+    }\n+\n+    private int bsR( final int n )\n+    {\n+        while( m_bsLive < n )\n+        {\n+            char ch = 0;\n+            try\n+            {\n+                ch = (char)m_input.read();\n+            }\n+            catch( final IOException ioe )\n+            {\n+                compressedStreamEOF();\n+            }\n+\n+            if( ch == -1 )\n+            {\n+                compressedStreamEOF();\n+            }\n+\n+            m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );\n+            m_bsLive += 8;\n+        }\n+\n+        final int result = ( m_bsBuff >> ( m_bsLive - n ) ) & ( ( 1 << n ) - 1 );\n+        m_bsLive -= n;\n+        return result;\n+    }\n+\n+    private void bsSetStream( final InputStream input )\n+    {\n+        m_input = input;\n+        m_bsLive = 0;\n+        m_bsBuff = 0;\n+    }\n+\n+    private void complete()\n+    {\n+        m_storedCombinedCRC = readInt();\n+        if( m_storedCombinedCRC != m_computedCombinedCRC )\n+        {\n+            crcError();\n+        }\n+\n+        bsFinishedWithStream();\n+        m_streamEnd = true;\n+    }\n+\n+    private void endBlock()\n+    {\n+        m_computedBlockCRC = m_crc.getFinalCRC();\n+        /*\n+         * A bad CRC is considered a fatal error.\n+         */\n+        if( m_storedBlockCRC != m_computedBlockCRC )\n+        {\n+            crcError();\n+        }\n+\n+        m_computedCombinedCRC = ( m_computedCombinedCRC << 1 )\n+            | ( m_computedCombinedCRC >>> 31 );\n+        m_computedCombinedCRC ^= m_computedBlockCRC;\n+    }\n+\n+    private void hbCreateDecodeTables( final int[] limit,\n+                                       final int[] base,\n+                                       final int[] perm,\n+                                       final char[] length,\n+                                       final int minLen,\n+                                       final int maxLen,\n+                                       final int alphaSize )\n+    {\n+        int pp = 0;\n+        for( int i = minLen; i <= maxLen; i++ )\n+        {\n+            for( int j = 0; j < alphaSize; j++ )\n+            {\n+                if( length[ j ] == i )\n+                {\n+                    perm[ pp ] = j;\n+                    pp++;\n+                }\n+            }\n+        }\n+\n+        for( int i = 0; i < MAX_CODE_LEN; i++ )\n+        {\n+            base[ i ] = 0;\n+        }\n+\n+        for( int i = 0; i < alphaSize; i++ )\n+        {\n+            base[ length[ i ] + 1 ]++;\n+        }\n+\n+        for( int i = 1; i < MAX_CODE_LEN; i++ )\n+        {\n+            base[ i ] += base[ i - 1 ];\n+        }\n+\n+        for( int i = 0; i < MAX_CODE_LEN; i++ )\n+        {\n+            limit[ i ] = 0;\n+        }\n+\n+        int vec = 0;\n+        for( int i = minLen; i <= maxLen; i++ )\n+        {\n+            vec += ( base[ i + 1 ] - base[ i ] );\n+            limit[ i ] = vec - 1;\n+            vec <<= 1;\n+        }\n+\n+        for( int i = minLen + 1; i <= maxLen; i++ )\n+        {\n+            base[ i ] = ( ( limit[ i - 1 ] + 1 ) << 1 ) - base[ i ];\n+        }\n+    }\n+\n+    private void initBlock()\n+    {\n+        final char magic1 = readUnsignedChar();\n+        final char magic2 = readUnsignedChar();\n+        final char magic3 = readUnsignedChar();\n+        final char magic4 = readUnsignedChar();\n+        final char magic5 = readUnsignedChar();\n+        final char magic6 = readUnsignedChar();\n+        if( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 &&\n+            magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 )\n+        {\n+            complete();\n+            return;\n+        }\n+\n+        if( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 ||\n+            magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 )\n+        {\n+            badBlockHeader();\n+            m_streamEnd = true;\n+            return;\n+        }\n+\n+        m_storedBlockCRC = readInt();\n+\n+        if( bsR( 1 ) == 1 )\n+        {\n+            m_blockRandomised = true;\n+        }\n+        else\n+        {\n+            m_blockRandomised = false;\n+        }\n+\n+        //        currBlockNo++;\n+        getAndMoveToFrontDecode();\n+\n+        m_crc.initialiseCRC();\n+        m_currentState = START_BLOCK_STATE;\n+    }\n+\n+    private void initialize()\n+    {\n+        final char magic3 = readUnsignedChar();\n+        final char magic4 = readUnsignedChar();\n+        if( magic3 != 'h' || magic4 < '1' || magic4 > '9' )\n+        {\n+            bsFinishedWithStream();\n+            m_streamEnd = true;\n+            return;\n+        }\n+\n+        setDecompressStructureSizes( magic4 - '0' );\n+        m_computedCombinedCRC = 0;\n+    }\n+\n+    private void makeMaps()\n+    {\n+        m_nInUse = 0;\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            if( m_inUse[ i ] )\n+            {\n+                m_seqToUnseq[ m_nInUse ] = (char)i;\n+                m_unseqToSeq[ i ] = (char)m_nInUse;\n+                m_nInUse++;\n+            }\n+        }\n+    }\n+\n+    private void recvDecodingTables()\n+    {\n+        buildInUseTable();\n+        makeMaps();\n+        final int alphaSize = m_nInUse + 2;\n+\n+        /*\n+         * Now the selectors\n+         */\n+        final int groupCount = bsR( 3 );\n+        final int selectorCount = bsR( 15 );\n+        for( int i = 0; i < selectorCount; i++ )\n+        {\n+            int run = 0;\n+            while( bsR( 1 ) == 1 )\n+            {\n+                run++;\n+            }\n+            m_selectorMtf[ i ] = (char)run;\n+        }\n+\n+        /*\n+         * Undo the MTF values for the selectors.\n+         */\n+        final char[] pos = new char[ N_GROUPS ];\n+        for( char v = 0; v < groupCount; v++ )\n+        {\n+            pos[ v ] = v;\n+        }\n+\n+        for( int i = 0; i < selectorCount; i++ )\n+        {\n+            int v = m_selectorMtf[ i ];\n+            final char tmp = pos[ v ];\n+            while( v > 0 )\n+            {\n+                pos[ v ] = pos[ v - 1 ];\n+                v--;\n+            }\n+            pos[ 0 ] = tmp;\n+            m_selector[ i ] = tmp;\n+        }\n+\n+        final char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+        /*\n+         * Now the coding tables\n+         */\n+        for( int i = 0; i < groupCount; i++ )\n+        {\n+            int curr = bsR( 5 );\n+            for( int j = 0; j < alphaSize; j++ )\n+            {\n+                while( bsR( 1 ) == 1 )\n+                {\n+                    if( bsR( 1 ) == 0 )\n+                    {\n+                        curr++;\n+                    }\n+                    else\n+                    {\n+                        curr--;\n+                    }\n+                }\n+                len[ i ][ j ] = (char)curr;\n+            }\n+        }\n+\n+        /*\n+         * Create the Huffman decoding tables\n+         */\n+        for( int k = 0; k < groupCount; k++ )\n+        {\n+            int minLen = 32;\n+            int maxLen = 0;\n+            for( int i = 0; i < alphaSize; i++ )\n+            {\n+                if( len[ k ][ i ] > maxLen )\n+                {\n+                    maxLen = len[ k ][ i ];\n+                }\n+                if( len[ k ][ i ] < minLen )\n+                {\n+                    minLen = len[ k ][ i ];\n+                }\n+            }\n+            hbCreateDecodeTables( m_limit[ k ], m_base[ k ], m_perm[ k ], len[ k ], minLen,\n+                                  maxLen, alphaSize );\n+            m_minLens[ k ] = minLen;\n+        }\n+    }\n+\n+    private void buildInUseTable()\n+    {\n+        final boolean[] inUse16 = new boolean[ 16 ];\n+\n+        /*\n+         * Receive the mapping table\n+         */\n+        for( int i = 0; i < 16; i++ )\n+        {\n+            if( bsR( 1 ) == 1 )\n+            {\n+                inUse16[ i ] = true;\n+            }\n+            else\n+            {\n+                inUse16[ i ] = false;\n+            }\n+        }\n+\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        for( int i = 0; i < 16; i++ )\n+        {\n+            if( inUse16[ i ] )\n+            {\n+                for( int j = 0; j < 16; j++ )\n+                {\n+                    if( bsR( 1 ) == 1 )\n+                    {\n+                        m_inUse[ i * 16 + j ] = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/bzip2/CBZip2OutputStream.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/bzip2/CBZip2OutputStream.java,v 1.1 2003/12/02 20:43:04 dirkv Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/12/02 20:43:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.bzip2;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * An output stream that compresses into the BZip2 format (without the file\n+ * header chars) into another stream. TODO: Update to BZip2 1.0.1\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+public class CBZip2OutputStream\n+    extends OutputStream\n+    implements BZip2Constants\n+{\n+    private static final int LOWER_BYTE_MASK = 0x000000ff;\n+    private static final int UPPER_BYTE_MASK = 0xffffff00;\n+    private static final int SETMASK = ( 1 << 21 );\n+    private static final int CLEARMASK = ( ~SETMASK );\n+    private static final int GREATER_ICOST = 15;\n+    private static final int LESSER_ICOST = 0;\n+    private static final int SMALL_THRESH = 20;\n+    private static final int DEPTH_THRESH = 10;\n+\n+    /*\n+     * If you are ever unlucky/improbable enough\n+     * to get a stack overflow whilst sorting,\n+     * increase the following constant and try\n+     * again.  In practice I have never seen the\n+     * stack go above 27 elems, so the following\n+     * limit seems very generous.\n+     */\n+    private static final int QSORT_STACK_SIZE = 1000;\n+\n+    private CRC m_crc = new CRC();\n+\n+    private boolean[] m_inUse = new boolean[ 256 ];\n+\n+    private char[] m_seqToUnseq = new char[ 256 ];\n+    private char[] m_unseqToSeq = new char[ 256 ];\n+\n+    private char[] m_selector = new char[ MAX_SELECTORS ];\n+    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];\n+\n+    private int[] m_mtfFreq = new int[ MAX_ALPHA_SIZE ];\n+\n+    private int m_currentChar = -1;\n+    private int m_runLength;\n+\n+    private boolean m_closed;\n+\n+    /*\n+     * Knuth's increments seem to work better\n+     * than Incerpi-Sedgewick here.  Possibly\n+     * because the number of elems to sort is\n+     * usually small, typically <= 20.\n+     */\n+    private int[] m_incs = new int[]\n+    {\n+        1, 4, 13, 40, 121, 364, 1093, 3280,\n+        9841, 29524, 88573, 265720,\n+        797161, 2391484\n+    };\n+\n+    private boolean m_blockRandomised;\n+\n+    /*\n+     * always: in the range 0 .. 9.\n+     * The current block size is 100000 * this number.\n+     */\n+    private int m_blockSize100k;\n+    private int m_bsBuff;\n+    private int m_bsLive;\n+\n+    /*\n+     * index of the last char in the block, so\n+     * the block size == last + 1.\n+     */\n+    private int m_last;\n+\n+    /*\n+     * index in zptr[] of original string after sorting.\n+     */\n+    private int m_origPtr;\n+\n+    private int m_allowableBlockSize;\n+\n+    private char[] m_block;\n+\n+    private int m_blockCRC;\n+    private int m_combinedCRC;\n+\n+    private OutputStream m_bsStream;\n+    private boolean m_firstAttempt;\n+    private int[] m_ftab;\n+    private int m_nInUse;\n+\n+    private int m_nMTF;\n+    private int[] m_quadrant;\n+    private short[] m_szptr;\n+    private int m_workDone;\n+\n+    /*\n+     * Used when sorting.  If too many long comparisons\n+     * happen, we stop sorting, randomise the block\n+     * slightly, and try again.\n+     */\n+    private int m_workFactor;\n+    private int m_workLimit;\n+    private int[] m_zptr;\n+\n+    public CBZip2OutputStream( final OutputStream output )\n+        throws IOException\n+    {\n+        this( output, 9 );\n+    }\n+\n+    public CBZip2OutputStream( final OutputStream output, final int blockSize )\n+        throws IOException\n+    {\n+        bsSetStream( output );\n+        m_workFactor = 50;\n+\n+        int outBlockSize = blockSize;\n+        if( outBlockSize > 9 )\n+        {\n+            outBlockSize = 9;\n+        }\n+        if( outBlockSize < 1 )\n+        {\n+            outBlockSize = 1;\n+        }\n+        m_blockSize100k = outBlockSize;\n+        allocateCompressStructures();\n+        initialize();\n+        initBlock();\n+    }\n+\n+    private static void hbMakeCodeLengths( char[] len, int[] freq,\n+                                           int alphaSize, int maxLen )\n+    {\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int nNodes;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int nHeap;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int n1;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int n2;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int i;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int j;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int k;\n+        boolean tooLong;\n+\n+        int[] heap = new int[ MAX_ALPHA_SIZE + 2 ];\n+        int[] weights = new int[ MAX_ALPHA_SIZE * 2 ];\n+        int[] parent = new int[ MAX_ALPHA_SIZE * 2 ];\n+\n+        for( i = 0; i < alphaSize; i++ )\n+        {\n+            weights[ i + 1 ] = ( freq[ i ] == 0 ? 1 : freq[ i ] ) << 8;\n+        }\n+\n+        while( true )\n+        {\n+            nNodes = alphaSize;\n+            nHeap = 0;\n+\n+            heap[ 0 ] = 0;\n+            weights[ 0 ] = 0;\n+            parent[ 0 ] = -2;\n+\n+            for( i = 1; i <= alphaSize; i++ )\n+            {\n+                parent[ i ] = -1;\n+                nHeap++;\n+                heap[ nHeap ] = i;\n+                {\n+                    int zz;\n+                    int tmp;\n+                    zz = nHeap;\n+                    tmp = heap[ zz ];\n+                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )\n+                    {\n+                        heap[ zz ] = heap[ zz >> 1 ];\n+                        zz >>= 1;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+            }\n+            if( !( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) )\n+            {\n+                panic();\n+            }\n+\n+            while( nHeap > 1 )\n+            {\n+                n1 = heap[ 1 ];\n+                heap[ 1 ] = heap[ nHeap ];\n+                nHeap--;\n+                {\n+                    int zz = 0;\n+                    int yy = 0;\n+                    int tmp = 0;\n+                    zz = 1;\n+                    tmp = heap[ zz ];\n+                    while( true )\n+                    {\n+                        yy = zz << 1;\n+                        if( yy > nHeap )\n+                        {\n+                            break;\n+                        }\n+                        if( yy < nHeap &&\n+                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )\n+                        {\n+                            yy++;\n+                        }\n+                        if( weights[ tmp ] < weights[ heap[ yy ] ] )\n+                        {\n+                            break;\n+                        }\n+                        heap[ zz ] = heap[ yy ];\n+                        zz = yy;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+                n2 = heap[ 1 ];\n+                heap[ 1 ] = heap[ nHeap ];\n+                nHeap--;\n+                {\n+                    int zz = 0;\n+                    int yy = 0;\n+                    int tmp = 0;\n+                    zz = 1;\n+                    tmp = heap[ zz ];\n+                    while( true )\n+                    {\n+                        yy = zz << 1;\n+                        if( yy > nHeap )\n+                        {\n+                            break;\n+                        }\n+                        if( yy < nHeap &&\n+                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )\n+                        {\n+                            yy++;\n+                        }\n+                        if( weights[ tmp ] < weights[ heap[ yy ] ] )\n+                        {\n+                            break;\n+                        }\n+                        heap[ zz ] = heap[ yy ];\n+                        zz = yy;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+                nNodes++;\n+                parent[ n1 ] = nNodes;\n+                parent[ n2 ] = nNodes;\n+\n+                final int v1 = weights[ n1 ];\n+                final int v2 = weights[ n2 ];\n+                final int weight = calculateWeight( v1, v2 );\n+                weights[ nNodes ] = weight;\n+\n+                parent[ nNodes ] = -1;\n+                nHeap++;\n+                heap[ nHeap ] = nNodes;\n+                {\n+                    int zz = 0;\n+                    int tmp = 0;\n+                    zz = nHeap;\n+                    tmp = heap[ zz ];\n+                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )\n+                    {\n+                        heap[ zz ] = heap[ zz >> 1 ];\n+                        zz >>= 1;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+            }\n+            if( !( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) )\n+            {\n+                panic();\n+            }\n+\n+            tooLong = false;\n+            for( i = 1; i <= alphaSize; i++ )\n+            {\n+                j = 0;\n+                k = i;\n+                while( parent[ k ] >= 0 )\n+                {\n+                    k = parent[ k ];\n+                    j++;\n+                }\n+                len[ i - 1 ] = (char)j;\n+                if( j > maxLen )\n+                {\n+                    tooLong = true;\n+                }\n+            }\n+\n+            if( !tooLong )\n+            {\n+                break;\n+            }\n+\n+            for( i = 1; i < alphaSize; i++ )\n+            {\n+                j = weights[ i ] >> 8;\n+                j = 1 + ( j / 2 );\n+                weights[ i ] = j << 8;\n+            }\n+        }\n+    }\n+\n+    private static int calculateWeight( final int v1, final int v2 )\n+    {\n+        final int upper = ( v1 & UPPER_BYTE_MASK ) + ( v2 & UPPER_BYTE_MASK );\n+        final int v1Lower = ( v1 & LOWER_BYTE_MASK );\n+        final int v2Lower = ( v2 & LOWER_BYTE_MASK );\n+        final int nnnn = ( v1Lower > v2Lower ) ? v1Lower : v2Lower;\n+        return upper | ( 1 + nnnn );\n+    }\n+\n+    private static void panic()\n+    {\n+        System.out.println( \"panic\" );\n+        //throw new CError();\n+    }\n+\n+    public void close()\n+        throws IOException\n+    {\n+        if( m_closed )\n+        {\n+            return;\n+        }\n+\n+        if( m_runLength > 0 )\n+        {\n+            writeRun();\n+        }\n+        m_currentChar = -1;\n+        endBlock();\n+        endCompression();\n+        m_closed = true;\n+        super.close();\n+        m_bsStream.close();\n+    }\n+\n+    public void finalize()\n+        throws Throwable\n+    {\n+        close();\n+    }\n+\n+    public void flush()\n+        throws IOException\n+    {\n+        super.flush();\n+        m_bsStream.flush();\n+    }\n+\n+    /**\n+     * modified by Oliver Merkel, 010128\n+     *\n+     * @param bv Description of Parameter\n+     * @exception java.io.IOException Description of Exception\n+     */\n+    public void write( int bv )\n+        throws IOException\n+    {\n+        int b = ( 256 + bv ) % 256;\n+        if( m_currentChar != -1 )\n+        {\n+            if( m_currentChar == b )\n+            {\n+                m_runLength++;\n+                if( m_runLength > 254 )\n+                {\n+                    writeRun();\n+                    m_currentChar = -1;\n+                    m_runLength = 0;\n+                }\n+            }\n+            else\n+            {\n+                writeRun();\n+                m_runLength = 1;\n+                m_currentChar = b;\n+            }\n+        }\n+        else\n+        {\n+            m_currentChar = b;\n+            m_runLength++;\n+        }\n+    }\n+\n+    private void allocateCompressStructures()\n+    {\n+        int n = BASE_BLOCK_SIZE * m_blockSize100k;\n+        m_block = new char[ ( n + 1 + NUM_OVERSHOOT_BYTES ) ];\n+        m_quadrant = new int[ ( n + NUM_OVERSHOOT_BYTES ) ];\n+        m_zptr = new int[ n ];\n+        m_ftab = new int[ 65537 ];\n+\n+        if( m_block == null || m_quadrant == null || m_zptr == null\n+            || m_ftab == null )\n+        {\n+            //int totalDraw = (n + 1 + NUM_OVERSHOOT_BYTES) + (n + NUM_OVERSHOOT_BYTES) + n + 65537;\n+            //compressOutOfMemory ( totalDraw, n );\n+        }\n+\n+        /*\n+         * The back end needs a place to store the MTF values\n+         * whilst it calculates the coding tables.  We could\n+         * put them in the zptr array.  However, these values\n+         * will fit in a short, so we overlay szptr at the\n+         * start of zptr, in the hope of reducing the number\n+         * of cache misses induced by the multiple traversals\n+         * of the MTF values when calculating coding tables.\n+         * Seems to improve compression speed by about 1%.\n+         */\n+        //    szptr = zptr;\n+\n+        m_szptr = new short[ 2 * n ];\n+    }\n+\n+    private void bsFinishedWithStream()\n+        throws IOException\n+    {\n+        while( m_bsLive > 0 )\n+        {\n+            int ch = ( m_bsBuff >> 24 );\n+            try\n+            {\n+                m_bsStream.write( ch );// write 8-bit\n+            }\n+            catch( IOException e )\n+            {\n+                throw e;\n+            }\n+            m_bsBuff <<= 8;\n+            m_bsLive -= 8;\n+        }\n+    }\n+\n+    private void bsPutIntVS( int numBits, int c )\n+        throws IOException\n+    {\n+        bsW( numBits, c );\n+    }\n+\n+    private void bsPutUChar( int c )\n+        throws IOException\n+    {\n+        bsW( 8, c );\n+    }\n+\n+    private void bsPutint( int u )\n+        throws IOException\n+    {\n+        bsW( 8, ( u >> 24 ) & 0xff );\n+        bsW( 8, ( u >> 16 ) & 0xff );\n+        bsW( 8, ( u >> 8 ) & 0xff );\n+        bsW( 8, u & 0xff );\n+    }\n+\n+    private void bsSetStream( OutputStream f )\n+    {\n+        m_bsStream = f;\n+        m_bsLive = 0;\n+        m_bsBuff = 0;\n+    }\n+\n+    private void bsW( int n, int v )\n+        throws IOException\n+    {\n+        while( m_bsLive >= 8 )\n+        {\n+            int ch = ( m_bsBuff >> 24 );\n+            try\n+            {\n+                m_bsStream.write( ch );// write 8-bit\n+            }\n+            catch( IOException e )\n+            {\n+                throw e;\n+            }\n+            m_bsBuff <<= 8;\n+            m_bsLive -= 8;\n+        }\n+        m_bsBuff |= ( v << ( 32 - m_bsLive - n ) );\n+        m_bsLive += n;\n+    }\n+\n+    private void doReversibleTransformation()\n+    {\n+        int i;\n+\n+        m_workLimit = m_workFactor * m_last;\n+        m_workDone = 0;\n+        m_blockRandomised = false;\n+        m_firstAttempt = true;\n+\n+        mainSort();\n+\n+        if( m_workDone > m_workLimit && m_firstAttempt )\n+        {\n+            randomiseBlock();\n+            m_workLimit = 0;\n+            m_workDone = 0;\n+            m_blockRandomised = true;\n+            m_firstAttempt = false;\n+            mainSort();\n+        }\n+\n+        m_origPtr = -1;\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            if( m_zptr[ i ] == 0 )\n+            {\n+                m_origPtr = i;\n+                break;\n+            }\n+        }\n+        ;\n+\n+        if( m_origPtr == -1 )\n+        {\n+            panic();\n+        }\n+    }\n+\n+    private void endBlock()\n+        throws IOException\n+    {\n+        m_blockCRC = m_crc.getFinalCRC();\n+        m_combinedCRC = ( m_combinedCRC << 1 ) | ( m_combinedCRC >>> 31 );\n+        m_combinedCRC ^= m_blockCRC;\n+\n+        /*\n+         * sort the block and establish posn of original string\n+         */\n+        doReversibleTransformation();\n+\n+        /*\n+         * A 6-byte block header, the value chosen arbitrarily\n+         * as 0x314159265359 :-).  A 32 bit value does not really\n+         * give a strong enough guarantee that the value will not\n+         * appear by chance in the compressed datastream.  Worst-case\n+         * probability of this event, for a 900k block, is about\n+         * 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.\n+         * For a compressed file of size 100Gb -- about 100000 blocks --\n+         * only a 48-bit marker will do.  NB: normal compression/\n+         * decompression do *not* rely on these statistical properties.\n+         * They are only important when trying to recover blocks from\n+         * damaged files.\n+         */\n+        bsPutUChar( 0x31 );\n+        bsPutUChar( 0x41 );\n+        bsPutUChar( 0x59 );\n+        bsPutUChar( 0x26 );\n+        bsPutUChar( 0x53 );\n+        bsPutUChar( 0x59 );\n+\n+        /*\n+         * Now the block's CRC, so it is in a known place.\n+         */\n+        bsPutint( m_blockCRC );\n+\n+        /*\n+         * Now a single bit indicating randomisation.\n+         */\n+        if( m_blockRandomised )\n+        {\n+            bsW( 1, 1 );\n+        }\n+        else\n+        {\n+            bsW( 1, 0 );\n+        }\n+\n+        /*\n+         * Finally, block's contents proper.\n+         */\n+        moveToFrontCodeAndSend();\n+    }\n+\n+    private void endCompression()\n+        throws IOException\n+    {\n+        /*\n+         * Now another magic 48-bit number, 0x177245385090, to\n+         * indicate the end of the last block.  (sqrt(pi), if\n+         * you want to know.  I did want to use e, but it contains\n+         * too much repetition -- 27 18 28 18 28 46 -- for me\n+         * to feel statistically comfortable.  Call me paranoid.)\n+         */\n+        bsPutUChar( 0x17 );\n+        bsPutUChar( 0x72 );\n+        bsPutUChar( 0x45 );\n+        bsPutUChar( 0x38 );\n+        bsPutUChar( 0x50 );\n+        bsPutUChar( 0x90 );\n+\n+        bsPutint( m_combinedCRC );\n+\n+        bsFinishedWithStream();\n+    }\n+\n+    private boolean fullGtU( int i1, int i2 )\n+    {\n+        int k;\n+        char c1;\n+        char c2;\n+        int s1;\n+        int s2;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        k = m_last + 1;\n+\n+        do\n+        {\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            if( i1 > m_last )\n+            {\n+                i1 -= m_last;\n+                i1--;\n+            }\n+            ;\n+            if( i2 > m_last )\n+            {\n+                i2 -= m_last;\n+                i2--;\n+            }\n+            ;\n+\n+            k -= 4;\n+            m_workDone++;\n+        } while( k >= 0 );\n+\n+        return false;\n+    }\n+\n+    private void generateMTFValues()\n+    {\n+        char[] yy = new char[ 256 ];\n+        int i;\n+        int j;\n+        char tmp;\n+        char tmp2;\n+        int zPend;\n+        int wr;\n+        int EOB;\n+\n+        makeMaps();\n+        EOB = m_nInUse + 1;\n+\n+        for( i = 0; i <= EOB; i++ )\n+        {\n+            m_mtfFreq[ i ] = 0;\n+        }\n+\n+        wr = 0;\n+        zPend = 0;\n+        for( i = 0; i < m_nInUse; i++ )\n+        {\n+            yy[ i ] = (char)i;\n+        }\n+\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            char ll_i;\n+\n+            ll_i = m_unseqToSeq[ m_block[ m_zptr[ i ] ] ];\n+\n+            j = 0;\n+            tmp = yy[ j ];\n+            while( ll_i != tmp )\n+            {\n+                j++;\n+                tmp2 = tmp;\n+                tmp = yy[ j ];\n+                yy[ j ] = tmp2;\n+            }\n+            ;\n+            yy[ 0 ] = tmp;\n+\n+            if( j == 0 )\n+            {\n+                zPend++;\n+            }\n+            else\n+            {\n+                if( zPend > 0 )\n+                {\n+                    zPend--;\n+                    while( true )\n+                    {\n+                        switch( zPend % 2 )\n+                        {\n+                            case 0:\n+                                m_szptr[ wr ] = (short)RUNA;\n+                                wr++;\n+                                m_mtfFreq[ RUNA ]++;\n+                                break;\n+                            case 1:\n+                                m_szptr[ wr ] = (short)RUNB;\n+                                wr++;\n+                                m_mtfFreq[ RUNB ]++;\n+                                break;\n+                        }\n+                        ;\n+                        if( zPend < 2 )\n+                        {\n+                            break;\n+                        }\n+                        zPend = ( zPend - 2 ) / 2;\n+                    }\n+                    ;\n+                    zPend = 0;\n+                }\n+                m_szptr[ wr ] = (short)( j + 1 );\n+                wr++;\n+                m_mtfFreq[ j + 1 ]++;\n+            }\n+        }\n+\n+        if( zPend > 0 )\n+        {\n+            zPend--;\n+            while( true )\n+            {\n+                switch( zPend % 2 )\n+                {\n+                    case 0:\n+                        m_szptr[ wr ] = (short)RUNA;\n+                        wr++;\n+                        m_mtfFreq[ RUNA ]++;\n+                        break;\n+                    case 1:\n+                        m_szptr[ wr ] = (short)RUNB;\n+                        wr++;\n+                        m_mtfFreq[ RUNB ]++;\n+                        break;\n+                }\n+                if( zPend < 2 )\n+                {\n+                    break;\n+                }\n+                zPend = ( zPend - 2 ) / 2;\n+            }\n+        }\n+\n+        m_szptr[ wr ] = (short)EOB;\n+        wr++;\n+        m_mtfFreq[ EOB ]++;\n+\n+        m_nMTF = wr;\n+    }\n+\n+    private void hbAssignCodes( int[] code, char[] length, int minLen,\n+                                int maxLen, int alphaSize )\n+    {\n+        int n;\n+        int vec;\n+        int i;\n+\n+        vec = 0;\n+        for( n = minLen; n <= maxLen; n++ )\n+        {\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                if( length[ i ] == n )\n+                {\n+                    code[ i ] = vec;\n+                    vec++;\n+                }\n+            }\n+            ;\n+            vec <<= 1;\n+        }\n+    }\n+\n+    private void initBlock()\n+    {\n+        //        blockNo++;\n+        m_crc.initialiseCRC();\n+        m_last = -1;\n+        //        ch = 0;\n+\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        /*\n+         * 20 is just a paranoia constant\n+         */\n+        m_allowableBlockSize = BASE_BLOCK_SIZE * m_blockSize100k - 20;\n+    }\n+\n+    private void initialize()\n+        throws IOException\n+    {\n+        /*\n+         * Write `magic' bytes h indicating file-format == huffmanised,\n+         * followed by a digit indicating blockSize100k.\n+         */\n+        bsPutUChar( 'h' );\n+        bsPutUChar( '0' + m_blockSize100k );\n+\n+        m_combinedCRC = 0;\n+    }\n+\n+    private void mainSort()\n+    {\n+        int i;\n+        int j;\n+        int ss;\n+        int sb;\n+        int[] runningOrder = new int[ 256 ];\n+        int[] copy = new int[ 256 ];\n+        boolean[] bigDone = new boolean[ 256 ];\n+        int c1;\n+        int c2;\n+\n+        /*\n+         * In the various block-sized structures, live data runs\n+         * from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n+         * set up the overshoot area for block.\n+         */\n+        //   if (verbosity >= 4) fprintf ( stderr, \"        sort initialise ...\\n\" );\n+        for( i = 0; i < NUM_OVERSHOOT_BYTES; i++ )\n+        {\n+            m_block[ m_last + i + 2 ] = m_block[ ( i % ( m_last + 1 ) ) + 1 ];\n+        }\n+        for( i = 0; i <= m_last + NUM_OVERSHOOT_BYTES; i++ )\n+        {\n+            m_quadrant[ i ] = 0;\n+        }\n+\n+        m_block[ 0 ] = m_block[ m_last + 1 ];\n+\n+        if( m_last < 4000 )\n+        {\n+            /*\n+             * Use simpleSort(), since the full sorting mechanism\n+             * has quite a large constant overhead.\n+             */\n+            for( i = 0; i <= m_last; i++ )\n+            {\n+                m_zptr[ i ] = i;\n+            }\n+            m_firstAttempt = false;\n+            m_workDone = 0;\n+            m_workLimit = 0;\n+            simpleSort( 0, m_last, 0 );\n+        }\n+        else\n+        {\n+            for( i = 0; i <= 255; i++ )\n+            {\n+                bigDone[ i ] = false;\n+            }\n+\n+            for( i = 0; i <= 65536; i++ )\n+            {\n+                m_ftab[ i ] = 0;\n+            }\n+\n+            c1 = m_block[ 0 ];\n+            for( i = 0; i <= m_last; i++ )\n+            {\n+                c2 = m_block[ i + 1 ];\n+                m_ftab[ ( c1 << 8 ) + c2 ]++;\n+                c1 = c2;\n+            }\n+\n+            for( i = 1; i <= 65536; i++ )\n+            {\n+                m_ftab[ i ] += m_ftab[ i - 1 ];\n+            }\n+\n+            c1 = m_block[ 1 ];\n+            for( i = 0; i < m_last; i++ )\n+            {\n+                c2 = m_block[ i + 2 ];\n+                j = ( c1 << 8 ) + c2;\n+                c1 = c2;\n+                m_ftab[ j ]--;\n+                m_zptr[ m_ftab[ j ] ] = i;\n+            }\n+\n+            j = ( ( m_block[ m_last + 1 ] ) << 8 ) + ( m_block[ 1 ] );\n+            m_ftab[ j ]--;\n+            m_zptr[ m_ftab[ j ] ] = m_last;\n+\n+            /*\n+             * Now ftab contains the first loc of every small bucket.\n+             * Calculate the running order, from smallest to largest\n+             * big bucket.\n+             */\n+            for( i = 0; i <= 255; i++ )\n+            {\n+                runningOrder[ i ] = i;\n+            }\n+            {\n+                int vv;\n+                int h = 1;\n+                do\n+                {\n+                    h = 3 * h + 1;\n+                } while( h <= 256 );\n+                do\n+                {\n+                    h = h / 3;\n+                    for( i = h; i <= 255; i++ )\n+                    {\n+                        vv = runningOrder[ i ];\n+                        j = i;\n+                        while( ( m_ftab[ ( ( runningOrder[ j - h ] ) + 1 ) << 8 ]\n+                            - m_ftab[ ( runningOrder[ j - h ] ) << 8 ] ) >\n+                            ( m_ftab[ ( ( vv ) + 1 ) << 8 ] - m_ftab[ ( vv ) << 8 ] ) )\n+                        {\n+                            runningOrder[ j ] = runningOrder[ j - h ];\n+                            j = j - h;\n+                            if( j <= ( h - 1 ) )\n+                            {\n+                                break;\n+                            }\n+                        }\n+                        runningOrder[ j ] = vv;\n+                    }\n+                } while( h != 1 );\n+            }\n+\n+            /*\n+             * The main sorting loop.\n+             */\n+            for( i = 0; i <= 255; i++ )\n+            {\n+\n+                /*\n+                 * Process big buckets, starting with the least full.\n+                 */\n+                ss = runningOrder[ i ];\n+\n+                /*\n+                 * Complete the big bucket [ss] by quicksorting\n+                 * any unsorted small buckets [ss, j].  Hopefully\n+                 * previous pointer-scanning phases have already\n+                 * completed many of the small buckets [ss, j], so\n+                 * we don't have to sort them at all.\n+                 */\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    sb = ( ss << 8 ) + j;\n+                    if( !( ( m_ftab[ sb ] & SETMASK ) == SETMASK ) )\n+                    {\n+                        int lo = m_ftab[ sb ] & CLEARMASK;\n+                        int hi = ( m_ftab[ sb + 1 ] & CLEARMASK ) - 1;\n+                        if( hi > lo )\n+                        {\n+                            qSort3( lo, hi, 2 );\n+                            if( m_workDone > m_workLimit && m_firstAttempt )\n+                            {\n+                                return;\n+                            }\n+                        }\n+                        m_ftab[ sb ] |= SETMASK;\n+                    }\n+                }\n+\n+                /*\n+                 * The ss big bucket is now done.  Record this fact,\n+                 * and update the quadrant descriptors.  Remember to\n+                 * update quadrants in the overshoot area too, if\n+                 * necessary.  The \"if (i < 255)\" test merely skips\n+                 * this updating for the last bucket processed, since\n+                 * updating for the last bucket is pointless.\n+                 */\n+                bigDone[ ss ] = true;\n+\n+                if( i < 255 )\n+                {\n+                    int bbStart = m_ftab[ ss << 8 ] & CLEARMASK;\n+                    int bbSize = ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart;\n+                    int shifts = 0;\n+\n+                    while( ( bbSize >> shifts ) > 65534 )\n+                    {\n+                        shifts++;\n+                    }\n+\n+                    for( j = 0; j < bbSize; j++ )\n+                    {\n+                        int a2update = m_zptr[ bbStart + j ];\n+                        int qVal = ( j >> shifts );\n+                        m_quadrant[ a2update ] = qVal;\n+                        if( a2update < NUM_OVERSHOOT_BYTES )\n+                        {\n+                            m_quadrant[ a2update + m_last + 1 ] = qVal;\n+                        }\n+                    }\n+\n+                    if( !( ( ( bbSize - 1 ) >> shifts ) <= 65535 ) )\n+                    {\n+                        panic();\n+                    }\n+                }\n+\n+                /*\n+                 * Now scan this big bucket so as to synthesise the\n+                 * sorted order for small buckets [t, ss] for all t != ss.\n+                 */\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    copy[ j ] = m_ftab[ ( j << 8 ) + ss ] & CLEARMASK;\n+                }\n+\n+                for( j = m_ftab[ ss << 8 ] & CLEARMASK;\n+                     j < ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ); j++ )\n+                {\n+                    c1 = m_block[ m_zptr[ j ] ];\n+                    if( !bigDone[ c1 ] )\n+                    {\n+                        m_zptr[ copy[ c1 ] ] = m_zptr[ j ] == 0 ? m_last : m_zptr[ j ] - 1;\n+                        copy[ c1 ]++;\n+                    }\n+                }\n+\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    m_ftab[ ( j << 8 ) + ss ] |= SETMASK;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void makeMaps()\n+    {\n+        int i;\n+        m_nInUse = 0;\n+        for( i = 0; i < 256; i++ )\n+        {\n+            if( m_inUse[ i ] )\n+            {\n+                m_seqToUnseq[ m_nInUse ] = (char)i;\n+                m_unseqToSeq[ i ] = (char)m_nInUse;\n+                m_nInUse++;\n+            }\n+        }\n+    }\n+\n+    private char med3( char a, char b, char c )\n+    {\n+        char t;\n+        if( a > b )\n+        {\n+            t = a;\n+            a = b;\n+            b = t;\n+        }\n+        if( b > c )\n+        {\n+            t = b;\n+            b = c;\n+            c = t;\n+        }\n+        if( a > b )\n+        {\n+            b = a;\n+        }\n+        return b;\n+    }\n+\n+    private void moveToFrontCodeAndSend()\n+        throws IOException\n+    {\n+        bsPutIntVS( 24, m_origPtr );\n+        generateMTFValues();\n+        sendMTFValues();\n+    }\n+\n+    private void qSort3( int loSt, int hiSt, int dSt )\n+    {\n+        int unLo;\n+        int unHi;\n+        int ltLo;\n+        int gtHi;\n+        int med;\n+        int n;\n+        int m;\n+        int sp;\n+        int lo;\n+        int hi;\n+        int d;\n+        StackElem[] stack = new StackElem[ QSORT_STACK_SIZE ];\n+        for( int count = 0; count < QSORT_STACK_SIZE; count++ )\n+        {\n+            stack[ count ] = new StackElem();\n+        }\n+\n+        sp = 0;\n+\n+        stack[ sp ].m_ll = loSt;\n+        stack[ sp ].m_hh = hiSt;\n+        stack[ sp ].m_dd = dSt;\n+        sp++;\n+\n+        while( sp > 0 )\n+        {\n+            if( sp >= QSORT_STACK_SIZE )\n+            {\n+                panic();\n+            }\n+\n+            sp--;\n+            lo = stack[ sp ].m_ll;\n+            hi = stack[ sp ].m_hh;\n+            d = stack[ sp ].m_dd;\n+\n+            if( hi - lo < SMALL_THRESH || d > DEPTH_THRESH )\n+            {\n+                simpleSort( lo, hi, d );\n+                if( m_workDone > m_workLimit && m_firstAttempt )\n+                {\n+                    return;\n+                }\n+                continue;\n+            }\n+\n+            med = med3( m_block[ m_zptr[ lo ] + d + 1 ],\n+                        m_block[ m_zptr[ hi ] + d + 1 ],\n+                        m_block[ m_zptr[ ( lo + hi ) >> 1 ] + d + 1 ] );\n+\n+            unLo = lo;\n+            ltLo = lo;\n+            unHi = hi;\n+            gtHi = hi;\n+\n+            while( true )\n+            {\n+                while( true )\n+                {\n+                    if( unLo > unHi )\n+                    {\n+                        break;\n+                    }\n+                    n = m_block[ m_zptr[ unLo ] + d + 1 ] - med;\n+                    if( n == 0 )\n+                    {\n+                        int temp = 0;\n+                        temp = m_zptr[ unLo ];\n+                        m_zptr[ unLo ] = m_zptr[ ltLo ];\n+                        m_zptr[ ltLo ] = temp;\n+                        ltLo++;\n+                        unLo++;\n+                        continue;\n+                    }\n+                    ;\n+                    if( n > 0 )\n+                    {\n+                        break;\n+                    }\n+                    unLo++;\n+                }\n+                while( true )\n+                {\n+                    if( unLo > unHi )\n+                    {\n+                        break;\n+                    }\n+                    n = m_block[ m_zptr[ unHi ] + d + 1 ] - med;\n+                    if( n == 0 )\n+                    {\n+                        int temp = 0;\n+                        temp = m_zptr[ unHi ];\n+                        m_zptr[ unHi ] = m_zptr[ gtHi ];\n+                        m_zptr[ gtHi ] = temp;\n+                        gtHi--;\n+                        unHi--;\n+                        continue;\n+                    }\n+                    ;\n+                    if( n < 0 )\n+                    {\n+                        break;\n+                    }\n+                    unHi--;\n+                }\n+                if( unLo > unHi )\n+                {\n+                    break;\n+                }\n+                int temp = 0;\n+                temp = m_zptr[ unLo ];\n+                m_zptr[ unLo ] = m_zptr[ unHi ];\n+                m_zptr[ unHi ] = temp;\n+                unLo++;\n+                unHi--;\n+            }\n+\n+            if( gtHi < ltLo )\n+            {\n+                stack[ sp ].m_ll = lo;\n+                stack[ sp ].m_hh = hi;\n+                stack[ sp ].m_dd = d + 1;\n+                sp++;\n+                continue;\n+            }\n+\n+            n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo );\n+            vswap( lo, unLo - n, n );\n+            m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi );\n+            vswap( unLo, hi - m + 1, m );\n+\n+            n = lo + unLo - ltLo - 1;\n+            m = hi - ( gtHi - unHi ) + 1;\n+\n+            stack[ sp ].m_ll = lo;\n+            stack[ sp ].m_hh = n;\n+            stack[ sp ].m_dd = d;\n+            sp++;\n+\n+            stack[ sp ].m_ll = n + 1;\n+            stack[ sp ].m_hh = m - 1;\n+            stack[ sp ].m_dd = d + 1;\n+            sp++;\n+\n+            stack[ sp ].m_ll = m;\n+            stack[ sp ].m_hh = hi;\n+            stack[ sp ].m_dd = d;\n+            sp++;\n+        }\n+    }\n+\n+    private void randomiseBlock()\n+    {\n+        int i;\n+        int rNToGo = 0;\n+        int rTPos = 0;\n+        for( i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            if( rNToGo == 0 )\n+            {\n+                rNToGo = (char)RAND_NUMS[ rTPos ];\n+                rTPos++;\n+                if( rTPos == 512 )\n+                {\n+                    rTPos = 0;\n+                }\n+            }\n+            rNToGo--;\n+            m_block[ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 );\n+            // handle 16 bit signed numbers\n+            m_block[ i + 1 ] &= 0xFF;\n+\n+            m_inUse[ m_block[ i + 1 ] ] = true;\n+        }\n+    }\n+\n+    private void sendMTFValues()\n+        throws IOException\n+    {\n+        char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+\n+        int v;\n+\n+        int t;\n+\n+        int i;\n+\n+        int j;\n+\n+        int gs;\n+\n+        int ge;\n+\n+        int bt;\n+\n+        int bc;\n+\n+        int iter;\n+        int nSelectors = 0;\n+        int alphaSize;\n+        int minLen;\n+        int maxLen;\n+        int selCtr;\n+        int nGroups;\n+\n+        alphaSize = m_nInUse + 2;\n+        for( t = 0; t < N_GROUPS; t++ )\n+        {\n+            for( v = 0; v < alphaSize; v++ )\n+            {\n+                len[ t ][ v ] = (char)GREATER_ICOST;\n+            }\n+        }\n+\n+        /*\n+         * Decide how many coding tables to use\n+         */\n+        if( m_nMTF <= 0 )\n+        {\n+            panic();\n+        }\n+\n+        if( m_nMTF < 200 )\n+        {\n+            nGroups = 2;\n+        }\n+        else if( m_nMTF < 600 )\n+        {\n+            nGroups = 3;\n+        }\n+        else if( m_nMTF < 1200 )\n+        {\n+            nGroups = 4;\n+        }\n+        else if( m_nMTF < 2400 )\n+        {\n+            nGroups = 5;\n+        }\n+        else\n+        {\n+            nGroups = 6;\n+        }\n+        {\n+            /*\n+             * Generate an initial set of coding tables\n+             */\n+            int nPart;\n+            int remF;\n+            int tFreq;\n+            int aFreq;\n+\n+            nPart = nGroups;\n+            remF = m_nMTF;\n+            gs = 0;\n+            while( nPart > 0 )\n+            {\n+                tFreq = remF / nPart;\n+                ge = gs - 1;\n+                aFreq = 0;\n+                while( aFreq < tFreq && ge < alphaSize - 1 )\n+                {\n+                    ge++;\n+                    aFreq += m_mtfFreq[ ge ];\n+                }\n+\n+                if( ge > gs && nPart != nGroups && nPart != 1\n+                    && ( ( nGroups - nPart ) % 2 == 1 ) )\n+                {\n+                    aFreq -= m_mtfFreq[ ge ];\n+                    ge--;\n+                }\n+\n+                for( v = 0; v < alphaSize; v++ )\n+                {\n+                    if( v >= gs && v <= ge )\n+                    {\n+                        len[ nPart - 1 ][ v ] = (char)LESSER_ICOST;\n+                    }\n+                    else\n+                    {\n+                        len[ nPart - 1 ][ v ] = (char)GREATER_ICOST;\n+                    }\n+                }\n+\n+                nPart--;\n+                gs = ge + 1;\n+                remF -= aFreq;\n+            }\n+        }\n+\n+        int[][] rfreq = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+        int[] fave = new int[ N_GROUPS ];\n+        short[] cost = new short[ N_GROUPS ];\n+        /*\n+         * Iterate up to N_ITERS times to improve the tables.\n+         */\n+        for( iter = 0; iter < N_ITERS; iter++ )\n+        {\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                fave[ t ] = 0;\n+            }\n+\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                for( v = 0; v < alphaSize; v++ )\n+                {\n+                    rfreq[ t ][ v ] = 0;\n+                }\n+            }\n+\n+            nSelectors = 0;\n+            gs = 0;\n+            while( true )\n+            {\n+\n+                /*\n+                 * Set group start & end marks.\n+                 */\n+                if( gs >= m_nMTF )\n+                {\n+                    break;\n+                }\n+                ge = gs + G_SIZE - 1;\n+                if( ge >= m_nMTF )\n+                {\n+                    ge = m_nMTF - 1;\n+                }\n+\n+                /*\n+                 * Calculate the cost of this group as coded\n+                 * by each of the coding tables.\n+                 */\n+                for( t = 0; t < nGroups; t++ )\n+                {\n+                    cost[ t ] = 0;\n+                }\n+\n+                if( nGroups == 6 )\n+                {\n+                    short cost0 = 0;\n+                    short cost1 = 0;\n+                    short cost2 = 0;\n+                    short cost3 = 0;\n+                    short cost4 = 0;\n+                    short cost5 = 0;\n+\n+                    for( i = gs; i <= ge; i++ )\n+                    {\n+                        short icv = m_szptr[ i ];\n+                        cost0 += len[ 0 ][ icv ];\n+                        cost1 += len[ 1 ][ icv ];\n+                        cost2 += len[ 2 ][ icv ];\n+                        cost3 += len[ 3 ][ icv ];\n+                        cost4 += len[ 4 ][ icv ];\n+                        cost5 += len[ 5 ][ icv ];\n+                    }\n+                    cost[ 0 ] = cost0;\n+                    cost[ 1 ] = cost1;\n+                    cost[ 2 ] = cost2;\n+                    cost[ 3 ] = cost3;\n+                    cost[ 4 ] = cost4;\n+                    cost[ 5 ] = cost5;\n+                }\n+                else\n+                {\n+                    for( i = gs; i <= ge; i++ )\n+                    {\n+                        short icv = m_szptr[ i ];\n+                        for( t = 0; t < nGroups; t++ )\n+                        {\n+                            cost[ t ] += len[ t ][ icv ];\n+                        }\n+                    }\n+                }\n+\n+                /*\n+                 * Find the coding table which is best for this group,\n+                 * and record its identity in the selector table.\n+                 */\n+                bc = 999999999;\n+                bt = -1;\n+                for( t = 0; t < nGroups; t++ )\n+                {\n+                    if( cost[ t ] < bc )\n+                    {\n+                        bc = cost[ t ];\n+                        bt = t;\n+                    }\n+                }\n+                ;\n+                fave[ bt ]++;\n+                m_selector[ nSelectors ] = (char)bt;\n+                nSelectors++;\n+\n+                /*\n+                 * Increment the symbol frequencies for the selected table.\n+                 */\n+                for( i = gs; i <= ge; i++ )\n+                {\n+                    rfreq[ bt ][ m_szptr[ i ] ]++;\n+                }\n+\n+                gs = ge + 1;\n+            }\n+\n+            /*\n+             * Recompute the tables based on the accumulated frequencies.\n+             */\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                hbMakeCodeLengths( len[ t ], rfreq[ t ], alphaSize, 20 );\n+            }\n+        }\n+\n+        rfreq = null;\n+        fave = null;\n+        cost = null;\n+\n+        if( !( nGroups < 8 ) )\n+        {\n+            panic();\n+        }\n+        if( !( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) )\n+        {\n+            panic();\n+        }\n+        {\n+            /*\n+             * Compute MTF values for the selectors.\n+             */\n+            char[] pos = new char[ N_GROUPS ];\n+            char ll_i;\n+            char tmp2;\n+            char tmp;\n+            for( i = 0; i < nGroups; i++ )\n+            {\n+                pos[ i ] = (char)i;\n+            }\n+            for( i = 0; i < nSelectors; i++ )\n+            {\n+                ll_i = m_selector[ i ];\n+                j = 0;\n+                tmp = pos[ j ];\n+                while( ll_i != tmp )\n+                {\n+                    j++;\n+                    tmp2 = tmp;\n+                    tmp = pos[ j ];\n+                    pos[ j ] = tmp2;\n+                }\n+                pos[ 0 ] = tmp;\n+                m_selectorMtf[ i ] = (char)j;\n+            }\n+        }\n+\n+        int[][] code = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+\n+        /*\n+         * Assign actual codes for the tables.\n+         */\n+        for( t = 0; t < nGroups; t++ )\n+        {\n+            minLen = 32;\n+            maxLen = 0;\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                if( len[ t ][ i ] > maxLen )\n+                {\n+                    maxLen = len[ t ][ i ];\n+                }\n+                if( len[ t ][ i ] < minLen )\n+                {\n+                    minLen = len[ t ][ i ];\n+                }\n+            }\n+            if( maxLen > 20 )\n+            {\n+                panic();\n+            }\n+            if( minLen < 1 )\n+            {\n+                panic();\n+            }\n+            hbAssignCodes( code[ t ], len[ t ], minLen, maxLen, alphaSize );\n+        }\n+        {\n+            /*\n+             * Transmit the mapping table.\n+             */\n+            boolean[] inUse16 = new boolean[ 16 ];\n+            for( i = 0; i < 16; i++ )\n+            {\n+                inUse16[ i ] = false;\n+                for( j = 0; j < 16; j++ )\n+                {\n+                    if( m_inUse[ i * 16 + j ] )\n+                    {\n+                        inUse16[ i ] = true;\n+                    }\n+                }\n+            }\n+\n+            for( i = 0; i < 16; i++ )\n+            {\n+                if( inUse16[ i ] )\n+                {\n+                    bsW( 1, 1 );\n+                }\n+                else\n+                {\n+                    bsW( 1, 0 );\n+                }\n+            }\n+\n+            for( i = 0; i < 16; i++ )\n+            {\n+                if( inUse16[ i ] )\n+                {\n+                    for( j = 0; j < 16; j++ )\n+                    {\n+                        if( m_inUse[ i * 16 + j ] )\n+                        {\n+                            bsW( 1, 1 );\n+                        }\n+                        else\n+                        {\n+                            bsW( 1, 0 );\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        /*\n+         * Now the selectors.\n+         */\n+        bsW( 3, nGroups );\n+        bsW( 15, nSelectors );\n+        for( i = 0; i < nSelectors; i++ )\n+        {\n+            for( j = 0; j < m_selectorMtf[ i ]; j++ )\n+            {\n+                bsW( 1, 1 );\n+            }\n+            bsW( 1, 0 );\n+        }\n+\n+        for( t = 0; t < nGroups; t++ )\n+        {\n+            int curr = len[ t ][ 0 ];\n+            bsW( 5, curr );\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                while( curr < len[ t ][ i ] )\n+                {\n+                    bsW( 2, 2 );\n+                    curr++;\n+                    /*\n+                     * 10\n+                     */\n+                }\n+                while( curr > len[ t ][ i ] )\n+                {\n+                    bsW( 2, 3 );\n+                    curr--;\n+                    /*\n+                     * 11\n+                     */\n+                }\n+                bsW( 1, 0 );\n+            }\n+        }\n+\n+        /*\n+         * And finally, the block data proper\n+         */\n+        selCtr = 0;\n+        gs = 0;\n+        while( true )\n+        {\n+            if( gs >= m_nMTF )\n+            {\n+                break;\n+            }\n+            ge = gs + G_SIZE - 1;\n+            if( ge >= m_nMTF )\n+            {\n+                ge = m_nMTF - 1;\n+            }\n+            for( i = gs; i <= ge; i++ )\n+            {\n+                bsW( len[ m_selector[ selCtr ] ][ m_szptr[ i ] ],\n+                     code[ m_selector[ selCtr ] ][ m_szptr[ i ] ] );\n+            }\n+\n+            gs = ge + 1;\n+            selCtr++;\n+        }\n+        if( !( selCtr == nSelectors ) )\n+        {\n+            panic();\n+        }\n+    }\n+\n+    private void simpleSort( int lo, int hi, int d )\n+    {\n+        int i;\n+        int j;\n+        int h;\n+        int bigN;\n+        int hp;\n+        int v;\n+\n+        bigN = hi - lo + 1;\n+        if( bigN < 2 )\n+        {\n+            return;\n+        }\n+\n+        hp = 0;\n+        while( m_incs[ hp ] < bigN )\n+        {\n+            hp++;\n+        }\n+        hp--;\n+\n+        for( ; hp >= 0; hp-- )\n+        {\n+            h = m_incs[ hp ];\n+\n+            i = lo + h;\n+            while( true )\n+            {\n+                /*\n+                 * copy 1\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                /*\n+                 * copy 2\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                /*\n+                 * copy 3\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                if( m_workDone > m_workLimit && m_firstAttempt )\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void vswap( int p1, int p2, int n )\n+    {\n+        int temp = 0;\n+        while( n > 0 )\n+        {\n+            temp = m_zptr[ p1 ];\n+            m_zptr[ p1 ] = m_zptr[ p2 ];\n+            m_zptr[ p2 ] = temp;\n+            p1++;\n+            p2++;\n+            n--;\n+        }\n+    }\n+\n+    private void writeRun()\n+        throws IOException\n+    {\n+        if( m_last < m_allowableBlockSize )\n+        {\n+            m_inUse[ m_currentChar ] = true;\n+            for( int i = 0; i < m_runLength; i++ )\n+            {\n+                m_crc.updateCRC( (char)m_currentChar );\n+            }\n+            switch( m_runLength )\n+            {\n+                case 1:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                case 2:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                case 3:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                default:\n+                    m_inUse[ m_runLength - 4 ] = true;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)( m_runLength - 4 );\n+                    break;\n+            }\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            writeRun();\n+        }\n+    }\n+\n+    private static class StackElem\n+    {\n+        int m_dd;\n+        int m_hh;\n+        int m_ll;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/bzip2/CRC.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/bzip2/CRC.java,v 1.1 2003/12/02 20:43:04 dirkv Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/12/02 20:43:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.bzip2;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * A simple class the hold and calculate the CRC for sanity checking of the\n+ * data.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+class CRC\n+{\n+    private static int[] CRC32_TABLE = new int[]\n+    {\n+        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n+        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n+        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n+        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n+        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n+        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n+        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n+        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n+        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n+        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n+        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n+        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n+        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n+        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n+        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n+        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n+        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n+        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n+        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n+        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n+        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n+        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n+        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n+        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n+        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n+        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n+        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n+        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n+        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n+        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n+        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n+        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n+        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n+        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n+        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n+        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n+        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n+        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n+        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n+        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n+        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n+        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n+        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n+        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n+        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n+        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n+        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n+        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n+        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n+        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n+        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n+        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n+        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n+        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n+        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n+        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n+        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n+        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n+        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n+        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n+        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n+        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n+        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n+        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n+    };\n+\n+    private int m_globalCrc;\n+\n+    protected CRC()\n+    {\n+        initialiseCRC();\n+    }\n+\n+    int getFinalCRC()\n+    {\n+        return ~m_globalCrc;\n+    }\n+\n+    void initialiseCRC()\n+    {\n+        m_globalCrc = 0xffffffff;\n+    }\n+\n+    void updateCRC( final int inCh )\n+    {\n+        int temp = ( m_globalCrc >> 24 ) ^ inCh;\n+        if( temp < 0 )\n+        {\n+            temp = 256 + temp;\n+        }\n+        m_globalCrc = ( m_globalCrc << 8 ) ^ CRC32_TABLE[ temp ];\n+    }\n+}\n+", "timestamp": 1070397784, "metainfo": ""}