{"sha": "59896525b912d1bbede71aba1ae568b4305ec6ff", "log": "Add support for archive header decompression/decryption. Streams that filter should extend FilterInputStream.    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.io.DataInput;\n import java.io.DataInputStream;\n import java.io.File;\n+import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.RandomAccessFile;\n  * encryption types, but at the moment only\n  * only Copy, LZMA2, BZIP2, and AES-256 + SHA-256\n  * are supported, and archive header compression\n- * (which always uses the unsupported LZMA\n+ * (when it uses the unsupported LZMA\n  * compression) isn't. So the only archives\n  * that can be read are the following:\n  * <pre>\n- * 7z a -mhc=off -mx=0 [-ppassword] archive.7z files\n- * 7z a -mhc=off -m0=LZMA2 [-ppassword] archive.7z files\n- * 7z a -mhc=off -m0=BZIP2 [-ppassword] archive.7z files\n+ * 7z a -mhc=off [-mhe=on] -mx=0 [-ppassword] archive.7z files\n+ * 7z a -mhc=off [-mhe=on] -m0=LZMA2 [-ppassword] archive.7z files\n+ * 7z a -mhc=off [-mhe=on] -m0=BZIP2 [-ppassword] archive.7z files\n  * </pre>\n  * <p>\n  * The format is very Windows/Intel specific,\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n     \n-    public SevenZFile(final File filename) throws IOException {\n+    public SevenZFile(final File filename, final String password) throws IOException {\n         boolean succeeded = false;\n+        this.password = password;\n         this.file = new RandomAccessFile(filename, \"r\");\n         try {\n             archive = readHeaders();\n         }\n     }\n     \n-    public SevenZFile(final File filename, final String password) throws IOException {\n-        this(filename);\n-        this.password = password;\n+    public SevenZFile(final File filename) throws IOException {\n+        this(filename, null);\n     }\n \n     public void close() {\n             throw new IOException(\"NextHeader CRC mismatch\");\n         }\n         \n-        final Archive archive = new Archive();\n         final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n-        final DataInputStream nextHeaderInputStream = new DataInputStream(\n+        DataInputStream nextHeaderInputStream = new DataInputStream(\n                 byteStream);\n+        Archive archive = new Archive();\n         int nid = nextHeaderInputStream.readUnsignedByte();\n         if (nid == NID.kEncodedHeader) {\n-            readEncodedHeader(nextHeaderInputStream, archive);\n+            nextHeaderInputStream = readEncodedHeader(nextHeaderInputStream, archive);\n+            // Archive gets rebuilt with the new header\n+            archive = new Archive();\n             nid = nextHeaderInputStream.readUnsignedByte();\n         }\n         if (nid == NID.kHeader) {\n             readHeader(nextHeaderInputStream, archive);\n+        } else {\n+            throw new IOException(\"Broken or unsupported archive: no Header\");\n         }\n         return archive;\n     }\n         }\n     }\n     \n-    private void readEncodedHeader(final DataInputStream header, final Archive archive) throws IOException {\n+    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive) throws IOException {\n         debug(\"EncodedHeader\");\n \n         readStreamsInfo(header, archive);\n         \n-        // FIXME: and decompress it etc.\n-        \n-        throw new IOException(\"LZMA compression unsupported, so files with compressed header cannot be read\");\n+        // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n+        final Folder folder = archive.folders[0];\n+        final int firstPackStreamIndex = 0;\n+        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n+                0;\n+        \n+        file.seek(folderOffset);\n+        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n+                archive.packSizes[firstPackStreamIndex]);\n+        for (final Coder coder : folder.coders) {\n+            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n+                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n+            }\n+            inputStreamStack = Coders.addDecoder(inputStreamStack, coder, password);\n+        }\n+        if (folder.hasCrc) {\n+            inputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\n+                    folder.getUnpackSize(), folder.crc);\n+        }\n+        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n+        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n+        try {\n+            nextHeaderInputStream.readFully(nextHeader);\n+        } finally {\n+            nextHeaderInputStream.close();\n+        }\n+        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n+\n+        \n+        //throw new IOException(\"LZMA compression unsupported, so files with compressed header cannot be read\");\n         // FIXME: this extracts the header to an LZMA file which can then be\n         // manually decompressed.\n //        long offset = SIGNATURE_HEADER_SIZE + archive.packPos;\n         return value;\n     }\n     \n-    private static class BoundedInputStream extends InputStream {\n-        private InputStream is;\n+    private static class BoundedInputStream extends FilterInputStream {\n         private long bytesRemaining;\n         \n-        public BoundedInputStream(final InputStream is, final long size) {\n-            this.is = is;\n+        public BoundedInputStream(final InputStream in, final long size) {\n+            super(in);\n             bytesRemaining = size;\n         }\n         \n         public int read() throws IOException {\n             if (bytesRemaining > 0) {\n                 --bytesRemaining;\n-                return is.read();\n+                return in.read();\n             } else {\n                 return -1;\n             }\n             if (bytesToRead > bytesRemaining) {\n                 bytesToRead = (int) bytesRemaining;\n             }\n-            final int bytesRead = is.read(b, off, bytesToRead);\n+            final int bytesRead = in.read(b, off, bytesToRead);\n             if (bytesRead >= 0) {\n                 bytesRemaining -= bytesRead;\n             }\n--- a/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n  */\n package org.apache.commons.compress.utils;\n \n+import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.zip.CRC32;\n \n-public class CRC32VerifyingInputStream extends InputStream {\n-    private final InputStream is;\n+public class CRC32VerifyingInputStream extends FilterInputStream {\n     private long bytesRemaining;\n     private final int expectedCrc32;\n     private final CRC32 crc32 = new CRC32();\n     \n-    public CRC32VerifyingInputStream(final InputStream is, final long size, final int expectedCrc32) {\n-        this.is = is;\n+    public CRC32VerifyingInputStream(final InputStream in, final long size, final int expectedCrc32) {\n+        super(in);\n         this.expectedCrc32 = expectedCrc32;\n         this.bytesRemaining = size;\n     }\n         if (bytesRemaining <= 0) {\n             return -1;\n         }\n-        int ret = is.read();\n+        int ret = in.read();\n         if (ret >= 0) {\n             crc32.update(ret);\n             --bytesRemaining;\n \n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-        int ret = is.read(b, off, len);\n+        int ret = in.read(b, off, len);\n         if (ret >= 0) {\n             crc32.update(b, off, ret);\n             bytesRemaining -= ret;\n \n     @Override\n     public void close() throws IOException {\n-        is.close();\n+        in.close();\n     }\n }", "timestamp": 1368732023, "metainfo": ""}