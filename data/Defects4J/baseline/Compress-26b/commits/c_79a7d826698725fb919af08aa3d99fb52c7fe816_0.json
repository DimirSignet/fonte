{"sha": "79a7d826698725fb919af08aa3d99fb52c7fe816", "log": "COMPRESS-206 read second Tar-EOF record as well, if there is one.  Based on patch by Peter De Maeyer  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             hasHitEOF = true;\n         } else if (buffer.isEOFRecord(headerBuf)) {\n             hasHitEOF = true;\n+            buffer.tryToConsumeSecondEOFRecord();\n         }\n \n         return hasHitEOF ? null : headerBuf;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n             inStream = null;\n         }\n     }\n+\n+    /**\n+     * Tries to read the next record rewinding the stream if if is not a EOF record.\n+     *\n+     * <p>This is meant to protect against cases where a tar\n+     * implemenation has written only one EOF record when two are\n+     * expected.  Actually this won't help since a non-conforming\n+     * implementation likely won't fill full blocks consisting of - be\n+     * default - ten records either so we probably have already read\n+     * beyond the archive anyway.</p>\n+     */\n+    void tryToConsumeSecondEOFRecord() throws IOException {\n+        boolean shouldReset = true;\n+        boolean marked = inStream.markSupported();\n+        if (marked) {\n+            inStream.mark(recordSize);\n+        }\n+        try {\n+            shouldReset = !isEOFRecord(readRecord());\n+        } finally {\n+            if (shouldReset && marked) {\n+                inStream.reset();\n+            }\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n \n package org.apache.commons.compress.archivers.tar;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n+import java.io.InputStream;\n import java.io.IOException;\n import java.net.URI;\n import java.net.URL;\n         tis.close();\n     }\n \n+    @Test\n+    public void shouldConsumeArchiveCompletely() throws Exception {\n+        InputStream is = TarArchiveInputStreamTest.class\n+            .getResourceAsStream(\"/archive_with_trailer.tar\");\n+        TarArchiveInputStream tar = new TarArchiveInputStream(is);\n+        while (tar.getNextTarEntry() != null) {\n+            // just consume the archive\n+            ;\n+        }\n+        byte[] expected = new byte[] {\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n+        };\n+        byte[] actual = new byte[expected.length];\n+        is.read(actual);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n     private TarArchiveInputStream getTestStream(String name) {\n         return new TarArchiveInputStream(\n                 TarArchiveInputStreamTest.class.getResourceAsStream(name));", "timestamp": 1358709024, "metainfo": ""}