{"sha": "ea31005111f0abede7e43e4ba0012e62e0808b22", "log": "Add some explanations, mark comments originally made by Julian Seward  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n  * Encapsulates the Burrows-Wheeler sorting algorithm needed by {@link\n  * BZip2CompressorOutputStream}.\n  *\n+ * <p>This class is based on a Java port of Julian Seward's\n+ * blocksort.c in his libbzip2</p>\n+ *\n+ * <p>The Burrows-Wheeler transform is a reversible transform of the\n+ * original data that is supposed to group similiar bytes close to\n+ * each other.  The idea is to sort all permutations of the input and\n+ * only keep the last byte of each permutation.  E.g. for \"Commons\n+ * Compress\" you'd get:</p>\n+ *\n+ * <pre>\n+ * Commons Compress\n+ * CompressCommons \n+ * essCommons Compr\n+ * mmons CompressCo\n+ * mons CompressCom\n+ * mpressCommons Co\n+ * ns CompressCommo\n+ * ommons CompressC\n+ * ompressCommons C\n+ * ons CompressComm\n+ * pressCommons Com\n+ * ressCommons Comp\n+ * s CompressCommon\n+ * sCommons Compres\n+ * ssCommons Compre\n+ * </pre>\n+ *\n+ * <p>Which results in a new text \"s romooCCmmpnse\", in adition the\n+ * index of the first line that contained the original text is kept -\n+ * in this case it is 0.  The idea is that in a long English text all\n+ * permutations that start with \"he\" are likely suffixes of a \"the\" and\n+ * thus they end in \"t\" leading to a larger block of \"t\"s that can\n+ * better be compressed by the subsequent Move-to-Front, run-length\n+ * und Huffman encoding steps.</p>\n+ *\n+ * <p>For more information see for example:</p>\n+ * <ul>\n+ *   <li><a\n+ *   href=\"http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf\">Burrows,\n+ *   M. and Wheeler, D.: A Block-sorting Lossless Data Compression\n+ *   Algorithm</a></li>\n+ *   <li><a href=\"http://webglimpse.net/pubs/suffix.pdf\">Manber, U. and\n+ *   Myers, G.: Suffix arrays: A new method for on-line string\n+ *   searches</a></li>\n+ *   <li><a\n+ *   href=\"http://www.cs.tufts.edu/~nr/comp150fp/archive/bob-sedgewick/fast-strings.pdf\">Bentley,\n+ *   J.L. and Sedgewick, R.: Fast Algorithms for Sorting and Searching\n+ *   Strings</a></li>\n+ * </ul>\n+ *\n  * @NotThreadSafe\n  */\n class BlockSort {\n+\n+    /*\n+     * Some of the constructs used in the C code cannot be ported\n+     * literally to Java - for example macros, unsigned types.  Some\n+     * code has been hand-tuned to improve performance.  In order to\n+     * avoid memory pressure some structures are reused for several\n+     * blocks and some memory is even shared between sorting and the\n+     * MTF stage even though either algorithm uses it for its own\n+     * purpose.\n+     *\n+     * Comments preserved from the actual C code are prefixed with\n+     * \"LBZ2:\".\n+     */\n+\n+    /*\n+     * 2012-05-20 Stefan Bodewig:\n+     *\n+     * The class seems to mix several revisions of libbzip2's code.\n+     * The mainSort function and those used by it look closer to the\n+     * 0.9.5 version but show some variations introduced later.  At\n+     * the same time the logic to randomize the block on bad input has\n+     * been dropped after 0.9.0 and replaced by a fallback sorting\n+     * algorithm.\n+     */\n \n     private static final int SETMASK = (1 << 21);\n     private static final int CLEARMASK = (~SETMASK);\n     private static final int WORK_FACTOR = 30;\n \n     /*\n-     * <p> If you are ever unlucky/improbable enough to get a stack\n+     * LBZ2: If you are ever unlucky/improbable enough to get a stack\n      * overflow whilst sorting, increase the following constant and\n      * try again. In practice I have never seen the stack go above 27\n-     * elems, so the following limit seems very generous.  </p>\n+     * elems, so the following limit seems very generous.\n      */\n     private static final int QSORT_STACK_SIZE = 1000;\n \n-    /**\n-     * Knuth's increments seem to work better than Incerpi-Sedgewick here.\n+    /*\n+     * LBZ2: Knuth's increments seem to work better than Incerpi-Sedgewick here.\n      * Possibly because the number of elems to sort is usually small, typically\n      * &lt;= 20.\n      */\n     BlockSort(final BZip2CompressorOutputStream.Data data) {\n         this.quadrant = data.sfmap;\n     }\n+\n+/*---------------------------------------------*/\n+/*--\n+   LBZ2: The following is an implementation of\n+   an elegant 3-way quicksort for strings,\n+   described in a paper \"Fast Algorithms for\n+   Sorting and Searching Strings\", by Robert\n+   Sedgewick and Jon L. Bentley.\n+--*/\n \n     /**\n      * This is the most hammered method of this class.\n         final int workLimitShadow = this.workLimit;\n         final boolean firstAttemptShadow = this.firstAttempt;\n \n-        // Set up the 2-byte frequency table\n+        // LBZ2: Set up the 2-byte frequency table\n         for (int i = 65537; --i >= 0;) {\n             ftab[i] = 0;\n         }\n         }\n         block[0] = block[lastShadow + 1];\n \n-        // Complete the initial radix sort:\n+        // LBZ2: Complete the initial radix sort:\n \n         int c1 = block[0] & 0xff;\n         for (int i = 0; i <= lastShadow; i++) {\n         fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n \n         /*\n-         * Now ftab contains the first loc of every small bucket. Calculate the\n+         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n          * running order, from smallest to largest big bucket.\n          */\n         for (int i = 256; --i >= 0;) {\n         }\n \n         /*\n-         * The main sorting loop.\n+         * LBZ2: The main sorting loop.\n          */\n         for (int i = 0; i <= 255; i++) {\n             /*\n-             * Process big buckets, starting with the least full.\n+             * LBZ2: Process big buckets, starting with the least full.\n              */\n             final int ss = runningOrder[i];\n \n             // Step 1:\n             /*\n-             * Complete the big bucket [ss] by quicksorting any unsorted small\n+             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n              * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n              * already completed many of the small buckets [ss, j], so we don't\n              * have to sort them at all.\n             }\n \n             // Step 2:\n-            // Now scan this big bucket so as to synthesise the\n+            // LBZ2: Now scan this big bucket so as to synthesise the\n             // sorted order for small buckets [t, ss] for all t != ss.\n \n             for (int j = 0; j <= 255; j++) {\n \n             // Step 3:\n             /*\n-             * The ss big bucket is now done. Record this fact, and update the\n+             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n              * quadrant descriptors. Remember to update quadrants in the\n              * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n              * skips this updating for the last bucket processed, since updating\n         }\n     }\n \n+/*---------------------------------------------*/\n+\n     private void randomiseBlock(final BZip2CompressorOutputStream.Data data,\n                                 final int lastShadow) {\n         final boolean[] inUse = data.inUse;", "timestamp": 1337521547, "metainfo": ""}