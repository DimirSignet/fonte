{"sha": "46628efdacc42d4b6bdc11f69405ab7bbea32c03", "log": "@Override  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public long getSize() {\n         return this.getLength();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public String getName() {\n         return name;\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(1000 * getLastModified());\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public boolean isDirectory() {\n         return false;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n      * @see\n      * org.apache.commons.compress.archivers.ArchiveInputStream#getNextEntry()\n      */\n+    @Override\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextArEntry();\n     }\n      * \n      * @see java.io.InputStream#close()\n      */\n+    @Override\n     public void close() throws IOException {\n         if (!closed) {\n             closed = true;\n      * \n      * @see java.io.InputStream#read(byte[], int, int)\n      */\n+    @Override\n     public int read(byte[] b, final int off, final int len) throws IOException {\n         int toRead = len;\n         if (currentEntry != null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void closeArchiveEntry() throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n         return offset;\n     }\n \n+    @Override\n     public void write(byte[] b, int off, int len) throws IOException {\n         out.write(b, off, len);\n         count(len);\n     /**\n      * Calls finish if necessary, and then closes the OutputStream\n      */\n+    @Override\n     public void close() throws IOException {\n         if(!finished) {\n             finish();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n             throws IOException {\n         if(finished) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void finish() throws IOException {\n         if(haveUnclosedEntry) {\n             throw new IOException(\"This archive contains unclosed entries.\");\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * @return Returns the filesize.\n      * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n      */\n+    @Override\n     public long getSize() {\n         return this.filesize;\n     }\n      * \n      * @return Returns the name.\n      */\n+    @Override\n     public String getName() {\n         return this.name;\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(1000 * getTime());\n     }\n      * \n      * @return TRUE if this entry is a directory.\n      */\n+    @Override\n     public boolean isDirectory() {\n         return (this.mode & S_IFMT) == C_ISDIR;\n     }\n     /* (non-Javadoc)\n      * @see java.lang.Object#hashCode()\n      */\n+    @Override\n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n     /* (non-Javadoc)\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n+    @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n      *             if an I/O error has occurred or if a CPIO file error has\n      *             occurred\n      */\n+    @Override\n     public int available() throws IOException {\n         ensureOpen();\n         if (this.entryEOF) {\n      * @throws IOException\n      *             if an I/O error has occurred\n      */\n+    @Override\n     public void close() throws IOException {\n         if (!this.closed) {\n             in.close();\n      *             if an I/O error has occurred or if a CPIO file error has\n      *             occurred\n      */\n+    @Override\n     public int read(final byte[] b, final int off, final int len)\n             throws IOException {\n         ensureOpen();\n      * @throws IllegalArgumentException\n      *             if n < 0\n      */\n+    @Override\n     public long skip(final long n) throws IOException {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"negative skip length\");\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextCPIOEntry();\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      *             occurred\n      * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n      */\n+    @Override\n     public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n      * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n      * ()\n      */\n+    @Override\n     public void closeArchiveEntry() throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n      *             if an I/O error has occurred or if a CPIO file error has\n      *             occurred\n      */\n+    @Override\n     public void write(final byte[] b, final int off, final int len)\n             throws IOException {\n         ensureOpen();\n      *             if an I/O exception has occurred or if a CPIO file error has\n      *             occurred\n      */\n+    @Override\n     public void finish() throws IOException {\n         ensureOpen();\n         if (finished) {\n      *             if an I/O error has occurred or if a CPIO file error has\n      *             occurred\n      */\n+    @Override\n     public void close() throws IOException {\n         if(!finished) {\n             finish();\n      * \n      * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n      */\n+    @Override\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n             throws IOException {\n         if(finished) {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      * @param it Entry to be checked for equality.\n      * @return True if the entries are equal.\n      */\n+    @Override\n     public boolean equals(Object it) {\n         if (it == null || getClass() != it.getClass()) {\n             return false;\n      *\n      * @return the entry hashcode\n      */\n+    @Override\n     public int hashCode() {\n         return getName().hashCode();\n     }\n      *\n      * @return This entry's name.\n      */\n+    @Override\n     public String getName() {\n         return name.toString();\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public Date getLastModifiedDate() {\n         return getModTime();\n     }\n      *\n      * @return This entry's file size.\n      */\n+    @Override\n     public long getSize() {\n         return size;\n     }\n      *\n      * @return True if this entry is a directory.\n      */\n+    @Override\n     public boolean isDirectory() {\n         if (file != null) {\n             return file.isDirectory();\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n      * Closes this stream. Calls the TarBuffer's close() method.\n      * @throws IOException on error\n      */\n+    @Override\n     public void close() throws IOException {\n         buffer.close();\n     }\n      * @return The number of available bytes for the current entry.\n      * @throws IOException for signature\n      */\n+    @Override\n     public int available() throws IOException {\n         if (entrySize - entryOffset > Integer.MAX_VALUE) {\n             return Integer.MAX_VALUE;\n      * @return the number actually skipped\n      * @throws IOException on error\n      */\n+    @Override\n     public long skip(long numToSkip) throws IOException {\n         // REVIEW\n         // This is horribly inefficient, but it ensures that we\n     /**\n      * Since we do not support marking just yet, we do nothing.\n      */\n+    @Override\n     public synchronized void reset() {\n     }\n \n         }\n     }\n \n+    @Override\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextTarEntry();\n     }\n      * @return The number of bytes read, or -1 at EOF.\n      * @throws IOException on error\n      */\n+    @Override\n     public int read(byte[] buf, int offset, int numToRead) throws IOException {\n         int totalRead = 0;\n \n      *\n      * <p>May return false if the current entry is a sparse file.</p>\n      */\n+    @Override\n     public boolean canReadEntryData(ArchiveEntry ae) {\n         if (ae instanceof TarArchiveEntry) {\n             TarArchiveEntry te = (TarArchiveEntry) ae;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n      * \n      * @throws IOException on error\n      */\n+    @Override\n     public void finish() throws IOException {\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n      * Closes the underlying OutputStream.\n      * @throws IOException on error\n      */\n+    @Override\n     public void close() throws IOException {\n         if(!finished) {\n             finish();\n      * @throws IOException on error\n      * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n      */\n+    @Override\n     public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n      * next entry written.\n      * @throws IOException on error\n      */\n+    @Override\n     public void closeArchiveEntry() throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n      * @param numToWrite The number of bytes to write.\n      * @throws IOException on error\n      */\n+    @Override\n     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n         if ((currBytes + numToWrite) > currSize) {\n             throw new IOException(\"request to write '\" + numToWrite\n         buffer.writeRecord(recordBuf);\n     }\n \n-    // used to be implemented via FilterOutputStream\n+    @Override\n     public void flush() throws IOException {\n         out.flush();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n             throws IOException {\n         if(finished) {\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int read() throws IOException {\n         if (this.in != null) {\n             return read0();\n      * \n      * @see java.io.InputStream#read(byte[], int, int)\n      */\n+    @Override\n     public int read(final byte[] dest, final int offs, final int len)\n         throws IOException {\n         if (offs < 0) {\n         }\n     }\n \n+    @Override\n     public void close() throws IOException {\n         InputStream inShadow = this.in;\n         if (inShadow != null) {\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void write(final int b) throws IOException {\n         if (this.out != null) {\n             write0(b);\n     /**\n      * Overriden to close the stream.\n      */\n+    @Override\n     protected void finalize() throws Throwable {\n         finish();\n         super.finalize();\n         }\n     }\n \n+    @Override\n     public void close() throws IOException {\n         if (out != null) {\n             OutputStream outShadow = this.out;\n         }\n     }\n \n+    @Override\n     public void flush() throws IOException {\n         OutputStream outShadow = this.out;\n         if (outShadow != null) {\n         return this.blockSize100k;\n     }\n \n+    @Override\n     public void write(final byte[] buf, int offs, final int len)\n         throws IOException {\n         if (offs < 0) {\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public int read() throws IOException {\n         int read = in.read();\n         this.count(read < 0 ? -1 : 1);\n      * \n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public int read(byte[] b) throws IOException {\n         int read = in.read(b);\n         this.count(read);\n      * \n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public int read(byte[] b, int from, int length) throws IOException {\n         int read = in.read(b, from, length);\n         this.count(read);\n      * \n      * @since 1.2\n      */\n+    @Override\n     public void close() throws IOException {\n         if (this.in != System.in) {\n             this.in.close();\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void write(int b) throws IOException {\n         out.write(b);\n     }\n      * \n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public void write(byte[] b) throws IOException {\n         out.write(b);\n     }\n      * \n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public void write(byte[] b, int from, int length) throws IOException {\n         out.write(b, from, length);\n     }\n \n+    @Override\n     public void close() throws IOException {\n         out.close();\n     }", "timestamp": 1312648240, "metainfo": ""}