{"sha": "3685eeae9077221b27c617f9e8eb9836cfbb39d1", "log": "one readFully method to rule them all  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.utils.ArchiveUtils;\n import org.apache.commons.compress.utils.CharsetNames;\n+import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n \n     private final int readFully(final byte[] b, final int off, final int len)\n             throws IOException {\n-        if (len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        }\n-        int n = 0;\n-        while (n < len) {\n-            int count = this.in.read(b, off + n, len - n);\n-            count(count);\n-            if (count < 0) {\n-                throw new EOFException();\n-            }\n-            n += count;\n-        }\n-        return n;\n+        int count = IOUtils.readFully(in, b, off, len);\n+        count(count);\n+        if (count < len) {\n+            throw new EOFException();\n+        }\n+        return count;\n     }\n \n     private long readBinaryLong(final int length, final boolean swapHalfWord)\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n import java.util.zip.DataFormatException;\n import java.util.zip.Inflater;\n \n+import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * Filter stream that mimics a physical tape drive capable of compressing\n      */\n     private boolean readFully(byte[] b, int off, int len)\n         throws IOException {\n-        int count = 0;\n-\n-        while (count < len) {\n-            int n = in.read(b, off + count, len - count);\n-\n-            if (n == -1) {\n-                throw new ShortFileException();\n-            }\n-\n-            count += n;\n+        int count = IOUtils.readFully(in, b, off, len);\n+        if (count < len) {\n+            throw new ShortFileException();\n         }\n \n         return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n \n import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n     }\n \n     private void readFully(byte[] b) throws IOException {\n-        int count = 0, x = 0;\n-        while (count != b.length) {\n-            count += x = in.read(b, count, b.length - count);\n-            if (x == -1) {\n-                throw new EOFException();\n-            }\n-            count(x);\n+        int count = IOUtils.readFully(in, b);\n+        count(count);\n+        if (count < b.length) {\n+            throw new EOFException();\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n      *\n      * <p>This method will only skip less than the requested number of\n      * bytes if the end of the input stream has been reached.</p>\n-\n+     *\n      * @param input stream to skip bytes in\n      * @param numToSkip the number of bytes to skip\n      * @return the number of bytes actually skipped\n             numToSkip -= skipped;\n         }\n         return (available - numToSkip);\n+    }\n+\n+    /**\n+     * Reads as much from input as possible to fill the given array.\n+     *\n+     * <p>This method may invoke read repeatedly to fill the array and\n+     * only read less bytes than the length of the array if the end of\n+     * the stream has been reached.</p>\n+     *\n+     * @param input stream to read from\n+     * @param b buffer to fill\n+     * @retun the number of bytes actually read\n+     */\n+    public static int readFully(InputStream input, byte[] b) throws IOException {\n+        return readFully(input, b, 0, b.length);\n+    }\n+\n+    /**\n+     * Reads as much from input as possible to fill the given array\n+     * with the given amount of bytes.\n+     *\n+     * <p>This method may invoke read repeatedly to read the bytes and\n+     * only read less bytes than the requested length if the end of\n+     * the stream has been reached.</p>\n+     *\n+     * @param input stream to read from\n+     * @param b buffer to fill\n+     * @param offset offset into the buffer to start filling at\n+     * @param amount of bytes to read\n+     * @retun the number of bytes actually read\n+     */\n+    public static int readFully(InputStream input, byte[] b, int offset, int len)\n+        throws IOException {\n+        if (len < 0 || offset < 0 || len + offset > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+        int count = 0, x = 0;\n+        while (count != len) {\n+            x = input.read(b, offset + count, len - count);\n+            if (x == -1) {\n+                break;\n+            }\n+            count += x;\n+        }\n+        return count;\n     }\n \n     // toByteArray(InputStream) copied from:", "timestamp": 1380892652, "metainfo": ""}