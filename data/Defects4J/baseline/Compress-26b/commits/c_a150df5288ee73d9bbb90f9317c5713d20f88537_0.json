{"sha": "a150df5288ee73d9bbb90f9317c5713d20f88537", "log": "COMPRESS-147 be extra defensive against overflows - can actually not happen with the current snappy compressors where offset will always be <= 32768  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n         while (readNow > 0) {\n             final int b = readOneByte();\n             int length = 0;\n-            int offset = 0;\n+            long offset = 0;\n \n             switch (b & TAG_MASK) {\n \n      * backreferences that would go past the end of the block (offset > current\n      * decompressed position), which is also nonsensical and thus not allowed.\n      * \n-     * @param offset\n+     * @param off\n      *            The offset from the backward from the end of expanded stream\n      * @param length\n      *            The number of bytes to copy\n      *             buffer\n      * @return True if the decompressed data should be flushed\n      */\n-    private boolean expandCopy(final int offset, int length) throws IOException {\n-        if (offset > blockSize) {\n+    private boolean expandCopy(final long off, int length) throws IOException {\n+        if (off > blockSize) {\n             throw new IOException(\"Offset is larger than block size\");\n         }\n+        int offset = (int) off;\n \n         if (offset == 1) {\n             byte lastChar = decompressBuf[writeIndex - 1];", "timestamp": 1386402387, "metainfo": ""}