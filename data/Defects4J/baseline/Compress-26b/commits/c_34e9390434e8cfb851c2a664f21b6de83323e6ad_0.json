{"sha": "34e9390434e8cfb851c2a664f21b6de83323e6ad", "log": "address issues detected by findbugs  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n     private int mode;\n     private Set<PERMISSION> permissions = Collections.emptySet();\n     private long size;\n-    private Date atime;\n-    private Date mtime;\n+    private long atime;\n+    private long mtime;\n     private int uid;\n     private int gid;\n \n+    /**\n+     * Currently unused\n+     */\n     private DumpArchiveSummary summary = null;\n \n     // this information is available from standard index.\n     private long offset;\n     private int ino;\n     private int nlink;\n-    private Date ctime;\n+    private long ctime;\n     private int generation;\n     private boolean isDeleted;\n \n      * Get file creation time.\n      */\n     public Date getCreationTime() {\n-        return ctime;\n+        return new Date(ctime);\n     }\n \n     /**\n      * Set the file creation time.\n      */\n     public void setCreationTime(Date ctime) {\n-        this.ctime = ctime;\n+        this.ctime = ctime.getTime();\n     }\n \n     /**\n     public boolean equals(Object o) {\n         if (o == this) {\n             return true;\n-        } else if (!o.getClass().equals(getClass())) {\n+        } else if (o == null || !o.getClass().equals(getClass())) {\n             return false;\n         }\n \n             return false;\n         }\n \n-        if ((summary != null) || summary.equals(rhs.summary)) {\n+        if ((summary == null && rhs.summary != null)\n+            || (summary != null && !summary.equals(rhs.summary))) {\n             return false;\n         }\n \n         entry.setLastModifiedDate(new Date(t));\n         t = (1000L * DumpArchiveUtil.convert32(buffer, 64)) +\n             (DumpArchiveUtil.convert32(buffer, 68) / 1000);\n-        entry.ctime = new Date(t);\n+        entry.ctime = t;\n \n         // db: 72-119 - direct blocks\n         // id: 120-131 - indirect blocks\n \n     /** {@inheritDoc} */\n     public Date getLastModifiedDate() {\n-        return mtime;\n+        return new Date(mtime);\n     }\n \n     /**\n      * Set the time the file was last modified.\n      */\n     public void setLastModifiedDate(Date mtime) {\n-        this.mtime = mtime;\n+        this.mtime = mtime.getTime();\n     }\n \n     /**\n      * Returns the time the file was last accessed.\n      */\n     public Date getAccessTime() {\n-        return atime;\n+        return new Date(atime);\n     }\n \n     /**\n      * Set the time the file was last accessed.\n      */\n     public void setAccessTime(Date atime) {\n-        this.atime = atime;\n+        this.atime = atime.getTime();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveException;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n+import java.io.EOFException;\n import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n         }\n \n         // we don't do anything with this yet.\n-        raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount());\n+        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n+            == -1) {\n+            throw new EOFException();\n+        }\n         readIdx = active.getHeaderCount();\n     }\n \n         }\n \n         // we don't do anything with this yet.\n-        raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount());\n+        if (raw.skip(DumpArchiveConstants.TP_SIZE * active.getHeaderCount())\n+            == -1) {\n+            throw new EOFException();\n+        }\n         readIdx = active.getHeaderCount();\n     }\n \n             // block by block. We may want to revisit this if\n             // the unnecessary decompression time adds up.\n             while (readIdx < active.getHeaderCount()) {\n-                if (!active.isSparseRecord(readIdx++)) {\n-                    raw.skip(DumpArchiveConstants.TP_SIZE);\n+                if (!active.isSparseRecord(readIdx++)\n+                    && raw.skip(DumpArchiveConstants.TP_SIZE) == -1) {\n+                    throw new EOFException();\n                 }\n             }\n \n \n             // skip any remaining segments for prior file.\n             while (DumpArchiveConstants.SEGMENT_TYPE.ADDR == active.getHeaderType()) {\n-                raw.skip(DumpArchiveConstants.TP_SIZE * (active.getHeaderCount() -\n-                    active.getHeaderHoles()));\n+                if (raw.skip(DumpArchiveConstants.TP_SIZE\n+                             * (active.getHeaderCount()\n+                                - active.getHeaderHoles())) == -1) {\n+                    throw new EOFException();\n+                }\n \n                 filepos = raw.getBytesRead();\n                 headerBytes = raw.readRecord();\n                 blockBuffer = new byte[datalen];\n             }\n \n-            raw.read(blockBuffer, 0, datalen);\n+            if (raw.read(blockBuffer, 0, datalen) != datalen) {\n+                throw new EOFException();\n+            }\n \n             int reclen = 0;\n \n                 }\n \n                 if (!active.isSparseRecord(readIdx++)) {\n-                    raw.read(readBuf, 0, readBuf.length);\n+                    int r = raw.read(readBuf, 0, readBuf.length);\n+                    if (r != readBuf.length) {\n+                        throw new EOFException();\n+                    }\n                 } else {\n                     Arrays.fill(readBuf, (byte) 0);\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n  * For the corresponding C structure see the header of {@link DumpArchiveEntry}.\n  */\n public class DumpArchiveSummary {\n-    private Date dumpDate;\n-    private Date previousDumpDate;\n+    private long dumpDate;\n+    private long previousDumpDate;\n     private int volume;\n     private String label;\n     private int level;\n     private int ntrec;\n \n     DumpArchiveSummary(byte[] buffer) {\n-        dumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 4));\n-        previousDumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 8));\n+        dumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\n+        previousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\n         volume = DumpArchiveUtil.convert32(buffer, 12);\n         label = new String(buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\n         level = DumpArchiveUtil.convert32(buffer, 692);\n      * @return the date of this dump.\n      */\n     public Date getDumpDate() {\n-        return dumpDate;\n+        return new Date(dumpDate);\n     }\n \n     /**\n      * Set dump date.\n      */\n     public void setDumpDate(Date dumpDate) {\n-        this.dumpDate = dumpDate;\n+        this.dumpDate = dumpDate.getTime();\n     }\n \n     /**\n      * @return dumpdate may be null\n      */\n     public Date getPreviousDumpDate() {\n-        return previousDumpDate;\n+        return new Date(previousDumpDate);\n     }\n \n     /**\n      * Set previous dump date.\n      */\n     public void setPreviousDumpDate(Date previousDumpDate) {\n-        this.previousDumpDate = previousDumpDate;\n+        this.previousDumpDate = previousDumpDate.getTime();\n     }\n \n     /**\n             hash = label.hashCode();\n         }\n \n-        if (dumpDate != null) {\n-            hash = (31 * dumpDate.hashCode()) + 17;\n-        }\n+        hash += 31 * dumpDate;\n \n         if (hostname != null) {\n             hash = (31 * hostname.hashCode()) + 17;\n             return true;\n         }\n \n-        if (!o.getClass().equals(getClass())) {\n+        if (o == null || !o.getClass().equals(getClass())) {\n             return false;\n         }\n \n         DumpArchiveSummary rhs = (DumpArchiveSummary) o;\n \n-        if ((dumpDate == null) || !dumpDate.equals(rhs.dumpDate)) {\n+        if (dumpDate != rhs.dumpDate) {\n             return false;\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n     }\n \n     /**\n-     * @see java.io.InputStream#read(byte[], int, int)\n+     * {@inheritDoc}\n+     *\n+     * <p>reads the full given length unless EOF is reached.</p> \n+     *\n+     * @param len length to read, must be a multiple of the stream's\n+     * record size\n      */\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n \n     /**\n      * Skip bytes. Same as read but without the arraycopy.\n-     * @see java.io.InputStream#read(byte[], int, int)\n+     *\n+     * <p>skips the full given length unless EOF is reached.</p> \n+     *\n+     * @param len length to read, must be a multiple of the stream's\n+     * record size\n      */\n     @Override\n     public long skip(long len) throws IOException {\n             success = readFully(blockBuffer, 0, blockSize);\n             bytesRead += blockSize;\n         } else {\n-            in.read(blockBuffer, 0, 4);\n+            if (!readFully(blockBuffer, 0, 4)) {\n+                return false;\n+            }\n             bytesRead += 4;\n \n             int h = DumpArchiveUtil.convert32(blockBuffer, 0);", "timestamp": 1313467447, "metainfo": ""}