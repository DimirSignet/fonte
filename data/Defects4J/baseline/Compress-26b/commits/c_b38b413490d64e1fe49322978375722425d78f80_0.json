{"sha": "b38b413490d64e1fe49322978375722425d78f80", "log": "merge  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n import javax.crypto.spec.SecretKeySpec;\n \n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n+import org.tukaani.xz.LZMAInputStream;\n import org.tukaani.xz.LZMA2InputStream;\n \n class Coders {\n     \n     static CoderId[] coderTable = new CoderId[] {\n         new CoderId(new byte[] { (byte)0x00 }, new CopyDecoder()),\n+        new CoderId(new byte[] { (byte)0x03, (byte)0x01, (byte)0x01 }, new LZMADecoder()),\n         new CoderId(new byte[] { (byte)0x21 }, new LZMA2Decoder()),\n         // FIXME: gives corrupt output\n         //new CoderId(new byte[] { (byte)0x04, (byte)0x01, (byte)0x08 }, new DeflateDecoder()),\n                 dictionarySize = (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n             }\n             return new LZMA2InputStream(in, dictionarySize);\n+        }\n+    }\n+    \n+    static class LZMADecoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException {\n+            byte propsByte = coder.properties[0];\n+            long dictSize = coder.properties[1];\n+            for (int i = 1; i < 4; i++) {\n+                dictSize |= (coder.properties[i + 1] << (8 * i));\n+            }\n+            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n+                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n+            }\n+            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n         }\n     }\n     \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n+import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n import org.apache.commons.compress.compressors.xz.XZUtils;\n      * @since 1.4\n      */\n     public static final String XZ = \"xz\";\n+\n+    /**\n+     * Constant used to identify the LZMA compression method.\n+     * @since 1.6\n+     */\n+    public static final String LZMA = \"lzma\";\n \n     private boolean decompressConcatenated = false;\n \n     /**\n      * Create a compressor input stream from a compressor name and an input stream.\n      * \n-     * @param name of the compressor, i.e. \"gz\", \"bzip2\", \"xz\", or \"pack200\"\n+     * @param name of the compressor, i.e. \"gz\", \"bzip2\", \"xz\", \"lzma\", or \"pack200\"\n      * @param in the input stream\n      * @return compressor input stream\n      * @throws CompressorException if the compressor name is not known\n \n             if (XZ.equalsIgnoreCase(name)) {\n                 return new XZCompressorInputStream(in);\n+            }\n+\n+            if (LZMA.equalsIgnoreCase(name)) {\n+                return new LZMACompressorInputStream(in);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lzma;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.tukaani.xz.LZMAInputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * LZMA decompressor.\n+ * @since 1.6\n+ */\n+public class LZMACompressorInputStream extends CompressorInputStream {\n+    private final InputStream in;\n+\n+    /**\n+     * Creates a new input stream that decompresses LZMA-compressed data\n+     * from the specified input stream.\n+     *\n+     * @param       inputStream where to read the compressed data\n+     *\n+     * @throws      IOException if the input is not in the .lzma format,\n+     *                          the input is corrupt or truncated, the .lzma\n+     *                          headers specify sizes that are not supported\n+     *                          by this implementation, or the underlying\n+     *                          <code>inputStream</code> throws an exception\n+     */\n+    public LZMACompressorInputStream(InputStream inputStream)\n+            throws IOException {\n+        in = new LZMAInputStream(inputStream);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        int ret = in.read();\n+        count(ret == -1 ? -1 : 1);\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        int ret = in.read(buf, off, len);\n+        count(ret);\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public long skip(long n) throws IOException {\n+        return in.skip(n);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() throws IOException {\n+        return in.available();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n import org.apache.commons.compress.AbstractTestCase;\n \n public class SevenZFileTest extends AbstractTestCase {\n+    private static String TEST2_CONTENT = \"<?xml version = '1.0'?>\\r\\n<!DOCTYPE\"\n+        + \" connections>\\r\\n<meinxml>\\r\\n\\t<leer />\\r\\n</meinxml>\\n\";\n+\n     public void testAllEmptyFilesArchive() throws Exception {\n         SevenZFile archive = new SevenZFile(getFile(\"7z-empty-mhc-off.7z\"));\n         try {\n \n     public void testHelloWorldHeaderCompressionOffLZMA2() throws Exception {\n         checkHelloWorld(\"7z-hello-mhc-off-lzma2.7z\");\n+    }\n+\n+    public void test7zUnarchive() throws Exception {\n+        SevenZFile sevenZFile = new SevenZFile(getFile(\"bla.7z\"));\n+        try {\n+            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n+            assertEquals(\"test1.xml\", entry.getName());\n+            entry = sevenZFile.getNextEntry();\n+            assertEquals(\"test2.xml\", entry.getName());\n+            byte[] contents = new byte[(int)entry.getSize()];\n+            int off = 0;\n+            while ((off < contents.length)) {\n+                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n+                assert(bytesRead >= 0);\n+                off += bytesRead;\n+            }\n+            assertEquals(TEST2_CONTENT, new String(contents, \"UTF-8\"));\n+            assertNull(sevenZFile.getNextEntry());\n+        } finally {\n+            sevenZFile.close();\n+        }\n     }\n \n     private void checkHelloWorld(final String filename) throws Exception {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class LZMATestCase extends AbstractTestCase {\n+\n+    public void testLZMAUnarchive() throws Exception {\n+        final File input = getFile(\"bla.tar.lzma\");\n+        final File output = new File(dir, \"bla.tar\");\n+        final InputStream is = new FileInputStream(input);\n+        try {\n+            final CompressorInputStream in = new LZMACompressorInputStream(is);\n+            FileOutputStream out = null;\n+            try {\n+                out = new FileOutputStream(output);\n+                IOUtils.copy(in, out);\n+            } finally {\n+                if (out != null) {\n+                    out.close();\n+                }\n+                in.close();\n+            }\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}", "timestamp": 1373035354, "metainfo": ""}