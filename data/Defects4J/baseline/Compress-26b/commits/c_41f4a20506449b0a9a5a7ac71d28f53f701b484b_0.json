{"sha": "41f4a20506449b0a9a5a7ac71d28f53f701b484b", "log": "clean up protected/public API - SANDBOX-294 - a combination of patches by Sebb, Christian Grobmeier and discussion on the dev list http://mail-archives.apache.org/mod_mbox/commons-dev/200903.mbox/%3Cy1ufxhbifdo.fsf@v30161.1blu.de%3E  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n  * pathname c_chksum 8 0 for \"new\" portable format; for CRC format the sum of\n  * all the bytes in the file\n  * \n- * based on code from the jRPM project (jrpm.sourceforge.net) \n+ * This class uses mutable fields and is not considered to be threadsafe.\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net)\n  */\n public class CpioArchiveEntry implements CpioConstants, ArchiveEntry {\n-\t\n+\n     private long chksum = 0;\n \n     private short fileFormat = -1;\n     private long rmin = 0;\n \n     private long uid = 0;\n-\n-    /**\n-     * Ceates a CPIOArchiveEntry without a cpio format.\n-     */\n-    public CpioArchiveEntry() {\n-        // do nothing\n-    }\n \n     /**\n      * Ceates a CPIOArchiveEntry with a specified format.\n     }\n \n     /**\n-     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry will\n-     * be the new format.\n+     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry\n+     * will be the new format.\n      * \n      * @param name\n      *            The name of this entry.\n     }\n \n     /**\n-     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry will\n-     * be the new format.\n+     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry\n+     * will be the new format.\n      * \n      * @param name\n      *            The name of this entry.\n      * @param size\n-     * \t\t\t  The size of this entry\n+     *            The size of this entry\n      */\n     public CpioArchiveEntry(final String name, final long size) {\n         this(FORMAT_NEW);\n         this.name = name;\n         this.setSize(size);\n     }\n-    \n+\n     /**\n      * Check if the method is allowed for the defined format.\n      */\n      * \n      * @return Returns the device id.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n      */\n     public long getDevice() {\n         checkOldFormat();\n      * \n      * @return Returns the major device id.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n      */\n     public long getDeviceMaj() {\n         checkNewFormat();\n      * \n      * @return Returns the filesize.\n      */\n-    /* (non-Javadoc)\n+    /*\n+     * (non-Javadoc)\n+     * \n      * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n      */\n     public long getSize() {\n      * \n      * @return Returns the remote device id.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n      */\n     public long getRemoteDevice() {\n         checkOldFormat();\n      * \n      * @return Returns the remote major device id.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n      */\n     public long getRemoteDeviceMaj() {\n         checkNewFormat();\n      * \n      * @return Returns the remote minor device id.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n      */\n     public long getRemoteDeviceMin() {\n         checkNewFormat();\n      * @param device\n      *            The device id to set.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n      */\n     public void setDevice(final long device) {\n         checkOldFormat();\n      * @param format\n      *            The format to set.\n      */\n-    void setFormat(final short format) {\n+    final void setFormat(final short format) {\n         switch (format) {\n         case FORMAT_NEW:\n             this.fileFormat = FORMAT_NEW;\n             break;\n         default:\n             // FIXME: testCpioUnarchive fails if I change the line to\n-            //        actually throw the excpetion\n-            new IllegalArgumentException(\"Unknown mode (full mode: \"\n-                                               + mode + \", masked mode: \"\n-                                               + (mode & S_IFMT));\n+            // actually throw the excpetion\n+            new IllegalArgumentException(\"Unknown mode (full mode: \" + mode\n+                    + \", masked mode: \" + (mode & S_IFMT));\n         }\n \n         this.mode = mode;\n      * @param device\n      *            The remote device id to set.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n      */\n     public void setRemoteDevice(final long device) {\n         checkOldFormat();\n      * @param rmaj\n      *            The remote major device id to set.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n      */\n     public void setRemoteDeviceMaj(final long rmaj) {\n         checkNewFormat();\n      * @param rmin\n      *            The remote minor device id to set.\n      * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n      */\n     public void setRemoteDeviceMin(final long rmin) {\n         checkNewFormat();\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n /**\n- * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of cpio are\n- * supported (old ascii, old binary, new portable format and the new portable\n- * format with crc).\n+ * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n+ * cpio are supported (old ascii, old binary, new portable format and the new\n+ * portable format with crc).\n  * <p/>\n  * <p/>\n  * The stream can be read by extracting a cpio entry (containing all\n  * <p/>\n  * Note: This implementation should be compatible to cpio 2.5\n  * \n- * based on code from the jRPM project (jrpm.sourceforge.net) \n+ * This class uses mutable fields and is not considered to be threadsafe.\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net)\n  */\n \n-public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants {\n+public class CpioArchiveInputStream extends ArchiveInputStream implements\n+        CpioConstants {\n \n     private boolean closed = false;\n \n \n     private boolean entryEOF = false;\n \n-    private byte[] singleByteBuf = new byte[1];\n-\n-    private byte tmpbuf[] = new byte[4096];\n+    private final byte[] singleByteBuf = new byte[1];\n+\n+    private final byte tmpbuf[] = new byte[4096];\n \n     private long crc = 0;\n \n \n     /**\n      * Construct the cpio input stream\n-     *\n-     * @param in The cpio stream\n+     * \n+     * @param in\n+     *            The cpio stream\n      */\n     public CpioArchiveInputStream(final InputStream in) {\n         this.in = in;\n      * <p/>\n      * Programs should not count on this method to return the actual number of\n      * bytes that could be read without blocking.\n-     *\n+     * \n      * @return 1 before EOF and 0 after EOF has reached for current entry.\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public int available() throws IOException {\n         ensureOpen();\n     }\n \n     /**\n-     * Converts a byte array to a long. Halfwords can be swaped with setting\n-     * swapHalfWord=true.\n-     *\n-     * @param number       An array of bytes containing a number\n-     * @param swapHalfWord Swap halfwords ([0][1][2][3]->[1][0][3][2])\n-     * @return The long value\n-     */\n-    private long byteArray2long(final byte[] number, final boolean swapHalfWord) {\n-        long ret = 0;\n-        int pos = 0;\n-        byte tmp_number[] = new byte[number.length];\n-        System.arraycopy(number, 0, tmp_number, 0, number.length);\n-\n-        if (tmp_number.length % 2 != 0) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        if (!swapHalfWord) {\n-            byte tmp = 0;\n-            for (pos = 0; pos < tmp_number.length; pos++) {\n-                tmp = tmp_number[pos];\n-                tmp_number[pos++] = tmp_number[pos];\n-                tmp_number[pos] = tmp;\n-            }\n-        }\n-\n-        ret = tmp_number[0] & 0xFF;\n-        for (pos = 1; pos < tmp_number.length; pos++) {\n-            ret <<= 8;\n-            ret |= tmp_number[pos] & 0xFF;\n-        }\n-        return ret;\n-    }\n-\n-    /**\n      * Closes the CPIO input stream.\n-     *\n-     * @throws IOException if an I/O error has occurred\n+     * \n+     * @throws IOException\n+     *             if an I/O error has occurred\n      */\n     public void close() throws IOException {\n         if (!this.closed) {\n     /**\n      * Closes the current CPIO entry and positions the stream for reading the\n      * next entry.\n-     *\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * \n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public void closeEntry() throws IOException {\n         ensureOpen();\n \n     /**\n      * Check to make sure that this stream has not been closed\n-     *\n-     * @throws IOException if the stream is already closed\n+     * \n+     * @throws IOException\n+     *             if the stream is already closed\n      */\n     private void ensureOpen() throws IOException {\n         if (this.closed) {\n     /**\n      * Reads the next CPIO file entry and positions stream at the beginning of\n      * the entry data.\n-     *\n+     * \n      * @return the CPIOArchiveEntry just read\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n         ensureOpen();\n         }\n         byte magic[] = new byte[2];\n         readFully(magic, 0, magic.length);\n-        if (byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\n+        if (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(false);\n-        } else if (byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\n+        } else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(true);\n         } else {\n             byte more_magic[] = new byte[4];\n             byte tmp[] = new byte[6];\n             System.arraycopy(magic, 0, tmp, 0, magic.length);\n             System.arraycopy(more_magic, 0, tmp, magic.length,\n-                             more_magic.length);\n+                    more_magic.length);\n             String magicString = new String(tmp);\n             if (magicString.equals(MAGIC_NEW)) {\n                 this.entry = readNewEntry(false);\n     /**\n      * Reads a byte of data. This method will block until enough input is\n      * available.\n-     *\n+     * \n      * @return the byte read, or -1 if end of input is reached\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public int read() throws IOException {\n         return read(this.singleByteBuf, 0, 1) == -1 ? -1\n-            : this.singleByteBuf[0] & 0xff;\n+                : this.singleByteBuf[0] & 0xff;\n     }\n \n     /**\n      * Reads from the current CPIO entry into an array of bytes. Blocks until\n      * some input is available.\n-     *\n-     * @param b   the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param len the maximum number of bytes read\n+     * \n+     * @param b\n+     *            the buffer into which the data is read\n+     * @param off\n+     *            the start offset of the data\n+     * @param len\n+     *            the maximum number of bytes read\n      * @return the actual number of bytes read, or -1 if the end of the entry is\n      *         reached\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public int read(final byte[] b, final int off, final int len)\n-        throws IOException {\n+            throws IOException {\n         ensureOpen();\n         if (off < 0 || len < 0 || off > b.length - len) {\n             throw new IndexOutOfBoundsException();\n             return -1;\n         }\n         int tmplength = (int) Math.min(len, this.entry.getSize()\n-                                       - this.entryBytesRead);\n+                - this.entryBytesRead);\n         if (tmplength < 0) {\n             return -1;\n         }\n     }\n \n     private final int readFully(final byte[] b, final int off, final int len)\n-        throws IOException {\n+            throws IOException {\n         if (len < 0) {\n             throw new IndexOutOfBoundsException();\n         }\n     }\n \n     private long readBinaryLong(final int length, final boolean swapHalfWord)\n-        throws IOException {\n+            throws IOException {\n         byte tmp[] = new byte[length];\n         readFully(tmp, 0, tmp.length);\n-        return byteArray2long(tmp, swapHalfWord);\n+        return CpioUtil.byteArray2long(tmp, swapHalfWord);\n     }\n \n     private long readAsciiLong(final int length, final int radix)\n-        throws IOException {\n+            throws IOException {\n         byte tmpBuffer[] = new byte[length];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n         return Long.parseLong(new String(tmpBuffer), radix);\n     }\n \n-    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n+    private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n+            throws IOException {\n         CpioArchiveEntry ret;\n         if (hasCrc) {\n             ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n     }\n \n     private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n-        throws IOException {\n+            throws IOException {\n         CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n \n         ret.setDevice(readBinaryLong(2, swapHalfWord));\n \n     /**\n      * Skips specified number of bytes in the current CPIO entry.\n-     *\n-     * @param n the number of bytes to skip\n+     * \n+     * @param n\n+     *            the number of bytes to skip\n      * @return the actual number of bytes skipped\n-     * @throws IOException              if an I/O error has occurred\n-     * @throws IllegalArgumentException if n < 0\n+     * @throws IOException\n+     *             if an I/O error has occurred\n+     * @throws IllegalArgumentException\n+     *             if n < 0\n      */\n     public long skip(final long n) throws IOException {\n         if (n < 0) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n /**\n- * CPIOArchiveOutputStream is a stream for writting cpio streams. All formats of cpio\n- * are supported (old ascii, old binary, new portable format and the new\n+ * CPIOArchiveOutputStream is a stream for writting cpio streams. All formats of\n+ * cpio are supported (old ascii, old binary, new portable format and the new\n  * portable format with crc).\n  * <p/>\n  * <p/>\n- * An entry can be written by creating an instance of CPIOArchiveEntry and fill it with\n- * the necessary values and put it into the cpio stream. Afterwards write the\n- * contents of the file into the cpio stream. Either close the stream by calling\n- * finish() or put a next entry into the cpio stream.\n+ * An entry can be written by creating an instance of CPIOArchiveEntry and fill\n+ * it with the necessary values and put it into the cpio stream. Afterwards\n+ * write the contents of the file into the cpio stream. Either close the stream\n+ * by calling finish() or put a next entry into the cpio stream.\n  * <p/>\n  * <code><pre>\n  * CPIOArchiveOutputStream cpioOut = new CPIOArchiveOutputStream(new BufferedOutputStream(\n  * </pre></code>\n  * <p/>\n  * Note: This implementation should be compatible to cpio 2.5\n- *\n- * based on code from the jRPM project (jrpm.sourceforge.net) \n+ * \n+ * This class uses mutable fields and is not considered threadsafe.\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net)\n  */\n-public class CpioArchiveOutputStream extends ArchiveOutputStream implements CpioConstants {\n+public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n+        CpioConstants {\n \n     private CpioArchiveEntry cpioEntry;\n \n \n     private short entryFormat = FORMAT_NEW;\n \n-    private HashMap names = new HashMap();\n+    private final HashMap names = new HashMap();\n \n     private long crc = 0;\n \n     private final OutputStream out;\n \n     /**\n+     * Construct the cpio output stream with a specified format\n+     * \n+     * @param out\n+     *            The cpio stream\n+     * @param format\n+     *            The format of the stream\n+     */\n+    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n+        this.out = new FilterOutputStream(out);\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Construct the cpio output stream. The format for this CPIO stream is the\n+     * \"new\" format\n+     * \n+     * @param out\n+     *            The cpio stream\n+     */\n+    public CpioArchiveOutputStream(final OutputStream out) {\n+        this(out, FORMAT_NEW);\n+    }\n+\n+    /**\n      * Check to make sure that this stream has not been closed\n-     *\n-     * @throws IOException if the stream is already closed\n+     * \n+     * @throws IOException\n+     *             if the stream is already closed\n      */\n     private void ensureOpen() throws IOException {\n         if (this.closed) {\n     }\n \n     /**\n-     * Construct the cpio output stream with a specified format\n-     *\n-     * @param out    The cpio stream\n-     * @param format The format of the stream\n-     */\n-    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n-        this.out = new FilterOutputStream(out);\n-        setFormat(format);\n-    }\n-\n-    /**\n-     * Construct the cpio output stream. The format for this CPIO stream is the\n-     * \"new\" format\n-     *\n-     * @param out The cpio stream\n-     */\n-    public CpioArchiveOutputStream(final OutputStream out) {\n-        this(out, FORMAT_NEW);\n-    }\n-\n-    /**\n      * Set a default header format. This will be used if no format is defined in\n      * the cpioEntry given to putNextEntry().\n-     *\n-     * @param format A CPIO format\n-     */\n-    public void setFormat(final short format) {\n+     * \n+     * @param format\n+     *            A CPIO format\n+     */\n+    private void setFormat(final short format) {\n         switch (format) {\n         case FORMAT_NEW:\n         case FORMAT_NEW_CRC:\n      * current time will be used if the entry has no set modification time and\n      * the default header format will be used if no other format is specified in\n      * the entry.\n-     *\n-     * @param e the CPIO cpioEntry to be written\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n-     */\n-    public synchronized void putNextEntry(final CpioArchiveEntry e) throws IOException {\n+     * \n+     * @param e\n+     *            the CPIO cpioEntry to be written\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n+     */\n+    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n         ensureOpen();\n         if (this.cpioEntry != null) {\n             closeEntry(); // close previous entry\n         if (e.getTime() == -1) {\n             e.setTime(System.currentTimeMillis());\n         }\n+\n+        // TODO what happens if an entry has an other format than the\n+        // outputstream?\n         if (e.getFormat() == -1) {\n             e.setFormat(this.entryFormat);\n         }\n         pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n     }\n \n-    private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n+    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n+            throws IOException {\n         writeAsciiLong(entry.getDevice(), 6, 8);\n         writeAsciiLong(entry.getInode(), 6, 8);\n         writeAsciiLong(entry.getMode(), 6, 8);\n     }\n \n     private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n-                                     final boolean swapHalfWord) throws IOException {\n+            final boolean swapHalfWord) throws IOException {\n         writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n         writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n         writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n     /**\n      * Closes the current CPIO entry and positions the stream for writing the\n      * next entry.\n-     *\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n-     */\n-    public synchronized void closeEntry() throws IOException {\n+     * \n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n+     */\n+    public void closeEntry() throws IOException {\n         ensureOpen();\n \n         if (this.cpioEntry.getSize() != this.written) {\n             throw new IOException(\"invalid entry size (expected \"\n-                                  + this.cpioEntry.getSize() + \" but got \" + this.written\n-                                  + \" bytes)\");\n+                    + this.cpioEntry.getSize() + \" but got \" + this.written\n+                    + \" bytes)\");\n         }\n         if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n             pad(this.cpioEntry.getSize(), 4);\n     /**\n      * Writes an array of bytes to the current CPIO entry data. This method will\n      * block until all the bytes are written.\n-     *\n-     * @param b   the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * \n+     * @param b\n+     *            the data to be written\n+     * @param off\n+     *            the start offset in the data\n+     * @param len\n+     *            the number of bytes that are written\n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public synchronized void write(final byte[] b, final int off, final int len)\n-        throws IOException {\n+            throws IOException {\n         ensureOpen();\n         if (off < 0 || len < 0 || off > b.length - len) {\n             throw new IndexOutOfBoundsException();\n      * Finishes writing the contents of the CPIO output stream without closing\n      * the underlying stream. Use this method when applying multiple filters in\n      * succession to the same output stream.\n-     *\n-     * @throws IOException if an I/O exception has occurred or if a CPIO file error\n-     *                     has occurred\n-     */\n-    public synchronized void finish() throws IOException {\n+     * \n+     * @throws IOException\n+     *             if an I/O exception has occurred or if a CPIO file error has\n+     *             occurred\n+     */\n+    public void finish() throws IOException {\n         ensureOpen();\n-        // TODO: synchronize and finish\n+\n         if (this.finished) {\n             return;\n         }\n \n     /**\n      * Closes the CPIO output stream as well as the stream being filtered.\n-     *\n-     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n-     *                     occurred\n+     * \n+     * @throws IOException\n+     *             if an I/O error has occurred or if a CPIO file error has\n+     *             occurred\n      */\n     public void close() throws IOException {\n         if (!this.closed) {\n     }\n \n     private void writeBinaryLong(final long number, final int length,\n-                                 final boolean swapHalfWord) throws IOException {\n-        byte tmp[] = long2byteArray(number, length, swapHalfWord);\n+            final boolean swapHalfWord) throws IOException {\n+        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n         out.write(tmp);\n     }\n \n     private void writeAsciiLong(final long number, final int length,\n-                                final int radix) throws IOException {\n+            final int radix) throws IOException {\n         StringBuffer tmp = new StringBuffer();\n         String tmpStr;\n         if (radix == 16) {\n         out.write('\\0');\n     }\n \n-    /**\n-     * Converts a byte array to a long. Halfwords can be swaped with setting\n-     * swapHalfWord=true.\n-     *\n-     * @param number       An array of bytes containing a number\n-     * @param length       The length of the returned array\n-     * @param swapHalfWord Swap halfwords ([0][1][2][3]->[1][0][3][2])\n-     * @return The long value\n-     */\n-    private static byte[] long2byteArray(final long number, final int length,\n-                                         final boolean swapHalfWord) {\n-        byte[] ret = new byte[length];\n-        int pos = 0;\n-        long tmp_number = 0;\n-\n-        if (length % 2 != 0 || length < 2) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        tmp_number = number;\n-        for (pos = length - 1; pos >= 0; pos--) {\n-            ret[pos] = (byte) (tmp_number & 0xFF);\n-            tmp_number >>= 8;\n-        }\n-\n-        if (!swapHalfWord) {\n-            byte tmp = 0;\n-            for (pos = 0; pos < length; pos++) {\n-                tmp = ret[pos];\n-                ret[pos++] = ret[pos];\n-                ret[pos] = tmp;\n-            }\n-        }\n-\n-        return ret;\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry()\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see\n+     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n+     * ()\n      */\n     public void closeArchiveEntry() throws IOException {\n         this.closeEntry();\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry(org.apache.commons.compress.archivers.ArchiveEntry)\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see\n+     * org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry\n+     * (org.apache.commons.compress.archivers.ArchiveEntry)\n      */\n     public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        this.putNextEntry((CpioArchiveEntry)entry);\n-    }\n-\n-    /* (non-Javadoc)\n+        this.putNextEntry((CpioArchiveEntry) entry);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n      * @see java.io.OutputStream#write(int)\n      */\n     public void write(int b) throws IOException {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n+package org.apache.commons.compress.archivers.cpio;\n+\n+class CpioUtil {\n+    /**\n+     * Converts a byte array to a long. Halfwords can be swaped with setting\n+     * swapHalfWord=true.\n+     * \n+     * @param number\n+     *            An array of bytes containing a number\n+     * @param swapHalfWord\n+     *            Swap halfwords ([0][1][2][3]->[1][0][3][2])\n+     * @return The long value\n+     */\n+    static long byteArray2long(final byte[] number, final boolean swapHalfWord) {\n+        long ret = 0;\n+        int pos = 0;\n+        byte tmp_number[] = new byte[number.length];\n+        System.arraycopy(number, 0, tmp_number, 0, number.length);\n+\n+        if (tmp_number.length % 2 != 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        if (!swapHalfWord) {\n+            byte tmp = 0;\n+            for (pos = 0; pos < tmp_number.length; pos++) {\n+                tmp = tmp_number[pos];\n+                tmp_number[pos++] = tmp_number[pos];\n+                tmp_number[pos] = tmp;\n+            }\n+        }\n+\n+        ret = tmp_number[0] & 0xFF;\n+        for (pos = 1; pos < tmp_number.length; pos++) {\n+            ret <<= 8;\n+            ret |= tmp_number[pos] & 0xFF;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Converts a byte array to a long. Halfwords can be swaped with setting\n+     * swapHalfWord=true.\n+     * \n+     * @param number\n+     *            An array of bytes containing a number\n+     * @param length\n+     *            The length of the returned array\n+     * @param swapHalfWord\n+     *            Swap halfwords ([0][1][2][3]->[1][0][3][2])\n+     * @return The long value\n+     */\n+    static byte[] long2byteArray(final long number, final int length,\n+            final boolean swapHalfWord) {\n+        byte[] ret = new byte[length];\n+        int pos = 0;\n+        long tmp_number = 0;\n+\n+        if (length % 2 != 0 || length < 2) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        tmp_number = number;\n+        for (pos = length - 1; pos >= 0; pos--) {\n+            ret[pos] = (byte) (tmp_number & 0xFF);\n+            tmp_number >>= 8;\n+        }\n+\n+        if (!swapHalfWord) {\n+            byte tmp = 0;\n+            for (pos = 0; pos < length; pos++) {\n+                tmp = ret[pos];\n+                ret[pos++] = ret[pos];\n+                ret[pos] = tmp;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n     private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n     private static final int BYTE_MASK = 0xFF;\n \n-    // CheckStyle:VisibilityModifier OFF - bc\n-    protected boolean debug;\n-    protected boolean hasHitEOF;\n-    protected long entrySize;\n-    protected long entryOffset;\n-    protected byte[] readBuf;\n-    protected TarBuffer buffer;\n-    protected TarArchiveEntry currEntry;\n+    private boolean debug;\n+    private boolean hasHitEOF;\n+    private long entrySize;\n+    private long entryOffset;\n+    private byte[] readBuf;\n+    protected final TarBuffer buffer;\n+    private TarArchiveEntry currEntry;\n \n     /**\n      * This contents of this array is not used at all in this class,\n-     * it is only here to avoid repreated object creation during calls\n+     * it is only here to avoid repeated object creation during calls\n      * to the no-arg read method.\n      */\n-    protected byte[] oneBuf;\n-\n-    // CheckStyle:VisibilityModifier ON\n-\n-    private final InputStream in;\n+    private final byte[] oneBuf;\n \n     /**\n      * Constructor for TarInputStream.\n      * @param recordSize the record size to use\n      */\n     public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n-        this.in = is;\n-\n         this.buffer = new TarBuffer(is, blockSize, recordSize);\n         this.readBuf = null;\n         this.oneBuf = new byte[1];\n         }\n     }\n \n+    protected final TarArchiveEntry getCurrentEntry() {\n+        return currEntry;\n+    }\n+\n+    protected final void setCurrentEntry(TarArchiveEntry e) {\n+        currEntry = e;\n+    }\n+\n+    protected final boolean isAtEOF() {\n+        return hasHitEOF;\n+    }\n+\n+    protected final void setAtEOF(boolean b) {\n+        hasHitEOF = b;\n+    }\n+\n+\n     // used to be implemented via FilterInputStream\n     public int read(byte[] b) throws IOException {\n         return read(b, 0, b.length);\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     /** GNU tar extensions are used to store long file names in the archive. */\n     public static final int LONGFILE_GNU = 2;\n \n-    // CheckStyle:VisibilityModifier OFF - bc\n-    protected boolean   debug;\n-    protected long      currSize;\n-    protected String    currName;\n-    protected long      currBytes;\n-    protected byte[]    oneBuf;\n-    protected byte[]    recordBuf;\n-    protected int       assemLen;\n-    protected byte[]    assemBuf;\n-    protected TarBuffer buffer;\n-    protected int       longFileMode = LONGFILE_ERROR;\n-    // CheckStyle:VisibilityModifier ON\n+    private boolean   debug;// NOT READ\n+    private long      currSize;\n+    private String    currName;\n+    private long      currBytes;\n+    private final byte[]    oneBuf;\n+    private final byte[]    recordBuf;\n+    private int       assemLen;\n+    private final byte[]    assemBuf;\n+    protected final TarBuffer buffer;\n+    private int       longFileMode = LONGFILE_ERROR;\n \n     private boolean closed = false;\n \n         return \"tar\";\n     }\n \n-    public byte[] getHeader() {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n     public String getName() {\n         return \"tar\";\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private ZipEncoding zipEncoding =\n         ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING);\n \n-   // CheckStyle:VisibilityModifier OFF - bc\n-\n     /**\n      * This Deflater object is used for output.\n      *\n-     * <p>This attribute is only protected to provide a level of API\n-     * backwards compatibility.  This class used to extend {@link\n-     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n-     * Revision 1.13.</p>\n-     */\n-    protected Deflater def = new Deflater(level, true);\n+     */\n+    protected final Deflater def = new Deflater(level, true);\n \n     /**\n      * This buffer servers as a Deflater.\n      *\n-     * <p>This attribute is only protected to provide a level of API\n-     * backwards compatibility.  This class used to extend {@link\n-     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n-     * Revision 1.13.</p>\n-     */\n-    protected byte[] buf = new byte[BUFFER_SIZE];\n-\n-    // CheckStyle:VisibilityModifier ON\n+     */\n+    private final byte[] buf = new byte[BUFFER_SIZE];\n \n     /**\n      * Optional random access output.\n                 deflate();\n             }\n \n-            entry.setSize(adjustToLong(def.getTotalIn()));\n-            entry.setCompressedSize(adjustToLong(def.getTotalOut()));\n+            entry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\n+            entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\n             entry.setCrc(realCrc);\n \n             def.reset();\n         written += SHORT;\n \n         // last mod. time and date\n-        writeOut(toDosTime(ze.getTime()));\n+        writeOut(ZipUtil.toDosTime(ze.getTime()));\n         written += WORD;\n \n         // CRC\n         written += SHORT;\n \n         // last mod. time and date\n-        writeOut(toDosTime(ze.getTime()));\n+        writeOut(ZipUtil.toDosTime(ze.getTime()));\n         written += WORD;\n \n         // CRC\n     }\n \n     /**\n-     * Smallest date/time ZIP can handle.\n-     */\n-    private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n-\n-    /**\n-     * Convert a Date object to a DOS date/time field.\n-     * @param time the <code>Date</code> to convert\n-     * @return the date as a <code>ZipLong</code>\n-     */\n-    protected static ZipLong toDosTime(Date time) {\n-        return new ZipLong(toDosTime(time.getTime()));\n-    }\n-\n-    /**\n-     * Convert a Date object to a DOS date/time field.\n-     *\n-     * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n-     * @param t number of milliseconds since the epoch\n-     * @return the date as a byte array\n-     */\n-    protected static byte[] toDosTime(long t) {\n-        Date time = new Date(t);\n-        // CheckStyle:MagicNumberCheck OFF - I do not think that using constants\n-        //                                   here will improve the readablity\n-        int year = time.getYear() + 1900;\n-        if (year < 1980) {\n-            return DOS_TIME_MIN;\n-        }\n-        int month = time.getMonth() + 1;\n-        long value =  ((year - 1980) << 25)\n-            |         (month << 21)\n-            |         (time.getDate() << 16)\n-            |         (time.getHours() << 11)\n-            |         (time.getMinutes() << 5)\n-            |         (time.getSeconds() >> 1);\n-        return ZipLong.getBytes(value);\n-        // CheckStyle:MagicNumberCheck ON\n-    }\n-\n-    /**\n      * Write bytes to output or random access file.\n      * @param data the byte array to write\n      * @throws IOException on error\n             raf.write(data, offset, length);\n         } else {\n             out.write(data, offset, length);\n-        }\n-    }\n-\n-    /**\n-     * Assumes a negative integer really is a positive integer that\n-     * has wrapped around and re-creates the original value.\n-     * @param i the value to treat as unsigned int.\n-     * @return the unsigned int as a long.\n-     */\n-    protected static long adjustToLong(int i) {\n-        if (i < 0) {\n-            return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n-        } else {\n-            return i;\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n             // FIXME this is actually not very cpu cycles friendly as we are converting from\n             // dos to java while the underlying Sun implementation will convert\n             // from java to dos time for internal storage...\n-            long time = dosToJavaTime(ZipLong.getValue(cfh, off));\n+            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n             ze.setTime(time);\n             off += WORD;\n \n     }\n \n     /**\n-     * Convert a DOS date/time field to a Date object.\n-     *\n-     * @param zipDosTime contains the stored DOS time.\n-     * @return a Date instance corresponding to the given time.\n-     */\n-    protected static Date fromDosTime(ZipLong zipDosTime) {\n-        long dosTime = zipDosTime.getValue();\n-        return new Date(dosToJavaTime(dosTime));\n-    }\n-\n-    /*\n-     * Converts DOS time to Java time (number of milliseconds since epoch).\n-     */\n-    private static long dosToJavaTime(long dosTime) {\n-        Calendar cal = Calendar.getInstance();\n-        // CheckStyle:MagicNumberCheck OFF - no point\n-        cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\n-        cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\n-        cal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\n-        cal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\n-        cal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\n-        cal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n-        // CheckStyle:MagicNumberCheck ON\n-        return cal.getTime().getTime();\n-    }\n-\n-\n-    /**\n      * Checks whether the archive starts with a LFH.  If it doesn't,\n      * it may be an empty archive.\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+public abstract class ZipUtil {\n+    /**\n+     * Smallest date/time ZIP can handle.\n+     */\n+    private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     * @param time the <code>Date</code> to convert\n+     * @return the date as a <code>ZipLong</code>\n+     */\n+    public static ZipLong toDosTime(Date time) {\n+        return new ZipLong(toDosTime(time.getTime()));\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     *\n+     * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n+     * @param t number of milliseconds since the epoch\n+     * @return the date as a byte array\n+     */\n+    public static byte[] toDosTime(long t) {\n+        Date time = new Date(t);\n+        // CheckStyle:MagicNumberCheck OFF - I do not think that using constants\n+        //                                   here will improve the readablity\n+        int year = time.getYear() + 1900;\n+        if (year < 1980) {\n+            return DOS_TIME_MIN;\n+        }\n+        int month = time.getMonth() + 1;\n+        long value =  ((year - 1980) << 25)\n+            |         (month << 21)\n+            |         (time.getDate() << 16)\n+            |         (time.getHours() << 11)\n+            |         (time.getMinutes() << 5)\n+            |         (time.getSeconds() >> 1);\n+        return ZipLong.getBytes(value);\n+        // CheckStyle:MagicNumberCheck ON\n+    }\n+\n+    /**\n+     * Assumes a negative integer really is a positive integer that\n+     * has wrapped around and re-creates the original value.\n+     * @param i the value to treat as unsigned int.\n+     * @return the unsigned int as a long.\n+     */\n+    public static long adjustToLong(int i) {\n+        if (i < 0) {\n+            return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    /**\n+     * Convert a DOS date/time field to a Date object.\n+     *\n+     * @param zipDosTime contains the stored DOS time.\n+     * @return a Date instance corresponding to the given time.\n+     */\n+    public static Date fromDosTime(ZipLong zipDosTime) {\n+        long dosTime = zipDosTime.getValue();\n+        return new Date(dosToJavaTime(dosTime));\n+    }\n+\n+    /**\n+     * Converts DOS time to Java time (number of milliseconds since\n+     * epoch).\n+     */\n+    public static long dosToJavaTime(long dosTime) {\n+        Calendar cal = Calendar.getInstance();\n+        // CheckStyle:MagicNumberCheck OFF - no point\n+        cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\n+        cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\n+        cal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\n+        cal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\n+        cal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\n+        cal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\n+        // CheckStyle:MagicNumberCheck ON\n+        return cal.getTime().getTime();\n+    }\n+\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n       index of the last char in the block, so\n       the block size == last + 1.\n     */\n-    int last;\n+    private int last;\n \n     /*\n       index in zptr[] of original string after sorting.\n     */\n-    int origPtr;\n+    private int origPtr;\n \n     /*\n       always: in the range 0 .. 9.\n       The current block size is 100000 * this number.\n     */\n-    int blockSize100k;\n-\n-    boolean blockRandomised;\n-\n-    int bytesOut;\n-    int bsBuff;\n-    int bsLive;\n-    CRC mCrc = new CRC();\n+    private int blockSize100k;\n+\n+    private boolean blockRandomised;\n+\n+    private int bytesOut;\n+    private int bsBuff;\n+    private int bsLive;\n+    private final CRC mCrc = new CRC();\n \n     private boolean[] inUse = new boolean[256];\n     private int nInUse;\n         }\n     }\n \n-    boolean closed = false;\n+    private boolean closed = false;\n \n     protected void finalize() throws Throwable {\n         close();\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n  * data.\n  */\n class CRC {\n-\t static final int crc32Table[] = {\n+    private static final int crc32Table[] = {\n \t        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n \t        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n \t        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n \t        this.globalCrc = globalCrcShadow;\n \t    }\n \n-\t    int globalCrc;\n+\t    private int globalCrc;\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import junit.framework.TestCase;\n+\n+public class ZipUtilTest extends TestCase {\n+    \n+    private Date time;\n+    private ZipLong zl;\n+    \n+    /**\n+     * Constructor\n+     */\t\n+    public ZipUtilTest(String name) {\n+        super(name);\n+    }\n+\t\n+    protected void setUp() throws Exception {\n+        time = new Date();\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(time);\n+        int year = cal.get(Calendar.YEAR);\n+        int month = cal.get(Calendar.MONTH) + 1;\n+        long value =  ((year - 1980) << 25)\n+            |         (month << 21)\n+            |\t      (cal.get(Calendar.DAY_OF_MONTH) << 16)\n+            |         (cal.get(Calendar.HOUR_OF_DAY) << 11)\n+            |         (cal.get(Calendar.MINUTE) << 5)\n+            |         (cal.get(Calendar.SECOND) >> 1);\n+\n+        byte[] result = new byte[4];\n+        result[0] = (byte) ((value & 0xFF));\n+        result[1] = (byte) ((value & 0xFF00) >> 8);\n+        result[2] = (byte) ((value & 0xFF0000) >> 16);\n+        result[3] = (byte) ((value & 0xFF000000L) >> 24);\n+        zl = new ZipLong(result);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+    \n+    public void testZipLong() throws Exception {\n+        ZipLong test = ZipUtil.toDosTime(time);\n+        assertEquals(test.getValue(), zl.getValue());\n+    }\n+\n+    public void testAdjustToLong() {\n+        assertEquals(Integer.MAX_VALUE,\n+                     ZipUtil.adjustToLong(Integer.MAX_VALUE));\n+        assertEquals(((long) Integer.MAX_VALUE) + 1,\n+                     ZipUtil.adjustToLong(Integer.MAX_VALUE + 1));\n+        assertEquals(2 * ((long) Integer.MAX_VALUE),\n+                     ZipUtil.adjustToLong(2 * Integer.MAX_VALUE));\n+    }\n+\n+}", "timestamp": 1237563757, "metainfo": ""}