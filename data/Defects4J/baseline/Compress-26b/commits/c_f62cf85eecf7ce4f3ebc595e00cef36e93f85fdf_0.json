{"sha": "f62cf85eecf7ce4f3ebc595e00cef36e93f85fdf", "log": "provide access to all entries of a given name in ZipFile, COMPRESS-227  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.Deque;\n import java.util.Enumeration;\n import java.util.HashMap;\n-import java.util.LinkedHashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n     private static final int POS_3 = 3;\n \n     /**\n-     * Maps ZipArchiveEntrys to two longs, recording the offsets of\n-     * the local file headers and the start of entry data.\n-     */\n-    private final Map<ZipArchiveEntry, OffsetEntry> entries =\n-        new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE);\n-\n-    /**\n-     * Maps String to ZipArchiveEntrys, name -> actual entry.\n-     */\n-    private final Map<String, ZipArchiveEntry> nameMap =\n-        new HashMap<String, ZipArchiveEntry>(HASH_SIZE);\n+     * List of entries in the order they appear inside the central\n+     * directory.\n+     */\n+    private final List<ZipArchiveEntry> entries =\n+        new LinkedList<ZipArchiveEntry>();\n+\n+    /**\n+     * Maps String to list of ZipArchiveEntrys, name -> actual entries.\n+     */\n+    private final Map<String, Deque<ZipArchiveEntry>> nameMap =\n+        new HashMap<String, Deque<ZipArchiveEntry>>(HASH_SIZE);\n \n     private static final class OffsetEntry {\n         private long headerOffset = -1;\n      * @return all entries as {@link ZipArchiveEntry} instances\n      */\n     public Enumeration<ZipArchiveEntry> getEntries() {\n-        return Collections.enumeration(entries.keySet());\n+        return Collections.enumeration(entries);\n     }\n \n     /**\n      * @since 1.1\n      */\n     public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n-        ZipArchiveEntry[] allEntries =\n-            entries.keySet().toArray(new ZipArchiveEntry[0]);\n+        ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[0]);\n         Arrays.sort(allEntries, OFFSET_COMPARATOR);\n         return Collections.enumeration(Arrays.asList(allEntries));\n     }\n     /**\n      * Returns a named entry - or {@code null} if no entry by\n      * that name exists.\n+     *\n+     * <p>If multiple entries with the same name exist the first entry\n+     * in the archive's central directory by that name is\n+     * returned.</p>\n+     *\n      * @param name name of the entry.\n      * @return the ZipArchiveEntry corresponding to the given name - or\n      * {@code null} if not present.\n      */\n     public ZipArchiveEntry getEntry(String name) {\n-        return nameMap.get(name);\n+        Deque<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        return entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n+    }\n+\n+    /**\n+     * Returns all named entries in the same order they appear within\n+     * the archive's central directory.\n+     *\n+     * @param name name of the entry.\n+     * @return the Iterator<ZipArchiveEntry> corresponding to the\n+     * given name\n+     * @since 1.6\n+     */\n+    public Iterator<ZipArchiveEntry> getEntries(String name) {\n+        Deque<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        return entriesOfThatName != null ? entriesOfThatName.iterator()\n+            : Collections.<ZipArchiveEntry>emptyList().iterator();\n+    }\n+\n+    /**\n+     * Returns all named entries in the same order their contents\n+     * appear within the archive.\n+     *\n+     * @param name name of the entry.\n+     * @return the Iterator<ZipArchiveEntry> corresponding to the\n+     * given name\n+     * @since 1.6\n+     */\n+    public Iterator<ZipArchiveEntry> getEntriesInPhysicalOrder(String name) {\n+        ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n+        if (nameMap.containsKey(name)) {\n+            entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n+            Arrays.sort(entriesOfThatName, OFFSET_COMPARATOR);\n+        }\n+        return Arrays.asList(entriesOfThatName).iterator();\n     }\n \n     /**\n      */\n     public InputStream getInputStream(ZipArchiveEntry ze)\n         throws IOException, ZipException {\n-        OffsetEntry offsetEntry = entries.get(ze);\n-        if (offsetEntry == null) {\n+        if (!(ze instanceof Entry)) {\n             return null;\n         }\n+        // checked just above\n+        @SuppressWarnings(\"unchecked\") OffsetEntry offsetEntry =\n+            ((Entry) ze).getOffsetEntry();\n         ZipUtil.checkRequestedFeatures(ze);\n         long start = offsetEntry.dataOffset;\n         BoundedInputStream bis =\n         throws IOException {\n         archive.readFully(CFH_BUF);\n         int off = 0;\n-        ZipArchiveEntry ze = new ZipArchiveEntry();\n+        OffsetEntry offset = new OffsetEntry();\n+        Entry ze = new Entry(offset);\n \n         int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n         ze.setName(entryEncoding.decode(fileName), fileName);\n \n         // LFH offset,\n-        OffsetEntry offset = new OffsetEntry();\n         offset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n         // data offset will be filled later\n-        entries.put(ze, offset);\n+        entries.add(ze);\n \n         byte[] cdExtraData = new byte[extraLen];\n         archive.readFully(cdExtraData);\n     private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                             entriesWithoutUTF8Flag)\n         throws IOException {\n-        // changing the name of a ZipArchiveEntry is going to change\n-        // the hashcode - see COMPRESS-164\n-        // Map needs to be reconstructed in order to keep central\n-        // directory order\n-        Map<ZipArchiveEntry, OffsetEntry> origMap =\n-            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n-        entries.clear();\n-        for (Map.Entry<ZipArchiveEntry, OffsetEntry> ent : origMap.entrySet()) {\n-            ZipArchiveEntry ze = ent.getKey();\n-            OffsetEntry offsetEntry = ent.getValue();\n+        for (Iterator<ZipArchiveEntry> it = entries.iterator(); it.hasNext(); ) {\n+            // entries is filled in populateFromCentralDirectory and\n+            // never modified\n+            @SuppressWarnings(\"unchecked\") Entry ze = (Entry) it.next();\n+            OffsetEntry offsetEntry = ze.getOffsetEntry();\n             long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n             archive.readFully(SHORT_BUF);\n                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n \n             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n-                String orig = ze.getName();\n                 NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                          nc.comment);\n             }\n-            entries.put(ze, offsetEntry);\n-            nameMap.put(ze.getName(), ze);\n+\n+            String name = ze.getName();\n+            Deque<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+            if (entriesOfThatName == null) {\n+                entriesOfThatName = new LinkedList<ZipArchiveEntry>();\n+                nameMap.put(name, entriesOfThatName);\n+            }\n+            entriesOfThatName.addLast(ze);\n         }\n     }\n \n                 return 0;\n             }\n \n-            OffsetEntry off1 = entries.get(e1);\n-            OffsetEntry off2 = entries.get(e2);\n-            if (off1 == null) {\n+            @SuppressWarnings(\"unchecked\") Entry ent1 =\n+                e1 instanceof Entry ? (Entry) e1 : null;\n+            @SuppressWarnings(\"unchecked\") Entry ent2 =\n+                e2 instanceof Entry ? (Entry) e2 : null;\n+            if (ent1 == null) {\n                 return 1;\n             }\n-            if (off2 == null) {\n+            if (ent2 == null) {\n                 return -1;\n             }\n-            long val = (off1.headerOffset - off2.headerOffset);\n+            long val = (ent1.getOffsetEntry().headerOffset\n+                        - ent2.getOffsetEntry().headerOffset);\n             return val == 0 ? 0 : val < 0 ? -1 : +1;\n         }\n     };\n+\n+    /**\n+     * Extends ZipArchiveEntry to store the offset within the archive.\n+     */\n+    private static class Entry extends ZipArchiveEntry {\n+\n+        private final OffsetEntry offsetEntry;\n+\n+        Entry(OffsetEntry offset) {\n+            this.offsetEntry = offset;\n+        }\n+\n+        OffsetEntry getOffsetEntry() {\n+            return offsetEntry;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 3 * super.hashCode()\n+                + (int) (offsetEntry.headerOffset % Integer.MAX_VALUE);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (super.equals(other)) {\n+                // super.equals would return false otherwise\n+                @SuppressWarnings(\"unchecked\") Entry otherEntry = (Entry) other;\n+                return offsetEntry.headerOffset\n+                        == otherEntry.offsetEntry.headerOffset\n+                    && offsetEntry.dataOffset\n+                        == otherEntry.offsetEntry.dataOffset;\n+            }\n+            return false;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.Iterator;\n import java.util.TreeMap;\n import java.util.zip.ZipEntry;\n \n         ZipArchiveEntry ze = zf.getEntry(\"test1.txt\");\n         assertNotNull(ze);\n         assertNotNull(zf.getInputStream(ze));\n+\n+        int numberOfEntries = 0;\n+        for (Iterator it = zf.getEntries(\"test1.txt\"); it.hasNext(); it.next()) {\n+            numberOfEntries++;\n+        }\n+        assertEquals(2, numberOfEntries);\n     }\n \n     /*", "timestamp": 1369504020, "metainfo": ""}