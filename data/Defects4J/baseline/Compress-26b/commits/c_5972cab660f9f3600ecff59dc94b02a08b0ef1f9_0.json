{"sha": "5972cab660f9f3600ecff59dc94b02a08b0ef1f9", "log": "Add encoding support to DumpArchiveInputStream - related to COMPRESS-180  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n     private String entryEncoding = null;\n \n     /**\n-     * Returns the encoding to use for arj, zip and tar files,\n+     * Returns the encoding to use for arj, zip, dump and tar files,\n      * or null for the default.\n      *\n      * @return entry encoding, or null\n     }\n \n     /**\n-     * Sets the encoding to use for arj, zip and tar files.\n-     * Use null for the default.\n+     * Sets the encoding to use for arj, zip, dump and tar files.  Use\n+     * null for the default.\n      *\n      * @since 1.5\n      */\n             return new CpioArchiveInputStream(in);\n         }\n         if (DUMP.equalsIgnoreCase(archiverName)) {\n-            return new DumpArchiveInputStream(in);\n+            if (entryEncoding != null) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new DumpArchiveInputStream(in);\n+            }\n         }\n \n         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveException;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n \n import java.io.EOFException;\n import java.io.IOException;\n  * Methods are provided to position at each successive entry in\n  * the archive, and the read each entry as a normal input stream\n  * using read().\n+ *\n+ * There doesn't seem to exist a hint on the encoding of string values\n+ * in any piece documentation.  Given the main purpose of dump/restore\n+ * is backing up a system it seems very likely the format uses the\n+ * current default encoding of the system.\n  *\n  * @NotThreadSafe\n  */\n     private Queue<DumpArchiveEntry> queue;\n \n     /**\n+     * The encoding to use for filenames and labels.\n+     */\n+    private final ZipEncoding encoding;\n+\n+    /**\n+     * Constructor using the platform's default encoding for file\n+     * names.\n+     *\n+     * @param is\n+     * @throws ArchiveException\n+     */\n+    public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n+        this(is, null);\n+    }\n+\n+    /**\n      * Constructor.\n      *\n      * @param is\n-     * @throws ArchiveException\n-     */\n-    public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @since 1.6\n+     */\n+    public DumpArchiveInputStream(InputStream is, String encoding)\n+        throws ArchiveException {\n         this.raw = new TapeInputStream(is);\n         this.hasHitEOF = false;\n+        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         try {\n             // read header, verify it's a dump archive.\n             }\n \n             // get summary information\n-            summary = new DumpArchiveSummary(headerBytes);\n+            summary = new DumpArchiveSummary(headerBytes, this.encoding);\n \n             // reset buffer with actual block size.\n             raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n \n                 byte type = blockBuffer[i + 6];\n \n-                String name = new String(blockBuffer, i + 8, blockBuffer[i + 7]); // TODO default charset?\n+                String name = DumpArchiveUtil.decode(encoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n \n                 if (\".\".equals(name) || \"..\".equals(name)) {\n                     // do nothing...\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n+import java.io.IOException;\n import java.util.Date;\n \n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n \n /**\n  * This class represents identifying information about a Dump archive volume.\n     private int firstrec;\n     private int ntrec;\n \n-    DumpArchiveSummary(byte[] buffer) {\n+    DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\n         dumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\n         previousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\n         volume = DumpArchiveUtil.convert32(buffer, 12);\n-        label = new String(buffer, 676, DumpArchiveConstants.LBLSIZE).trim(); // TODO default charset?\n+        label = DumpArchiveUtil.decode(encoding, buffer, 676, DumpArchiveConstants.LBLSIZE).trim();\n         level = DumpArchiveUtil.convert32(buffer, 692);\n-        filesys = new String(buffer, 696, DumpArchiveConstants.NAMELEN).trim(); // TODO default charset?\n-        devname = new String(buffer, 760, DumpArchiveConstants.NAMELEN).trim(); // TODO default charset?\n-        hostname = new String(buffer, 824, DumpArchiveConstants.NAMELEN).trim(); // TODO default charset?\n+        filesys = DumpArchiveUtil.decode(encoding, buffer, 696, DumpArchiveConstants.NAMELEN).trim();\n+        devname = DumpArchiveUtil.decode(encoding, buffer, 760, DumpArchiveConstants.NAMELEN).trim();\n+        hostname = DumpArchiveUtil.decode(encoding, buffer, 824, DumpArchiveConstants.NAMELEN).trim();\n         flags = DumpArchiveUtil.convert32(buffer, 888);\n         firstrec = DumpArchiveUtil.convert32(buffer, 892);\n         ntrec = DumpArchiveUtil.convert32(buffer, 896);\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n+import java.io.IOException;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n \n /**\n  * Various utilities for dump archives.\n \n         return i;\n     }\n+\n+    /**\n+     * Decodes a byte array to a string.\n+     */\n+    static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\n+        throws IOException {\n+        byte[] copy = new byte[len];\n+        System.arraycopy(b, offset, copy, 0, len);\n+        return encoding.decode(copy);\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n \n import org.apache.commons.compress.utils.BoundedInputStream;\n import org.apache.commons.compress.utils.CRC32VerifyingInputStream;\n+import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n  * Reads a 7z file, using RandomAccessFile under\n                         int nextName = 0;\n                         for (int i = 0; i < names.length; i += 2) {\n                             if (names[i] == 0 && names[i+1] == 0) {\n-                                files[nextFile++].setName(new String(names, nextName, i-nextName, \"UTF-16LE\"));\n+                                files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n                                 nextName = i + 2;\n                             }\n                         }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n     // Helper method to generate the exception message\n     private static String exceptionMessage(byte[] buffer, final int offset,\n             final int length, int current, final byte currentByte) {\n-        String string = new String(buffer, offset, length); // TODO default charset?\n+        // default charset is good enough for an exception message,\n+        //\n+        // the alternative was to modify parseOctal and\n+        // parseOctalOrBinary to receive the ZipEncoding of the\n+        // archive (deprecating the existing public methods, of\n+        // course) and dealing with the fact that ZipEncoding#decode\n+        // can throw an IOException which parseOctal* doesn't declare\n+        String string = new String(buffer, offset, length);\n+\n         string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\n         final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n         return s;", "timestamp": 1376151769, "metainfo": ""}