{"sha": "576c408ea92683ebd4e20118c4d2ec05cb8a58e2", "log": "sync with trunk  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n                 TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 tais.getNextEntry();\n                 return new TarArchiveInputStream(in);\n-            } catch (Exception e) { // can generate IllegalArgumentException as well as IOException\n+            } catch (Exception e) { // NOPMD\n+                // can generate IllegalArgumentException as well as IOException\n+                // autodetection, simply not a TAR\n                 // ignored\n             }\n         } catch (IOException e) {\n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.InputStream;\n-\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.ArchiveInputStream;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n \n /**\n  * Simple command line application that lists the contents of an archive.\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n             }\n         }\n \n-        if (offset % 2 != 0) {\n-            if (read() < 0) {\n-                // hit eof\n-                return null;\n-            }\n+        if (offset % 2 != 0 && read() < 0) {\n+            // hit eof\n+            return null;\n         }\n \n         if (input.available() == 0) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n      */\n     private void closeEntry() throws IOException {\n         ensureOpen();\n-        while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) {\n+        while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { // NOPMD\n             // do nothing\n         }\n \n         if (this.entryBytesRead == this.entry.getSize()) {\n             skip(entry.getDataPadCount());\n             this.entryEOF = true;\n-            if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n-                if (this.crc != this.entry.getChksum()) {\n-                    throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead());\n-                }\n+            if (this.entry.getFormat() == FORMAT_NEW_CRC\n+                && this.crc != this.entry.getChksum()) {\n+                throw new IOException(\"CRC Error. Occured at byte: \"\n+                                      + getBytesRead());\n             }\n             return -1; // EOF for this entry\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n                     + \" bytes)\");\n         }\n         pad(this.entry.getDataPadCount());\n-        if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n-            if (this.crc != this.entry.getChksum()) {\n-                throw new IOException(\"CRC Error\");\n-            }\n+        if (this.entry.getFormat() == FORMAT_NEW_CRC\n+            && this.crc != this.entry.getChksum()) {\n+            throw new IOException(\"CRC Error\");\n         }\n         this.entry = null;\n         this.crc = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n             return null;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.compress.archivers.zip.ZipArchiveEntry#equals(java.lang.Object)\n-     */\n-    public boolean equals(Object obj) {\n-        return super.equals(obj);\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.compress.archivers.zip.ZipArchiveEntry#hashCode()\n-     */\n-    public int hashCode() {\n-        return super.hashCode();\n-    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n             throw new IOException(\"reading (via skip) from an output buffer\");\n         }\n \n-        if (currRecIdx >= recsPerBlock) {\n-            if (!readBlock()) {\n-                return;    // UNDONE\n-            }\n+        if (currRecIdx >= recsPerBlock && !readBlock()) {\n+            return;    // UNDONE\n         }\n \n         currRecIdx++;\n             throw new IOException(\"reading from an output buffer\");\n         }\n \n-        if (currRecIdx >= recsPerBlock) {\n-            if (!readBlock()) {\n-                return null;\n-            }\n+        if (currRecIdx >= recsPerBlock && !readBlock()) {\n+            return null;\n         }\n \n         byte[] result = new byte[recordSize];\n         } else if (inStream != null) {\n             if (inStream != System.in) {\n                 inStream.close();\n-\n-                inStream = null;\n-            }\n+            }\n+            inStream = null;\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     public void write(byte[] b, int offset, int length) throws IOException {\n         ZipUtil.checkRequestedFeatures(entry);\n         if (entry.getMethod() == DEFLATED) {\n-            if (length > 0) {\n-                if (!def.finished()) {\n-                    if (length <= DEFLATER_BLOCK_SIZE) {\n-                        def.setInput(b, offset, length);\n+            if (length > 0 && !def.finished()) {\n+                if (length <= DEFLATER_BLOCK_SIZE) {\n+                    def.setInput(b, offset, length);\n+                    deflateUntilInputIsNeeded();\n+                } else {\n+                    final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n+                    for (int i = 0; i < fullblocks; i++) {\n+                        def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n+                                     DEFLATER_BLOCK_SIZE);\n                         deflateUntilInputIsNeeded();\n-                    } else {\n-                        final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n-                        for (int i = 0; i < fullblocks; i++) {\n-                            def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n-                                         DEFLATER_BLOCK_SIZE);\n-                            deflateUntilInputIsNeeded();\n-                        }\n-                        final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n-                        if (done < length) {\n-                            def.setInput(b, offset + done, length - done);\n-                            deflateUntilInputIsNeeded();\n-                        }\n+                    }\n+                    final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n+                    if (done < length) {\n+                        def.setInput(b, offset + done, length - done);\n+                        deflateUntilInputIsNeeded();\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n                 try {\n                     closed = true;\n                     archive.close();\n-                } catch (IOException e2) {\n+                } catch (IOException e2) { // NOPMD\n                     // swallow, throw the original exception instead\n                 }\n             }\n         if (zipfile != null) {\n             try {\n                 zipfile.close();\n-            } catch (IOException e) {\n-                //ignore\n+            } catch (IOException e) { // NOPMD\n+                //ignore, that's why the method is called \"quietly\"\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n                         results.deleted(name);\n                         break;\n                     }\n-                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n-                    if (name.startsWith(change.targetFile() + \"/\")) {\n+                } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n+                    // don't combine ifs to make future extensions more easy\n+                    if (name.startsWith(change.targetFile() + \"/\")) { // NOPMD\n                         copy = false;\n                         results.deleted(name);\n                         break;\n                 }\n             }\n \n-            if (copy) {\n-                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n-                    copyStream(in, out, entry);\n-                    results.addedFromStream(entry.getName());\n-                }\n+            if (copy\n+                && !isDeletedLater(workingSet, entry)\n+                && !results.hasBeenAdded(entry.getName())) {\n+                copyStream(in, out, entry);\n+                results.addedFromStream(entry.getName());\n             }\n         }\n         \n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n          * I don't initialize it at construction time to avoid unneccessary\n          * memory allocation when compressing small files.\n          */\n-        final int[] initTT(int length) {\n+        int[] initTT(int length) {\n             int[] ttShadow = this.tt;\n \n             // tt.length should always be >= length, but theoretically\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n         sendMTFValues6(nGroups, alphaSize);\n \n         /* And finally, the block data proper */\n-        sendMTFValues7(nSelectors);\n+        sendMTFValues7();\n     }\n \n     private void sendMTFValues0(final int nGroups, final int alphaSize) {\n         this.bsLive = bsLiveShadow;\n     }\n \n-    private void sendMTFValues7(final int nSelectors) throws IOException {\n+    private void sendMTFValues7() throws IOException {\n         final Data dataShadow = this.data;\n         final byte[][] len = dataShadow.sendMTFValues_len;\n         final int[][] code = dataShadow.sendMTFValues_code;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     private int method = -1;\n \n+    /**\n+     * The {@link java.util.zip.ZipEntry#setSize} method in the base\n+     * class throws an IllegalArgumentException if the size is bigger\n+     * than 2GB for Java versions < 7.  Need to keep our own size\n+     * information for Zip64 support.\n+     */\n+    private long size = SIZE_UNKNOWN;\n+\n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n             setExtra();\n         }\n         setMethod(entry.getMethod());\n+        this.size = entry.getSize();\n     }\n \n     /**\n      */\n     protected void setName(String name) {\n         this.name = name;\n+    }\n+\n+    /**\n+     * Gets the uncompressed size of the entry data.\n+     * @return the entry size\n+     */\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Sets the uncompressed size of the entry data.\n+     * @param size the uncompressed size in bytes\n+     * @exception IllegalArgumentException if the specified size is less\n+     *            than 0\n+     */\n+    public void setSize(long size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"invalid entry size\");\n+        }\n+        this.size = size;\n     }\n \n     /**", "timestamp": 1311583468, "metainfo": ""}