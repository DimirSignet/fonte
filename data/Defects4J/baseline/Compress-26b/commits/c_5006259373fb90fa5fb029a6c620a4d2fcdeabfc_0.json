{"sha": "5006259373fb90fa5fb029a6c620a4d2fcdeabfc", "log": "currently failing (almost passing ;-) test for deflate with known size to a stream case, save work  ", "commit": "\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n     private static final int ONE_HUNDRED_THOUSAND = 100000;\n \n     @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n-        FileInputStream fin = new FileInputStream(get5GBZerosFile());\n-        ZipArchiveInputStream zin = null;\n-        try {\n-            zin = new ZipArchiveInputStream(fin);\n-            ZipArchiveEntry zae = zin.getNextZipEntry();\n-            assertEquals(\"5GB_of_Zeros\", zae.getName());\n-            assertEquals(FIVE_BILLION, zae.getSize());\n-            byte[] buf = new byte[1024 * 1024];\n-            long read = 0;\n-            Random r = new Random(System.currentTimeMillis());\n-            int readNow;\n-            while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n-                // testing all bytes for a value of 0 is going to take\n-                // too long, just pick a few ones randomly\n-                for (int i = 0; i < 1024; i++) {\n-                    int idx = r.nextInt(readNow);\n-                    assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n-                }\n-                read += readNow;\n-            }\n-            assertEquals(FIVE_BILLION, read);\n-            assertNull(zin.getNextZipEntry());\n-        } finally {\n-            if (zin != null) {\n-                zin.close();\n-            }\n-            if (fin != null) {\n-                fin.close();\n-            }\n-        }\n+        read5GBOfZerosImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n     }\n \n     @Test public void read100KFilesUsingInputStream() throws Throwable {\n      *\n      * Creates a temporary archive of approx 5GB in size\n      */\n+    @Ignore\n     @Test public void writeBigStoredEntryToStream() throws Throwable {\n         withTemporaryArchive(\"writeBigStoredEntryToStream\",\n                              new ZipOutputTest() {\n                                      } finally {\n                                          a.close();\n                                      }\n+                                 }\n+                             },\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH and ZIP64\n+     * entry, real values are inside the data descriptor.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    @Ignore\n+    @Test public void writeBigDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     byte[] buf = new byte[1000 * 1000];\n+                                     ZipArchiveEntry zae =\n+                                         new ZipArchiveEntry(\"0\");\n+                                     zae.setSize(FIVE_BILLION);\n+                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                     zos.putArchiveEntry(zae);\n+                                     for (int j = 0;\n+                                          j < FIVE_BILLION / 1000 / 1000;\n+                                          j++) {\n+                                         zos.write(buf);\n+                                     }\n+                                     zos.closeArchiveEntry();\n+                                     zos.close();\n+\n+                                     RandomAccessFile a =\n+                                         new RandomAccessFile(f, \"r\");\n+                                     try {\n+                                         final long end = a.length();\n+                                         long cdOffsetLoc = end - 22\n+                                             - 20\n+                                             - 56\n+                                             + 48;\n+                                         // seek to central directory\n+                                         a.seek(cdOffsetLoc);\n+                                         byte[] cdOffset = new byte[8];\n+                                         a.readFully(cdOffset);\n+                                         a.seek(ZipEightByteInteger\n+                                                .getLongValue(cdOffset));\n+\n+                                         // grab first entry, verify\n+                                         // sizes are 0xFFFFFFFF and\n+                                         // it has a ZIP64 extended\n+                                         // information extra field\n+                                         byte[] header = new byte[12];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                                 // version made by\n+                                                 45, 0,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         byte[] crc = new byte[4];\n+                                         a.readFully(crc);\n+                                         assertArrayEquals(new byte[] {\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                             }, crc);\n+                                         // ignore compressed size,\n+                                         // check it is smaller than\n+                                         // 4GB by validating it is\n+                                         // not part of the ZIP64\n+                                         // extra field\n+                                         a.skipBytes(4);\n+                                         byte[] rest = new byte[23];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 12, 0,\n+                                                 // comment length\n+                                                 0, 0,\n+                                                 // disk number\n+                                                 0, 0,\n+                                                 // attributes\n+                                                 0, 0,\n+                                                 0, 0, 0, 0,\n+                                                 // offset\n+                                                 0, 0, 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         byte[] extra = new byte[12];\n+                                         a.readFully(extra);\n+                                         // 5e9 == 0x12A05F200\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 8, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                             }, extra);\n+\n+                                         // and now validate local file header\n+                                         a.seek(0);\n+                                         header = new byte[10];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         rest = new byte[17];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 0, 0, 0, 0,\n+                                                 // Compressed Size\n+                                                 0, 0, 0, 0,\n+                                                 // Original Size\n+                                                 0, 0, 0, 0,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         a.readFully(extra);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, 0, 0, 0,\n+                                                 // compressed size\n+                                                 0, 0, 0, 0,\n+                                             }, extra);\n+                                     } finally {\n+                                         a.close();\n+                                     }\n+\n+                                     read5GBOfZerosImpl(f, \"0\");\n                                  }\n                              },\n                              false);\n         f.deleteOnExit();\n         return f;\n     }\n+\n+    private static void read5GBOfZerosImpl(File f, String expectedName)\n+        throws IOException {\n+        FileInputStream fin = new FileInputStream(f);\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(fin);\n+            ZipArchiveEntry zae = zin.getNextZipEntry();\n+            assertEquals(expectedName, zae.getName());\n+            byte[] buf = new byte[1024 * 1024];\n+            long read = 0;\n+            Random r = new Random(System.currentTimeMillis());\n+            int readNow;\n+            while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n+                // testing all bytes for a value of 0 is going to take\n+                // too long, just pick a few ones randomly\n+                for (int i = 0; i < 1024; i++) {\n+                    int idx = r.nextInt(readNow);\n+                    assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n+                }\n+                read += readNow;\n+            }\n+            assertEquals(FIVE_BILLION, read);\n+            assertEquals(FIVE_BILLION, zae.getSize());\n+            assertNull(zin.getNextZipEntry());\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+            if (fin != null) {\n+                fin.close();\n+            }\n+        }\n+    }\n }", "timestamp": 1312008038, "metainfo": ""}