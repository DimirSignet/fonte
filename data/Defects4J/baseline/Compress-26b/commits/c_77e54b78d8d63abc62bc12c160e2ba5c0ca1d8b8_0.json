{"sha": "77e54b78d8d63abc62bc12c160e2ba5c0ca1d8b8", "log": "even if those arrays are small, ensure they are read completely - also make draining more efficient.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n import org.apache.commons.compress.utils.ArchiveUtils;\n+import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * Implements the \"ar\" archive format as an input stream.\n     public ArArchiveEntry getNextArEntry() throws IOException {\n         if (currentEntry != null) {\n             final long entryEnd = entryOffset + currentEntry.getLength();\n-            while (offset < entryEnd) {\n-                int x = read();\n-                if (x == -1) {\n-                    // hit EOF before previous entry was complete\n-                    // TODO: throw an exception instead?\n-                    return null;\n-                }\n-            }\n+            IOUtils.skip(this, entryEnd - offset);\n             currentEntry = null;\n         }\n \n         if (offset == 0) {\n             final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n             final byte[] realized = new byte[expected.length];\n-            final int read = read(realized);\n+            final int read = IOUtils.readFully(this, realized);\n             if (read != expected.length) {\n                 throw new IOException(\"failed to read header. Occured at byte: \" + getBytesRead());\n             }\n             return null;\n         }\n \n-        read(NAME_BUF);\n-        read(LAST_MODIFIED_BUF);\n-        read(ID_BUF);\n+        IOUtils.readFully(this, NAME_BUF);\n+        IOUtils.readFully(this, LAST_MODIFIED_BUF);\n+        IOUtils.readFully(this, ID_BUF);\n         int userId = asInt(ID_BUF, true);\n-        read(ID_BUF);\n-        read(FILE_MODE_BUF);\n-        read(LENGTH_BUF);\n+        IOUtils.readFully(this, ID_BUF);\n+        IOUtils.readFully(this, FILE_MODE_BUF);\n+        IOUtils.readFully(this, LENGTH_BUF);\n \n         {\n             final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\n             final byte[] realized = new byte[expected.length];\n-            final int read = read(realized);\n+            final int read = IOUtils.readFully(this, realized);\n             if (read != expected.length) {\n                 throw new IOException(\"failed to read entry trailer. Occured at byte: \" + getBytesRead());\n             }\n         int nameLen =\n             Integer.parseInt(bsdLongName.substring(BSD_LONGNAME_PREFIX_LEN));\n         byte[] name = new byte[nameLen];\n-        int read = 0, readNow = 0;\n-        while ((readNow = input.read(name, read, nameLen - read)) >= 0) {\n-            read += readNow;\n-            count(readNow);\n-            if (read == nameLen) {\n-                break;\n-            }\n-        }\n+        int read = IOUtils.readFully(input, name);\n+        count(read);\n         if (read != nameLen) {\n             throw new EOFException();\n         }", "timestamp": 1388608906, "metainfo": ""}