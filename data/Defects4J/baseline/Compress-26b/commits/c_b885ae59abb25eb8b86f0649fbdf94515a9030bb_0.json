{"sha": "b885ae59abb25eb8b86f0649fbdf94515a9030bb", "log": "merge 7z write support  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n  */\n public class SevenZFile {\n     private static final boolean DEBUG = false;\n-    private static final int SIGNATURE_HEADER_SIZE = 32;\n+    static final int SIGNATURE_HEADER_SIZE = 32;\n     private RandomAccessFile file;\n     private final Archive archive;\n     private int currentEntryIndex = -1;\n     private InputStream currentEntryInputStream = null;\n     private String password;\n         \n-    private static final byte[] sevenZSignature = {\n+    static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n     \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+\n+/**\n+ * Writes a 7z file.\n+ */\n+public class SevenZOutputFile {\n+    private final RandomAccessFile file;\n+    private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\n+    private int numNonEmptyStreams = 0;\n+    private CRC32 crc32 = new CRC32();\n+    private long fileBytesWritten = 0;\n+    private boolean finished = false;\n+    \n+    public SevenZOutputFile(final File filename) throws IOException {\n+        file = new RandomAccessFile(filename, \"rw\");\n+        file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n+    }\n+    \n+    public void close() {\n+        try {\n+            if (!finished) {\n+                finish();\n+            }\n+            file.close();\n+        } catch (IOException ioEx) { // NOPMD\n+        }\n+    }\n+    \n+    public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n+            final String entryName) throws IOException {\n+        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+        entry.setDirectory(inputFile.isDirectory());\n+        entry.setName(entryName);\n+        entry.setHasLastModifiedDate(true);\n+        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n+        return entry;\n+    }\n+\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n+        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n+        files.add(entry);\n+    }\n+    \n+    public void closeArchiveEntry() throws IOException {\n+        final SevenZArchiveEntry entry = files.get(files.size() - 1);\n+        if (fileBytesWritten > 0) {\n+            entry.setHasStream(true);\n+            ++numNonEmptyStreams;\n+            entry.setSize(fileBytesWritten);\n+            entry.setCrc((int) crc32.getValue());\n+            entry.setHasCrc(true);\n+        } else {\n+            entry.setHasStream(false);\n+            entry.setSize(0);\n+            entry.setHasCrc(false);\n+        }\n+        crc32.reset();\n+        fileBytesWritten = 0;\n+    }\n+    \n+    public void write(final int b) throws IOException {\n+        file.write(b);\n+        crc32.update(b);\n+        fileBytesWritten++;\n+    }\n+    \n+    public void write(final byte[] b) throws IOException {\n+        write(b, 0, b.length);\n+    }\n+    \n+    public void write(final byte[] b, final int off, final int len) throws IOException {\n+        file.write(b, off, len);\n+        crc32.update(b, off, len);\n+        fileBytesWritten += len;\n+    }\n+    \n+    public void finish() throws IOException {\n+        if (finished) {\n+            throw new IOException(\"This archive has already been finished\");\n+        }\n+        finished = true;\n+        \n+        final long headerPosition = file.getFilePointer();\n+        \n+        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n+        final DataOutputStream header = new DataOutputStream(headerBaos);\n+        \n+        writeHeader(header);\n+        header.flush();\n+        final byte[] headerBytes = headerBaos.toByteArray();\n+        file.write(headerBytes);\n+        \n+        final CRC32 crc32 = new CRC32();\n+        \n+        // signature header\n+        file.seek(0);\n+        file.write(SevenZFile.sevenZSignature);\n+        // version\n+        file.write(0);\n+        file.write(2);\n+        \n+        // start header\n+        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n+        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n+        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n+        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n+        crc32.reset();\n+        crc32.update(headerBytes);\n+        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n+        startHeaderStream.flush();\n+        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n+        crc32.reset();\n+        crc32.update(startHeaderBytes);\n+        file.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n+        file.write(startHeaderBytes);\n+    }\n+    \n+    private void writeHeader(final DataOutput header) throws IOException {\n+        header.write(NID.kHeader);\n+        \n+        header.write(NID.kMainStreamsInfo);\n+        writeStreamsInfo(header);\n+        writeFilesInfo(header);\n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeStreamsInfo(final DataOutput header) throws IOException {\n+        if (numNonEmptyStreams > 0) {\n+            writePackInfo(header);\n+            writeUnpackInfo(header);\n+        }\n+        \n+        writeSubStreamsInfo(header);\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writePackInfo(final DataOutput header) throws IOException {\n+        // FIXME: this needs to use the compressed sizes/CRCs when we start supporting compression.\n+        header.write(NID.kPackInfo);\n+        \n+        writeUint64(header, 0);\n+        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n+        \n+        header.write(NID.kSize);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                writeUint64(header, entry.getSize());\n+            }\n+        }\n+        \n+        header.write(NID.kCRC);\n+        header.write(1);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+            }\n+        }\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeUnpackInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kUnpackInfo);\n+        \n+        header.write(NID.kFolder);\n+        // FIXME: add real support for solid compression, and actual compression methods\n+        writeUint64(header, numNonEmptyStreams);\n+        header.write(0);\n+        for (int i = 0; i < numNonEmptyStreams; i++) {\n+            writeFolder(header);\n+        }\n+        \n+        header.write(NID.kCodersUnpackSize);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                writeUint64(header, entry.getSize());\n+            }\n+        }\n+        \n+        header.write(NID.kCRC);\n+        header.write(1);\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.hasStream()) {\n+                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+            }\n+        }\n+        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeFolder(final DataOutput header) throws IOException {\n+        writeUint64(header, 1);\n+        header.write(1);\n+        header.write(0);\n+    }\n+    \n+    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kSubStreamsInfo);\n+//        \n+//        header.write(NID.kCRC);\n+//        header.write(1);\n+//        for (final SevenZArchiveEntry entry : files) {\n+//            if (entry.getHasCrc()) {\n+//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+//            }\n+//        }\n+//        \n+        header.write(NID.kEnd);\n+    }\n+    \n+    private void writeFilesInfo(final DataOutput header) throws IOException {\n+        header.write(NID.kFilesInfo);\n+        \n+        writeUint64(header, files.size());\n+\n+        writeFileEmptyStreams(header);\n+        writeFileEmptyFiles(header);\n+        writeFileAntiItems(header);\n+        writeFileNames(header);\n+        writeFileCTimes(header);\n+        writeFileATimes(header);\n+        writeFileMTimes(header);\n+        writeFileWindowsAttributes(header);\n+        header.write(0);\n+    }\n+    \n+    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n+        boolean hasEmptyStreams = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (!entry.hasStream()) {\n+                hasEmptyStreams = true;\n+                break;\n+            }\n+        }\n+        if (hasEmptyStreams) {\n+            header.write(NID.kEmptyStream);\n+            final BitSet emptyStreams = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                emptyStreams.set(i, !files.get(i).hasStream());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, emptyStreams, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n+        boolean hasEmptyFiles = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (!entry.hasStream() && !entry.isDirectory()) {\n+                hasEmptyFiles = true;\n+                break;\n+            }\n+        }\n+        if (hasEmptyFiles) {\n+            header.write(NID.kEmptyFile);\n+            final BitSet emptyFiles = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                emptyFiles.set(i, !files.get(i).hasStream() && !files.get(i).isDirectory());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, emptyFiles, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileAntiItems(final DataOutput header) throws IOException {\n+        boolean hasAntiItems = false;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.isAntiItem()) {\n+                hasAntiItems = true;\n+                break;\n+            }\n+        }\n+        if (hasAntiItems) {\n+            header.write(NID.kAnti);\n+            final BitSet antiItems = new BitSet(files.size());\n+            for (int i = 0; i < files.size(); i++) {\n+                antiItems.set(i, files.get(i).isAntiItem());\n+            }\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            writeBits(out, antiItems, files.size());\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+    \n+    private void writeFileNames(final DataOutput header) throws IOException {\n+        header.write(NID.kName);\n+        \n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final DataOutputStream out = new DataOutputStream(baos);\n+        out.write(0);\n+        for (final SevenZArchiveEntry entry : files) {\n+            out.write(entry.getName().getBytes(\"UTF-16LE\"));\n+            out.writeShort(0);\n+        }\n+        out.flush();\n+        final byte[] contents = baos.toByteArray();\n+        writeUint64(header, contents.length);\n+        header.write(contents);\n+    }\n+\n+    private void writeFileCTimes(final DataOutput header) throws IOException {\n+        int numCreationDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasCreationDate()) {\n+                ++numCreationDates;\n+            }\n+        }\n+        if (numCreationDates > 0) {\n+            header.write(NID.kCTime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numCreationDates != files.size()) {\n+                out.write(0);\n+                final BitSet cTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    cTimes.set(i, files.get(i).getHasCreationDate());\n+                }\n+                writeBits(out, cTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasCreationDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileATimes(final DataOutput header) throws IOException {\n+        int numAccessDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasAccessDate()) {\n+                ++numAccessDates;\n+            }\n+        }\n+        if (numAccessDates > 0) {\n+            header.write(NID.kATime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numAccessDates != files.size()) {\n+                out.write(0);\n+                final BitSet aTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    aTimes.set(i, files.get(i).getHasAccessDate());\n+                }\n+                writeBits(out, aTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasAccessDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileMTimes(final DataOutput header) throws IOException {\n+        int numLastModifiedDates = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasLastModifiedDate()) {\n+                ++numLastModifiedDates;\n+            }\n+        }\n+        if (numLastModifiedDates > 0) {\n+            header.write(NID.kMTime);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numLastModifiedDates != files.size()) {\n+                out.write(0);\n+                final BitSet mTimes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    mTimes.set(i, files.get(i).getHasLastModifiedDate());\n+                }\n+                writeBits(out, mTimes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasLastModifiedDate()) {\n+                    out.writeLong(Long.reverseBytes(\n+                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n+        int numWindowsAttributes = 0;\n+        for (final SevenZArchiveEntry entry : files) {\n+            if (entry.getHasWindowsAttributes()) {\n+                ++numWindowsAttributes;\n+            }\n+        }\n+        if (numWindowsAttributes > 0) {\n+            header.write(NID.kWinAttributes);\n+\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final DataOutputStream out = new DataOutputStream(baos);\n+            if (numWindowsAttributes != files.size()) {\n+                out.write(0);\n+                final BitSet attributes = new BitSet(files.size());\n+                for (int i = 0; i < files.size(); i++) {\n+                    attributes.set(i, files.get(i).getHasWindowsAttributes());\n+                }\n+                writeBits(out, attributes, files.size());\n+            } else {\n+                out.write(1);\n+            }\n+            out.write(0);\n+            for (final SevenZArchiveEntry entry : files) {\n+                if (entry.getHasWindowsAttributes()) {\n+                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n+                }\n+            }\n+            out.flush();\n+            final byte[] contents = baos.toByteArray();\n+            writeUint64(header, contents.length);\n+            header.write(contents);\n+        }\n+    }\n+\n+    private void writeUint64(final DataOutput header, long value) throws IOException {\n+        int firstByte = 0;\n+        int mask = 0x80;\n+        int i;\n+        for (i = 0; i < 8; i++) {\n+            if (value < ((1L << ( 7  * (i + 1))))) {\n+                firstByte |= (value >>> (8 * i));\n+                break;\n+            }\n+            firstByte |= mask;\n+            mask >>>= 1;\n+        }\n+        header.write(firstByte);\n+        for (; i > 0; i--) {\n+            header.write((int) (0xff & value));\n+            value >>>= 8;\n+        }\n+    }\n+\n+    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n+        int cache = 0;\n+        int shift = 7;\n+        for (int i = 0; i < length; i++) {\n+            cache |= ((bits.get(i) ? 1 : 0) << shift);\n+            --shift;\n+            if (shift == 0) {\n+                header.write(cache);\n+                shift = 7;\n+                cache = 0;\n+            }\n+        }\n+        if (length > 0 && shift > 0) {\n+            header.write(cache);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/SevenZTestCase.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry;\n+import org.apache.commons.compress.archivers.sevenz.SevenZFile;\n+import org.apache.commons.compress.archivers.sevenz.SevenZOutputFile;\n+\n+public class SevenZTestCase extends AbstractTestCase {\n+    public void testSevenZArchiveCreation() throws Exception {\n+        final File output = new File(dir, \"bla.7z\");\n+        final File file1 = getFile(\"test1.xml\");\n+        final File file2 = getFile(\"test2.xml\");\n+\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        try {\n+            SevenZArchiveEntry entry;\n+            \n+            entry = outArchive.createArchiveEntry(file1, file1.getName());\n+            outArchive.putArchiveEntry(entry);\n+            copy(file1, outArchive);\n+            outArchive.closeArchiveEntry();\n+            \n+            entry = outArchive.createArchiveEntry(file2, file2.getName());\n+            outArchive.putArchiveEntry(entry);\n+            copy(file2, outArchive);\n+            outArchive.closeArchiveEntry();\n+        } finally {\n+            outArchive.close();\n+        }\n+        \n+        final SevenZFile archive = new SevenZFile(output);\n+        try {\n+            SevenZArchiveEntry entry;\n+            \n+            entry = archive.getNextEntry();\n+            assert(entry != null);\n+            assertEquals(entry.getName(), file1.getName());\n+            \n+            entry = archive.getNextEntry();\n+            assert(entry != null);\n+            assertEquals(entry.getName(), file2.getName());\n+            \n+            assert(archive.getNextEntry() == null);\n+        } finally {\n+            archive.close();\n+        }\n+    }\n+    \n+    private void copy(final File src, final SevenZOutputFile dst) throws IOException { \n+        FileInputStream fis = null;\n+        try {\n+            fis = new FileInputStream(src);\n+            final byte[] buffer = new byte[8*1024];\n+            int bytesRead;\n+            while ((bytesRead = fis.read(buffer)) >= 0) {\n+                dst.write(buffer, 0, bytesRead);\n+            }\n+        } finally {\n+            if (fis != null) {\n+                fis.close();\n+            }\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n import javax.crypto.spec.SecretKeySpec;\n \n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n+import org.tukaani.xz.LZMAInputStream;\n import org.tukaani.xz.LZMA2InputStream;\n \n class Coders {\n     \n     static CoderId[] coderTable = new CoderId[] {\n         new CoderId(new byte[] { (byte)0x00 }, new CopyDecoder()),\n+        new CoderId(new byte[] { (byte)0x03, (byte)0x01, (byte)0x01 }, new LZMADecoder()),\n         new CoderId(new byte[] { (byte)0x21 }, new LZMA2Decoder()),\n         // FIXME: gives corrupt output\n         //new CoderId(new byte[] { (byte)0x04, (byte)0x01, (byte)0x08 }, new DeflateDecoder()),\n                 dictionarySize = (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n             }\n             return new LZMA2InputStream(in, dictionarySize);\n+        }\n+    }\n+    \n+    static class LZMADecoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException {\n+            byte propsByte = coder.properties[0];\n+            long dictSize = coder.properties[1];\n+            for (int i = 1; i < 4; i++) {\n+                dictSize |= (coder.properties[i + 1] << (8 * i));\n+            }\n+            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n+                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n+            }\n+            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n         }\n     }\n     \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n+import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n import org.apache.commons.compress.compressors.xz.XZUtils;\n      * @since 1.4\n      */\n     public static final String XZ = \"xz\";\n+\n+    /**\n+     * Constant used to identify the LZMA compression method.\n+     * @since 1.6\n+     */\n+    public static final String LZMA = \"lzma\";\n \n     private boolean decompressConcatenated = false;\n \n     /**\n      * Create a compressor input stream from a compressor name and an input stream.\n      * \n-     * @param name of the compressor, i.e. \"gz\", \"bzip2\", \"xz\", or \"pack200\"\n+     * @param name of the compressor, i.e. \"gz\", \"bzip2\", \"xz\", \"lzma\", or \"pack200\"\n      * @param in the input stream\n      * @return compressor input stream\n      * @throws CompressorException if the compressor name is not known\n \n             if (XZ.equalsIgnoreCase(name)) {\n                 return new XZCompressorInputStream(in);\n+            }\n+\n+            if (LZMA.equalsIgnoreCase(name)) {\n+                return new LZMACompressorInputStream(in);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lzma;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.tukaani.xz.LZMAInputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * LZMA decompressor.\n+ * @since 1.6\n+ */\n+public class LZMACompressorInputStream extends CompressorInputStream {\n+    private final InputStream in;\n+\n+    /**\n+     * Creates a new input stream that decompresses LZMA-compressed data\n+     * from the specified input stream.\n+     *\n+     * @param       inputStream where to read the compressed data\n+     *\n+     * @throws      IOException if the input is not in the .lzma format,\n+     *                          the input is corrupt or truncated, the .lzma\n+     *                          headers specify sizes that are not supported\n+     *                          by this implementation, or the underlying\n+     *                          <code>inputStream</code> throws an exception\n+     */\n+    public LZMACompressorInputStream(InputStream inputStream)\n+            throws IOException {\n+        in = new LZMAInputStream(inputStream);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        int ret = in.read();\n+        count(ret == -1 ? -1 : 1);\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        int ret = in.read(buf, off, len);\n+        count(ret);\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public long skip(long n) throws IOException {\n+        return in.skip(n);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() throws IOException {\n+        return in.available();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n import org.apache.commons.compress.AbstractTestCase;\n \n public class SevenZFileTest extends AbstractTestCase {\n+    private static String TEST2_CONTENT = \"<?xml version = '1.0'?>\\r\\n<!DOCTYPE\"\n+        + \" connections>\\r\\n<meinxml>\\r\\n\\t<leer />\\r\\n</meinxml>\\n\";\n+\n     public void testAllEmptyFilesArchive() throws Exception {\n         SevenZFile archive = new SevenZFile(getFile(\"7z-empty-mhc-off.7z\"));\n         try {\n \n     public void testHelloWorldHeaderCompressionOffLZMA2() throws Exception {\n         checkHelloWorld(\"7z-hello-mhc-off-lzma2.7z\");\n+    }\n+\n+    public void test7zUnarchive() throws Exception {\n+        SevenZFile sevenZFile = new SevenZFile(getFile(\"bla.7z\"));\n+        try {\n+            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n+            assertEquals(\"test1.xml\", entry.getName());\n+            entry = sevenZFile.getNextEntry();\n+            assertEquals(\"test2.xml\", entry.getName());\n+            byte[] contents = new byte[(int)entry.getSize()];\n+            int off = 0;\n+            while ((off < contents.length)) {\n+                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n+                assert(bytesRead >= 0);\n+                off += bytesRead;\n+            }\n+            assertEquals(TEST2_CONTENT, new String(contents, \"UTF-8\"));\n+            assertNull(sevenZFile.getNextEntry());\n+        } finally {\n+            sevenZFile.close();\n+        }\n     }\n \n     private void checkHelloWorld(final String filename) throws Exception {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class LZMATestCase extends AbstractTestCase {\n+\n+    public void testLZMAUnarchive() throws Exception {\n+        final File input = getFile(\"bla.tar.lzma\");\n+        final File output = new File(dir, \"bla.tar\");\n+        final InputStream is = new FileInputStream(input);\n+        try {\n+            final CompressorInputStream in = new LZMACompressorInputStream(is);\n+            FileOutputStream out = null;\n+            try {\n+                out = new FileOutputStream(output);\n+                IOUtils.copy(in, out);\n+            } finally {\n+                if (out != null) {\n+                    out.close();\n+                }\n+                in.close();\n+            }\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}", "timestamp": 1370967623, "metainfo": ""}