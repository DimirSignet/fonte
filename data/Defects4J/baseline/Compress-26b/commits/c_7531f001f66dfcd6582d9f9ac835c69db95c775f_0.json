{"sha": "7531f001f66dfcd6582d9f9ac835c69db95c775f", "log": "first piece of infrastructure for ZIP64 support, deal with numbers represented as eight bytes in big-endian order.  COMPRESS-36  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * Utility class that represents an eight byte integer with conversion\n+ * rules for the big endian byte order of ZIP files.\n+ * @Immutable\n+ */\n+public final class ZipEightByteInteger {\n+\n+    private static final int BYTE_MASK = 0xFF;\n+\n+    private static final int BYTE_1 = 1;\n+    private static final int BYTE_1_MASK = 0xFF00;\n+    private static final int BYTE_1_SHIFT = 8;\n+\n+    private static final int BYTE_2 = 2;\n+    private static final int BYTE_2_MASK = 0xFF0000;\n+    private static final int BYTE_2_SHIFT = 16;\n+\n+    private static final int BYTE_3 = 3;\n+    private static final long BYTE_3_MASK = 0xFF000000L;\n+    private static final int BYTE_3_SHIFT = 24;\n+\n+    private static final int BYTE_4 = 4;\n+    private static final long BYTE_4_MASK = 0xFF00000000L;\n+    private static final int BYTE_4_SHIFT = 32;\n+\n+    private static final int BYTE_5 = 5;\n+    private static final long BYTE_5_MASK = 0xFF0000000000L;\n+    private static final int BYTE_5_SHIFT = 40;\n+\n+    private static final int BYTE_6 = 6;\n+    private static final long BYTE_6_MASK = 0xFF000000000000L;\n+    private static final int BYTE_6_SHIFT = 48;\n+\n+    private static final int BYTE_7 = 7;\n+    private static final long BYTE_7_MASK = 0x7F00000000000000L;\n+    private static final int BYTE_7_SHIFT = 56;\n+\n+    private static final int LEFTMOST_BIT_SHIFT = 63;\n+    private static final byte LEFTMOST_BIT = (byte) 0x80;\n+\n+    private final BigInteger value;\n+\n+    /**\n+     * Create instance from a number.\n+     * @param value the long to store as a ZipEightByteInteger\n+     */\n+    public ZipEightByteInteger(long value) {\n+        this(BigInteger.valueOf(value));\n+    }\n+\n+    /**\n+     * Create instance from a number.\n+     * @param value the BigInteger to store as a ZipEightByteInteger\n+     */\n+    public ZipEightByteInteger(BigInteger value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Create instance from bytes.\n+     * @param bytes the bytes to store as a ZipEightByteInteger\n+     */\n+    public ZipEightByteInteger (byte[] bytes) {\n+        this(bytes, 0);\n+    }\n+\n+    /**\n+     * Create instance from the eight bytes starting at offset.\n+     * @param bytes the bytes to store as a ZipEightByteInteger\n+     * @param offset the offset to start\n+     */\n+    public ZipEightByteInteger (byte[] bytes, int offset) {\n+        value = ZipEightByteInteger.getValue(bytes, offset);\n+    }\n+\n+    /**\n+     * Get value as eight bytes in big endian byte order.\n+     * @return value as eight bytes in big endian order\n+     */\n+    public byte[] getBytes() {\n+        return ZipEightByteInteger.getBytes(value);\n+    }\n+\n+    /**\n+     * Get value as Java long.\n+     * @return value as a long\n+     */\n+    public long getLongValue() {\n+        return value.longValue();\n+    }\n+\n+    /**\n+     * Get value as Java long.\n+     * @return value as a long\n+     */\n+    public BigInteger getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Get value as eight bytes in big endian byte order.\n+     * @param value the value to convert\n+     * @return value as eight bytes in big endian byte order\n+     */\n+    public static byte[] getBytes(long value) {\n+        return getBytes(BigInteger.valueOf(value));\n+    }\n+\n+    /**\n+     * Get value as eight bytes in big endian byte order.\n+     * @param value the value to convert\n+     * @return value as eight bytes in big endian byte order\n+     */\n+    public static byte[] getBytes(BigInteger value) {\n+        byte[] result = new byte[8];\n+        long val = value.longValue();\n+        result[0] = (byte) ((val & BYTE_MASK));\n+        result[BYTE_1] = (byte) ((val & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        result[BYTE_2] = (byte) ((val & BYTE_2_MASK) >> BYTE_2_SHIFT);\n+        result[BYTE_3] = (byte) ((val & BYTE_3_MASK) >> BYTE_3_SHIFT);\n+        result[BYTE_4] = (byte) ((val & BYTE_4_MASK) >> BYTE_4_SHIFT);\n+        result[BYTE_5] = (byte) ((val & BYTE_5_MASK) >> BYTE_5_SHIFT);\n+        result[BYTE_6] = (byte) ((val & BYTE_6_MASK) >> BYTE_6_SHIFT);\n+        result[BYTE_7] = (byte) ((val & BYTE_7_MASK) >> BYTE_7_SHIFT);\n+        if (value.testBit(LEFTMOST_BIT_SHIFT)) {\n+            result[BYTE_7] |= LEFTMOST_BIT;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Helper method to get the value as a Java long from eight bytes\n+     * starting at given array offset\n+     * @param bytes the array of bytes\n+     * @param offset the offset to start\n+     * @return the corresponding Java long value\n+     */\n+    public static long getLongValue(byte[] bytes, int offset) {\n+        return getValue(bytes, offset).longValue();\n+    }\n+\n+    /**\n+     * Helper method to get the value as a Java BigInteger from eight\n+     * bytes starting at given array offset\n+     * @param bytes the array of bytes\n+     * @param offset the offset to start\n+     * @return the corresponding Java BigInteger value\n+     */\n+    public static BigInteger getValue(byte[] bytes, int offset) {\n+        long value = ((long) bytes[offset + BYTE_7] << BYTE_7_SHIFT) & BYTE_7_MASK;\n+        value += ((long) bytes[offset + BYTE_6] << BYTE_6_SHIFT) & BYTE_6_MASK;\n+        value += ((long) bytes[offset + BYTE_5] << BYTE_5_SHIFT) & BYTE_5_MASK;\n+        value += ((long) bytes[offset + BYTE_4] << BYTE_4_SHIFT) & BYTE_4_MASK;\n+        value += ((long) bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\n+        value += ((long) bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\n+        value += ((long) bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n+        value += ((long) bytes[offset] & BYTE_MASK);\n+        BigInteger val = BigInteger.valueOf(value);\n+        return (bytes[offset + BYTE_7] & LEFTMOST_BIT) == LEFTMOST_BIT\n+            ? val.setBit(LEFTMOST_BIT_SHIFT) : val;\n+    }\n+\n+    /**\n+     * Helper method to get the value as a Java long from an eight-byte array\n+     * @param bytes the array of bytes\n+     * @return the corresponding Java long value\n+     */\n+    public static long getLongValue(byte[] bytes) {\n+        return getLongValue(bytes, 0);\n+    }\n+\n+    /**\n+     * Helper method to get the value as a Java long from an eight-byte array\n+     * @param bytes the array of bytes\n+     * @return the corresponding Java BigInteger value\n+     */\n+    public static BigInteger getValue(byte[] bytes) {\n+        return getValue(bytes, 0);\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     * @param o an object to compare\n+     * @return true if the objects are equal\n+     */\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof ZipEightByteInteger)) {\n+            return false;\n+        }\n+        return value.equals(((ZipEightByteInteger) o).getValue());\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     * @return the hashCode of the value stored in the ZipEightByteInteger\n+     */\n+    public int hashCode() {\n+        return value.hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipEightByteIntegerTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.math.BigInteger;\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit 3 testcases for org.apache.commons.compress.archivers.zip.ZipEightByteInteger.\n+ *\n+ */\n+public class ZipEightByteIntegerTest extends TestCase {\n+\n+    public ZipEightByteIntegerTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testLongToBytes() {\n+        ZipEightByteInteger zl = new ZipEightByteInteger(0xAB12345678l);\n+        byte[] result = zl.getBytes();\n+        assertEquals(\"length getBytes\", 8, result.length);\n+        assertEquals(\"first byte getBytes\", 0x78, result[0]);\n+        assertEquals(\"second byte getBytes\", 0x56, result[1]);\n+        assertEquals(\"third byte getBytes\", 0x34, result[2]);\n+        assertEquals(\"fourth byte getBytes\", 0x12, result[3]);\n+        assertEquals(\"fifth byte getBytes\", (byte) 0xAB, result[4]);\n+        assertEquals(\"sixth byte getBytes\", 0, result[5]);\n+        assertEquals(\"seventh byte getBytes\", 0, result[6]);\n+        assertEquals(\"eighth byte getBytes\", 0, result[7]);\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testLongFromBytes() {\n+        byte[] val = new byte[] {0x78, 0x56, 0x34, 0x12, (byte) 0xAB, 0x00, 0x00, 0x00};\n+        ZipEightByteInteger zl = new ZipEightByteInteger(val);\n+        assertEquals(\"longValue from bytes\", 0xAB12345678l, zl.getLongValue());\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testBIToBytes() {\n+        ZipEightByteInteger zl =\n+            new ZipEightByteInteger(BigInteger.valueOf(Long.MAX_VALUE)\n+                                    .shiftLeft(1));\n+        byte[] result = zl.getBytes();\n+        assertEquals(\"length getBytes\", 8, result.length);\n+        assertEquals(\"first byte getBytes\", (byte) 0xFE, result[0]);\n+        assertEquals(\"second byte getBytes\", (byte) 0xFF, result[1]);\n+        assertEquals(\"third byte getBytes\", (byte) 0xFF, result[2]);\n+        assertEquals(\"fourth byte getBytes\", (byte) 0xFF, result[3]);\n+        assertEquals(\"fifth byte getBytes\", (byte) 0xFF, result[4]);\n+        assertEquals(\"sixth byte getBytes\", (byte) 0xFF, result[5]);\n+        assertEquals(\"seventh byte getBytes\", (byte) 0xFF, result[6]);\n+        assertEquals(\"eighth byte getBytes\", (byte) 0xFF, result[7]);\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testBIFromBytes() {\n+        byte[] val = new byte[] {(byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};\n+        ZipEightByteInteger zl = new ZipEightByteInteger(val);\n+        assertEquals(\"value from bytes\",\n+                     BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1),\n+                     zl.getValue());\n+    }\n+\n+    /**\n+     * Test the contract of the equals method.\n+     */\n+    public void testEquals() {\n+        ZipEightByteInteger zl = new ZipEightByteInteger(0x12345678);\n+        ZipEightByteInteger zl2 = new ZipEightByteInteger(0x12345678);\n+        ZipEightByteInteger zl3 = new ZipEightByteInteger(0x87654321);\n+\n+        assertTrue(\"reflexive\", zl.equals(zl));\n+\n+        assertTrue(\"works\", zl.equals(zl2));\n+        assertTrue(\"works, part two\", !zl.equals(zl3));\n+\n+        assertTrue(\"symmetric\", zl2.equals(zl));\n+\n+        assertTrue(\"null handling\", !zl.equals(null));\n+        assertTrue(\"non ZipEightByteInteger handling\", !zl.equals(new Integer(0x1234)));\n+    }\n+\n+    /**\n+     * Test sign handling.\n+     */\n+    public void testSign() {\n+        ZipEightByteInteger zl = new ZipEightByteInteger(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});\n+        assertEquals(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1).setBit(0),\n+                     zl.getValue());\n+    }\n+}", "timestamp": 1311237421, "metainfo": ""}