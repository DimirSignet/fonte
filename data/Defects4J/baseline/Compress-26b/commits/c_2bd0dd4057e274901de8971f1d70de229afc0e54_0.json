{"sha": "2bd0dd4057e274901de8971f1d70de229afc0e54", "log": "Normalize all @since tags to \"@since version\" instead of \"@since Apache Commons Compress version\"  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveEntry.java\n     /**\n      * The last modified date of the entry.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public Date getLastModifiedDate();\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n      * Doesn't increment if the EOF has been hit (read == -1)\n      * \n      * @param read the number of bytes read\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     protected void count(long read) {\n         if (read != -1) {\n      * Decrements the counter of already read bytes.\n      * \n      * @param pushedBack the number of bytes pushed back.\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     protected void pushedBackBytes(long pushedBack) {\n         bytesRead -= pushedBack;\n     /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public long getBytesRead() {\n         return bytesRead;\n      *\n      * <p>This implementation always returns true.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public boolean canReadEntryData(ArchiveEntry ae) {\n         return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n      * Doesn't increment if the EOF has been hit (read == -1)\n      * \n      * @param written the number of bytes written\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     protected void count(long written) {\n         if (written != -1) {\n     /**\n      * Returns the current number of bytes written to this stream.\n      * @return the number of written bytes\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public long getBytesWritten() {\n         return bytesWritten;\n      * not supported (yet).</p>\n      *\n      * <p>This implementation always returns true.\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public boolean canWriteEntryData(ArchiveEntry ae) {\n         return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n  * <p>The name of the archive must be given as a command line argument.</p>\n  * <p>The optional second argument defines the archive type, in case the format is not recognised.</p>\n  *\n- * @since Apache Commons Compress 1.1\n+ * @since 1.1\n  */\n public final class Lister {\n     private static final ArchiveStreamFactory factory = new ArchiveStreamFactory();\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n      *       the member.\n      * </pre>\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private static boolean isBSDLongName(String name) {\n         return name != null && name.matches(BSD_LONGNAME_PATTERN);\n      *\n      * @see #isBSDLongName\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private String getBSDLongName(String bsdLongName) throws IOException {\n         int nameLen =\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n      * This specifies the treatment of long file names (names >= 16).\n      * Default is LONGFILE_ERROR.\n      * @param longFileMode the mode to use\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     public void setLongFileMode(int longFileMode) {\n         this.longFileMode = longFileMode;\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public CpioArchiveEntry(final short format, final String name) {\n         this(format);\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public CpioArchiveEntry(final short format, final String name,\n                             final long size) {\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public CpioArchiveEntry(final short format, File inputFile,\n                             String entryName) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      * @param blockSize\n      *            The block size of the archive.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public CpioArchiveOutputStream(final OutputStream out, final short format,\n                                    final int blockSize) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n     /**\n      * The default block size.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     final int BLOCK_SIZE = 512;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      * @param preserveLeadingSlashes whether to allow leading slashes\n      * in the name.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n         this();\n      * \n      * @param link the link name to use.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public void setLinkName(String link) {\n         this.linkName = link;\n      * Get this entry's major device number.\n      *\n      * @return This entry's major device number.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public int getDevMajor() {\n         return devMajor;\n      *\n      * @param devNo This entry's major device number.\n      * @throws IllegalArgumentException if the devNo is &lt; 0.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public void setDevMajor(int devNo) {\n         if (devNo < 0){\n      * Get this entry's minor device number.\n      *\n      * @return This entry's minor device number.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public int getDevMinor() {\n         return devMinor;\n      *\n      * @param devNo This entry's minor device number.\n      * @throws IllegalArgumentException if the devNo is &lt; 0.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public void setDevMinor(int devNo) {\n         if (devNo < 0){\n      * \n      * @return {@code true} if this is a Pax header.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n+     * \n      */\n     public boolean isPaxHeader(){\n         return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n      * \n      * @return {@code true} if this is a Pax header.\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public boolean isGlobalPaxHeader(){\n         return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n     /**\n      * Check if this is a \"normal file\"\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isFile() {\n         if (file != null) {\n     /**\n      * Check if this is a symbolic link entry.\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isSymbolicLink() {\n         return linkFlag == LF_SYMLINK;\n     /**\n      * Check if this is a link entry.\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isLink() {\n         return linkFlag == LF_LINK;\n     /**\n      * Check if this is a character device entry.\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isCharacterDevice() {\n         return linkFlag == LF_CHR;\n     /**\n      * Check if this is a block device entry.\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isBlockDevice() {\n         return linkFlag == LF_BLK;\n     /**\n      * Check if this is a FIFO (pipe) entry.\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public boolean isFIFO() {\n         return linkFlag == LF_FIFO;\n      * @param starMode whether to use the star/GNU tar/BSD tar\n      * extension for numeric fields if their value doesn't fit in the\n      * maximum size of standard tar archives\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n                                  boolean starMode) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n      * This specifies the treatment of big files (sizes &gt; TarConstants.MAXSIZE) and other numeric values to big to fit into a traditional tar header.\n      * Default is BIGNUMBER_ERROR.\n      * @param bigNumberMode the mode to use\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public void setBigNumberMode(int bigNumberMode) {\n         this.bigNumberMode = bigNumberMode;\n \n     /**\n      * Whether to add a PAX extension header for non-ASCII file names.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n         addPaxHeadersForNonAsciiNames = b;\n \n     /**\n      * Writes a PAX extended header with the given map as contents.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     void writePaxHeaders(String entryName,\n                          Map<String, String> headers) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n \n     /**\n      * Sparse file type.\n-     * @since Apache Commons Compress 1.1.1\n+     * @since 1.1.1\n      */\n     byte LF_GNUTYPE_SPARSE = (byte) 'S';\n \n \n     /**\n      * Identifies the entry as a Pax extended header.\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     byte LF_PAX_EXTENDED_HEADER_LC = (byte) 'x';\n \n     /**\n      * Identifies the entry as a Pax extended header (SunOS tar -E).\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     byte LF_PAX_EXTENDED_HEADER_UC = (byte) 'X';\n \n     /**\n      * Identifies the entry as a Pax global extended header.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     byte LF_PAX_GLOBAL_EXTENDED_HEADER = (byte) 'g';\n \n     /**\n      * The magic tag representing an Ant tar archive.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     String MAGIC_ANT = \"ustar\\0\";\n \n     /**\n      * The \"version\" representing an Ant tar archive.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     // Does not appear to have a version, however Ant does write 8 bytes,\n     // so assume the version is 2 nulls\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * missing or an invalid byte is detected in an octal number, or\n      * if a binary number would exceed the size of a signed long\n      * 64-bit integer.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                           final int length) {\n      * @return The updated offset.\n      * @throws IllegalArgumentException if the value (and trailer)\n      * will not fit in the buffer.\n-     * @since Apache Commons Compress 1.4\n+     * @since 1.4\n      */\n     public static int formatLongOctalOrBinaryBytes(\n         final long value, byte[] buf, final int offset, final int length) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public static ZipExtraField[] parse(byte[] data, boolean local,\n                                         UnparseableExtraField onUnparseableData)\n      * \"enum\" for the possible actions to take if the extra field\n      * cannot be parsed.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public static final class UnparseableExtraField {\n         /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n /**\n  * Parser/encoder for the \"general purpose bit\" field in ZIP's local\n  * file and central directory headers.\n- * @since Apache Commons Compress 1.1\n+ * @since 1.1\n  * @NotThreadSafe\n  */\n public final class GeneralPurposeBit {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n  * APPNOTE.TXT</a>}).  Since it isn't used anywhere except to satisfy the\n  * ZipExtraField contract it shouldn't matter anyway.</p>\n  *\n- * @since Apache Commons Compress 1.1\n+ * @since 1.1\n  * @NotThreadSafe\n  */\n public final class UnparseableExtraFieldData implements ZipExtraField {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n  * <p>The implementation relies on data being read from the local file\n  * header and assumes that both size values are always present.</p>\n  *\n- * @since Apache Commons Compress 1.2\n+ * @since 1.2\n  * @NotThreadSafe\n  */\n public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n      *\n      * <p>Not used for anything else</p>\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private byte[] rawCentralDirectoryData;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64Mode.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64Mode.java\n  *\n  * @see ZipArchiveOutputStream#setUseZip64\n  *\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public enum Zip64Mode {\n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n  * Exception thrown when attempting to write data that requires Zip64\n  * support to an archive and {@link ZipArchiveOutputStream#setUseZip64\n  * UseZip64} has been set to {@link Zip64Mode#Never Never}.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public class Zip64RequiredException extends ZipException {\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      *\n      * @return compression method\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public int getMethod() {\n      *\n      * @param method compression method\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public void setMethod(int method) {\n      * exists.\n      * @return an array of the extra fields\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n         if (extraFields == null) {\n     /**\n      * Removes unparseable extra field data.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public void removeUnparseableExtraFieldData() {\n         if (unparseableExtra == null) {\n      *\n      * @return null if no such field exists.\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n         return unparseableExtra;\n      * the guessed or configured encoding\n      * @param rawName the bytes originally read as name from the\n      * archive\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     protected void setName(String name, byte[] rawName) {\n         setName(name);\n      * <p>This method will return null if this instance has not been\n      * read from an archive.</p>\n      *\n-     * @since Apache Commons Compress 1.2\n+     * @since 1.2\n      */\n     public byte[] getRawName() {\n         if (rawName != null) {\n \n     /**\n      * The \"general purpose bit\" field.\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public GeneralPurposeBit getGeneralPurposeBit() {\n         return gpb;\n \n     /**\n      * The \"general purpose bit\" field.\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public void setGeneralPurposeBit(GeneralPurposeBit b) {\n         gpb = b;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n      * Extra Fields (if present) to set the file names.\n      * @param allowStoredEntriesWithDataDescriptor whether the stream\n      * will try to read STORED entries that use a data descriptor\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public ZipArchiveInputStream(InputStream inputStream,\n                                  String encoding,\n      *\n      * <p>May return false if it is set up to use encryption or a\n      * compression method that hasn't been implemented yet.</p>\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public boolean canReadEntryData(ArchiveEntry ae) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     /**\n      * Whether anything inside this archive has used a ZIP64 feature.\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private boolean hasUsedZip64 = false;\n \n      * size and data is written to a non-seekable stream - in this\n      * case the default is {@link Zip64Mode#Never Never}.</p>\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     public void setUseZip64(Zip64Mode mode) {\n         zip64Mode = mode;\n      *\n      * <p>May return false if it is set up to use encryption or a\n      * compression method that hasn't been implemented yet.</p>\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public boolean canWriteEntryData(ArchiveEntry ae) {\n      * Writes the &quot;ZIP64 End of central dir record&quot; and\n      * &quot;ZIP64 End of central dir locator&quot;.\n      * @throws IOException on error\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     protected void writeZip64CentralDirectory() throws IOException {\n         if (zip64Mode == Zip64Mode.Never) {\n      * Get the existing ZIP64 extended information extra field or\n      * create a new one and add it to the entry.\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private Zip64ExtendedInformationExtraField\n         getZip64Extra(ZipArchiveEntry ze) {\n      * Is there a ZIP64 extended information extra field for the\n      * entry?\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private boolean hasZip64Extra(ZipArchiveEntry ze) {\n         return ze.getExtraField(Zip64ExtendedInformationExtraField\n      * unknown size that gets written to a non-seekable stream the\n      * change the default to Never.\n      *\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     private Zip64Mode getEffectiveZip64Mode(ZipArchiveEntry ze) {\n         if (zip64Mode != Zip64Mode.AsNeeded\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n /**\n  * Various constants used throughout the package.\n  *\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n final class ZipConstants {\n     private ZipConstants() { }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n  * rules for the big endian byte order of ZIP files.\n  * @Immutable\n  *\n- * @since Apache Commons Compress 1.2\n+ * @since 1.2\n  */\n public final class ZipEightByteInteger {\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      *\n      * <p>May return false if it is set up to use encryption or a\n      * compression method that hasn't been implemented yet.</p>\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public boolean canReadEntryData(ZipArchiveEntry ze) {\n         return ZipUtil.canHandleEntryData(ze);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n \n     /**\n      * Data Descriptor signature\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n \n     /**\n      * Value stored in size and similar fields if ZIP64 extensions are\n      * used.\n-     * @since Apache Commons Compress 1.3\n+     * @since 1.3\n      */\n     static final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n      * \n      * @param read the number of bytes read\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     protected void count(int read) {\n         count((long) read);\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public long getBytesRead() {\n         return bytesRead;\n--- a/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n /**\n  * File name mapping code for the compression formats.\n  * @ThreadSafe\n- * @since Apache Commons Compress 1.4\n+ * @since 1.4\n  */\n public class FileNameUtil {\n \n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n      *            the number of bytes to check\n      * @return true, if this stream is a bzip2 compressed stream, false otherwise\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public static boolean matches(byte[] signature, int length) {\n \n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n     /**\n      * {@inheritDoc}\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n      * @param length    the number of bytes to check\n      * @return          true if this is a .gz stream, false otherwise\n      *\n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     public static boolean matches(byte[] signature, int length) {\n \n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n     /**\n      * {@inheritDoc}\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public void write(byte[] b) throws IOException {\n     /**\n      * {@inheritDoc}\n      * \n-     * @since Apache Commons Compress 1.1\n+     * @since 1.1\n      */\n     @Override\n     public void write(byte[] b, int from, int length) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/InMemoryCachingStreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/InMemoryCachingStreamBridge.java\n /**\n  * StreamSwitcher that caches all data written to the output side in\n  * memory.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n class InMemoryCachingStreamBridge extends StreamBridge {\n     InMemoryCachingStreamBridge() {\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n  * return 0.</p>\n  *\n  * @NotThreadSafe\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public class Pack200CompressorInputStream extends CompressorInputStream {\n     private final InputStream originalInput;\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n  * An output stream that compresses using the Pack200 format.\n  * \n  * @NotThreadSafe\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public class Pack200CompressorOutputStream extends CompressorOutputStream {\n     private boolean finished = false;\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Strategy.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Strategy.java\n /**\n  * The different modes the Pack200 streams can use to wrap input and\n  * output.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public enum Pack200Strategy {\n     /** Cache output in memory */\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n  * Utility methods for Pack200.\n  *\n  * @ThreadSafe\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n public class Pack200Utils {\n     private Pack200Utils() { }\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n  * OutputStream.\n  *\n  * @ThreadSafe\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n abstract class StreamBridge extends FilterOutputStream {\n     private InputStream input;\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/TempFileCachingStreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/TempFileCachingStreamBridge.java\n /**\n  * StreamSwitcher that caches all data written to the output side in\n  * a temporary file.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  */\n class TempFileCachingStreamBridge extends StreamBridge {\n     private final File f;\n--- a/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n \n /**\n  * Stream that tracks the number of bytes read.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  * @NotThreadSafe\n  */\n public class CountingInputStream extends FilterInputStream {\n--- a/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n \n /**\n  * Stream that tracks the number of bytes read.\n- * @since Apache Commons Compress 1.3\n+ * @since 1.3\n  * @NotThreadSafe\n  */\n public class CountingOutputStream extends FilterOutputStream {", "timestamp": 1333285359, "metainfo": ""}